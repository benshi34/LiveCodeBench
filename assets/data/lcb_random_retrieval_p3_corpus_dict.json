{"1873_A": {"text": "", "problem_ids": []}, "1873_B": {"text": "", "problem_ids": []}, "1873_D": {"text": "", "problem_ids": []}, "1883_B": {"text": "", "problem_ids": []}, "1883_C": {"text": "", "problem_ids": []}, "1899_A": {"text": "", "problem_ids": []}, "1899_B": {"text": "", "problem_ids": []}, "1899_C": {"text": "", "problem_ids": []}, "1899_D": {"text": "", "problem_ids": []}, "2727": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.\nYour task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:\n\nabs(i - j) >= indexDifference, and\nabs(nums[i] - nums[j]) >= valueDifference\n\nReturn an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.\nNote: i and j may be equal.\n\u00a0\nExample 1:\n\nInput: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4\nOutput: [0,3]\nExplanation: In this example, i = 0 and j = 3 can be selected.\nabs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.\nHence, a valid answer is [0,3].\n[3,0] is also a valid answer.\n\nExample 2:\n\nInput: nums = [2,1], indexDifference = 0, valueDifference = 0\nOutput: [0,0]\nExplanation: In this example, i = 0 and j = 0 can be selected.\nabs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.\nHence, a valid answer is [0,0].\nOther valid answers are [0,1], [1,0], and [1,1].\n\nExample 3:\n\nInput: nums = [1,2,3], indexDifference = 2, valueDifference = 4\nOutput: [-1,-1]\nExplanation: In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.\nHence, [-1,-1] is returned.\n\u00a0\nConstraints:\n\n1 <= n == nums.length <= 100\n0 <= nums[i] <= 50\n0 <= indexDifference <= 100\n0 <= valueDifference <= 50 Explanation:\n\nSolution 1: Two Pointers + Maintaining Maximum and Minimum Values\nWe use two pointers $i$ and $j$ to maintain a sliding window with a gap of $indexDifference$, where $j$ and $i$ point to the left and right boundaries of the window, respectively. Initially, $i$ points to $indexDifference$, and $j` points to $0$.\nWe use $mi$ and $mx$ to maintain the indices of the minimum and maximum values to the left of pointer $j$.\nWhen pointer $i$ moves to the right, we need to update $mi$ and $mx$. If $nums[j] \\lt nums[mi]$, then $mi$ is updated to $j$; if $nums[j] \\gt nums[mx]$, then $mx$ is updated to $j$. After updating $mi$ and $mx$, we can determine whether we have found a pair of indices that satisfy the condition. If $nums[i] - nums[mi] \\ge valueDifference$, then we have found a pair of indices $[mi, i]$ that satisfy the condition; if $nums[mx] - nums[i] >= valueDifference$, then we have found a pair of indices $[mx, i]$ that satisfy the condition.\nIf pointer $i$ moves to the end of the array and we have not found a pair of indices that satisfy the condition, we return $[-1, -1]$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven the head of a linked list head, in which each node contains an integer value.\nBetween every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.\nReturn the linked list after insertion.\nThe greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.\n\u00a0\nExample 1:\n\n\nInput: head = [18,6,10,3]\nOutput: [18,6,6,2,10,1,3]\nExplanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).\n- We insert the greatest common divisor of 18 and 6 = 6 between the 1st and the 2nd nodes.\n- We insert the greatest common divisor of 6 and 10 = 2 between the 2nd and the 3rd nodes.\n- We insert the greatest common divisor of 10 and 3 = 1 between the 3rd and the 4th nodes.\nThere are no more adjacent nodes, so we return the linked list.\n\nExample 2:\n\n\nInput: head = [7]\nOutput: [7]\nExplanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes.\nThere are no pairs of adjacent nodes, so we return the initial linked list.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is in the range [1, 5000].\n1 <= Node.val <= 1000 Explanation:\n\nSolution 1: Simulation\nWe use two pointers $pre$ and $cur$ to point to the current node and the next node respectively. We only need to insert a new node between $pre$ and $cur$. Therefore, each time we calculate the greatest common divisor $x$ of $pre$ and $cur$, we insert a new node with value $x$ between $pre$ and $cur$. Then we update $pre = cur$ and $cur = cur.next$, and continue to traverse the linked list until $cur$ is null.\nThe time complexity is $O(n \\times \\log M)$, where $n$ is the length of the linked list, and $M$ is the maximum value of the nodes in the linked list. Ignoring the space consumption of the result linked list, the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n\u00a0\nExample 1:\n\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\n\nExample 2:\n\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\n\nExample 3:\n\nInput: s = \"\"\nOutput: 0\n\n\u00a0\nConstraints:\n\n0 <= s.length <= 3 * 104\ns[i] is '(', or ')'. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i]$ to be the length of the longest valid parentheses that ends with $s[i-1]$, and the answer is $max(f[i])$.\nWhen $i \\lt 2$, the length of the string is less than $2$, and there is no valid parentheses, so $f[i] = 0$.\nWhen $i \\ge 2$, we consider the length of the longest valid parentheses that ends with $s[i-1]$, that is, $f[i]$:\n\nIf $s[i-1]$ is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ must be $0$, so $f[i] = 0$.\nIf $s[i-1]$ is a right parenthesis, there are the following two cases:\nIf $s[i-2]$ is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-2] + 2$.\nIf $s[i-2]$ is a right parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-1] + 2$, but we also need to consider whether $s[i-f[i-1]-2]$ is a left parenthesis. If it is a left parenthesis, then the length of the longest valid parentheses that ends with $s[i-1]$ is $f[i-1] + 2 + f[i-f[i-1]-2]$.\n\n\n\nTherefore, we can get the state transition equation:\n$$\n\\begin{cases}\nf[i] = 0, & \\textit{if } s[i-1] = '(',\\\nf[i] = f[i-2] + 2, & \\textit{if } s[i-1] = ')' \\textit{ and } s[i-2] = '(',\\\nf[i] = f[i-1] + 2 + f[i-f[i-1]-2], & \\textit{if } s[i-1] = ')' \\textit{ and } s[i-2] = ')' \\textit{ and } s[i-f[i-1]-2] = '(',\\\n\\end{cases}\n$$\nFinally, we only need to return $max(f)$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string. \n\n", "problem_ids": ["find-indices-with-index-and-value-difference-i", "insert-greatest-common-divisors-in-linked-list", "longest-valid-parentheses"]}, "2728": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of integers, return the maximum sum for a non-empty\u00a0subarray (contiguous elements) with at most one element deletion.\u00a0In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the\u00a0sum of the remaining elements is maximum possible.\nNote that the subarray needs to be non-empty after deleting one element.\n\u00a0\nExample 1:\n\nInput: arr = [1,-2,0,3]\nOutput: 4\nExplanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.\nExample 2:\n\nInput: arr = [1,-2,-2,3]\nOutput: 3\nExplanation: We just choose [3] and it's the maximum sum.\n\nExample 3:\n\nInput: arr = [-1,-1,-1,-1]\nOutput: -1\nExplanation:\u00a0The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 105\n-104 <= arr[i] <= 104 Explanation:\n\nSolution 1: Preprocessing + Enumeration\nWe can preprocess the array $\\textit{arr}$ to find the maximum subarray sum ending and starting with each element, storing them in arrays $\\textit{left}$ and $\\textit{right}$, respectively.\nIf we do not delete any element, then the maximum subarray sum is the maximum value in $\\textit{left}[i]$ or $\\textit{right}[i]$; if we delete an element, we can enumerate each position $i$ in $[1..n-2]$, calculate the value of $\\textit{left}[i-1] + \\textit{right}[i+1]$, and take the maximum value.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $\\textit{arr}$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a m\u00a0* n\u00a0matrix seats\u00a0\u00a0that represent seats distributions\u00a0in a classroom.\u00a0If a seat\u00a0is\u00a0broken, it is denoted by '#' character otherwise it is denoted by a '.' character.\nStudents can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting\u00a0directly in front or behind him. Return the maximum number of students that can take the exam together\u00a0without any cheating being possible.\nStudents must be placed in seats in good condition.\n\u00a0\nExample 1:\n\n\nInput: seats = [[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n\u00a0               [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\n\u00a0               [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]\nOutput: 4\nExplanation: Teacher can place 4 students in available seats so they don't cheat on the exam. \n\nExample 2:\n\nInput: seats = [[\".\",\"#\"],\n\u00a0               [\"#\",\"#\"],\n\u00a0               [\"#\",\".\"],\n\u00a0               [\"#\",\"#\"],\n\u00a0               [\".\",\"#\"]]\nOutput: 3\nExplanation: Place all students in available seats. \n\n\nExample 3:\n\nInput: seats = [[\"#\",\".\",\".\",\".\",\"#\"],\n\u00a0               [\".\",\"#\",\".\",\"#\",\".\"],\n\u00a0               [\".\",\".\",\"#\",\".\",\".\"],\n\u00a0               [\".\",\"#\",\".\",\"#\",\".\"],\n\u00a0               [\"#\",\".\",\".\",\".\",\"#\"]]\nOutput: 10\nExplanation: Place students in available seats in column 1, 3 and 5.\n\n\u00a0\nConstraints:\n\nseats\u00a0contains only characters\u00a0'.'\u00a0and'#'.\nm ==\u00a0seats.length\nn ==\u00a0seats[i].length\n1 <= m <= 8\n1 <= n <= 8 Explanation:\n\nSolution 1: State Compression + Memoization Search\nWe notice that each seat has two states: selectable and non-selectable. Therefore, we can use a binary number to represent the seat state of each row, where $1$ represents selectable, and $0$ represents non-selectable. For example, for the first row in Example 1, we can represent it as $010010$. Therefore, we convert the initial seats into a one-dimensional array $ss$, where $ss[i]$ represents the seat state of the $i$th row.\nNext, we design a function $dfs(seat, i)$, which represents the maximum number of students that can be accommodated starting from the $i$th row, and the seat state of the current row is $seat$.\nWe can enumerate all the seat selection states $mask$ of the $i$th row, and judge whether $mask$ meets the following conditions:\n\nThe state $mask$ cannot select seats outside of $seat$;\nThe state $mask$ cannot select adjacent seats.\n\nIf the conditions are met, we calculate the number of seats selected in the current row $cnt$. If it is the last row, update the return value of the function, that is, $ans = \\max(ans, cnt)$. Otherwise, we continue to recursively solve the maximum number of the next row. The seat state of the next row is $nxt = ss[i + 1]$, and we need to exclude the left and right sides of the selected seats in the current row. Then we recursively solve the maximum number of the next row, that is, $ans = \\max(ans, cnt + dfs(nxt, i + 1))$.\nFinally, we return $ans$ as the return value of the function.\nTo avoid repeated calculations, we can use memoization search to save the return value of the function $dfs(seat, i)$ in a two-dimensional array $f$, where $f[seat][i]$ represents the maximum number of students that can be accommodated starting from the $i$th row, and the seat state of the current row is $seat$.\nThe time complexity is $O(4^n \\times n \\times m)$, and the space complexity is $O(2^n \\times m)$. Where $m$ and $n$ are the number of rows and columns of the seats, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\nGiven two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If the task is impossible, return -1.\n\u00a0\nExample 1:\n\nInput: source = \"abc\", target = \"abcbc\"\nOutput: 2\nExplanation: The target \"abcbc\" can be formed by \"abc\" and \"bc\", which are subsequences of source \"abc\".\n\nExample 2:\n\nInput: source = \"abc\", target = \"acdbc\"\nOutput: -1\nExplanation: The target string cannot be constructed from the subsequences of source string due to the character \"d\" in target string.\n\nExample 3:\n\nInput: source = \"xyz\", target = \"xzyxz\"\nOutput: 3\nExplanation: The target string can be constructed as follows \"xz\" + \"y\" + \"xz\".\n\n\u00a0\nConstraints:\n\n1 <= source.length, target.length <= 1000\nsource and target consist of lowercase English letters. Explanation:\n\nSolution 1: Two Pointers\nWe can use the two pointers method, where pointer $j$ points to the target string target. Then we traverse the source string source with pointer $i$ pointing to the source string source. If $source[i] = target[j]$, then both $i$ and $j$ move one step forward, otherwise only pointer $i$ moves. When both pointers $i$ and $j$ reach the end of the string, if no equal character is found, return $-1$, otherwise the subsequence count increases by one, and then set pointer $i$ to $0$ and continue to traverse.\nAfter the traversal ends, return the subsequence count.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the lengths of the strings source and target respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-subarray-sum-with-one-deletion", "maximum-students-taking-exam", "shortest-way-to-form-string"]}, "2730": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\nExample 2:\n\n\nInput: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).\n\nExample 3:\n\n\nInput: grid = [[1,2],[4,3]]\nOutput: 1\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4 Explanation:\n\nSolution 1: Double-ended Queue BFS\nThis problem is essentially a shortest path model, but what we are looking for is the minimum number of direction changes.\nIn an undirected graph where the edge weights are only 0 and 1, we can use a double-ended queue for BFS. The principle is that when the weight of the point that can be expanded currently is 0, it is added to the front of the queue; when the weight is 1, it is added to the end of the queue.\n\nIf the weight of an edge is 0, then the weight of the newly expanded node is the same as the weight of the current queue head node. Obviously, it can be used as the starting point for the next expansion. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.\n\u00a0\nExample 1:\n\nInput: n = 12, k = 3\nOutput: 3\nExplanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.\n\nExample 2:\n\nInput: n = 7, k = 2\nOutput: 7\nExplanation: Factors list is [1, 7], the 2nd factor is 7.\n\nExample 3:\n\nInput: n = 4, k = 4\nOutput: -1\nExplanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.\n\n\u00a0\nConstraints:\n\n1 <= k <= n <= 1000\n\n\u00a0\nFollow up:\nCould you solve this problem in less than O(n) complexity? Explanation:\n\nSolution 1: Brute Force Enumeration\nA \"factor\" is a number that can divide another number. Therefore, we only need to enumerate from $1$ to $n$, find all numbers that can divide $n$, and then return the $k$-th one.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nThe diameter of a tree is the number of edges in the longest path in that tree.\nThere is an undirected tree of n nodes labeled from 0 to n - 1. You are given a 2D array edges where edges.length == n - 1 and edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the tree.\nReturn the diameter of the tree.\n\u00a0\nExample 1:\n\n\nInput: edges = [[0,1],[0,2]]\nOutput: 2\nExplanation: The longest path of the tree is the path 1 - 0 - 2.\n\nExample 2:\n\n\nInput: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]\nOutput: 4\nExplanation: The longest path of the tree is the path 3 - 2 - 1 - 4 - 5.\n\n\u00a0\nConstraints:\n\nn == edges.length + 1\n1 <= n <= 104\n0 <= ai, bi < n\nai != bi Explanation:\n\nSolution 1: Two DFS Passes\nFirst, we arbitrarily select a node and start a depth-first search (DFS) from this node to find the farthest node from it, denoted as node $a$. Then, we start another DFS from node $a$ to find the farthest node from node $a$, denoted as node $b$. It can be proven that the path between node $a$ and node $b$ is the diameter of the tree.\nTime complexity is $O(n)$, and space complexity is $O(n)$, where $n$ is the number of nodes.\nSimilar problems:\n\n1522. Diameter of N-Ary Tree \ud83d\udd12 \n\n", "problem_ids": ["minimum-cost-to-make-at-least-one-valid-path-in-a-grid", "the-kth-factor-of-n", "tree-diameter"]}, "2754": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed string num of length n consisting of digits.\nReturn true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false.\n\u00a0\nExample 1:\n\nInput: num = \"1210\"\nOutput: true\nExplanation:\nnum[0] = '1'. The digit 0 occurs once in num.\nnum[1] = '2'. The digit 1 occurs twice in num.\nnum[2] = '1'. The digit 2 occurs once in num.\nnum[3] = '0'. The digit 3 occurs zero times in num.\nThe condition holds true for every index in \"1210\", so return true.\n\nExample 2:\n\nInput: num = \"030\"\nOutput: false\nExplanation:\nnum[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.\nnum[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.\nnum[2] = '0'. The digit 2 occurs zero times in num.\nThe indices 0 and 1 both violate the condition, so return false.\n\n\u00a0\nConstraints:\n\nn == num.length\n1 <= n <= 10\nnum consists of digits. Explanation:\n\nSolution 1: Counting + Enumeration\nWe can use an array $\\textit{cnt}$ of length $10$ to count the occurrences of each digit in the string $\\textit{num}$. Then, we enumerate each digit in the string $\\textit{num}$ and check if its occurrence count equals the digit itself. If this condition is satisfied for all digits, we return $\\text{true}$; otherwise, we return $\\text{false}$.\nThe time complexity is $O(n)$, and the space complexity is $O(|\\Sigma|)$. Here, $n$ is the length of the string $\\textit{num}$, and $|\\Sigma|$ is the range of possible digit values, which is $10$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nA node is good if all the subtrees rooted at its children have the same size.\nReturn the number of good nodes in the given tree.\nA subtree of treeName is a tree consisting of a node in treeName and all of its descendants.\n\u00a0\nExample 1:\n\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\nOutput: 7\nExplanation:\n\nAll of the nodes of the given tree are good.\n\nExample 2:\n\nInput: edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]\nOutput: 6\nExplanation:\n\nThere are 6 good nodes in the given tree. They are colored in the image above.\nExample 3:\n\nInput: edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]\nOutput: 12\nExplanation:\n\nAll nodes except node 9 are good.\n\n\n\u00a0\nConstraints:\n\n2 <= n <= 105\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nThe input is generated such that edges represents a valid tree. Explanation:\n\nSolution 1: DFS\nFirst, we construct the adjacency list $\\textit{g}$ of the tree based on the given edges $\\textit{edges}$, where $\\textit{g}[a]$ represents all the neighboring nodes of node $a$.\nNext, we design a function $\\textit{dfs}(a, \\textit{fa})$ to calculate the number of nodes in the subtree rooted at node $a$ and to accumulate the count of good nodes. Here, $\\textit{fa}$ represents the parent node of node $a$.\nThe execution process of the function $\\textit{dfs}(a, \\textit{fa})$ is as follows:\n\nInitialize variables $\\textit{pre} = -1$, $\\textit{cnt} = 1$, $\\textit{ok} = 1$, representing the number of nodes in a subtree of node $a$, the total number of nodes in all subtrees of node $a$, and whether node $a$ is a good node, respectively.\nTraverse all neighboring nodes $b$ of node $a$. If $b$ is not equal to $\\textit{fa}$, recursively call $\\textit{dfs}(b, a)$, with the return value being $\\textit{cur}$, and add $\\textit{cur}$ to $\\textit{cnt}$. If $\\textit{pre} < 0$, assign $\\textit{cur}$ to $\\textit{pre}$; otherwise, if $\\textit{pre}$ is not equal to $\\textit{cur}$, it means the number of nodes in different subtrees of node $a$ is different, and set $\\textit{ok}$ to $0$.\nFinally, add $\\textit{ok}$ to the answer and return $\\textit{cnt}$.\n\nIn the main function, we call $\\textit{dfs}(0, -1)$ and return the final answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ represents the number of nodes. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.\nThe elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\nReturn an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.\n\u00a0\nExample 1:\n\n\nInput: original = [1,2,3,4], m = 2, n = 2\nOutput: [[1,2],[3,4]]\nExplanation: The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n\nExample 2:\n\nInput: original = [1,2,3], m = 1, n = 3\nOutput: [[1,2,3]]\nExplanation: The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n\nExample 3:\n\nInput: original = [1,2], m = 1, n = 1\nOutput: []\nExplanation: There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.\n\n\u00a0\nConstraints:\n\n1 <= original.length <= 5 * 104\n1 <= original[i] <= 105\n1 <= m, n <= 4 * 104 Explanation:\n\nSolution 1: Simulation\nAccording to the problem description, we know that to construct an $m$-row and $n$-column two-dimensional array, it needs to satisfy that $m \\times n$ equals the length of the original array. If it does not satisfy, return an empty array directly.\nIf it does satisfy, we can follow the process described in the problem, and put the elements from the original array into the two-dimensional array in order.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the two-dimensional array, respectively. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["check-if-number-has-equal-digit-count-and-digit-value", "count-the-number-of-good-nodes", "convert-1d-array-into-2d-array"]}, "2755": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array nums consisting of positive integers.\nWe call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\nReturn the length of the longest nice subarray.\nA subarray is a contiguous part of an array.\nNote that subarrays of length 1 are always considered nice.\n\u00a0\nExample 1:\n\nInput: nums = [1,3,8,48,10]\nOutput: 3\nExplanation: The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:\n- 3 AND 8 = 0.\n- 3 AND 48 = 0.\n- 8 AND 48 = 0.\nIt can be proven that no longer nice subarray can be obtained, so we return 3.\nExample 2:\n\nInput: nums = [3,1,5,11,13]\nOutput: 1\nExplanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Two Pointers\nWe define a variable $mask$ to record the bitwise OR result of the elements in the current subarray, initially $mask = 0$. Also, we use two pointers $j$ and $i$ to point to the left and right endpoints of the current subarray, initially $i = j = 0$.\nNext, we traverse the array $nums$ from left to right. For each element $x$ we encounter:\nWe perform a bitwise AND operation between it and $mask$. If the result is not $0$, it means that $x$ and at least one element in $mask$ have a binary representation where a certain bit is $1$, and the corresponding bit in the other element's binary representation is $0$. Such pairs of elements cannot satisfy the problem's requirements, so we need to move $j$ to the right until the bitwise AND result of $x$ and $mask$ is $0$.\nAt this point, we have found a subarray that satisfies the problem's requirements. Its length is $i - j + 1$. We compare it with the length of the current longest elegant subarray. If it is longer than the current longest elegant subarray, we update the length of the longest elegant subarray.\nThen we perform a bitwise OR operation between $mask$ and $x$, and continue to the next element.\nFinally, the length of the longest elegant subarray we obtain is the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and an integer x.\nFind the minimum absolute difference between two elements in the array that are at least x indices apart.\nIn other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.\nReturn an integer denoting the minimum absolute difference between two elements that are at least x indices apart.\n\u00a0\nExample 1:\n\nInput: nums = [4,3,2,4], x = 2\nOutput: 0\nExplanation: We can select nums[0] = 4 and nums[3] = 4. \nThey are at least 2 indices apart, and their absolute difference is the minimum, 0. \nIt can be shown that 0 is the optimal answer.\n\nExample 2:\n\nInput: nums = [5,3,2,10,15], x = 1\nOutput: 1\nExplanation: We can select nums[1] = 3 and nums[2] = 2.\nThey are at least 1 index apart, and their absolute difference is the minimum, 1.\nIt can be shown that 1 is the optimal answer.\n\nExample 3:\n\nInput: nums = [1,2,3,4], x = 3\nOutput: 3\nExplanation: We can select nums[0] = 1 and nums[3] = 4.\nThey are at least 3 indices apart, and their absolute difference is the minimum, 3.\nIt can be shown that 3 is the optimal answer.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= x < nums.length Explanation:\n\nSolution 1: Ordered Set\nWe create an ordered set to store the elements whose distance to the current index is at least $x$.\nNext, we enumerate from index $i = x$, each time we add $nums[i - x]$ into the ordered set. Then we find the two elements in the ordered set which are closest to $nums[i]$, and the minimum absolute difference between them is the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of array $nums$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed 2D integer array nums representing the coordinates of the cars parking on a number line. For any index i, nums[i] = [starti, endi] where starti is the starting point of the ith car and endi is the ending point of the ith car.\nReturn the number of integer points on the line that are covered with any part of a car.\n\u00a0\nExample 1:\n\nInput: nums = [[3,6],[1,5],[4,7]]\nOutput: 7\nExplanation: All the points from 1 to 7 intersect at least one car, therefore the answer would be 7.\n\nExample 2:\n\nInput: nums = [[1,3],[5,8]]\nOutput: 7\nExplanation: Points intersecting at least one car are 1, 2, 3, 5, 6, 7, 8. There are a total of 7 points, therefore the answer would be 7.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100\nnums[i].length == 2\n1 <= starti\u00a0<= endi\u00a0<= 100 Explanation:\n\nSolution 1: Difference Array\nWe create a difference array $d$ of length $110$, then traverse the given array. For each interval $[a, b]$, we increase $d[a]$ by $1$ and decrease $d[b + 1]$ by $1$. Finally, we traverse the difference array $d$, calculate the prefix sum $s$ at each position. If $s > 0$, it means that the position is covered, and we increase the answer by $1$.\nThe time complexity is $O(n)$, and the space complexity is $O(M)$. Here, $n$ is the length of the given array, and $M$ is the maximum value in the array. \n\n", "problem_ids": ["longest-nice-subarray", "minimum-absolute-difference-between-elements-with-constraint", "points-that-intersect-with-cars"]}, "2756": {"text": "Similar Problem 1 \n\n Problem:\n\nThe imbalance number of a 0-indexed integer array arr of length n is defined as the number of indices in sarr = sorted(arr) such that:\n\n0 <= i < n - 1, and\nsarr[i+1] - sarr[i] > 1\n\nHere, sorted(arr) is the function that returns the sorted version of arr.\nGiven a 0-indexed integer array nums, return the sum of imbalance numbers of all its subarrays.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,1,4]\nOutput: 3\nExplanation: There are 3 subarrays with non-zero imbalance numbers:\n- Subarray [3, 1] with an imbalance number of 1.\n- Subarray [3, 1, 4] with an imbalance number of 1.\n- Subarray [1, 4] with an imbalance number of 1.\nThe imbalance number of all other subarrays is 0. Hence, the sum of imbalance numbers of all the subarrays of nums is 3. \n\nExample 2:\n\nInput: nums = [1,3,3,3,5]\nOutput: 8\nExplanation: There are 7 subarrays with non-zero imbalance numbers:\n- Subarray [1, 3] with an imbalance number of 1.\n- Subarray [1, 3, 3] with an imbalance number of 1.\n- Subarray [1, 3, 3, 3] with an imbalance number of 1.\n- Subarray [1, 3, 3, 3, 5] with an imbalance number of 2. \n- Subarray [3, 3, 3, 5] with an imbalance number of 1. \n- Subarray [3, 3, 5] with an imbalance number of 1.\n- Subarray [3, 5] with an imbalance number of 1.\nThe imbalance number of all other subarrays is 0. Hence, the sum of imbalance numbers of all the subarrays of nums is 8. \n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= nums.length Explanation:\n\nSolution 1: Enumeration + Ordered Set\nWe can first enumerate the left endpoint $i$ of the subarray. For each $i$, we enumerate the right endpoint $j$ of the subarray from small to large, and maintain all the elements in the current subarray with an ordered list. We also use a variable $cnt$ to maintain the unbalanced number of the current subarray.\nFor each number $nums[j]$, we find the first element $nums[k]$ in the ordered list that is greater than or equal to $nums[j]$, and the last element $nums[h]$ that is less than $nums[j]$:\n\nIf $nums[k]$ exists, and the difference between $nums[k]$ and $nums[j]$ is more than $1$, the unbalanced number increases by $1$;\nIf $nums[h]$ exists, and the difference between $nums[j]$ and $nums[h]$ is more than $1$, the unbalanced number increases by $1$;\nIf both $nums[k]$ and $nums[h]$ exist, then inserting the element $nums[j]$ between $nums[h]$ and $nums[k]$ will reduce the unbalanced number by $1$.\n\nThen, we add the unbalanced number of the current subarray to the answer, and continue the iteration until we finish iterating over all subarrays.\nThe time complexity is $O(n^2 \\times \\log n)$ and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere are n teams numbered from 0 to n - 1 in a tournament; each team is also a node in a DAG.\nYou are given the integer n and a 0-indexed 2D integer array edges of length m representing the DAG, where edges[i] = [ui, vi] indicates that there is a directed edge from team ui to team vi in the graph.\nA directed edge from a to b in the graph means that team a is stronger than team b and team b is weaker than team a.\nTeam a will be the champion of the tournament if there is no team b that is stronger than team a.\nReturn the team that will be the champion of the tournament if there is a unique champion, otherwise, return -1.\nNotes\n\nA cycle is a series of nodes a1, a2, ..., an, an+1 such that node a1 is the same node as node an+1, the nodes a1, a2, ..., an are distinct, and there is a directed edge from the node ai to node ai+1 for every i in the range [1, n].\nA DAG is a directed graph that does not have any cycle.\n\n\u00a0\nExample 1:\n\n\nInput: n = 3, edges = [[0,1],[1,2]]\nOutput: 0\nExplanation: Team 1 is weaker than team 0. Team 2 is weaker than team 1. So the champion is team 0.\n\nExample 2:\n\n\nInput: n = 4, edges = [[0,2],[1,3],[1,2]]\nOutput: -1\nExplanation: Team 2 is weaker than team 0 and team 1. Team 3 is weaker than team 1. But team 1 and team 0 are not weaker than any other teams. So the answer is -1.\n\n\u00a0\nConstraints:\n\n1 <= n <= 100\nm == edges.length\n0 <= m <= n * (n - 1) / 2\nedges[i].length == 2\n0 <= edge[i][j] <= n - 1\nedges[i][0] != edges[i][1]\nThe input is generated such that if team a is stronger than team b, team b is not stronger than team a.\nThe input is generated such that if team a is stronger than team b and team b is stronger than team c, then team a is stronger than team c. Explanation:\n\nSolution 1: Counting In-degrees\nBased on the problem description, we only need to count the in-degrees of each node and record them in an array $indeg$. If only one node has an in-degree of $0$, then this node is the champion; otherwise, there is no unique champion.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an array happiness of length n, and a positive integer k.\nThere are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.\nIn each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.\nReturn the maximum sum of the happiness values of the selected children you can achieve by selecting k children.\n\u00a0\nExample 1:\n\nInput: happiness = [1,2,3], k = 2\nOutput: 4\nExplanation: We can pick 2 children in the following way:\n- Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1].\n- Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. Note that the happiness value cannot become less than 0.\nThe sum of the happiness values of the selected children is 3 + 1 = 4.\n\nExample 2:\n\nInput: happiness = [1,1,1,1], k = 2\nOutput: 1\nExplanation: We can pick 2 children in the following way:\n- Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0].\n- Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0].\nThe sum of the happiness values of the selected children is 1 + 0 = 1.\n\nExample 3:\n\nInput: happiness = [2,3,4,5], k = 1\nOutput: 5\nExplanation: We can pick 1 child in the following way:\n- Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3].\nThe sum of the happiness values of the selected children is 5.\n\n\u00a0\nConstraints:\n\n1 <= n == happiness.length <= 2 * 105\n1 <= happiness[i] <= 108\n1 <= k <= n Explanation:\n\nSolution 1: Greedy + Sorting\nTo maximize the sum of happiness, we should prioritize choosing children with higher happiness values. Therefore, we can sort the children in descending order of happiness, and then select $k$ children in sequence. For the current $i$-th child, the happiness value that can be obtained is $\\max(happiness[i] - i, 0)$. Finally, we return the sum of the happiness values of these $k$ children.\nThe time complexity is $O(n \\times \\log n + k)$ and the space complexity is $O(\\log n)$, where $n$ is the length of the happiness array. \n\n", "problem_ids": ["sum-of-imbalance-numbers-of-all-subarrays", "find-champion-ii", "maximize-happiness-of-selected-children"]}, "2757": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.\n\u00a0\nExample 1:\nInput: nums = [3,2,3]\nOutput: 3\n\nExample 2:\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\n\u00a0\nConstraints:\n\nn == nums.length\n1 <= n <= 5 * 104\n-109 <= nums[i] <= 109\n\n\u00a0\nFollow-up: Could you solve the problem in linear time and in O(1) space? Explanation:\n\nSolution 1: Moore Voting Algorithm\nThe basic steps of the Moore voting algorithm are as follows:\nInitialize the element $m$ and initialize the counter $cnt = 0$. Then, for each element $x$ in the input list:\n\nIf $cnt = 0$, then $m = x$ and $cnt = 1$;\nOtherwise, if $m = x$, then $cnt = cnt + 1$, otherwise $cnt = cnt - 1$.\n\nIn general, the Moore voting algorithm requires two passes over the input list. In the first pass, we generate the candidate value $m$, and if there is a majority, the candidate value is the majority value. In the second pass, we simply compute the frequency of the candidate value to confirm whether it is the majority value. Since this problem has clearly stated that there is a majority value, we can directly return $m$ after the first pass, without the need for a second pass to confirm whether it is the majority value.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou have n bulbs in a row numbered from 1 to n. Initially, all the bulbs are turned off. We turn on exactly one bulb every day until all bulbs are on after n days.\nYou are given an array bulbs\u00a0of length n\u00a0where bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at position x\u00a0where\u00a0i\u00a0is\u00a00-indexed\u00a0and\u00a0x\u00a0is\u00a01-indexed.\nGiven an integer k, return\u00a0the minimum day number such that there exists two turned on bulbs that have exactly\u00a0k bulbs between them that are all turned off. If there isn't such day, return -1.\n\u00a0\nExample 1:\n\nInput: bulbs = [1,3,2], k = 1\nOutput: 2\nExplanation:\nOn the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]\nOn the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]\nOn the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]\nWe return 2 because on the second day, there were two on bulbs with one off bulb between them.\nExample 2:\n\nInput: bulbs = [1,2,3], k = 1\nOutput: -1\n\n\u00a0\nConstraints:\n\nn == bulbs.length\n1 <= n <= 2 * 104\n1 <= bulbs[i] <= n\nbulbs\u00a0is a permutation of numbers from\u00a01\u00a0to\u00a0n.\n0 <= k <= 2 * 104 Explanation:\n\nSolution 1: Binary Indexed Tree\nWe can use a Binary Indexed Tree to maintain the prefix sum of the bulbs. Every time we turn on a bulb, we update the corresponding position in the Binary Indexed Tree. Then we check if the $k$ bulbs to the left or right of the current bulb are all turned off and the $(k+1)$-th bulb is already turned on. If either of these conditions is met, we return the current day.\nThe time complexity is $O(n \\times \\log n)$ and the space complexity is $O(n)$, where $n$ is the number of bulbs. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a map of a server center, represented as a m * n integer matrix\u00a0grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.\n\nReturn the number of servers\u00a0that communicate with any other server.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,0],[0,1]]\nOutput: 0\nExplanation:\u00a0No servers can communicate with others.\nExample 2:\n\n\nInput: grid = [[1,0],[1,1]]\nOutput: 3\nExplanation:\u00a0All three servers can communicate with at least one other server.\n\nExample 3:\n\n\nInput: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]\nOutput: 4\nExplanation:\u00a0The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m <= 250\n1 <= n <= 250\ngrid[i][j] == 0 or 1 Explanation:\n\nSolution 1: Counting\nWe can count the number of servers in each row and each column, then traverse each server. If the number of servers in the current server's row or column exceeds $1$, it means the current server meets the condition, and we increment the result by $1$.\nAfter the traversal, we return the result.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m + n)$. Where $m$ and $n$ are the number of rows and columns in the matrix, respectively. \n\n", "problem_ids": ["majority-element", "k-empty-slots", "count-servers-that-communicate"]}, "2777": {"text": "Similar Problem 1 \n\n Problem:\n\nAlice and Bob are playing a game on a string.\nYou are given a string s, Alice and Bob will take turns playing the following game where Alice starts first:\n\nOn Alice's turn, she has to remove any non-empty substring from s that contains an odd number of vowels.\nOn Bob's turn, he has to remove any non-empty substring from s that contains an even number of vowels.\n\nThe first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play optimally.\nReturn true if Alice wins the game, and false otherwise.\nThe English vowels are: a, e, i, o, and u.\n\u00a0\nExample 1:\n\nInput: s = \"leetcoder\"\nOutput: true\nExplanation:\nAlice can win the game as follows:\n\nAlice plays first, she can delete the underlined substring in s = \"leetcoder\" which contains 3 vowels. The resulting string is s = \"der\".\nBob plays second, he can delete the underlined substring in s = \"der\" which contains 0 vowels. The resulting string is s = \"er\".\nAlice plays third, she can delete the whole string s = \"er\" which contains 1 vowel.\nBob plays fourth, since the string is empty, there is no valid play for Bob. So Alice wins the game.\n\n\nExample 2:\n\nInput: s = \"bbcd\"\nOutput: false\nExplanation:\nThere is no valid play for Alice in her first turn, so Alice loses the game.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists only of lowercase English letters. Explanation:\n\nSolution 1: Brain Teaser\nLet's denote the number of vowels in the string as $k$.\nIf $k = 0$, meaning there are no vowels in the string, then Little Red cannot remove any substring, and Little Ming wins directly.\nIf $k$ is odd, then Little Red can remove the entire string, resulting in a direct win for Little Red.\nIf $k$ is even, then Little Red can remove $k - 1$ vowels, leaving one vowel in the string. In this case, Little Ming cannot remove any substring, leading to a direct win for Little Red.\nIn conclusion, if the string contains vowels, then Little Red wins; otherwise, Little Ming wins.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two 0-indexed strings str1 and str2.\nIn an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'.\nReturn true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise.\nNote: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.\n\u00a0\nExample 1:\n\nInput: str1 = \"abc\", str2 = \"ad\"\nOutput: true\nExplanation: Select index 2 in str1.\nIncrement str1[2] to become 'd'. \nHence, str1 becomes \"abd\" and str2 is now a subsequence. Therefore, true is returned.\nExample 2:\n\nInput: str1 = \"zc\", str2 = \"ad\"\nOutput: true\nExplanation: Select indices 0 and 1 in str1. \nIncrement str1[0] to become 'a'. \nIncrement str1[1] to become 'd'. \nHence, str1 becomes \"ad\" and str2 is now a subsequence. Therefore, true is returned.\nExample 3:\n\nInput: str1 = \"ab\", str2 = \"d\"\nOutput: false\nExplanation: In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once. \nTherefore, false is returned.\n\u00a0\nConstraints:\n\n1 <= str1.length <= 105\n1 <= str2.length <= 105\nstr1 and str2 consist of only lowercase English letters. Explanation:\n\nSolution 1: Two Pointers\nThis problem actually requires us to determine whether a string $s$ is a subsequence of another string $t$. However, the characters do not have to match exactly. If two characters are the same, or one character is the next character of the other, they can match.\nThe time complexity is $O(m + n)$, where $m$ and $n$ are the lengths of the strings $str1$ and $str2$ respectively. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.\n\u00a0\nExample 1:\n\nInput: s = \"eceba\", k = 2\nOutput: 3\nExplanation: The substring is \"ece\" with length 3.\nExample 2:\n\nInput: s = \"aa\", k = 1\nOutput: 2\nExplanation: The substring is \"aa\" with length 2.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 5 * 104\n0 <= k <= 50 Explanation:\n\nSolution 1: Sliding Window + Hash Table\nWe can use the idea of a sliding window, with a hash table $\\textit{cnt}$ to record the occurrence count of each character within the window, and $\\textit{l}$ to denote the left boundary of the window.\nIterate through the string, adding the character at the right boundary to the hash table each time. If the number of distinct characters in the hash table exceeds $k$, remove the character at the left boundary from the hash table, then update the left boundary $\\textit{l}$.\nFinally, return the length of the string minus the length of the left boundary.\nThe time complexity is $O(n)$, and the space complexity is $O(k)$. Here, $n$ is the length of the string. \n\n", "problem_ids": ["vowels-game-in-a-string", "make-string-a-subsequence-using-cyclic-increments", "longest-substring-with-at-most-k-distinct-characters"]}, "2779": {"text": "Similar Problem 1 \n\n Problem:\n\nIn the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\" and use the dial to spell a specific keyword to open the door.\nGiven a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.\nInitially, the first character of the ring is aligned at the \"12:00\" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the \"12:00\" direction and then by pressing the center button.\nAt the stage of rotating the ring to spell the key character key[i]:\n\nYou can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the \"12:00\" direction, where this character must equal key[i].\nIf the character key[i] has been aligned at the \"12:00\" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\n\n\u00a0\nExample 1:\n\n\nInput: ring = \"godding\", key = \"gd\"\nOutput: 4\nExplanation:\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n\nExample 2:\n\nInput: ring = \"godding\", key = \"godding\"\nOutput: 13\n\n\u00a0\nConstraints:\n\n1 <= ring.length, key.length <= 100\nring and key consist of only lower case English letters.\nIt is guaranteed that key could always be spelled by rotating ring. Explanation:\n\nSolution 1: Dynamic Programming\nFirst, we preprocess the positions of each character $c$ in the string $ring$, and record them in the array $pos[c]$. Suppose the lengths of the strings $key$ and $ring$ are $m$ and $n$, respectively.\nThen we define $f[i][j]$ as the minimum number of steps to spell the first $i+1$ characters of the string $key$, and the $j$-th character of $ring$ is aligned with the $12:00$ direction. Initially, $f[i][j]=+\\infty$. The answer is $\\min_{0 \\leq j < n} f[m - 1][j]$.\nWe can first initialize $f[0][j]$, where $j$ is the position where the character $key[0]$ appears in $ring$. Since the $j$-th character of $ring$ is aligned with the $12:00$ direction, we only need $1$ step to spell $key[0]$. In addition, we need $min(j, n - j)$ steps to rotate $ring$ to the $12:00$ direction. Therefore, $f[0][j]=min(j, n - j) + 1$.\nNext, we consider how the state transitions when $i \\geq 1$. We can enumerate the position list $pos[key[i]]$ where $key[i]$ appears in $ring$, and enumerate the position list $pos[key[i-1]]$ where $key[i-1]$ appears in $ring$, and then update $f[i][j]$, i.e., $f[i][j]=\\min_{k \\in pos[key[i-1]]} f[i-1][k] + \\min(\\textit{abs}(j - k), n - \\textit{abs}(j - k)) + 1$.\nFinally, we return $\\min_{0 \\leq j \\lt n} f[m - 1][j]$.\nThe time complexity is $O(m \\times n^2)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the lengths of the strings $key$ and $ring$, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is a company with n branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads.\nThe company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches (possibly none). However, they want to ensure that the remaining branches have a distance of at most maxDistance from each other.\nThe distance between two branches is the minimum total traveled length needed to reach one branch from another.\nYou are given integers n, maxDistance, and a 0-indexed 2D array roads, where roads[i] = [ui, vi, wi] represents the undirected road between branches ui and vi with length wi.\nReturn the number of possible sets of closing branches, so that any branch has a distance of at most maxDistance from any other.\nNote that, after closing a branch, the company will no longer have access to any roads connected to it.\nNote that, multiple roads are allowed.\n\u00a0\nExample 1:\n\n\nInput: n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]\nOutput: 5\nExplanation: The possible sets of closing branches are:\n- The set [2], after closing, active branches are [0,1] and they are reachable to each other within distance 2.\n- The set [0,1], after closing, the active branch is [2].\n- The set [1,2], after closing, the active branch is [0].\n- The set [0,2], after closing, the active branch is [1].\n- The set [0,1,2], after closing, there are no active branches.\nIt can be proven, that there are only 5 possible sets of closing branches.\n\nExample 2:\n\n\nInput: n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]\nOutput: 7\nExplanation: The possible sets of closing branches are:\n- The set [], after closing, active branches are [0,1,2] and they are reachable to each other within distance 4.\n- The set [0], after closing, active branches are [1,2] and they are reachable to each other within distance 2.\n- The set [1], after closing, active branches are [0,2] and they are reachable to each other within distance 2.\n- The set [0,1], after closing, the active branch is [2].\n- The set [1,2], after closing, the active branch is [0].\n- The set [0,2], after closing, the active branch is [1].\n- The set [0,1,2], after closing, there are no active branches.\nIt can be proven, that there are only 7 possible sets of closing branches.\n\nExample 3:\n\nInput: n = 1, maxDistance = 10, roads = []\nOutput: 2\nExplanation: The possible sets of closing branches are:\n- The set [], after closing, the active branch is [0].\n- The set [0], after closing, there are no active branches.\nIt can be proven, that there are only 2 possible sets of closing branches.\n\n\u00a0\nConstraints:\n\n1 <= n <= 10\n1 <= maxDistance <= 105\n0 <= roads.length <= 1000\nroads[i].length == 3\n0 <= ui, vi <= n - 1\nui != vi\n1 <= wi <= 1000\nAll branches are reachable from each other by traveling some roads. Explanation:\n\nSolution 1: Binary Enumeration + Floyd Algorithm\nWe notice that $n \\leq 10$, so we might as well consider using the method of binary enumeration to enumerate all subsets of departments.\nFor each subset of departments, we can use the Floyd algorithm to calculate the shortest distance between the remaining departments, and then judge whether it meets the requirements of the problem. Specifically, we first enumerate the middle point $k$, then enumerate the starting point $i$ and the ending point $j$. If $g[i][k] + g[k][j] < g[i][j]$, then we update $g[i][j]$ with the shorter distance $g[i][k] + g[k][j]$.\nThe time complexity is $O(2^n \\times (n^3 + m))$, and the space complexity is $O(n^2)$. Here, $n$ and $m$ are the number of departments and the number of roads, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string.\nAn English letter b is greater than another letter a if b appears after a in the English alphabet.\n\u00a0\nExample 1:\n\nInput: s = \"lEeTcOdE\"\nOutput: \"E\"\nExplanation:\nThe letter 'E' is the only letter to appear in both lower and upper case.\n\nExample 2:\n\nInput: s = \"arRAzFif\"\nOutput: \"R\"\nExplanation:\nThe letter 'R' is the greatest letter to appear in both lower and upper case.\nNote that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'.\n\nExample 3:\n\nInput: s = \"AbCdEfGhIjK\"\nOutput: \"\"\nExplanation:\nThere is no letter that appears in both lower and upper case.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 1000\ns consists of lowercase and uppercase English letters. Explanation:\n\nSolution 1: Hash Table + Enumeration\nFirst, we use a hash table $ss$ to record all the letters that appear in the string $s$. Then we start enumerating from the last letter of the uppercase alphabet. If both the uppercase and lowercase forms of the current letter are in $ss$, we return that letter.\nAt the end of the enumeration, if no letter that meets the conditions is found, we return an empty string.\nThe time complexity is $O(n)$, and the space complexity is $O(C)$. Here, $n$ and $C$ are the length of the string $s$ and the size of the character set, respectively. \n\n", "problem_ids": ["freedom-trail", "number-of-possible-sets-of-closing-branches", "greatest-english-letter-in-upper-and-lower-case"]}, "2784": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\u00a0\nExample 1:\n\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\n\n\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\u00a0\nFollow-up: Can you solve the problem in O(1) extra memory space? Explanation:\n\nSolution 1: Iteration\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the linked list. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\n\u00a0\nExample 1:\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\nInput: numRows = 1\nOutput: [[1]]\n\n\u00a0\nConstraints:\n\n1 <= numRows <= 30 Explanation:\n\nSolution 1: Simulation\nFirst, we create an answer array $f$, and then set the first row of $f$ to $[1]$. Next, starting from the second row, the first and last elements of each row are $1$, and the other elements are calculated by $f[i][j] = f[i - 1][j - 1] + f[i - 1][j]$.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the number of rows. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\n\u00a0\nExample 1:\n\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= n <= 500\n-500 <= Node.val <= 500\n1 <= left <= right <= n\n\n\u00a0\nFollow up: Could you do it in one pass? Explanation:\n\nSolution 1: Simulation\nDefine a dummy head node dummy, pointing to the head node head of the linked list. Then define a pointer pre pointing to dummy. Start traversing the linked list from the dummy head node. When you traverse to the left node, point pre to this node. Then start traversing right - left + 1 times from this node, and insert the nodes you traverse into the back of pre. Finally, return dummy.next.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the linked list. \n\n", "problem_ids": ["reverse-nodes-in-k-group", "pascal's-triangle", "reverse-linked-list-ii"]}, "2785": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.\n\u00a0\nExample 1:\n\nInput: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\nOutput: 3\nExplanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).\n\nExample 2:\n\nInput: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\nOutput: 6\nExplanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 105\n1 <= arr[i] <= 104\n1 <= k <= arr.length\n0 <= threshold <= 104 Explanation:\n\nSolution 1: Sliding Window\nWe can multiply threshold by $k$, so that we can directly compare the sum within the window with threshold.\nWe maintain a sliding window of length $k$, and for each window, we calculate the sum $s$. If $s$ is greater than or equal to threshold, we increment the answer.\nThe time complexity is $O(n)$, where $n$ is the length of the array arr. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array rewardValues of length n, representing the values of rewards.\nInitially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:\n\nChoose an unmarked index i from the range [0, n - 1].\nIf rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.\n\nReturn an integer denoting the maximum total reward you can collect by performing the operations optimally.\n\u00a0\nExample 1:\n\nInput: rewardValues = [1,1,3,3]\nOutput: 4\nExplanation:\nDuring the operations, we can choose to mark the indices 0 and 2 in order, and the total reward will be 4, which is the maximum.\n\nExample 2:\n\nInput: rewardValues = [1,6,4,3,2]\nOutput: 11\nExplanation:\nMark the indices 0, 2, and 1 in order. The total reward will then be 11, which is the maximum.\n\n\u00a0\nConstraints:\n\n1 <= rewardValues.length <= 2000\n1 <= rewardValues[i] <= 2000 Explanation:\n\nSolution 1: Sorting + Memoization + Binary Search\nWe can sort the rewardValues array and then use memoization to solve for the maximum total reward.\nWe define a function $\\textit{dfs}(x)$, representing the maximum total reward that can be obtained when the current total reward is $x$. Thus, the answer is $\\textit{dfs}(0)$.\nThe execution process of the function $\\textit{dfs}(x)$ is as follows:\n\nPerform a binary search in the rewardValues array for the index $i$ of the first element greater than $x$;\nIterate over the elements in the rewardValues array starting from index $i$, and for each element $v$, calculate the maximum value of $v + \\textit{dfs}(x + v)$.\nReturn the result.\n\nTo avoid repeated calculations, we use a memoization array f to record the results that have already been computed.\nThe time complexity is $O(n \\times (\\log n + M))$, and the space complexity is $O(M)$. Where $n$ is the length of the rewardValues array, and $M$ is twice the maximum value in the rewardValues array. \n\nSimilar Problem 3 \n\n Problem:\n\nTable: Project\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| project_id  | int     |\n| employee_id | int     |\n| workload    | int     |\n+-------------+---------+\nemployee_id is the primary key (column with unique values) of this table.\nemployee_id is a foreign key (reference column) to Employee table.\nEach row of this table indicates that the employee with employee_id is working on the project with project_id and the workload of the project.\n\nTable: Employees\n\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| employee_id      | int     |\n| name             | varchar |\n| team             | varchar |\n+------------------+---------+\nemployee_id is the primary key (column with unique values) of this table.\nEach row of this table contains information about one employee.\n\nWrite a solution to find the employees who are allocated to projects with a workload that exceeds the average workload of all employees for their respective teams\nReturn the result table ordered by employee_id, project_id in ascending order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nProject table:\n+-------------+-------------+----------+\n| project_id  | employee_id | workload |\n+-------------+-------------+----------+\n| 1           | 1           |  45      |\n| 1           | 2           |  90      | \n| 2           | 3           |  12      |\n| 2           | 4           |  68      |\n+-------------+-------------+----------+\nEmployees table:\n+-------------+--------+------+\n| employee_id | name   | team |\n+-------------+--------+------+\n| 1           | Khaled | A    |\n| 2           | Ali    | B    |\n| 3           | John   | B    |\n| 4           | Doe    | A    |\n+-------------+--------+------+\nOutput: \n+-------------+------------+---------------+------------------+\n| employee_id | project_id | employee_name | project_workload |\n+-------------+------------+---------------+------------------+  \n| 2           | 1          | Ali           | 90               | \n| 4           | 2          | Doe           | 68               | \n+-------------+------------+---------------+------------------+\nExplanation: \n- Employee with ID 1 has a project workload of 45 and belongs to Team A, where the average workload is 56.50. Since his project workload does not exceed the team's average workload, he will be excluded.\n- Employee with ID 2 has a project workload of 90 and belongs to Team B, where the average workload is 51.00. Since his project workload does exceed the team's average workload, he will be included.\n- Employee with ID 3 has a project workload of 12 and belongs to Team B, where the average workload is 51.00. Since his project workload does not exceed the team's average workload, he will be excluded.\n- Employee with ID 4 has a project workload of 68 and belongs to Team A, where the average workload is 56.50. Since his project workload does exceed the team's average workload, he will be included.\nResult table orderd by employee_id, project_id in ascending order. Explanation:\n\nSolution 1: Grouping Statistics + Equi-Join\nFirst, we join the Project table and the Employees table based on employee_id, then group by team to calculate the average workload of each team, and record it in the temporary table T.\nThen, we join the Project table and the Employees table again, and also join the T table, to find employees whose workload is greater than the average workload of the team. Finally, we sort by employee_id and project_id.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nWITH\n    T AS (\n        SELECT team, AVG(workload) AS avg_workload\n        FROM\n            Project\n            JOIN Employees USING (employee_id)\n        GROUP BY 1\n    )\nSELECT\n    employee_id,\n    project_id,\n    name AS employee_name,\n    workload AS project_workload\nFROM\n    Project\n    JOIN Employees USING (employee_id)\n    JOIN T USING (team)\nWHERE workload > avg_workload\nORDER BY 1, 2;\n``` \n\n", "problem_ids": ["number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold", "maximum-total-reward-using-operations-i", "employees-project-allocation"]}, "2786": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 1-indexed array nums. Your task is to select a complete subset from nums where every pair of selected indices multiplied is a perfect square,. i. e. if you select ai and aj, i * j must be a perfect square.\nReturn the sum of the complete subset with the maximum sum.\n\u00a0\nExample 1:\n\nInput: nums = [8,7,3,5,7,2,4,9]\nOutput: 16\nExplanation:\nWe select elements at indices 2 and 8 and 2\u00a0* 8\u00a0is a perfect square.\n\nExample 2:\n\nInput: nums = [8,10,3,8,1,13,7,9,4]\nOutput: 20\nExplanation:\nWe select elements at indices 1, 4, and 9. 1 * 4, 1 * 9, 4 * 9 are perfect squares.\n\n\u00a0\nConstraints:\n\n1 <= n == nums.length <= 104\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Enumeration\nWe note that if a number can be expressed in the form of $k \\times j^2$, then all numbers of this form have the same $k$.\nTherefore, we can enumerate $k$ in the range $[1,..n]$, and then start enumerating $j$ from $1$, each time adding the value of $nums[k \\times j^2 - 1]$ to $t$, until $k \\times j^2 > n$. At this point, update the answer to $ans = \\max(ans, t)$.\nFinally, return the answer $ans$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two strings stamp and target. Initially, there is a string s of length target.length with all s[i] == '?'.\nIn one turn, you can place stamp over s and replace every letter in the s with the corresponding letter from stamp.\n\nFor example, if stamp = \"abc\" and target = \"abcba\", then s is \"?????\" initially. In one turn you can:\n\n    \nplace stamp at index 0 of s to obtain \"abc??\",\nplace stamp at index 1 of s to obtain \"?abc?\", or\nplace stamp at index 2 of s to obtain \"??abc\".\n\n    Note that stamp must be fully contained in the boundaries of s in order to stamp (i.e., you cannot place stamp at index 3 of s).\n\nWe want to convert s to target using at most 10 * target.length turns.\nReturn an array of the index of the left-most letter being stamped at each turn. If we cannot obtain target from s within 10 * target.length turns, return an empty array.\n\u00a0\nExample 1:\n\nInput: stamp = \"abc\", target = \"ababc\"\nOutput: [0,2]\nExplanation: Initially s = \"?????\".\n- Place stamp at index 0 to get \"abc??\".\n- Place stamp at index 2 to get \"ababc\".\n[1,0,2] would also be accepted as an answer, as well as some other answers.\n\nExample 2:\n\nInput: stamp = \"abca\", target = \"aabcaca\"\nOutput: [3,0,1]\nExplanation: Initially s = \"???????\".\n- Place stamp at index 3 to get \"???abca\".\n- Place stamp at index 0 to get \"abcabca\".\n- Place stamp at index 1 to get \"aabcaca\".\n\n\u00a0\nConstraints:\n\n1 <= stamp.length <= target.length <= 1000\nstamp and target consist of lowercase English letters. Explanation:\n\nSolution 1: Reverse Thinking + Topological Sorting\nIf we operate on the sequence in a forward manner, it would be quite complicated because subsequent operations would overwrite previous ones. Therefore, we consider operating on the sequence in a reverse manner, i.e., starting from the target string $target$ and considering the process of turning $target$ into $?????$.\nLet's denote the length of the stamp as $m$ and the length of the target string as $n$. If we operate on the target string with the stamp, there are $n-m+1$ starting positions where the stamp can be placed. We can enumerate these $n-m+1$ starting positions and use a method similar to topological sorting to operate in reverse.\nFirstly, we clarify that each starting position corresponds to a window of length $m$.\nNext, we define the following data structures or variables:\n\nIn-degree array $indeg$, where $indeg[i]$ represents how many characters in the $i$-th window are different from the characters in the stamp. Initially, $indeg[i]=m$. If $indeg[i]=0$, it means that all characters in the $i$-th window are the same as those in the stamp, and we can place the stamp in the $i$-th window.\nAdjacency list $g$, where $g[i]$ represents the set of all windows with different characters from the stamp on the $i$-th position of the target string $target$.\nQueue $q$, used to store the numbers of all windows with an in-degree of $0$.\nArray $vis$, used to mark whether each position of the target string $target$ has been covered.\nArray $ans$, used to store the answer.\n\nThen, we perform topological sorting. In each step of the topological sorting, we take out the window number $i$ at the head of the queue, and put $i$ into the answer array $ans$. Then, we enumerate each position $j$ in the stamp. If the $j$-th position in the $i$-th window has not been covered, we cover it and reduce the in-degree of all windows in the $indeg$ array that are the same as the $j$-th position in the $i$-th window by $1$. If the in-degree of a window becomes $0$, we put it into the queue $q$ for processing next time.\nAfter the topological sorting is over, if every position of the target string $target$ has been covered, then the answer array $ans$ stores the answer we are looking for. Otherwise, the target string $target$ cannot be covered, and we return an empty array.\nThe time complexity is $O(n \\times (n - m + 1))$, and the space complexity is $O(n \\times (n - m + 1))$. Here, $n$ and $m$ are the lengths of the target string $target$ and the stamp, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an array nums consisting of positive integers where all integers have the same number of digits.\nThe digit difference between two integers is the count of different digits that are in the same position in the two integers.\nReturn the sum of the digit differences between all pairs of integers in nums.\n\u00a0\nExample 1:\n\nInput: nums = [13,23,12]\nOutput: 4\nExplanation:\nWe have the following:\n- The digit difference between 13 and 23 is 1.\n- The digit difference between 13 and 12 is 1.\n- The digit difference between 23 and 12 is 2.\nSo the total sum of digit differences between all pairs of integers is 1 + 1 + 2 = 4.\n\nExample 2:\n\nInput: nums = [10,10,10,10]\nOutput: 0\nExplanation:\nAll the integers in the array are the same. So the total sum of digit differences between all pairs of integers will be 0.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 105\n1 <= nums[i] < 109\nAll integers in nums have the same number of digits. Explanation:\n\nSolution 1: Counting\nFirst, we get the number of digits $m$ in the array. Then for each digit, we count the occurrence of each number at this digit in the array nums, denoted as cnt. Therefore, the sum of the digit differences of all number pairs at this digit is:\n$$\n\\sum_{v \\in \\textit{cnt}} v \\times (n - v)\n$$\nwhere $n$ is the length of the array. We add up the digit differences of all digits and divide by $2$ to get the answer.\nThe time complexity is $O(n \\times m)$, and the space complexity is $O(C)$, where $n$ and $m$ are the length of the array and the number of digits in the numbers, respectively; and $C$ is a constant, in this problem $C = 10$. \n\n", "problem_ids": ["maximum-element-sum-of-a-complete-subset-of-indices", "stamping-the-sequence", "sum-of-digit-differences-of-all-pairs"]}, "2791": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string compressed representing a compressed version of a string. The format is a character followed by its frequency. For example, \"a3b1a1c2\" is a compressed version of the string \"aaabacc\".\nWe seek a better compression with the following conditions:\n\nEach character should appear only once in the compressed version.\nThe characters should be in alphabetical order.\n\nReturn the better compression of compressed.\nNote: In the better version of compression, the order of letters may change, which is acceptable.\n\u00a0\nExample 1:\n\nInput: compressed = \"a3c9b2c1\"\nOutput: \"a3b2c10\"\nExplanation:\nCharacters \"a\" and \"b\" appear only once in the input, but \"c\" appears twice, once with a size of 9 and once with a size of 1.\nHence, in the resulting string, it should have a size of 10.\n\nExample 2:\n\nInput: compressed = \"c2b3a1\"\nOutput: \"a1b3c2\"\n\nExample 3:\n\nInput: compressed = \"a2b4c1\"\nOutput: \"a2b4c1\"\n\n\u00a0\nConstraints:\n\n1 <= compressed.length <= 6 * 104\ncompressed consists only of lowercase English letters and digits.\ncompressed is a valid compression, i.e., each character is followed by its frequency.\nFrequencies are in the range [1, 104] and have no leading zeroes. Explanation:\n\nSolution 1: Hash Table + Two Pointers\nWe can use a hash table to count the frequency of each character, and then use two pointers to traverse the compressed string, adding the frequency of each character to the hash table. Finally, we concatenate the characters and frequencies into a string in alphabetical order.\nThe time complexity is $O(n + |\\Sigma| \\log |\\Sigma|)$, and the space complexity is $O(|\\Sigma|)$. Where $n$ is the length of the string compressed, and $|\\Sigma|$ is the size of the character set. Here, the character set is lowercase letters, so $|\\Sigma| = 26$. \n\nSimilar Problem 2 \n\n Problem:\n\nA sentence is a string of single-space separated words where each word consists only of lowercase letters.\nA word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\nGiven two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.\n\u00a0\nExample 1:\nInput: s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\nOutput: [\"sweet\",\"sour\"]\n\nExample 2:\nInput: s1 = \"apple apple\", s2 = \"banana\"\nOutput: [\"banana\"]\n\n\u00a0\nConstraints:\n\n1 <= s1.length, s2.length <= 200\ns1 and s2 consist of lowercase English letters and spaces.\ns1 and s2 do not have leading or trailing spaces.\nAll the words in s1 and s2 are separated by a single space. Explanation:\n\nSolution 1: Hash Table\nAccording to the problem description, as long as a word appears once, it meets the requirements of the problem. Therefore, we use a hash table cnt to record all words and their occurrence counts.\nThen we traverse the hash table, and take out all strings that appear only once.\nThe time complexity is $O(m + n)$, and the space complexity is $O(m + n)$. Here, $m$ and $n$ are the lengths of strings s1 and s2, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.\nBattleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).\n\u00a0\nExample 1:\n\n\nInput: board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\nOutput: 2\n\nExample 2:\n\nInput: board = [[\".\"]]\nOutput: 0\n\n\u00a0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 200\nboard[i][j] is either '.' or 'X'.\n\n\u00a0\nFollow up: Could you do it in one-pass, using only O(1) extra memory and without modifying the values board? Explanation:\n\nSolution 1: Direct Iteration\nWe can iterate through the matrix, find the top-left corner of each battleship, i.e., the position where the current position is X and both the top and left are not X, and increment the answer by one.\nAfter the iteration ends, return the answer.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["better-compression-of-string", "uncommon-words-from-two-sentences", "battleships-in-a-board"]}, "2792": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: Activity\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n(player_id, event_date) is the primary key (combination of columns with unique values) of this table.\nThis table shows the activity of players of some games.\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.\n\n\u00a0\nWrite a solution to find the first login date for each player.\nReturn the result table in any order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nActivity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-05-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\nOutput: \n+-----------+-------------+\n| player_id | first_login |\n+-----------+-------------+\n| 1         | 2016-03-01  |\n| 2         | 2017-06-25  |\n| 3         | 2016-03-02  |\n+-----------+-------------+ Explanation:\n\nSolution 1: Group By + Min Function\nWe can use GROUP BY to group the player_id and then take the minimum event_date in each group as the date when the player first logged into the platform. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array nums. In one operation, you can add or subtract 1 from any element of nums.\nReturn the minimum number of operations to make all elements of nums divisible by 3.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation:\nAll array elements can be made divisible by 3 using 3 operations:\n\nSubtract 1 from 1.\nAdd 1 to 2.\nSubtract 1 from 4.\n\n\nExample 2:\n\nInput: nums = [3,6,9]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Mathematics\nWe directly iterate through the array $\\textit{nums}$. For each element $x$, we calculate the remainder of $x$ divided by 3, $x \\bmod 3$. If the remainder is not 0, we need to make $x$ divisible by 3 with the minimum number of operations. Therefore, we can choose to either decrease $x$ by $x \\bmod 3$ or increase $x$ by $3 - x \\bmod 3$, and we accumulate the minimum of these two values to the answer.\nThe time complexity is $O(n)$, where $n$ is the length of the array $\\textit{nums}$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nIn LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\nYou are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy.\nYou are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer.\nReturn the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.\n\u00a0\nExample 1:\n\nInput: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\nOutput: 14\nExplanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n\nExample 2:\n\nInput: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\nOutput: 11\nExplanation: The price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n\n\u00a0\nConstraints:\n\nn == price.length == needs.length\n1 <= n <= 6\n0 <= price[i], needs[i] <= 10\n1 <= special.length <= 100\nspecial[i].length == n + 1\n0 <= special[i][j] <= 50\nThe input is generated that at least one of special[i][j] is non-zero for 0 <= j <= n - 1. Explanation:\n\nSolution 1: State Compression + Memoization Search\nWe notice that the number of types of items $n \\leq 6$ in the problem, and the quantity of each item needed does not exceed $10$. We can use $4$ binary bits to represent the quantity of each item needed. Thus, we only need at most $6 \\times 4 = 24$ binary bits to represent the entire shopping list.\nFirst, we convert the shopping list $\\textit{needs}$ into an integer $\\textit{mask}$, where the quantity of the $i$-th item needed is stored in the $i \\times 4$ to $(i + 1) \\times 4 - 1$ bits of $\\textit{mask}$. For example, when $\\textit{needs} = [1, 2, 1]$, we have $\\textit{mask} = 0b0001 0010 0001$.\nThen, we design a function $\\textit{dfs}(cur)$, representing the minimum amount of money we need to spend when the current state of the shopping list is $\\textit{cur}$. Therefore, the answer is $\\textit{dfs}(\\textit{mask})$.\nThe calculation method of the function $\\textit{dfs}(cur)$ is as follows:\n\nFirst, we calculate the cost of the current shopping list $\\textit{cur}$ without using any bundles, denoted as $\\textit{ans}$.\nThen, we iterate through each bundle $\\textit{offer}$. If the current shopping list $\\textit{cur}$ can use the bundle $\\textit{offer}$, i.e., the quantity of each item in $\\textit{cur}$ is not less than that in the bundle $\\textit{offer}$, then we can try to use this bundle. We subtract the quantity of each item in the bundle $\\textit{offer}$ from $\\textit{cur}$, obtaining a new shopping list $\\textit{nxt}$, then recursively calculate the minimum cost of $\\textit{nxt}$ and add the price of the bundle $\\textit{offer}[n]$, updating $\\textit{ans}$, i.e., $\\textit{ans} = \\min(\\textit{ans}, \\textit{offer}[n] + \\textit{dfs}(\\textit{nxt}))$.\nFinally, return $\\textit{ans}$.\n\nTo avoid repeated calculations, we use a hash table $\\textit{f}$ to record the minimum cost corresponding to each state $\\textit{cur}$.\nThe time complexity is $O(n \\times k \\times m^n)$, where $n$ represents the types of items, and $k$ and $m$ respectively represent the number of bundles and the maximum demand for each type of item. The space complexity is $O(n \\times m^n)$. \n\n", "problem_ids": ["game-play-analysis-i", "find-minimum-operations-to-make-all-elements-divisible-by-three", "shopping-offers"]}, "2800": {"text": "Similar Problem 1 \n\n Problem:\n\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n\u00a0\nExample 1:\n\n\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 104].\n-1000 <= Node.val <= 1000 Explanation:\n\nSolution 1: Level Order Traversal\nWe can use level order traversal to serialize the binary tree. Starting from the root node, we add the nodes of the binary tree to the queue in the order from top to bottom, from left to right. Then we dequeue the nodes in the queue one by one. If the node is not null, we add its value to the serialized string; otherwise, we add a special character #. Finally, we return the serialized string.\nDuring deserialization, we split the serialized string by the delimiter to get a string array, and then add the elements in the string array to the queue in order. The elements in the queue are the nodes of the binary tree. We dequeue the elements from the queue one by one. If the element is not #, we convert it to an integer and use it as the value of the node, and then add the node to the queue; otherwise, we set it to null. Finally, we return the root node.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the binary tree. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., \u221a(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\n\u00a0\nExample 1:\n\n\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\nExample 2:\n\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n\n\u00a0\nConstraints:\n\n1 <= k <= points.length <= 104\n-104 <= xi, yi <= 104 Explanation:\n\nSolution 1: Custom Sorting\nWe sort all points by their distance from the origin in ascending order, and then take the first $k$ points.\nThe time complexity is $O(n \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of the array $\\textit{points}$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.\nTo separate the digits of an integer is to get all the digits it has in the same order.\n\nFor example, for the integer 10921, the separation of its digits is [1,0,9,2,1].\n\n\u00a0\nExample 1:\n\nInput: nums = [13,25,83,77]\nOutput: [1,3,2,5,8,3,7,7]\nExplanation: \n- The separation of 13 is [1,3].\n- The separation of 25 is [2,5].\n- The separation of 83 is [8,3].\n- The separation of 77 is [7,7].\nanswer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.\n\nExample 2:\n\nInput: nums = [7,1,3,9]\nOutput: [7,1,3,9]\nExplanation: The separation of each integer in nums is itself.\nanswer = [7,1,3,9].\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 105 Explanation:\n\nSolution 1: Simulation\nSplit each number in the array into digits, then put the split numbers into the answer array in order.\nThe time complexity is $O(n \\times \\log_{10} M)$, and the space complexity is $O(n \\times \\log_{10} M)$. Where $n$ is the length of the array $nums$, and $M$ is the maximum value in the array $nums$. \n\n", "problem_ids": ["serialize-and-deserialize-binary-tree", "k-closest-points-to-origin", "separate-the-digits-in-an-array"]}, "2802": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\n\nFor example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\nReturn the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.\n\u00a0\nExample 1:\n\n\nInput: root = [1,2,3]\nOutput: 25\nExplanation:\nThe root-to-leaf path 1->2 represents the number 12.\nThe root-to-leaf path 1->3 represents the number 13.\nTherefore, sum = 12 + 13 = 25.\n\nExample 2:\n\n\nInput: root = [4,9,0,5,1]\nOutput: 1026\nExplanation:\nThe root-to-leaf path 4->9->5 represents the number 495.\nThe root-to-leaf path 4->9->1 represents the number 491.\nThe root-to-leaf path 4->0 represents the number 40.\nTherefore, sum = 495 + 491 + 40 = 1026.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\n0 <= Node.val <= 9\nThe depth of the tree will not exceed 10. Explanation:\n\nSolution 1: DFS\nWe can design a function $dfs(root, s)$, which represents the sum of all path numbers from the current node $root$ to the leaf nodes, given that the current path number is $s$. The answer is $dfs(root, 0)$.\nThe calculation of the function $dfs(root, s)$ is as follows:\n\nIf the current node $root$ is null, return $0$.\nOtherwise, add the value of the current node to $s$, i.e., $s = s \\times 10 + root.val$.\nIf the current node is a leaf node, return $s$.\nOtherwise, return $dfs(root.left, s) + dfs(root.right, s)$.\n\nThe time complexity is $O(n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the number of nodes in the binary tree. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\npref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\nIt can be proven that the answer is unique.\n\u00a0\nExample 1:\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\nExample 2:\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\u00a0\nConstraints:\n\n1 <= pref.length <= 105\n0 <= pref[i] <= 106 Explanation:\n\nSolution 1: Bit Manipulation\nAccording to the problem statement, we have equation one:\n$$\npref[i]=arr[0] \\oplus arr[1] \\oplus \\cdots \\oplus arr[i]\n$$\nSo, we also have equation two:\n$$\npref[i-1]=arr[0] \\oplus arr[1] \\oplus \\cdots \\oplus arr[i-1]\n$$\nWe perform a bitwise XOR operation on equations one and two, and get:\n$$\npref[i] \\oplus pref[i-1]=arr[i]\n$$\nThat is, each item in the answer array is obtained by performing a bitwise XOR operation on the adjacent two items in the prefix XOR array.\nThe time complexity is $O(n)$, where $n$ is the length of the prefix XOR array. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and a positive integer k.\nYou can apply the following operation on the array any number of times:\n\nChoose any subarray of size k from the array and decrease all its elements by 1.\n\nReturn true if you can make all the array elements equal to 0, or false otherwise.\nA subarray is a contiguous non-empty part of an array.\n\u00a0\nExample 1:\n\nInput: nums = [2,2,3,1,1,0], k = 3\nOutput: true\nExplanation: We can do the following operations:\n- Choose the subarray [2,2,3]. The resulting array will be nums = [1,1,2,1,1,0].\n- Choose the subarray [2,1,1]. The resulting array will be nums = [1,1,1,0,0,0].\n- Choose the subarray [1,1,1]. The resulting array will be nums = [0,0,0,0,0,0].\n\nExample 2:\n\nInput: nums = [1,3,1,1], k = 2\nOutput: false\nExplanation: It is not possible to make all the array elements equal to 0.\n\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 105\n0 <= nums[i] <= 106 Explanation:\n\nSolution 1: Difference Array + Prefix Sum\nFirst, let's consider the first element of $nums$, $nums[0]$:\n\nIf $nums[0] = 0$, we don't need to do anything.\nIf $nums[0] > 0$, we need to operate on $nums[0..k-1]$ for $nums[0]$ times, subtracting $nums[0]$ from all elements in $nums[0..k-1]$, so $nums[0]$ becomes $0$.\n\nTo perform the add and subtract operations on a contiguous segment of elements simultaneously, we can use a difference array to manage these operations. We represent the difference array with $d[i]$, and calculating the prefix sum of the difference array gives us the change of the value at each position.\nTherefore, we iterate over $nums$. For each element $nums[i]$, the current position's change quantity is $s = \\sum_{j=0}^{i} d[j]$. We add $s$ to $nums[i]$ to get the actual value of $nums[i]$.\n\nIf $nums[i] = 0$, there's no need for any operation, and we can skip directly.\nIf $nums[i]=0$ or $i + k > n$, it indicates that after the previous operations, $nums[i]$ has become negative, or $nums[i..i+k-1]$ is out of bounds. Therefore, it's impossible to make all elements in $nums$ equal to $0$. We return false. Otherwise, we need to subtract $nums[i]$ from all elements in the interval $[i..i+k-1]$. Therefore, we subtract $nums[i]$ from $s$ and add $nums[i]$ to $d[i+k]$.\nWe continue to iterate over the next element.\n\nIf the iteration ends, it means that all elements in $nums$ can be made equal to $0$, so we return true.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["sum-root-to-leaf-numbers", "find-the-original-array-of-prefix-xor", "apply-operations-to-make-all-array-elements-equal-to-zero"]}, "2808": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a balanced parentheses string s, return the score of the string.\nThe score of a balanced parentheses string is based on the following rule:\n\n\"()\" has score 1.\nAB has score A + B, where A and B are balanced parentheses strings.\n(A) has score 2 * A, where A is a balanced parentheses string.\n\n\u00a0\nExample 1:\n\nInput: s = \"()\"\nOutput: 1\n\nExample 2:\n\nInput: s = \"(())\"\nOutput: 2\n\nExample 3:\n\nInput: s = \"()()\"\nOutput: 2\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 50\ns consists of only '(' and ')'.\ns is a balanced parentheses string. Explanation:\n\nSolution 1: Counting\nBy observing, we find that () is the only structure that contributes to the score, and the outer parentheses just add some multipliers to this structure. So, we only need to focus on ().\nWe use $d$ to maintain the current depth of parentheses. For each (, we increase the depth by one, and for each ), we decrease the depth by one. When we encounter (), we add $2^d$ to the answer.\nLet's take (()(())) as an example. We first find the two closed parentheses () inside, and then add the corresponding $2^d$ to the score. In fact, we are calculating the score of (()) + ((())).\n```bash\n( ( ) ( ( ) ) )\n  ^ ^   ^ ^\n( ( ) ) + ( ( ( ) ) )\n  ^ ^         ^ ^\n```\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the string.\nRelated problems about parentheses:\n\n678. Valid Parenthesis String\n1021. Remove Outermost Parentheses\n1096. Brace Expansion II\n1249. Minimum Remove to Make Valid Parentheses\n1541. Minimum Insertions to Balance a Parentheses String\n2116. Check if a Parentheses String Can Be Valid \n\nSimilar Problem 2 \n\n Problem:\n\nYou have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.\nReturn true if the edges of the given graph make up a valid tree, and false otherwise.\n\u00a0\nExample 1:\n\n\nInput: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]\nOutput: true\n\nExample 2:\n\n\nInput: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]\nOutput: false\n\n\u00a0\nConstraints:\n\n1 <= n <= 2000\n0 <= edges.length <= 5000\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nThere are no self-loops or repeated edges. Explanation:\n\nSolution 1: Union-Find\nTo determine whether it is a tree, the following two conditions must be met:\n\nThe number of edges is equal to the number of nodes minus one;\nThere is no cycle.\n\nWe can use a union-find set to determine whether there is a cycle. We traverse the edges, if two nodes are already in the same set, it means there is a cycle. Otherwise, we merge the two nodes into the same set. Then we decrease the number of connected components by one, and finally check whether the number of connected components is $1$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$, where $n$ is the number of nodes. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum.\nReturn the sum of the k integers appended to nums.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,25,10,25], k = 2\nOutput: 5\nExplanation: The two unique positive integers that do not appear in nums which we append are 2 and 3.\nThe resulting sum of nums is 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum.\nThe sum of the two integers appended is 2 + 3 = 5, so we return 5.\nExample 2:\n\nInput: nums = [5,6], k = 6\nOutput: 25\nExplanation: The six unique positive integers that do not appear in nums which we append are 1, 2, 3, 4, 7, and 8.\nThe resulting sum of nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the minimum. \nThe sum of the six integers appended is 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= k <= 108 Explanation:\n\nSolution 1: Sorting + Greedy + Mathematics\nWe can add two sentinel nodes to the array, which are $0$ and $2 \\times 10^9$.\nThen we sort the array. For any two adjacent elements $a$ and $b$ in the array, the integers in the interval $[a+1, b-1]$ do not appear in the array, and we can add these integers to the array.\nTherefore, we traverse the adjacent element pairs $(a, b)$ in the array from small to large. For each adjacent element pair, we calculate the number of integers $m$ in the interval $[a+1, b-1]$. The sum of these $m$ integers is $\\frac{m \\times (a+1 + a+m)}{2}$. We add this sum to the answer and subtract $m$ from $k$. If $k$ is reduced to $0$, we can stop the traversal and return the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Where $n$ is the length of the array. \n\n", "problem_ids": ["score-of-parentheses", "graph-valid-tree", "append-k-integers-with-minimal-sum"]}, "2810": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n\u00a0\nExample 1:\n\nInput: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\nExplanation: After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\nExample 2:\n\nInput: nums = [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.\n\n\u00a0\nFollow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach? Explanation:\n\nSolution 1: Two Pointers\nSince the array $nums$ is already sorted in non-decreasing order, the square values of the negative numbers in the array are decreasing, and the square values of the positive numbers are increasing. We can use two pointers, each pointing to the ends of the array. Each time we compare the square values of the elements pointed to by the two pointers, we put the larger square value at the end of the result array.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. Ignoring the space consumption of the answer array, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a 2D grid of 0s and 1s, return the number of elements in\u00a0the largest square\u00a0subgrid that has all 1s on its border, or 0 if such a subgrid\u00a0doesn't exist in the grid.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput: 9\n\n\nExample 2:\n\n\nInput: grid = [[1,1,0,0]]\n\nOutput: 1\n\n\n\u00a0\nConstraints:\n\n1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1 Explanation:\n\nSolution 1: Prefix Sum + Enumeration\nWe can use the prefix sum method to preprocess the number of consecutive 1s down and to the right of each position, denoted as down[i][j] and right[i][j].\nThen we enumerate the side length $k$ of the square, starting from the largest side length. Then we enumerate the upper left corner position $(i, j)$ of the square. If it meets the condition, we can return $k^2$.\nThe time complexity is $O(m \\times n \\times \\min(m, n))$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns of the grid, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nDesign a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\nImplement the FreqStack class:\n\nFreqStack() constructs an empty frequency stack.\nvoid push(int val) pushes an integer val onto the top of the stack.\nint pop() removes and returns the most frequent element in the stack.\n    \nIf there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n\n\n\n\u00a0\nExample 1:\n\nInput\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\nExplanation\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n\n\u00a0\nConstraints:\n\n0 <= val <= 109\nAt most 2 * 104 calls will be made to push and pop.\nIt is guaranteed that there will be at least one element in the stack before calling pop. Explanation:\n\nSolution 1: Hash Table + Priority Queue (Max Heap)\nAccording to the problem description, we need to design a data structure that supports popping out the element with the highest frequency. If multiple elements have the same frequency, the element closest to the top of the stack should be popped out.\nWe can use a hash table $cnt$ to record the frequency of each element, and a priority queue (max heap) $q$ to maintain the frequency of elements and their corresponding timestamps.\nWhen performing a push operation, we first increment the current timestamp, i.e., $ts \\gets ts + 1$; then we increment the frequency of the element $val$, i.e., $cnt[val] \\gets cnt[val] + 1$, and finally, we add the triplet $(cnt[val], ts, val)$ to the priority queue $q$. The time complexity of the push operation is $O(\\log n)$.\nWhen performing a pop operation, we directly pop an element from the priority queue $q$. Since the elements in the priority queue $q$ are sorted in descending order of frequency, the popped element is definitely the one with the highest frequency. If multiple elements have the same frequency, the element closest to the top of the stack is popped out, i.e., the element with the largest timestamp is popped out. After popping, we decrement the frequency of the popped element, i.e., $cnt[val] \\gets cnt[val] - 1$. The time complexity of the pop operation is $O(\\log n)$. \n\n", "problem_ids": ["squares-of-a-sorted-array", "largest-1-bordered-square", "maximum-frequency-stack"]}, "2811": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string word that consists of digits and lowercase English letters.\nYou will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123\u00a0 34 8\u00a0 34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\".\nReturn the number of different integers after performing the replacement operations on word.\nTwo integers are considered different if their decimal representations without any leading zeros are different.\n\u00a0\nExample 1:\n\nInput: word = \"a123bc34d8ef34\"\nOutput: 3\nExplanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once.\n\nExample 2:\n\nInput: word = \"leet1234code234\"\nOutput: 2\n\nExample 3:\n\nInput: word = \"a1b01c001\"\nOutput: 1\nExplanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values.\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 1000\nword consists of digits and lowercase English letters. Explanation:\n\nSolution 1: Double Pointers + Simulation\nTraverse the string word, find the start and end positions of each integer, cut out this substring, and store it in the hash set $s$.\nAfter the traversal, return the size of the hash set $s$.\n\nNote, the integer represented by each substring may be very large, we cannot directly convert it to an integer. Therefore, we can remove the leading zeros of each substring before storing it in the hash set.\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string word. \n\nSimilar Problem 2 \n\n Problem:\n\nAn array A is larger than some array B if for the first index i where A[i] != B[i], A[i] > B[i].\nFor example, consider 0-indexing:\n\n[1,3,2,4] > [1,2,2,4], since at index 1, 3 > 2.\n[1,4,4,4] < [2,1,1,1], since at index 0, 1 < 2.\n\nA subarray is a contiguous subsequence of the array.\nGiven an integer array nums of distinct integers, return the largest subarray of nums of length k.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,5,2,3], k = 3\nOutput: [5,2,3]\nExplanation: The subarrays of size 3 are: [1,4,5], [4,5,2], and [5,2,3].\nOf these, [5,2,3] is the largest.\nExample 2:\n\nInput: nums = [1,4,5,2,3], k = 4\nOutput: [4,5,2,3]\nExplanation: The subarrays of size 4 are: [1,4,5,2], and [4,5,2,3].\nOf these, [4,5,2,3] is the largest.\nExample 3:\n\nInput: nums = [1,4,5,2,3], k = 1\nOutput: [5]\n\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 105\n1 <= nums[i] <= 109\nAll the integers of nums are unique.\n\n\u00a0\nFollow up: What if the integers in nums are not distinct? Explanation:\n\nSolution 1: Simulation\nAll integers in the array are distinct, so we can first find the index of the maximum element in the range $[0,..n-k]$, and then take $k$ elements starting from this index.\nThe time complexity is $O(n)$, where $n$ is the length of the array. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a string of length 5 called time, representing the current time on a digital clock in the format \"hh:mm\". The earliest possible time is \"00:00\" and the latest possible time is \"23:59\".\nIn the string time, the digits represented by the ?\u00a0symbol are unknown, and must be replaced with a digit from 0 to 9.\nReturn an integer answer, the number of valid clock times that can be created by replacing every ?\u00a0with a digit from 0 to 9.\n\u00a0\nExample 1:\n\nInput: time = \"?5:00\"\nOutput: 2\nExplanation: We can replace the ? with either a 0 or 1, producing \"05:00\" or \"15:00\". Note that we cannot replace it with a 2, since the time \"25:00\" is invalid. In total, we have two choices.\n\nExample 2:\n\nInput: time = \"0?:0?\"\nOutput: 100\nExplanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.\n\nExample 3:\n\nInput: time = \"??:??\"\nOutput: 1440\nExplanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices.\n\n\u00a0\nConstraints:\n\ntime is a valid string of length 5 in the format \"hh:mm\".\n\"00\" <= hh <= \"23\"\n\"00\" <= mm <= \"59\"\nSome of the digits might be replaced with '?' and need to be replaced with digits from 0 to 9. Explanation:\n\nSolution 1: Enumeration\nWe can directly enumerate all times from $00:00$ to $23:59$, then judge whether each time is valid, if so, increment the answer.\nAfter the enumeration ends, return the answer.\nThe time complexity is $O(24 \\times 60)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["number-of-different-integers-in-a-string", "largest-subarray-length-k", "number-of-valid-clock-times"]}, "2812": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array nums containing n integers.\nAt each second, you perform the following operation on the array:\n\nFor every index i in the range [0, n - 1], replace nums[i] with either nums[i], nums[(i - 1 + n) % n], or nums[(i + 1) % n].\n\nNote that all the elements get replaced simultaneously.\nReturn the minimum number of seconds needed to make all elements in the array nums equal.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,1,2]\nOutput: 1\nExplanation: We can equalize the array in 1 second in the following way:\n- At 1st second, replace values at each index with [nums[3],nums[1],nums[3],nums[3]]. After replacement, nums = [2,2,2,2].\nIt can be proven that 1 second is the minimum amount of seconds needed for equalizing the array.\n\nExample 2:\n\nInput: nums = [2,1,3,3,2]\nOutput: 2\nExplanation: We can equalize the array in 2 seconds in the following way:\n- At 1st second, replace values at each index with [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].\n- At 2nd second, replace values at each index with [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].\nIt can be proven that 2 seconds is the minimum amount of seconds needed for equalizing the array.\n\nExample 3:\n\nInput: nums = [5,5,5,5]\nOutput: 0\nExplanation: We don't need to perform any operations as all elements in the initial array are the same.\n\n\u00a0\nConstraints:\n\n1 <= n == nums.length <= 105\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Enumeration\nWe assume that all elements eventually become $x$, and $x$ must be an element in the array.\nThe number $x$ can expand one bit to the left and right every second. If there are multiple identical $x$, then the time required to expand the entire array depends on the maximum distance between two adjacent $x$.\nTherefore, we enumerate each element as the final $x$, calculate the maximum distance $t$ between two adjacent elements in each $x$, then the final answer is $\\min\\limits_{x \\in nums} \\left\\lfloor \\frac{t}{2} \\right\\rfloor$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array enemyEnergies denoting the energy values of various enemies.\nYou are also given an integer currentEnergy denoting the amount of energy you have initially.\nYou start with 0 points, and all the enemies are unmarked initially.\nYou can perform either of the following operations zero or multiple times to gain points:\n\nChoose an unmarked enemy, i, such that currentEnergy >= enemyEnergies[i]. By choosing this option:\n\n    \nYou gain 1 point.\nYour energy is reduced by the enemy's energy, i.e. currentEnergy = currentEnergy - enemyEnergies[i].\n\n\nIf you have at least 1 point, you can choose an unmarked enemy, i. By choosing this option:\n    \nYour energy increases by the enemy's energy, i.e. currentEnergy = currentEnergy + enemyEnergies[i].\nThe enemy i is marked.\n\n\n\nReturn an integer denoting the maximum points you can get in the end by optimally performing operations.\n\u00a0\nExample 1:\n\nInput: enemyEnergies = [3,2,2], currentEnergy = 2\nOutput: 3\nExplanation:\nThe following operations can be performed to get 3 points, which is the maximum:\n\nFirst operation on enemy 1: points increases by 1, and currentEnergy decreases by 2. So, points = 1, and currentEnergy = 0.\nSecond operation on enemy 0: currentEnergy increases by 3, and enemy 0 is marked. So, points = 1, currentEnergy = 3, and marked enemies = [0].\nFirst operation on enemy 2: points increases by 1, and currentEnergy decreases by 2. So, points = 2, currentEnergy = 1, and marked enemies = [0].\nSecond operation on enemy 2: currentEnergy increases by 2, and enemy 2 is marked. So, points = 2, currentEnergy = 3, and marked enemies = [0, 2].\nFirst operation on enemy 1: points increases by 1, and currentEnergy decreases by 2. So, points = 3, currentEnergy = 1, and marked enemies = [0, 2].\n\n\nExample 2:\n\nInput: enemyEnergies = [2], currentEnergy = 10\nOutput: 5\nExplanation: \nPerforming the first operation 5 times on enemy 0 results in the maximum number of points.\n\n\u00a0\nConstraints:\n\n1 <= enemyEnergies.length <= 105\n1 <= enemyEnergies[i] <= 109\n0 <= currentEnergy <= 109 Explanation:\n\nSolution 1: Greedy + Sorting\nAccording to the problem description, we need to score by defeating enemies with the lowest energy value and increase our energy value by defeating enemies with the highest energy value and marking them.\nTherefore, we can sort the enemies by their energy values, then start from the enemy with the highest energy value, always choose the enemy with the lowest energy value to score and consume energy. Next, we add the energy value of the enemy with the highest energy to our current energy and mark that enemy. Repeat the above steps until all enemies are marked.\nThe time complexity is $O(n \\log n)$, and the space complexity is $O(\\log n)$, where $n$ is the number of enemies. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.\nYou are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.\nThere are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.\nOnly one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.\nReturn the minimum number of minutes needed to pick up all the garbage.\n\u00a0\nExample 1:\n\nInput: garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\nOutput: 21\nExplanation:\nThe paper garbage truck:\n1. Travels from house 0 to house 1\n2. Collects the paper garbage at house 1\n3. Travels from house 1 to house 2\n4. Collects the paper garbage at house 2\nAltogether, it takes 8 minutes to pick up all the paper garbage.\nThe glass garbage truck:\n1. Collects the glass garbage at house 0\n2. Travels from house 0 to house 1\n3. Travels from house 1 to house 2\n4. Collects the glass garbage at house 2\n5. Travels from house 2 to house 3\n6. Collects the glass garbage at house 3\nAltogether, it takes 13 minutes to pick up all the glass garbage.\nSince there is no metal garbage, we do not need to consider the metal garbage truck.\nTherefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.\n\nExample 2:\n\nInput: garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\nOutput: 37\nExplanation:\nThe metal garbage truck takes 7 minutes to pick up all the metal garbage.\nThe paper garbage truck takes 15 minutes to pick up all the paper garbage.\nThe glass garbage truck takes 15 minutes to pick up all the glass garbage.\nIt takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.\n\n\u00a0\nConstraints:\n\n2 <= garbage.length <= 105\ngarbage[i] consists of only the letters 'M', 'P', and 'G'.\n1 <= garbage[i].length <= 10\ntravel.length == garbage.length - 1\n1 <= travel[i] <= 100 Explanation:\n\nSolution 1: Hash Table + Prefix Sum\nAccording to the problem description, each garbage truck starts from house $0$, collects one type of garbage, and moves forward in order until it reaches the house index where this type of garbage last appears.\nTherefore, we can use a hash table $\\textit{last}$ to record the house index where each type of garbage last appears. We assume that the $i$-th type of garbage last appears in the $j$-th house, then the driving time required for the $i$-th truck is $\\textit{travel}[0] + \\textit{travel}[1] + \\cdots + \\textit{travel}[j-1]$. Note, if $j = 0$, no driving time is needed. We accumulate the driving time of all vehicles, add the total collection time of each type of garbage, and we can get the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(k)$, where $n$ and $k$ are the number and types of garbage, respectively. In this problem, $k = 3$. \n\n", "problem_ids": ["minimum-seconds-to-equalize-a-circular-array", "maximum-points-after-enemy-battles", "minimum-amount-of-time-to-collect-garbage"]}, "2816": {"text": "Similar Problem 1 \n\n Problem:\n\nYou have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\nFor each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\nGiven an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\n\u00a0\nExample 1:\n\nInput: machines = [1,0,5]\nOutput: 3\nExplanation:\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\nExample 2:\n\nInput: machines = [0,3,0]\nOutput: 2\nExplanation:\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\nExample 3:\n\nInput: machines = [0,2,0]\nOutput: -1\nExplanation:\nIt's impossible to make all three washing machines have the same number of dresses.\n\n\u00a0\nConstraints:\n\nn == machines.length\n1 <= n <= 104\n0 <= machines[i] <= 105 Explanation:\n\nSolution 1: Greedy\nIf the total number of clothes in the washing machines cannot be divided evenly by the number of washing machines, it is impossible to make the number of clothes in each washing machine equal, so we directly return $-1$.\nOtherwise, suppose the total number of clothes in the washing machines is $s$, then the number of clothes in each washing machine will eventually become $k = s / n$.\nWe define $a_i$ as the difference between the number of clothes in the $i$-th washing machine and $k$, that is, $a_i = \\textit{machines}[i] - k$. If $a_i > 0$, it means that the $i$-th washing machine has extra clothes and needs to pass them to the adjacent washing machine; if $a_i < 0$, it means that the $i$-th washing machine lacks clothes and needs to get them from the adjacent washing machine.\nWe define the sum of the differences in the number of clothes in the first $i$ washing machines as $s_i = \\sum_{j=0}^{i-1} a_j$. If we regard the first $i$ washing machines as one group and the remaining washing machines as another group. Then if $s_i$ is a positive number, it means that the first group of washing machines has extra clothes and needs to pass them to the second group of washing machines; if $s_i$ is a negative number, it means that the first group of washing machines lacks clothes and needs to get them from the second group of washing machines.\nThen there are the following two situations:\n\nThe maximum number of times clothes need to be moved between the two groups is $\\max_{i=0}^{n-1} \\lvert s_i \\rvert$;\nA washing machine in the group has too many clothes and needs to move clothes to both sides, the maximum number of times clothes need to be moved is $\\max_{i=0}^{n-1} a_i$.\n\nWe take the maximum of the two.\nThe time complexity is $O(n)$, where $n$ is the number of washing machines. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere are n rooms labeled from 0 to n - 1\u00a0and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\n\u00a0\nExample 1:\n\nInput: rooms = [[1],[2],[3],[]]\nOutput: true\nExplanation: \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n\nExample 2:\n\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\n\n\u00a0\nConstraints:\n\nn == rooms.length\n2 <= n <= 1000\n0 <= rooms[i].length <= 1000\n1 <= sum(rooms[i].length) <= 3000\n0 <= rooms[i][j] < n\nAll the values of rooms[i] are unique. Explanation:\n\nSolution 1: Depth-First Search (DFS)\nWe can use the Depth-First Search (DFS) method to traverse the entire graph, count the number of reachable nodes, and use an array vis to mark whether the current node has been visited to prevent repeated visits.\nFinally, we count the number of visited nodes. If it is the same as the total number of nodes, it means that all nodes can be visited; otherwise, there are nodes that cannot be reached.\nThe time complexity is $O(n + m)$, and the space complexity is $O(n)$, where $n$ is the number of nodes, and $m$ is the number of edges. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two 0-indexed integer permutations A and B of length n.\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\nReturn the prefix common array of A and B.\nA sequence of n integers is called a\u00a0permutation if it contains all integers from 1 to n exactly once.\n\u00a0\nExample 1:\n\nInput: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: 1 and 3 are common in A and B, so C[1] = 2.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\nAt i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.\n\nExample 2:\n\nInput: A = [2,3,1], B = [3,1,2]\nOutput: [0,1,3]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: only 3 is common in A and B, so C[1] = 1.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\n\n\u00a0\nConstraints:\n\n1 <= A.length == B.length == n <= 50\n1 <= A[i], B[i] <= n\nIt is guaranteed that A and B are both a permutation of n integers. Explanation:\n\nSolution 1: Counting\nWe can use two arrays $cnt1$ and $cnt2$ to record the occurrence times of each element in arrays $A$ and $B$ respectively, and use an array $ans$ to record the answer.\nTraverse arrays $A$ and $B$, increment the occurrence times of $A[i]$ in $cnt1$, and increment the occurrence times of $B[i]$ in $cnt2$. Then enumerate $j \\in [1,n]$, calculate the minimum occurrence times of each element $j$ in $cnt1$ and $cnt2$, and accumulate them into $ans[i]$.\nAfter the traversal, return the answer array $ans$.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n)$. Here, $n$ is the length of arrays $A$ and $B$. \n\n", "problem_ids": ["super-washing-machines", "keys-and-rooms", "find-the-prefix-common-array-of-two-arrays"]}, "2817": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 2D binary array grid. Find a rectangle with horizontal and vertical sides with the smallest area, such that all the 1's in grid lie inside this rectangle.\nReturn the minimum possible area of the rectangle.\n\u00a0\nExample 1:\n\nInput: grid = [[0,1,0],[1,0,1]]\nOutput: 6\nExplanation:\n\nThe smallest rectangle has a height of 2 and a width of 3, so it has an area of 2 * 3 = 6.\n\nExample 2:\n\nInput: grid = [[1,0],[0,0]]\nOutput: 1\nExplanation:\n\nThe smallest rectangle has both height and width 1, so its area is 1 * 1 = 1.\n\n\u00a0\nConstraints:\n\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] is either 0 or 1.\nThe input is generated such that there is at least one 1 in grid. Explanation:\n\nSolution 1: Find Minimum and Maximum Boundaries\nWe can traverse grid, finding the minimum boundary of all 1s, denoted as $(x_1, y_1)$, and the maximum boundary, denoted as $(x_2, y_2)$. Then, the area of the minimum rectangle is $(x_2 - x_1 + 1) \\times (y_2 - y_1 + 1)$.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns in grid, respectively. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an array of integers nums (0-indexed) and an integer k.\nThe score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.\nReturn the maximum possible score of a good subarray.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,3,7,4,5], k = 3\nOutput: 15\nExplanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. \n\nExample 2:\n\nInput: nums = [5,5,4,5,4,1,1,1], k = 0\nOutput: 20\nExplanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 2 * 104\n0 <= k < nums.length Explanation:\n\nSolution 1: Monotonic Stack\nWe can enumerate each element $nums[i]$ in $nums$ as the minimum value of the subarray, and use a monotonic stack to find the first position $left[i]$ on the left that is less than $nums[i]$ and the first position $right[i]$ on the right that is less than or equal to $nums[i]$. Then, the score of the subarray with $nums[i]$ as the minimum value is $nums[i] \\times (right[i] - left[i] - 1)$.\nIt should be noted that the answer can only be updated when the left and right boundaries $left[i]$ and $right[i]$ satisfy $left[i]+1 \\leq k \\leq right[i]-1$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is a number n between 0 and 230 - 1 (both inclusive) that you have to find.\nThere is a pre-defined API int commonBits(int num) that helps you with your mission. But here is the challenge, every time you call this function, n changes in some way. But keep in mind, that you have to find the initial value of n.\ncommonBits(int num) acts as follows:\n\nCalculate count which is the number of bits where both n and num have the same value in that position of their binary representation.\nn = n XOR num\nReturn count.\n\nReturn the number n.\nNote: In this world, all numbers are between 0 and 230 - 1 (both inclusive), thus for counting common bits, we see only the first 30 bits of those numbers.\n\u00a0\nConstraints:\n\n0 <= n <= 230 - 1\n0 <= num <= 230 - 1\nIf you ask for some num out of the given range, the output wouldn't be reliable. Explanation:\n\nSolution 1: Bit Manipulation\nBased on the problem description, we observe that:\n\nIf we call the commonBits function twice with the same number, the value of $n$ will not change.\nIf we call commonBits(1 << i), the $i$-th bit of $n$ will be flipped, i.e., if the $i$-th bit of $n$ is $1$, it will become $0$ after the call, and vice versa.\n\nTherefore, for each bit $i$, we can call commonBits(1 << i) twice, denoted as count1 and count2 respectively. If count1 > count2, it means the $i$-th bit of $n$ is $1$, otherwise it is $0$.\nThe time complexity is $O(\\log n)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["find-the-minimum-area-to-cover-all-ones-i", "maximum-score-of-a-good-subarray", "guess-the-number-using-bitwise-questions-ii"]}, "2819": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\nIf there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.\n\u00a0\nExample 1:\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n\nExample 2:\nInput: s = \"abcd\", k = 2\nOutput: \"bacd\"\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 104\ns consists of only lowercase English letters.\n1 <= k <= 104 Explanation:\n\nSolution 1: Two Pointers\nWe can traverse the string $\\textit{s}$, iterating over every $\\textit{2k}$ characters, and then use the two-pointer technique to reverse the first $\\textit{k}$ characters among these $\\textit{2k}$ characters.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string $\\textit{s}$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a binary array nums.\nA subarray of an array is good if it contains exactly one element with the value 1.\nReturn an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nExample 1:\n\nInput: nums = [0,1,0,0,1]\nOutput: 3\nExplanation: There are 3 ways to split nums into good subarrays:\n- [0,1] [0,0,1]\n- [0,1,0] [0,1]\n- [0,1,0,0] [1]\n\nExample 2:\n\nInput: nums = [0,1,0]\nOutput: 1\nExplanation: There is 1 way to split nums into good subarrays:\n- [0,1,0]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 1 Explanation:\n\nSolution 1: Multiplication Principle\nBased on the problem description, we can draw a dividing line between two $1$s. Assuming the indices of the two $1$s are $j$ and $i$ respectively, then the number of different dividing lines that can be drawn is $i - j$. We find all the pairs of $j$ and $i$ that meet the condition, and then multiply all the $i - j$ together. If no dividing line can be found between two $1$s, it means there are no $1$s in the array, and the answer is $0$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\u00a0\nExample 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\u00a0\nConstraints:\n\n1 <= n <= 45 Explanation:\n\nSolution 1: Recursion\nWe define $f[i]$ to represent the number of ways to climb to the $i$-th step, then $f[i]$ can be transferred from $f[i - 1]$ and $f[i - 2]$, that is:\n$$\nf[i] = f[i - 1] + f[i - 2]\n$$\nThe initial conditions are $f[0] = 1$ and $f[1] = 1$, that is, the number of ways to climb to the 0th step is 1, and the number of ways to climb to the 1st step is also 1.\nThe answer is $f[n]$.\nSince $f[i]$ is only related to $f[i - 1]$ and $f[i - 2]$, we can use two variables $a$ and $b$ to maintain the current number of ways, reducing the space complexity to $O(1)$.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["reverse-string-ii", "ways-to-split-array-into-good-subarrays", "climbing-stairs"]}, "2824": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array of unique integers salary where salary[i] is the salary of the ith employee.\nReturn the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.\n\u00a0\nExample 1:\n\nInput: salary = [4000,3000,1000,2000]\nOutput: 2500.00000\nExplanation: Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500\n\nExample 2:\n\nInput: salary = [1000,2000,3000]\nOutput: 2000.00000\nExplanation: Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000\n\n\u00a0\nConstraints:\n\n3 <= salary.length <= 100\n1000 <= salary[i] <= 106\nAll the integers of salary are unique. Explanation:\n\nSolution 1: Simulation\nSimulate according to the problem's requirements.\nTraverse the array, find the maximum and minimum values, and accumulate the sum. Then calculate the average value after removing the maximum and minimum values.\nThe time complexity is $O(n)$, where $n$ is the length of the array salary. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\n\u00a0\nExample 1:\n\n\nInput: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.\n\nExample 2:\n\n\nInput: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.\n\n\u00a0\nConstraints:\n\nn == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique. Explanation:\n\nSolution 1: Simulation\nWe first use the array $pos$ to record the coordinates of the grid visited by the knight, and then traverse the $pos$ array to check whether the difference between the adjacent two grid coordinates is $(1, 2)$ or $(2, 1)$. If not, return false.\nOtherwise, return true after the traversal ends.\nThe time complexity is $O(n^2)$ and the space complexity is $O(n^2)$, where $n$ is the length of the chessboard. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:\n\nYou will pick any pizza slice.\nYour friend Alice will pick the next slice in the anti-clockwise direction of your pick.\nYour friend Bob will pick the next slice in the clockwise direction of your pick.\nRepeat until there are no more slices of pizzas.\n\nGiven an integer array slices that represent the sizes of the pizza slices in a clockwise direction, return the maximum possible sum of slice sizes that you can pick.\n\u00a0\nExample 1:\n\n\nInput: slices = [1,2,3,4,5,6]\nOutput: 10\nExplanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n\nExample 2:\n\n\nInput: slices = [8,9,8,6,1,1]\nOutput: 16\nExplanation: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n\n\u00a0\nConstraints:\n\n3 * n == slices.length\n1 <= slices.length <= 500\n1 <= slices[i] <= 1000 Explanation:\n\nSolution 1: Dynamic Programming\nWe can transform this problem into: In a circular array of length $3n$, select $n$ non-adjacent numbers so that the sum of these $n$ numbers is maximized.\nThe proof is as follows:\n\nWhen $n = 1$, we can choose any number in the array.\nWhen $n > 1$, there must exist a number such that there are two consecutive numbers on one side of it that have not been selected, and at least one number on the other side has not been selected. Therefore, we can remove this number and the numbers on both sides of it from the array, and then the remaining $3(n - 1)$ numbers form a new circular array. The problem scale is reduced to selecting $n - 1$ non-adjacent numbers in a circular array of length $3(n - 1)$, so that the sum of these $n - 1$ numbers is maximized.\n\nTherefore, the problem we need to solve can be transformed into: In a circular array of length $3n$, select $n$ non-adjacent numbers so that the sum of these $n$ numbers is maximized.\nIn a circular array, if the first number is selected, the last number cannot be selected. If the last number is selected, the first number cannot be selected. Therefore, we can split the circular array into two arrays, one is without the first number, and the other is without the last number. Then solve the maximum value of these two arrays separately, and finally take the larger of the two maximum values.\nWe use a function $g(nums)$, which represents the maximum sum of selecting $n$ non-adjacent numbers in the array $nums$. Then our goal is to find the larger value between $g(slices)$ and $g(slices[1:])$.\nThe solution method of function $g(nums)$ is as follows:\nWe denote the length of array $nums$ as $m$, and define $f[i][j]$ as the maximum sum of selecting $j$ non-adjacent numbers in the first $i$ numbers of array $nums$.\nConsider $f[i][j]$, if we do not select the $i$-th number, then $f[i][j] = f[i - 1][j]$. If we select the $i$-th number, then $f[i][j] = f[i - 2][j - 1] + nums[i - 1]$. Therefore, we can get the state transition equation:\n$$\nf[i][j] = \\max(f[i - 1][j], f[i - 2][j - 1] + nums[i - 1])\n$$\nFinally, return $f[m][n]$.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Where $n$ is the length of the array $slices$. \n\n", "problem_ids": ["average-salary-excluding-the-minimum-and-maximum-salary", "check-knight-tour-configuration", "pizza-with-3n-slices"]}, "2825": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0.\n\u00a0\nExample 1:\n\nInput: nums = [21,4,7]\nOutput: 32\nExplanation: \n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\n\nExample 2:\n\nInput: nums = [21,21]\nOutput: 64\n\nExample 3:\n\nInput: nums = [1,2,3,4,5]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n1 <= nums[i] <= 105 Explanation:\n\nSolution 1: Factor Decomposition\nWe can perform factor decomposition on each number. If the number of factors is $4$, then this number meets the requirements of the problem, and we can add its factors to the answer.\nThe time complexity is $O(n \\times \\sqrt{n})$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:\n\n0 <= i < j < nums.length\nnums[i] + rev(nums[j]) == nums[j] + rev(nums[i])\n\nReturn the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: nums = [42,11,1,97]\nOutput: 2\nExplanation: The two pairs are:\n - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.\n - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.\n\nExample 2:\n\nInput: nums = [13,10,35,24,76]\nOutput: 4\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109 Explanation:\n\nSolution 1: Equation Transformation + Hash Table\nFor the index pair $(i, j)$, if it satisfies the condition, then we have $nums[i] + rev(nums[j]) = nums[j] + rev(nums[i])$, which means $nums[i] - nums[j] = rev(nums[j]) - rev(nums[i])$.\nTherefore, we can use $nums[i] - rev(nums[i])$ as the key of a hash table and count the number of occurrences of each key. Finally, we calculate the combination of values corresponding to each key, add them up, and get the final answer.\nNote that we need to perform modulo operation on the answer.\nThe time complexity is $O(n \\times \\log M)$, where $n$ and $M$ are the length of the $nums$ array and the maximum value in the $nums$ array, respectively. The space complexity is $O(n)$. \n\nSimilar Problem 3 \n\n Problem:\n\nA company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.\nEach employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure.\nThe head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\nThe i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).\nReturn the number of minutes needed to inform all the employees about the urgent news.\n\u00a0\nExample 1:\n\nInput: n = 1, headID = 0, manager = [-1], informTime = [0]\nOutput: 0\nExplanation: The head of the company is the only employee in the company.\n\nExample 2:\n\n\nInput: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\nOutput: 1\nExplanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\nThe tree structure of the employees in the company is shown.\n\n\u00a0\nConstraints:\n\n1 <= n <= 105\n0 <= headID < n\nmanager.length == n\n0 <= manager[i] < n\nmanager[headID] == -1\ninformTime.length == n\n0 <= informTime[i] <= 1000\ninformTime[i] == 0 if employee i has no subordinates.\nIt is guaranteed that all the employees can be informed. Explanation:\n\nSolution 1: DFS\nWe first build an adjacent list $g$ according to the $manager$ array, where $g[i]$ represents all direct subordinates of employee $i$.\nNext, we design a function $dfs(i)$, which means the time required for employee $i$ to notify all his subordinates (including direct subordinates and indirect subordinates), and then the answer is $dfs(headID)$.\nIn function $dfs(i)$, we need to traverse all direct subordinates $j$ of $i$. For each subordinate, employee $i$ needs to notify him, which takes $informTime[i]$ time, and his subordinates need to notify their subordinates, which takes $dfs(j)$ time. We take the maximum value of $informTime[i] + dfs(j)$ as the return value of function $dfs(i)$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of employees. \n\n", "problem_ids": ["four-divisors", "count-nice-pairs-in-an-array", "time-needed-to-inform-all-employees"]}, "2827": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string of length 5 called time, representing the current time on a digital clock in the format \"hh:mm\". The earliest possible time is \"00:00\" and the latest possible time is \"23:59\".\nIn the string time, the digits represented by the ?\u00a0symbol are unknown, and must be replaced with a digit from 0 to 9.\nReturn an integer answer, the number of valid clock times that can be created by replacing every ?\u00a0with a digit from 0 to 9.\n\u00a0\nExample 1:\n\nInput: time = \"?5:00\"\nOutput: 2\nExplanation: We can replace the ? with either a 0 or 1, producing \"05:00\" or \"15:00\". Note that we cannot replace it with a 2, since the time \"25:00\" is invalid. In total, we have two choices.\n\nExample 2:\n\nInput: time = \"0?:0?\"\nOutput: 100\nExplanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.\n\nExample 3:\n\nInput: time = \"??:??\"\nOutput: 1440\nExplanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices.\n\n\u00a0\nConstraints:\n\ntime is a valid string of length 5 in the format \"hh:mm\".\n\"00\" <= hh <= \"23\"\n\"00\" <= mm <= \"59\"\nSome of the digits might be replaced with '?' and need to be replaced with digits from 0 to 9. Explanation:\n\nSolution 1: Enumeration\nWe can directly enumerate all times from $00:00$ to $23:59$, then judge whether each time is valid, if so, increment the answer.\nAfter the enumeration ends, return the answer.\nThe time complexity is $O(24 \\times 60)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle.\n\u00a0\nExample 1:\n\n\nInput: n = 2, m = 3\nOutput: 3\nExplanation: 3 squares are necessary to cover the rectangle.\n2 (squares of 1x1)\n1 (square of 2x2)\nExample 2:\n\n\nInput: n = 5, m = 8\nOutput: 5\n\nExample 3:\n\n\nInput: n = 11, m = 13\nOutput: 6\n\n\u00a0\nConstraints:\n\n1 <= n, m <= 13 Explanation:\n\nSolution 1: Recursive Backtracking + State Compression\nWe can perform recursive backtracking by position, during which we use a variable $t$ to record the current number of tiles used.\n\nIf $j = m$, i.e., the $i$-th row has been completely filled, then we recurse to the next row, i.e., $(i + 1, 0)$.\nIf $i = n$, it means that all positions have been filled, we update the answer and return.\nIf the current position $(i, j)$ has been filled, then directly recurse to the next position $(i, j + 1)$.\nOtherwise, we enumerate the maximum square side length $w$ that the current position $(i, j)$ can fill, and fill all positions from $(i, j)$ to $(i + w - 1, j + w - 1)$, then recurse to the next position $(i, j + w)$. When backtracking, we need to clear all positions from $(i, j)$ to $(i + w - 1, j + w - 1)$.\n\nSince each position only has two states: filled or not filled, we can use an integer to represent the current state. We use an integer array $filled$ of length $n$, where $filled[i]$ represents the state of the $i$-th row. If the $j$-th bit of $filled[i]$ is $1$, it means that the $i$-th row and the $j$-th column have been filled, otherwise it means not filled. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote:\u00a0A leaf is a node with no children.\n\u00a0\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\n\nExample 2:\n\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000 Explanation:\n\nSolution 1: Recursion\nThe termination condition for recursion is when the current node is null, at which point return $0$. If one of the left or right subtrees of the current node is null, return the minimum depth of the non-null subtree plus $1$. If neither the left nor right subtree of the current node is null, return the smaller value of the minimum depths of the left and right subtrees plus $1$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["number-of-valid-clock-times", "tiling-a-rectangle-with-the-fewest-squares", "minimum-depth-of-binary-tree"]}, "2828": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two positive integers n and limit.\nReturn the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.\n\u00a0\nExample 1:\n\nInput: n = 5, limit = 2\nOutput: 3\nExplanation: There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).\n\nExample 2:\n\nInput: n = 3, limit = 3\nOutput: 10\nExplanation: There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).\n\n\u00a0\nConstraints:\n\n1 <= n <= 50\n1 <= limit <= 50 Explanation:\n\nSolution 1: Combinatorial Mathematics + Principle of Inclusion-Exclusion\nAccording to the problem description, we need to distribute $n$ candies to $3$ children, with each child receiving between $[0, limit]$ candies.\nThis is equivalent to placing $n$ balls into $3$ boxes. Since the boxes can be empty, we can add $3$ virtual balls, and then use the method of inserting partitions, i.e., there are a total of $n + 3$ balls, and we insert $2$ partitions among the $n + 3 - 1$ positions, thus dividing the actual $n$ balls into $3$ groups, and allowing the boxes to be empty. Therefore, the initial number of schemes is $C_{n + 2}^2$.\nWe need to exclude the schemes where the number of balls in a box exceeds $limit$. Consider that there is a box where the number of balls exceeds $limit$, then the remaining balls (including virtual balls) have at most $n + 3 - (limit + 1) = n - limit + 2$, and the number of positions is $n - limit + 1$, so the number of schemes is $C_{n - limit + 1}^2$. Since there are $3$ boxes, the number of such schemes is $3 \\times C_{n - limit + 1}^2$. In this way, we will exclude too many schemes where the number of balls in two boxes exceeds $limit$ at the same time, so we need to add the number of such schemes, i.e., $3 \\times C_{n - 2 \\times limit}^2$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed array nums consisting of n positive integers.\nThe array nums is called alternating if:\n\nnums[i - 2] == nums[i], where 2 <= i <= n - 1.\nnums[i - 1] != nums[i], where 1 <= i <= n - 1.\n\nIn one operation, you can choose an index i and change nums[i] into any positive integer.\nReturn the minimum number of operations required to make the array alternating.\n\u00a0\nExample 1:\n\nInput: nums = [3,1,3,2,4,3]\nOutput: 3\nExplanation:\nOne way to make the array alternating is by converting it to [3,1,3,1,3,1].\nThe number of operations required in this case is 3.\nIt can be proven that it is not possible to make the array alternating in less than 3 operations. \n\nExample 2:\n\nInput: nums = [1,2,2,2,2]\nOutput: 2\nExplanation:\nOne way to make the array alternating is by converting it to [1,2,1,2,1].\nThe number of operations required in this case is 2.\nNote that the array cannot be converted to [2,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105 Explanation:\n\nSolution 1: Maintain Count of Odd and Even Positions\nAccording to the problem description, if an array $\\textit{nums}$ is an alternating array, then the elements at odd positions and even positions must be different, and the elements at odd positions are the same, as well as the elements at even positions.\nTo minimize the number of operations required to transform the array $\\textit{nums}$ into an alternating array, we can count the occurrence of elements at odd and even positions. We find the two elements with the highest occurrence at even positions, $a_0$ and $a_2$, and their corresponding counts $a_1$ and $a_3$; similarly, we find the two elements with the highest occurrence at odd positions, $b_0$ and $b_2$, and their corresponding counts $b_1$ and $b_3$.\nIf $a_0 \\neq b_0$, then we can change all elements at even positions in the array $\\textit{nums}$ to $a_0$ and all elements at odd positions to $b_0$, making the number of operations $n - (a_1 + b_1)$; if $a_0 = b_0$, then we can change all elements at even positions in the array $\\textit{nums}$ to $a_0$ and all elements at odd positions to $b_2$, or change all elements at even positions to $a_2$ and all elements at odd positions to $b_0$, making the number of operations $n - \\max(a_1 + b_3, a_3 + b_1)$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $\\textit{nums}$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.\nThe elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\nReturn an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.\n\u00a0\nExample 1:\n\n\nInput: original = [1,2,3,4], m = 2, n = 2\nOutput: [[1,2],[3,4]]\nExplanation: The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n\nExample 2:\n\nInput: original = [1,2,3], m = 1, n = 3\nOutput: [[1,2,3]]\nExplanation: The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n\nExample 3:\n\nInput: original = [1,2], m = 1, n = 1\nOutput: []\nExplanation: There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.\n\n\u00a0\nConstraints:\n\n1 <= original.length <= 5 * 104\n1 <= original[i] <= 105\n1 <= m, n <= 4 * 104 Explanation:\n\nSolution 1: Simulation\nAccording to the problem description, we know that to construct an $m$-row and $n$-column two-dimensional array, it needs to satisfy that $m \\times n$ equals the length of the original array. If it does not satisfy, return an empty array directly.\nIf it does satisfy, we can follow the process described in the problem, and put the elements from the original array into the two-dimensional array in order.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the two-dimensional array, respectively. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["distribute-candies-among-children-i", "minimum-operations-to-make-the-array-alternating", "convert-1d-array-into-2d-array"]}, "2831": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array start where start = [startX, startY] represents your initial position (startX, startY) in a 2D space. You are also given the array target where target = [targetX, targetY] represents your target position (targetX, targetY).\nThe cost of going from a position (x1, y1) to any other position in the space (x2, y2) is |x2 - x1| + |y2 - y1|.\nThere are also some special roads. You are given a 2D array specialRoads where specialRoads[i] = [x1i, y1i, x2i, y2i, costi] indicates that the ith special road goes in one direction from (x1i, y1i) to (x2i, y2i) with a cost equal to costi. You can use each special road any number of times.\nReturn the minimum cost required to go from (startX, startY) to (targetX, targetY).\n\u00a0\nExample 1:\n\nInput: start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]\nOutput: 5\nExplanation:\n\n(1,1) to (1,2) with a cost of |1 - 1| + |2 - 1| = 1.\n(1,2) to (3,3). Use specialRoads[0] with the cost 2.\n(3,3) to (3,4) with a cost of |3 - 3| + |4 - 3| = 1.\n(3,4) to (4,5). Use specialRoads[1] with the cost 1.\n\nSo the total cost is 1 + 2 + 1 + 1 = 5.\n\nExample 2:\n\nInput: start = [3,2], target = [5,7], specialRoads = [[5,7,3,2,1],[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]\nOutput: 7\nExplanation:\nIt is optimal not to use any special edges and go directly from the starting to the ending position with a cost |5 - 3| + |7 - 2| = 7.\nNote that the specialRoads[0] is directed from (5,7) to (3,2).\n\nExample 3:\n\nInput: start = [1,1], target = [10,4], specialRoads = [[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\nOutput: 8\nExplanation:\n\n(1,1) to (1,2) with a cost of |1 - 1| + |2 - 1| = 1.\n(1,2) to (7,4). Use specialRoads[1] with the cost 4.\n(7,4) to (10,4) with a cost of |10 - 7| + |4 - 4| = 3.\n\n\n\u00a0\nConstraints:\n\nstart.length == target.length == 2\n1 <= startX <= targetX <= 105\n1 <= startY <= targetY <= 105\n1 <= specialRoads.length <= 200\nspecialRoads[i].length == 5\nstartX <= x1i, x2i <= targetX\nstartY <= y1i, y2i <= targetY\n1 <= costi <= 105 Explanation:\n\nSolution 1: Dijkstra\nWe can find that for each coordinate $(x, y)$ we visit, suppose the minimum cost from the start point to $(x, y)$ is $d$. If we choose to move directly to $(targetX, targetY)$, then the total cost is $d + |x - targetX| + |y - targetY|$. If we choose to go through a special path $(x_1, y_1) \\rightarrow (x_2, y_2)$, then we need to spend $|x - x_1| + |y - y_1| + cost$ to move from $(x, y)$ to $(x_2, y_2)$.\nTherefore, we can use Dijkstra algorithm to find the minimum cost from the start point to all points, and then choose the smallest one from them.\nWe define a priority queue $q$, each element in the queue is a triple $(d, x, y)$, which means that the minimum cost from the start point to $(x, y)$ is $d$. Initially, we add $(0, startX, startY)$ to the queue.\nIn each step, we take out the first element $(d, x, y)$ in the queue, at this time we can update the answer, that is $ans = \\min(ans, d + dist(x, y, targetX, targetY))$. Then we enumerate all special paths $(x_1, y_1) \\rightarrow (x_2, y_2)$ and add $(d + dist(x, y, x_1, y_1) + cost, x_2, y_2)$ to the queue.\nFinally, when the queue is empty, we can get the answer.\nThe time complexity is $O(n^2 \\times \\log n)$, and the space complexity is $O(n^2)$. Where $n$ is the number of special paths. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array nums of size n containing each element from 0 to n - 1 (inclusive). Each of the elements from 1 to n - 1 represents an item, and the element 0 represents an empty space.\nIn one operation, you can move any item to the empty space. nums is considered to be sorted if the numbers of all the items are in ascending order and the empty space is either at the beginning or at the end of the array.\nFor example, if n = 4, nums is sorted if:\n\nnums = [0,1,2,3] or\nnums = [1,2,3,0]\n\n...and considered to be unsorted otherwise.\nReturn the minimum number of operations needed to sort nums.\n\u00a0\nExample 1:\n\nInput: nums = [4,2,0,3,1]\nOutput: 3\nExplanation:\n- Move item 2 to the empty space. Now, nums = [4,0,2,3,1].\n- Move item 1 to the empty space. Now, nums = [4,1,2,3,0].\n- Move item 4 to the empty space. Now, nums = [0,1,2,3,4].\nIt can be proven that 3 is the minimum number of operations needed.\n\nExample 2:\n\nInput: nums = [1,2,3,4,0]\nOutput: 0\nExplanation: nums is already sorted so return 0.\n\nExample 3:\n\nInput: nums = [1,0,2,4,3]\nOutput: 2\nExplanation:\n- Move item 2 to the empty space. Now, nums = [1,2,0,4,3].\n- Move item 3 to the empty space. Now, nums = [1,2,3,4,0].\nIt can be proven that 2 is the minimum number of operations needed.\n\n\u00a0\nConstraints:\n\nn == nums.length\n2 <= n <= 105\n0 <= nums[i] < n\nAll the values of nums are unique. Explanation:\n\nSolution 1: Permutation Cycle\nFor a permutation cycle of length $m$, if $0$ is in the cycle, the number of swaps is $m-1$; otherwise, the number of swaps is $m+1$.\nWe find all permutation cycles, first calculate the total number of swaps assuming each cycle requires $m+1$ swaps, then check if $0$ is misplaced. If it is, it means $0$ is in a permutation cycle, so we subtract $2$ from the total number of swaps.\nHere, $0$ can be at position $0$ or at position $n-1$. We take the minimum of these two cases.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an array nums of length n and a positive integer k.\nA subarray of nums is called good if the absolute difference between its first and last element is exactly k, in other words, the subarray nums[i..j] is good if |nums[i] - nums[j]| == k.\nReturn the maximum sum of a good subarray of nums. If there are no good subarrays, return 0.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4,5,6], k = 1\nOutput: 11\nExplanation: The absolute difference between the first and last element must be 1 for a good subarray. All the good subarrays are: [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray sum is 11 for the subarray [5,6].\n\nExample 2:\n\nInput: nums = [-1,3,2,4,5], k = 3\nOutput: 11\nExplanation: The absolute difference between the first and last element must be 3 for a good subarray. All the good subarrays are: [-1,3,2], and [2,4,5]. The maximum subarray sum is 11 for the subarray [2,4,5].\n\nExample 3:\n\nInput: nums = [-1,-2,-3,-4], k = 2\nOutput: -6\nExplanation: The absolute difference between the first and last element must be 2 for a good subarray. All the good subarrays are: [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 for the subarray [-1,-2,-3].\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 105\n-109 <= nums[i] <= 109\n1 <= k <= 109 Explanation:\n\nSolution 1: Prefix Sum + Hash Table\nWe use a hash table $p$ to record the sum $s$ of the prefix array $nums[0..i-1]$ for $nums[i]$. If there are multiple identical $nums[i]$, we only keep the smallest $s$. Initially, we set $p[nums[0]]$ to $0$. In addition, we use a variable $s$ to record the current prefix sum, initially $s = 0$. Initialize the answer $ans$ to $-\\infty$.\nNext, we enumerate $nums[i]$, and maintain a variable $s$ to represent the sum of $nums[0..i]$. If $nums[i] - k$ is in $p$, then we have found a good subarray, and update the answer to $ans = \\max(ans, s - p[nums[i] - k])$. Similarly, if $nums[i] + k$ is in $p$, then we have also found a good subarray, and update the answer to $ans = \\max(ans, s - p[nums[i] + k])$. Then, if $i + 1 \\lt n$ and $nums[i + 1]$ is not in $p$, or $p[nums[i + 1]] \\gt s$, we set $p[nums[i + 1]]$ to $s$.\nFinally, if $ans = -\\infty$, then we return $0$, otherwise return $ans$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["minimum-cost-of-a-path-with-special-roads", "sort-array-by-moving-items-to-empty-space", "maximum-good-subarray-sum"]}, "2832": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is an m x n matrix that is initialized to all 0's. There is also a 2D array indices where each indices[i] = [ri, ci] represents a 0-indexed location to perform some increment operations on the matrix.\nFor each location indices[i], do both of the following:\n\nIncrement all the cells on row ri.\nIncrement all the cells on column ci.\n\nGiven m, n, and indices, return the number of odd-valued cells in the matrix after applying the increment to all locations in indices.\n\u00a0\nExample 1:\n\n\nInput: m = 2, n = 3, indices = [[0,1],[1,1]]\nOutput: 6\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\nAfter applying first increment it becomes [[1,2,1],[0,1,0]].\nThe final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.\n\nExample 2:\n\n\nInput: m = 2, n = 2, indices = [[1,1],[0,0]]\nOutput: 0\nExplanation: Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.\n\n\u00a0\nConstraints:\n\n1 <= m, n <= 50\n1 <= indices.length <= 100\n0 <= ri < m\n0 <= ci < n\n\n\u00a0\nFollow up: Could you solve this in O(n + m + indices.length) time with only O(n + m) extra space? Explanation:\n\nSolution 1: Simulation\nWe create a matrix $g$ to store the result of operations. For each pair $(r_i, c_i)$ in $\\textit{indices}$, we add $1$ to all numbers in the $r_i$-th row of the matrix and add $1$ to all elements in the $c_i$-th column.\nAfter the simulation ends, we traverse the matrix and count the number of odd numbers.\nThe time complexity is $O(k \\times (m + n) + m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $k$ is the length of $\\textit{indices}$. \n\nSimilar Problem 2 \n\n Problem:\n\nImplement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\nImplement the MyQueue class:\n\nvoid push(int x) Pushes element x to the back of the queue.\nint pop() Removes the element from the front of the queue and returns it.\nint peek() Returns the element at the front of the queue.\nboolean empty() Returns true if the queue is empty, false otherwise.\n\nNotes:\n\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\nDepending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n\n\u00a0\nExample 1:\n\nInput\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 1, 1, false]\n\nExplanation\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\u00a0\nConstraints:\n\n1 <= x <= 9\nAt most 100\u00a0calls will be made to push, pop, peek, and empty.\nAll the calls to pop and peek are valid.\n\n\u00a0\nFollow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Explanation:\n\nSolution 1: Double Stack\nWe use two stacks, where stk1 is used for enqueue, and another stack stk2 is used for dequeue.\nWhen enqueueing, we directly push the element into stk1. The time complexity is $O(1)$.\nWhen dequeueing, we first check whether stk2 is empty. If it is empty, we pop all elements from stk1 and push them into stk2, and then pop an element from stk2. If stk2 is not empty, we directly pop an element from stk2. The amortized time complexity is $O(1)$.\nWhen getting the front element, we first check whether stk2 is empty. If it is empty, we pop all elements from stk1 and push them into stk2, and then get the top element from stk2. If stk2 is not empty, we directly get the top element from stk2. The amortized time complexity is $O(1)$.\nWhen checking whether the queue is empty, we only need to check whether both stacks are empty. The time complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two integer arrays nums and divisors.\nThe divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].\nReturn the integer divisors[i] with the maximum divisibility score. If multiple integers have the maximum score, return the smallest one.\n\u00a0\nExample 1:\n\nInput: nums = [2,9,15,50], divisors = [5,3,7,2]\nOutput: 2\nExplanation:\nThe divisibility score of divisors[0] is 2 since nums[2] and nums[3] are divisible by 5.\nThe divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 3.\nThe divisibility score of divisors[2] is 0 since none of the numbers in nums is divisible by 7.\nThe divisibility score of divisors[3] is 2 since nums[0] and nums[3] are divisible by 2.\nAs divisors[0],\u00a0divisors[1], and divisors[3] have the same divisibility score, we return the smaller one which is divisors[3].\n\nExample 2:\n\nInput: nums = [4,7,9,3,9], divisors = [5,2,3]\nOutput: 3\nExplanation:\nThe divisibility score of divisors[0] is 0 since none of numbers in nums is divisible by 5.\nThe divisibility score of divisors[1] is 1 since only nums[0] is divisible by 2.\nThe divisibility score of divisors[2] is 3 since nums[2], nums[3] and nums[4] are divisible by 3.\n\nExample 3:\n\nInput: nums = [20,14,21,10], divisors = [10,16,20]\nOutput: 10\nExplanation:\nThe divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 10.\nThe divisibility score of divisors[1] is 0 since none of the numbers in nums is divisible by 16.\nThe divisibility score of divisors[2] is 1 since nums[0] is divisible by 20.\n\n\u00a0\nConstraints:\n\n1 <= nums.length, divisors.length <= 1000\n1 <= nums[i], divisors[i] <= 109 Explanation:\n\nSolution 1: Enumeration\nWe can enumerate each element $div$ in $divisors$, and calculate how many elements in $nums$ can be divided by $div$, denoted as $cnt$.\n\nIf $cnt$ is greater than the current maximum divisibility score $mx$, then update $mx = cnt$, and update $ans = div$.\nIf $cnt$ equals $mx$ and $div$ is less than $ans$, then update $ans = div$.\n\nFinally, return $ans$.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the lengths of $nums$ and $divisors$ respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["cells-with-odd-values-in-a-matrix", "implement-queue-using-stacks", "find-the-maximum-divisibility-score"]}, "2833": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2p - 1] in their binary representations. You are allowed to do the following operation any number of times:\n\nChoose two elements x and y from nums.\nChoose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.\n\nFor example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.\nFind the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.\nNote: The answer should be the minimum product before the modulo operation is done.\n\u00a0\nExample 1:\n\nInput: p = 1\nOutput: 1\nExplanation: nums = [1].\nThere is only one element, so the product equals that element.\n\nExample 2:\n\nInput: p = 2\nOutput: 6\nExplanation: nums = [01, 10, 11].\nAny swap would either make the product 0 or stay the same.\nThus, the array product of 1 * 2 * 3 = 6 is already minimized.\n\nExample 3:\n\nInput: p = 3\nOutput: 1512\nExplanation: nums = [001, 010, 011, 100, 101, 110, 111]\n- In the first operation we can swap the leftmost bit of the second and fifth elements.\n    - The resulting array is [001, 110, 011, 100, 001, 110, 111].\n- In the second operation we can swap the middle bit of the third and fourth elements.\n    - The resulting array is [001, 110, 001, 110, 001, 110, 111].\nThe array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product.\n\n\u00a0\nConstraints:\n\n1 <= p <= 60 Explanation:\n\nSolution 1: Greedy + Fast Power\nWe notice that each operation does not change the sum of the elements. When the sum of the elements remains unchanged, to minimize the product, we should maximize the difference between the elements as much as possible.\nSince the largest element is $2^p - 1$, no matter which element it exchanges with, it will not increase the difference. Therefore, we do not need to consider the case of exchanging with the largest element.\nFor the other elements in $[1,..2^p-2]$, we pair the first and last elements one by one, that is, pair $x$ with $2^p-1-x$. After several operations, each pair of elements becomes $(1, 2^p-2)$. The final product is $(2^p-1) \\times (2^p-2)^{2^{p-1}-1}$.\nThe time complexity is $O(p)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nWe are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\nYou call a pre-defined API int guess(int num), which returns three possible results:\n\n-1: Your guess is higher than the number I picked (i.e. num > pick).\n1: Your guess is lower than the number I picked (i.e. num < pick).\n0: your guess is equal to the number I picked (i.e. num == pick).\n\nReturn the number that I picked.\n\u00a0\nExample 1:\n\nInput: n = 10, pick = 6\nOutput: 6\n\nExample 2:\n\nInput: n = 1, pick = 1\nOutput: 1\n\nExample 3:\n\nInput: n = 2, pick = 1\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= n <= 231 - 1\n1 <= pick <= n Explanation:\n\nSolution 1: Binary Search\nWe perform a binary search in the interval $[1,..n]$, and find the first number that satisfies guess(x) <= 0, which is the answer.\nThe time complexity is $O(\\log n)$, where $n$ is the upper limit given in the problem. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\n\u00a0\nExample 1:\n\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\nExample 2:\n\n\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\nExample 3:\n\n\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\n\n\u00a0\nConstraints:\n\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.\n\n\u00a0\nFollow up: Can you solve it using O(1) (i.e. constant) memory? Explanation:\n\nSolution 1: Two Pointers\nWe first use the fast and slow pointers to judge whether the linked list has a ring. If there is a ring, the fast and slow pointers will definitely meet, and the meeting node must be in the ring.\nIf there is no ring, the fast pointer will reach the tail of the linked list first, and return null directly.\nIf there is a ring, we then define an answer pointer $ans$ to point to the head of the linked list, and then let $ans$ and the slow pointer move forward together, moving one step at a time, until $ans$ and the slow pointer meet, and the meeting node is the ring entrance node.\nWhy can this find the entrance node of the ring?\nLet's assume that the distance from the head node of the linked list to the entrance of the ring is $x$, the distance from the entrance of the ring to the meeting node is $y$, and the distance from the meeting node to the entrance of the ring is $z$. Then the distance traveled by the slow pointer is $x + y$, and the distance traveled by the fast pointer is $x + y + k \\times (y + z)$, where $k$ is the number of times the fast pointer goes around the ring.\n\nBecause the speed of the fast pointer is twice that of the slow pointer, it is $2 \\times (x + y) = x + y + k \\times (y + z)$, which can be deduced that $x + y = k \\times (y + z)$, that is $x = (k - 1) \\times (y + z) + z$.\nThat is to say, if we define an answer pointer $ans$ to point to the head of the linked list, and the $ans$ and the slow pointer move forward together, they will definitely meet at the ring entrance.\nThe time complexity is $O(n)$, where $n$ is the number of nodes in the linked list. The space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-non-zero-product-of-the-array-elements", "guess-number-higher-or-lower", "linked-list-cycle-ii"]}, "2834": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.\nThe second greater integer of nums[i] is nums[j] such that:\n\nj > i\nnums[j] > nums[i]\nThere exists exactly one index k such that nums[k] > nums[i] and i < k < j.\n\nIf there is no such nums[j], the second greater integer is considered to be -1.\n\nFor example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3,\u00a0and that of 3 and 4 is -1.\n\nReturn an integer array answer, where answer[i] is the second greater integer of nums[i].\n\u00a0\nExample 1:\n\nInput: nums = [2,4,0,9,6]\nOutput: [9,6,6,-1,-1]\nExplanation:\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return [9,6,6,-1,-1].\n\nExample 2:\n\nInput: nums = [3,3]\nOutput: [-1,-1]\nExplanation:\nWe return [-1,-1] since neither integer has any integer greater than it.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109 Explanation:\n\nSolution 1: Sorting + Ordered Set\nWe can convert the elements in the array into pairs $(x, i)$, where $x$ is the value of the element and $i$ is the index of the element. Then sort by the value of the elements in descending order.\nNext, we traverse the sorted array, maintaining an ordered set that stores the indices of the elements. When we traverse to the element $(x, i)$, the indices of all elements greater than $x$ are already in the ordered set. We only need to find the index $j$ of the next element after $i$ in the ordered set, then the element corresponding to $j$ is the second largest element of $x$. Then, we add $i$ to the ordered set. Continue to traverse the next element.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer n, the number of teams in a tournament that has strange rules:\n\nIf the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.\nIf the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.\n\nReturn the number of matches played in the tournament until a winner is decided.\n\u00a0\nExample 1:\n\nInput: n = 7\nOutput: 6\nExplanation: Details of the tournament: \n- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 3 + 2 + 1 = 6.\n\nExample 2:\n\nInput: n = 14\nOutput: 13\nExplanation: Details of the tournament:\n- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 7 + 3 + 2 + 1 = 13.\n\n\u00a0\nConstraints:\n\n1 <= n <= 200 Explanation:\n\nSolution 1: Quick Thinking\nFrom the problem description, we know that there are $n$ teams in total. Each pairing will eliminate one team. Therefore, the number of pairings is equal to the number of teams eliminated, which is $n - 1$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nA critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].\n\u00a0\nExample 1:\n\n\nInput: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].\n\nExample 2:\n\n\nInput: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.\n\nExample 3:\n\n\nInput: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105 Explanation:\n\nSolution 1: Direct Traversal\nBased on the problem description, we need to find the positions of the first and last critical points in the linked list, $\\textit{first}$ and $\\textit{last}$, respectively. This allows us to calculate the maximum distance $\\textit{maxDistance} = \\textit{last} - \\textit{first}$. For the minimum distance $\\textit{minDistance}$, we need to traverse the linked list, calculate the distance between two adjacent critical points, and take the minimum value.\nThe time complexity is $O(n)$, where $n$ is the length of the linked list. The space complexity is $O(1)$. \n\n", "problem_ids": ["next-greater-element-iv", "count-of-matches-in-tournament", "find-the-minimum-and-maximum-number-of-nodes-between-critical-points"]}, "2837": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and an integer k.\nReturn an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.\nThe set bits in an integer are the 1's present when it is written in binary.\n\nFor example, the binary representation of 21 is 10101, which has 3 set bits.\n\n\u00a0\nExample 1:\n\nInput: nums = [5,10,1,5,2], k = 1\nOutput: 13\nExplanation: The binary representation of the indices are: \n0 = 0002\n1 = 0012\n2 = 0102\n3 = 0112\n4 = 1002 \nIndices 1, 2, and 4 have k = 1 set bits in their binary representation.\nHence, the answer is nums[1] + nums[2] + nums[4] = 13.\nExample 2:\n\nInput: nums = [4,3,2,1], k = 2\nOutput: 1\nExplanation: The binary representation of the indices are:\n0 = 002\n1 = 012\n2 = 102\n3 = 112\nOnly index 3 has k = 2 set bits in its binary representation.\nHence, the answer is nums[3] = 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 105\n0 <= k <= 10 Explanation:\n\nSolution 1: Simulation\nWe directly traverse each index $i$, and check whether the number of $1$s in its binary representation is equal to $k$. If it is, we add the corresponding element to the answer $ans$.\nAfter the traversal ends, we return the answer.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a rows x cols\u00a0binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\u00a0\nExample 1:\n\n\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n\nExample 2:\n\nInput: matrix = [[\"0\"]]\nOutput: 0\n\nExample 3:\n\nInput: matrix = [[\"1\"]]\nOutput: 1\n\n\u00a0\nConstraints:\n\nrows == matrix.length\ncols == matrix[i].length\n1 <= row, cols <= 200\nmatrix[i][j] is '0' or '1'. Explanation:\n\nSolution 1: Monotonic Stack\nWe treat each row as the base of the histogram, and calculate the maximum area of the histogram for each row.\nThe time complexity is $O(m \\times n)$, where $m$ represents the number of rows in $matrix$, and $n$ represents the number of columns in $matrix$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a digit string s that consists of digits from 0 to 9.\nA string is called semi-repetitive if there is at most one adjacent pair of the same digit. For example, \"0010\", \"002020\", \"0123\", \"2002\", and \"54944\" are semi-repetitive while the following are not: \"00101022\" (adjacent same digit pairs are 00 and 22), and \"1101234883\" (adjacent same digit pairs are 11 and 88).\nReturn the length of the longest semi-repetitive substring of s.\n\u00a0\nExample 1:\n\nInput: s = \"52233\"\nOutput: 4\nExplanation:\nThe longest semi-repetitive substring is \"5223\". Picking the whole string \"52233\" has two adjacent same digit pairs 22 and 33, but at most one is allowed.\n\nExample 2:\n\nInput: s = \"5494\"\nOutput: 4\nExplanation:\ns is a semi-repetitive string.\n\nExample 3:\n\nInput: s = \"1111111\"\nOutput: 2\nExplanation:\nThe longest semi-repetitive substring is \"11\". Picking the substring \"111\" has two adjacent same digit pairs, but at most one is allowed.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 50\n'0' <= s[i] <= '9' Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers to maintain a range $s[j..i]$ such that there is at most one pair of adjacent characters that are equal, initially $j = 0$, $i = 1$. Initialize the answer $ans = 1$.\nWe use $cnt$ to record the number of pairs of adjacent characters that are equal in the range. If $cnt > 1$, then we need to move the left pointer $j$ until $cnt \\le 1$. Each time, we update the answer as $ans = \\max(ans, i - j + 1)$.\nThe time complexity is $O(n)$, where $n$ is the length of the string. The space complexity is $O(1)$. \n\n", "problem_ids": ["sum-of-values-at-indices-with-k-set-bits", "maximal-rectangle", "find-the-longest-semi-repetitive-substring"]}, "2839": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s. It may contain any number of '*' characters. Your task is to remove all '*' characters.\nWhile there is a '*', do the following operation:\n\nDelete the leftmost '*' and the smallest non-'*' character to its left. If there are several smallest characters, you can delete any of them.\n\nReturn the lexicographically smallest resulting string after removing all '*' characters.\n\u00a0\nExample 1:\n\nInput: s = \"aaba*\"\nOutput: \"aab\"\nExplanation:\nWe should delete one of the 'a' characters with '*'. If we choose s[3], s becomes the lexicographically smallest.\n\nExample 2:\n\nInput: s = \"abc\"\nOutput: \"abc\"\nExplanation:\nThere is no '*' in the string.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists only of lowercase English letters and '*'.\nThe input is generated such that it is possible to delete all '*' characters. Explanation:\n\nSolution 1: Record Indices by Character\nWe define an array $g$ to record the index list of each character, and a boolean array $rem$ of length $n$ to record whether each character needs to be deleted.\nWe traverse the string $s$:\nIf the current character is an asterisk, we need to delete it, so we mark $rem[i]$ as deleted. At the same time, we need to delete the character with the smallest lexicographical order and the largest index at this time. We traverse the 26 lowercase letters in ascending order. If $g[a]$ is not empty, we delete the last index in $g[a]$ and set the corresponding index in $rem$ as deleted.\nIf the current character is not an asterisk, we add the index of the current character to $g$.\nFinally, we traverse $s$ and concatenate the undeleted characters.\nThe time complexity is $O(n \\times |\\Sigma|)$, and the space complexity is $O(n)$. Where $n$ is the length of the string $s$, and $|\\Sigma|$ is the size of the character set. In this problem, $|\\Sigma| = 26$. \n\nSimilar Problem 2 \n\n Problem:\n\nDesign a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\nImplement the FreqStack class:\n\nFreqStack() constructs an empty frequency stack.\nvoid push(int val) pushes an integer val onto the top of the stack.\nint pop() removes and returns the most frequent element in the stack.\n    \nIf there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n\n\n\n\u00a0\nExample 1:\n\nInput\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\nExplanation\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n\n\u00a0\nConstraints:\n\n0 <= val <= 109\nAt most 2 * 104 calls will be made to push and pop.\nIt is guaranteed that there will be at least one element in the stack before calling pop. Explanation:\n\nSolution 1: Hash Table + Priority Queue (Max Heap)\nAccording to the problem description, we need to design a data structure that supports popping out the element with the highest frequency. If multiple elements have the same frequency, the element closest to the top of the stack should be popped out.\nWe can use a hash table $cnt$ to record the frequency of each element, and a priority queue (max heap) $q$ to maintain the frequency of elements and their corresponding timestamps.\nWhen performing a push operation, we first increment the current timestamp, i.e., $ts \\gets ts + 1$; then we increment the frequency of the element $val$, i.e., $cnt[val] \\gets cnt[val] + 1$, and finally, we add the triplet $(cnt[val], ts, val)$ to the priority queue $q$. The time complexity of the push operation is $O(\\log n)$.\nWhen performing a pop operation, we directly pop an element from the priority queue $q$. Since the elements in the priority queue $q$ are sorted in descending order of frequency, the popped element is definitely the one with the highest frequency. If multiple elements have the same frequency, the element closest to the top of the stack is popped out, i.e., the element with the largest timestamp is popped out. After popping, we decrement the frequency of the popped element, i.e., $cnt[val] \\gets cnt[val] - 1$. The time complexity of the pop operation is $O(\\log n)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\u00a0\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\n\u00a0\nConstraints:\n\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.\n\n\u00a0\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case? Explanation:\n\nSolution 1: Counting\nWe first determine whether the length of the two strings is equal. If they are not equal, the characters in the two strings must be different, so return false.\nOtherwise, we use a hash table or an array of length $26$ to record the number of times each character appears in the string $s$, and then traverse the other string $t$. Each time we traverse a character, we subtract the number of times the corresponding character appears in the hash table by one. If the number of times after subtraction is less than $0$, the number of times the character appears in the two strings is different, return false. If after traversing the two strings, all the character counts in the hash table are $0$, it means that the characters in the two strings appear the same number of times, return true.\nThe time complexity is $O(n)$, the space complexity is $O(C)$, where $n$ is the length of the string; and $C$ is the size of the character set, which is $C=26$ in this problem. \n\n", "problem_ids": ["lexicographically-minimum-string-after-removing-stars", "maximum-frequency-stack", "valid-anagram"]}, "2844": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.\n\u00a0\nExample 1:\n\nInput: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.\nExample 2:\n\nInput: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.\n\nExample 3:\n\nInput: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 2000\n0 <= nums[i] <= 105 Explanation:\n\nSolution 1: Hash Table\nWe use a hash table $cnt$ to count the occurrence of all even elements, and then find the even element with the highest occurrence and the smallest value.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a string s, return the number of substrings that have only one distinct letter.\n\u00a0\nExample 1:\n\nInput: s = \"aaaba\"\nOutput: 8\nExplanation: The substrings with one distinct letter are \"aaa\", \"aa\", \"a\", \"b\".\n\"aaa\" occurs 1 time.\n\"aa\" occurs 2 times.\n\"a\" occurs 4 times.\n\"b\" occurs 1 time.\nSo the answer is 1 + 2 + 4 + 1 = 8.\n\nExample 2:\n\nInput: s = \"aaaaaaaaaa\"\nOutput: 55\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 1000\ns[i] consists of only lowercase English letters. Explanation:\n\nSolution 1: Two Pointers\nWe can use two pointers, where pointer $i$ points to the start of the current substring, and pointer $j$ moves to the right to the first position that is different from $s[i]$. Then, $[i,..j-1]$ is a substring with $s[i]$ as the only character, and its length is $j-i$. Therefore, the number of substrings with $s[i]$ as the only character is $\\frac{(j-i+1)(j-i)}{2}$, which is added to the answer. Then, we set $i=j$ and continue to traverse until $i$ exceeds the range of string $s$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\u00a0\nExample 1:\n\nInput: s = \"the sky is blue\"\nOutput: \"blue is sky the\"\n\nExample 2:\n\nInput: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\nExample 3:\n\nInput: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space? Explanation:\n\nSolution 1: Two Pointers\nWe can use two pointers $i$ and $j$ to find each word, add it to the result list, then reverse the result list, and finally concatenate it into a string.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the string. \n\n", "problem_ids": ["most-frequent-even-element", "count-substrings-with-only-one-distinct-letter", "reverse-words-in-a-string"]}, "2845": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\u00a0\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nExample 2:\n\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\u00a0\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000 Explanation:\n\nSolution 1: In-place Rotation\nAccording to the problem requirements, we actually need to rotate $matrix[i][j]$ to $matrix[j][n - i - 1]$.\nWe can first flip the matrix upside down, that is, swap $matrix[i][j]$ and $matrix[n - i - 1][j]$, and then flip the matrix along the main diagonal, that is, swap $matrix[i][j]$ and $matrix[j][i]$. This way, we can rotate $matrix[i][j]$ to $matrix[j][n - i - 1]$.\nThe time complexity is $O(n^2)$, where $n$ is the side length of the matrix. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\n\u00a0\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums is guaranteed to be rotated at some pivot.\n-104 <= target <= 104\n\n\u00a0\nFollow up: This problem is similar to\u00a0Search in Rotated Sorted Array, but\u00a0nums may contain duplicates. Would this affect the runtime complexity? How and why? Explanation:\n\nSolution 1: Binary Search\nWe define the left boundary $l=0$ and the right boundary $r=n-1$ for the binary search, where $n$ is the length of the array.\nDuring each binary search process, we get the current midpoint $mid=(l+r)/2$.\n\nIf $nums[mid] \\gt nums[r]$, it means that $[l,mid]$ is ordered. At this time, if $nums[l] \\le target \\le nums[mid]$, it means that $target$ is in $[l,mid]$, otherwise $target$ is in $[mid+1,r]$.\nIf $nums[mid] \\lt nums[r]$, it means that $[mid+1,r]$ is ordered. At this time, if $nums[mid] \\lt target \\le nums[r]$, it means that $target$ is in $[mid+1,r]$, otherwise $target$ is in $[l,mid]$.\nIf $nums[mid] = nums[r]$, it means that the elements $nums[mid]$ and $nums[r]$ are equal. At this time, we cannot determine which interval $target$ is in, so we can only decrease $r$ by $1$.\n\nAfter the binary search ends, if $nums[l] = target$, it means that the target value $target$ exists in the array, otherwise it means it does not exist.\nThe time complexity is approximately $O(\\log n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer n and an integer start.\nDefine an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length.\nReturn the bitwise XOR of all elements of nums.\n\u00a0\nExample 1:\n\nInput: n = 5, start = 0\nOutput: 8\nExplanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\nWhere \"^\" corresponds to bitwise XOR operator.\n\nExample 2:\n\nInput: n = 4, start = 3\nOutput: 8\nExplanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.\n\n\u00a0\nConstraints:\n\n1 <= n <= 1000\n0 <= start <= 1000\nn == nums.length Explanation:\n\nSolution 1: Simulation\nWe can directly simulate to calculate the XOR result of all elements in the array.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["rotate-image", "search-in-rotated-sorted-array-ii", "xor-operation-in-an-array"]}, "2847": {"text": "Similar Problem 1 \n\n Problem:\n\nDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\nMachine 1 (sender) has the function:\n\nstring encode(vector<string> strs) {\n  // ... your code\n  return encoded_string;\n}\nMachine 2 (receiver) has the function:\n\nvector<string> decode(string s) {\n  //... your code\n  return strs;\n}\n\nSo Machine 1 does:\n\nstring encoded_string = encode(strs);\n\nand Machine 2 does:\n\nvector<string> strs2 = decode(encoded_string);\n\nstrs2 in Machine 2 should be the same as strs in Machine 1.\nImplement the encode and decode methods.\nYou are not allowed to\u00a0solve the problem using any serialize methods (such as eval).\n\u00a0\nExample 1:\n\nInput: dummy_input = [\"Hello\",\"World\"]\nOutput: [\"Hello\",\"World\"]\nExplanation:\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nString[] strs = decoder.decode(msg);\n\nExample 2:\n\nInput: dummy_input = [\"\"]\nOutput: [\"\"]\n\n\u00a0\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] contains any possible characters out of 256 valid ASCII characters.\n\n\u00a0\nFollow up: Could you write a generalized algorithm to work on any possible set of characters? Explanation:\n\nSolution 1: Encode String Length\nDuring encoding, we convert the length of the string into a fixed 4-digit string, add the string itself, and append it to the result string in sequence.\nDuring decoding, we first take the first four digits of the string to get the length, and then cut the following string according to the length. We cut it in sequence until we get the list of strings.\nThe time complexity is $O(n)$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is a strange printer with the following two special properties:\n\nThe printer can only print a sequence of the same character each time.\nAt each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string s, return the minimum number of turns the printer needed to print it.\n\u00a0\nExample 1:\n\nInput: s = \"aaabbb\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"bbb\".\n\nExample 2:\n\nInput: s = \"aba\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 100\ns consists of lowercase English letters. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i][j]$ as the minimum operations to print $s[i..j]$, with the initial value $f[i][j]=\\infty$, and the answer is $f[0][n-1]$, where $n$ is the length of string $s$.\nConsider $f[i][j]$, if $s[i] = s[j]$, we can print $s[j]$ when print $s[i]$, so we can ignore $s[j]$ and continue to print $s[i+1..j-1]$. If $s[i] \\neq s[j]$, we need to print the substring separately, i.e. $s[i..k]$ and $s[k+1..j]$, where $k \\in [i,j)$. So we can have the following transition equation:\n$$\nf[i][j]=\n\\begin{cases}\n1, & \\textit{if } i=j \\\nf[i][j-1], & \\textit{if } s[i]=s[j] \\\n\\min_{i \\leq k < j} {f[i][k]+f[k+1][j]}, & \\textit{otherwise}\n\\end{cases}\n$$\nWe can enumerate $i$ from large to small and $j$ from small to large, so that we can ensure that $f[i][j-1]$, $f[i][k]$ and $f[k+1][j]$ have been calculated when we calculate $f[i][j]$.\nThe time complexity is $O(n^3)$ and the space complexity is $O(n^2)$. Where $n$ is the length of string $s$. \n\nSimilar Problem 3 \n\n Problem:\n\nThere exist two undirected trees with n and m nodes, numbered from 0 to n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree.\nYou must connect one node from the first tree with another node from the second tree with an edge.\nReturn the minimum possible diameter of the resulting tree.\nThe diameter of a tree is the length of the longest path between any two nodes in the tree.\n\u00a0\nExample 1:\n\nInput: edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]\nOutput: 3\nExplanation:\nWe can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree.\n\nExample 2:\n\n\nInput: edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\nOutput: 5\nExplanation:\nWe can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.\n\n\u00a0\nConstraints:\n\n1 <= n, m <= 105\nedges1.length == n - 1\nedges2.length == m - 1\nedges1[i].length == edges2[i].length == 2\nedges1[i] = [ai, bi]\n0 <= ai, bi < n\nedges2[i] = [ui, vi]\n0 <= ui, vi < m\nThe input is generated such that edges1 and edges2 represent valid trees. Explanation:\n\nSolution 1: Two DFS Passes\nWe denote $d_1$ and $d_2$ as the diameters of the two trees, respectively. Then, the diameter of the merged tree can be one of the following two cases:\n\nThe diameter of the merged tree is the diameter of one of the original trees, i.e., $\\max(d_1, d_2)$;\nThe diameter of the merged tree passes through both of the original trees. We calculate the radii of the original two trees as $r_1 = \\lceil \\frac{d_1}{2} \\rceil$ and $r_2 = \\lceil \\frac{d_2}{2} \\rceil$, respectively. Then, the diameter of the merged tree is $r_1 + r_2 + 1$.\n\nWe take the maximum of these two cases.\nWhen calculating the diameter of a tree, we can use two DFS passes. First, we arbitrarily select a node and start a DFS from this node to find the farthest node from it, denoted as node $a$. Then, we start another DFS from node $a$ to find the farthest node from node $a$, denoted as node $b$. It can be proven that the path between node $a$ and node $b$ is the diameter of the tree.\nThe time complexity is $O(n + m)$, and the space complexity is $O(n + m)$, where $n$ and $m$ are the number of nodes in the two trees, respectively. \n\n", "problem_ids": ["encode-and-decode-strings", "strange-printer", "find-minimum-diameter-after-merging-two-trees"]}, "2848": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n\nExample 2:\n\n\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1 Explanation:\n\nSolution 1: Two DFS Traversals\nFirst, we perform a DFS traversal to determine whether there is a path from $(0, 0)$ to $(m - 1, n - 1)$, and we denote the result as $a$. During the DFS process, we set the value of the visited cells to $0$ to prevent revisiting.\nNext, we set the values of $(0, 0)$ and $(m - 1, n - 1)$ to $1$, and perform another DFS traversal to determine whether there is a path from $(0, 0)$ to $(m - 1, n - 1)$, and we denote the result as $b$. During the DFS process, we set the value of the visited cells to $0$ to avoid revisiting.\nFinally, if both $a$ and $b$ are true, we return false, otherwise, we return true.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows and columns of the matrix, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an array nums of integers, a move\u00a0consists of choosing any element and decreasing it by 1.\nAn array A is a\u00a0zigzag array\u00a0if either:\n\nEvery even-indexed element is greater than adjacent elements, ie.\u00a0A[0] > A[1] < A[2] > A[3] < A[4] > ...\nOR, every odd-indexed element is greater than adjacent elements, ie.\u00a0A[0] < A[1] > A[2] < A[3] > A[4] < ...\n\nReturn the minimum number of moves to transform the given array nums into a zigzag array.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: 2\nExplanation: We can decrease 2 to 0 or 3 to 1.\n\nExample 2:\n\nInput: nums = [9,6,1,6,2]\nOutput: 4\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000 Explanation:\n\nSolution 1: Enumeration + Greedy\nWe can separately enumerate the even and odd positions as the elements \"smaller than adjacent elements\", and then calculate the required number of operations. The minimum of the two is taken.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value.\nIf it is possible, return any [i, j] with i + 1 < j, such that:\n\narr[0], arr[1], ..., arr[i] is the first part,\narr[i + 1], arr[i + 2], ..., arr[j - 1] is the second part, and\narr[j], arr[j + 1], ..., arr[arr.length - 1] is the third part.\nAll three parts have equal binary values.\n\nIf it is not possible, return [-1, -1].\nNote that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.\n\u00a0\nExample 1:\nInput: arr = [1,0,1,0,1]\nOutput: [0,3]\n\nExample 2:\nInput: arr = [1,1,0,1,1]\nOutput: [-1,-1]\n\nExample 3:\nInput: arr = [1,1,0,0,1]\nOutput: [0,2]\n\n\u00a0\nConstraints:\n\n3 <= arr.length <= 3 * 104\narr[i] is 0 or 1 Explanation:\n\nSolution 1: Counting + Three Pointers\nWe denote the length of the array as $n$, and the number of '1's in the array as $cnt$.\nObviously, $cnt$ must be a multiple of $3$, otherwise the array cannot be divided into three equal parts, and we can return $[-1, -1]$ in advance. If $cnt$ is $0$, it means that all elements in the array are '0', and we can directly return $[0, n - 1]$.\nWe divide $cnt$ by $3$ to get the number of '1's in each part, and then find the position of the first '1' in each part in the array arr (refer to the $find(x)$ function in the following code), denoted as $i$, $j$, $k$ respectively.\nbash\n0 1 1 0 0 0 1 1 0 0 0 0 0 1 1 0 0\n  ^         ^             ^\n  i         j             k\nThen we start from $i$, $j$, $k$ and traverse each part at the same time, check whether the corresponding values of the three parts are equal. If they are, continue to traverse until $k$ reaches the end of arr.\nbash\n0 1 1 0 0 0 1 1 0 0 0 0 0 1 1 0 0\n          ^         ^             ^\n          i         j             k\nAt the end of the traversal, if $k=n$, it means that it satisfies the three equal parts, and we return $[i - 1, j]$ as the answer, otherwise return $[-1, -1]$.\nThe time complexity is $O(n)$, where $n$ is the length of arr. The space complexity is $O(1)$.\nSimilar problems:\n\n1573. Number of Ways to Split a String \n\n", "problem_ids": ["disconnect-path-in-a-binary-matrix-by-at-most-one-flip", "decrease-elements-to-make-array-zigzag", "three-equal-parts"]}, "2849": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j].\nReturn the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions.\n\u00a0\nExample 1:\n\nInput: nums = [18,43,36,13,7]\nOutput: 54\nExplanation: The pairs (i, j) that satisfy the conditions are:\n- (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.\n- (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.\nSo the maximum sum that we can obtain is 54.\n\nExample 2:\n\nInput: nums = [10,12,19,14]\nOutput: -1\nExplanation: There are no two numbers that satisfy the conditions, so we return -1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Hash Table\nWe can use a hash table $d$ to record the maximum value corresponding to each digit sum, and initialize an answer variable $ans = -1$.\nNext, we traverse the array $nums$. For each number $v$, we calculate its digit sum $x$. If $x$ exists in the hash table $d$, then we update the answer $ans = \\max(ans, d[x] + v)$. Then update the hash table $d[x] = \\max(d[x], v)$.\nFinally, return the answer $ans$.\nSince the maximum element in $nums$ is $10^9$, the maximum digit sum is $9 \\times 9 = 81$. We can directly define an array $d$ of length $100$ to replace the hash table.\nThe time complexity is $O(n \\times \\log M)$, and the space complexity is $O(D)$. Here, $n$ is the length of the array $nums$, and $M$ and $D$ are the maximum value of the elements in the array $nums$ and the maximum value of the digit sum, respectively. In this problem, $M \\leq 10^9$, $D \\leq 81$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.\n\u00a0\nExample 1:\n\n\nInput: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n\nExample 2:\n\nInput: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted.\n\n\u00a0\nConstraints:\n\n1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree. Explanation:\n\nSolution 1: Enumeration of Connected Blocks\nAssume the number of connected blocks is $k$, then the number of edges to be deleted is $k-1$, and the value of each connected block is $\\frac{s}{k}$, where $s$ is the sum of the values of all nodes in $nums$.\nWe enumerate $k$ from large to small. If there exists a $k$ such that $\\frac{s}{k}$ is an integer, and the value of each connected block obtained is equal, then directly return $k-1$. The initial value of $k$ is $\\min(n, \\frac{s}{mx})$, where $mx$ is the maximum value in $nums$.\nThe key point is to judge whether for a given $\\frac{s}{k}$, it is possible to divide several subtrees such that the value of each subtree is $\\frac{s}{k}$.\nHere we use the dfs function to judge. We recursively traverse from top to bottom to calculate the value of each subtree. If the sum of the subtree values is exactly $\\frac{s}{k}$, it means that the division is successful at this time. We set the value to $0$ and return it to the upper level, indicating that this subtree can be disconnected from the parent node. If the sum of the subtree values is greater than $\\frac{s}{k}$, it means that the division fails at this time. We return $-1$, indicating that it cannot be divided.\nThe time complexity is $O(n \\times \\sqrt{s})$, where $n$ and $s$ are the length of $nums$ and the sum of the values of all nodes in $nums$, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and an integer value.\nIn one operation, you can add or subtract value from any element of nums.\n\nFor example, if nums = [1,2,3] and value = 2, you can choose to subtract value from nums[0] to make nums = [-1,2,3].\n\nThe MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.\n\nFor example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.\n\nReturn the maximum MEX of nums after applying the mentioned operation any number of times.\n\u00a0\nExample 1:\n\nInput: nums = [1,-10,7,13,6,8], value = 5\nOutput: 4\nExplanation: One can achieve this result by applying the following operations:\n- Add value to nums[1] twice to make nums = [1,0,7,13,6,8]\n- Subtract value from nums[2] once to make nums = [1,0,2,13,6,8]\n- Subtract value from nums[3] twice to make nums = [1,0,2,3,6,8]\nThe MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve.\n\nExample 2:\n\nInput: nums = [1,-10,7,13,6,8], value = 7\nOutput: 2\nExplanation: One can achieve this result by applying the following operation:\n- subtract value from nums[2] once to make nums = [1,-10,0,13,6,8]\nThe MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve.\n\n\u00a0\nConstraints:\n\n1 <= nums.length, value <= 105\n-109 <= nums[i] <= 109 Explanation:\n\nSolution 1: Count\nWe use a hash table or array $cnt$ to count the number of times each remainder of $value$ is taken modulo in the array.\nThen start from $0$ and traverse, for the current number $i$ traversed, if $cnt[i \\bmod value]$ is $0$, it means that there is no number in the array that takes $i$ modulo $value$ as the remainder, then $i$ is the MEX of the array, and return directly. Otherwise, reduce $cnt[i \\bmod value]$ by $1$ and continue to traverse.\nThe time complexity is $O(n)$ and the space complexity is $O(value)$. Where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["max-sum-of-a-pair-with-equal-sum-of-digits", "create-components-with-same-value", "smallest-missing-non-negative-integer-after-operations"]}, "2850": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b customer has in the j\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b bank. Return the wealth that the richest customer has.\nA customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.\n\u00a0\nExample 1:\n\nInput: accounts = [[1,2,3],[3,2,1]]\nOutput: 6\nExplanation:\n1st customer has wealth = 1 + 2 + 3 = 6\n2nd customer has wealth = 3 + 2 + 1 = 6\nBoth customers are considered the richest with a wealth of 6 each, so return 6.\n\nExample 2:\n\nInput: accounts = [[1,5],[7,3],[3,5]]\nOutput: 10\nExplanation: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.\nExample 3:\n\nInput: accounts = [[2,8,7],[7,1,3],[1,9,5]]\nOutput: 17\n\n\u00a0\nConstraints:\n\nm ==\u00a0accounts.length\nn ==\u00a0accounts[i].length\n1 <= m, n <= 50\n1 <= accounts[i][j] <= 100 Explanation:\n\nSolution 1: Summation\nWe traverse accounts and find the maximum sum of each row.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns in the grid, respectively. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an array of integers nums, calculate the pivot index of this array.\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\nReturn the leftmost pivot index. If no such index exists, return -1.\n\u00a0\nExample 1:\n\nInput: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation:\nThe pivot index is 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement.\nExample 3:\n\nInput: nums = [2,1,-1]\nOutput: 0\nExplanation:\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n-1000 <= nums[i] <= 1000\n\n\u00a0\nNote: This question is the same as\u00a01991:\u00a0https://leetcode.com/problems/find-the-middle-index-in-array/ Explanation:\n\nSolution 1: Prefix Sum\nWe define a variable $left$ to represent the sum of elements to the left of index $i$ in the array $\\textit{nums}$, and a variable $right$ to represent the sum of elements to the right of index $i$ in the array $\\textit{nums}$. Initially, $left = 0$, $right = \\sum_{i = 0}^{n - 1} nums[i]$.\nWe traverse the array $\\textit{nums}$. For the current number $x$ being traversed, we update $right = right - x$. At this point, if $left = right$, it indicates that the current index $i$ is the middle position, and we can return it directly. Otherwise, we update $left = left + x$ and continue to traverse the next number.\nIf the middle position is not found by the end of the traversal, return $-1$.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array $\\textit{nums}$.\nSimilar Problems:\n\n1991. Find the Middle Index in Array\n2574. Left and Right Sum Differences \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two 0-indexed strings source and target, both of length n and consisting of lowercase English characters. You are also given two 0-indexed string arrays original and changed, and an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i].\nYou start with the string source. In one operation, you can pick a substring x from the string, and change it to y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. You are allowed to do any number of operations, but any pair of operations must satisfy either of these two conditions:\n\nThe substrings picked in the operations are source[a..b] and source[c..d] with either b < c or d < a. In other words, the indices picked in both operations are disjoint.\nThe substrings picked in the operations are source[a..b] and source[c..d] with a == c and b == d. In other words, the indices picked in both operations are identical.\n\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\n\u00a0\nExample 1:\n\nInput: source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\nOutput: 28\nExplanation: To convert \"abcd\" to \"acbe\", do the following operations:\n- Change substring source[1..1] from \"b\" to \"c\" at a cost of 5.\n- Change substring source[2..2] from \"c\" to \"e\" at a cost of 1.\n- Change substring source[2..2] from \"e\" to \"b\" at a cost of 2.\n- Change substring source[3..3] from \"d\" to \"e\" at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28. \nIt can be shown that this is the minimum possible cost.\n\nExample 2:\n\nInput: source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]\nOutput: 9\nExplanation: To convert \"abcdefgh\" to \"acdeeghh\", do the following operations:\n- Change substring source[1..3] from \"bcd\" to \"cde\" at a cost of 1.\n- Change substring source[5..7] from \"fgh\" to \"thh\" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.\n- Change substring source[5..7] from \"thh\" to \"ghh\" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.\nThe total cost incurred is 1 + 3 + 5 = 9.\nIt can be shown that this is the minimum possible cost.\n\nExample 3:\n\nInput: source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]\nOutput: -1\nExplanation: It is impossible to convert \"abcdefgh\" to \"addddddd\".\nIf you select substring source[1..3] as the first operation to change \"abcdefgh\" to \"adddefgh\", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.\nIf you select substring source[3..7] as the first operation to change \"abcdefgh\" to \"abcddddd\", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.\n\n\u00a0\nConstraints:\n\n1 <= source.length == target.length <= 1000\nsource, target consist only of lowercase English characters.\n1 <= cost.length == original.length == changed.length <= 100\n1 <= original[i].length == changed[i].length <= source.length\noriginal[i], changed[i] consist only of lowercase English characters.\noriginal[i] != changed[i]\n1 <= cost[i] <= 106 Explanation:\n\nSolution 1: Trie + Floyd Algorithm + Memoization Search\nAccording to the problem description, we can consider each string as a node, and the conversion cost between each pair of strings as a directed edge. We first initialize a $26 \\times 26$ two-dimensional array $g$, where $g[i][j]$ represents the minimum cost of converting string $i$ to string $j$. Initially, $g[i][j] = \\infty$, and if $i = j$, then $g[i][j] = 0$. Here, we can use a trie to store the strings in original and changed along with their corresponding integer identifiers.\nNext, we use the Floyd algorithm to calculate the minimum cost between any two strings.\nThen, we define a function $dfs(i)$ to represent the minimum cost of converting the string $source[i..]$ to the string $target[i..]$. The answer is $dfs(0)$.\nThe calculation process of the function $dfs(i)$ is as follows:\n\nIf $i \\geq |source|$, no conversion is needed, return $0$.\nOtherwise, if $source[i] = target[i]$, we can skip directly and recursively calculate $dfs(i + 1)$. We can also enumerate the index $j$ in the range $[i, |source|)$, if $source[i..j]$ and $target[i..j]$ are both in the trie, and their corresponding integer identifiers $x$ and $y$ are both greater than or equal to $0$, then we can add $dfs(j + 1)$ and $g[x][y]$ to get the cost of one conversion scheme, and we take the minimum value among all schemes.\n\nIn summary, we can get:\n$$\ndfs(i) = \\begin{cases}\n0, & i \\geq |source| \\\ndfs(i + 1), & source[i] = target[i] \\\n\\min_{i \\leq j < |source|} { dfs(j + 1) + g[x][y] }, & \\textit{otherwise}\n\\end{cases}\n$$\nWhere $x$ and $y$ are the integer identifiers of $source[i..j]$ and $target[i..j]$ in the trie, respectively.\nTo avoid repeated calculations, we can use memoization search.\nThe time complexity is $O(m^3 + n^2 + m \\times n)$, and the space complexity is $O(m^2 + m \\times n + n)$. Where $m$ and $n$ are the lengths of the arrays original and source, respectively. \n\n", "problem_ids": ["richest-customer-wealth", "find-pivot-index", "minimum-cost-to-convert-string-ii"]}, "2854": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string target, an array of strings words, and an integer array costs, both arrays of the same length.\nImagine an empty string s.\nYou can perform the following operation any number of times (including zero):\n\nChoose an index i in the range [0, words.length - 1].\nAppend words[i] to s.\nThe cost of operation is costs[i].\n\nReturn the minimum cost to make s equal to target. If it's not possible, return -1.\n\u00a0\nExample 1:\n\nInput: target = \"abcdef\", words = [\"abdef\",\"abc\",\"d\",\"def\",\"ef\"], costs = [100,1,1,10,5]\nOutput: 7\nExplanation:\nThe minimum cost can be achieved by performing the following operations:\n\nSelect index 1 and append \"abc\" to s at a cost of 1, resulting in s = \"abc\".\nSelect index 2 and append \"d\" to s at a cost of 1, resulting in s = \"abcd\".\nSelect index 4 and append \"ef\" to s at a cost of 5, resulting in s = \"abcdef\".\n\n\nExample 2:\n\nInput: target = \"aaaa\", words = [\"z\",\"zz\",\"zzz\"], costs = [1,10,100]\nOutput: -1\nExplanation:\nIt is impossible to make s equal to target, so we return -1.\n\n\u00a0\nConstraints:\n\n1 <= target.length <= 2000\n1 <= words.length == costs.length <= 50\n1 <= words[i].length <= target.length\ntarget and words[i] consist only of lowercase English letters.\n1 <= costs[i] <= 105 Explanation:\n\nSolution 1: Trie + Memoized Search\nWe first create a Trie $\\textit{trie}$, where each node in the Trie contains an array $\\textit{children}$ of length $26$, and each element in the array is a pointer to the next node. Each node in the Trie also contains a $\\textit{cost}$ variable, which represents the minimum cost from the root node to the current node.\nWe traverse the $\\textit{words}$ array, inserting each word into the Trie while updating the $\\textit{cost}$ variable for each node.\nNext, we define a memoized search function $\\textit{dfs}(i)$, which represents the minimum cost to construct the string starting from $\\textit{target}[i]$. The answer is $\\textit{dfs}(0)$.\nThe calculation process of the function $\\textit{dfs}(i)$ is as follows:\n\nIf $i \\geq \\textit{len}(\\textit{target})$, it means the entire string has been constructed, so return $0$.\nOtherwise, we start from the root node of the $\\textit{trie}$ and traverse all suffixes starting from $\\textit{target}[i]$, finding the minimum cost, which is the $\\textit{cost}$ variable in the $\\textit{trie}$, plus the result of $\\textit{dfs}(j+1)$, where $j$ is the ending position of the suffix starting from $\\textit{target}[i]$.\n\nFinally, if $\\textit{dfs}(0) < \\textit{inf}$, return $\\textit{dfs}(0)$; otherwise, return $-1$.\nThe time complexity is $O(n^2 + L)$, and the space complexity is $O(n + L)$. Here, $n$ is the length of $\\textit{target}$, and $L$ is the sum of the lengths of all words in the $\\textit{words}$ array. \n\nSimilar Problem 2 \n\n Problem:\n\nTable: Customers\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID and name of a customer.\n\n\u00a0\nTable: Orders\n\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\ncustomerId is a foreign key (reference columns) of the ID from the Customers table.\nEach row of this table indicates the ID of an order and the ID of the customer who ordered it.\n\n\u00a0\nWrite a solution to find all customers who never order anything.\nReturn the result table in any order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\nOutput: \n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+ Explanation:\n\nSolution 1: NOT IN\nList all customer IDs of existing orders, and use NOT IN to find customers who are not in the list. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer n. There are n rooms numbered from 0 to n - 1.\nYou are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.\nMeetings are allocated to rooms in the following manner:\n\nEach meeting will take place in the unused room with the lowest number.\nIf there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.\nWhen a room becomes unused, meetings that have an earlier original start time should be given the room.\n\nReturn the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.\nA half-closed interval [a, b) is the interval between a and b including a and not including b.\n\u00a0\nExample 1:\n\nInput: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]\nOutput: 0\nExplanation:\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\nExample 2:\n\nInput: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\nOutput: 1\nExplanation:\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n\n\u00a0\nConstraints:\n\n1 <= n <= 100\n1 <= meetings.length <= 105\nmeetings[i].length == 2\n0 <= starti < endi <= 5 * 105\nAll the values of starti are unique. Explanation:\n\nSolution 1: Priority Queue (Min Heap)\nWe define two priority queues, representing idle meeting rooms and busy meeting rooms, respectively. Among them: the idle meeting rooms idle are sorted according to index; while the busy meeting rooms busy are sorted according to end time, index.\nFirst, sort the meetings by start time, then traverse the meetings. For each meeting:\n\nIf there is a busy meeting room that is less than or equal to the start time of the current meeting, add it to the idle meeting room queue idle.\nIf there are currently idle meeting rooms, take out the meeting room with the smallest weight from the idle queue idle and add it to the busy queue busy.\nIf there are currently no idle meeting rooms, find the meeting room with the earliest end time and smallest index in the busy queue busy, and re-add it to the busy queue busy.\n\nThe time complexity is $O(m \\times \\log m)$, where $m$ is the number of meetings.\nSimilar problems:\n\n1882. Process Tasks Using Servers \n\n", "problem_ids": ["construct-string-with-minimum-cost-(easy)", "customers-who-never-order", "meeting-rooms-iii"]}, "2855": {"text": "Similar Problem 1 \n\n Problem:\n\nSome robots are standing on an infinite number line with their initial coordinates given by a 0-indexed integer array nums and will start moving once given the command to move. The robots will move a unit distance each second.\nYou are given a string s denoting the direction in which robots will move on command. 'L' means the robot will move towards the left side or negative side of the number line, whereas 'R' means the robot will move towards the right side or positive side of the number line.\nIf two robots collide, they will start moving in opposite directions.\nReturn the sum of distances between all the\u00a0pairs of robots d seconds after\u00a0the command. Since the sum can be very large, return it modulo 109 + 7.\nNote: \n\nFor two robots at the index i and j, pair (i,j) and pair (j,i) are considered the same pair.\nWhen robots collide, they instantly change their directions without wasting any time.\nCollision happens\u00a0when two robots share the same place in a\u00a0moment.\n    \nFor example, if a robot is positioned in 0 going to the right and another is positioned in 2 going to the left, the next second they'll be both in 1 and they will change direction and the next second the first one will be in 0, heading left, and another will be in 2, heading right.\nFor example,\u00a0if a robot is positioned in 0 going to the right and another is positioned in 1\u00a0going to the left, the next second the first one will be in 0, heading left, and another will be in 1, heading right.\n\n\n\n\u00a0\nExample 1:\n\nInput: nums = [-2,0,2], s = \"RLL\", d = 3\nOutput: 8\nExplanation: \nAfter 1 second, the positions are [-1,-1,1]. Now, the robot at index 0 will move left, and the robot at index 1 will move right.\nAfter 2 seconds, the positions are [-2,0,0]. Now, the robot at index 1 will move left, and the robot at index 2 will move right.\nAfter 3 seconds, the positions are [-3,-1,1].\nThe distance between the robot at index 0 and 1 is abs(-3 - (-1)) = 2.\nThe distance between the robot at index 0 and 2 is abs(-3 - 1) = 4.\nThe distance between the robot at index 1 and 2 is abs(-1 - 1) = 2.\nThe sum of the pairs of all distances = 2 + 4 + 2 = 8.\n\nExample 2:\n\nInput: nums = [1,0], s = \"RL\", d = 2\nOutput: 5\nExplanation: \nAfter 1 second, the positions are [2,-1].\nAfter 2 seconds, the positions are [3,-2].\nThe distance between the two robots is abs(-2 - 3) = 5.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 105\n-2 * 109\u00a0<= nums[i] <= 2 * 109\n0 <= d <= 109\nnums.length == s.length\u00a0\ns consists of 'L' and 'R' only\nnums[i]\u00a0will be unique. Explanation:\n\nSolution 1: Quick thinking + Sorting\nAfter two robots collide, they will immediately change direction, which is equivalent to the two robots continuing to move in their original direction. Therefore, we traverse the array $nums$, and according to the instructions in the string $s$, we add or subtract $d$ from the position of each robot, and then sort the array $nums$.\nNext, we enumerate the position of each robot from small to large, and calculate the sum of the distances between the current robot and all robots in front, which is the answer.\nThe time complexity is $O(n \\times \\log n)$ and the space complexity is $O(n)$, where $n$ is the number of robots. \n\nSimilar Problem 2 \n\n Problem:\n\nA maximum tree is a tree where every node has a value greater than any other value in its subtree.\nYou are given the root of a maximum binary tree and an integer val.\nJust as in the previous problem, the given tree was constructed from a list a (root = Construct(a)) recursively with the following Construct(a) routine:\n\nIf a is empty, return null.\nOtherwise, let a[i] be the largest element of a. Create a root node with the value a[i].\nThe left child of root will be Construct([a[0], a[1], ..., a[i - 1]]).\nThe right child of root will be Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]).\nReturn root.\n\nNote that we were not given a directly, only a root node root = Construct(a).\nSuppose b is a copy of a with the value val appended to it. It is guaranteed that b has unique values.\nReturn Construct(b).\n\u00a0\nExample 1:\n\n\nInput: root = [4,1,3,null,null,2], val = 5\nOutput: [5,4,null,1,3,null,null,2]\nExplanation: a = [1,4,2,3], b = [1,4,2,3,5]\n\nExample 2:\n\n\nInput: root = [5,2,4,null,1], val = 3\nOutput: [5,2,4,null,1,null,3]\nExplanation: a = [2,1,5,4], b = [2,1,5,4,3]\n\nExample 3:\n\n\nInput: root = [5,2,3,null,1], val = 4\nOutput: [5,2,4,null,1,3]\nExplanation: a = [2,1,5,3], b = [2,1,5,3,4]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 100].\n1 <= Node.val <= 100\nAll the values of the tree are unique.\n1 <= val <= 100 Explanation:\n\nSolution 1: Recursion\nIf $val$ is the maximum number, then make $val$ the new root node, and $root$ the left subtree of the new root node.\nIf $val$ is not the maximum number, since $val$ is the last appended number, it must be on the right side of $root$. Therefore, we can insert $val$ as a new node into the right subtree of $root$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the tree. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer matrix grid and an integer k.\nReturn the number of submatrices that contain the top-left element of the grid, and have a sum less than or equal to k.\n\u00a0\nExample 1:\n\n\nInput: grid = [[7,6,3],[6,6,1]], k = 18\nOutput: 4\nExplanation: There are only 4 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 18.\nExample 2:\n\n\nInput: grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20\nOutput: 6\nExplanation: There are only 6 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 20.\n\n\u00a0\nConstraints:\n\nm == grid.length \nn == grid[i].length\n1 <= n, m <= 1000 \n0 <= grid[i][j] <= 1000\n1 <= k <= 109 Explanation:\n\nSolution 1: Two-Dimensional Prefix Sum\nThe problem is actually asking for the number of prefix submatrices in a two-dimensional matrix whose sum is less than or equal to $k$.\nThe calculation formula for the two-dimensional prefix sum is:\n$$\ns[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + x\n$$\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. \n\n", "problem_ids": ["movement-of-robots", "maximum-binary-tree-ii", "count-submatrices-with-top-left-element-and-sum-less-than-k"]}, "2856": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 2D integer array points, where points[i] = [xi, yi]. You are also given an integer w. Your task is to cover all the given points with rectangles.\nEach rectangle has its lower end at some point (x1, 0) and its upper end at some point (x2, y2), where x1 <= x2, y2 >= 0, and the condition x2 - x1 <= w must be satisfied for each rectangle.\nA point is considered covered by a rectangle if it lies within or on the boundary of the rectangle.\nReturn an integer denoting the minimum number of rectangles needed so that each point is covered by at least one rectangle.\nNote: A point may be covered by more than one rectangle.\n\u00a0\nExample 1:\n\n\nInput: points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1\nOutput: 2\nExplanation: \nThe image above shows one possible placement of rectangles to cover the points:\n\nA rectangle with a lower end at (1, 0) and its upper end at (2, 8)\nA rectangle with a lower end at (3, 0) and its upper end at (4, 8)\n\n\nExample 2:\n\n\nInput: points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2\nOutput: 3\nExplanation: \nThe image above shows one possible placement of rectangles to cover the points:\n\nA rectangle with a lower end at (0, 0) and its upper end at (2, 2)\nA rectangle with a lower end at (3, 0) and its upper end at (5, 5)\nA rectangle with a lower end at (6, 0) and its upper end at (6, 6)\n\n\nExample 3:\n\n\nInput: points = [[2,3],[1,2]], w = 0\nOutput: 2\nExplanation: \nThe image above shows one possible placement of rectangles to cover the points:\n\nA rectangle with a lower end at (1, 0) and its upper end at (1, 2)\nA rectangle with a lower end at (2, 0) and its upper end at (2, 3)\n\n\n\u00a0\nConstraints:\n\n1 <= points.length <= 105\npoints[i].length == 2\n0 <= xi == points[i][0] <= 109\n0 <= yi == points[i][1] <= 109\n0 <= w <= 109\nAll pairs (xi, yi) are distinct. Explanation:\n\nSolution 1: Greedy + Sorting\nAccording to the problem description, we do not need to consider the height of the rectangles, only the width.\nWe can sort all the points by their x-coordinates and use a variable $x_1$ to record the rightmost x-coordinate that the current rectangle can cover. Initially, $x_1 = -1$.\nNext, we iterate through all the points. If the current point's x-coordinate $x$ is greater than $x_1$, it means the existing rectangle cannot cover the current point. We need to add a new rectangle, increment the answer by one, and update $x_1 = x + w$.\nAfter completing the iteration, we obtain the minimum number of rectangles needed.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the number of points. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n\u00a0\nExample 1:\n\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n\u00a0\nConstraints:\n\nn == height.length\n2 <= n <= 105\n0 <= height[i] <= 104 Explanation:\n\nSolution 1: Two Pointers\nInitially, we consider the capacity of the water that the two farthest pillars can hold. The width of the water is the distance between the two pillars, and the height of the water depends on the shorter one between the two pillars.\nThe current pillars are the pillars on the farthest sides, so the width of the water is the largest. For other combinations, the width of the water is smaller. Suppose the height of the left pillar is less than or equal to the height of the right pillar, then the height of the water is the height of the left pillar. If we move the right pillar, the width of the water will decrease, but the height of the water will not increase, so the capacity of the water will definitely decrease. Therefore, we move the left pillar and update the maximum capacity.\nRepeat this process until the two pillars meet.\nThe time complexity is $O(n)$, where $n$ is the length of the array height. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences.\nReturn the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\nExample 1:\n\nInput: nums = [3,6,1,2,5], k = 2\nOutput: 2\nExplanation:\nWe can partition nums into the two subsequences [3,1,2] and [6,5].\nThe difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\nThe difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\nSince two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.\n\nExample 2:\n\nInput: nums = [1,2,3], k = 1\nOutput: 2\nExplanation:\nWe can partition nums into the two subsequences [1,2] and [3].\nThe difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\nThe difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\nSince two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].\n\nExample 3:\n\nInput: nums = [2,2,4,5], k = 0\nOutput: 3\nExplanation:\nWe can partition nums into the three subsequences [2,2], [4], and [5].\nThe difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\nThe difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\nThe difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\nSince three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 105\n0 <= k <= 105 Explanation:\n\nSolution 1: Greedy + Sorting\nThe problem requires dividing into subsequences, not subarrays, so the elements in a subsequence can be non-continuous. We can sort the array $\\textit{nums}$. Assuming the first element of the current subsequence is $a$, the difference between the maximum and minimum values in the subsequence will not exceed $k$. Therefore, we can iterate through the array $\\textit{nums}$. If the difference between the current element $b$ and $a$ is greater than $k$, then update $a$ to $b$ and increase the number of subsequences by 1. After the iteration, we can obtain the minimum number of subsequences, noting that the initial number of subsequences is $1$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of the array $\\textit{nums}$. \n\n", "problem_ids": ["minimum-rectangles-to-cover-points", "container-with-most-water", "partition-array-such-that-maximum-difference-is-k"]}, "2857": {"text": "Similar Problem 1 \n\n Problem:\n\nA transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nYou are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\nReturn a list of transactions that are possibly invalid. You may return the answer in any order.\n\u00a0\nExample 1:\n\nInput: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\nExample 2:\n\nInput: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]\n\nExample 3:\n\nInput: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]\n\n\u00a0\nConstraints:\n\ntransactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of digits, and represent an integer between 0 and 1000.\nEach {amount} consist of digits, and represent an integer between 0 and 2000. Explanation:\n\nSolution 1: Hash Table + Simulation\nWe traverse the transaction list. For each transaction, if the amount is greater than 1000, or if the transaction has the same name but different cities and the time interval does not exceed 60 minutes, then add it to the answer.\nSpecifically, we use a hash table d to record each transaction, where the key is the transaction name, and the value is a list. Each element in the list is a tuple (time, city, index), indicating that a transaction with the number index was conducted in the city city at the moment time. At the same time, we use a hash table idx to record the transaction number in the answer.\nWe traverse the transaction list. For each transaction, we first add it to the hash table d, and then judge whether its amount is greater than 1000. If so, add its number to the answer. Then we traverse the transactions in the hash table d. If the transaction names are the same but the cities are different and the time interval does not exceed 60 minutes, add its number to the answer.\nFinally, we traverse the transaction numbers in the answer and add the corresponding transactions to the answer.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n)$. Here, $n$ is the length of the transaction list. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n\u00a0\nExample 1:\n\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n\u00a0\nConstraints:\n\nn == height.length\n2 <= n <= 105\n0 <= height[i] <= 104 Explanation:\n\nSolution 1: Two Pointers\nInitially, we consider the capacity of the water that the two farthest pillars can hold. The width of the water is the distance between the two pillars, and the height of the water depends on the shorter one between the two pillars.\nThe current pillars are the pillars on the farthest sides, so the width of the water is the largest. For other combinations, the width of the water is smaller. Suppose the height of the left pillar is less than or equal to the height of the right pillar, then the height of the water is the height of the left pillar. If we move the right pillar, the width of the water will decrease, but the height of the water will not increase, so the capacity of the water will definitely decrease. Therefore, we move the left pillar and update the maximum capacity.\nRepeat this process until the two pillars meet.\nThe time complexity is $O(n)$, where $n$ is the length of the array height. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an m x n integer matrix mat and an integer target.\nChoose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized.\nReturn the minimum absolute difference.\nThe absolute difference between two numbers a and b is the absolute value of a - b.\n\u00a0\nExample 1:\n\n\nInput: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13\nOutput: 0\nExplanation: One possible choice is to:\n- Choose 1 from the first row.\n- Choose 5 from the second row.\n- Choose 7 from the third row.\nThe sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.\n\nExample 2:\n\n\nInput: mat = [[1],[2],[3]], target = 100\nOutput: 94\nExplanation: The best possible choice is to:\n- Choose 1 from the first row.\n- Choose 2 from the second row.\n- Choose 3 from the third row.\nThe sum of the chosen elements is 6, and the absolute difference is 94.\n\nExample 3:\n\n\nInput: mat = [[1,2,9,8,7]], target = 6\nOutput: 1\nExplanation: The best choice is to choose 7 from the first row.\nThe absolute difference is 1.\n\n\u00a0\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 70\n1 <= mat[i][j] <= 70\n1 <= target <= 800 Explanation:\n\nSolution 1: Dynamic Programming (Grouped Knapsack)\nLet $f[i][j]$ represent whether it is possible to select elements from the first $i$ rows with a sum of $j$. Then we have the state transition equation:\n$$\nf[i][j] = \\begin{cases} 1 & \\textit{if there exists } x \\in row[i] \\textit{ such that } f[i - 1][j - x] = 1 \\ 0 & \\textit{otherwise} \\end{cases}\n$$\nwhere $row[i]$ represents the set of elements in the $i$-th row.\nSince $f[i][j]$ is only related to $f[i - 1][j]$, we can use a rolling array to optimize the space complexity.\nFinally, we traverse the $f$ array to find the smallest absolute difference.\nThe time complexity is $O(m^2 \\times n \\times C)$ and the space complexity is $O(m \\times C)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, respectively, and $C$ is the maximum value of the matrix elements. \n\n", "problem_ids": ["invalid-transactions", "container-with-most-water", "minimize-the-difference-between-target-and-chosen-elements"]}, "2866": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.\n\u00a0\nExample 1:\n\nInput: n = 5\nOutput: 10\nExplanation: The smallest multiple of both 5 and 2 is 10.\n\nExample 2:\n\nInput: n = 6\nOutput: 6\nExplanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself.\n\n\u00a0\nConstraints:\n\n1 <= n <= 150 Explanation:\n\nSolution 1: Mathematics\nIf $n$ is even, then the least common multiple (LCM) of $2$ and $n$ is $n$ itself. Otherwise, the LCM of $2$ and $n$ is $n \\times 2$.\nThe time complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.\n\u00a0\nExample 1:\n\n\nInput: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.\n\nExample 2:\n\n\nInput: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.\n\nExample 3:\n\n\nInput: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.\n\n\u00a0\nConstraints:\n\ngrid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105 Explanation:\n\nSolution 1: Prefix Sum\nWe notice that if we determine the position $j$ where the first robot turns down, then the optimal path of the second robot is also determined. The optimal path of the second robot is the prefix sum of the first row from $j+1$ to $n-1$, or the prefix sum of the second row from $0$ to $j-1$, taking the maximum of the two.\nFirst, we calculate the suffix sum of the points in the first row, denoted as $s_1$, and the prefix sum of the points in the second row, denoted as $s_2$. Initially, $s_1 = \\sum_{j=0}^{n-1} grid[0][j]$, $s_2 = 0$.\nThen we enumerate the position $j$ where the first robot turns down. At this time, we update $s_1 = s_1 - grid[0][j]$. Then the sum of the optimal path of the second robot is $max(s_1, s_2)$. We take the minimum of $max(s_1, s_2)$ for all $j$. Then we update $s_2 = s_2 + grid[1][j]$.\nAfter the enumeration, we return the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the number of columns in the grid. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\u00a0\nExample 1:\n\nInput: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n\nExample 2:\n\nInput: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109 Explanation:\n\nSolution 1: Discuss Different Cases\nLet $m$ represent the length of string $s$, and $n$ represent the length of string $t$. We can assume that $m$ is always greater than or equal to $n$.\nIf $m-n > 1$, return false directly;\nOtherwise, iterate through $s$ and $t$, if $s[i]$ is not equal to $t[i]$:\n\nIf $m \\neq n$, compare $s[i+1:]$ with $t[i:]$, return true if they are equal, otherwise return false;\nIf $m = n$, compare $s[i:]$ with $t[i:]$, return true if they are equal, otherwise return false.\n\nIf the iteration ends, it means that all the characters of $s$ and $t$ that have been iterated are equal, at this time it needs to satisfy $m=n+1$.\nThe time complexity is $O(m)$, where $m$ is the length of string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["smallest-even-multiple", "grid-game", "maximum-gap"]}, "2867": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.\nReturn the minimum number of extra characters left over if you break up s optimally.\n\u00a0\nExample 1:\n\nInput: s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\nOutput: 1\nExplanation: We can break s in two substrings: \"leet\" from index 0 to 3 and \"code\" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.\n\n\nExample 2:\n\nInput: s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\nOutput: 3\nExplanation: We can break s in two substrings: \"hello\" from index 3 to 7 and \"world\" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 50\n1 <= dictionary.length <= 50\n1 <= dictionary[i].length <= 50\ndictionary[i]\u00a0and s consists of only lowercase English letters\ndictionary contains distinct words Explanation:\n\nSolution 1: Hash Table + Dynamic Programming\nWe can use a hash table $ss$ to record all words in the dictionary, which allows us to quickly determine whether a string is in the dictionary.\nNext, we define $f[i]$ to represent the minimum number of extra characters in the first $i$ characters of string $s$, initially $f[0] = 0$.\nWhen $i \\ge 1$, the $i$th character $s[i - 1]$ can be an extra character, in which case $f[i] = f[i - 1] + 1$. If there exists an index $j \\in [0, i - 1]$ such that $s[j..i)$ is in the hash table $ss$, then we can take $s[j..i)$ as a word, in which case $f[i] = f[j]$.\nIn summary, we can get the state transition equation:\n$$\nf[i] = \\min { f[i - 1] + 1, \\min_{j \\in [0, i - 1]} f[j] }\n$$\nwhere $i \\ge 1$, and $j \\in [0, i - 1]$ and $s[j..i)$ is in the hash table $ss$.\nThe final answer is $f[n]$.\nThe time complexity is $O(n^3 + L)$, and the space complexity is $O(n + L)$. Here, $n$ is the length of string $s$, and $L$ is the sum of the lengths of all words in the dictionary. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven two positive integers a and b, return the count of numbers having\u00a0unique digits in the range [a, b] (inclusive).\n\u00a0\nExample 1:\n\nInput: a = 1, b = 20\nOutput: 19\nExplanation: All the numbers in the range [1, 20] have unique digits except 11. Hence, the answer is 19.\n\nExample 2:\n\nInput: a = 9, b = 19\nOutput: 10\nExplanation: All the numbers in the range [9, 19] have unique digits except 11. Hence, the answer is 10. \n\nExample 3:\n\nInput: a = 80, b = 120\nOutput: 27\nExplanation: There are 41 numbers in the range [80, 120], 27 of which have unique digits.\n\n\u00a0\nConstraints:\n\n1 <= a <= b <= 1000 Explanation:\n\nSolution 1: State Compression + Digit DP\nThe problem asks to count how many numbers in the range $[a, b]$ have unique digits. We can solve this problem using state compression and digit DP.\nWe can use a function $f(n)$ to count how many numbers in the range $[1, n]$ have unique digits. Then the answer is $f(b) - f(a - 1)$.\nIn addition, we can use a binary number to record the digits that have appeared in the number. For example, if the digits $1, 3, 5$ have appeared in the number, we can use $10101$ to represent this state.\nNext, we use memoization search to implement digit DP. We search from the starting point to the bottom layer to get the number of schemes, return the answer layer by layer and accumulate it, and finally get the final answer from the search starting point.\nThe basic steps are as follows:\n\nWe convert the number $n$ into a string $num$, where $num[0]$ is the highest digit and $num[len - 1]$ is the lowest digit.\nBased on the problem information, we design a function $dfs(pos, mask, limit)$, where $pos$ represents the current processing position, $mask$ represents the digits that have appeared in the current number, and $limit$ represents whether there is a limit at the current position. If $limit$ is true, then the digit at the current position cannot exceed $num[pos]$.\n\nThe answer is $dfs(0, 0, true)$.\nThe time complexity is $O(m \\times 2^{10} \\times 10)$, and the space complexity is $O(m \\times 2^{10})$. Where $m$ is the number of digits in $b$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two integers m and n representing the dimensions of a\u00a00-indexed\u00a0m x n grid.\nYou are also given a 0-indexed 2D integer matrix coordinates, where coordinates[i] = [x, y] indicates that the cell with coordinates [x, y] is colored black. All cells in the grid that do not appear in coordinates are white.\nA block is defined as a 2 x 2 submatrix of the grid. More formally, a block with cell [x, y] as its top-left corner where 0 <= x < m - 1 and 0 <= y < n - 1 contains the coordinates [x, y], [x + 1, y], [x, y + 1], and [x + 1, y + 1].\nReturn a 0-indexed integer array arr of size 5 such that arr[i] is the number of blocks that contains exactly i black cells.\n\u00a0\nExample 1:\n\nInput: m = 3, n = 3, coordinates = [[0,0]]\nOutput: [3,1,0,0,0]\nExplanation: The grid looks like this:\n\nThere is only 1 block with one black cell, and it is the block starting with cell [0,0].\nThe other 3 blocks start with cells [0,1], [1,0] and [1,1]. They all have zero black cells. \nThus, we return [3,1,0,0,0]. \n\nExample 2:\n\nInput: m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]\nOutput: [0,2,2,0,0]\nExplanation: The grid looks like this:\n\nThere are 2 blocks with two black cells (the ones starting with cell coordinates [0,0] and [0,1]).\nThe other 2 blocks have starting cell coordinates of [1,0] and [1,1]. They both have 1 black cell.\nTherefore, we return [0,2,2,0,0].\n\n\u00a0\nConstraints:\n\n2 <= m <= 105\n2 <= n <= 105\n0 <= coordinates.length <= 104\ncoordinates[i].length == 2\n0 <= coordinates[i][0] < m\n0 <= coordinates[i][1] < n\nIt is guaranteed that coordinates contains pairwise distinct coordinates. Explanation:\n\nSolution 1: Hash Table\nFor each $2 \\times 2$ submatrix, we can use its upper-left corner coordinate $(x, y)$ to represent it.\nFor each black cell $(x, y)$, its contribution to the 4 submatrices is $1$, namely the matrices $(x - 1, y - 1)$, $(x - 1, y)$, $(x, y - 1)$, $(x, y)$.\nTherefore, we traverse all the black cells, and then accumulate the number of black cells in each submatrix, recorded in the hash table $cnt$.\nFinally, we traverse all the values in $cnt$ (greater than $0$), count the number of times they appear, and record them in the answer array $ans$, while $ans[0]$ represents the number of submatrices without black cells, the value is $(m - 1) \\times (n - 1) - \\sum_{i = 1}^4 ans[i]$.\nTime complexity $O(l)$, space complexity $O(l)$, where $l$ is the length of $coordinates$. \n\n", "problem_ids": ["extra-characters-in-a-string", "count-numbers-with-unique-digits-ii", "number-of-black-blocks"]}, "2868": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying\u00a0the constraint.\n\u00a0\nExample 1:\n\nInput: n = 7\nOutput: 21\nExplanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21.\n\nExample 2:\n\nInput: n = 10\nOutput: 40\nExplanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40.\n\nExample 3:\n\nInput: n = 9\nOutput: 30\nExplanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30.\n\n\u00a0\nConstraints:\n\n1 <= n <= 103 Explanation:\n\nSolution 1: Enumeration\nWe directly enumerate every number $x$ in $[1,..n]$, and if $x$ is divisible by $3$, $5$, and $7$, we add $x$ to the answer.\nAfter the enumeration, we return the answer.\nThe time complexity is $O(n)$, where $n$ is the given integer. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nTable: Emails\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n\nWrite a solution to find all unique email domains and count the number of individuals associated with each domain. Consider only those domains that end with .com.\nReturn the result table orderd by email domains in ascending order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nEmails table:\n+-----+-----------------------+\n| id  | email                 |\n+-----+-----------------------+\n| 336 | hwkiy@test.edu        |\n| 489 | adcmaf@outlook.com    |\n| 449 | vrzmwyum@yahoo.com    |\n| 95  | tof@test.edu          |\n| 320 | jxhbagkpm@example.org |\n| 411 | zxcf@outlook.com      |\n+----+------------------------+\nOutput: \n+--------------+-------+\n| email_domain | count |\n+--------------+-------+\n| outlook.com  | 2     |\n| yahoo.com    | 1     |  \n+--------------+-------+\nExplanation: \n- The valid domains ending with \".com\" are only \"outlook.com\" and \"yahoo.com\", with respective counts of 2 and 1.\nOutput table is ordered by email_domains in ascending order. Explanation:\n\nSolution 1: Using SUBSTRING_INDEX Function + Grouping Statistics\nFirst, we filter out all emails ending with .com, then use the SUBSTRING_INDEX function to extract the domain name of the email. Finally, we use GROUP BY to count the number of each domain.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nSELECT SUBSTRING_INDEX(email, '@', -1) AS email_domain, COUNT(1) AS count\nFROM Emails\nWHERE email LIKE '%.com'\nGROUP BY 1\nORDER BY 1;\n``` \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:\n\nFor each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.\nThen, place those numbers on the board.\n\nReturn the number of distinct integers present on the board after 109 days have elapsed.\nNote:\n\nOnce a number is placed on the board, it will remain on it until the end.\n%\u00a0stands\u00a0for the modulo operation. For example,\u00a014 % 3 is 2.\n\n\u00a0\nExample 1:\n\nInput: n = 5\nOutput: 4\nExplanation: Initially, 5 is present on the board. \nThe next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. \nAfter that day, 3 will be added to the board because 4 % 3 == 1. \nAt the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. \n\nExample 2:\n\nInput: n = 3\nOutput: 2\nExplanation: \nSince 3 % 2 == 1, 2 will be added to the board. \nAfter a billion days, the only two distinct numbers on the board are 2 and 3. \n\n\u00a0\nConstraints:\n\n1 <= n <= 100 Explanation:\n\nSolution 1: Lateral Thinking\nSince every operation on the number $n$ on the desktop will also cause the number $n-1$ to appear on the desktop, the final numbers on the desktop are $[2,...n]$, that is, $n-1$ numbers.\nNote that $n$ could be $1$, so it needs to be specially judged.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["sum-multiples", "find-all-unique-email-domains", "count-distinct-numbers-on-board"]}, "2869": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal.\nReturn true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise.\nNote:\n\nThe frequency of a letter x is the number of times it occurs in the string.\nYou must remove exactly one letter and cannot choose to do nothing.\n\n\u00a0\nExample 1:\n\nInput: word = \"abcc\"\nOutput: true\nExplanation: Select index 3 and delete it: word becomes \"abc\" and each character has a frequency of 1.\n\nExample 2:\n\nInput: word = \"aazz\"\nOutput: false\nExplanation: We must delete a character, so either the frequency of \"a\" is 1 and the frequency of \"z\" is 2, or vice versa. It is impossible to make all present letters have equal frequency.\n\n\u00a0\nConstraints:\n\n2 <= word.length <= 100\nword consists of lowercase English letters only. Explanation:\n\nSolution 1: Counting + Enumeration\nFirst, we use a hash table or an array of length $26$ named $cnt$ to count the number of occurrences of each letter in the string.\nNext, we enumerate the $26$ letters. If letter $c$ appears in the string, we decrement its count by one, then check whether the counts of the remaining letters are the same. If they are, return true. Otherwise, increment the count of $c$ by one and continue to enumerate the next letter.\nIf the enumeration ends, it means that it is impossible to make the counts of the remaining letters the same by deleting one letter, so return false.\nThe time complexity is $O(n + C^2)$, and the space complexity is $O(C)$. Here, $n$ is the length of the string $word$, and $C$ is the size of the character set. In this problem, $C = 26$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an array of strings ideas that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:\n\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\nSwap the first letters of ideaA and ideaB with each other.\nIf both of the new names are not found in the original ideas, then the name ideaA ideaB (the concatenation of ideaA and ideaB, separated by a space) is a valid company name.\nOtherwise, it is not a valid name.\n\nReturn the number of distinct valid names for the company.\n\u00a0\nExample 1:\n\nInput: ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]\nOutput: 6\nExplanation: The following selections are valid:\n- (\"coffee\", \"donuts\"): The company name created is \"doffee conuts\".\n- (\"donuts\", \"coffee\"): The company name created is \"conuts doffee\".\n- (\"donuts\", \"time\"): The company name created is \"tonuts dime\".\n- (\"donuts\", \"toffee\"): The company name created is \"tonuts doffee\".\n- (\"time\", \"donuts\"): The company name created is \"dime tonuts\".\n- (\"toffee\", \"donuts\"): The company name created is \"doffee tonuts\".\nTherefore, there are a total of 6 distinct company names.\n\nThe following are some examples of invalid selections:\n- (\"coffee\", \"time\"): The name \"toffee\" formed after swapping already exists in the original array.\n- (\"time\", \"toffee\"): Both names are still the same after swapping and exist in the original array.\n- (\"coffee\", \"toffee\"): Both names formed after swapping already exist in the original array.\n\nExample 2:\n\nInput: ideas = [\"lack\",\"back\"]\nOutput: 0\nExplanation: There are no valid selections. Therefore, 0 is returned.\n\n\u00a0\nConstraints:\n\n2 <= ideas.length <= 5 * 104\n1 <= ideas[i].length <= 10\nideas[i] consists of lowercase English letters.\nAll the strings in ideas are unique. Explanation:\n\nSolution 1: Enumeration Counting\nWe define $f[i][j]$ to represent the number of strings in $ideas$ that start with the $i$th letter and are not in $ideas$ after being replaced with the $j$th letter. Initially, $f[i][j] = 0$. Additionally, we use a hash table $s$ to record the strings in $ideas$, which allows us to quickly determine whether a string is in $ideas$.\nNext, we traverse the strings in $ideas$. For the current string $v$, we enumerate the first letter $j$ after replacement. If the string after $v$ is replaced is not in $ideas$, then we update $f[i][j] = f[i][j] + 1$.\nFinally, we traverse the strings in $ideas$ again. For the current string $v$, we enumerate the first letter $j$ after replacement. If the string after $v$ is replaced is not in $ideas$, then we update the answer $ans = ans + f[j][i]$.\nThe final answer is $ans$.\nThe time complexity is $O(n \\times m \\times |\\Sigma|)$, and the space complexity is $O(|\\Sigma|^2)$. Here, $n$ and $m$ are the number of strings in $ideas$ and the maximum length of the strings, respectively, and $|\\Sigma|$ is the character set that appears in the string. In this problem, $|\\Sigma| \\leq 26$. \n\nSimilar Problem 3 \n\n Problem:\n\nAlice and Bob are traveling to Rome for separate business meetings.\nYou are given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice will be in the city from the dates arriveAlice to leaveAlice (inclusive), while Bob will be in the city from the dates arriveBob to leaveBob (inclusive). Each will be a 5-character string in the format \"MM-DD\", corresponding to the month and day of the date.\nReturn the total number of days that Alice and Bob are in Rome together.\nYou can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].\n\u00a0\nExample 1:\n\nInput: arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"\nOutput: 3\nExplanation: Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n\nExample 2:\n\nInput: arriveAlice = \"10-01\", leaveAlice = \"10-31\", arriveBob = \"11-01\", leaveBob = \"12-31\"\nOutput: 0\nExplanation: There is no day when Alice and Bob are in Rome together, so we return 0.\n\n\u00a0\nConstraints:\n\nAll dates are provided in the format \"MM-DD\".\nAlice and Bob's arrival dates are earlier than or equal to their leaving dates.\nThe given dates are valid dates of a non-leap year. Explanation:\n\nSolution 1: Simulation\nWe convert the dates into days, and then calculate the number of days both people are in Rome.\nThe time complexity is $O(C)$, and the space complexity is $O(C)$. Here, $C$ is a constant. \n\n", "problem_ids": ["remove-letter-to-equalize-frequency", "naming-a-company", "count-days-spent-together"]}, "2870": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met:\n\nEach element p[i][j] is calculated as the product of all elements in grid except for the element grid[i][j]. This product is then taken modulo 12345.\n\nReturn the product matrix of grid.\n\u00a0\nExample 1:\n\nInput: grid = [[1,2],[3,4]]\nOutput: [[24,12],[8,6]]\nExplanation: p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24\np[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12\np[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8\np[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6\nSo the answer is [[24,12],[8,6]].\nExample 2:\n\nInput: grid = [[12345],[2],[1]]\nOutput: [[2],[0],[0]]\nExplanation: p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2.\np[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0. So p[0][1] = 0.\np[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0. So p[0][2] = 0.\nSo the answer is [[2],[0],[0]].\n\u00a0\nConstraints:\n\n1 <= n == grid.length\u00a0<= 105\n1 <= m == grid[i].length\u00a0<= 105\n2 <= n * m <= 105\n1 <= grid[i][j] <= 109 Explanation:\n\nSolution 1: Prefix and Suffix Decomposition\nWe can preprocess the suffix product (excluding itself) of each element, and then traverse the matrix to calculate the prefix product (excluding itself) of each element. The product of the two gives us the result for each position.\nSpecifically, we use $p[i][j]$ to represent the result of the element in the $i$-th row and $j$-th column of the matrix. We define a variable $suf$ to represent the product of all elements below and to the right of the current position. Initially, $suf$ is set to $1$. We start traversing from the bottom right corner of the matrix. For each position $(i, j)$, we assign $suf$ to $p[i][j]$, and then update $suf$ to $suf \\times grid[i][j] \\bmod 12345$. This way, we can obtain the suffix product of each position.\nNext, we start traversing from the top left corner of the matrix. For each position $(i, j)$, we multiply $p[i][j]$ by $pre$, take the result modulo $12345$, and then update $pre$ to $pre \\times grid[i][j] \\bmod 12345$. This way, we can obtain the prefix product of each position.\nAfter the traversal, we return the result matrix $p$.\nThe time complexity is $O(n \\times m)$, where $n$ and $m$ are the number of rows and columns in the matrix, respectively. Ignoring the space occupied by the result matrix, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung.\nYou are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. You are able to insert rungs at any positive integer height if a rung is not already there.\nReturn the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.\n\u00a0\nExample 1:\n\nInput: rungs = [1,3,5,10], dist = 2\nOutput: 2\nExplanation:\nYou currently cannot reach the last rung.\nAdd rungs at heights 7 and 8 to climb this ladder. \nThe ladder will now have rungs at [1,3,5,7,8,10].\n\nExample 2:\n\nInput: rungs = [3,6,8,10], dist = 3\nOutput: 0\nExplanation:\nThis ladder can be climbed without adding additional rungs.\n\nExample 3:\n\nInput: rungs = [3,4,6,7], dist = 2\nOutput: 1\nExplanation:\nYou currently cannot reach the first rung from the ground.\nAdd a rung at height 1 to climb this ladder.\nThe ladder will now have rungs at [1,3,4,6,7].\n\n\u00a0\nConstraints:\n\n1 <= rungs.length <= 105\n1 <= rungs[i] <= 109\n1 <= dist <= 109\nrungs is strictly increasing. Explanation:\n\nSolution 1: Greedy + Simulation\nAccording to the problem description, we know that every time we plan to climb a new rung, we need to ensure that the height difference between the new rung and the current position does not exceed dist. Otherwise, we need to greedily insert a new rung at a distance of $dist$ from the current position, climb a new rung, and the total number of rungs to be inserted is $\\lfloor \\frac{b - a - 1}{dist} \\rfloor$, where $a$ and $b$ are the current position and the height of the new rung, respectively. The answer is the sum of all inserted rungs.\nThe time complexity is $O(n)$, where $n$ is the length of rungs. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.\n\u00a0\nExample 1:\n\nInput: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. \n\nExample 2:\n\nInput: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].\n\nExample 3:\n\nInput: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].\n\n\u00a0\nConstraints:\n\nm == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 100\u00a0\nmat[i][j] is either 0 or 1. Explanation:\n\nSolution 1: Simulation\nWe directly traverse the matrix, count the number of $1$s in each row, and update the maximum value and the corresponding row index. Note that if the number of $1$s in the current row is equal to the maximum value, we need to choose the row with the smaller index.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["construct-product-matrix", "add-minimum-number-of-rungs", "row-with-maximum-ones"]}, "2872": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n\u00a0\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\n\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109 Explanation:\n\nSolution 1: Sorting\nFirst, we sort the array nums.\nThen, we traverse the array. If there are two adjacent elements that are the same, it means that there are duplicate elements in the array, and we directly return true.\nOtherwise, when the traversal ends, we return false.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the length of the array nums. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.\n\u00a0\nExample 1:\n\n\nInput: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.  \n\nExample 2:\n\n\nInput: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\n\nExample 3:\n\nInput: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree. Explanation:\n\nSolution 1: Recursion\nWe design a recursive function $dfs(head, root)$, which indicates whether the linked list $head$ corresponds to a subpath on the path starting with $root$ in the binary tree. The logic of the function $dfs(head, root)$ is as follows:\n\nIf the linked list $head$ is empty, it means that the linked list has been traversed, return true;\nIf the binary tree $root$ is empty, it means that the binary tree has been traversed, but the linked list has not been traversed yet, return false;\nIf the value of the binary tree $root$ is not equal to the value of the linked list $head$, return false;\nOtherwise, return $dfs(head.next, root.left)$ or $dfs(head.next, root.right)$.\n\nIn the main function, we call $dfs(head, root)$ for each node of the binary tree. As long as one returns true, it means that the linked list is a subpath of the binary tree, return true; if all nodes return false, it means that the linked list is not a subpath of the binary tree, return false.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the binary tree. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array enemyEnergies denoting the energy values of various enemies.\nYou are also given an integer currentEnergy denoting the amount of energy you have initially.\nYou start with 0 points, and all the enemies are unmarked initially.\nYou can perform either of the following operations zero or multiple times to gain points:\n\nChoose an unmarked enemy, i, such that currentEnergy >= enemyEnergies[i]. By choosing this option:\n\n    \nYou gain 1 point.\nYour energy is reduced by the enemy's energy, i.e. currentEnergy = currentEnergy - enemyEnergies[i].\n\n\nIf you have at least 1 point, you can choose an unmarked enemy, i. By choosing this option:\n    \nYour energy increases by the enemy's energy, i.e. currentEnergy = currentEnergy + enemyEnergies[i].\nThe enemy i is marked.\n\n\n\nReturn an integer denoting the maximum points you can get in the end by optimally performing operations.\n\u00a0\nExample 1:\n\nInput: enemyEnergies = [3,2,2], currentEnergy = 2\nOutput: 3\nExplanation:\nThe following operations can be performed to get 3 points, which is the maximum:\n\nFirst operation on enemy 1: points increases by 1, and currentEnergy decreases by 2. So, points = 1, and currentEnergy = 0.\nSecond operation on enemy 0: currentEnergy increases by 3, and enemy 0 is marked. So, points = 1, currentEnergy = 3, and marked enemies = [0].\nFirst operation on enemy 2: points increases by 1, and currentEnergy decreases by 2. So, points = 2, currentEnergy = 1, and marked enemies = [0].\nSecond operation on enemy 2: currentEnergy increases by 2, and enemy 2 is marked. So, points = 2, currentEnergy = 3, and marked enemies = [0, 2].\nFirst operation on enemy 1: points increases by 1, and currentEnergy decreases by 2. So, points = 3, currentEnergy = 1, and marked enemies = [0, 2].\n\n\nExample 2:\n\nInput: enemyEnergies = [2], currentEnergy = 10\nOutput: 5\nExplanation: \nPerforming the first operation 5 times on enemy 0 results in the maximum number of points.\n\n\u00a0\nConstraints:\n\n1 <= enemyEnergies.length <= 105\n1 <= enemyEnergies[i] <= 109\n0 <= currentEnergy <= 109 Explanation:\n\nSolution 1: Greedy + Sorting\nAccording to the problem description, we need to score by defeating enemies with the lowest energy value and increase our energy value by defeating enemies with the highest energy value and marking them.\nTherefore, we can sort the enemies by their energy values, then start from the enemy with the highest energy value, always choose the enemy with the lowest energy value to score and consume energy. Next, we add the energy value of the enemy with the highest energy to our current energy and mark that enemy. Repeat the above steps until all enemies are marked.\nThe time complexity is $O(n \\log n)$, and the space complexity is $O(\\log n)$, where $n$ is the number of enemies. \n\n", "problem_ids": ["contains-duplicate", "linked-list-in-binary-tree", "maximum-points-after-enemy-battles"]}, "2873": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\nReturn an array containing the answers to the queries.\n\u00a0\nExample 1:\n\nInput: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\nOutput: [3,3,1,4]\nExplanation: The queries are processed as follows:\n- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\n\nExample 2:\n\nInput: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\nOutput: [2,-1,4,6]\nExplanation: The queries are processed as follows:\n- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.\n\n\u00a0\nConstraints:\n\n1 <= intervals.length <= 105\n1 <= queries.length <= 105\nintervals[i].length == 2\n1 <= lefti <= righti <= 107\n1 <= queries[j] <= 107 Explanation:\n\nSolution 1: Sorting + Offline Query + Priority Queue (Min Heap)\nWe notice that the order of queries does not affect the answer, and the intervals involved do not change. Therefore, we consider sorting all queries in ascending order, and sorting all intervals in ascending order of the left endpoint.\nWe use a priority queue (min heap) $pq$ to maintain all current intervals. Each element in the queue is a pair $(v, r)$, representing an interval with length $v$ and right endpoint $r$. Initially, the priority queue is empty. In addition, we define a pointer $i$ that points to the current interval being traversed, and initially $i=0$.\nWe traverse each query $(x, j)$ in ascending order and perform the following operations:\n\nIf the pointer $i$ has not traversed all intervals, and the left endpoint of the current interval $[a, b]$ is less than or equal to $x$, then we add this interval to the priority queue and move the pointer $i$ one step forward. Repeat this process.\nIf the priority queue is not empty, and the right endpoint of the heap top element is less than $x$, then we pop the heap top element. Repeat this process.\nAt this point, if the priority queue is not empty, then the heap top element is the smallest interval containing $x$. We add its length $v$ to the answer array $ans$.\n\nAfter the above process is over, we return the answer array $ans$.\nThe time complexity is $O(n \\times \\log n + m \\times \\log m)$, and the space complexity is $O(n + m)$. Where $n$ and $m$ are the lengths of the arrays intervals and queries respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a binary array nums of length n, a positive integer k and a non-negative integer maxChanges.\nAlice plays a game, where the goal is for Alice to pick up k ones from nums using the minimum number of moves. When the game starts, Alice picks up any index aliceIndex in the range [0, n - 1] and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice can make any number of moves (including zero) where in each move Alice must perform exactly one of the following actions:\n\nSelect any index j != aliceIndex such that nums[j] == 0 and set nums[j] = 1. This action can be performed at most maxChanges times.\nSelect any two adjacent indices x and y (|x - y| == 1) such that nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move and nums[y] becomes 0.\n\nReturn the minimum number of moves required by Alice to pick exactly k ones.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\nOutput: 3\nExplanation: Alice can pick up 3 ones in 3 moves, if Alice performs the following actions in each move when standing at aliceIndex == 1:\n\nAt the start of the game Alice picks up the one and nums[1] becomes 0. nums becomes [1,0,0,0,0,1,1,0,0,1].\nSelect j == 2 and perform an action of the first type. nums becomes [1,0,1,0,0,1,1,0,0,1]\nSelect x == 2 and y == 1, and perform an action of the second type. nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].\nSelect x == 0 and y == 1, and perform an action of the second type. nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].\n\nNote that it may be possible for Alice to pick up 3 ones using some other sequence of 3 moves.\n\nExample 2:\n\nInput: nums = [0,0,0,0], k = 2, maxChanges = 3\nOutput: 4\nExplanation: Alice can pick up 2 ones in 4 moves, if Alice performs the following actions in each move when standing at aliceIndex == 0:\n\nSelect j == 1 and perform an action of the first type. nums becomes [0,1,0,0].\nSelect x == 1 and y == 0, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\nSelect j == 1 again and perform an action of the first type. nums becomes [0,1,0,0].\nSelect x == 1 and y == 0 again, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\n\n\n\u00a0\nConstraints:\n\n2 <= n <= 105\n0 <= nums[i] <= 1\n1 <= k <= 105\n0 <= maxChanges <= 105\nmaxChanges + sum(nums) >= k Explanation:\n\nSolution 1: Greedy + Prefix Sum + Binary Search\nWe consider enumerating Alice's standing position $i$. For each $i$, we follow the strategy below:\n\nFirst, if the number at position $i$ is $1$, we can directly pick up a $1$ without needing any moves.\nThen, we pick up the number $1$ from both sides of position $i$, which is action $2$, i.e., move the $1$ from position $i-1$ to position $i$, then pick it up; move the $1$ from position $i+1$ to position $i$, then pick it up. Each pick up of a $1$ requires $1$ move.\nNext, we maximize the conversion of $0$s at positions $i-1$ or $i+1$ to $1$s using action $1$, then move them to position $i$ using action $2$ to pick them up. This continues until the number of $1$s picked up reaches $k$ or the number of times action $1$ is used reaches $\\textit{maxChanges}$. Assuming the number of times action $1$ is used is $c$, then a total of $2c$ moves are needed.\nAfter utilizing action $1$, if the number of $1$s picked up has not reached $k$, we need to continue considering moving $1$s to position $i$ from the intervals $[1,..i-2]$ and $[i+2,..n]$ using action $2$ to pick them up. We can use binary search to determine the size of this interval so that the number of $1$s picked up reaches $k$. Specifically, we binary search for an interval size $d$, then within the intervals $[i-d,..i-2]$ and $[i+2,..i+d]$, we perform action $2$ to move $1$s to position $i$ for pickup. If the number of $1$s picked up reaches $k$, we update the answer.\n\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $\\textit{nums}$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates\u00a0where the candidate numbers sum to target.\nEach number in candidates\u00a0may only be used once in the combination.\nNote:\u00a0The solution set must not contain duplicate combinations.\n\u00a0\nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\u00a0\nConstraints:\n\n1 <=\u00a0candidates.length <= 100\n1 <=\u00a0candidates[i] <= 50\n1 <= target <= 30 Explanation:\n\nSolution 1: Sorting + Pruning + Backtracking\nWe can first sort the array to facilitate pruning and skipping duplicate numbers.\nNext, we design a function $dfs(i, s)$, which means starting the search from index $i$ with a remaining target value of $s$. Here, $i$ and $s$ are both non-negative integers, the current search path is $t$, and the answer is $ans$.\nIn the function $dfs(i, s)$, we first check whether $s$ is $0$. If it is, we add the current search path $t$ to the answer $ans$, and then return. If $i \\geq n$ or $s \\lt candidates[i]$, the path is invalid, so we return directly. Otherwise, we start the search from index $i$, and the search index range is $j \\in [i, n)$, where $n$ is the length of the array $candidates$. During the search, if $j \\gt i$ and $candidates[j] = candidates[j - 1]$, it means that the current number is the same as the previous number, we can skip the current number because the previous number has been searched. Otherwise, we add the current number to the search path $t$, recursively call the function $dfs(j + 1, s - candidates[j])$, and after the recursion ends, we remove the current number from the search path $t$.\nWe can also change the implementation logic of the function $dfs(i, s)$ to another form. If we choose the current number, we add the current number to the search path $t$, then recursively call the function $dfs(i + 1, s - candidates[i])$, and after the recursion ends, we remove the current number from the search path $t$. If we do not choose the current number, we can skip all numbers that are the same as the current number, then recursively call the function $dfs(j, s)$, where $j$ is the index of the first number that is different from the current number.\nIn the main function, we just need to call the function $dfs(0, target)$ to get the answer.\nThe time complexity is $O(2^n \\times n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $candidates$. Due to pruning, the actual time complexity is much less than $O(2^n \\times n)$.\nSimilar problems:\n\n39. Combination Sum\n77. Combinations\n216. Combination Sum III \n\n", "problem_ids": ["minimum-interval-to-include-each-query", "minimum-moves-to-pick-k-ones", "combination-sum-ii"]}, "2876": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an n * m 0-indexed grid of string land. Right now, you are standing at the cell that contains \"S\", and you want to get to the cell containing \"D\". There are three other types of cells in this land:\n\n\".\": These cells are empty.\n\"X\": These cells are stone.\n\"*\": These cells are flooded.\n\nAt each second, you can move to a cell that shares a side with your current cell (if it exists). Also, at each second, every empty cell that shares a side with a flooded cell becomes flooded as well.\nThere are two problems ahead of your journey:\n\nYou can't step on stone cells.\nYou can't step on flooded cells since you will drown (also, you can't step on a cell that will be flooded at the same time as you step on it).\n\nReturn the minimum time it takes you to reach the destination in seconds, or -1 if it is impossible.\nNote that the destination will never be flooded.\n\u00a0\nExample 1:\n\nInput: land = [[\"D\",\".\",\"*\"],[\".\",\".\",\".\"],[\".\",\"S\",\".\"]]\nOutput: 3\nExplanation: The picture below shows the simulation of the land second by second. The blue cells are flooded, and the gray cells are stone.\nPicture (0) shows the initial state and picture (3) shows the final state when we reach destination. As you see, it takes us 3 second to reach destination and the answer would be 3.\nIt can be shown that 3 is the minimum time needed to reach from S to D.\n\n\nExample 2:\n\nInput: land = [[\"D\",\"X\",\"*\"],[\".\",\".\",\".\"],[\".\",\".\",\"S\"]]\nOutput: -1\nExplanation: The picture below shows the simulation of the land second by second. The blue cells are flooded, and the gray cells are stone.\nPicture (0) shows the initial state. As you see, no matter which paths we choose, we will drown at the 3rd\u00a0second. Also the minimum path takes us 4 seconds to reach from S to D.\nSo the answer would be -1.\n\n\nExample 3:\n\nInput: land = [[\"D\",\".\",\".\",\".\",\"*\",\".\"],[\".\",\"X\",\".\",\"X\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"S\",\".\"]]\nOutput: 6\nExplanation: It can be shown that we can reach destination in 6 seconds. Also it can be shown that 6 is the minimum seconds one need to reach from S to D.\n\n\u00a0\nConstraints:\n\n2 <= n, m <= 100\nland\u00a0consists only of\u00a0\"S\", \"D\", \".\", \"*\" and\u00a0\"X\".\nExactly one of the cells is equal to \"S\".\nExactly one of the cells is equal to \"D\". Explanation:\n\nSolution 1: Two BFS Traversals\nFirst, we run a BFS (Breadth-First Search) to calculate the shortest distance from each cell to the water, and record it in the array $g$. Then, we run another BFS starting from the cell $(s_i, s_j)$ to find the shortest distance to the target cell $(d_i, d_j)$. During this process, if the adjacent cell $(x, y)$ of the current cell $(i, j)$ satisfies $g[x][y] > t + 1$, then we can move from $(x, y)$ to $(i, j)$.\nThe time complexity is $O(m \\times n)$ and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows and columns of the array $land$, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nTwo strings are considered close if you can attain one from the other using the following operations:\n\nOperation 1: Swap any two existing characters.\n\n    \nFor example, abcde -> aecdb\n\n\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\n    \nFor example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)\n\n\n\nYou can use the operations on either string as many times as necessary.\nGiven two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.\n\u00a0\nExample 1:\n\nInput: word1 = \"abc\", word2 = \"bca\"\nOutput: true\nExplanation: You can attain word2 from word1 in 2 operations.\nApply Operation 1: \"abc\" -> \"acb\"\nApply Operation 1: \"acb\" -> \"bca\"\n\nExample 2:\n\nInput: word1 = \"a\", word2 = \"aa\"\nOutput: false\nExplanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.\n\nExample 3:\n\nInput: word1 = \"cabbba\", word2 = \"abbccc\"\nOutput: true\nExplanation: You can attain word2 from word1 in 3 operations.\nApply Operation 1: \"cabbba\" -> \"caabbb\"\nApply Operation 2: \"caabbb\" -> \"baaccc\"\nApply Operation 2: \"baaccc\" -> \"abbccc\"\n\n\u00a0\nConstraints:\n\n1 <= word1.length, word2.length <= 105\nword1 and word2 contain only lowercase English letters. Explanation:\n\nSolution 1: Counting + Sorting\nAccording to the problem description, two strings are close if they meet the following two conditions simultaneously:\n\nThe strings word1 and word2 must contain the same types of letters.\nThe arrays obtained by sorting the counts of all characters in word1 and word2 must be the same.\n\nTherefore, we can first use an array or hash table to count the occurrences of each letter in word1 and word2 respectively, and then compare whether they are the same. If they are not the same, return false early.\nOtherwise, we sort the corresponding counts, and then compare whether the counts at the corresponding positions are the same. If they are not the same, return false.\nAt the end of the traversal, return true.\nThe time complexity is $O(m + n + C \\times \\log C)$, and the space complexity is $O(C)$. Here, $m$ and $n$ are the lengths of the strings word1 and word2 respectively, and $C$ is the number of letter types. In this problem, $C=26$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\u00a0\nExample 1:\n\n\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n\nExample 2:\n\n\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\n-100 <= Node.val <= 100\n\n\u00a0\nFollow up: Could you solve it both recursively and iteratively? Explanation:\n\nSolution 1: Recursion\nWe design a function $dfs(root1, root2)$ to determine whether two binary trees are symmetric. The answer is $dfs(root, root)$.\nThe logic of the function $dfs(root1, root2)$ is as follows:\n\nIf both $root1$ and $root2$ are null, then the two binary trees are symmetric, return true.\nIf only one of $root1$ and $root2$ is null, or if $root1.val \\neq root2.val$, then the two binary trees are not symmetric, return false.\nOtherwise, determine whether the left subtree of $root1$ is symmetric to the right subtree of $root2$, and whether the right subtree of $root1$ is symmetric to the left subtree of $root2$. Here we use recursion.\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["minimum-time-takes-to-reach-destination-without-drowning", "determine-if-two-strings-are-close", "symmetric-tree"]}, "2877": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\nA good subarray is a subarray where:\n\nits length is at least two, and\nthe sum of the elements of the subarray is a multiple of k.\n\nNote that:\n\nA subarray is a contiguous part of the array.\nAn integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.\n\n\u00a0\nExample 1:\n\nInput: nums = [23,2,4,6,7], k = 6\nOutput: true\nExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\nExample 2:\n\nInput: nums = [23,2,6,4,7], k = 6\nOutput: true\nExplanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\nExample 3:\n\nInput: nums = [23,2,6,4,7], k = 13\nOutput: false\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n0 <= sum(nums[i]) <= 231 - 1\n1 <= k <= 231 - 1 Explanation:\n\nSolution 1: Prefix Sum + Hash Table\nAccording to the problem description, if there exist two positions $i$ and $j$ ($j < i$) where the remainders of the prefix sums modulo $k$ are the same, then the sum of the subarray $\\textit{nums}[j+1..i]$ is a multiple of $k$.\nTherefore, we can use a hash table to store the first occurrence of each remainder of the prefix sum modulo $k$. Initially, we store a key-value pair $(0, -1)$ in the hash table, indicating that the remainder $0$ of the prefix sum $0$ appears at position $-1$.\nAs we iterate through the array, we calculate the current prefix sum's remainder modulo $k$. If the current prefix sum's remainder modulo $k$ has not appeared in the hash table, we store the current prefix sum's remainder modulo $k$ and its corresponding position in the hash table. Otherwise, if the current prefix sum's remainder modulo $k$ has already appeared in the hash table at position $j$, then we have found a subarray $\\textit{nums}[j+1..i]$ that meets the conditions, and thus return $\\textit{True}$.\nAfter completing the iteration, if no subarray meeting the conditions is found, we return $\\textit{False}$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $\\textit{nums}$. \n\nSimilar Problem 2 \n\n Problem:\n\nTable: cities\n\n+-------------+---------+\n| Column Name | Type    | \n+-------------+---------+\n| state       | varchar |\n| city        | varchar |\n+-------------+---------+\n(state, city) is the primary key (combination of columns with unique values) for this table.\nEach row of this table contains the state name and the city name within that state.\n\nWrite a solution to find all the cities in each state and combine them into a single comma-separated string.\nReturn the result table ordered by state in ascending order.\nThe result format is in the following example.\n\u00a0\nExample:\n\nInput:\ncities table:\n\n+-------------+---------------+\n| state       | city          |\n+-------------+---------------+\n| California  | Los Angeles   |\n| California  | San Francisco |\n| California  | San Diego     |\n| Texas       | Houston       |\n| Texas       | Austin        |\n| Texas       | Dallas        |\n| New York    | New York City |\n| New York    | Buffalo       |\n| New York    | Rochester     |\n+-------------+---------------+\n\nOutput:\n\n+-------------+---------------------------------------+\n| state       | cities                                |\n+-------------+---------------------------------------+\n| California  | Los Angeles, San Diego, San Francisco |\n| New York    | Buffalo, New York City, Rochester     |\n| Texas       | Austin, Dallas, Houston               |\n+-------------+---------------------------------------+\n\nExplanation:\n\nCalifornia: All cities (\"Los Angeles\", \"San Diego\", \"San Francisco\") are listed in a comma-separated string.\nNew York: All cities (\"Buffalo\", \"New York City\", \"Rochester\") are listed in a comma-separated string.\nTexas: All cities (\"Austin\", \"Dallas\", \"Houston\") are listed in a comma-separated string.\n\nNote: The output table is ordered by the state name in ascending order. Explanation:\n\nSolution 1: Grouping and Aggregation\nWe can first group by the state field, then sort the city field within each group, and finally use the GROUP_CONCAT function to concatenate the sorted city names into a comma-separated string.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nSELECT\n    state,\n    GROUP_CONCAT(city ORDER BY city SEPARATOR ', ') cities\nFROM cities\nGROUP BY 1\nORDER BY 1;\n```\nPandas\n```python\nimport pandas as pd\ndef find_cities(cities: pd.DataFrame) -> pd.DataFrame:\n    result = (\n        cities.groupby(\"state\")[\"city\"]\n        .apply(lambda x: \", \".join(sorted(x)))\n        .reset_index()\n    )\n    result.columns = [\"state\", \"cities\"]\n    return result\n``` \n\nSimilar Problem 3 \n\n Problem:\n\nA company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.\nThe employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.\nGiven a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting.\n\u00a0\nExample 1:\n\n\nInput: favorite = [2,2,1,2]\nOutput: 3\nExplanation:\nThe above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.\nAll employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.\nNote that the company can also invite employees 1, 2, and 3, and give them their desired seats.\nThe maximum number of employees that can be invited to the meeting is 3. \n\nExample 2:\n\nInput: favorite = [1,2,0]\nOutput: 3\nExplanation: \nEach employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.\nThe seating arrangement will be the same as that in the figure given in example 1:\n- Employee 0 will sit between employees 2 and 1.\n- Employee 1 will sit between employees 0 and 2.\n- Employee 2 will sit between employees 1 and 0.\nThe maximum number of employees that can be invited to the meeting is 3.\n\nExample 3:\n\n\nInput: favorite = [3,0,1,4,1]\nOutput: 4\nExplanation:\nThe above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.\nEmployee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\nSo the company leaves them out of the meeting.\nThe maximum number of employees that can be invited to the meeting is 4.\n\n\u00a0\nConstraints:\n\nn == favorite.length\n2 <= n <= 105\n0 <= favorite[i] <=\u00a0n - 1\nfavorite[i] != i Explanation:\n\nSolution 1: Maximum Cycle in Graph + Longest Chain\nWe observe that the employee's preference relationship in the problem can be regarded as a directed graph, which can be divided into multiple \"base cycle inward trees\". Each structure contains a cycle, and each node on the cycle is connected to a tree.\nWhat is a \"base cycle inward tree\"? First, a base cycle tree is a directed graph with $n$ nodes and $n$ edges, and an inward tree means that in this directed graph, each node has exactly one outgoing edge. In this problem, each employee has exactly one favorite employee, so the constructed directed graph can be composed of multiple \"base cycle inward trees\".\n\nFor this problem, we can find the length of the maximum cycle in the graph. Here we only need to find the length of the largest cycle, because if there are multiple cycles, they are not connected to each other, which does not meet the problem requirements.\nIn addition, for the size of the cycle equal to $2$, that is, there are two employees who like each other, then we can arrange these two employees together. If these two employees are each liked by other employees, then we only need to arrange the employees who like them next to them. If there are multiple such situations, we can arrange them all.\nTherefore, the problem is actually equivalent to finding the length of the maximum cycle in the graph, and all cycles of length $2$ plus their longest chain. The maximum of these two can be found. To find the longest chain to the cycle of length $2$, we can use topological sorting.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array favorite. \n\n", "problem_ids": ["continuous-subarray-sum", "find-cities-in-each-state", "maximum-employees-to-be-invited-to-a-meeting"]}, "2878": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.\nA uni-value grid is a grid where all the elements of it are equal.\nReturn the minimum number of operations to make the grid uni-value. If it is not possible, return -1.\n\u00a0\nExample 1:\n\n\nInput: grid = [[2,4],[6,8]], x = 2\nOutput: 4\nExplanation: We can make every element equal to 4 by doing the following: \n- Add x to 2 once.\n- Subtract x from 6 once.\n- Subtract x from 8 twice.\nA total of 4 operations were used.\n\nExample 2:\n\n\nInput: grid = [[1,5],[2,3]], x = 1\nOutput: 5\nExplanation: We can make every element equal to 3.\n\nExample 3:\n\n\nInput: grid = [[1,2],[3,4]], x = 2\nOutput: -1\nExplanation: It is impossible to make every element equal.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n1 <= m * n <= 105\n1 <= x, grid[i][j] <= 104 Explanation:\n\nSolution 1: Greedy\nFirstly, to make the grid a single-value grid, the remainder of all elements of the grid with $x$ must be the same.\nTherefore, we can first traverse the grid to check whether the remainder of all elements with $x$ is the same. If not, return $-1$. Otherwise, we put all elements into an array, sort the array, take the median, then traverse the array, calculate the difference between each element and the median, divide it by $x$, and add all the differences to get the answer.\nThe time complexity is $O((m \\times n) \\times \\log (m \\times n))$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns of the grid, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.\nAn alphanumeric string is a string consisting of lowercase English letters and digits.\n\u00a0\nExample 1:\n\nInput: s = \"dfa12321afd\"\nOutput: 2\nExplanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.\n\nExample 2:\n\nInput: s = \"abc1111\"\nOutput: -1\nExplanation: The digits that appear in s are [1]. There is no second largest digit. \n\n\u00a0\nConstraints:\n\n1 <= s.length <= 500\ns consists of only lowercase English letters and digits. Explanation:\n\nSolution 1: One Pass\nWe define $a$ and $b$ to represent the largest and second largest numbers in the string, initially $a = b = -1$.\nWe traverse the string $s$. If the current character is a digit, we convert it to a number $v$. If $v > a$, it means that $v$ is the largest number currently appearing, we update $b$ to $a$, and update $a$ to $v$; if $v < a$, it means that $v$ is the second largest number currently appearing, we update $b$ to $v$.\nAfter the traversal, we return $b$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nA magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\n\u00a0\nExample 1:\n\nInput: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= n <= 105 Explanation:\n\nSolution 1: Simulate the Construction Process\nAccording to the problem, we know that each group of numbers in the string $s$ can be obtained from the digits of the string $s$ itself.\nThe first two groups of numbers in string $s$ are $1$ and $22$, which are obtained from the first and second digits of string $s$, respectively. Moreover, the first group of numbers contains only $1$, the second group contains only $2$, the third group contains only $1$, and so on.\nSince the first two groups of numbers are known, we initialize string $s$ as $122$, and then start constructing from the third group. The third group of numbers is obtained from the third digit of string $s$ (index $i=2$), so at this point, we point the pointer $i$ to the third digit $2$ of string $s$.\n1 2 2\n    ^\n    i\nThe digit pointed by pointer $i$ is $2$, indicating that the third group of numbers will appear twice. Since the previous group of numbers is $2$, and the numbers alternate between groups, the third group of numbers is two $1$s, i.e., $11$. After construction, the pointer $i$ moves to the next position, pointing to the fourth digit $1$ of string $s$.\n1 2 2 1 1\n      ^\n      i\nAt this point, the digit pointed by pointer $i$ is $1$, indicating that the fourth group of numbers will appear once. Since the previous group of numbers is $1$, and the numbers alternate between groups, the fourth group of numbers is one $2$, i.e., $2$. After construction, the pointer $i$ moves to the next position, pointing to the fifth digit $1$ of string $s$.\n1 2 2 1 1 2\n        ^\n        i\nFollowing this rule, we simulate the construction process sequentially until the length of string $s$ is greater than or equal to $n$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. \n\n", "problem_ids": ["minimum-operations-to-make-a-uni-value-grid", "second-largest-digit-in-a-string", "magical-string"]}, "2879": {"text": "Similar Problem 1 \n\n Problem:\n\nA boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes:\n\n't' that evaluates to true.\n'f' that evaluates to false.\n'!(subExpr)' that evaluates to the logical NOT of the inner expression subExpr.\n'&(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical AND of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n'|(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical OR of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n\nGiven a string expression that represents a boolean expression, return the evaluation of that expression.\nIt is guaranteed that the given expression is valid and follows the given rules.\n\u00a0\nExample 1:\n\nInput: expression = \"&(|(f))\"\nOutput: false\nExplanation: \nFirst, evaluate |(f) --> f. The expression is now \"&(f)\".\nThen, evaluate &(f) --> f. The expression is now \"f\".\nFinally, return false.\n\nExample 2:\n\nInput: expression = \"|(f,f,f,t)\"\nOutput: true\nExplanation: The evaluation of (false OR false OR false OR true) is true.\n\nExample 3:\n\nInput: expression = \"!(&(f,t))\"\nOutput: true\nExplanation: \nFirst, evaluate &(f,t) --> (false AND true) --> false --> f. The expression is now \"!(f)\".\nThen, evaluate !(f) --> NOT false --> true. We return true.\n\n\u00a0\nConstraints:\n\n1 <= expression.length <= 2 * 104\nexpression[i] is one following characters: '(', ')', '&', '|', '!', 't', 'f', and ','. Explanation:\n\nSolution 1: Stack\nFor this type of expression parsing problem, we can use a stack to assist.\nWe traverse the expression expression from left to right. For each character $c$ we encounter:\n\nIf $c$ is one of \"tf!&|\", we push it directly onto the stack;\nIf $c$ is a right parenthesis ')', we pop elements from the stack until we encounter an operator '!', '&', or '|'. During this process, we use variables $t$ and $f$ to record the number of 't' and 'f' characters popped from the stack. Finally, based on the number of characters popped and the operator, we calculate a new character 't' or 'f' and push it onto the stack.\n\nAfter traversing the expression expression, there is only one character left in the stack. If it is 't', return true, otherwise return false.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the expression expression. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer array nums and an integer k, you can perform the following operation on the array any number of times:\n\nSelect two adjacent elements of the array like x and y, such that x * y <= k, and replace both of them with a single element with value x * y (e.g. in one operation the array [1, 2, 2, 3] with k = 5 can become [1, 4, 3] or [2, 2, 3], but can't become [1, 2, 6]).\n\nReturn the minimum possible length of nums after any number of operations.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,3,7,3,5], k = 20\nOutput: 3\nExplanation: We perform these operations:\n1. [2,3,3,7,3,5] -> [6,3,7,3,5]\n2. [6,3,7,3,5] -> [18,7,3,5]\n3. [18,7,3,5] -> [18,7,15]\nIt can be shown that 3 is the minimum length possible to achieve with the given operation.\n\nExample 2:\n\nInput: nums = [3,3,3,3], k = 6\nOutput: 4\nExplanation: We can't perform any operations since the product of every two adjacent elements is greater than 6.\nHence, the answer is 4.\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n1 <= k <= 109 Explanation:\n\nSolution 1: Greedy\nWe use a variable $ans$ to record the current length of the array, and a variable $y$ to record the current product of the array. Initially, $ans = 1$ and $y = nums[0]$.\nWe start traversing from the second element of the array. Let the current element be $x$:\n\nIf $x = 0$, then the product of the entire array is $0 \\le k$, so the minimum length of the answer array is $1$, and we can return directly.\nIf $x \\times y \\le k$, then we can merge $x$ and $y$, that is, $y = x \\times y$.\nIf $x \\times y \\gt k$, then we cannot merge $x$ and $y$, so we need to treat $x$ as a separate element, that is, $ans = ans + 1$, and $y = x$.\n\nThe final answer is $ans$.\nThe time complexity is $O(n)$, where n is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\u00a0\nExample 1:\n\nInput: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".\n\nExample 2:\n\nInput: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".\n\nExample 3:\n\nInput: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced.\n\n\u00a0\nConstraints:\n\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2. Explanation:\n\nSolution 1: Greedy\nWe use a variable $x$ to record the current number of unmatched left brackets. We traverse the string $s$, for each character $c$:\n\nIf $c$ is a left bracket, then we increment $x$ by one;\nIf $c$ is a right bracket, then we need to check whether $x$ is greater than zero. If it is, we match the current right bracket with the nearest unmatched left bracket on the left, i.e., decrement $x$ by one.\n\nAfter the traversal, we will definitely get a string of the form \"]]]...[[[...\". We then greedily swap the brackets at both ends each time, which can eliminate $2$ unmatched left brackets at a time. Therefore, the total number of swaps needed is $\\left\\lfloor \\frac{x + 1}{2} \\right\\rfloor$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["parsing-a-boolean-expression", "minimizing-array-after-replacing-pairs-with-their-product", "minimum-number-of-swaps-to-make-the-string-balanced"]}, "2881": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven three integers a, b, and n, return the maximum value of (a XOR x) * (b XOR x) where 0 <= x < 2n.\nSince the answer may be too large, return it modulo 109 + 7.\nNote that XOR is the bitwise XOR operation.\n\u00a0\nExample 1:\n\nInput: a = 12, b = 5, n = 4\nOutput: 98\nExplanation: For x = 2, (a XOR x) = 14 and (b XOR x) = 7. Hence, (a XOR x) * (b XOR x) = 98. \nIt can be shown that 98 is the maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.\n\nExample 2:\n\nInput: a = 6, b = 7 , n = 5\nOutput: 930\nExplanation: For x = 25, (a XOR x) = 31 and (b XOR x) = 30. Hence, (a XOR x) * (b XOR x) = 930.\nIt can be shown that 930 is the maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.\nExample 3:\n\nInput: a = 1, b = 6, n = 3\nOutput: 12\nExplanation: For x = 5, (a XOR x) = 4 and (b XOR x) = 3. Hence, (a XOR x) * (b XOR x) = 12.\nIt can be shown that 12 is the maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.\n\n\u00a0\nConstraints:\n\n0 <= a, b < 250\n0 <= n <= 50 Explanation:\n\nSolution 1: Greedy + Bitwise Operation\nAccording to the problem description, we can assign a number to the $[0..n)$ bits of $a$ and $b$ in binary at the same time, so that the product of $a$ and $b$ is maximized.\nTherefore, we first extract the parts of $a$ and $b$ that are higher than the $n$ bits, denoted as $ax$ and $bx$.\nNext, we consider each bit in $[0..n)$ from high to low. We denote the current bits of $a$ and $b$ as $x$ and $y$.\nIf $x = y$, then we can set the current bit of $ax$ and $bx$ to $1$ at the same time. Therefore, we update $ax = ax \\mid 1 << i$ and $bx = bx \\mid 1 << i$. Otherwise, if $ax < bx$, to maximize the final product, we should set the current bit of $ax$ to $1$. Otherwise, we can set the current bit of $bx$ to $1$.\nFinally, we return $ax \\times bx \\bmod (10^9 + 7)$ as the answer.\nThe time complexity is $O(n)$, where $n$ is the integer given in the problem. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.\n\u00a0\nExample 1:\n\nInput: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n\nExample 2:\n\nInput: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n\nExample 3:\n\nInput: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\n\n\u00a0\nFollow up: Can you find an O(n) solution? Explanation:\n\nSolution 1: Single Pass\nWe can use three variables $m_1$, $m_2$, and $m_3$ to represent the first, second, and third largest numbers in the array respectively. Initially, we set these three variables to negative infinity.\nThen, we iterate through each number in the array. For each number:\n\nIf it equals any of $m_1$, $m_2$, or $m_3$, we skip this number.\nIf it is greater than $m_1$, we update the values of $m_1$, $m_2$, and $m_3$ to $m_2$, $m_3$, and this number respectively.\nIf it is greater than $m_2$, we update the values of $m_2$ and $m_3$ to $m_3$ and this number respectively.\nIf it is greater than $m_3$, we update the value of $m_3$ to this number.\n\nFinally, if the value of $m_3$ has not been updated, it means that there is no third largest number in the array, so we return $m_1$. Otherwise, we return $m_3$.\nThe time complexity is $O(n)$, where $n$ is the length of the array nums. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums. In one operation, you can add or subtract 1 from any element of nums.\nReturn the minimum number of operations to make all elements of nums divisible by 3.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation:\nAll array elements can be made divisible by 3 using 3 operations:\n\nSubtract 1 from 1.\nAdd 1 to 2.\nSubtract 1 from 4.\n\n\nExample 2:\n\nInput: nums = [3,6,9]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Mathematics\nWe directly iterate through the array $\\textit{nums}$. For each element $x$, we calculate the remainder of $x$ divided by 3, $x \\bmod 3$. If the remainder is not 0, we need to make $x$ divisible by 3 with the minimum number of operations. Therefore, we can choose to either decrease $x$ by $x \\bmod 3$ or increase $x$ by $3 - x \\bmod 3$, and we accumulate the minimum of these two values to the answer.\nThe time complexity is $O(n)$, where $n$ is the length of the array $\\textit{nums}$. The space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-xor-product", "third-maximum-number", "find-minimum-operations-to-make-all-elements-divisible-by-three"]}, "2882": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated string because it is not the concatenation of any permutation of words.\n\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\u00a0\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation:\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation:\nThere is no concatenated substring.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation:\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"].\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"].\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"].\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters. Explanation:\n\nSolution 1: Hash Table + Sliding Window\nWe use a hash table $cnt$ to count the number of times each word appears in $words$, and use a hash table $cnt1$ to count the number of times each word appears in the current sliding window. We denote the length of the string $s$ as $m$, the number of words in the string array $words$ as $n$, and the length of each word as $k$.\nWe can enumerate the starting point $i$ of the sliding window, where $0 \\lt i < k$. For each starting point, we maintain a sliding window with the left boundary as $l$, the right boundary as $r$, and the number of words in the sliding window as $t$. Additionally, we use a hash table $cnt1$ to count the number of times each word appears in the sliding window.\nEach time, we extract the string $s[r:r+k]$. If $s[r:r+k]$ is not in the hash table $cnt$, it means that the words in the current sliding window are not valid. We update the left boundary $l$ to $r$, clear the hash table $cnt1$, and reset the word count $t$ to 0. If $s[r:r+k]$ is in the hash table $cnt$, it means that the words in the current sliding window are valid. We increase the word count $t$ by 1, and increase the count of $s[r:r+k]$ in the hash table $cnt1$ by 1. If $cnt1[s[r:r+k]]$ is greater than $cnt[s[r:r+k]]$, it means that $s[r:r+k]$ appears too many times in the current sliding window. We need to move the left boundary $l$ to the right until $cnt1[s[r:r+k]] = cnt[s[r:r+k]]$. If $t = n$, it means that the words in the current sliding window are exactly valid, and we add the left boundary $l$ to the answer array.\nThe time complexity is $O(m \\times k)$, and the space complexity is $O(n \\times k)$. Here, $m$ and $n$ are the lengths of the string $s$ and the string array $words$ respectively, and $k$ is the length of the words in the string array $words$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given the head of a doubly linked list, which contains nodes that have a next pointer and a previous pointer.\nReturn an integer array which contains the elements of the linked list in order.\n\u00a0\nExample 1:\n\nInput: head = [1,2,3,4,3,2,1]\nOutput: [1,2,3,4,3,2,1]\n\nExample 2:\n\nInput: head = [2,2,2,2,2]\nOutput: [2,2,2,2,2]\n\nExample 3:\n\nInput: head = [3,2,3,2,3,2]\nOutput: [3,2,3,2,3,2]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the given list is in the range [1, 50].\n1 <= Node.val <= 50 Explanation:\n\nSolution 1: Direct Traversal\nWe can directly traverse the linked list, adding the values of the nodes to the answer array $\\textit{ans}$ one by one.\nAfter the traversal is complete, return the answer array $\\textit{ans}$.\nThe time complexity is $O(n)$, where $n$ is the length of the linked list. Ignoring the space consumption of the answer array, the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums.\nReturn the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.\nThe value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].\n\u00a0\nExample 1:\n\nInput: nums = [12,6,1,2,7]\nOutput: 77\nExplanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77. \n\nExample 2:\n\nInput: nums = [1,10,3,4,19]\nOutput: 133\nExplanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 0\nExplanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.\n\n\u00a0\nConstraints:\n\n3 <= nums.length <= 100\n1 <= nums[i] <= 106 Explanation:\n\nSolution 1: Maintain Maximum Prefix Value and Maximum Difference\nWe can use two variables $mx$ and $mx_diff$ to maintain the maximum prefix value and maximum difference, respectively. When traversing the array, we update these two variables, and the answer is the maximum value of all $mx_diff \\times nums[i]$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["substring-with-concatenation-of-all-words", "convert-doubly-linked-list-to-array-i", "maximum-value-of-an-ordered-triplet-i"]}, "2883": {"text": "Similar Problem 1 \n\n Problem:\n\nWe have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\n\u00a0\nExample 1:\n\n\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\nOutput: 120\nExplanation: The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n\nExample 2:\n \n\nInput: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\nOutput: 150\nExplanation: The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\nExample 3:\n\n\nInput: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\nOutput: 6\n\n\u00a0\nConstraints:\n\n1 <= startTime.length == endTime.length == profit.length <= 5 * 104\n1 <= startTime[i] < endTime[i] <= 109\n1 <= profit[i] <= 104 Explanation:\n\nSolution 1: Memoization Search + Binary Search\nFirst, we sort the jobs by start time in ascending order, then design a function $dfs(i)$ to represent the maximum profit that can be obtained starting from the $i$-th job. The answer is $dfs(0)$.\nThe calculation process of function $dfs(i)$ is as follows:\nFor the $i$-th job, we can choose to do it or not. If we don't do it, the maximum profit is $dfs(i + 1)$; if we do it, we can use binary search to find the first job that starts after the end time of the $i$-th job, denoted as $j$, then the maximum profit is $profit[i] + dfs(j)$. We take the larger of the two. That is:\n$$\ndfs(i)=\\max(dfs(i+1),profit[i]+dfs(j))\n$$\nWhere $j$ is the smallest index that satisfies $startTime[j] \\ge endTime[i]$.\nIn this process, we can use memoization search to save the answer of each state to avoid repeated calculations.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the number of jobs. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is a hotel with n rooms. The rooms are represented by a 2D integer array rooms where rooms[i] = [roomIdi, sizei] denotes that there is a room with room number roomIdi and size equal to sizei. Each roomIdi is guaranteed to be unique.\nYou are also given k queries in a 2D array queries where queries[j] = [preferredj, minSizej]. The answer to the jth query is the room number id of a room such that:\n\nThe room has a size of at least minSizej, and\nabs(id - preferredj) is minimized, where abs(x) is the absolute value of x.\n\nIf there is a tie in the absolute difference, then use the room with the smallest such id. If there is no such room, the answer is -1.\nReturn an array answer of length k where answer[j] contains the answer to the jth query.\n\u00a0\nExample 1:\n\nInput: rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]\nOutput: [3,-1,3]\nExplanation: The answers to the queries are as follows:\nQuery = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.\nQuery = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.\nQuery = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.\nExample 2:\n\nInput: rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]\nOutput: [2,1,3]\nExplanation: The answers to the queries are as follows:\nQuery = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.\nQuery = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.\nQuery = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3.\n\u00a0\nConstraints:\n\nn == rooms.length\n1 <= n <= 105\nk == queries.length\n1 <= k <= 104\n1 <= roomIdi, preferredj <= 107\n1 <= sizei, minSizej <= 107 Explanation:\n\nSolution 1: Offline Query + Ordered Set + Binary Search\nWe notice that the order of queries does not affect the answer, and the problem involves the size relationship of room areas. Therefore, we can sort the queries in ascending order of minimum area, so that we can process each query from small to large. Also, we sort the rooms in ascending order of area.\nNext, we create an ordered list and add all room numbers to the ordered list.\nThen, we process each query from small to large. For each query, we first remove all rooms with an area less than or equal to the current query's minimum area from the ordered list. Then, in the remaining rooms, we use binary search to find the room number closest to the current query. If there is no such room, we return $-1$.\nThe time complexity is $O(n \\times \\log n + k \\times \\log k)$, and the space complexity is $O(n + k)$. Where $n$ and $k$ are the number of rooms and queries, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nThe frequency of an element is the number of times it occurs in an array.\nYou are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.\nReturn the maximum possible frequency of an element after performing at most k operations.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,4], k = 5\nOutput: 3\nExplanation: Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3.\nExample 2:\n\nInput: nums = [1,4,8,13], k = 5\nOutput: 2\nExplanation: There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n\nExample 3:\n\nInput: nums = [3,9,6], k = 2\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\n1 <= k <= 105 Explanation:\n\nSolution 1: Sorting + Prefix Sum + Binary Search\nAccording to the problem description, we can draw three conclusions:\n\nAfter several operations, the element with the highest frequency in the array must be an element in the original array. Why? Suppose the elements operated are $a_1, a_2, \\cdots, a_m$, where the maximum is $a_m$. These elements have all been changed to the same value $x$, where $x \\geq a_m$. Then we can also change these elements all to $a_m$, and the number of operations will not increase.\nThe elements operated must be a continuous subarray in the sorted array.\nIf a frequency $m$ satisfies the condition, then all $m' < m$ also satisfy the condition. This inspires us to consider using binary search to find the maximum frequency that satisfies the condition.\n\nTherefore, we can sort the array $nums$ and then calculate the prefix sum array $s$ of the sorted array, where $s[i]$ represents the sum of the first $i$ elements.\nNext, we define the left boundary of the binary search as $l = 1$, and the right boundary as $r = n$. For each binary search, we take the middle value $m = (l + r + 1) / 2$, and then check whether there exists a continuous subarray of length $m$ such that all elements in the subarray can be changed to an element in the array, and the number of operations does not exceed $k$. If such a subarray exists, we can update the left boundary $l$ to $m$, otherwise update the right boundary $r$ to $m - 1$.\nFinally, return the left boundary $l$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["maximum-profit-in-job-scheduling", "closest-room", "frequency-of-the-most-frequent-element"]}, "2884": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two positive integers m and n which are the height and width of a 0-indexed 2D-array board, a pair of positive integers (r, c) which is the starting position of the knight on the board.\nYour task is to find an order of movements for the knight, in a manner that every cell of the\u00a0board gets visited exactly once (the starting cell is considered visited and you shouldn't visit it again).\nReturn the array board in which the cells' values show the order of visiting the cell starting from 0 (the initial place of the knight).\nNote that a knight can move from cell (r1, c1) to cell (r2, c2) if 0 <= r2 <= m - 1 and 0 <= c2 <= n - 1 and min(abs(r1 - r2), abs(c1 - c2)) = 1 and max(abs(r1 - r2), abs(c1 - c2)) = 2.\n\u00a0\nExample 1:\n\nInput: m = 1, n = 1, r = 0, c = 0\nOutput: [[0]]\nExplanation: There is only 1 cell and the knight is initially on it so there is only a 0 inside the 1x1 grid.\n\nExample 2:\n\nInput: m = 3, n = 4, r = 0, c = 0\nOutput: [[0,3,6,9],[11,8,1,4],[2,5,10,7]]\nExplanation: By the following order of movements we can visit the entire board.\n(0,0)->(1,2)->(2,0)->(0,1)->(1,3)->(2,1)->(0,2)->(2,3)->(1,1)->(0,3)->(2,2)->(1,0)\n\u00a0\nConstraints:\n\n1 <= m,\u00a0n <= 5\n0 <= r <= m - 1\n0 <= c <= n - 1\nThe inputs will be generated such that there exists at least one\u00a0possible order of movements with the given condition Explanation:\n\nSolution 1: Backtracking\nWe create a two-dimensional array $g$, used to record the knight's movement order, initially $g[r][c] = -1$, and all other positions are set to $-1$ as well. Additionally, we need a variable $ok$ to record whether a solution has been found.\nNext, we start depth-first search from $(r, c)$. Each time we search position $(i, j)$, we first check if $g[i][j]$ equals $m \\times n - 1$. If so, it means we have found a solution, then we set $ok$ to true and return. Otherwise, we enumerate the knight's eight possible movement directions to position $(x, y)$. If $0 \\leq x < m$, $0 \\leq y < n$, and $g[x][y]=-1$, then we update $g[x][y]$ to $g[i][j]+1$, and recursively search position $(x, y)$. If after the search, the variable $ok$ is true, we return directly. Otherwise, we reset $g[x][y]$ to $-1$ and continue searching in other directions.\nFinally, return the two-dimensional array $g$.\nThe time complexity is $O(8^{m \\times n})$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the integers given in the problem. \n\nSimilar Problem 2 \n\n Problem:\n\nAlice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them.\nThe game proceeds as follows:\n\nAlice takes the first turn.\nIn each turn, a player must choose either the clockwise or anti-clockwise direction and pick one flower from that side.\nAt the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.\n\nGiven two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:\n\nAlice must win the game according to the described rules.\nThe number of flowers x in the clockwise direction must be in the range [1,n].\nThe number of flowers y in the anti-clockwise direction must be in the range [1,m].\n\nReturn the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.\n\u00a0\nExample 1:\n\nInput: n = 3, m = 2\nOutput: 3\nExplanation: The following pairs satisfy conditions described in the statement: (1,2), (3,2), (2,1).\n\nExample 2:\n\nInput: n = 1, m = 1\nOutput: 0\nExplanation: No pairs satisfy the conditions described in the statement.\n\n\u00a0\nConstraints:\n\n1 <= n, m <= 105 Explanation:\n\nSolution 1: Mathematics\nAccording to the problem description, in each move, the player will choose to move in a clockwise or counterclockwise direction and then pick a flower. Since Alice moves first, when $x + y$ is odd, Alice will definitely win the game.\nTherefore, the number of flowers $x$ and $y$ meet the following conditions:\n\n$x + y$ is odd;\n$1 \\le x \\le n$;\n$1 \\le y \\le m$.\n\nIf $x$ is odd, $y$ must be even. At this time, the number of values of $x$ is $\\lceil \\frac{n}{2} \\rceil$, the number of values of $y$ is $\\lfloor \\frac{m}{2} \\rfloor$, so the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor$.\nIf $x$ is even, $y$ must be odd. At this time, the number of values of $x$ is $\\lfloor \\frac{n}{2} \\rfloor$, the number of values of $y$ is $\\lceil \\frac{m}{2} \\rceil$, so the number of pairs that meet the conditions is $\\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$.\nTherefore, the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$, which is $\\lfloor \\frac{n + 1}{2} \\rfloor \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lfloor \\frac{m + 1}{2} \\rfloor$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.\nReturn the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.\n\u00a0\nExample 1:\n\nInput: s = \"aabaaaacaabc\", k = 2\nOutput: 8\nExplanation: \nTake three characters from the left of s. You now have two 'a' characters, and one 'b' character.\nTake five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.\nA total of 3 + 5 = 8 minutes is needed.\nIt can be proven that 8 is the minimum number of minutes needed.\n\nExample 2:\n\nInput: s = \"a\", k = 1\nOutput: -1\nExplanation: It is not possible to take one 'b' or 'c' so return -1.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists of only the letters 'a', 'b', and 'c'.\n0 <= k <= s.length Explanation:\n\nSolution 1: Sliding Window\nFirst, we use a hash table or an array of length $3$, denoted as $cnt$, to count the number of each character in string $s$. If any character appears less than $k$ times, it cannot be obtained, so we return $-1$ in advance.\nThe problem asks us to remove characters from the left and right sides of the string, so that the number of each remaining character is not less than $k$. We can consider the problem in reverse: remove a substring of certain size in the middle, so that in the remaining string on both sides, the number of each character is not less than $k$.\nTherefore, we maintain a sliding window, with pointers $j$ and $i$ representing the left and right boundaries of the window, respectively. The string within the window is what we want to remove. Each time we move the right boundary $i$, we add the corresponding character $s[i]$ to the window (i.e., remove one character $s[i]$). If the count of $cnt[s[i]]$ is less than $k$, then we move the left boundary $j$ in a loop until the count of $cnt[s[i]]$ is not less than $k$. The size of the window at this time is $i - j + 1$, and we update the maximum window size.\nThe final answer is the length of string $s$ minus the size of the maximum window.\nThe time complexity is $O(n)$, where $n$ is the length of string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["the-knight\u2019s-tour", "alice-and-bob-playing-flower-game", "take-k-of-each-character-from-left-and-right"]}, "2886": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\nAll the numbers of\u00a0nums are unique. Explanation:\n\nSolution 1: DFS (Backtracking)\nWe design a function $dfs(i)$, which represents starting the search from the $i$th element of the array for all subsets. The execution logic of the function $dfs(i)$ is as follows:\n\nIf $i = n$, it means the current search has ended. Add the current subset $t$ to the answer array $ans$, and then return.\nOtherwise, we can choose not to select the current element and directly execute $dfs(i + 1)$; or we can choose the current element, i.e., add the current element $nums[i]$ to the subset $t$, and then execute $dfs(i + 1)$. Note that we need to remove $nums[i]$ from the subset $t$ after executing $dfs(i + 1)$ (backtracking).\n\nIn the main function, we call $dfs(0)$, i.e., start searching all subsets from the first element of the array. Finally, return the answer array $ans$.\nThe time complexity is $O(n \\times 2^n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. There are a total of $2^n$ subsets, and each subset takes $O(n)$ time to construct. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed m x n matrix grid consisting of positive integers.\nYou can start at any cell in the first column of the matrix, and traverse the grid in the following way:\n\nFrom a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.\n\nReturn the maximum number of moves that you can perform.\n\u00a0\nExample 1:\n\n\nInput: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\nOutput: 3\nExplanation: We can start at the cell (0, 0) and make the following moves:\n- (0, 0) -> (0, 1).\n- (0, 1) -> (1, 2).\n- (1, 2) -> (2, 3).\nIt can be shown that it is the maximum number of moves that can be made.\nExample 2:\n\n\nInput: grid = [[3,2,4],[2,1,9],[1,1,7]]\nOutput: 0\nExplanation: Starting from any cell in the first column we cannot perform any moves.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n1 <= grid[i][j] <= 106 Explanation:\n\nSolution 1: BFS\nWe define a queue $q$, and initially add all the row coordinates of the first column to the queue.\nNext, we start from the first column and traverse column by column. For each column, we take out all the row coordinates in the queue one by one. For each row coordinate $i$, we get all possible row coordinates $k$ of the next column, and satisfy $grid[i][j] < grid[k][j + 1]$, and add these row coordinates to a new set $t$. If $t$ is empty, it means that we cannot continue to move, so we return the current column number. Otherwise, we assign $t$ to $q$ and continue to traverse the next column.\nFinally, if we have traversed all the columns, it means that we can move to the last column, so we return $n - 1$.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m)$. Where $m$ and $n$ are the number of rows and columns in the matrix, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an integer array nums sorted in non-decreasing order and an integer target, return true if target is a majority element, or false otherwise.\nA majority element in an array nums is an element that appears more than nums.length / 2 times in the array.\n\u00a0\nExample 1:\n\nInput: nums = [2,4,5,5,5,5,5,6,6], target = 5\nOutput: true\nExplanation: The value 5 appears 5 times and the length of the array is 9.\nThus, 5 is a majority element because 5 > 9/2 is true.\n\nExample 2:\n\nInput: nums = [10,100,101,101], target = 101\nOutput: false\nExplanation: The value 101 appears 2 times and the length of the array is 4.\nThus, 101 is not a majority element because 2 > 4/2 is false.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i], target <= 109\nnums is sorted in non-decreasing order. Explanation:\n\nSolution 1: Binary Search\nWe notice that the elements in the array $nums$ are non-decreasing, that is, the elements in the array $nums$ are monotonically increasing. Therefore, we can use the method of binary search to find the index $left$ of the first element in the array $nums$ that is greater than or equal to $target$, and the index $right$ of the first element in the array $nums$ that is greater than $target$. If $right - left > \\frac{n}{2}$, it means that the number of occurrences of the element $target$ in the array $nums$ exceeds half of the length of the array, so return $true$, otherwise return $false$.\nThe time complexity is $O(\\log n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["subsets", "maximum-number-of-moves-in-a-grid", "check-if-a-number-is-majority-element-in-a-sorted-array"]}, "2887": {"text": "Similar Problem 1 \n\n Problem:\n\nThere are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n1st friend receives the ball.\n\nAfter that, 1st friend passes it to the friend who is k steps away from them in the clockwise direction.\nAfter that, the friend who receives the ball should pass it to the friend who is 2 * k steps away from them in the clockwise direction.\nAfter that, the friend who receives the ball should pass it to the friend who is 3 * k steps away from them in the clockwise direction, and so on and so forth.\n\nIn other words, on the ith turn, the friend holding the ball should pass it to the friend who is i * k steps away from them in the clockwise direction.\nThe game is finished when some friend receives the ball for the second time.\nThe losers of the game are friends who did not receive the ball in the entire game.\nGiven the number of friends, n, and an integer k, return the array answer, which contains the losers of the game in the ascending order.\n\u00a0\nExample 1:\n\nInput: n = 5, k = 2\nOutput: [4,5]\nExplanation: The game goes as follows:\n1) Start at 1st\u00a0friend and pass the ball to the friend who is 2 steps away from them - 3rd\u00a0friend.\n2) 3rd\u00a0friend passes the ball to the friend who is 4 steps away from them - 2nd\u00a0friend.\n3) 2nd\u00a0friend passes the ball to the friend who is 6 steps away from them  - 3rd\u00a0friend.\n4) The game ends as 3rd\u00a0friend receives the ball for the second time.\n\nExample 2:\n\nInput: n = 4, k = 4\nOutput: [2,3,4]\nExplanation: The game goes as follows:\n1) Start at the 1st\u00a0friend and pass the ball to the friend who is 4 steps away from them - 1st\u00a0friend.\n2) The game ends as 1st\u00a0friend receives the ball for the second time.\n\n\u00a0\nConstraints:\n\n1 <= k <= n <= 50 Explanation:\n\nSolution 1: Simulation\nWe use an array vis to record whether each friend has received the ball, initially, all friends have not received the ball. Then, we simulate the game process according to the rules described in the problem statement until a friend receives the ball for the second time.\nIn the simulation process, we use two variables $i$ and $p$ to represent the current friend holding the ball and the current passing step length, respectively. Initially, $i=0, p=1$, indicating the first friend receives the ball. Each time the ball is passed, we update $i$ to $(i+p \\times k) \\bmod n$, representing the next friend's number to receive the ball, and then update $p$ to $p+1$, representing the step length for the next pass. The game ends when a friend receives the ball for the second time.\nFinally, we iterate through the array vis and add the numbers of friends who have not received the ball to the answer array.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of friends. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a string s, return the number of distinct substrings of\u00a0s.\nA substring of a string is obtained by deleting any number of characters (possibly zero) from the front of the string and any number (possibly zero) from the back of the string.\n\u00a0\nExample 1:\n\nInput: s = \"aabbaba\"\nOutput: 21\nExplanation: The set of distinct strings is [\"a\",\"b\",\"aa\",\"bb\",\"ab\",\"ba\",\"aab\",\"abb\",\"bab\",\"bba\",\"aba\",\"aabb\",\"abba\",\"bbab\",\"baba\",\"aabba\",\"abbab\",\"bbaba\",\"aabbab\",\"abbaba\",\"aabbaba\"]\n\nExample 2:\n\nInput: s = \"abcdefg\"\nOutput: 28\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 500\ns consists of lowercase English letters.\n\n\u00a0\nFollow up: Can you solve this problem in O(n) time complexity? Explanation:\n\nSolution 1: Brute Force Enumeration\nEnumerate all substrings and use a hash table to record the count of different substrings.\nThe time complexity is $O(n^3)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of the string. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\u00a0\nExample 1:\n\nInput: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n\nExample 2:\n\nInput: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109 Explanation:\n\nSolution 1: Discuss Different Cases\nLet $m$ represent the length of string $s$, and $n$ represent the length of string $t$. We can assume that $m$ is always greater than or equal to $n$.\nIf $m-n > 1$, return false directly;\nOtherwise, iterate through $s$ and $t$, if $s[i]$ is not equal to $t[i]$:\n\nIf $m \\neq n$, compare $s[i+1:]$ with $t[i:]$, return true if they are equal, otherwise return false;\nIf $m = n$, compare $s[i:]$ with $t[i:]$, return true if they are equal, otherwise return false.\n\nIf the iteration ends, it means that all the characters of $s$ and $t$ that have been iterated are equal, at this time it needs to satisfy $m=n+1$.\nThe time complexity is $O(m)$, where $m$ is the length of string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["find-the-losers-of-the-circular-game", "number-of-distinct-substrings-in-a-string", "maximum-gap"]}, "2888": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,1,1,1], target = 2\nOutput: 2\nExplanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n\nExample 2:\n\nInput: nums = [-1,3,5,1,4,2,-9], target = 6\nOutput: 2\nExplanation: There are 3 subarrays with sum equal to 6.\n([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n0 <= target <= 106 Explanation:\n\nSolution 1: Greedy + Prefix Sum + Hash Table\nWe traverse the array $nums$, using the method of prefix sum + hash table, to find subarrays with a sum of $target$. If found, we increment the answer by one, then we set the prefix sum to $0$ and continue to traverse the array $nums$ until the entire array is traversed.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nWe have n chips, where the position of the ith chip is position[i].\nWe need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:\n\nposition[i] + 2 or position[i] - 2 with cost = 0.\nposition[i] + 1 or position[i] - 1 with cost = 1.\n\nReturn the minimum cost needed to move all the chips to the same position.\n\u00a0\nExample 1:\n\n\nInput: position = [1,2,3]\nOutput: 1\nExplanation: First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\nExample 2:\n\n\nInput: position = [2,2,2,3,3]\nOutput: 2\nExplanation: We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\nExample 3:\n\nInput: position = [1,1000000000]\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= position.length <= 100\n1 <= position[i] <= 10^9 Explanation:\n\nSolution 1: Quick Thinking\nMove all chips at even indices to position 0, and all chips at odd indices to position 1, all at a cost of 0. Then, choose the position (either 0 or 1) with fewer chips and move these chips to the other position. The minimum cost required is the smaller quantity of chips.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the number of chips. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].\nThe array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.\n\nFor example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:\n\n    \nIf question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.\nIf instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.\n\n\n\nReturn the maximum points you can earn for the exam.\n\u00a0\nExample 1:\n\nInput: questions = [[3,2],[4,3],[4,4],[2,5]]\nOutput: 5\nExplanation: The maximum points can be earned by solving questions 0 and 3.\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n- Unable to solve questions 1 and 2\n- Solve question 3: Earn 2 points\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n\nExample 2:\n\nInput: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\nOutput: 7\nExplanation: The maximum points can be earned by solving questions 1 and 4.\n- Skip question 0\n- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\n- Unable to solve questions 2 and 3\n- Solve question 4: Earn 5 points\nTotal points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.\n\n\u00a0\nConstraints:\n\n1 <= questions.length <= 105\nquestions[i].length == 2\n1 <= pointsi, brainpoweri <= 105 Explanation:\n\nSolution 1: Memoization Search\nWe design a function $dfs(i)$, which represents the maximum score that can be obtained starting from the $i$-th problem. Therefore, the answer is $dfs(0)$.\nThe calculation method of the function $dfs(i)$ is as follows:\n\nIf $i \\geq n$, it means that all problems have been solved, return $0$;\nOtherwise, let the score of the $i$-th problem be $p$, and the number of problems to skip be $b$, then $dfs(i) = \\max(p + dfs(i + b + 1), dfs(i + 1))$.\n\nTo avoid repeated calculations, we can use the method of memoization search, using an array $f$ to record the values of all already computed $dfs(i)$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of problems. \n\n", "problem_ids": ["maximum-number-of-non-overlapping-subarrays-with-sum-equals-target", "minimum-cost-to-move-chips-to-the-same-position", "solving-questions-with-brainpower"]}, "2891": {"text": "Similar Problem 1 \n\n Problem:\n\nThis is an interactive problem.\nThere is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size m x n, and each cell in the grid is either empty or blocked. It is guaranteed that the starting cell and the target cell are different, and neither of them is blocked.\nYou want to find the minimum distance to the target cell. However, you do not know the grid's dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the GridMaster object.\nThr GridMaster class has the following functions:\n\nboolean canMove(char direction) Returns true if the robot can move in that direction. Otherwise, it returns false.\nvoid move(char direction) Moves the robot in that direction. If this move would move the robot to a blocked cell or off the grid, the move will be ignored, and the robot will remain in the same position.\nboolean isTarget() Returns true if the robot is currently on the target cell. Otherwise, it returns false.\n\nNote that direction in the above functions should be a character from {'U','D','L','R'}, representing the directions up, down, left, and right, respectively.\nReturn the minimum distance between the robot's initial starting cell and the target cell. If there is no valid path between the cells, return -1.\nCustom testing:\nThe test input is read as a 2D matrix grid of size m x n where:\n\ngrid[i][j] == -1 indicates that the robot is in cell (i, j) (the starting cell).\ngrid[i][j] == 0 indicates that the cell (i, j) is blocked.\ngrid[i][j] == 1 indicates that the cell (i, j) is empty.\ngrid[i][j] == 2 indicates that the cell (i, j) is the target cell.\n\nThere is exactly one -1 and 2 in grid. Remember that you will not have this information in your code.\n\u00a0\nExample 1:\n\nInput: grid = [[1,2],[-1,0]]\nOutput: 2\nExplanation: One possible interaction is described below:\nThe robot is initially standing on cell (1, 0), denoted by the -1.\n- master.canMove('U') returns true.\n- master.canMove('D') returns false.\n- master.canMove('L') returns false.\n- master.canMove('R') returns false.\n- master.move('U') moves the robot to the cell (0, 0).\n- master.isTarget() returns false.\n- master.canMove('U') returns false.\n- master.canMove('D') returns true.\n- master.canMove('L') returns false.\n- master.canMove('R') returns true.\n- master.move('R') moves the robot to the cell (0, 1).\n- master.isTarget() returns true. \nWe now know that the target is the cell (0, 1), and the shortest path to the target cell is 2.\n\nExample 2:\n\nInput: grid = [[0,0,-1],[1,1,1],[2,0,0]]\nOutput: 4\nExplanation:\u00a0The minimum distance between the robot and the target cell is 4.\nExample 3:\n\nInput: grid = [[-1,0],[0,2]]\nOutput: -1\nExplanation:\u00a0There is no path from the robot to the target cell.\n\u00a0\nConstraints:\n\n1 <= n, m <= 500\nm == grid.length\nn == grid[i].length\ngrid[i][j] is either -1, 0, 1, or 2.\nThere is exactly one -1 in grid.\nThere is exactly one 2 in grid. Explanation:\n\nSolution 1: DFS for Graph Construction + BFS for Shortest Path\nWe can assume that the robot starts from the coordinate $(0, 0)$. Then, we can use DFS to find all reachable coordinates and record them in the hash table $vis$. In addition, we also need to record the coordinates of the endpoint $target$.\nIf the endpoint cannot be found, we directly return $-1$. Otherwise, we can use BFS to find the shortest path.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows and columns of the grid, respectively.\nSimilar problems:\n\n1810. Minimum Path Cost in a Hidden Grid \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an array nums consisting of positive integers.\nReturn the total frequencies of elements in nums\u00a0such that those elements all have the maximum frequency.\nThe frequency of an element is the number of occurrences of that element in the array.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,2,3,1,4]\nOutput: 4\nExplanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.\nSo the number of elements in the array with maximum frequency is 4.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: 5\nExplanation: All elements of the array have a frequency of 1 which is the maximum.\nSo the number of elements in the array with maximum frequency is 5.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100 Explanation:\n\nSolution 1: Counting\nWe can use a hash table or array $cnt$ to record the occurrence of each element.\nThen we traverse $cnt$ to find the element with the most occurrences, and let its occurrence be $mx$. We sum up the occurrences of elements that appear $mx$ times, which is the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array $nums$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a 0-indexed integer array nums, find a 0-indexed integer array answer where:\n\nanswer.length == nums.length.\nanswer[i] = |leftSum[i] - rightSum[i]|.\n\nWhere:\n\nleftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.\nrightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.\n\nReturn the array answer.\n\u00a0\nExample 1:\n\nInput: nums = [10,4,8,3]\nOutput: [15,1,11,22]\nExplanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].\nThe array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].\n\nExample 2:\n\nInput: nums = [1]\nOutput: [0]\nExplanation: The array leftSum is [0] and the array rightSum is [0].\nThe array answer is [|0 - 0|] = [0].\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 105 Explanation:\n\nSolution 1: Prefix Sum\nWe define a variable $left$ to represent the sum of the elements to the left of index $i$ in the array nums, and a variable $right$ to represent the sum of the elements to the right of index $i$ in the array nums. Initially, $left = 0$, $right = \\sum_{i = 0}^{n - 1} nums[i]$.\nWe iterate over the array nums. For the current number $x$ we are iterating over, we update $right = right - x$. At this point, $left$ and $right$ represent the sum of the elements to the left and right of index $i$ in the array nums, respectively. We add the absolute difference between $left$ and $right$ to the answer array ans, and then update $left = left + x$.\nAfter the iteration is complete, we return the answer array ans.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Where $n$ is the length of the array nums.\nSimilar problems:\n\n0724. Find Pivot Index\n1991. Find the Middle Index in Array \n\n", "problem_ids": ["shortest-path-in-a-hidden-grid", "count-elements-with-maximum-frequency", "left-and-right-sum-differences"]}, "2892": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e., the\u00a0length of the garden is n).\nThere are n + 1 taps located at points [0, 1, ..., n] in the garden.\nGiven an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.\nReturn the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.\n\u00a0\nExample 1:\n\n\nInput: n = 5, ranges = [3,4,1,1,0,0]\nOutput: 1\nExplanation: The tap at point 0 can cover the interval [-3,3]\nThe tap at point 1 can cover the interval [-3,5]\nThe tap at point 2 can cover the interval [1,3]\nThe tap at point 3 can cover the interval [2,4]\nThe tap at point 4 can cover the interval [4,4]\nThe tap at point 5 can cover the interval [5,5]\nOpening Only the second tap will water the whole garden [0,5]\n\nExample 2:\n\nInput: n = 3, ranges = [0,0,0,0]\nOutput: -1\nExplanation: Even if you activate all the four taps you cannot water the whole garden.\n\n\u00a0\nConstraints:\n\n1 <= n <= 104\nranges.length == n + 1\n0 <= ranges[i] <= 100 Explanation:\n\nSolution 1: Greedy\nWe note that for all taps that can cover a certain left endpoint, choosing the tap that can cover the farthest right endpoint is optimal.\nTherefore, we can preprocess the array $ranges$. For the $i$-th tap, it can cover the left endpoint $l = \\max(0, i - ranges[i])$ and the right endpoint $r = i + ranges[i]$. We calculate the position of the tap that can cover the left endpoint $l$ with the farthest right endpoint and record it in the array $last[i]$.\nThen we define the following three variables:\n\nVariable $ans$ represents the final answer, i.e., the minimum number of taps;\nVariable $mx$ represents the farthest right endpoint that can currently be covered;\nVariable $pre$ represents the farthest right endpoint covered by the previous tap.\n\nWe traverse all positions in the range $[0, \\ldots, n-1]$. For the current position $i$, we use $last[i]$ to update $mx$, i.e., $mx = \\max(mx, last[i])$.\n\nIf $mx \\leq i$, it means the next position cannot be covered, so we return $-1$.\nIf $pre = i$, it means a new subinterval needs to be used, so we increment $ans$ by $1$ and update $pre = mx$.\n\nAfter the traversal, we return $ans$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the garden.\nSimilar problems:\n\n45. Jump Game II\n55. Jump Game\n1024. Video Stitching \n\nSimilar Problem 2 \n\n Problem:\n\nGiven the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:\n\n\nIf the current number is even, you have to divide it by 2.\n\n\nIf the current number is odd, you have to add 1 to it.\n\n\nIt is guaranteed that you can always reach one for all test cases.\n\u00a0\nExample 1:\n\nInput: s = \"1101\"\nOutput: 6\nExplanation: \"1101\" corressponds to number 13 in their decimal representation.\nStep 1) 13 is odd, add 1 and obtain 14.\u00a0\nStep 2) 14 is even, divide by 2 and obtain 7.\nStep 3) 7 is odd, add 1 and obtain 8.\nStep 4) 8 is even, divide by 2 and obtain 4.\u00a0 \nStep 5) 4 is even, divide by 2 and obtain 2.\u00a0\nStep 6) 2 is even, divide by 2 and obtain 1.\u00a0 \n\nExample 2:\n\nInput: s = \"10\"\nOutput: 1\nExplanation: \"10\" corresponds to number 2 in their decimal representation.\nStep 1) 2 is even, divide by 2 and obtain 1.\u00a0 \n\nExample 3:\n\nInput: s = \"1\"\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= s.length\u00a0<= 500\ns consists of characters '0' or '1'\ns[0] == '1' Explanation:\n\nSolution 1: Simulation\nWe simulate operations $1$ and $2$, while using carry to record the carry-over.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the 0-indexed arrays prices and profits of length n. There are n items in an store where the ith item has a price of prices[i] and a profit of profits[i].\nWe have to pick three items with the following condition:\n\nprices[i] < prices[j] < prices[k] where i < j < k.\n\nIf we pick items with indices i, j and k satisfying the above condition, the profit would be profits[i] + profits[j] + profits[k].\nReturn the maximum profit we can get, and -1 if it's not possible to pick three items with the given condition.\n\u00a0\nExample 1:\n\nInput: prices = [10,2,3,4], profits = [100,2,7,10]\nOutput: 19\nExplanation: We can't pick the item with index i=0 since there are no indices j and k such that the condition holds.\nSo the only triplet we can pick, are the items with indices 1, 2 and 3 and it's a valid pick since prices[1] < prices[2] < prices[3].\nThe answer would be sum of their profits which is 2 + 7 + 10 = 19.\nExample 2:\n\nInput: prices = [1,2,3,4,5], profits = [1,5,3,4,6]\nOutput: 15\nExplanation: We can select any triplet of items since for each triplet of indices i, j and k such that i < j < k, the condition holds.\nTherefore the maximum profit we can get would be the 3 most profitable items which are indices 1, 3 and 4.\nThe answer would be sum of their profits which is 5 + 4 + 6 = 15.\nExample 3:\n\nInput: prices = [4,3,2,1], profits = [33,20,19,87]\nOutput: -1\nExplanation: We can't select any triplet of indices such that the condition holds, so we return -1.\n\n\u00a0\nConstraints:\n\n3 <= prices.length == profits.length <= 2000\n1 <= prices[i] <= 106\n1 <= profits[i] <= 106 Explanation:\n\nSolution 1: Enumerate the Middle Element\nWe can enumerate the middle element $profits[j]$, and then enumerate the left element $profits[i]$ and the right element $profits[k]$. For each $profits[j]$, we need to find the maximum $profits[i]$ and the maximum $profits[k]$ such that $prices[i] < prices[j] < prices[k]$. We define $left$ as the maximum value on the left of $profits[j]$, and $right$ as the maximum value on the right of $profits[j]$. If they exist, we update the answer as $ans = \\max(ans, left + profits[j] + right)$.\nThe time complexity is $O(n^2)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-number-of-taps-to-open-to-water-a-garden", "number-of-steps-to-reduce-a-number-in-binary-representation-to-one", "maximum-profitable-triplets-with-increasing-prices-i"]}, "2893": {"text": "Similar Problem 1 \n\n Problem:\n\nAlice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them.\nThe game proceeds as follows:\n\nAlice takes the first turn.\nIn each turn, a player must choose either the clockwise or anti-clockwise direction and pick one flower from that side.\nAt the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.\n\nGiven two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:\n\nAlice must win the game according to the described rules.\nThe number of flowers x in the clockwise direction must be in the range [1,n].\nThe number of flowers y in the anti-clockwise direction must be in the range [1,m].\n\nReturn the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.\n\u00a0\nExample 1:\n\nInput: n = 3, m = 2\nOutput: 3\nExplanation: The following pairs satisfy conditions described in the statement: (1,2), (3,2), (2,1).\n\nExample 2:\n\nInput: n = 1, m = 1\nOutput: 0\nExplanation: No pairs satisfy the conditions described in the statement.\n\n\u00a0\nConstraints:\n\n1 <= n, m <= 105 Explanation:\n\nSolution 1: Mathematics\nAccording to the problem description, in each move, the player will choose to move in a clockwise or counterclockwise direction and then pick a flower. Since Alice moves first, when $x + y$ is odd, Alice will definitely win the game.\nTherefore, the number of flowers $x$ and $y$ meet the following conditions:\n\n$x + y$ is odd;\n$1 \\le x \\le n$;\n$1 \\le y \\le m$.\n\nIf $x$ is odd, $y$ must be even. At this time, the number of values of $x$ is $\\lceil \\frac{n}{2} \\rceil$, the number of values of $y$ is $\\lfloor \\frac{m}{2} \\rfloor$, so the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor$.\nIf $x$ is even, $y$ must be odd. At this time, the number of values of $x$ is $\\lfloor \\frac{n}{2} \\rfloor$, the number of values of $y$ is $\\lceil \\frac{m}{2} \\rceil$, so the number of pairs that meet the conditions is $\\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$.\nTherefore, the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$, which is $\\lfloor \\frac{n + 1}{2} \\rfloor \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lfloor \\frac{m + 1}{2} \\rfloor$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\n\u00a0\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums is guaranteed to be rotated at some pivot.\n-104 <= target <= 104\n\n\u00a0\nFollow up: This problem is similar to\u00a0Search in Rotated Sorted Array, but\u00a0nums may contain duplicates. Would this affect the runtime complexity? How and why? Explanation:\n\nSolution 1: Binary Search\nWe define the left boundary $l=0$ and the right boundary $r=n-1$ for the binary search, where $n$ is the length of the array.\nDuring each binary search process, we get the current midpoint $mid=(l+r)/2$.\n\nIf $nums[mid] \\gt nums[r]$, it means that $[l,mid]$ is ordered. At this time, if $nums[l] \\le target \\le nums[mid]$, it means that $target$ is in $[l,mid]$, otherwise $target$ is in $[mid+1,r]$.\nIf $nums[mid] \\lt nums[r]$, it means that $[mid+1,r]$ is ordered. At this time, if $nums[mid] \\lt target \\le nums[r]$, it means that $target$ is in $[mid+1,r]$, otherwise $target$ is in $[l,mid]$.\nIf $nums[mid] = nums[r]$, it means that the elements $nums[mid]$ and $nums[r]$ are equal. At this time, we cannot determine which interval $target$ is in, so we can only decrease $r$ by $1$.\n\nAfter the binary search ends, if $nums[l] = target$, it means that the target value $target$ exists in the array, otherwise it means it does not exist.\nThe time complexity is approximately $O(\\log n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nOn a social network consisting of m users and some friendships between users, two users can communicate with each other if they know a common language.\nYou are given an integer n, an array languages, and an array friendships where:\n\nThere are n languages numbered 1 through n,\nlanguages[i] is the set of languages the i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b user knows, and\nfriendships[i] = [u\u200b\u200b\u200b\u200b\u200b\u200bi\u200b\u200b\u200b, v\u200b\u200b\u200b\u200b\u200b\u200bi] denotes a friendship between the users u\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bi\u200b\u200b\u200b\u200b\u200b and vi.\n\nYou can choose one language and teach it to some users so that all friends can communicate with each other. Return the minimum number of users you need to teach.\nNote that friendships are not transitive, meaning if x is a friend of y and y is a friend of z, this doesn't guarantee that x is a friend of z.\n\u00a0\nExample 1:\n\nInput: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]\nOutput: 1\nExplanation: You can either teach user 1 the second language or user 2 the first language.\n\nExample 2:\n\nInput: n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]\nOutput: 2\nExplanation: Teach the third language to users 1 and 3, yielding two users to teach.\n\n\u00a0\nConstraints:\n\n2 <= n <= 500\nlanguages.length == m\n1 <= m <= 500\n1 <= languages[i].length <= n\n1 <= languages[i][j] <= n\n1 <= u\u200b\u200b\u200b\u200b\u200b\u200bi < v\u200b\u200b\u200b\u200b\u200b\u200bi <= languages.length\n1 <= friendships.length <= 500\nAll tuples (u\u200b\u200b\u200b\u200b\u200bi, v\u200b\u200b\u200b\u200b\u200b\u200bi) are unique\nlanguages[i] contains only unique values Explanation:\n\nSolution 1: Simulation + Statistics\nFor each friendship, if the sets of languages known by the two people do not intersect, then a language needs to be taught so that the two people can communicate with each other. We put these people into a hash set $s$.\nThen in this set $s$, we count the number of people who know each language, and get the maximum number, which we denote as $mx$. So the answer is len(s) - mx.\nThe time complexity is $O(m^2 \\times k)$. Here, $m$ is the number of languages, and $k$ is the number of friendships. \n\n", "problem_ids": ["alice-and-bob-playing-flower-game", "search-in-rotated-sorted-array-ii", "minimum-number-of-people-to-teach"]}, "2902": {"text": "Similar Problem 1 \n\n Problem:\n\nThere are n people and 40 types of hats labeled from 1 to 40.\nGiven a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person.\nReturn the number of ways that the n people wear different hats to each other.\nSince the answer may be too large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: hats = [[3,4],[4,5],[5]]\nOutput: 1\nExplanation: There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\n\nExample 2:\n\nInput: hats = [[3,5,1],[3,5]]\nOutput: 4\nExplanation: There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)\n\nExample 3:\n\nInput: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\nOutput: 24\nExplanation: Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24.\n\n\u00a0\nConstraints:\n\nn == hats.length\n1 <= n <= 10\n1 <= hats[i].length <= 40\n1 <= hats[i][j] <= 40\nhats[i] contains a list of unique integers. Explanation:\n\nSolution 1: Dynamic Programming\nWe notice that $n$ is not greater than $10$, so we consider using DP with state compression to solve this problem.\nWe define $f[i][j]$ as the number of ways to assign the first $i$ hats to the people whose state is $j$. Here $j$ is a binary number, which represents a set of people. We have $f[0][0]=1$ at the beginning, and the answer is $f[m][2^n - 1]$, where $m$ is the maximum number of hats and $n$ is the number of people.\nConsider $f[i][j]$. If we don't assign the $i$-th hat to anyone, then $f[i][j]=f[i-1][j]$; if we assign the $i$-th hat to the person $k$ who likes it, then $f[i][j]=f[i-1][j \\oplus 2^k]$. Here $\\oplus$ denotes the XOR operation. Therefore, we can get the state transition equation:\n$$\nf[i][j]=f[i-1][j]+ \\sum_{k \\in like[i]} f[i-1][j \\oplus 2^k]\n$$\nwhere $like[i]$ denotes the set of people who like the $i$-th hat.\nThe final answer is $f[m][2^n - 1]$, and the answer may be very large, so we need to take it modulo $10^9 + 7$.\nTime complexity $O(m \\times 2^n \\times n)$, space complexity $O(m \\times 2^n)$. Here $m$ is the maximum number of hats, which is no more than $40$ in this problem; and $n$ is the number of people, which is no more than $10$ in this problem. \n\nSimilar Problem 2 \n\n Problem:\n\nYou have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:\n\nChose two indices i and j, and swap the ith\u00a0fruit of basket1 with the jth\u00a0fruit of basket2.\nThe cost of the swap is min(basket1[i],basket2[j]).\n\nTwo baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.\nReturn the minimum cost to make both the baskets equal or -1 if impossible.\n\u00a0\nExample 1:\n\nInput: basket1 = [4,2,2,2], basket2 = [1,4,1,2]\nOutput: 1\nExplanation: Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal.\n\nExample 2:\n\nInput: basket1 = [2,3,4,1], basket2 = [3,2,5,1]\nOutput: -1\nExplanation: It can be shown that it is impossible to make both the baskets equal.\n\n\u00a0\nConstraints:\n\nbasket1.length == basket2.length\n1 <= basket1.length <= 105\n1 <= basket1[i],basket2[i]\u00a0<= 109 Explanation:\n\nSolution 1: Greedy + Construction\nFirst, we can remove the common elements from both arrays. For the remaining numbers, the occurrence of each number must be even, otherwise, it is impossible to construct identical arrays. Let's denote the arrays after removing common elements as $a$ and $b$.\nNext, we consider how to perform the swaps.\nIf we want to swap the smallest number in $a$, we need to find the largest number in $b$ to swap with it; similarly, if we want to swap the smallest number in $b$, we need to find the largest number in $a$ to swap with it. This can be achieved by sorting.\nHowever, there is another swapping scheme. We can use a smallest number $mi$ as a transition element, first swap the number in $a$ with $mi$, and then swap $mi$ with the number in $b$. In this way, the cost of swapping is $2 \\times mi$.\nIn the code implementation, we can directly merge arrays $a$ and $b$ into an array $nums$, and then sort the array $nums$. Next, we enumerate the first half of the numbers, calculate the minimum cost each time, and add it to the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference between any two time-points in the list.\n\u00a0\nExample 1:\nInput: timePoints = [\"23:59\",\"00:00\"]\nOutput: 1\n\nExample 2:\nInput: timePoints = [\"00:00\",\"23:59\",\"00:00\"]\nOutput: 0\n\n\u00a0\nConstraints:\n\n2 <= timePoints.length <= 2 * 104\ntimePoints[i] is in the format \"HH:MM\". Explanation:\n\nSolution 1: Sorting\nWe notice that there can be at most $24 \\times 60 = 1440$ distinct time points. Therefore, if the length of $timePoints$ exceeds $1440$, it implies there are duplicate time points, and we can return $0$ early.\nNext, we iterate through the list of time points and convert it into a list of minutes $nums$. For example, for the time point 13:14, we convert it into $13 \\times 60 + 14$.\nThen, we sort the list of minutes in ascending order and append the smallest time $nums[0]$ plus $1440$ to the end of the list. This step is to handle the special case of the difference between the maximum and minimum values.\nFinally, we iterate through the list of minutes to find the minimum difference between any two adjacent times.\nThe time complexity is $O(n \\log n)$, and the space complexity is $O(n)$, where $n$ is the number of time points. \n\n", "problem_ids": ["number-of-ways-to-wear-different-hats-to-each-other", "rearranging-fruits", "minimum-time-difference"]}, "2915": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string word that consists of digits and lowercase English letters.\nYou will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123\u00a0 34 8\u00a0 34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\".\nReturn the number of different integers after performing the replacement operations on word.\nTwo integers are considered different if their decimal representations without any leading zeros are different.\n\u00a0\nExample 1:\n\nInput: word = \"a123bc34d8ef34\"\nOutput: 3\nExplanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once.\n\nExample 2:\n\nInput: word = \"leet1234code234\"\nOutput: 2\n\nExample 3:\n\nInput: word = \"a1b01c001\"\nOutput: 1\nExplanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values.\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 1000\nword consists of digits and lowercase English letters. Explanation:\n\nSolution 1: Double Pointers + Simulation\nTraverse the string word, find the start and end positions of each integer, cut out this substring, and store it in the hash set $s$.\nAfter the traversal, return the size of the hash set $s$.\n\nNote, the integer represented by each substring may be very large, we cannot directly convert it to an integer. Therefore, we can remove the leading zeros of each substring before storing it in the hash set.\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string word. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.\n\u00a0\nExample 1:\n\nInput: c = 5\nOutput: true\nExplanation: 1 * 1 + 2 * 2 = 5\n\nExample 2:\n\nInput: c = 3\nOutput: false\n\n\u00a0\nConstraints:\n\n0 <= c <= 231 - 1 Explanation:\n\nSolution 1: Mathematics + Two Pointers\nWe can use the two-pointer method to solve this problem. Define two pointers $a$ and $b$, pointing to $0$ and $\\sqrt{c}$ respectively. In each step, we calculate the value of $s = a^2 + b^2$, and then compare the size of $s$ and $c$. If $s = c$, we have found two integers $a$ and $b$ such that $a^2 + b^2 = c$. If $s < c$, we increase the value of $a$ by $1$. If $s > c$, we decrease the value of $b$ by $1$. We continue this process until we find the answer, or the value of $a$ is greater than the value of $b$, and return false.\nThe time complexity is $O(\\sqrt{c})$, where $c$ is the given non-negative integer. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven two strings low and high that represent two integers low and high where low <= high, return the number of strobogrammatic numbers in the range [low, high].\nA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\u00a0\nExample 1:\nInput: low = \"50\", high = \"100\"\nOutput: 3\n\nExample 2:\nInput: low = \"0\", high = \"0\"\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= low.length, high.length <= 15\nlow and high consist of only digits.\nlow <= high\nlow and high do not contain any leading zeros except for zero itself. Explanation:\n\nSolution 1: Recursion\nIf the length is $1$, then the strobogrammatic numbers are only $0, 1, 8$; if the length is $2$, then the strobogrammatic numbers are only $11, 69, 88, 96$.\nWe design a recursive function $dfs(u)$, which returns the strobogrammatic numbers of length $u$.\nIf $u$ is $0$, return a list containing an empty string, i.e., [\"\"]; if $u$ is $1$, return the list [\"0\", \"1\", \"8\"].\nIf $u$ is greater than $1$, we traverse all the strobogrammatic numbers of length $u - 2$. For each strobogrammatic number $v$, we add $1, 8, 6, 9$ to both sides of it, and we can get the strobogrammatic numbers of length $u$.\nNote that if $u \\neq n$, we can also add $0$ to both sides of the strobogrammatic number.\nLet the lengths of $low$ and $high$ be $a$ and $b$ respectively.\nNext, we traverse all lengths in the range $[a,..b]$. For each length $n$, we get all strobogrammatic numbers $dfs(n)$, and then check whether they are in the range $[low, high]$. If they are, we increment the answer.\nThe time complexity is $O(2^{n+2} \\times \\log n)$.\nSimilar problems:\n\n247. Strobogrammatic Number II \n\n", "problem_ids": ["number-of-different-integers-in-a-string", "sum-of-square-numbers", "strobogrammatic-number-iii"]}, "2916": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the head of a linked list head, in which each node contains an integer value.\nBetween every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.\nReturn the linked list after insertion.\nThe greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.\n\u00a0\nExample 1:\n\n\nInput: head = [18,6,10,3]\nOutput: [18,6,6,2,10,1,3]\nExplanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).\n- We insert the greatest common divisor of 18 and 6 = 6 between the 1st and the 2nd nodes.\n- We insert the greatest common divisor of 6 and 10 = 2 between the 2nd and the 3rd nodes.\n- We insert the greatest common divisor of 10 and 3 = 1 between the 3rd and the 4th nodes.\nThere are no more adjacent nodes, so we return the linked list.\n\nExample 2:\n\n\nInput: head = [7]\nOutput: [7]\nExplanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes.\nThere are no pairs of adjacent nodes, so we return the initial linked list.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is in the range [1, 5000].\n1 <= Node.val <= 1000 Explanation:\n\nSolution 1: Simulation\nWe use two pointers $pre$ and $cur$ to point to the current node and the next node respectively. We only need to insert a new node between $pre$ and $cur$. Therefore, each time we calculate the greatest common divisor $x$ of $pre$ and $cur$, we insert a new node with value $x$ between $pre$ and $cur$. Then we update $pre = cur$ and $cur = cur.next$, and continue to traverse the linked list until $cur$ is null.\nThe time complexity is $O(n \\times \\log M)$, where $n$ is the length of the linked list, and $M$ is the maximum value of the nodes in the linked list. Ignoring the space consumption of the result linked list, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.\nYou are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nYou need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.\nReturn the maximum total importance of all roads possible after assigning the values optimally.\n\u00a0\nExample 1:\n\n\nInput: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\nOutput: 43\nExplanation: The figure above shows the country and the assigned values of [2,4,5,3,1].\n- The road (0,1) has an importance of 2 + 4 = 6.\n- The road (1,2) has an importance of 4 + 5 = 9.\n- The road (2,3) has an importance of 5 + 3 = 8.\n- The road (0,2) has an importance of 2 + 5 = 7.\n- The road (1,3) has an importance of 4 + 3 = 7.\n- The road (2,4) has an importance of 5 + 1 = 6.\nThe total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.\nIt can be shown that we cannot obtain a greater total importance than 43.\n\nExample 2:\n\n\nInput: n = 5, roads = [[0,3],[2,4],[1,3]]\nOutput: 20\nExplanation: The figure above shows the country and the assigned values of [4,3,2,5,1].\n- The road (0,3) has an importance of 4 + 5 = 9.\n- The road (2,4) has an importance of 2 + 1 = 3.\n- The road (1,3) has an importance of 3 + 5 = 8.\nThe total importance of all roads is 9 + 3 + 8 = 20.\nIt can be shown that we cannot obtain a greater total importance than 20.\n\n\u00a0\nConstraints:\n\n2 <= n <= 5 * 104\n1 <= roads.length <= 5 * 104\nroads[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\nThere are no duplicate roads. Explanation:\n\nSolution 1: Greedy + Sorting\nWe consider the contribution of each city to the total importance of all roads, recorded in the array $\\textit{deg}$. Then, we sort $\\textit{deg}$ by contribution from smallest to largest and allocate $[1, 2, ..., n]$ to the cities in order.\nThe time complexity is $O(n \\log n)$, and the space complexity is $O(n)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.\nWe want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\nReturn the reformatted license key.\n\u00a0\nExample 1:\n\nInput: s = \"5F3Z-2e-9-w\", k = 4\nOutput: \"5F3Z-2E9W\"\nExplanation: The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n\nExample 2:\n\nInput: s = \"2-5g-3-J\", k = 2\nOutput: \"2-5G-3J\"\nExplanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists of English letters, digits, and dashes '-'.\n1 <= k <= 104 Explanation:\n\nSolution 1: Simulation\nFirst, we count the number of characters in the string $s$ excluding the hyphens, and take the modulus of $k$ to determine the number of characters in the first group. If it is $0$, then the number of characters in the first group is $k$; otherwise, it is the result of the modulus operation.\nNext, we iterate through the string $s$. For each character, if it is a hyphen, we skip it; otherwise, we convert it to an uppercase letter and add it to the answer string. Meanwhile, we maintain a counter $cnt$, representing the remaining number of characters in the current group. When $cnt$ decreases to $0$, we need to update $cnt$ to $k$, and if the current character is not the last one, we need to add a hyphen to the answer string.\nFinally, we remove the hyphen at the end of the answer string and return the answer string.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. Ignoring the space consumption of the answer string, the space complexity is $O(1)$. \n\n", "problem_ids": ["insert-greatest-common-divisors-in-linked-list", "maximum-total-importance-of-roads", "license-key-formatting"]}, "2917": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.\n\n\u00a0\nExample 1:\n\nInput: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.\n\nExample 2:\n\nInput: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109\n\n\u00a0 Explanation:\n\nSolution 1: Memoization Search\nWe design a function $dfs(i)$ to represent the minimum number of partitions starting from index $i$ of string $s$. The answer is $dfs(0)$.\nThe calculation process of the function $dfs(i)$ is as follows:\n\nIf $i \\geq n$, it means that it has reached the end of the string, return $0$.\nOtherwise, we enumerate all substrings starting from $i$. If the value of the substring is less than or equal to $k$, then we can take the substring as a partition. Then we can get $dfs(j + 1)$, where $j$ is the end index of the substring. We take the minimum value among all possible partitions, add $1$, and that is the value of $dfs(i)$.\n\nFinally, if $dfs(0) = \\infty$, it means there is no good partition, return $-1$. Otherwise, return $dfs(0)$.\nTo avoid repeated calculations, we can use memoization search.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the string $s$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou have a certain number of processors, each having 4 cores. The number of tasks to be executed is four times the number of processors. Each task must be assigned to a unique core, and each core can only be used once.\nYou are given an array processorTime representing the time each processor becomes available and an array tasks representing how long each task takes to complete. Return the\u00a0minimum time needed to complete all tasks.\n\u00a0\nExample 1:\n\nInput: processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]\nOutput: 16\nExplanation:\nAssign the tasks at indices 4, 5, 6, 7 to the first processor which becomes available at time = 8, and the tasks at indices 0, 1, 2, 3 to the second processor which becomes available at time = 10.\u00a0\nThe time taken by the first processor to finish the execution of all tasks is\u00a0max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16.\nThe time taken by the second processor to finish the execution of all tasks is\u00a0max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13.\n\nExample 2:\n\nInput: processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]\nOutput: 23\nExplanation:\nAssign the tasks at indices 1, 4, 5, 6 to the first processor and the others to the second processor.\nThe time taken by the first processor to finish the execution of all tasks is max(10 + 3, 10 + 5, 10 + 8, 10 + 4) = 18.\nThe time taken by the second processor to finish the execution of all tasks is max(20 + 2, 20 + 1, 20 + 2, 20 + 3) = 23.\n\n\u00a0\nConstraints:\n\n1 <= n == processorTime.length <= 25000\n1 <= tasks.length <= 105\n0 <= processorTime[i] <= 109\n1 <= tasks[i] <= 109\ntasks.length == 4 * n Explanation:\n\nSolution 1: Greedy + Sorting\nTo minimize the time required to process all tasks, the four tasks with the longest processing time should be assigned to the processors that become idle earliest.\nTherefore, we sort the processors by their idle time and sort the tasks by their processing time. Then, we assign the four tasks with the longest processing time to the processor that becomes idle earliest, and calculate the maximum end time.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the number of tasks. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:\n\nIn the beginning, you have the permutation P=[1,2,3,...,m].\nFor the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].\n\nReturn an array containing the result for the given queries.\n\u00a0\nExample 1:\n\nInput: queries = [3,1,2,1], m = 5\nOutput: [2,1,2,1] \nExplanation: The queries are processed as follow: \nFor i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. \nFor i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. \nFor i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. \nFor i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. \nTherefore, the array containing the result is [2,1,2,1].  \n\nExample 2:\n\nInput: queries = [4,1,2,2], m = 4\nOutput: [3,1,2,0]\n\nExample 3:\n\nInput: queries = [7,5,5,8,3], m = 8\nOutput: [6,5,0,7,5]\n\n\u00a0\nConstraints:\n\n1 <= m <= 10^3\n1 <= queries.length <= m\n1 <= queries[i] <= m Explanation:\n\nSolution 1: Simulation\nThe problem's data scale is not large, so we can directly simulate it. \n\n", "problem_ids": ["partition-string-into-substrings-with-values-at-most-k", "minimum-processing-time", "queries-on-a-permutation-with-key"]}, "2919": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string s, return the number of substrings that have only one distinct letter.\n\u00a0\nExample 1:\n\nInput: s = \"aaaba\"\nOutput: 8\nExplanation: The substrings with one distinct letter are \"aaa\", \"aa\", \"a\", \"b\".\n\"aaa\" occurs 1 time.\n\"aa\" occurs 2 times.\n\"a\" occurs 4 times.\n\"b\" occurs 1 time.\nSo the answer is 1 + 2 + 4 + 1 = 8.\n\nExample 2:\n\nInput: s = \"aaaaaaaaaa\"\nOutput: 55\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 1000\ns[i] consists of only lowercase English letters. Explanation:\n\nSolution 1: Two Pointers\nWe can use two pointers, where pointer $i$ points to the start of the current substring, and pointer $j$ moves to the right to the first position that is different from $s[i]$. Then, $[i,..j-1]$ is a substring with $s[i]$ as the only character, and its length is $j-i$. Therefore, the number of substrings with $s[i]$ as the only character is $\\frac{(j-i+1)(j-i)}{2}$, which is added to the answer. Then, we set $i=j$ and continue to traverse until $i$ exceeds the range of string $s$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed m x n matrix grid consisting of positive integers.\nYou can start at any cell in the first column of the matrix, and traverse the grid in the following way:\n\nFrom a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.\n\nReturn the maximum number of moves that you can perform.\n\u00a0\nExample 1:\n\n\nInput: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\nOutput: 3\nExplanation: We can start at the cell (0, 0) and make the following moves:\n- (0, 0) -> (0, 1).\n- (0, 1) -> (1, 2).\n- (1, 2) -> (2, 3).\nIt can be shown that it is the maximum number of moves that can be made.\nExample 2:\n\n\nInput: grid = [[3,2,4],[2,1,9],[1,1,7]]\nOutput: 0\nExplanation: Starting from any cell in the first column we cannot perform any moves.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n1 <= grid[i][j] <= 106 Explanation:\n\nSolution 1: BFS\nWe define a queue $q$, and initially add all the row coordinates of the first column to the queue.\nNext, we start from the first column and traverse column by column. For each column, we take out all the row coordinates in the queue one by one. For each row coordinate $i$, we get all possible row coordinates $k$ of the next column, and satisfy $grid[i][j] < grid[k][j + 1]$, and add these row coordinates to a new set $t$. If $t$ is empty, it means that we cannot continue to move, so we return the current column number. Otherwise, we assign $t$ to $q$ and continue to traverse the next column.\nFinally, if we have traversed all the columns, it means that we can move to the last column, so we return $n - 1$.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m)$. Where $m$ and $n$ are the number of rows and columns in the matrix, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.\nReturn the maximum possible length of s.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\nExample 1:\n\nInput: arr = [\"un\",\"iq\",\"ue\"]\nOutput: 4\nExplanation: All the valid concatenations are:\n- \"\"\n- \"un\"\n- \"iq\"\n- \"ue\"\n- \"uniq\" (\"un\" + \"iq\")\n- \"ique\" (\"iq\" + \"ue\")\nMaximum length is 4.\n\nExample 2:\n\nInput: arr = [\"cha\",\"r\",\"act\",\"ers\"]\nOutput: 6\nExplanation: Possible longest valid concatenations are \"chaers\" (\"cha\" + \"ers\") and \"acters\" (\"act\" + \"ers\").\n\nExample 3:\n\nInput: arr = [\"abcdefghijklmnopqrstuvwxyz\"]\nOutput: 26\nExplanation: The only string in arr has all 26 characters.\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 16\n1 <= arr[i].length <= 26\narr[i] contains only lowercase English letters. Explanation:\n\nSolution 1: Bit Manipulation + State Compression\nState compression is used, with a 32-bit number recording the occurrence of letters, and masks storing the strings enumerated before.\nThe time complexity is $O(2^n + L)$, and the space complexity is $O(2^n)$. Where $n$ and $L$ are the length of the string array and the sum of the lengths of the strings in the array, respectively. \n\n", "problem_ids": ["count-substrings-with-only-one-distinct-letter", "maximum-number-of-moves-in-a-grid", "maximum-length-of-a-concatenated-string-with-unique-characters"]}, "2920": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a collection of numbered balls\u00a0and instructed to sort them into boxes for a nearly balanced distribution. There are two rules you must follow:\n\nBalls with the same\u00a0box must have the same value. But, if you have more than one ball with the same number, you can put them in different boxes.\nThe biggest box can only have one more ball than the smallest box.\n\n\u200bReturn the fewest number of boxes to sort these balls following these rules.\n\u00a0\nExample 1: \n\nInput:   balls = [3,2,3,2,3] \nOutput:   2 \nExplanation:\nWe can sort balls into boxes as follows:\n\n[3,3,3]\n[2,2]\n\nThe size difference between the two boxes doesn't exceed one.\n\nExample 2: \n\nInput:   balls = [10,10,10,3,1,1] \nOutput:   4 \nExplanation:\nWe can sort balls into boxes as follows:\n\n\n\n[10]\n[10,10]\n[3]\n[1,1]\n\nYou can't use fewer than four boxes while still following the rules. For example, putting all three balls numbered 10 in one box would break the rule about the maximum size difference between boxes.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Hash Table + Enumeration\nWe use a hash table $cnt$ to count the number of occurrences of each number in the array $nums$. Let $k$ be the minimum value of the number of occurrences, and then we can enumerate the size of the groups in the range $[k,..1]$. Since the difference in size between each group is not more than $1$, the group size can be either $k$ or $k+1$.\nFor the current group size $k$ being enumerated, we traverse each occurrence $v$ in the hash table. If $\\lfloor \\frac{v}{k} \\rfloor < v \\bmod k$, it means that we cannot divide the occurrence $v$ into $k$ or $k+1$ groups with the same value, so we can skip this group size $k$ directly. Otherwise, it means that we can form groups, and we only need to form as many groups of size $k+1$ as possible to ensure the minimum number of groups. Therefore, we can divide $v$ numbers into $\\lceil \\frac{v}{k+1} \\rceil$ groups and add them to the current enumerated answer. Since we enumerate $k$ from large to small, as long as we find a valid grouping scheme, it must be optimal.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed string s, and a 2D array of integers queries, where queries[i] = [li, ri] indicates a substring of s starting from the index li and ending at the index ri (both inclusive), i.e. s[li..ri].\nReturn an array ans where ans[i] is the number of same-end substrings of queries[i].\nA 0-indexed string t of length n is called same-end if it has the same character at both of its ends, i.e., t[0] == t[n - 1].\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nExample 1:\n\nInput: s = \"abcaab\", queries = [[0,0],[1,4],[2,5],[0,5]]\nOutput: [1,5,5,10]\nExplanation: Here is the same-end substrings of each query:\n1st query: s[0..0] is \"a\" which has 1 same-end substring: \"a\".\n2nd query: s[1..4] is \"bcaa\" which has 5 same-end substrings: \"bcaa\", \"bcaa\", \"bcaa\", \"bcaa\", \"bcaa\".\n3rd query: s[2..5] is \"caab\" which has 5 same-end substrings: \"caab\", \"caab\", \"caab\", \"caab\", \"caab\".\n4th query: s[0..5] is \"abcaab\" which has 10 same-end substrings: \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\".\n\nExample 2:\n\nInput: s = \"abcd\", queries = [[0,3]]\nOutput: [4]\nExplanation: The only query is s[0..3] which is \"abcd\". It has 4 same-end substrings: \"abcd\", \"abcd\", \"abcd\", \"abcd\".\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 3 * 104\ns consists only of lowercase English letters.\n1 <= queries.length <= 3 * 104\nqueries[i] = [li, ri]\n0 <= li <= ri < s.length Explanation:\n\nSolution 1: Prefix Sum + Enumeration\nWe can preprocess the prefix sum for each letter and record it in the array $cnt$, where $cnt[i][j]$ represents the number of times the $i$-th letter appears in the first $j$ characters. In this way, for each interval $[l, r]$, we can enumerate each letter $c$ in the interval, quickly calculate the number of times $c$ appears in the interval $x$ using the prefix sum array. We can arbitrarily choose two of them to form a tail-equal substring, the number of substrings is $C_x^2=\\frac{x(x-1)}{2}$, plus the situation where each letter in the interval can form a tail-equal substring alone, there are $r - l + 1$ letters in total. Therefore, for each query $[l, r]$, the number of tail-equal substrings that meet the conditions is $r - l + 1 + \\sum_{c \\in \\Sigma} \\frac{x_c(x_c-1)}{2}$, where $x_c$ represents the number of times the letter $c$ appears in the interval $[l, r]$.\nThe time complexity is $O((n + m) \\times |\\Sigma|)$, and the space complexity is $O(n \\times |\\Sigma|)$. Here, $n$ and $m$ are the lengths of the string $s$ and the number of queries, respectively, and $\\Sigma$ represents the set of letters appearing in the string $s$, in this problem $|\\Sigma|=26$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.\nAn alphanumeric string is a string consisting of lowercase English letters and digits.\n\u00a0\nExample 1:\n\nInput: s = \"dfa12321afd\"\nOutput: 2\nExplanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.\n\nExample 2:\n\nInput: s = \"abc1111\"\nOutput: -1\nExplanation: The digits that appear in s are [1]. There is no second largest digit. \n\n\u00a0\nConstraints:\n\n1 <= s.length <= 500\ns consists of only lowercase English letters and digits. Explanation:\n\nSolution 1: One Pass\nWe define $a$ and $b$ to represent the largest and second largest numbers in the string, initially $a = b = -1$.\nWe traverse the string $s$. If the current character is a digit, we convert it to a number $v$. If $v > a$, it means that $v$ is the largest number currently appearing, we update $b$ to $a$, and update $a$ to $v$; if $v < a$, it means that $v$ is the second largest number currently appearing, we update $b$ to $v$.\nAfter the traversal, we return $b$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-number-of-groups-to-create-a-valid-assignment", "number-of-same-end-substrings", "second-largest-digit-in-a-string"]}, "2921": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a binary string s, and two integers num1 and num2. num1 and num2 are coprime numbers.\nA ratio substring is a substring of s where the ratio between the number of 0's and the number of 1's in the substring is exactly num1 : num2.\n\nFor example, if num1 = 2 and num2 = 3, then \"01011\" and \"1110000111\" are ratio substrings, while \"11000\" is not.\n\nReturn the number of non-empty ratio substrings of s.\nNote that:\n\nA substring is a contiguous sequence of characters within a string.\nTwo values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the greatest common divisor of x and y.\n\n\u00a0\nExample 1:\n\nInput: s = \"0110011\", num1 = 1, num2 = 2\nOutput: 4\nExplanation: There exist 4 non-empty ratio substrings.\n- The substring s[0..2]: \"0110011\". It contains one 0 and two 1's. The ratio is 1 : 2.\n- The substring s[1..4]: \"0110011\". It contains one 0 and two 1's. The ratio is 1 : 2.\n- The substring s[4..6]: \"0110011\". It contains one 0 and two 1's. The ratio is 1 : 2.\n- The substring s[1..6]: \"0110011\". It contains two 0's and four 1's. The ratio is 2 : 4 == 1 : 2.\nIt can be shown that there are no more ratio substrings.\n\nExample 2:\n\nInput: s = \"10101\", num1 = 3, num2 = 1\nOutput: 0\nExplanation: There is no ratio substrings of s. We return 0.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\n1 <= num1, num2 <= s.length\nnum1 and num2 are coprime integers. Explanation:\n\nSolution 1: Prefix Sum + Counting\nWe use $one[i]$ to represent the number of $1$s in the substring $s[0,..i]$, and $zero[i]$ to represent the number of $0$s in the substring $s[0,..i]$. A substring meets the condition if\n$$\n\\frac{zero[j] - zero[i]}{one[j] - one[i]} = \\frac{num1}{num2}\n$$\nwhere $i < j$. We can transform the above equation into\n$$\none[j] \\times num1 - zero[j] \\times num2 = one[i] \\times num1 - zero[i] \\times num2\n$$\nWhen we iterate to index $j$, we only need to count how many indices $i$ satisfy the above equation. Therefore, we can use a hash table to record the number of occurrences of $one[i] \\times num1 - zero[i] \\times num2$, and when we iterate to index $j$, we only need to count the number of occurrences of $one[j] \\times num1 - zero[j] \\times num2$.\nThe hash table initially only has one key-value pair $(0, 1)$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the string $s$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order.\nWhile the exact formula is hidden, the function is monotonically increasing, i.e.:\n\nf(x, y) < f(x + 1, y)\nf(x, y) < f(x, y + 1)\n\nThe function interface is defined like this:\n\ninterface CustomFunction {\npublic:\n  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.\n  int f(int x, int y);\n};\n\nWe will judge your solution as follows:\n\nThe judge has a list of 9 hidden implementations of CustomFunction, along with a way to generate an answer key of all valid pairs for a specific z.\nThe judge will receive two inputs: a function_id (to determine which implementation to test your code with), and the target z.\nThe judge will call your findSolution and compare your results with the answer key.\nIf your results match the answer key, your solution will be Accepted.\n\n\u00a0\nExample 1:\n\nInput: function_id = 1, z = 5\nOutput: [[1,4],[2,3],[3,2],[4,1]]\nExplanation: The hidden formula for function_id = 1 is f(x, y) = x + y.\nThe following positive integer values of x and y make f(x, y) equal to 5:\nx=1, y=4 -> f(1, 4) = 1 + 4 = 5.\nx=2, y=3 -> f(2, 3) = 2 + 3 = 5.\nx=3, y=2 -> f(3, 2) = 3 + 2 = 5.\nx=4, y=1 -> f(4, 1) = 4 + 1 = 5.\n\nExample 2:\n\nInput: function_id = 2, z = 5\nOutput: [[1,5],[5,1]]\nExplanation: The hidden formula for function_id = 2 is f(x, y) = x * y.\nThe following positive integer values of x and y make f(x, y) equal to 5:\nx=1, y=5 -> f(1, 5) = 1 * 5 = 5.\nx=5, y=1 -> f(5, 1) = 5 * 1 = 5.\n\n\u00a0\nConstraints:\n\n1 <= function_id <= 9\n1 <= z <= 100\nIt is guaranteed that the solutions of f(x, y) == z will be in the range 1 <= x, y <= 1000.\nIt is also guaranteed that f(x, y) will fit in 32 bit signed integer if 1 <= x, y <= 1000. Explanation:\n\nSolution 1: Enumeration + Binary Search\nAccording to the problem, we know that the function $f(x, y)$ is a monotonically increasing function. Therefore, we can enumerate $x$, and then binary search $y$ in $[1,...z]$ to make $f(x, y) = z$. If found, add $(x, y)$ to the answer.\nThe time complexity is $O(n \\log n)$, where $n$ is the value of $z$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:\n\nitems[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.\nThe value of each item in items is unique.\n\nReturn a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.\nNote: ret should be returned in ascending order by value.\n\u00a0\nExample 1:\n\nInput: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\nOutput: [[1,6],[3,9],[4,5]]\nExplanation: \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.\nThe item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.\nThe item with value = 4 occurs in items1 with weight = 5, total weight = 5.  \nTherefore, we return [[1,6],[3,9],[4,5]].\n\nExample 2:\n\nInput: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\nOutput: [[1,4],[2,4],[3,4]]\nExplanation: \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.\nThe item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.\nThe item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.\nTherefore, we return [[1,4],[2,4],[3,4]].\nExample 3:\n\nInput: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\nOutput: [[1,7],[2,4],[7,1]]\nExplanation:\nThe item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. \nThe item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. \nThe item with value = 7 occurs in items2 with weight = 1, total weight = 1.\nTherefore, we return [[1,7],[2,4],[7,1]].\n\n\u00a0\nConstraints:\n\n1 <= items1.length, items2.length <= 1000\nitems1[i].length == items2[i].length == 2\n1 <= valuei, weighti <= 1000\nEach valuei in items1 is unique.\nEach valuei in items2 is unique. Explanation:\n\nSolution 1: Hash Table or Array\nWe can use a hash table or array cnt to count the total weight of each item in items1 and items2. Then, we traverse the values in ascending order, adding each value and its corresponding total weight to the result array.\nThe time complexity is $O(n + m)$ and the space complexity is $O(n + m)$, where $n$ and $m$ are the lengths of items1 and items2 respectively. \n\n", "problem_ids": ["number-of-substrings-with-fixed-ratio", "find-positive-integer-solution-for-a-given-equation", "merge-similar-items"]}, "2952": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a list of phrases, generate a list of\u00a0Before and After puzzles.\nA phrase is a string that consists of lowercase English letters and spaces only. No space appears in the start or the end of a phrase. There are\u00a0no consecutive spaces\u00a0in a phrase.\nBefore and After\u00a0puzzles are phrases that are formed by merging\u00a0two phrases where the last\u00a0word of the first\u00a0phrase is the same as the first word of the second phrase.\nReturn the\u00a0Before and After\u00a0puzzles that can be formed by every two phrases\u00a0phrases[i]\u00a0and\u00a0phrases[j]\u00a0where\u00a0i != j. Note that the order of matching two phrases matters, we want to consider both orders.\nYou should return a list of\u00a0distinct\u00a0strings sorted\u00a0lexicographically.\n\u00a0\nExample 1:\n\nInput: phrases = [\"writing code\",\"code rocks\"]\nOutput: [\"writing code rocks\"]\n\nExample 2:\n\nInput: phrases = [\"mission statement\",\n                  \"a quick bite to eat\",\n\u00a0                 \"a chip off the old block\",\n\u00a0                 \"chocolate bar\",\n\u00a0                 \"mission impossible\",\n\u00a0                 \"a man on a mission\",\n\u00a0                 \"block party\",\n\u00a0                 \"eat my words\",\n\u00a0                 \"bar of soap\"]\nOutput: [\"a chip off the old block party\",\n\u00a0        \"a man on a mission impossible\",\n\u00a0        \"a man on a mission statement\",\n\u00a0        \"a quick bite to eat my words\",\n         \"chocolate bar of soap\"]\n\nExample 3:\n\nInput: phrases = [\"a\",\"b\",\"a\"]\nOutput: [\"a\"]\n\n\u00a0\nConstraints:\n\n1 <= phrases.length <= 100\n1 <= phrases[i].length <= 100 Explanation:\n\nSolution 1: Hash Table + Sorting\nFirst, we traverse the phrases list, storing the first and last words of each phrase in the array $ps$, where $ps[i][0]$ and $ps[i][1]$ represent the first and last words of the $i$th phrase, respectively.\nNext, we enumerate all $(i, j)$, where $i, j \\in [0, n)$ and $i \\neq j$. If $ps[i][1] = ps[j][0]$, then we can concatenate the $i$th phrase and the $j$th phrase to get a new phrase $phrases[i] + phrases[j][len(ps[j][0]):]$, and add the new phrase to the hash table $s$.\nFinally, we convert the hash table $s$ into an array and sort it to get the answer.\nThe time complexity is $O(n^2 \\times m \\times (\\log n + \\log m))$, and the space complexity is $O(n^2 \\times m)$. Here, $n$ and $m$ represent the length of the phrases array and the average length of each phrase, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\u00a0\nExample 1:\n\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true\n\nExample 2:\n\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\nOutput: true\n\nExample 3:\n\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\nOutput: false\n\n\u00a0\nConstraints:\n\nm == board.length\nn = board[i].length\n1 <= m, n <= 6\n1 <= word.length <= 15\nboard and word consists of only lowercase and uppercase English letters.\n\n\u00a0\nFollow up: Could you use search pruning to make your solution faster with a larger board? Explanation:\n\nSolution 1: DFS (Backtracking)\nWe can enumerate each position $(i, j)$ in the grid as the starting point of the search, and then start a depth-first search from the starting point. If we can search to the end of the word, it means the word exists, otherwise, it means the word does not exist.\nTherefore, we design a function $dfs(i, j, k)$, which represents whether we can successfully search from the $(i, j)$ position of the grid, starting from the $k$th character of the word. The execution steps of the function $dfs(i, j, k)$ are as follows:\n\nIf $k = |word|-1$, it means that we have searched to the last character of the word. At this time, we only need to judge whether the character at the $(i, j)$ position of the grid is equal to $word[k]$. If they are equal, it means the word exists, otherwise, it means the word does not exist. Whether the word exists or not, there is no need to continue to search, so return the result directly.\nOtherwise, if the $word[k]$ character is not equal to the character at the $(i, j)$ position of the grid, it means that the search failed this time, so return false directly.\nOtherwise, we temporarily store the character at the $(i, j)$ position of the grid in $c$, and then modify the character at this position to a special character '0', indicating that the character at this position has been used to prevent it from being reused in subsequent searches. Then we start from the up, down, left, and right directions of the $(i, j)$ position to search for the $k+1$th character in the grid. If any direction is successful, it means the search is successful, otherwise, it means the search failed. At this time, we need to restore the character at the $(i, j)$ position of the grid, that is, put $c$ back to the $(i, j)$ position (backtracking).\n\nIn the main function, we enumerate each position $(i, j)$ in the grid as the starting point. If calling $dfs(i, j, 0)$ returns true, it means the word exists, otherwise, it means the word does not exist, so return false.\nThe time complexity is $O(m \\times n \\times 3^k)$, and the space complexity is $O(\\min(m \\times n, k))$. Here, $m$ and $n$ are the number of rows and columns of the grid, respectively; and $k$ is the length of the string $word$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system.\nThe mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9.\nYou are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements.\nNotes:\n\nElements with the same mapped values should appear in the same relative order as in the input.\nThe elements of nums should only be sorted based on their mapped values and not be replaced by them.\n\n\u00a0\nExample 1:\n\nInput: mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]\nOutput: [338,38,991]\nExplanation: \nMap the number 991 as follows:\n1. mapping[9] = 6, so all occurrences of the digit 9 will become 6.\n2. mapping[1] = 9, so all occurrences of the digit 1 will become 9.\nTherefore, the mapped value of 991 is 669.\n338 maps to 007, or 7 after removing the leading zeros.\n38 maps to 07, which is also 7 after removing leading zeros.\nSince 338 and 38 share the same mapped value, they should remain in the same relative order, so 338 comes before 38.\nThus, the sorted array is [338,38,991].\n\nExample 2:\n\nInput: mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]\nOutput: [123,456,789]\nExplanation: 789 maps to 789, 456 maps to 456, and 123 maps to 123. Thus, the sorted array is [123,456,789].\n\n\u00a0\nConstraints:\n\nmapping.length == 10\n0 <= mapping[i] <= 9\nAll the values of mapping[i] are unique.\n1 <= nums.length <= 3 * 104\n0 <= nums[i] < 109 Explanation:\n\nSolution 1: Custom Sorting\nWe traverse each element $nums[i]$ in the array $nums$, store its mapped value $y$ and index $i$ into the array $arr$, then sort the array $arr$. Finally, we extract the index $i$ from the sorted array $arr$, convert it to the element $nums[i]$ in the original array $nums$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["before-and-after-puzzle", "word-search", "sort-the-jumbled-numbers"]}, "2953": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once.\nReturn the minimum number of substrings in such a partition.\nNote that each character should belong to exactly one substring in a partition.\n\u00a0\nExample 1:\n\nInput: s = \"abacaba\"\nOutput: 4\nExplanation:\nTwo possible partitions are (\"a\",\"ba\",\"cab\",\"a\") and (\"ab\",\"a\",\"ca\",\"ba\").\nIt can be shown that 4 is the minimum number of substrings needed.\n\nExample 2:\n\nInput: s = \"ssssss\"\nOutput: 6\nExplanation:\nThe only valid partition is (\"s\",\"s\",\"s\",\"s\",\"s\",\"s\").\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists of only English lowercase letters. Explanation:\n\nSolution 1: Greedy\nAccording to the problem, each substring should be as long as possible and contain unique characters. We just need to partition greedily.\nDuring the process, we can use a hash table to record all characters in the current substring, with a space complexity of $O(n)$; or we can use a number to record characters using bitwise operations, with a space complexity of $O(1)$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nCustom Judge:\nThe inputs to the judge are given as follows (your program is not given these inputs):\n\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\nskipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.\n\u00a0\nExample 1:\n\n\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\nOutput: Intersected at '8'\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.\n\nExample 2:\n\n\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\nOutput: Intersected at '2'\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\nExample 3:\n\n\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\nOutput: No intersection\nExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n\u00a0\nConstraints:\n\nThe number of nodes of listA is in the m.\nThe number of nodes of listB is in the n.\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <\u00a0m\n0 <= skipB <\u00a0n\nintersectVal is 0 if listA and listB do not intersect.\nintersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.\n\n\u00a0\nFollow up: Could you write a solution that runs in O(m + n) time and use only O(1) memory? Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers $a$ and $b$ to point to two linked lists $headA$ and $headB$ respectively.\nWe traverse the linked lists simultaneously. When $a$ reaches the end of the linked list $headA$, it is repositioned to the head node of the linked list $headB$. When $b$ reaches the end of the linked list $headB$, it is repositioned to the head node of the linked list $headA$.\nIf the two pointers meet, the node they point to is the first common node. If they don't meet, it means that the two linked lists have no common nodes. At this time, both pointers point to null, and we can return either one.\nThe time complexity is $O(m+n)$, where $m$ and $n$ are the lengths of the linked lists $headA$ and $headB$ respectively. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a 1-indexed integer array prices, where prices[i] is the price of a particular stock on the ith day, your task is to select some of the elements of prices such that your selection is linear.\nA selection indexes, where indexes is a 1-indexed integer array of length k which is a subsequence of the array [1, 2, ..., n], is linear if:\n\nFor every 1 < j <= k, prices[indexes[j]] - prices[indexes[j - 1]] == indexes[j] - indexes[j - 1].\n\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nThe score of a selection indexes, is equal to the sum of the following array: [prices[indexes[1]], prices[indexes[2]], ..., prices[indexes[k]].\nReturn the maximum score that a linear selection can have.\n\u00a0\nExample 1:\n\nInput: prices = [1,5,3,7,8]\nOutput: 20\nExplanation: We can select the indexes [2,4,5]. We show that our selection is linear:\nFor j = 2, we have:\nindexes[2] - indexes[1] = 4 - 2 = 2.\nprices[4] - prices[2] = 7 - 5 = 2.\nFor j = 3, we have:\nindexes[3] - indexes[2] = 5 - 4 = 1.\nprices[5] - prices[4] = 8 - 7 = 1.\nThe sum of the elements is: prices[2] + prices[4] + prices[5] = 20.\nIt can be shown that the maximum sum a linear selection can have is 20.\n\nExample 2:\n\nInput: prices = [5,6,7,8,9]\nOutput: 35\nExplanation: We can select all of the indexes [1,2,3,4,5]. Since each element has a difference of exactly 1 from its previous element, our selection is linear.\nThe sum of all the elements is 35 which is the maximum possible some out of every selection.\n\u00a0\nConstraints:\n\n1 <= prices.length <= 105\n1 <= prices[i] <= 109 Explanation:\n\nSolution 1: Hash Table\nWe can transform the equation as follows:\n$$\nprices[i] - i = prices[j] - j\n$$\nIn fact, the problem is to find the maximum sum of all $prices[i]$ under the same $prices[i] - i$.\nTherefore, we can use a hash table $cnt$ to store the sum of all $prices[i]$ under the same $prices[i] - i$, and finally take the maximum value in the hash table.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the $prices$ array. \n\n", "problem_ids": ["optimal-partition-of-string", "intersection-of-two-linked-lists", "maximum-linear-stock-score"]}, "2954": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array nums consisting of positive integers.\nSplit the array into one or more disjoint subarrays such that:\n\nEach element of the array belongs to exactly one subarray, and\nThe GCD of the elements of each subarray is strictly greater than 1.\n\nReturn the minimum number of subarrays that can be obtained after the split.\nNote that:\n\nThe GCD of a subarray is the largest positive integer that evenly divides all the elements of the subarray.\nA subarray is a contiguous part of the array.\n\n\u00a0\nExample 1:\n\nInput: nums = [12,6,3,14,8]\nOutput: 2\nExplanation: We can split the array into the subarrays: [12,6,3] and [14,8].\n- The GCD of 12, 6 and 3 is 3, which is strictly greater than 1.\n- The GCD of 14 and 8 is 2, which is strictly greater than 1.\nIt can be shown that splitting the array into one subarray will make the GCD = 1.\n\nExample 2:\n\nInput: nums = [4,12,6,14]\nOutput: 1\nExplanation: We can split the array into only one subarray, which is the whole array.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 2000\n2 <= nums[i] <= 109 Explanation:\n\nSolution 1: Greedy + Mathematics\nFor each element in the array, if its greatest common divisor (gcd) with the previous element is $1$, then it needs to be the first element of a new subarray. Otherwise, it can be placed in the same subarray with the previous elements.\nTherefore, we first initialize a variable $g$, representing the gcd of the current subarray. Initially, $g=0$ and the answer variable $ans=1$.\nNext, we traverse the array from front to back, maintaining the gcd $g$ of the current subarray. If the gcd of the current element $x$ and $g$ is $1$, then we need to make the current element the first element of a new subarray. Therefore, the answer increases by $1$, and $g$ is updated to $x$. Otherwise, the current element can be placed in the same subarray with the previous elements. Continue to traverse the array until the traversal ends.\nThe time complexity is $O(n \\times \\log m)$, where $n$ and $m$ are the length of the array and the maximum value in the array, respectively. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a 2D character matrix grid, where grid[i][j] is either 'X', 'Y', or '.', return the number of submatrices that contain:\n\ngrid[0][0]\nan equal frequency of 'X' and 'Y'.\nat least one 'X'.\n\n\u00a0\nExample 1:\n\nInput: grid = [[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]\nOutput: 3\nExplanation:\n\n\nExample 2:\n\nInput: grid = [[\"X\",\"X\"],[\"X\",\"Y\"]]\nOutput: 0\nExplanation:\nNo submatrix has an equal frequency of 'X' and 'Y'.\n\nExample 3:\n\nInput: grid = [[\".\",\".\"],[\".\",\".\"]]\nOutput: 0\nExplanation:\nNo submatrix has at least one 'X'.\n\n\u00a0\nConstraints:\n\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] is either 'X', 'Y', or '.'. Explanation:\n\nSolution 1: 2D Prefix Sum\nAccording to the problem description, we only need to calculate the prefix sums $s[i][j][0]$ and $s[i][j][1]$ for each position $(i, j)$, which represent the number of characters X and Y in the submatrix from $(0, 0)$ to $(i, j)$, respectively. If $s[i][j][0] > 0$ and $s[i][j][0] = s[i][j][1]$, it means the condition is met, and we increment the answer by one.\nAfter traversing all positions, return the answer.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ represent the number of rows and columns of the matrix, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are within the inclusive range.\nA number x is considered missing if x is in the range [lower, upper] and x is not in nums.\nReturn the shortest sorted list of ranges that exactly covers all the missing numbers. That is, no element of nums is included in any of the ranges, and each missing number is covered by one of the ranges.\n\u00a0\n\u00a0\nExample 1:\n\nInput: nums = [0,1,3,50,75], lower = 0, upper = 99\nOutput: [[2,2],[4,49],[51,74],[76,99]]\nExplanation: The ranges are:\n[2,2]\n[4,49]\n[51,74]\n[76,99]\n\nExample 2:\n\nInput: nums = [-1], lower = -1, upper = -1\nOutput: []\nExplanation: There are no missing ranges since there are no missing numbers.\n\n\u00a0\nConstraints:\n\n-109 <= lower <= upper <= 109\n0 <= nums.length <= 100\nlower <= nums[i] <= upper\nAll the values of nums are unique. Explanation:\n\nSolution 1: Simulation\nWe can simulate the problem directly according to the requirements.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-split-into-subarrays-with-gcd-greater-than-one", "count-submatrices-with-equal-frequency-of-x-and-y", "missing-ranges"]}, "2955": {"text": "Similar Problem 1 \n\n Problem:\n\nThis question is about implementing a basic elimination algorithm for Candy Crush.\nGiven an m x n integer array board representing the grid of candy where board[i][j] represents the type of candy. A value of board[i][j] == 0 represents that the cell is empty.\nThe given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:\n\nIf three or more candies of the same type are adjacent vertically or horizontally, crush them all at the same time - these positions become empty.\nAfter crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. No new candies will drop outside the top boundary.\nAfter the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.\nIf there does not exist more candies that can be crushed (i.e., the board is stable), then return the current board.\n\nYou need to perform the above rules until the board becomes stable, then return the stable board.\n\u00a0\nExample 1:\n\n\nInput: board = [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]\nOutput: [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]\n\nExample 2:\n\nInput: board = [[1,3,5,5,2],[3,4,3,3,1],[3,2,4,5,2],[2,4,4,5,5],[1,4,4,1,1]]\nOutput: [[1,3,0,0,0],[3,4,0,5,2],[3,2,0,3,1],[2,4,0,5,2],[1,4,3,1,1]]\n\n\u00a0\nConstraints:\n\nm == board.length\nn == board[i].length\n3 <= m, n <= 50\n1 <= board[i][j] <= 2000 Explanation:\n\nSolution 1: Simulation\nWe can traverse the matrix row by row and column by column to find three consecutive identical elements and mark them as negative numbers. If marking is successful, we need to move the elements in the matrix down until no elements can move down.\nThe time complexity is $O(m^2 \\times n^2)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.\nYou are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.\nDivide the nodes of the graph into m groups (1-indexed) such that:\n\nEach node in the graph belongs to exactly one group.\nFor every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.\n\nReturn the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.\n\u00a0\nExample 1:\n\n\nInput: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\nOutput: 4\nExplanation: As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n\nExample 2:\n\nInput: n = 3, edges = [[1,2],[2,3],[3,1]]\nOutput: -1\nExplanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible.\n\n\u00a0\nConstraints:\n\n1 <= n <= 500\n1 <= edges.length <= 104\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere is at most one edge between any pair of vertices. Explanation:\n\nSolution 1: BFS + Enumeration\nGiven that the graph provided by the problem may be disconnected, we need to process each connected component, find the maximum number of groups in each connected component, and accumulate them to get the final result.\nWe can enumerate each node as the node of the first group, then use BFS to traverse the entire connected component, and use an array $d$ to record the maximum number of groups in each connected component. In the code implementation, we use the smallest node in the connected component as the root node of this connected component.\nDuring the BFS process, we use a queue $q$ to store the nodes currently traversed, use an array $dist$ to record the distance from each node to the starting node, use a variable $mx$ to record the maximum depth of the current connected component, and use a variable $root$ to record the root node of the current connected component.\nDuring the traversal, if we find that the $dist[b]$ of a certain node $b$ is $0$, it means that $b$ has not been traversed yet. We set the distance of $b$ to $dist[a] + 1$, update $mx$, and add $b$ to the queue $q$. If the distance of $b$ has been updated, we check whether the distance between $b$ and $a$ is $1$. If not, it means that the problem requirements cannot be met, so we directly return $-1$.\nThe time complexity is $O(n \\times (n + m))$, and the space complexity is $O(n + m)$. Where $n$ and $m$ are the number of nodes and edges respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nThere are n houses in a village. We want to supply water for all the houses by building wells and laying pipes.\nFor each house i, we can either build a well inside it directly with cost wells[i - 1] (note the -1 due to 0-indexing), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes where each pipes[j] = [house1j, house2j, costj] represents the cost to connect house1j and house2j together using a pipe. Connections are bidirectional, and there could be multiple valid connections between the same two houses with different costs.\nReturn the minimum total cost to supply water to all houses.\n\u00a0\nExample 1:\n\n\nInput: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]\nOutput: 3\nExplanation: The image shows the costs of connecting houses using pipes.\nThe best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.\n\nExample 2:\n\nInput: n = 2, wells = [1,1], pipes = [[1,2,1],[1,2,2]]\nOutput: 2\nExplanation: We can supply water with cost two using one of the three options:\nOption 1:\n  - Build a well inside house 1 with cost 1.\n  - Build a well inside house 2 with cost 1.\nThe total cost will be 2.\nOption 2:\n  - Build a well inside house 1 with cost 1.\n  - Connect house 2 with house 1 with cost 1.\nThe total cost will be 2.\nOption 3:\n  - Build a well inside house 2 with cost 1.\n  - Connect house 1 with house 2 with cost 1.\nThe total cost will be 2.\nNote that we can connect houses 1 and 2 with cost 1 or with cost 2 but we will always choose the cheapest option. \n\n\u00a0\nConstraints:\n\n2 <= n <= 104\nwells.length == n\n0 <= wells[i] <= 105\n1 <= pipes.length <= 104\npipes[j].length == 3\n1 <= house1j, house2j <= n\n0 <= costj <= 105\nhouse1j != house2j Explanation:\n\nSolution 1: Kruskal's Algorithm (Minimum Spanning Tree)\nWe assume that there is a well with the number $0$. Then we can consider the connectivity between each house and the well $0$ as an edge, and the weight of each edge is the cost of building a well for that house. At the same time, we consider the connectivity between each house as an edge, and the weight of each edge is the cost of laying a pipe. In this way, we can transform this problem into finding the minimum spanning tree of an undirected graph.\nWe can use Kruskal's algorithm to find the minimum spanning tree of the undirected graph. First, we add an edge between the well $0$ and the house to the $pipes$ array, and then sort the $pipes$ array in ascending order of edge weights. Then, we traverse each edge. If this edge connects different connected components, we choose this edge and merge the corresponding connected components. If the current connected component is exactly $1$, then we have found the minimum spanning tree. The answer at this time is the current edge weight, and we return it.\nThe time complexity is $O((m + n) \\times \\log (m + n))$, and the space complexity is $O(m + n)$. Here, $m$ and $n$ are the lengths of the $pipes$ array and the $wells$ array, respectively. \n\n", "problem_ids": ["candy-crush", "divide-nodes-into-the-maximum-number-of-groups", "optimize-water-distribution-in-a-village"]}, "2977": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\u00a0\nExample 1:\n\nInput: x = 123\nOutput: 321\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\nExample 3:\n\nInput: x = 120\nOutput: 21\n\n\u00a0\nConstraints:\n\n-231 <= x <= 231 - 1 Explanation:\n\nSolution 1: Mathematics\nLet's denote $mi$ and $mx$ as $-2^{31}$ and $2^{31} - 1$ respectively, then the reverse result of $x$, $ans$, needs to satisfy $mi \\le ans \\le mx$.\nWe can continuously take the remainder of $x$ to get the last digit $y$ of $x$, and add $y$ to the end of $ans$. Before adding $y$, we need to check if $ans$ overflows. That is, check whether $ans \\times 10 + y$ is within the range $[mi, mx]$.\nIf $x \\gt 0$, it needs to satisfy $ans \\times 10 + y \\leq mx$, that is, $ans \\times 10 + y \\leq \\left \\lfloor \\frac{mx}{10} \\right \\rfloor \\times 10 + 7$. Rearranging gives $(ans - \\left \\lfloor \\frac{mx}{10} \\right \\rfloor) \\times 10 \\leq 7 - y$.\nNext, we discuss the conditions for the inequality to hold:\n\nWhen $ans \\lt \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$, the inequality obviously holds;\nWhen $ans = \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$, the necessary and sufficient condition for the inequality to hold is $y \\leq 7$. If $ans = \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$ and we can still add numbers, it means that the number is at the highest digit, that is, $y$ must not exceed $2$, therefore, the inequality must hold;\nWhen $ans \\gt \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$, the inequality obviously does not hold.\n\nIn summary, when $x \\gt 0$, the necessary and sufficient condition for the inequality to hold is $ans \\leq \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$.\nSimilarly, when $x \\lt 0$, the necessary and sufficient condition for the inequality to hold is $ans \\geq \\left \\lfloor \\frac{mi}{10} \\right \\rfloor$.\nTherefore, we can check whether $ans$ overflows by checking whether $ans$ is within the range $[\\left \\lfloor \\frac{mi}{10} \\right \\rfloor, \\left \\lfloor \\frac{mx}{10} \\right \\rfloor]$. If it overflows, return $0$. Otherwise, add $y$ to the end of $ans$, and then remove the last digit of $x$, that is, $x \\gets \\left \\lfloor \\frac{x}{10} \\right \\rfloor$.\nThe time complexity is $O(\\log |x|)$, where $|x|$ is the absolute value of $x$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array receiver of length n and an integer k. n players are playing a ball-passing game.\nYou choose the starting player, i. The game proceeds as follows: player i passes the ball to player receiver[i], who then passes it to receiver[receiver[i]], and so on, for k passes in total. The game's score is the sum of the indices of the players who touched the ball, including repetitions, i.e. i + receiver[i] + receiver[receiver[i]] + ... + receiver(k)[i].\nReturn\u00a0the maximum\u00a0possible score.\nNotes:\n\nreceiver may contain duplicates.\nreceiver[i] may be equal to i.\n\n\u00a0\nExample 1:\n\nInput: receiver = [2,0,1], k = 4\nOutput: 6\nExplanation:\nStarting with player i = 2 the initial score is 2:\n\n\n\nPass\nSender Index\nReceiver Index\nScore\n\n\n1\n2\n1\n3\n\n\n2\n1\n0\n3\n\n\n3\n0\n2\n5\n\n\n4\n2\n1\n6\n\n\n\n\nExample 2:\n\nInput: receiver = [1,1,1,2,3], k = 3\nOutput: 10\nExplanation:\nStarting with player i = 4 the initial score is 4:\n\n\n\nPass\nSender Index\nReceiver Index\nScore\n\n\n1\n4\n3\n7\n\n\n2\n3\n2\n9\n\n\n3\n2\n1\n10\n\n\n\n\n\u00a0\nConstraints:\n\n1 <= receiver.length == n <= 105\n0 <= receiver[i] <= n - 1\n1 <= k <= 1010 Explanation:\n\nSolution 1: Dynamic Programming + Binary Lifting\nThe problem asks us to find the maximum sum of the player IDs who have touched the ball within $k$ passes starting from each player $i$. If we solve it by brute force, we need to traverse upwards $k$ times starting from $i$, with a time complexity of $O(k)$, which will obviously time out.\nWe can use dynamic programming combined with binary lifting to handle this.\nWe define $f[i][j]$ as the player ID that can be reached by passing the ball $2^j$ times starting from player $i$, and define $g[i][j]$ as the sum of the player IDs that can be reached by passing the ball $2^j$ times starting from player $i$ (excluding the last player).\nWhen $j=0$, the number of passes is $1$, so $f[i][0] = receiver[i]$, and $g[i][0] = i$.\nWhen $j > 0$, the number of passes is $2^j$, which is equivalent to passing the ball $2^{j-1}$ times starting from player $i$, and then passing the ball $2^{j-1}$ times starting from player $f[i][j-1]$, so $f[i][j] = f[f[i][j-1]][j-1]$, and $g[i][j] = g[i][j-1] + g[f[i][j-1]][j-1]$.\nNext, we can enumerate each player $i$ as the starting player, then accumulate upwards according to the binary representation of $k$, and finally get the maximum sum of the player IDs who have touched the ball within $k$ passes starting from player $i$.\nThe time complexity is $O(n \\times \\log k)$, and the space complexity is $O(n \\times \\log k)$. Here, $n$ is the number of players.\nSimilar problems:\n\n1483. Kth Ancestor of a Tree Node \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\n\ni < j < k,\nnums[j] - nums[i] == diff, and\nnums[k] - nums[j] == diff.\n\nReturn the number of unique arithmetic triplets.\n\u00a0\nExample 1:\n\nInput: nums = [0,1,4,6,7,10], diff = 3\nOutput: 2\nExplanation:\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. \n\nExample 2:\n\nInput: nums = [4,5,6,7,8,9], diff = 2\nOutput: 2\nExplanation:\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.\n\n\u00a0\nConstraints:\n\n3 <= nums.length <= 200\n0 <= nums[i] <= 200\n1 <= diff <= 50\nnums is strictly increasing. Explanation:\n\nSolution 1: Brute Force\nWe notice that the length of the array $nums$ is no more than $200$. Therefore, we can directly enumerate $i$, $j$, $k$, and check whether they meet the conditions. If they do, we increment the count of the triplet.\nThe time complexity is $O(n^3)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\n", "problem_ids": ["reverse-integer", "maximize-value-of-function-in-a-ball-passing-game", "number-of-arithmetic-triplets"]}, "2979": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.\nReturn any array that satisfies this condition.\n\u00a0\nExample 1:\n\nInput: nums = [3,1,2,4]\nOutput: [2,4,3,1]\nExplanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n\nExample 2:\n\nInput: nums = [0]\nOutput: [0]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 5000\n0 <= nums[i] <= 5000 Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers $i$ and $j$ to point to the beginning and end of the array respectively. When $i < j$, we perform the following operations.\n\nIf $nums[i]$ is even, then increment $i$ by $1$.\nIf $nums[j]$ is odd, then decrement $j$ by $1$.\nIf $nums[i]$ is odd and $nums[j]$ is even, then swap $nums[i]$ and $nums[j]$. Then increment $i$ by $1$, and decrement $j$ by $1$.\n\nFinally, return the array $nums$.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n\u00a0\nExample 1:\n\n\nInput: head = [1,1,2]\nOutput: [1,2]\n\nExample 2:\n\n\nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is in the range [0, 300].\n-100 <= Node.val <= 100\nThe list is guaranteed to be sorted in ascending order. Explanation:\n\nSolution 1: Single Pass\nWe use a pointer $cur$ to traverse the linked list. If the element corresponding to the current $cur$ is the same as the element corresponding to $cur.next$, we set the $next$ pointer of $cur$ to point to the next node of $cur.next$. Otherwise, it means that the element corresponding to $cur$ in the linked list is not duplicated, so we can move the $cur$ pointer to the next node.\nAfter the traversal ends, return the head node of the linked list.\nThe time complexity is $O(n)$, where $n$ is the length of the linked list. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\n\u00a0\nExample 1:\n\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\nExample 2:\n\n\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\nExample 3:\n\n\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\n\n\u00a0\nConstraints:\n\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.\n\n\u00a0\nFollow up: Can you solve it using O(1) (i.e. constant) memory? Explanation:\n\nSolution 1: Two Pointers\nWe first use the fast and slow pointers to judge whether the linked list has a ring. If there is a ring, the fast and slow pointers will definitely meet, and the meeting node must be in the ring.\nIf there is no ring, the fast pointer will reach the tail of the linked list first, and return null directly.\nIf there is a ring, we then define an answer pointer $ans$ to point to the head of the linked list, and then let $ans$ and the slow pointer move forward together, moving one step at a time, until $ans$ and the slow pointer meet, and the meeting node is the ring entrance node.\nWhy can this find the entrance node of the ring?\nLet's assume that the distance from the head node of the linked list to the entrance of the ring is $x$, the distance from the entrance of the ring to the meeting node is $y$, and the distance from the meeting node to the entrance of the ring is $z$. Then the distance traveled by the slow pointer is $x + y$, and the distance traveled by the fast pointer is $x + y + k \\times (y + z)$, where $k$ is the number of times the fast pointer goes around the ring.\n\nBecause the speed of the fast pointer is twice that of the slow pointer, it is $2 \\times (x + y) = x + y + k \\times (y + z)$, which can be deduced that $x + y = k \\times (y + z)$, that is $x = (k - 1) \\times (y + z) + z$.\nThat is to say, if we define an answer pointer $ans$ to point to the head of the linked list, and the $ans$ and the slow pointer move forward together, they will definitely meet at the ring entrance.\nThe time complexity is $O(n)$, where $n$ is the number of nodes in the linked list. The space complexity is $O(1)$. \n\n", "problem_ids": ["sort-array-by-parity", "remove-duplicates-from-sorted-list", "linked-list-cycle-ii"]}, "2998": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: Boxes\n\n+--------------+------+\n| Column Name  | Type |\n+--------------+------+\n| box_id       | int  |\n| chest_id     | int  |\n| apple_count  | int  |\n| orange_count | int  |\n+--------------+------+\nbox_id is the column with unique values for this table.\nchest_id is a foreign key (reference column) of the chests table.\nThis table contains information about the boxes and the number of oranges and apples they have. Each box may include a chest, which also can contain oranges and apples.\n\n\u00a0\nTable: Chests\n\n+--------------+------+\n| Column Name  | Type |\n+--------------+------+\n| chest_id     | int  |\n| apple_count  | int  |\n| orange_count | int  |\n+--------------+------+\nchest_id is the column with unique values for this table.\nThis table contains information about the chests and the corresponding number of oranges and apples they have.\n\n\u00a0\nWrite a solution to count the number of apples and oranges in all the boxes. If a box contains a chest, you should also include the number of apples and oranges it has.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nBoxes table:\n+--------+----------+-------------+--------------+\n| box_id | chest_id | apple_count | orange_count |\n+--------+----------+-------------+--------------+\n| 2      | null     | 6           | 15           |\n| 18     | 14       | 4           | 15           |\n| 19     | 3        | 8           | 4            |\n| 12     | 2        | 19          | 20           |\n| 20     | 6        | 12          | 9            |\n| 8      | 6        | 9           | 9            |\n| 3      | 14       | 16          | 7            |\n+--------+----------+-------------+--------------+\nChests table:\n+----------+-------------+--------------+\n| chest_id | apple_count | orange_count |\n+----------+-------------+--------------+\n| 6        | 5           | 6            |\n| 14       | 20          | 10           |\n| 2        | 8           | 8            |\n| 3        | 19          | 4            |\n| 16       | 19          | 19           |\n+----------+-------------+--------------+\nOutput: \n+-------------+--------------+\n| apple_count | orange_count |\n+-------------+--------------+\n| 151         | 123          |\n+-------------+--------------+\nExplanation: \nbox 2 has 6 apples and 15 oranges.\nbox 18 has 4 + 20 (from the chest) = 24 apples and 15 + 10 (from the chest) = 25 oranges.\nbox 19 has 8 + 19 (from the chest) = 27 apples and 4 + 4 (from the chest) = 8 oranges.\nbox 12 has 19 + 8 (from the chest) = 27 apples and 20 + 8 (from the chest) = 28 oranges.\nbox 20 has 12 + 5 (from the chest) = 17 apples and 9 + 6 (from the chest) = 15 oranges.\nbox 8 has 9 + 5 (from the chest) = 14 apples and 9 + 6 (from the chest) = 15 oranges.\nbox 3 has 16 + 20 (from the chest) = 36 apples and 7 + 10 (from the chest) = 17 oranges.\nTotal number of apples = 6 + 24 + 27 + 27 + 17 + 14 + 36 = 151\nTotal number of oranges = 15 + 25 + 8 + 28 + 15 + 15 + 17 = 123 Explanation:\n\nSolution 1: Left Join + Summation\nWe can perform a left join on the Boxes table and the Chests table based on chest_id, and then calculate the total number of apples and oranges respectively. Note that if a box does not contain any small boxes, then the corresponding chest_id will be null. In this case, we need to consider the number of apples and oranges in the small boxes within that box to be 0.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nSELECT\n    SUM(IFNULL(b.apple_count, 0) + IFNULL(c.apple_count, 0)) AS apple_count,\n    SUM(IFNULL(b.orange_count, 0) + IFNULL(c.orange_count, 0)) AS orange_count\nFROM\n    Boxes AS b\n    LEFT JOIN Chests AS c USING (chest_id);\n```\nPandas\n```python\nimport pandas as pd\ndef count_apples_and_oranges(boxes: pd.DataFrame, chests: pd.DataFrame) -> pd.DataFrame:\n    merged_df = boxes.merge(\n        chests, on=\"chest_id\", how=\"left\", suffixes=(\"_box\", \"_chest\")\n    )\n    apple_count = (\n        merged_df[\"apple_count_box\"].fillna(0)\n        + merged_df[\"apple_count_chest\"].fillna(0)\n    ).sum()\n    orange_count = (\n        merged_df[\"orange_count_box\"].fillna(0)\n        + merged_df[\"orange_count_chest\"].fillna(0)\n    ).sum()\n    return pd.DataFrame({\"apple_count\": [apple_count], \"orange_count\": [orange_count]})\n``` \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:\n\nevent1 = [startTime1, endTime1] and\nevent2 = [startTime2, endTime2].\n\nEvent times are valid 24 hours format in the form of HH:MM.\nA conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).\nReturn true if there is a conflict between two events. Otherwise, return false.\n\u00a0\nExample 1:\n\nInput: event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"]\nOutput: true\nExplanation: The two events intersect at time 2:00.\n\nExample 2:\n\nInput: event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"]\nOutput: true\nExplanation: The two events intersect starting from 01:20 to 02:00.\n\nExample 3:\n\nInput: event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"]\nOutput: false\nExplanation: The two events do not intersect.\n\n\u00a0\nConstraints:\n\nevent1.length == event2.length == 2\nevent1[i].length == event2[i].length == 5\nstartTime1 <= endTime1\nstartTime2 <= endTime2\nAll the event times follow the HH:MM format. Explanation:\n\nSolution 1: String Comparison\nIf the start time of $event1$ is later than the end time of $event2$, or the end time of $event1$ is earlier than the start time of $event2$, then the two events will not conflict. Otherwise, the two events will conflict.\n\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.\nThe next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number is 2; \nThe number 2 can't find next greater number. \nThe second 1's next greater number needs to search circularly, which is also 2.\n\nExample 2:\n\nInput: nums = [1,2,3,4,3]\nOutput: [2,3,4,-1,4]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n-109 <= nums[i] <= 109 Explanation:\n\nSolution 1: Monotonic Stack\nThe problem requires us to find the next greater element for each element. Therefore, we can traverse the array from back to front, which effectively turns the problem into finding the previous greater element. Additionally, since the array is circular, we can traverse the array twice.\nSpecifically, we start traversing the array from index $n \\times 2 - 1$, where $n$ is the length of the array. Then, we let $j = i \\bmod n$, where $\\bmod$ represents the modulo operation. If the stack is not empty and the top element of the stack is less than or equal to $nums[j]$, then we continuously pop the top element of the stack until the stack is empty or the top element of the stack is greater than $nums[j]$. At this point, the top element of the stack is the previous greater element for $nums[j]$, and we assign it to $ans[j]$. Finally, we push $nums[j]$ onto the stack. We continue to the next element.\nAfter the traversal is complete, we can obtain the array $ans$, which represents the next greater element for each element in the array $nums$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["count-apples-and-oranges", "determine-if-two-events-have-conflict", "next-greater-element-ii"]}, "2999": {"text": "Similar Problem 1 \n\n Problem:\n\nA complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\nDesign an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.\nImplement the CBTInserter class:\n\nCBTInserter(TreeNode root) Initializes the data structure with the root of the complete binary tree.\nint insert(int v) Inserts a TreeNode into the tree with value Node.val == val so that the tree remains complete, and returns the value of the parent of the inserted TreeNode.\nTreeNode get_root() Returns the root node of the tree.\n\n\u00a0\nExample 1:\n\n\nInput\n[\"CBTInserter\", \"insert\", \"insert\", \"get_root\"]\n[[[1, 2]], [3], [4], []]\nOutput\n[null, 1, 2, [1, 2, 3, 4]]\n\nExplanation\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3); // return 1\ncBTInserter.insert(4); // return 2\ncBTInserter.get_root(); // return [1, 2, 3, 4]\n\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree will be in the range [1, 1000].\n0 <= Node.val <= 5000\nroot is a complete binary tree.\n0 <= val <= 5000\nAt most 104 calls will be made to insert and get_root. Explanation:\n\nSolution 1: BFS\nWe can use an array $tree$ to store all nodes of the complete binary tree. During initialization, we use a queue $q$ to perform level-order traversal of the given tree and store all nodes into the array $tree$.\nWhen inserting a node, we can find the parent node $p$ of the new node through the array $tree$. Then we create a new node $node$, insert it into the array $tree$, and make $node$ as the left child or right child of $p$. Finally, we return the value of $p$.\nWhen getting the root node, we directly return the first element of the array $tree$.\nIn terms of time complexity, it takes $O(n)$ time for initialization, and the time complexity for inserting a node and getting the root node are both $O(1)$. The space complexity is $O(n)$, where $n$ is the number of nodes in the tree. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed array nums consisting of non-negative powers of 2, and an integer target.\nIn one operation, you must apply the following changes to the array:\n\nChoose any element of the array nums[i] such that nums[i] > 1.\nRemove nums[i] from the array.\nAdd two occurrences of nums[i] / 2 to the end of nums.\n\nReturn the minimum number of operations you need to perform so that nums contains a subsequence whose elements sum to target. If it is impossible to obtain such a subsequence, return -1.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,8], target = 7\nOutput: 1\nExplanation: In the first operation, we choose element nums[2]. The array becomes equal to nums = [1,2,4,4].\nAt this stage, nums contains the subsequence [1,2,4] which sums up to 7.\nIt can be shown that there is no shorter sequence of operations that results in a subsequnce that sums up to 7.\n\nExample 2:\n\nInput: nums = [1,32,1,2], target = 12\nOutput: 2\nExplanation: In the first operation, we choose element nums[1]. The array becomes equal to nums = [1,1,2,16,16].\nIn the second operation, we choose element nums[3]. The array becomes equal to nums = [1,1,2,16,8,8]\nAt this stage, nums contains the subsequence [1,1,2,8] which sums up to 12.\nIt can be shown that there is no shorter sequence of operations that results in a subsequence that sums up to 12.\nExample 3:\n\nInput: nums = [1,32,1], target = 35\nOutput: -1\nExplanation: It can be shown that no sequence of operations results in a subsequence that sums up to 35.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 230\nnums consists only of non-negative powers of two.\n1 <= target < 231 Explanation:\n\nSolution 1: Greedy + Bit Manipulation\nObserving the operation in the problem, we find that each operation actually splits a number greater than $1$ into two equal numbers, which means that the sum of the elements in the array will not change after the operation. Therefore, if the sum of the elements in the array $s$ is less than $target$, it is impossible to obtain a subsequence with a sum of $target$ through the operation described in the problem, and we can directly return $-1$. Otherwise, we can definitely make the sum of some subsequences in the array equal to $target$ through the split operation.\nIn addition, the split operation will actually set the binary high bit of the number to $0$ and add $2$ to the lower bit. Therefore, we first use an array of length $32$ to record the number of times $1$ appears on each binary bit in the binary representation of all elements in the array $nums$.\nNext, starting from the low bit of $target$, for the $i$th bit of $target$, if the current bit number is $0$, skip it directly, that is, $i = i + 1$. If the current bit number is $1$, we need to find the smallest number $j$ (where $j \\ge i$) in the array $cnt$ such that $cnt[j] > 0$, and then we split the number $1$ at this bit to the lower bit $i$, that is, subtract $1$ from $cnt[j]$, and set each bit from $i$ to $j-1$ in $cnt$ to $1$, and the number of operations is $j-i$. Next, we let $j = i$, and then $i = i + 1$. Repeat the above operation until $i$ exceeds the index range of the array $cnt$, and return the number of operations at this time.\nNote that if $j < i$, actually two lower bits of $1$ can be combined into a higher bit of $1$. Therefore, if $j < i$, we add $\\frac{cnt[j]}{2}$ to $cnt[j+1]$, and take $cnt[j]$ modulo $2$, then let $j = j + 1$, and continue the above operation.\nThe time complexity is $O(n \\times \\log M)$, and the space complexity is $O(\\log M)$. Here, $n$ is the length of the array $nums$, and $M$ is the maximum value in the array $nums$. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is a bookstore owner that has a store open for n minutes. You are given an integer array customers of length n where customers[i] is the number of the customers that enter the store at the start of the ith minute and all those customers leave after the end of that minute.\nDuring certain minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.\nWhen the bookstore owner is grumpy, the customers entering during that minute are not satisfied. Otherwise, they are satisfied.\nThe bookstore owner knows a secret technique to remain not grumpy for minutes consecutive minutes, but this technique can only be used once.\nReturn the maximum number of customers that can be satisfied throughout the day.\n\u00a0\nExample 1:\n\nInput: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation:\nThe bookstore owner keeps themselves not grumpy for the last 3 minutes.\nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nExample 2:\n\nInput: customers = [1], grumpy = [0], minutes = 1\nOutput: 1\n\n\u00a0\nConstraints:\n\nn == customers.length == grumpy.length\n1 <= minutes <= n <= 2 * 104\n0 <= customers[i] <= 1000\ngrumpy[i] is either 0 or 1. Explanation:\n\nSolution 1: Sliding Window\nAccording to the problem description, we only need to count the number of customers when the boss is not angry $tot$, and add the maximum number of customers when the boss is angry within a sliding window of size minutes $mx$.\nWe define a variable $cnt$ to record the number of customers when the boss is angry within the sliding window, the initial value is the number of customers when the boss is angry in the first minutes. Then we traverse the array, each time we move the sliding window, we update the value of $cnt$, and at the same time update the value of $mx$.\nFinally, return $tot + mx$.\nThe time complexity is $O(n)$, where $n$ is the length of the array customers. The space complexity is $O(1)$. \n\n", "problem_ids": ["complete-binary-tree-inserter", "minimum-operations-to-form-subsequence-with-target-sum", "grumpy-bookstore-owner"]}, "3000": {"text": "Similar Problem 1 \n\n Problem:\n\nThere are n rooms labeled from 0 to n - 1\u00a0and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\n\u00a0\nExample 1:\n\nInput: rooms = [[1],[2],[3],[]]\nOutput: true\nExplanation: \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n\nExample 2:\n\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\n\n\u00a0\nConstraints:\n\nn == rooms.length\n2 <= n <= 1000\n0 <= rooms[i].length <= 1000\n1 <= sum(rooms[i].length) <= 3000\n0 <= rooms[i][j] < n\nAll the values of rooms[i] are unique. Explanation:\n\nSolution 1: Depth-First Search (DFS)\nWe can use the Depth-First Search (DFS) method to traverse the entire graph, count the number of reachable nodes, and use an array vis to mark whether the current node has been visited to prevent repeated visits.\nFinally, we count the number of visited nodes. If it is the same as the total number of nodes, it means that all nodes can be visited; otherwise, there are nodes that cannot be reached.\nThe time complexity is $O(n + m)$, and the space complexity is $O(n)$, where $n$ is the number of nodes, and $m$ is the number of edges. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.\nYou can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.\nLet maxLen be the side length of the largest square you can obtain from any of the given rectangles.\nReturn the number of rectangles that can make a square with a side length of maxLen.\n\u00a0\nExample 1:\n\n\nInput: rectangles = [[5,8],[3,9],[5,12],[16,5]]\n\nOutput: 3\n\nExplanation: The largest squares you can get from each rectangle are of lengths [5,3,5,5].\n\nThe largest possible square is of length 5, and you can get it out of 3 rectangles.\n\n\nExample 2:\n\n\nInput: rectangles = [[2,3],[3,7],[4,3],[3,7]]\n\nOutput: 3\n\n\n\u00a0\nConstraints:\n\n1 <= rectangles.length <= 1000\nrectangles[i].length == 2\n1 <= li, wi <= 109\nli != wi Explanation:\n\nSolution 1: Single Pass\nWe define a variable $ans$ to record the count of squares with the current maximum side length, and another variable $mx$ to record the current maximum side length.\nWe traverse the array $rectangles$. For each rectangle $[l, w]$, we take $x = \\min(l, w)$. If $mx < x$, it means we have found a larger side length, so we update $mx$ to $x$ and update $ans$ to $1$. If $mx = x$, it means we have found a side length equal to the current maximum side length, so we increase $ans$ by $1$.\nFinally, we return $ans$.\nThe time complexity is $O(n)$, where $n$ is the length of the array $rectangles$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a string word containing distinct lowercase English letters.\nTelephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with [\"a\",\"b\",\"c\"], we need to push the key one time to type \"a\", two times to type \"b\", and three times to type \"c\" .\nIt is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.\nReturn the minimum number of pushes needed to type word after remapping the keys.\nAn example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.\n\n\u00a0\nExample 1:\n\n\nInput: word = \"abcde\"\nOutput: 5\nExplanation: The remapped keypad given in the image provides the minimum cost.\n\"a\" -> one push on key 2\n\"b\" -> one push on key 3\n\"c\" -> one push on key 4\n\"d\" -> one push on key 5\n\"e\" -> one push on key 6\nTotal cost is 1 + 1 + 1 + 1 + 1 = 5.\nIt can be shown that no other mapping can provide a lower cost.\n\nExample 2:\n\n\nInput: word = \"xycdefghij\"\nOutput: 12\nExplanation: The remapped keypad given in the image provides the minimum cost.\n\"x\" -> one push on key 2\n\"y\" -> two pushes on key 2\n\"c\" -> one push on key 3\n\"d\" -> two pushes on key 3\n\"e\" -> one push on key 4\n\"f\" -> one push on key 5\n\"g\" -> one push on key 6\n\"h\" -> one push on key 7\n\"i\" -> one push on key 8\n\"j\" -> one push on key 9\nTotal cost is 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12.\nIt can be shown that no other mapping can provide a lower cost.\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 26\nword consists of lowercase English letters.\nAll letters in word are distinct. Explanation:\n\nSolution 1: Greedy Algorithm\nWe notice that all the letters in the string $word$ are different. Therefore, we can greedily distribute the letters evenly across the $8$ keys to minimize the number of key presses.\nThe time complexity is $O(n / 8)$, where $n$ is the length of the string $word$. The space complexity is $O(1)$. \n\n", "problem_ids": ["keys-and-rooms", "number-of-rectangles-that-can-form-the-largest-square", "minimum-number-of-pushes-to-type-word-i"]}, "3017": {"text": "Similar Problem 1 \n\n Problem:\n\nA robot on an infinite XY-plane starts at point (0, 0) facing north. The robot can receive a sequence of these three possible types of commands:\n\n-2: Turn left 90 degrees.\n-1: Turn right 90 degrees.\n1 <= k <= 9: Move forward k units, one unit at a time.\n\nSome of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, then it will instead stay in its current location and move on to the next command.\nReturn the maximum Euclidean distance that the robot ever gets from the origin squared (i.e. if the distance is 5, return 25).\nNote:\n\nNorth means +Y direction.\nEast means +X direction.\nSouth means -Y direction.\nWest means -X direction.\nThere can be obstacle in\u00a0[0,0].\n\n\u00a0\nExample 1:\n\nInput: commands = [4,-1,3], obstacles = []\nOutput: 25\nExplanation: The robot starts at (0, 0):\n1. Move north 4 units to (0, 4).\n2. Turn right.\n3. Move east 3 units to (3, 4).\nThe furthest point the robot ever gets from the origin is (3, 4), which squared is 32 + 42 = 25 units away.\n\nExample 2:\n\nInput: commands = [4,-1,4,-2,4], obstacles = [[2,4]]\nOutput: 65\nExplanation: The robot starts at (0, 0):\n1. Move north 4 units to (0, 4).\n2. Turn right.\n3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).\n4. Turn left.\n5. Move north 4 units to (1, 8).\nThe furthest point the robot ever gets from the origin is (1, 8), which squared is 12 + 82 = 65 units away.\n\nExample 3:\n\nInput: commands = [6,-1,-1,6], obstacles = []\nOutput: 36\nExplanation: The robot starts at (0, 0):\n1. Move north 6 units to (0, 6).\n2. Turn right.\n3. Turn right.\n4. Move south 6 units to (0, 0).\nThe furthest point the robot ever gets from the origin is (0, 6), which squared is 62 = 36 units away.\n\n\u00a0\nConstraints:\n\n1 <= commands.length <= 104\ncommands[i] is either -2, -1, or an integer in the range [1, 9].\n0 <= obstacles.length <= 104\n-3 * 104 <= xi, yi <= 3 * 104\nThe answer is guaranteed to be less than 231. Explanation:\n\nSolution 1: Hash table + simulation\nWe define a direction array $dirs=[0, 1, 0, -1, 0]$ of length $5$, where adjacent elements in the array represent a direction. That is, $(dirs[0], dirs[1])$ represents north, and $(dirs[1], dirs[2])$ represents east, and so on.\nWe use a hash table $s$ to store the coordinates of all obstacles, so that we can determine in $O(1)$ time whether the next step will encounter an obstacle.\nWe use two variables $x$ and $y$ to represent the current coordinates of the robot, initially $x = y = 0$. The variable $k$ represents the current direction of the robot, and the answer variable $ans$ represents the maximum Euclidean distance squared of the robot from the origin.\nNext, we traverse each element $c$ in the array $commands$:\n\nIf $c = -2$, it means that the robot turns left by $90$ degrees, that is, $k = (k + 3) \\bmod 4$;\nIf $c = -1$, it means that the robot turns right by $90$ degrees, that is, $k = (k + 1) \\bmod 4$;\nOtherwise, it means that the robot moves forward by $c$ units of length. We combine the robot's current direction $k$ with the direction array $dirs$, and we can get the increment of the robot on the $x$ axis and the $y$ axis. We add the increment of $c$ units of length to $x$ and $y$ respectively, and judge whether the new coordinates $(x, y)$ after each move are in the coordinates of obstacles. If not, update the answer $ans$, otherwise stop simulating and perform the simulation of the next instruction.\n\nFinally return the answer $ans$.\nTime complexity is $O(C \\times n + m)$, space complexity is $O(m)$. Where $C$ represents the maximum number of steps that can be moved each time, and $n$ and $m$ respectively represent the lengths of arrays $commands$ and arrays $obstacles$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make answer equal to matrix, then replace each element with the value -1 with the maximum element in its respective column.\nReturn the matrix answer.\n\u00a0\nExample 1:\n\n\nInput: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\nOutput: [[1,2,9],[4,8,6],[7,8,9]]\nExplanation: The diagram above shows the elements that are changed (in blue).\n- We replace the value in the cell [1][1] with the maximum value in the column 1, that is 8.\n- We replace the value in the cell [0][2] with the maximum value in the column 2, that is 9.\n\nExample 2:\n\n\nInput: matrix = [[3,-1],[5,2]]\nOutput: [[3,2],[5,2]]\nExplanation: The diagram above shows the elements that are changed (in blue).\n\n\u00a0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n2 <= m, n <= 50\n-1 <= matrix[i][j] <= 100\nThe input is generated such that each column contains at least one non-negative integer. Explanation:\n\nSolution 1: Simulation\nWe can follow the problem description, traverse each column, find the maximum value of each column, and then traverse each column again, replacing the elements with a value of -1 with the maximum value of that column.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nA peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i. Explanation:\n\nSolution 1: Binary Search\nWe define the left boundary of binary search as $left=0$ and the right boundary as $right=n-1$, where $n$ is the length of the array. In each step of binary search, we find the middle element $mid$ of the current interval, and compare the values of $mid$ and its right neighbor $mid+1$:\n\nIf the value of $mid$ is greater than the value of $mid+1$, there exists a peak element on the left side, and we update the right boundary $right$ to $mid$.\nOtherwise, there exists a peak element on the right side, and we update the left boundary $left$ to $mid+1$.\nFinally, when the left boundary $left$ is equal to the right boundary $right$, we have found the peak element of the array.\n\nThe time complexity is $O(\\log n)$, where $n$ is the length of the array $nums$. Each step of binary search can reduce the search interval by half, so the time complexity is $O(\\log n)$. The space complexity is $O(1)$. \n\n", "problem_ids": ["walking-robot-simulation", "modify-the-matrix", "find-peak-element"]}, "3018": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given 2 positive integers l and r. For any number x, all positive divisors of x except x are called the proper divisors of x.\nA number is called special if it has exactly 2 proper divisors. For example:\n\nThe number 4 is special because it has proper divisors 1 and 2.\nThe number 6 is not special because it has proper divisors 1, 2, and 3.\n\nReturn the count of numbers in the range [l, r] that are not special.\n\u00a0\nExample 1:\n\nInput: l = 5, r = 7\nOutput: 3\nExplanation:\nThere are no special numbers in the range [5, 7].\n\nExample 2:\n\nInput: l = 4, r = 16\nOutput: 11\nExplanation:\nThe special numbers in the range [4, 16] are 4 and 9.\n\n\u00a0\nConstraints:\n\n1 <= l <= r <= 109 Explanation:\n\nSolution 1: Mathematics\nAccording to the problem description, we can observe that only the squares of prime numbers are special numbers. Therefore, we can first preprocess all prime numbers less than or equal to $\\sqrt{10^9}$, and then iterate through the interval $[\\lceil\\sqrt{l}\\rceil, \\lfloor\\sqrt{r}\\rfloor]$, counting the number of primes $\\textit{cnt}$ in the interval. Finally, we return $r - l + 1 - \\textit{cnt}$.\nThe time complexity is $O(\\sqrt{m})$, and the space complexity is $O(\\sqrt{m})$, where $m = 10^9$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere are n houses in a village. We want to supply water for all the houses by building wells and laying pipes.\nFor each house i, we can either build a well inside it directly with cost wells[i - 1] (note the -1 due to 0-indexing), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes where each pipes[j] = [house1j, house2j, costj] represents the cost to connect house1j and house2j together using a pipe. Connections are bidirectional, and there could be multiple valid connections between the same two houses with different costs.\nReturn the minimum total cost to supply water to all houses.\n\u00a0\nExample 1:\n\n\nInput: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]\nOutput: 3\nExplanation: The image shows the costs of connecting houses using pipes.\nThe best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.\n\nExample 2:\n\nInput: n = 2, wells = [1,1], pipes = [[1,2,1],[1,2,2]]\nOutput: 2\nExplanation: We can supply water with cost two using one of the three options:\nOption 1:\n  - Build a well inside house 1 with cost 1.\n  - Build a well inside house 2 with cost 1.\nThe total cost will be 2.\nOption 2:\n  - Build a well inside house 1 with cost 1.\n  - Connect house 2 with house 1 with cost 1.\nThe total cost will be 2.\nOption 3:\n  - Build a well inside house 2 with cost 1.\n  - Connect house 1 with house 2 with cost 1.\nThe total cost will be 2.\nNote that we can connect houses 1 and 2 with cost 1 or with cost 2 but we will always choose the cheapest option. \n\n\u00a0\nConstraints:\n\n2 <= n <= 104\nwells.length == n\n0 <= wells[i] <= 105\n1 <= pipes.length <= 104\npipes[j].length == 3\n1 <= house1j, house2j <= n\n0 <= costj <= 105\nhouse1j != house2j Explanation:\n\nSolution 1: Kruskal's Algorithm (Minimum Spanning Tree)\nWe assume that there is a well with the number $0$. Then we can consider the connectivity between each house and the well $0$ as an edge, and the weight of each edge is the cost of building a well for that house. At the same time, we consider the connectivity between each house as an edge, and the weight of each edge is the cost of laying a pipe. In this way, we can transform this problem into finding the minimum spanning tree of an undirected graph.\nWe can use Kruskal's algorithm to find the minimum spanning tree of the undirected graph. First, we add an edge between the well $0$ and the house to the $pipes$ array, and then sort the $pipes$ array in ascending order of edge weights. Then, we traverse each edge. If this edge connects different connected components, we choose this edge and merge the corresponding connected components. If the current connected component is exactly $1$, then we have found the minimum spanning tree. The answer at this time is the current edge weight, and we return it.\nThe time complexity is $O((m + n) \\times \\log (m + n))$, and the space complexity is $O(m + n)$. Here, $m$ and $n$ are the lengths of the $pipes$ array and the $wells$ array, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nA string is considered beautiful if it satisfies the following conditions:\n\nEach of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it.\nThe letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.).\n\nFor example, strings \"aeiou\" and \"aaaaaaeiiiioou\" are considered beautiful, but \"uaeio\", \"aeoiu\", and \"aaaeeeooo\" are not beautiful.\nGiven a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0.\nA substring is a contiguous sequence of characters in a string.\n\u00a0\nExample 1:\n\nInput: word = \"aeiaaioaaaaeiiiiouuuooaauuaeiu\"\nOutput: 13\nExplanation: The longest beautiful substring in word is \"aaaaeiiiiouuu\" of length 13.\nExample 2:\n\nInput: word = \"aeeeiiiioooauuuaeiou\"\nOutput: 5\nExplanation: The longest beautiful substring in word is \"aeiou\" of length 5.\n\nExample 3:\n\nInput: word = \"a\"\nOutput: 0\nExplanation: There is no beautiful substring, so return 0.\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 5 * 105\nword consists of characters 'a', 'e', 'i', 'o', and 'u'. Explanation:\n\nSolution 1: Two Pointers + Simulation\nWe can first transform the string word. For example, for word=\"aaaeiouu\", we can transform it into data items ('a', 3), ('e', 1), ('i', 1), ('o', 1), ('u', 2) and store them in an array arr. Each data item's first element represents a vowel, and the second element represents the number of times the vowel appears consecutively. This transformation can be implemented using two pointers.\nNext, we traverse the array arr, each time taking $5$ adjacent data items, and judge whether the vowels in these data items are 'a', 'e', 'i', 'o', 'u' respectively. If so, calculate the total number of times the vowels appear in these $5$ data items, which is the length of the current beautiful substring, and update the maximum value of the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the string word. \n\n", "problem_ids": ["find-the-count-of-numbers-which-are-not-special", "optimize-water-distribution-in-a-village", "longest-substring-of-all-vowels-in-order"]}, "3019": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a binary tree, determine if it is height-balanced.\n\u00a0\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\nExample 2:\n\n\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\nExample 3:\n\nInput: root = []\nOutput: true\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 5000].\n-104 <= Node.val <= 104 Explanation:\n\nSolution 1: Bottom-Up Recursion\nWe define a function $height(root)$ to calculate the height of a binary tree, with the following logic:\n\nIf the binary tree $root$ is null, return $0$.\nOtherwise, recursively calculate the heights of the left and right subtrees, denoted as $l$ and $r$ respectively. If either $l$ or $r$ is $-1$, or the absolute difference between $l$ and $r$ is greater than $1$, then return $-1$. Otherwise, return $max(l, r) + 1$.\n\nTherefore, if the function $height(root)$ returns $-1$, it means the binary tree $root$ is not balanced. Otherwise, it is balanced.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a positive integer k. Initially, you have an array nums = [1].\nYou can perform any of the following operations on the array any number of times (possibly zero):\n\nChoose any element in the array and increase its value by 1.\nDuplicate any element in the array and add it to the end of the array.\n\nReturn the minimum number of operations required to make the sum of elements of the final array greater than or equal to k.\n\u00a0\nExample 1:\n\nInput: k = 11\nOutput: 5\nExplanation:\nWe can do the following operations on the array nums = [1]:\n\nIncrease the element by 1 three times. The resulting array is nums = [4].\nDuplicate the element two times. The resulting array is nums = [4,4,4].\n\nThe sum of the final array is 4 + 4 + 4 = 12 which is greater than or equal to k = 11.\nThe total number of operations performed is 3 + 2 = 5.\n\nExample 2:\n\nInput: k = 1\nOutput: 0\nExplanation:\nThe sum of the original array is already greater than or equal to 1, so no operations are needed.\n\n\u00a0\nConstraints:\n\n1 <= k <= 105 Explanation:\n\nSolution 1: Enumeration\nWe should put the copy operation (i.e., operation $2$) at the end to reduce the number of operations.\nTherefore, we enumerate the number of times $a$ for operation $1$ in the range $[0, k]$, then the number of times $b$ for operation $2$ is $\\left\\lceil \\frac{k}{a+1} \\right\\rceil - 1$. We take the minimum of $a+b$.\nThe time complexity is $O(k)$, where $k$ is the input positive integer $k$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.\nIf node i has no left child then leftChild[i] will equal -1, similarly for the right child.\nNote that the nodes have no values and that we only use the node numbers in this problem.\n\u00a0\nExample 1:\n\n\nInput: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\nOutput: true\n\nExample 2:\n\n\nInput: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\nOutput: false\n\nExample 3:\n\n\nInput: n = 2, leftChild = [1,0], rightChild = [-1,-1]\nOutput: false\n\n\u00a0\nConstraints:\n\nn == leftChild.length == rightChild.length\n1 <= n <= 104\n-1 <= leftChild[i], rightChild[i] <= n - 1 Explanation:\n\nSolution 1: Union-Find\nWe can traverse each node $i$ and its corresponding left and right children $l$, $r$, using an array $vis$ to record whether the node has a parent:\n\nIf the child node already has a parent, it means there are multiple fathers, which does not meet the condition, so we return false directly.\nIf the child node and the parent node are already in the same connected component, it means a cycle will be formed, which does not meet the condition, so we return false directly.\nOtherwise, we perform a union operation, set the corresponding position of the $vis$ array to true, and decrease the number of connected components by $1$.\n\nAfter the traversal, we check whether the number of connected components in the union-find set is $1$. If it is, we return true, otherwise, we return false.\nThe time complexity is $O(n \\times \\alpha(n))$, and the space complexity is $O(n)$. Where $n$ is the number of nodes, and $\\alpha(n)$ is the inverse Ackermann function, which is less than $5$. \n\n", "problem_ids": ["balanced-binary-tree", "apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k", "validate-binary-tree-nodes"]}, "3024": {"text": "Similar Problem 1 \n\n Problem:\n\nImplement a SnapshotArray that supports the following interface:\n\nSnapshotArray(int length) initializes an array-like data structure with the given length. Initially, each element equals 0.\nvoid set(index, val) sets the element at the given index to be equal to val.\nint snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.\nint get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id\n\n\u00a0\nExample 1:\n\nInput: [\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\"]\n[[3],[0,5],[],[0,6],[0,0]]\nOutput: [null,null,0,null,5]\nExplanation: \nSnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\nsnapshotArr.set(0,5);  // Set array[0] = 5\nsnapshotArr.snap();  // Take a snapshot, return snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5\n\u00a0\nConstraints:\n\n1 <= length <= 5 * 104\n0 <= index < length\n0 <= val <= 109\n0 <= snap_id < (the total number of times we call snap())\nAt most 5 * 104 calls will be made to set, snap, and get. Explanation:\n\nSolution 1: Array + Binary Search\nWe maintain an array of length length. Each element in the array is a list, which is used to store the value set each time and the corresponding snapshot ID.\nWhen the set method is called, we add the value and snapshot ID to the list at the corresponding index. The time complexity is $O(1)$.\nWhen the snap method is called, we first increment the snapshot ID, then return the snapshot ID minus one. The time complexity is $O(1)$.\nWhen the get method is called, we use binary search to find the first snapshot ID greater than snap_id at the corresponding position, and then return the previous value. If it cannot be found, return 0. The time complexity is $O(\\log n)$.\nThe space complexity is $O(n)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 1-indexed array nums. Your task is to select a complete subset from nums where every pair of selected indices multiplied is a perfect square,. i. e. if you select ai and aj, i * j must be a perfect square.\nReturn the sum of the complete subset with the maximum sum.\n\u00a0\nExample 1:\n\nInput: nums = [8,7,3,5,7,2,4,9]\nOutput: 16\nExplanation:\nWe select elements at indices 2 and 8 and 2\u00a0* 8\u00a0is a perfect square.\n\nExample 2:\n\nInput: nums = [8,10,3,8,1,13,7,9,4]\nOutput: 20\nExplanation:\nWe select elements at indices 1, 4, and 9. 1 * 4, 1 * 9, 4 * 9 are perfect squares.\n\n\u00a0\nConstraints:\n\n1 <= n == nums.length <= 104\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Enumeration\nWe note that if a number can be expressed in the form of $k \\times j^2$, then all numbers of this form have the same $k$.\nTherefore, we can enumerate $k$ in the range $[1,..n]$, and then start enumerating $j$ from $1$, each time adding the value of $nums[k \\times j^2 - 1]$ to $t$, until $k \\times j^2 > n$. At this point, update the answer to $ans = \\max(ans, t)$.\nFinally, return the answer $ans$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nDesign a phone directory that initially has maxNumbers empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.\nImplement the PhoneDirectory class:\n\nPhoneDirectory(int maxNumbers) Initializes the phone directory with the number of available slots maxNumbers.\nint get() Provides a number that is not assigned to anyone. Returns -1 if no number is available.\nbool check(int number) Returns true if the slot number is available and false otherwise.\nvoid release(int number) Recycles or releases the slot number.\n\n\u00a0\nExample 1:\n\nInput\n[\"PhoneDirectory\", \"get\", \"get\", \"check\", \"get\", \"check\", \"release\", \"check\"]\n[[3], [], [], [2], [], [2], [2], [2]]\nOutput\n[null, 0, 1, true, 2, false, null, true]\n\nExplanation\nPhoneDirectory phoneDirectory = new PhoneDirectory(3);\nphoneDirectory.get();      // It can return any available phone number. Here we assume it returns 0.\nphoneDirectory.get();      // Assume it returns 1.\nphoneDirectory.check(2);   // The number 2 is available, so return true.\nphoneDirectory.get();      // It returns 2, the only number that is left.\nphoneDirectory.check(2);   // The number 2 is no longer available, so return false.\nphoneDirectory.release(2); // Release number 2 back to the pool.\nphoneDirectory.check(2);   // Number 2 is available again, return true.\n\n\u00a0\nConstraints:\n\n1 <= maxNumbers <= 104\n0 <= number < maxNumbers\nAt most 2 * 104 calls will be made to get, check, and release. Explanation:\n\nSolution 1: Hash Table\nWe can use a hash set available to store unallocated phone numbers. Initially, the hash set contains [0, 1, 2, ..., maxNumbers - 1].\nWhen the get method is called, we take an unallocated phone number from available. If available is empty, we return -1. The time complexity is $O(1)$.\nWhen the check method is called, we just need to check whether number is in available. The time complexity is $O(1)$.\nWhen the release method is called, we add number to available. The time complexity is $O(1)$.\nThe space complexity is $O(n)$, where $n$ is the value of maxNumbers. \n\n", "problem_ids": ["snapshot-array", "maximum-element-sum-of-a-complete-subset-of-indices", "design-phone-directory"]}, "3025": {"text": "Similar Problem 1 \n\n Problem:\n\nAlice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them.\nThe game proceeds as follows:\n\nAlice takes the first turn.\nIn each turn, a player must choose either the clockwise or anti-clockwise direction and pick one flower from that side.\nAt the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.\n\nGiven two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:\n\nAlice must win the game according to the described rules.\nThe number of flowers x in the clockwise direction must be in the range [1,n].\nThe number of flowers y in the anti-clockwise direction must be in the range [1,m].\n\nReturn the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.\n\u00a0\nExample 1:\n\nInput: n = 3, m = 2\nOutput: 3\nExplanation: The following pairs satisfy conditions described in the statement: (1,2), (3,2), (2,1).\n\nExample 2:\n\nInput: n = 1, m = 1\nOutput: 0\nExplanation: No pairs satisfy the conditions described in the statement.\n\n\u00a0\nConstraints:\n\n1 <= n, m <= 105 Explanation:\n\nSolution 1: Mathematics\nAccording to the problem description, in each move, the player will choose to move in a clockwise or counterclockwise direction and then pick a flower. Since Alice moves first, when $x + y$ is odd, Alice will definitely win the game.\nTherefore, the number of flowers $x$ and $y$ meet the following conditions:\n\n$x + y$ is odd;\n$1 \\le x \\le n$;\n$1 \\le y \\le m$.\n\nIf $x$ is odd, $y$ must be even. At this time, the number of values of $x$ is $\\lceil \\frac{n}{2} \\rceil$, the number of values of $y$ is $\\lfloor \\frac{m}{2} \\rfloor$, so the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor$.\nIf $x$ is even, $y$ must be odd. At this time, the number of values of $x$ is $\\lfloor \\frac{n}{2} \\rfloor$, the number of values of $y$ is $\\lceil \\frac{m}{2} \\rceil$, so the number of pairs that meet the conditions is $\\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$.\nTherefore, the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$, which is $\\lfloor \\frac{n + 1}{2} \\rfloor \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lfloor \\frac{m + 1}{2} \\rfloor$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\n\nReturn true if the square is white, and false if the square is black.\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.\n\u00a0\nExample 1:\n\nInput: coordinates = \"a1\"\nOutput: false\nExplanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false.\n\nExample 2:\n\nInput: coordinates = \"h3\"\nOutput: true\nExplanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true.\n\nExample 3:\n\nInput: coordinates = \"c7\"\nOutput: false\n\n\u00a0\nConstraints:\n\ncoordinates.length == 2\n'a' <= coordinates[0] <= 'h'\n'1' <= coordinates[1] <= '8' Explanation:\n\nSolution 1: Find the Pattern\nBy observing the chessboard, we find that two squares $(x_1, y_1)$ and $(x_2, y_2)$ with the same color satisfy that both $x_1 + y_1$ and $x_2 + y_2$ are either odd or even.\nTherefore, we can get the corresponding coordinates $(x, y)$ from coordinates. If $x + y$ is odd, then the square is white, return true, otherwise return false.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).\nYou are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:\n\nCover all the empty cells.\nDo not cover any of the occupied cells.\nWe can put as many stamps as we want.\nStamps can overlap with each other.\nStamps are not allowed to be rotated.\nStamps must stay completely inside the grid.\n\nReturn true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\nOutput: true\nExplanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n\nExample 2:\n\n\nInput: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \nOutput: false \nExplanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[r].length\n1 <= m, n <= 105\n1 <= m * n <= 2 * 105\ngrid[r][c] is either 0 or 1.\n1 <= stampHeight, stampWidth <= 105 Explanation:\n\nSolution 1: Two-Dimensional Prefix Sum + Two-Dimensional Difference\nAccording to the problem description, every empty cell must be covered by a stamp, and no occupied cell can be covered. Therefore, we can traverse the two-dimensional matrix, and for each cell, if all cells in the area of $stampHeight \\times stampWidth$ with this cell as the upper left corner are empty (i.e., not occupied), then we can place a stamp at this cell.\nTo quickly determine whether all cells in an area are empty, we can use a two-dimensional prefix sum. We use $s_{i,j}$ to represent the number of occupied cells in the sub-matrix from $(1,1)$ to $(i,j)$ in the two-dimensional matrix. That is, $s_{i, j} = s_{i - 1, j} + s_{i, j - 1} - s_{i - 1, j - 1} + grid_{i-1, j-1}$.\nThen, with $(i, j)$ as the upper left corner, and the height and width are $stampHeight$ and $stampWidth$ respectively, the lower right coordinate of the sub-matrix is $(x, y) = (i + stampHeight - 1, j + stampWidth - 1)$. We can calculate the number of occupied cells in this sub-matrix through $s_{x, y} - s_{x, j - 1} - s_{i - 1, y} + s_{i - 1, j - 1}$. If the number of occupied cells in this sub-matrix is $0$, then we can place a stamp at $(i, j)$. After placing the stamp, all cells in this $stampHeight \\times stampWidth$ area will become occupied cells. We can use a two-dimensional difference array $d$ to record this change. That is:\n$$\n\\begin{aligned}\nd_{i, j} &\\leftarrow d_{i, j} + 1 \\\nd_{i, y + 1} &\\leftarrow d_{i, y + 1} - 1 \\\nd_{x + 1, j} &\\leftarrow d_{x + 1, j} - 1 \\\nd_{x + 1, y + 1} &\\leftarrow d_{x + 1, y + 1} + 1\n\\end{aligned}\n$$\nFinally, we perform a prefix sum operation on the two-dimensional difference array $d$ to find out the number of times each cell is covered by a stamp. If a cell is not occupied and the number of times it is covered by a stamp is $0$, then we cannot place a stamp at this cell, so we need to return $\\texttt{false}$. If all \"unoccupied cells\" are successfully covered by stamps, return $\\texttt{true}$.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the height and width of the two-dimensional matrix, respectively. \n\n", "problem_ids": ["alice-and-bob-playing-flower-game", "determine-color-of-a-chessboard-square", "stamping-the-grid"]}, "3031": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given three positive integers num1, num2, and num3.\nThe key of num1, num2, and num3 is defined as a four-digit number such that:\n\nInitially, if any number has less than four digits, it is padded with leading zeros.\nThe ith digit (1 <= i <= 4) of the key is generated by taking the smallest digit among the ith digits of num1, num2, and num3.\n\nReturn the key of the three numbers without leading zeros (if any).\n\u00a0\nExample 1:\n\nInput: num1 = 1, num2 = 10, num3 = 1000\nOutput: 0\nExplanation:\nOn padding, num1 becomes \"0001\", num2 becomes \"0010\", and num3 remains \"1000\".\n\nThe 1st digit of the key is min(0, 0, 1).\nThe 2nd digit of the key is min(0, 0, 0).\nThe 3rd digit of the key is min(0, 1, 0).\nThe 4th digit of the key is min(1, 0, 0).\n\nHence, the key is \"0000\", i.e. 0.\n\nExample 2:\n\nInput: num1 = 987, num2 = 879, num3 = 798\nOutput: 777\n\nExample 3:\n\nInput: num1 = 1, num2 = 2, num3 = 3\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= num1, num2, num3 <= 9999 Explanation:\n\nSolution 1: Simulation\nWe can directly simulate this process by defining a variable $\\textit{ans}$ to store the answer and a variable $\\textit{k}$ to represent the current digit place, where $\\textit{k} = 1$ represents the units place, $\\textit{k} = 10$ represents the tens place, and so on.\nStarting from the units place, for each digit place, we calculate the current digit of $\\textit{num1}$, $\\textit{num2}$, and $\\textit{num3}$, take the minimum of the three, and then add this minimum value multiplied by $\\textit{k}$ to the answer. Then, multiply $\\textit{k}$ by 10 and continue to the next digit place.\nFinally, return the answer.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a binary array nums of length n, a positive integer k and a non-negative integer maxChanges.\nAlice plays a game, where the goal is for Alice to pick up k ones from nums using the minimum number of moves. When the game starts, Alice picks up any index aliceIndex in the range [0, n - 1] and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice can make any number of moves (including zero) where in each move Alice must perform exactly one of the following actions:\n\nSelect any index j != aliceIndex such that nums[j] == 0 and set nums[j] = 1. This action can be performed at most maxChanges times.\nSelect any two adjacent indices x and y (|x - y| == 1) such that nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move and nums[y] becomes 0.\n\nReturn the minimum number of moves required by Alice to pick exactly k ones.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\nOutput: 3\nExplanation: Alice can pick up 3 ones in 3 moves, if Alice performs the following actions in each move when standing at aliceIndex == 1:\n\nAt the start of the game Alice picks up the one and nums[1] becomes 0. nums becomes [1,0,0,0,0,1,1,0,0,1].\nSelect j == 2 and perform an action of the first type. nums becomes [1,0,1,0,0,1,1,0,0,1]\nSelect x == 2 and y == 1, and perform an action of the second type. nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].\nSelect x == 0 and y == 1, and perform an action of the second type. nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].\n\nNote that it may be possible for Alice to pick up 3 ones using some other sequence of 3 moves.\n\nExample 2:\n\nInput: nums = [0,0,0,0], k = 2, maxChanges = 3\nOutput: 4\nExplanation: Alice can pick up 2 ones in 4 moves, if Alice performs the following actions in each move when standing at aliceIndex == 0:\n\nSelect j == 1 and perform an action of the first type. nums becomes [0,1,0,0].\nSelect x == 1 and y == 0, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\nSelect j == 1 again and perform an action of the first type. nums becomes [0,1,0,0].\nSelect x == 1 and y == 0 again, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\n\n\n\u00a0\nConstraints:\n\n2 <= n <= 105\n0 <= nums[i] <= 1\n1 <= k <= 105\n0 <= maxChanges <= 105\nmaxChanges + sum(nums) >= k Explanation:\n\nSolution 1: Greedy + Prefix Sum + Binary Search\nWe consider enumerating Alice's standing position $i$. For each $i$, we follow the strategy below:\n\nFirst, if the number at position $i$ is $1$, we can directly pick up a $1$ without needing any moves.\nThen, we pick up the number $1$ from both sides of position $i$, which is action $2$, i.e., move the $1$ from position $i-1$ to position $i$, then pick it up; move the $1$ from position $i+1$ to position $i$, then pick it up. Each pick up of a $1$ requires $1$ move.\nNext, we maximize the conversion of $0$s at positions $i-1$ or $i+1$ to $1$s using action $1$, then move them to position $i$ using action $2$ to pick them up. This continues until the number of $1$s picked up reaches $k$ or the number of times action $1$ is used reaches $\\textit{maxChanges}$. Assuming the number of times action $1$ is used is $c$, then a total of $2c$ moves are needed.\nAfter utilizing action $1$, if the number of $1$s picked up has not reached $k$, we need to continue considering moving $1$s to position $i$ from the intervals $[1,..i-2]$ and $[i+2,..n]$ using action $2$ to pick them up. We can use binary search to determine the size of this interval so that the number of $1$s picked up reaches $k$. Specifically, we binary search for an interval size $d$, then within the intervals $[i-d,..i-2]$ and $[i+2,..i+d]$, we perform action $2$ to move $1$s to position $i$ for pickup. If the number of $1$s picked up reaches $k$, we update the answer.\n\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $\\textit{nums}$. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\nGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\naddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\nint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.\n\n\u00a0\nExample 1:\n\n\nInput\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.\n\n\n\u00a0\nConstraints:\n\n1 <= n <= 100\n0 <= edges.length <= n * (n - 1)\nedges[i].length == edge.length == 3\n0 <= fromi, toi, from, to, node1, node2 <= n - 1\n1 <= edgeCosti, edgeCost <= 106\nThere are no repeated edges and no self-loops in the graph at any point.\nAt most 100 calls will be made for addEdge.\nAt most 100 calls will be made for shortestPath. Explanation:\n\nSolution 1: Dijsktra's Algorithm\nIn the initialization function, we first use the adjacency matrix $g$ to store the edge weights of the graph, where $g_{ij}$ represents the edge weight from node $i$ to node $j$. If there is no edge between $i$ and $j$, the value of $g_{ij}$ is $\\infty$.\nIn the addEdge function, we update the value of $g_{ij}$ to $edge[2]$.\nIn the shortestPath function, we use Dijsktra's algorithm to find the shortest path from node $node1$ to node $node2$. Here, $dist[i]$ represents the shortest path from node $node1$ to node $i$, and $vis[i]$ indicates whether node $i$ has been visited. We initialize $dist[node1]$ to $0$, and the rest of $dist[i]$ are all $\\infty$. Then we iterate $n$ times, each time finding the current unvisited node $t$ such that $dist[t]$ is the smallest. Then we mark node $t$ as visited, and then update the value of $dist[i]$ to $min(dist[i], dist[t] + g_{ti})$. Finally, we return $dist[node2]$. If $dist[node2]$ is $\\infty$, it means that there is no path from node $node1$ to node $node2$, so we return $-1$.\nThe time complexity is $O(n^2 \\times q)$, and the space complexity is $O(n^2)$. Where $n$ is the number of nodes, and $q$ is the number of calls to the shortestPath function. \n\n", "problem_ids": ["find-the-key-of-the-numbers", "minimum-moves-to-pick-k-ones", "design-graph-with-shortest-path-calculator"]}, "3032": {"text": "Similar Problem 1 \n\n Problem:\n\nWe define the conversion array conver of an array arr as follows:\n\nconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].\n\u00a0\nExample 1:\n\nInput: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56\n\nExample 2:\n\nInput: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Prefix Sum\nWe use a variable $mx$ to record the maximum value of the first $i$ elements in the array $nums$, and use an array $ans[i]$ to record the score of the first $i$ elements in the array $nums$.\nNext, we traverse the array $nums$. For each element $nums[i]$, we update $mx$, i.e., $mx = \\max(mx, nums[i])$, and then update $ans[i]$. If $i = 0$, then $ans[i] = nums[i] + mx$, otherwise $ans[i] = nums[i] + mx + ans[i - 1]$.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. Ignoring the space consumption of the answer array, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung.\nYou are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. You are able to insert rungs at any positive integer height if a rung is not already there.\nReturn the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.\n\u00a0\nExample 1:\n\nInput: rungs = [1,3,5,10], dist = 2\nOutput: 2\nExplanation:\nYou currently cannot reach the last rung.\nAdd rungs at heights 7 and 8 to climb this ladder. \nThe ladder will now have rungs at [1,3,5,7,8,10].\n\nExample 2:\n\nInput: rungs = [3,6,8,10], dist = 3\nOutput: 0\nExplanation:\nThis ladder can be climbed without adding additional rungs.\n\nExample 3:\n\nInput: rungs = [3,4,6,7], dist = 2\nOutput: 1\nExplanation:\nYou currently cannot reach the first rung from the ground.\nAdd a rung at height 1 to climb this ladder.\nThe ladder will now have rungs at [1,3,4,6,7].\n\n\u00a0\nConstraints:\n\n1 <= rungs.length <= 105\n1 <= rungs[i] <= 109\n1 <= dist <= 109\nrungs is strictly increasing. Explanation:\n\nSolution 1: Greedy + Simulation\nAccording to the problem description, we know that every time we plan to climb a new rung, we need to ensure that the height difference between the new rung and the current position does not exceed dist. Otherwise, we need to greedily insert a new rung at a distance of $dist$ from the current position, climb a new rung, and the total number of rungs to be inserted is $\\lfloor \\frac{b - a - 1}{dist} \\rfloor$, where $a$ and $b$ are the current position and the height of the new rung, respectively. The answer is the sum of all inserted rungs.\nThe time complexity is $O(n)$, where $n$ is the length of rungs. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a string s of '(' , ')' and lowercase English characters.\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.\n\n\u00a0\nExample 1:\n\nInput: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n\nExample 2:\n\nInput: s = \"a)b(c)d\"\nOutput: \"ab(c)d\"\n\nExample 3:\n\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns[i] is either\u00a0'(' , ')', or lowercase English letter. Explanation:\n\nSolution 1: Two Passes\nFirst, we scan from left to right and remove the extra right parentheses. Then, we scan from right to left and remove the extra left parentheses.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the string $s$.\nSimilar problems:\n\n678. Valid Parenthesis String\n2116. Check if a Parentheses String Can Be Valid \n\n", "problem_ids": ["find-the-score-of-all-prefixes-of-an-array", "add-minimum-number-of-rungs", "minimum-remove-to-make-valid-parentheses"]}, "3033": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array num sorted in non-decreasing order.\nYou can perform the following operation any number of times:\n\nChoose two indices, i and j, where nums[i] < nums[j].\nThen, remove the elements at indices i and j from nums. The remaining elements retain their original order, and the array is re-indexed.\n\nReturn the minimum length of nums after applying the operation zero or more times.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: 0\nExplanation:\n\n\nExample 2:\n\nInput: nums = [1,1,2,2,3,3]\nOutput: 0\nExplanation:\n\n\nExample 3:\n\nInput: nums = [1000000000,1000000000]\nOutput: 2\nExplanation:\nSince both numbers are equal, they cannot be removed.\n\nExample 4:\n\nInput: nums = [2,3,4,4,4]\nOutput: 1\nExplanation:\n\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\nnums is sorted in non-decreasing order. Explanation:\n\nSolution 1: Greedy + Priority Queue (Max Heap)\nWe use a hash table $cnt$ to count the occurrence of each element in the array $nums$, then add each value in $cnt$ to a priority queue (max heap) $pq$. Each time we take out two elements $x$ and $y$ from $pq$, decrease their values by one. If the value after decrement is still greater than $0$, we add the decremented value back to $pq$. Each time we take out two elements from $pq$, it means we delete a pair of numbers from the array, so the length of the array decreases by $2$. When the size of $pq$ is less than $2$, we stop the deletion operation.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:\n\nEvery round, first Alice will remove the minimum element from nums, and then Bob does the same.\nNow, first Bob will append the removed element in the array arr, and then Alice does the same.\nThe game continues until nums becomes empty.\n\nReturn the resulting array arr.\n\u00a0\nExample 1:\n\nInput: nums = [5,4,2,3]\nOutput: [3,2,5,4]\nExplanation: In round one, first Alice removes 2 and then Bob removes 3. Then in arr firstly Bob appends 3 and then Alice appends 2. So arr = [3,2].\nAt the begining of round two, nums = [5,4]. Now, first Alice removes 4 and then Bob removes 5. Then both append in arr which becomes [3,2,5,4].\n\nExample 2:\n\nInput: nums = [2,5]\nOutput: [5,2]\nExplanation: In round one, first Alice removes 2 and then Bob removes 5. Then in arr firstly Bob appends and then Alice appends. So arr = [5,2].\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 100\n1 <= nums[i] <= 100\nnums.length % 2 == 0 Explanation:\n\nSolution 1: Simulation + Priority Queue (Min Heap)\nWe can put the elements of the array $\\textit{nums}$ into a min heap one by one. Each time, we take out two elements $a$ and $b$ from the min heap, and then sequentially put $b$ and $a$ into the answer array until the min heap is empty.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $\\textit{nums}$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:\n\n|x - y| <= min(x, y)\n\nYou need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.\nReturn the maximum XOR value out of all possible strong pairs in the array nums.\nNote that you can pick the same integer twice to form a pair.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: 7\nExplanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.\n\nExample 2:\n\nInput: nums = [10,100]\nOutput: 0\nExplanation: There are 2 strong pairs in the array nums: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.\n\nExample 3:\n\nInput: nums = [500,520,2500,3000]\nOutput: 1020\nExplanation: There are 6 strong pairs in the array nums: (500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) and (3000, 3000).\nThe maximum XOR possible from these pairs is 500 XOR 520 = 1020 since the only other non-zero XOR value is 2500 XOR 3000 = 636.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 220 - 1 Explanation:\n\nSolution 1: Sorting + Binary Trie\nObserving the inequality $|x - y| \\leq \\min(x, y)$, which involves absolute value and minimum value, we can assume $x \\leq y$, then we have $y - x \\leq x$, that is, $y \\leq 2x$. We can enumerate $y$ from small to large, then $x$ must satisfy the inequality $y \\leq 2x$.\nTherefore, we sort the array $nums$, and then enumerate $y$ from small to large. We use two pointers to maintain a window so that the elements $x$ in the window satisfy the inequality $y \\leq 2x$. We can use a binary trie to maintain the elements in the window, so we can find the maximum XOR value in the window in $O(1)$ time. Each time we add $y$ to the trie, and remove the elements at the left end of the window that do not satisfy the inequality, this can ensure that the elements in the window satisfy the inequality $y \\leq 2x$. Then query the maximum XOR value from the trie and update the answer.\nThe time complexity is $O(n \\times \\log M)$, and the space complexity is $O(n \\times \\log M)$. Here, $n$ is the length of the array $nums$, and $M$ is the maximum value in the array $nums$. In this problem, $M = 2^{20}$. \n\n", "problem_ids": ["minimum-array-length-after-pair-removals", "minimum-number-game", "maximum-strong-pair-xor-ii"]}, "3034": {"text": "Similar Problem 1 \n\n Problem:\n\nAlice and Bob each have a lexicographically sorted array of strings named a and b respectively.\nThey are playing a wording game with the following rules:\n\nOn each turn, the current player should play a word from their list such that the new word is closely greater than the last played word; then it's the other player's turn.\nIf a player can't play a word on their turn, they lose.\n\nAlice starts the game by playing her lexicographically smallest word.\nGiven a and b, return true if Alice can win knowing that both players play their best, and false otherwise.\nA word w is closely greater than a word z if the following conditions are met:\n\nw is lexicographically greater than z.\nIf w1 is the first letter of w and z1 is the first letter of z, w1 should either be equal to z1 or be the letter after z1 in the alphabet.\nFor example, the word \"care\" is closely greater than \"book\" and \"car\", but is not closely greater than \"ant\" or \"cook\".\n\nA string s is lexicographically greater than a string t if in the first position where s and t differ, string s has a letter that appears later in the alphabet than the corresponding letter in t. If the first min(s.length, t.length) characters do not differ, then the longer string is the lexicographically greater one.\n\u00a0\nExample 1:\n\nInput: a = [\"avokado\",\"dabar\"], b = [\"brazil\"]\nOutput: false\nExplanation: Alice must start the game by playing the word \"avokado\" since it's her smallest word, then Bob plays his only word, \"brazil\", which he can play because its first letter, 'b', is the letter after Alice's word's first letter, 'a'.\nAlice can't play a word since the first letter of the only word left is not equal to 'b' or the letter after 'b', 'c'.\nSo, Alice loses, and the game ends.\nExample 2:\n\nInput: a = [\"ananas\",\"atlas\",\"banana\"], b = [\"albatros\",\"cikla\",\"nogomet\"]\nOutput: true\nExplanation: Alice must start the game by playing the word \"ananas\".\nBob can't play a word since the only word he has that starts with the letter 'a' or 'b' is \"albatros\", which is smaller than Alice's word.\nSo Alice wins, and the game ends.\nExample 3:\n\nInput: a = [\"hrvatska\",\"zastava\"], b = [\"bijeli\",\"galeb\"]\nOutput: true\nExplanation: Alice must start the game by playing the word \"hrvatska\".\nBob can't play a word since the first letter of both of his words are smaller than the first letter of Alice's word, 'h'.\nSo Alice wins, and the game ends.\n\n\u00a0\nConstraints:\n\n1 <= a.length, b.length <= 105\na[i] and b[i] consist only of lowercase English letters.\na and b are lexicographically sorted.\nAll the words in a and b combined are distinct.\nThe sum of the lengths of all the words in a and b combined does not exceed 106. Explanation:\n\nSolution 1: Simulation\nWe use $k$ to record whose turn it is, where $k=0$ means it is Alice's turn, and $k=1$ means it is Bob's turn. We use $i$ to record Alice's index, $j$ to record Bob's index, and $w$ to record the current word. Initially, we set $i=1$, $j=0$, and $w=a[0]$.\nWe perform the following steps repeatedly:\nIf $k=1$, we check if $j$ is equal to the length of $b$. If it is, then Alice wins and we return $true$. Otherwise, we check if the first letter of $b[j]$ is equal to the first letter of $w$. If it is, we check if $b[j]$ is greater than $w$, or if the first letter of $b[j]$ is one greater than the first letter of $w$. If either of these conditions is true, then Bob can play the $j$-th word. We set $w=b[j]$ and toggle $k$. Otherwise, Bob cannot play the $j$-th word, so we increment $j$.\nIf $k=0$, we check if $i$ is equal to the length of $a$. If it is, then Bob wins and we return $false$. Otherwise, we check if the first letter of $a[i]$ is equal to the first letter of $w$. If it is, we check if $a[i]$ is greater than $w$, or if the first letter of $a[i]$ is one greater than the first letter of $w$. If either of these conditions is true, then Alice can play the $i$-th word. We set $w=a[i]$ and toggle $k$. Otherwise, Alice cannot play the $i$-th word, so we increment $i$.\nThe time complexity is $O(m+n)$, where $m$ and $n$ are the lengths of arrays $a$ and $b$, respectively. We only need to traverse the arrays once. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:\n\nChoose any piles[i] and remove floor(piles[i] / 2) stones from it.\n\nNotice that you can apply the operation on the same pile more than once.\nReturn the minimum possible total number of stones remaining after applying the k operations.\nfloor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\n\u00a0\nExample 1:\n\nInput: piles = [5,4,9], k = 2\nOutput: 12\nExplanation:\u00a0Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are [5,4,5].\n- Apply the operation on pile 0. The resulting piles are [3,4,5].\nThe total number of stones in [3,4,5] is 12.\n\nExample 2:\n\nInput: piles = [4,3,6,7], k = 3\nOutput: 12\nExplanation:\u00a0Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\n- Apply the operation on pile 3. The resulting piles are [4,3,3,4].\n- Apply the operation on pile 0. The resulting piles are [2,3,3,4].\nThe total number of stones in [2,3,3,4] is 12.\n\n\u00a0\nConstraints:\n\n1 <= piles.length <= 105\n1 <= piles[i] <= 104\n1 <= k <= 105 Explanation:\n\nSolution 1: Greedy + Priority Queue (Max Heap)\nAccording to the problem description, in order to minimize the total number of remaining stones, we need to remove as many stones as possible from the stone piles. Therefore, we should always choose the pile with the most stones for removal.\nWe create a priority queue (max heap) $pq$ to store the number of stones in each pile. Initially, we add the number of stones in all piles to the priority queue.\nNext, we perform $k$ operations. In each operation, we take out the top element $x$ of the priority queue, halve $x$, and then add it back to the priority queue.\nAfter performing $k$ operations, the sum of all elements in the priority queue is the answer.\nThe time complexity is $O(n + k \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array piles. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums containing positive integers.\nYour task is to minimize the length of nums by performing the following operations any number of times (including zero):\n\nSelect two distinct indices i and j from nums, such that nums[i] > 0 and nums[j] > 0.\nInsert the result of nums[i] % nums[j] at the end of nums.\nDelete the elements at indices i and j from nums.\n\nReturn an integer denoting the minimum length of nums after performing the operation any number of times.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,3,1]\nOutput: 1\nExplanation: One way to minimize the length of the array is as follows:\nOperation 1: Select indices 2 and 1, insert nums[2] % nums[1] at the end and it becomes [1,4,3,1,3], then delete elements at indices 2 and 1.\nnums becomes [1,1,3].\nOperation 2: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [1,1,3,1], then delete elements at indices 1 and 2.\nnums becomes [1,1].\nOperation 3: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [1,1,0], then delete elements at indices 1 and 0.\nnums becomes [0].\nThe length of nums cannot be reduced further. Hence, the answer is 1.\nIt can be shown that 1 is the minimum achievable length. \nExample 2:\n\nInput: nums = [5,5,5,10,5]\nOutput: 2\nExplanation: One way to minimize the length of the array is as follows:\nOperation 1: Select indices 0 and 3, insert nums[0] % nums[3] at the end and it becomes [5,5,5,10,5,5], then delete elements at indices 0 and 3.\nnums becomes [5,5,5,5]. \nOperation 2: Select indices 2 and 3, insert nums[2] % nums[3] at the end and it becomes [5,5,5,5,0], then delete elements at indices 2 and 3. \nnums becomes [5,5,0]. \nOperation 3: Select indices 0 and 1, insert nums[0] % nums[1] at the end and it becomes [5,5,0,0], then delete elements at indices 0 and 1.\nnums becomes [0,0].\nThe length of nums cannot be reduced further. Hence, the answer is 2.\nIt can be shown that 2 is the minimum achievable length. \nExample 3:\n\nInput: nums = [2,3,4]\nOutput: 1\nExplanation: One way to minimize the length of the array is as follows: \nOperation 1: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [2,3,4,3], then delete elements at indices 1 and 2.\nnums becomes [2,3].\nOperation 2: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [2,3,1], then delete elements at indices 1 and 0.\nnums becomes [1].\nThe length of nums cannot be reduced further. Hence, the answer is 1.\nIt can be shown that 1 is the minimum achievable length.\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Case Discussion\nLet's denote the smallest element in the array $nums$ as $mi$.\nIf $mi$ appears only once, we can perform operations with $mi$ and the other elements in the array $nums$ to eliminate all other elements, leaving only $mi$. The answer is $1$.\nIf $mi$ appears multiple times, we need to check whether all elements in the array $nums$ are multiples of $mi$. If not, there exists at least one element $x$ such that $0 < x \\bmod mi < mi$. This means we can construct an element smaller than $mi$ through operations. This smaller element can eliminate all other elements through operations, leaving only this smaller element. The answer is $1$. If all elements are multiples of $mi$, we can first use $mi$ to eliminate all elements larger than $mi$. The remaining elements are all $mi$, with a count of $cnt$. Pair them up, and perform an operation for each pair. Finally, there will be $\\lceil cnt / 2 \\rceil$ elements left, so the answer is $\\lceil cnt / 2 \\rceil$.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\n", "problem_ids": ["the-wording-game", "remove-stones-to-minimize-the-total", "minimize-length-of-array-using-operations"]}, "3044": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s and a character c. Return the total number of substrings of s that start and end with c.\n\u00a0\nExample 1:\n\nInput: s = \"abada\", c = \"a\"\nOutput: 6\nExplanation: Substrings starting and ending with \"a\" are: \"abada\", \"abada\", \"abada\", \"abada\", \"abada\", \"abada\".\n\nExample 2:\n\nInput: s = \"zzz\", c = \"z\"\nOutput: 6\nExplanation: There are a total of 6 substrings in s and all start and end with \"z\".\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns and c consist\u00a0only of lowercase English letters. Explanation:\n\nSolution 1: Mathematics\nFirst, we can count the number of character $c$ in string $s$, denoted as $cnt$.\nEach character $c$ can form a substring on its own, so there are $cnt$ substrings that meet the condition. Each character $c$ can form a substring with other $c$ characters, so there are $\\frac{cnt \\times (cnt - 1)}{2}$ substrings that meet the condition.\nTherefore, the answer is $cnt + \\frac{cnt \\times (cnt - 1)}{2}$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a string s, your task is to find the length of the longest self-contained substring of s.\nA substring t of a string s is called self-contained if t != s and for every character in t, it doesn't exist in the rest of s.\nReturn the length of the longest self-contained substring of s if it exists, otherwise, return -1.\n\u00a0\nExample 1:\n\nInput: s = \"abba\"\nOutput: 2\nExplanation:\nLet's check the substring \"bb\". You can see that no other \"b\" is outside of this substring. Hence the answer is 2.\n\nExample 2:\n\nInput: s = \"abab\"\nOutput: -1\nExplanation:\nEvery substring we choose does not satisfy the described property (there is some character which is inside and outside of that substring). So the answer would be -1.\n\nExample 3:\n\nInput: s = \"abacd\"\nOutput: 4\nExplanation:\nLet's check the substring \"abac\". There is only one character outside of this substring and that is \"d\". There is no \"d\" inside the chosen substring, so it satisfies the condition and the answer is 4.\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 5 * 104\ns consists only of lowercase English letters. Explanation:\n\nSolution 1: Enumeration\nWe notice that the start of a substring that meets the conditions must be the position where a character appears for the first time.\nTherefore, we can use two arrays or hash tables first and last to record the positions where each character appears for the first time and the last time, respectively.\nNext, we enumerate each character c. Suppose the position where c first appears is $i$, and the position where it last appears is $mx$. Then we can start traversing from $i$. For each position $j$, we find the position $a$ where $s[j]$ first appears and the position $b$ where it last appears. If $a < i$, it means that $s[j]$ is on the left of $c$, which does not meet the enumeration conditions, and we can exit the loop directly. Otherwise, we update $mx = \\max(mx, b)$. If $mx = j$ and $j - i + 1 < n$, we update the answer to $ans = \\max(ans, j - i + 1)$.\nFinally, return the answer.\nThe time complexity is $O(n \\times |\\Sigma|)$, and the space complexity is $O(|\\Sigma|)$. Where $n$ is the length of the string $s$; and $|\\Sigma|$ is the size of the character set. In this problem, the character set is lowercase letters, so $|\\Sigma| = 26$. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is a 2D grid of size n x n where each cell of this grid has a lamp that is initially turned off.\nYou are given a 2D array of lamp positions lamps, where lamps[i] = [rowi, coli] indicates that the lamp at grid[rowi][coli] is turned on. Even if the same lamp is listed more than once, it is turned on.\nWhen a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.\nYou are also given another 2D array queries, where queries[j] = [rowj, colj]. For the jth query, determine whether grid[rowj][colj] is illuminated or not. After answering the jth query, turn off the lamp at grid[rowj][colj] and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with grid[rowj][colj].\nReturn an array of integers ans, where ans[j] should be 1 if the cell in the jth query was illuminated, or 0 if the lamp was not.\n\u00a0\nExample 1:\n\n\nInput: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]\nOutput: [1,0]\nExplanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4].\nThe 0th\u00a0query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square.\n\nThe 1st\u00a0query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle.\n\n\nExample 2:\n\nInput: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]\nOutput: [1,1]\n\nExample 3:\n\nInput: n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]\nOutput: [1,1,0]\n\n\u00a0\nConstraints:\n\n1 <= n <= 109\n0 <= lamps.length <= 20000\n0 <= queries.length <= 20000\nlamps[i].length == 2\n0 <= rowi, coli < n\nqueries[j].length == 2\n0 <= rowj, colj < n Explanation:\n\nSolution 1: Hash Table\nSuppose the coordinates of a lamp are $(x, y)$. Then, the row value is $x$, the column value is $y$, the main diagonal value is $x-y$, and the anti-diagonal value is $x+y$. Once we determine the unique value identifier for a line, we can use a hash table to record the number of lamps on that line.\nWe traverse the array $\\textit{lamps}$, and for each lamp, we increment the count of lamps in its row, column, main diagonal, and anti-diagonal by $1$.\nNote that when processing $\\textit{lamps}$, we need to remove duplicates because we treat repeated lamps as the same lamp.\nNext, we traverse the queries and check if there are lamps in the row, column, main diagonal, or anti-diagonal of the current query point. If there are, we set the value to $1$, indicating that the point is illuminated during the query. Then, we perform the turn-off operation by checking the eight neighboring points of the query point and the point itself to see if there are any lamps. If there are, we decrement the count of lamps in the corresponding row, column, main diagonal, and anti-diagonal by $1$ and remove the lamp from the grid.\nFinally, we return the answer array.\nThe time complexity is $O(m + q)$, where $m$ and $q$ are the lengths of the arrays $\\textit{lamps}$ and $\\textit{queries}$, respectively. \n\n", "problem_ids": ["count-substrings-starting-and-ending-with-given-character", "find-longest-self-contained-substring", "grid-illumination"]}, "3045": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\nYou are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\nReturn the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.\n\u00a0\nExample 1:\n\n\nInput: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\nOutput: 7\nExplanation: One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\nExample 2:\n\n\nInput: grid = [[0,2,4],[3,2,1],[1,0,4]]\nOutput: -1\nExplanation: There is no path from the top left to the bottom-right cell.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n0 <= grid[i][j] <= 105\ngrid[0][0] == 0\n\n\u00a0 Explanation:\n\nSolution 1: Shortest Path + Priority Queue (Min Heap)\nWe observe that if we cannot move at the cell $(0, 0)$, i.e., $grid[0][1] > 1$ and $grid[1][0] > 1$, then we cannot move at the cell $(0, 0)$ anymore, and we should return $-1$. For other cases, we can move.\nNext, we define $dist[i][j]$ to represent the earliest arrival time at $(i, j)$. Initially, $dist[0][0] = 0$, and the $dist$ of other positions are all initialized to $\\infty$.\nWe use a priority queue (min heap) to maintain the cells that can currently move. The elements in the priority queue are $(dist[i][j], i, j)$, i.e., $(dist[i][j], i, j)$ represents the earliest arrival time at $(i, j)$.\nEach time we take out the cell $(t, i, j)$ that can arrive the earliest from the priority queue. If $(i, j)$ is $(m - 1, n - 1)$, then we directly return $t$. Otherwise, we traverse the four adjacent cells $(x, y)$ of $(i, j)$, which are up, down, left, and right. If $t + 1 < grid[x][y]$, then the time $nt = grid[x][y] + (grid[x][y] - (t + 1)) \\bmod 2$ to move to $(x, y)$. At this time, we can repeatedly move to extend the time to no less than $grid[x][y]$, depending on the parity of the distance between $t + 1$ and $grid[x][y]$. Otherwise, the time $nt = t + 1$ to move to $(x, y)$. If $nt < dist[x][y]$, then we update $dist[x][y] = nt$, and add $(nt, x, y)$ to the priority queue.\nThe time complexity is $O(m \\times n \\times \\log (m \\times n))$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows and columns of the grid, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an array nums consisting of positive integers where all integers have the same number of digits.\nThe digit difference between two integers is the count of different digits that are in the same position in the two integers.\nReturn the sum of the digit differences between all pairs of integers in nums.\n\u00a0\nExample 1:\n\nInput: nums = [13,23,12]\nOutput: 4\nExplanation:\nWe have the following:\n- The digit difference between 13 and 23 is 1.\n- The digit difference between 13 and 12 is 1.\n- The digit difference between 23 and 12 is 2.\nSo the total sum of digit differences between all pairs of integers is 1 + 1 + 2 = 4.\n\nExample 2:\n\nInput: nums = [10,10,10,10]\nOutput: 0\nExplanation:\nAll the integers in the array are the same. So the total sum of digit differences between all pairs of integers will be 0.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 105\n1 <= nums[i] < 109\nAll integers in nums have the same number of digits. Explanation:\n\nSolution 1: Counting\nFirst, we get the number of digits $m$ in the array. Then for each digit, we count the occurrence of each number at this digit in the array nums, denoted as cnt. Therefore, the sum of the digit differences of all number pairs at this digit is:\n$$\n\\sum_{v \\in \\textit{cnt}} v \\times (n - v)\n$$\nwhere $n$ is the length of the array. We add up the digit differences of all digits and divide by $2$ to get the answer.\nThe time complexity is $O(n \\times m)$, and the space complexity is $O(C)$, where $n$ and $m$ are the length of the array and the number of digits in the numbers, respectively; and $C$ is a constant, in this problem $C = 10$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met:\n\nEach element p[i][j] is calculated as the product of all elements in grid except for the element grid[i][j]. This product is then taken modulo 12345.\n\nReturn the product matrix of grid.\n\u00a0\nExample 1:\n\nInput: grid = [[1,2],[3,4]]\nOutput: [[24,12],[8,6]]\nExplanation: p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24\np[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12\np[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8\np[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6\nSo the answer is [[24,12],[8,6]].\nExample 2:\n\nInput: grid = [[12345],[2],[1]]\nOutput: [[2],[0],[0]]\nExplanation: p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2.\np[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0. So p[0][1] = 0.\np[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0. So p[0][2] = 0.\nSo the answer is [[2],[0],[0]].\n\u00a0\nConstraints:\n\n1 <= n == grid.length\u00a0<= 105\n1 <= m == grid[i].length\u00a0<= 105\n2 <= n * m <= 105\n1 <= grid[i][j] <= 109 Explanation:\n\nSolution 1: Prefix and Suffix Decomposition\nWe can preprocess the suffix product (excluding itself) of each element, and then traverse the matrix to calculate the prefix product (excluding itself) of each element. The product of the two gives us the result for each position.\nSpecifically, we use $p[i][j]$ to represent the result of the element in the $i$-th row and $j$-th column of the matrix. We define a variable $suf$ to represent the product of all elements below and to the right of the current position. Initially, $suf$ is set to $1$. We start traversing from the bottom right corner of the matrix. For each position $(i, j)$, we assign $suf$ to $p[i][j]$, and then update $suf$ to $suf \\times grid[i][j] \\bmod 12345$. This way, we can obtain the suffix product of each position.\nNext, we start traversing from the top left corner of the matrix. For each position $(i, j)$, we multiply $p[i][j]$ by $pre$, take the result modulo $12345$, and then update $pre$ to $pre \\times grid[i][j] \\bmod 12345$. This way, we can obtain the prefix product of each position.\nAfter the traversal, we return the result matrix $p$.\nThe time complexity is $O(n \\times m)$, where $n$ and $m$ are the number of rows and columns in the matrix, respectively. Ignoring the space occupied by the result matrix, the space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-time-to-visit-a-cell-in-a-grid", "sum-of-digit-differences-of-all-pairs", "construct-product-matrix"]}, "3046": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a 0-indexed integer array nums, determine whether there exist two subarrays of length 2 with equal sum. Note that the two subarrays must begin at different indices.\nReturn true if these subarrays exist, and false otherwise.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nExample 1:\n\nInput: nums = [4,2,4]\nOutput: true\nExplanation: The subarrays with elements [4,2] and [2,4] have the same sum of 6.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: false\nExplanation: No two subarrays of size 2 have the same sum.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: true\nExplanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. \nNote that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 1000\n-109 <= nums[i] <= 109 Explanation:\n\nSolution 1: Hash Table\nWe can traverse the array $nums$, and use a hash table $vis$ to record the sum of every two adjacent elements in the array. If the sum of the current two elements has already appeared in the hash table, then return true. Otherwise, add the sum of the current two elements to the hash table.\nIf we finish traversing and haven't found two subarrays that meet the condition, return false.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an n-ary tree, return the level order traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n\u00a0\nExample 1:\n\n\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [[1],[3,2,4],[5,6]]\n\nExample 2:\n\n\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n\n\u00a0\nConstraints:\n\nThe height of the n-ary tree is less than or equal to 1000\nThe total number of nodes is between [0, 104] Explanation:\n\nSolution 1: BFS\nFirst, we check if the root node is null. If it is, we return an empty list directly.\nOtherwise, we create a queue $q$ and initially add the root node to the queue.\nWhen the queue is not empty, we loop through the following operations:\n\nCreate an empty list $t$ to store the values of the current level nodes.\nFor each node in the queue, add its value to $t$ and add its child nodes to the queue.\nAdd $t$ to the result list $ans$.\n\nFinally, return the result list $ans$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the N-ary tree. \n\nSimilar Problem 3 \n\n Problem:\n\nThere are m boys and n girls in a class attending an upcoming party.\nYou are given an m x n integer matrix grid, where grid[i][j] equals 0 or 1. If grid[i][j] == 1, then that means the ith boy can invite the jth girl to the party. A boy can invite at most one girl, and a girl can accept at most one invitation from a boy.\nReturn the maximum possible number of accepted invitations.\n\u00a0\nExample 1:\n\nInput: grid = [[1,1,1],\n               [1,0,1],\n               [0,0,1]]\nOutput: 3\nExplanation: The invitations are sent as follows:\n- The 1st boy invites the 2nd girl.\n- The 2nd boy invites the 1st girl.\n- The 3rd boy invites the 3rd girl.\nExample 2:\n\nInput: grid = [[1,0,1,0],\n               [1,0,0,0],\n               [0,0,1,0],\n               [1,1,1,0]]\nOutput: 3\nExplanation: The invitations are sent as follows:\n-The 1st boy invites the 3rd girl.\n-The 2nd boy invites the 1st girl.\n-The 3rd boy invites no one.\n-The 4th boy invites the 2nd girl.\n\u00a0\nConstraints:\n\ngrid.length == m\ngrid[i].length == n\n1 <= m, n <= 200\ngrid[i][j] is either 0 or 1. Explanation:\n\nSolution 1: Hungarian Algorithm\nThis problem belongs to the maximum matching problem of bipartite graphs, which is suitable for solving with the Hungarian algorithm.\nThe core idea of the Hungarian algorithm is to continuously start from unmatched points, look for augmenting paths, and stop when there are no augmenting paths. This gives the maximum match.\nThe time complexity is $O(m \\times n)$. \n\n", "problem_ids": ["find-subarrays-with-equal-sum", "n-ary-tree-level-order-traversal", "maximum-number-of-accepted-invitations"]}, "3047": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums containing positive integers.\nYour task is to minimize the length of nums by performing the following operations any number of times (including zero):\n\nSelect two distinct indices i and j from nums, such that nums[i] > 0 and nums[j] > 0.\nInsert the result of nums[i] % nums[j] at the end of nums.\nDelete the elements at indices i and j from nums.\n\nReturn an integer denoting the minimum length of nums after performing the operation any number of times.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,3,1]\nOutput: 1\nExplanation: One way to minimize the length of the array is as follows:\nOperation 1: Select indices 2 and 1, insert nums[2] % nums[1] at the end and it becomes [1,4,3,1,3], then delete elements at indices 2 and 1.\nnums becomes [1,1,3].\nOperation 2: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [1,1,3,1], then delete elements at indices 1 and 2.\nnums becomes [1,1].\nOperation 3: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [1,1,0], then delete elements at indices 1 and 0.\nnums becomes [0].\nThe length of nums cannot be reduced further. Hence, the answer is 1.\nIt can be shown that 1 is the minimum achievable length. \nExample 2:\n\nInput: nums = [5,5,5,10,5]\nOutput: 2\nExplanation: One way to minimize the length of the array is as follows:\nOperation 1: Select indices 0 and 3, insert nums[0] % nums[3] at the end and it becomes [5,5,5,10,5,5], then delete elements at indices 0 and 3.\nnums becomes [5,5,5,5]. \nOperation 2: Select indices 2 and 3, insert nums[2] % nums[3] at the end and it becomes [5,5,5,5,0], then delete elements at indices 2 and 3. \nnums becomes [5,5,0]. \nOperation 3: Select indices 0 and 1, insert nums[0] % nums[1] at the end and it becomes [5,5,0,0], then delete elements at indices 0 and 1.\nnums becomes [0,0].\nThe length of nums cannot be reduced further. Hence, the answer is 2.\nIt can be shown that 2 is the minimum achievable length. \nExample 3:\n\nInput: nums = [2,3,4]\nOutput: 1\nExplanation: One way to minimize the length of the array is as follows: \nOperation 1: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [2,3,4,3], then delete elements at indices 1 and 2.\nnums becomes [2,3].\nOperation 2: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [2,3,1], then delete elements at indices 1 and 0.\nnums becomes [1].\nThe length of nums cannot be reduced further. Hence, the answer is 1.\nIt can be shown that 1 is the minimum achievable length.\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Case Discussion\nLet's denote the smallest element in the array $nums$ as $mi$.\nIf $mi$ appears only once, we can perform operations with $mi$ and the other elements in the array $nums$ to eliminate all other elements, leaving only $mi$. The answer is $1$.\nIf $mi$ appears multiple times, we need to check whether all elements in the array $nums$ are multiples of $mi$. If not, there exists at least one element $x$ such that $0 < x \\bmod mi < mi$. This means we can construct an element smaller than $mi$ through operations. This smaller element can eliminate all other elements through operations, leaving only this smaller element. The answer is $1$. If all elements are multiples of $mi$, we can first use $mi$ to eliminate all elements larger than $mi$. The remaining elements are all $mi$, with a count of $cnt$. Pair them up, and perform an operation for each pair. Finally, there will be $\\lceil cnt / 2 \\rceil$ elements left, so the answer is $\\lceil cnt / 2 \\rceil$.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.\n\n\u00a0\nExample 1:\nInput: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]\n\nExample 2:\nInput: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n\nExample 3:\nInput: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n\n\u00a0\nConstraints:\n\n1 <= n <= 104 Explanation:\n\nSolution 1: Simulation\nWe iterate through each integer from 1 to $n$. For each integer, we check whether it is a multiple of both 3 and 5, or just a multiple of 3, or just a multiple of 5. Based on the check result, we add the corresponding string to the answer array.\nThe time complexity is $O(n)$, where $n$ is the integer given in the problem. Ignoring the space consumption of the answer array, the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums, an integer array queries, and an integer x.\nFor each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query.\nReturn an integer array answer containing the answers to all queries.\n\u00a0\nExample 1:\n\nInput: nums = [1,3,1,7], queries = [1,3,2,4], x = 1\nOutput: [0,-1,2,-1]\nExplanation:\n\nFor the 1st query, the first occurrence of 1 is at index 0.\nFor the 2nd query, there are only two occurrences of 1 in nums, so the answer is -1.\nFor the 3rd query, the second occurrence of 1 is at index 2.\nFor the 4th query, there are only two occurrences of 1 in nums, so the answer is -1.\n\n\nExample 2:\n\nInput: nums = [1,2,3], queries = [10], x = 5\nOutput: [-1]\nExplanation:\n\nFor the 1st query, 5 doesn't exist in nums, so the answer is -1.\n\n\n\u00a0\nConstraints:\n\n1 <= nums.length, queries.length <= 105\n1 <= queries[i] <= 105\n1 <= nums[i], x <= 104 Explanation:\n\nSolution 1: Simulation\nAccording to the problem description, we can first traverse the array nums to find the indices of all elements with a value of $x$, and record them in the array ids.\nNext, we traverse the array queries. For each query $i$, if $i - 1$ is less than the length of ids, then the answer is ids[i - 1], otherwise, the answer is $-1$.\nThe time complexity is $O(n + m)$, and the space complexity is $O(n + m)$. Where $n$ and $m$ are the lengths of the arrays nums and queries respectively. \n\n", "problem_ids": ["minimize-length-of-array-using-operations", "fizz-buzz", "find-occurrences-of-an-element-in-an-array"]}, "3055": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two 0-indexed integer arrays, nums1 and nums2, both having length n.\nYou are allowed to perform a series of operations (possibly none).\nIn an operation, you select an index i in the range [0, n - 1] and swap the values of nums1[i] and nums2[i].\nYour task is to find the minimum number of operations required to satisfy the following conditions:\n\nnums1[n - 1] is equal to the maximum value among all elements of nums1, i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]).\nnums2[n - 1] is equal to the maximum value among all elements of nums2, i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]).\n\nReturn an integer denoting the minimum number of operations needed to meet both conditions, or -1 if it is impossible to satisfy both conditions.\n\u00a0\nExample 1:\n\nInput: nums1 = [1,2,7], nums2 = [4,5,3]\nOutput: 1\nExplanation: In this example, an operation can be performed using index i = 2.\nWhen nums1[2] and nums2[2] are swapped, nums1 becomes [1,2,3] and nums2 becomes [4,5,7].\nBoth conditions are now satisfied.\nIt can be shown that the minimum number of operations needed to be performed is 1.\nSo, the answer is 1.\n\nExample 2:\n\nInput: nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]\nOutput: 2\nExplanation: In this example, the following operations can be performed:\nFirst operation using index i = 4.\nWhen nums1[4] and nums2[4] are swapped, nums1 becomes [2,3,4,5,4], and nums2 becomes [8,8,4,4,9].\nAnother operation using index i = 3.\nWhen nums1[3] and nums2[3] are swapped, nums1 becomes [2,3,4,4,4], and nums2 becomes [8,8,4,5,9].\nBoth conditions are now satisfied.\nIt can be shown that the minimum number of operations needed to be performed is 2.\nSo, the answer is 2.   \n\nExample 3:\n\nInput: nums1 = [1,5,4], nums2 = [2,5,3]\nOutput: -1\nExplanation: In this example, it is not possible to satisfy both conditions. \nSo, the answer is -1.\n\n\u00a0\nConstraints:\n\n1 <= n == nums1.length == nums2.length <= 1000\n1 <= nums1[i] <= 109\n1 <= nums2[i] <= 109 Explanation:\n\nSolution 1: Case Discussion + Greedy\nWe can discuss two cases:\n\nDo not swap the values of $nums1[n - 1]$ and $nums2[n - 1]$\nSwap the values of $nums1[n - 1]$ and $nums2[n - 1]$\n\nFor each case, we denote the last values of the arrays $nums1$ and $nums2$ as $x$ and $y$, respectively. Then we traverse the first $n - 1$ values of the arrays $nums1$ and $nums2$, and use a variable $cnt$ to record the number of swaps. If $nums1[i] \\leq x$ and $nums2[i] \\leq y$, then no swap is needed. Otherwise, if $nums1[i] \\leq y$ and $nums2[i] \\leq x$, then a swap is needed. If neither condition is met, return $-1$. Finally, return $cnt$.\nWe denote the number of swaps in the two cases as $a$ and $b$, respectively. If $a + b = -2$, then it is impossible to satisfy both conditions, so return $-1$. Otherwise, return $\\min(a, b + 1)$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an array nums, return the maximum value of a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k].\nThe value of a triplet (i, j, k) is nums[i] - nums[j] + nums[k].\n\n \n\n\u00a0\nExample 1: \n\nInput:  nums = [5,6,9] \nOutput:  8 \nExplanation:  We only have one choice for an increasing triplet and that is choosing all three elements. The value of this triplet would be 5 - 6 + 9 = 8.\n\nExample 2: \n\nInput:  nums = [1,5,3,6] \nOutput:  4 \nExplanation:  There are only two increasing triplets:\n(0, 1, 3): The value of this triplet is nums[0] - nums[1] + nums[3] = 1 - 5 + 6 = 2.\n(0, 2, 3): The value of this triplet is nums[0] - nums[2] + nums[3] = 1 - 3 + 6 = 4.\nThus the answer would be 4.\n\n\u00a0\nConstraints:\n\n3 <= nums.length <= 105\n1 <= nums[i] <= 109\nThe input is generated such that at least one triplet meets the given condition. Explanation:\n\nSolution 1: Suffix Maximum + Ordered Set\nWe can consider enumerating $nums[j]$. Then, we need to find the largest $nums[i]$ on the left of $j$ such that $nums[i] < nums[j]$, and find the largest $nums[k]$ on the right of $j$ such that $nums[k] > nums[j]$.\nTherefore, we can preprocess an array $right$, where $right[i]$ represents the maximum value to the right of $nums[i]$. Then, we can use an ordered set to maintain the values on the left of $nums[j]$, so that we can find the largest $nums[i]$ less than $nums[j]$ in $O(\\log n)$ time.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\nReturn the minimum possible difference.\n\u00a0\nExample 1:\n\nInput: nums = [90], k = 1\nOutput: 0\nExplanation: There is one way to pick score(s) of one student:\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\n\nExample 2:\n\nInput: nums = [9,4,1,7], k = 2\nOutput: 2\nExplanation: There are six ways to pick score(s) of two students:\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 1000\n0 <= nums[i] <= 105 Explanation:\n\nSolution 1: Sorting + Sliding Window\nWe can sort the students' scores in ascending order, then use a sliding window of size $k$ to calculate the difference between the maximum and minimum values in the window, and finally take the minimum of the differences of all windows.\nWhy do we take the scores of $k$ consecutive students? Because if they are not consecutive, the difference between the maximum and minimum values may remain the same or increase, but it will definitely not decrease. Therefore, we only need to consider the scores of $k$ consecutive students after sorting.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the number of students. \n\n", "problem_ids": ["minimum-operations-to-maximize-last-elements-in-arrays", "maximum-increasing-triplet-value", "minimum-difference-between-highest-and-lowest-of-k-scores"]}, "3080": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two positive integers low and high.\nAn integer x consisting of 2 * n digits is symmetric if the sum of the first n digits of x is equal to the sum of the last n digits of x. Numbers with an odd number of digits are never symmetric.\nReturn the number of symmetric integers in the range [low, high].\n\u00a0\nExample 1:\n\nInput: low = 1, high = 100\nOutput: 9\nExplanation: There are 9 symmetric integers between 1 and 100: 11, 22, 33, 44, 55, 66, 77, 88, and 99.\n\nExample 2:\n\nInput: low = 1200, high = 1230\nOutput: 4\nExplanation: There are 4 symmetric integers between 1200 and 1230: 1203, 1212, 1221, and 1230.\n\n\u00a0\nConstraints:\n\n1 <= low <= high <= 104 Explanation:\n\nSolution 1: Enumeration\nWe enumerate each integer $x$ in the range $[low, high]$, and check whether it is a palindromic number. If it is, then the answer $ans$ is increased by $1$.\nThe time complexity is $O(n \\times \\log m)$, and the space complexity is $O(\\log m)$. Here, $n$ is the number of integers in the range $[low, high]$, and $m$ is the maximum integer given in the problem. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two positive integers n and limit.\nReturn the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.\n\u00a0\nExample 1:\n\nInput: n = 5, limit = 2\nOutput: 3\nExplanation: There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).\n\nExample 2:\n\nInput: n = 3, limit = 3\nOutput: 10\nExplanation: There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).\n\n\u00a0\nConstraints:\n\n1 <= n <= 106\n1 <= limit <= 106 Explanation:\n\nSolution 1: Combinatorial Mathematics + Principle of Inclusion-Exclusion\nAccording to the problem description, we need to distribute $n$ candies to $3$ children, with each child receiving between $[0, limit]$ candies.\nThis is equivalent to placing $n$ balls into $3$ boxes. Since the boxes can be empty, we can add $3$ virtual balls, and then use the method of inserting partitions, i.e., there are a total of $n + 3$ balls, and we insert $2$ partitions among the $n + 3 - 1$ positions, thus dividing the actual $n$ balls into $3$ groups, and allowing the boxes to be empty. Therefore, the initial number of schemes is $C_{n + 2}^2$.\nWe need to exclude the schemes where the number of balls in a box exceeds $limit$. Consider that there is a box where the number of balls exceeds $limit$, then the remaining balls (including virtual balls) have at most $n + 3 - (limit + 1) = n - limit + 2$, and the number of positions is $n - limit + 1$, so the number of schemes is $C_{n - limit + 1}^2$. Since there are $3$ boxes, the number of such schemes is $3 \\times C_{n - limit + 1}^2$. In this way, we will exclude too many schemes where the number of balls in two boxes exceeds $limit$ at the same time, so we need to add the number of such schemes, i.e., $3 \\times C_{n - 2 \\times limit}^2$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nA competition consists of n players numbered from 0 to n - 1.\nYou are given an integer array skills of size n and a positive integer k, where skills[i] is the skill level of player i. All integers in skills are unique.\nAll players are standing in a queue in order from player 0 to player n - 1.\nThe competition process is as follows:\n\nThe first two players in the queue play a game, and the player with the higher skill level wins.\nAfter the game, the winner stays at the beginning of the queue, and the loser goes to the end of it.\n\nThe winner of the competition is the first player who wins k games in a row.\nReturn the initial index of the winning player.\n\u00a0\nExample 1:\n\nInput: skills = [4,2,6,3,9], k = 2\nOutput: 2\nExplanation:\nInitially, the queue of players is [0,1,2,3,4]. The following process happens:\n\nPlayers 0 and 1 play a game, since the skill of player 0 is higher than that of player 1, player 0 wins. The resulting queue is [0,2,3,4,1].\nPlayers 0 and 2 play a game, since the skill of player 2 is higher than that of player 0, player 2 wins. The resulting queue is [2,3,4,1,0].\nPlayers 2 and 3 play a game, since the skill of player 2 is higher than that of player 3, player 2 wins. The resulting queue is [2,4,1,0,3].\n\nPlayer 2 won k = 2 games in a row, so the winner is player 2.\n\nExample 2:\n\nInput: skills = [2,5,4], k = 3\nOutput: 1\nExplanation:\nInitially, the queue of players is [0,1,2]. The following process happens:\n\nPlayers 0 and 1 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].\nPlayers 1 and 2 play a game, since the skill of player 1 is higher than that of player 2, player 1 wins. The resulting queue is [1,0,2].\nPlayers 1 and 0 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].\n\nPlayer 1 won k = 3 games in a row, so the winner is player 1.\n\n\u00a0\nConstraints:\n\nn == skills.length\n2 <= n <= 105\n1 <= k <= 109\n1 <= skills[i] <= 106\nAll integers in skills are unique. Explanation:\n\nSolution 1: Quick Thinking\nWe notice that each time the first two elements of the array are compared, regardless of the result, the next comparison will always be between the next element in the array and the current winner. Therefore, if we have looped $n-1$ times, the final winner must be the maximum element in the array. Otherwise, if an element has won consecutively $k$ times, then this element is the final winner.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.\nSimilar problems:\n\n1535. Find the Winner of an Array Game \n\n", "problem_ids": ["count-symmetric-integers", "distribute-candies-among-children-ii", "find-the-first-player-to-win-k-games-in-a-row"]}, "3081": {"text": "Similar Problem 1 \n\n Problem:\n\nDesign a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.\nImplement the TwoSum class:\n\nTwoSum() Initializes the TwoSum object, with an empty array initially.\nvoid add(int number) Adds number to the data structure.\nboolean find(int value) Returns true if there exists any pair of numbers whose sum is equal to value, otherwise, it returns false.\n\n\u00a0\nExample 1:\n\nInput\n[\"TwoSum\", \"add\", \"add\", \"add\", \"find\", \"find\"]\n[[], [1], [3], [5], [4], [7]]\nOutput\n[null, null, null, null, true, false]\n\nExplanation\nTwoSum twoSum = new TwoSum();\ntwoSum.add(1);   // [] --> [1]\ntwoSum.add(3);   // [1] --> [1,3]\ntwoSum.add(5);   // [1,3] --> [1,3,5]\ntwoSum.find(4);  // 1 + 3 = 4, return true\ntwoSum.find(7);  // No two integers sum up to 7, return false\n\n\u00a0\nConstraints:\n\n-105 <= number <= 105\n-231 <= value <= 231 - 1\nAt most 104 calls will be made to add and find. Explanation:\n\nSolution 1: Hash Table\nWe use a hash table cnt to store the count of each number.\nWhen the add method is called, we increment the count of the number number.\nWhen the find method is called, we iterate over the hash table cnt. For each key x, we check if value - x is also a key in the hash table cnt. If it is, we check if x is equal to value - x. If they are not equal, it means we have found a pair of numbers whose sum is value, and we return true. If they are equal, we check if the count of x is greater than 1. If it is, it means we have found a pair of numbers whose sum is value, and we return true. If it is less than or equal to 1, it means we have not found a pair of numbers whose sum is value, and we continue to iterate over the hash table cnt. If we have not found a pair after the iteration, we return false.\nTime complexity:\n\nThe time complexity of the add method is $O(1)$.\nThe time complexity of the find method is $O(n)$.\n\nSpace complexity is $O(n)$, where $n$ is the size of the hash table cnt. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\n\u00a0\nExample 1:\n\n\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n\nExample 2:\n\n\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\u00a0\nConstraints:\n\nm == matrix.length\nn == matrix[0].length\n1 <= m, n <= 200\n-231 <= matrix[i][j] <= 231 - 1\n\n\u00a0\nFollow up:\n\nA straightforward solution using O(mn) space is probably a bad idea.\nA simple improvement uses O(m + n) space, but still not the best solution.\nCould you devise a constant space solution? Explanation:\n\nSolution 1: Array Mark\nWe use arrays rows and cols to mark the rows and columns to be cleared.\nThen traverse the matrix again, and clear the elements in the rows and columns marked in rows and cols.\nThe time complexity is $O(m\\times n)$, and the space complexity is $O(m+n)$. Where $m$ and $n$ are the number of rows and columns of the matrix respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.\n\n\u00a0\nExample 1:\nInput: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]\n\nExample 2:\nInput: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n\nExample 3:\nInput: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n\n\u00a0\nConstraints:\n\n1 <= n <= 104 Explanation:\n\nSolution 1: Simulation\nWe iterate through each integer from 1 to $n$. For each integer, we check whether it is a multiple of both 3 and 5, or just a multiple of 3, or just a multiple of 5. Based on the check result, we add the corresponding string to the answer array.\nThe time complexity is $O(n)$, where $n$ is the integer given in the problem. Ignoring the space consumption of the answer array, the space complexity is $O(1)$. \n\n", "problem_ids": ["two-sum-iii---data-structure-design", "set-matrix-zeroes", "fizz-buzz"]}, "3091": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and an integer k.\nYou can perform the following operation on the array at most k times:\n\nChoose any index i from the array and increase or decrease nums[i] by 1.\n\nThe score of the final array is the frequency of the most frequent element in the array.\nReturn the maximum score you can achieve.\nThe frequency of an element is the number of occurences of that element in the array.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,6,4], k = 3\nOutput: 3\nExplanation: We can do the following operations on the array:\n- Choose i = 0, and increase the value of nums[0] by 1. The resulting array is [2,2,6,4].\n- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,3].\n- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,2].\nThe element 2 is the most frequent in the final array so our score is 3.\nIt can be shown that we cannot achieve a better score.\n\nExample 2:\n\nInput: nums = [1,4,4,2,4], k = 0\nOutput: 3\nExplanation: We cannot apply any operations so our score will be the frequency of the most frequent element in the original array, which is 3.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= k <= 1014 Explanation:\n\nSolution 1: Sorting + Prefix Sum + Binary Search\nThe problem asks for the maximum frequency of the mode we can get after performing at most $k$ operations. If we sort the array $nums$ in ascending order, it would be best to turn a continuous segment of numbers into the same number, which can reduce the number of operations and increase the frequency of the mode.\nTherefore, we might as well sort the array $nums$ first.\nNext, we analyze that if a frequency $x$ is feasible, then for any $y \\le x$, the frequency $y$ is also feasible, which shows monotonicity. Therefore, we can use binary search to find the maximum feasible frequency.\nWe binary search the frequency, define the left boundary of the binary search as $l = 0$, and the right boundary as $r = n$, where $n$ is the length of the array. In each binary search process, we take the middle value $mid = \\lfloor \\frac{l + r + 1}{2} \\rfloor$, and then determine whether there exists a continuous subarray of length $mid$ in $nums$, such that all elements in this subarray become the median of this subarray, and the number of operations does not exceed $k$. If it exists, then we update the left boundary $l$ to $mid$, otherwise we update the right boundary $r$ to $mid - 1$.\nTo determine whether such a subarray exists, we can use prefix sum. We first define two pointers $i$ and $j$, initially $i = 0$, $j = i + mid$. Then all elements from $nums[i]$ to $nums[j - 1]$ are changed to $nums[(i + j) / 2]$, and the number of operations required is $left + right$, where:\n$$\n\\begin{aligned}\n\\textit{left} &= \\sum_{k = i}^{(i + j) / 2 - 1} (nums[(i + j) / 2] - nums[k]) \\\n&= ((i + j) / 2 - i) \\times nums[(i + j) / 2] - \\sum_{k = i}^{(i + j) / 2 - 1} nums[k]\n\\end{aligned}\n$$\n$$\n\\begin{aligned}\n\\textit{right} &= \\sum_{k = (i + j) / 2 + 1}^{j} (nums[k] - nums[(i + j) / 2]) \\\n&= \\sum_{k = (i + j) / 2 + 1}^{j} nums[k] - (j - (i + j) / 2) \\times nums[(i + j) / 2]\n\\end{aligned}\n$$\nWe can use the prefix sum array $s$ to calculate $\\sum_{k = i}^{j} nums[k]$, so as to calculate $left$ and $right$ in $O(1)$ time.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given the head of a linked list of even length containing integers.\nEach odd-indexed node contains an odd integer and each even-indexed node contains an even integer.\nWe call each even-indexed node and its next node a pair, e.g., the nodes with indices 0 and 1 are a pair, the nodes with indices 2 and 3 are a pair, and so on.\nFor every pair, we compare the values of the nodes in the pair:\n\nIf the odd-indexed node is higher, the \"Odd\" team gets a point.\nIf the even-indexed node is higher, the \"Even\" team gets a point.\n\nReturn the name of the team with the higher points, if the points are equal, return \"Tie\".\n\u00a0\nExample 1: \n\nInput:   head = [2,1] \nOutput:   \"Even\" \nExplanation:  There is only one pair in this linked list and that is (2,1). Since 2 > 1, the Even team gets the point.\nHence, the answer would be \"Even\".\n\nExample 2: \n\nInput:   head = [2,5,4,7,20,5] \nOutput:   \"Odd\" \nExplanation:  There are 3 pairs in this linked list. Let's investigate each pair individually:\n(2,5) -> Since 2 < 5, The Odd team gets the point.\n(4,7) -> Since 4 < 7, The Odd team gets the point.\n(20,5) -> Since 20 > 5, The Even team gets the point.\nThe Odd team earned 2 points while the Even team got 1 point and the Odd team has the higher points.\nHence, the answer would be \"Odd\".\n\nExample 3: \n\nInput:   head = [4,5,2,1] \nOutput:   \"Tie\" \nExplanation:  There are 2 pairs in this linked list. Let's investigate each pair individually:\n(4,5) -> Since 4 < 5, the Odd team gets the point.\n(2,1) -> Since 2 > 1, the Even team gets the point.\nBoth teams earned 1 point.\nHence, the answer would be \"Tie\".\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is in the range [2, 100].\nThe number of nodes in the list is even.\n1 <= Node.val <= 100\nThe value of each odd-indexed node is odd.\nThe value of each even-indexed node is even. Explanation:\n\nSolution 1: Simulation\nTraverse the linked list, each time taking out two nodes, compare their values, and then update the scores of odd and even numbers based on the comparison results. Finally, compare the scores of odd and even numbers and return the result.\nThe time complexity is $O(n)$, where $n$ is the length of the linked list. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest.\n\u00a0\nExample 1:\n\n\nInput: root = [4,2,5,1,3], target = 3.714286\nOutput: 4\n\nExample 2:\n\nInput: root = [1], target = 4.428571\nOutput: 1\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 104].\n0 <= Node.val <= 109\n-109 <= target <= 109 Explanation:\n\nSolution 1: Recursion\nWe define a recursive function dfs(node), which starts from the current node node and finds the node closest to the target value target. We can update the answer by comparing the absolute difference between the current node's value and the target value. If the target value is less than the current node's value, we recursively search the left subtree; otherwise, we recursively search the right subtree.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the binary search tree. \n\n", "problem_ids": ["apply-operations-to-maximize-frequency-score", "winner-of-the-linked-list-game", "closest-binary-search-tree-value"]}, "3093": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and an integer x.\nFind the minimum absolute difference between two elements in the array that are at least x indices apart.\nIn other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.\nReturn an integer denoting the minimum absolute difference between two elements that are at least x indices apart.\n\u00a0\nExample 1:\n\nInput: nums = [4,3,2,4], x = 2\nOutput: 0\nExplanation: We can select nums[0] = 4 and nums[3] = 4. \nThey are at least 2 indices apart, and their absolute difference is the minimum, 0. \nIt can be shown that 0 is the optimal answer.\n\nExample 2:\n\nInput: nums = [5,3,2,10,15], x = 1\nOutput: 1\nExplanation: We can select nums[1] = 3 and nums[2] = 2.\nThey are at least 1 index apart, and their absolute difference is the minimum, 1.\nIt can be shown that 1 is the optimal answer.\n\nExample 3:\n\nInput: nums = [1,2,3,4], x = 3\nOutput: 3\nExplanation: We can select nums[0] = 1 and nums[3] = 4.\nThey are at least 3 indices apart, and their absolute difference is the minimum, 3.\nIt can be shown that 3 is the optimal answer.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= x < nums.length Explanation:\n\nSolution 1: Ordered Set\nWe create an ordered set to store the elements whose distance to the current index is at least $x$.\nNext, we enumerate from index $i = x$, each time we add $nums[i - x]$ into the ordered set. Then we find the two elements in the ordered set which are closest to $nums[i]$, and the minimum absolute difference between them is the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and\u00a0it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\nExample 2:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 3\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000 Explanation:\n\nSolution 1: Dynamic Programming\nThe circular arrangement means that at most one of the first and last houses can be chosen for theft, so this circular arrangement problem can be reduced to two single-row house problems.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the root of a binary tree, return the sum of all left leaves.\nA leaf is a node with no children. A left leaf is a leaf that is the left child of another node.\n\u00a0\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 24\nExplanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.\n\nExample 2:\n\nInput: root = [1]\nOutput: 0\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\n-1000 <= Node.val <= 1000 Explanation:\n\nSolution 1: Recursion\nFirst, we check if root is null. If it is, we return $0$.\nOtherwise, we recursively call the sumOfLeftLeaves function to calculate the sum of all left leaves in root's right subtree, and assign the result to the answer variable $ans$. Then we check if root's left child exists. If it does, we check if it is a leaf node. If it is a leaf node, we add its value to the answer variable $ans$. Otherwise, we recursively call the sumOfLeftLeaves function to calculate the sum of all left leaves in root's left subtree, and add the result to the answer variable $ans$.\nFinally, we return the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["minimum-absolute-difference-between-elements-with-constraint", "house-robber-ii", "sum-of-left-leaves"]}, "3094": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two integers n and k.\nInitially, you start with an array a of n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you simultaneously update each element to be the sum of all its preceding elements plus the element itself. For example, after one second, a[0] remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2], and so on.\nReturn the value of a[n - 1] after k seconds.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: n = 4, k = 5\nOutput: 56\nExplanation:\n\n\n\nSecond\nState After\n\n\n0\n[1,1,1,1]\n\n\n1\n[1,2,3,4]\n\n\n2\n[1,3,6,10]\n\n\n3\n[1,4,10,20]\n\n\n4\n[1,5,15,35]\n\n\n5\n[1,6,21,56]\n\n\n\n\nExample 2:\n\nInput: n = 5, k = 3\nOutput: 35\nExplanation:\n\n\n\nSecond\nState After\n\n\n0\n[1,1,1,1,1]\n\n\n1\n[1,2,3,4,5]\n\n\n2\n[1,3,6,10,15]\n\n\n3\n[1,4,10,20,35]\n\n\n\n\n\u00a0\nConstraints:\n\n1 <= n, k <= 1000 Explanation:\n\nSolution 1: Simulation\nWe notice that the range of the integer $n$ is $1 \\leq n \\leq 1000$, so we can directly simulate this process.\nWe define an array $a$ of length $n$ and initialize all elements to $1$. Then we simulate the process for $k$ seconds, updating the elements of array $a$ every second until $k$ seconds have passed.\nFinally, we return $a[n - 1]$.\nThe time complexity is $O(n \\times k)$, and the space complexity is $O(n)$. Where $n$ is the length of the array $a$. \n\nSimilar Problem 2 \n\n Problem:\n\nAlice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them.\nThe game proceeds as follows:\n\nAlice takes the first turn.\nIn each turn, a player must choose either the clockwise or anti-clockwise direction and pick one flower from that side.\nAt the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.\n\nGiven two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:\n\nAlice must win the game according to the described rules.\nThe number of flowers x in the clockwise direction must be in the range [1,n].\nThe number of flowers y in the anti-clockwise direction must be in the range [1,m].\n\nReturn the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.\n\u00a0\nExample 1:\n\nInput: n = 3, m = 2\nOutput: 3\nExplanation: The following pairs satisfy conditions described in the statement: (1,2), (3,2), (2,1).\n\nExample 2:\n\nInput: n = 1, m = 1\nOutput: 0\nExplanation: No pairs satisfy the conditions described in the statement.\n\n\u00a0\nConstraints:\n\n1 <= n, m <= 105 Explanation:\n\nSolution 1: Mathematics\nAccording to the problem description, in each move, the player will choose to move in a clockwise or counterclockwise direction and then pick a flower. Since Alice moves first, when $x + y$ is odd, Alice will definitely win the game.\nTherefore, the number of flowers $x$ and $y$ meet the following conditions:\n\n$x + y$ is odd;\n$1 \\le x \\le n$;\n$1 \\le y \\le m$.\n\nIf $x$ is odd, $y$ must be even. At this time, the number of values of $x$ is $\\lceil \\frac{n}{2} \\rceil$, the number of values of $y$ is $\\lfloor \\frac{m}{2} \\rfloor$, so the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor$.\nIf $x$ is even, $y$ must be odd. At this time, the number of values of $x$ is $\\lfloor \\frac{n}{2} \\rfloor$, the number of values of $y$ is $\\lceil \\frac{m}{2} \\rceil$, so the number of pairs that meet the conditions is $\\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$.\nTherefore, the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$, which is $\\lfloor \\frac{n + 1}{2} \\rfloor \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lfloor \\frac{m + 1}{2} \\rfloor$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two 0-indexed integer arrays nums1 and nums2 of the same length. A pair of indices (i,j) is called beautiful if|nums1[i] - nums1[j]| + |nums2[i] - nums2[j]| is the smallest amongst all possible indices pairs where i < j.\nReturn the beautiful pair. In the case that there are multiple beautiful pairs, return the lexicographically smallest pair.\nNote that\n\n|x| denotes the absolute value of x.\nA pair of indices (i1, j1) is lexicographically smaller than (i2, j2) if i1 < i2 or i1 == i2 and j1 < j2.\n\n\u00a0\nExample 1:\n\nInput: nums1 = [1,2,3,2,4], nums2 = [2,3,1,2,3]\nOutput: [0,3]\nExplanation: Consider index 0 and index 3. The value of |nums1[i]-nums1[j]| + |nums2[i]-nums2[j]| is 1, which is the smallest value we can achieve.\n\nExample 2:\n\nInput: nums1 = [1,2,4,3,2,5], nums2 = [1,4,2,3,5,1]\nOutput: [1,4]\nExplanation: Consider index 1 and index 4. The value of |nums1[i]-nums1[j]| + |nums2[i]-nums2[j]| is 1, which is the smallest value we can achieve.\n\n\u00a0\nConstraints:\n\n2 <= nums1.length, nums2.length <= 105\nnums1.length == nums2.length\n0 <= nums1i\u00a0<= nums1.length\n0 <= nums2i\u00a0<= nums2.length Explanation:\n\nSolution 1: Sorting + Divide and Conquer\nThis problem is equivalent to finding two points in the plane, such that the Manhattan distance between them is the smallest. If there are multiple points satisfying the condition, return the one with the smallest index.\nFirst, we handle the case where there are duplicate points. For each point, we record the corresponding indices in a list. If the length of the index list is greater than $1$, then the first two indices in the index list can be used as candidates, and we find the smallest index pair.\nIf there are no duplicate points, we sort all the points by $x$ coordinates, and then use the divide and conquer to solve the problem.\nFor each interval $[l, r]$, we first calculate the median of the $x$ coordinates $m$, and then recursively solve the left and right intervals, and get $d_1, (pi_1, pj_1)$ and $d_2, (pi_2, pj_2)$ respectively, where $d_1$ and $d_2$ are the minimum Manhattan distances of the left and right intervals respectively, and $(pi_1, pj_1)$ and $(pi_2, pj_2)$ are the index pairs of the two points of the minimum Manhattan distance of the left and right intervals respectively. We take the smaller one of $d_1$ and $d_2$ as the minimum Manhattan distance of the current interval, and if $d_1 = d_2$, we take the one with the smaller index as the answer. The corresponding two points of the index are taken as the answer.\nThe above considers the case where the two points are on the same side. If the two points are on different sides, we take the middle point, i.e. the point with the index of $m = \\lfloor (l + r) / 2 \\rfloor$ as the standard, and divide a new region. The range of this region is to expand the range of $d_1$ from the middle point to the left and right sides respectively. Then we sort these points in the range by $y$ coordinates, and then traverse each point pair in the sorted order. If the difference of the $y$ coordinates of the two points is greater than the current minimum Manhattan distance, then the following point pairs do not need to be considered, because their $y$ coordinate differences are larger, so the Manhattan distance is larger, and it will not be smaller than the current minimum Manhattan distance. Otherwise, we update the minimum Manhattan distance, and update the answer.\nFinally, we return the answer.\nTime complexity: $O(n \\times \\log n)$, where $n$ is the length of the array.\nSpace complexity: $O(n)$. \n\n", "problem_ids": ["find-the-n-th-value-after-k-seconds", "alice-and-bob-playing-flower-game", "beautiful-pairs"]}, "3104": {"text": "Similar Problem 1 \n\n Problem:\n\nA game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\nThe graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\nThe mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0.\nDuring each player's turn, they must travel along one\u00a0edge of the graph that meets where they are.\u00a0 For example, if the Mouse is at node 1, it must travel to any node in graph[1].\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0).\nThen, the game can end in three\u00a0ways:\n\nIf ever the Cat occupies the same node as the Mouse, the Cat wins.\nIf ever the Mouse reaches the Hole, the Mouse wins.\nIf ever a position is repeated (i.e., the players are in the same position as a previous turn, and\u00a0it is the same player's turn to move), the game is a draw.\n\nGiven a graph, and assuming both players play optimally, return\n\n1\u00a0if the mouse wins the game,\n2\u00a0if the cat wins the game, or\n0\u00a0if the game is a draw.\n\n\u00a0\nExample 1:\n\n\nInput: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0\n\nExample 2:\n\n\nInput: graph = [[1,3],[0],[3],[0,2]]\nOutput: 1\n\n\u00a0\nConstraints:\n\n3 <= graph.length <= 50\n1\u00a0<= graph[i].length < graph.length\n0 <= graph[i][j] < graph.length\ngraph[i][j] != i\ngraph[i] is unique.\nThe mouse and the cat can always move.\u00a0 Explanation:\n\nSolution 1: Topological Sorting\nIn the game of cat and mouse, the state is determined by three factors: the position of the mouse, the position of the cat, and the mover. According to the game rules, the boundary states that can directly determine the outcome are:\n\nWhen the positions of the cat and the mouse are the same, the cat wins. This is a must-win state for the cat and a must-lose state for the mouse.\nWhen the mouse is in the hole, the mouse wins. This is a must-win state for the mouse and a must-lose state for the cat.\n\nTo get the game result of the initial state, we need to traverse all states starting from the boundary state. Each state includes the position of the mouse, the position of the cat, and the mover. Based on the current state, we can get all possible states of the previous round. The mover of the previous round is opposite to the mover of the current state, and the position of the mover of the previous round is different from the position of the current state.\nWe use the tuple $(m, c, t)$ to represent the state of this round, and $(pm, pc, pt)$ to represent the possible state of the previous round. Then, all possible states of the previous round are:\n\nIf the mover of this round is the mouse, then the mover of the previous round is the cat, the position of the mouse in the previous round is the position of the mouse in this round, and the position of the cat in the previous round is all adjacent points of the position of the cat in this round.\nIf the mover of this round is the cat, then the mover of the previous round is the mouse, the position of the cat in the previous round is the position of the cat in this round, and the position of the mouse in the previous round is all adjacent points of the position of the mouse in this round.\n\nInitially, except for the boundary states, the results of all other states are unknown. We start from the boundary state, for each state, get all possible states of the previous round and update the result. The update logic is as follows:\n\nIf the mover of the previous round is the same as the winner of this round, then the mover of the previous round can reach the current state and win, directly update the state of the previous round to the winner of this round.\nIf the mover of the previous round is different from the winner of this round, and all states that the mover of the previous round can reach are the must-lose states for the mover of the previous round, then we update the state of the previous round to the winner of this round.\n\nFor the second update logic, we need to record the degree of each state. Initially, the degree of each state represents the number of nodes that the mover of the state can move to, that is, the number of adjacent nodes of the node where the mover is located. If the mover is the cat and the node where it is located is adjacent to the hole, the degree of the state needs to be reduced by $1$.\nWhen the results of all states are updated, the result of the initial state is the final result.\nThe time complexity is $O(n^3)$, and the space complexity is $O(n^2)$. Where $n$ is the number of nodes in the graph. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two 1-indexed integer arrays, nums and, changeIndices, having lengths n and m, respectively.\nInitially, all indices in nums are unmarked. Your task is to mark all indices in nums.\nIn each second, s, in order from 1 to m (inclusive), you can perform one of the following operations:\n\nChoose an index i in the range [1, n] and decrement nums[i] by 1.\nIf nums[changeIndices[s]] is equal to 0, mark the index changeIndices[s].\nDo nothing.\n\nReturn an integer denoting the earliest second in the range [1, m] when all indices in nums can be marked by choosing operations optimally, or -1 if it is impossible.\n\u00a0\nExample 1:\n\nInput: nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]\nOutput: 8\nExplanation: In this example, we have 8 seconds. The following operations can be performed to mark all indices:\nSecond 1: Choose index 1 and decrement nums[1] by one. nums becomes [1,2,0].\nSecond 2: Choose index 1 and decrement nums[1] by one. nums becomes [0,2,0].\nSecond 3: Choose index 2 and decrement nums[2] by one. nums becomes [0,1,0].\nSecond 4: Choose index 2 and decrement nums[2] by one. nums becomes [0,0,0].\nSecond 5: Mark the index changeIndices[5], which is marking index 3, since nums[3] is equal to 0.\nSecond 6: Mark the index changeIndices[6], which is marking index 2, since nums[2] is equal to 0.\nSecond 7: Do nothing.\nSecond 8: Mark the index changeIndices[8], which is marking index 1, since nums[1] is equal to 0.\nNow all indices have been marked.\nIt can be shown that it is not possible to mark all indices earlier than the 8th second.\nHence, the answer is 8.\n\nExample 2:\n\nInput: nums = [1,3], changeIndices = [1,1,1,2,1,1,1]\nOutput: 6\nExplanation: In this example, we have 7 seconds. The following operations can be performed to mark all indices:\nSecond 1: Choose index 2 and decrement nums[2] by one. nums becomes [1,2].\nSecond 2: Choose index 2 and decrement nums[2] by one. nums becomes [1,1].\nSecond 3: Choose index 2 and decrement nums[2] by one. nums becomes [1,0].\nSecond 4: Mark the index changeIndices[4], which is marking index 2, since nums[2] is equal to 0.\nSecond 5: Choose index 1 and decrement nums[1] by one. nums becomes [0,0].\nSecond 6: Mark the index changeIndices[6], which is marking index 1, since nums[1] is equal to 0.\nNow all indices have been marked.\nIt can be shown that it is not possible to mark all indices earlier than the 6th second.\nHence, the answer is 6.\n\nExample 3:\n\nInput: nums = [0,1], changeIndices = [2,2,2]\nOutput: -1\nExplanation: In this example, it is impossible to mark all indices because index 1 isn't in changeIndices.\nHence, the answer is -1.\n\n\u00a0\nConstraints:\n\n1 <= n == nums.length <= 2000\n0 <= nums[i] <= 109\n1 <= m == changeIndices.length <= 2000\n1 <= changeIndices[i] <= n Explanation:\n\nSolution 1: Binary Search\nWe notice that if we can mark all indices within $t$ seconds, then we can also mark all indices within $t' \\geq t$ seconds. Therefore, we can use binary search to find the earliest seconds.\nWe define the left and right boundaries of binary search as $l = 1$ and $r = m + 1$, where $m$ is the length of the array changeIndices. For each $t = \\frac{l + r}{2}$, we check whether we can mark all indices within $t$ seconds. If we can, we move the right boundary to $t$, otherwise we move the left boundary to $t + 1$. Finally, we judge whether the left boundary is greater than $m$, if it is, return $-1$, otherwise return the left boundary.\nThe key to the problem is how to judge whether we can mark all indices within $t$ seconds. We can use an array $last$ to record the latest time each index needs to be marked, use a variable $decrement$ to record the current number of times that can be reduced, and use a variable $marked$ to record the number of indices that have been marked.\nWe traverse the first $t$ elements of the array changeIndices, for each element $i$, if $last[i] = s$, then we need to check whether $decrement$ is greater than or equal to $nums[i - 1]$, if it is, we subtract $nums[i - 1]$ from $decrement$, and add one to $marked$; otherwise, we return False. If $last[i] \\neq s$, then we can temporarily not mark the index, so we add one to $decrement$. Finally, we check whether $marked$ is equal to $n$, if it is, we return True, otherwise return False.\nThe time complexity is $O(m \\times \\log m)$, and the space complexity is $O(n)$. Where $n$ and $m$ are the lengths of nums and changeIndices respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums, an integer modulo, and an integer k.\nYour task is to find the count of subarrays that are interesting.\nA subarray nums[l..r] is interesting if the following condition holds:\n\nLet cnt be the number of indices i in the range [l, r] such that nums[i] % modulo == k. Then, cnt % modulo == k.\n\nReturn an integer denoting the count of interesting subarrays. \nNote: A subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nExample 1:\n\nInput: nums = [3,2,4], modulo = 2, k = 1\nOutput: 3\nExplanation: In this example the interesting subarrays are: \nThe subarray nums[0..0] which is [3]. \n- There is only one index, i = 0, in the range [0, 0] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 1 and cnt % modulo == k.  \nThe subarray nums[0..1] which is [3,2].\n- There is only one index, i = 0, in the range [0, 1] that satisfies nums[i] % modulo == k.  \n- Hence, cnt = 1 and cnt % modulo == k.\nThe subarray nums[0..2] which is [3,2,4]. \n- There is only one index, i = 0, in the range [0, 2] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 1 and cnt % modulo == k. \nIt can be shown that there are no other interesting subarrays. So, the answer is 3.\nExample 2:\n\nInput: nums = [3,1,9,6], modulo = 3, k = 0\nOutput: 2\nExplanation: In this example the interesting subarrays are: \nThe subarray nums[0..3] which is [3,1,9,6]. \n- There are three indices, i = 0, 2, 3, in the range [0, 3] that satisfy nums[i] % modulo == k. \n- Hence, cnt = 3 and cnt % modulo == k. \nThe subarray nums[1..1] which is [1]. \n- There is no index, i, in the range [1, 1] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 0 and cnt % modulo == k. \nIt can be shown that there are no other interesting subarrays. So, the answer is 2.\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105 \n1 <= nums[i] <= 109\n1 <= modulo <= 109\n0 <= k < modulo Explanation:\n\nSolution 1: Hash Table + Prefix Sum\nThe problem requires the number of indices $i$ in an interval that satisfy $nums[i] \\bmod modulo = k$. We can transform the array $nums$ into a $0-1$ array $arr$, where $arr[i] = 1$ indicates $nums[i] \\bmod modulo = k$, otherwise $arr[i] = 0$.\nFor an interval $[l, r]$, we can calculate the number of $1$s in $arr[l..r]$ through the prefix sum array $s$, i.e., $s[r] - s[l - 1]$, where $s[0] = 0$.\nWe use a hash table $cnt$ to record the number of occurrences of the prefix sum $s \\bmod modulo$, initially $cnt[0]=1$.\nNext, we traverse the array $arr$, calculate the prefix sum $s$, add the number of occurrences of $(s-k) \\bmod modulo$ to the answer, and then add $1$ to the number of occurrences of $s \\bmod modulo$.\nAfter the traversal ends, return the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["cat-and-mouse", "earliest-second-to-mark-indices-i", "count-of-interesting-subarrays"]}, "3106": {"text": "Similar Problem 1 \n\n Problem:\n\nImplement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\nboolean hasPrev() Returns true if there exists a number in the traversal to the left of the pointer, otherwise returns false.\nint prev() Moves the pointer to the left, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() and prev() calls will always be valid. That is, there will be at least a next/previous number in the in-order traversal when next()/prev() is called.\n\u00a0\nExample 1:\n\n\nInput\n[\"BSTIterator\", \"next\", \"next\", \"prev\", \"next\", \"hasNext\", \"next\", \"next\", \"next\", \"hasNext\", \"hasPrev\", \"prev\", \"prev\"]\n[[[7, 3, 15, null, null, 9, 20]], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null]]\nOutput\n[null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9]\n\nExplanation\n// The underlined element is where the pointer currently is.\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); // state is   [3, 7, 9, 15, 20]\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 3\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7\nbSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 3\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7\nbSTIterator.hasNext(); // return true\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 9\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 15\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 20\nbSTIterator.hasNext(); // return false\nbSTIterator.hasPrev(); // return true\nbSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 15\nbSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 9\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, next, hasPrev, and prev.\n\n\u00a0\nFollow up: Could you solve the problem without precalculating the values of the tree? Explanation:\n\nSolution 1: In-order Traversal + Array\nWe can use in-order traversal to store the values of all nodes in the binary search tree into an array $nums$, and then use the array to implement the iterator. We define a pointer $i$, initially $i = -1$, which points to an element in the array $nums$. Each time we call $next()$, we add $1$ to the value of $i$ and return $nums[i]$; each time we call $prev()$, we subtract $1$ from the value of $i$ and return $nums[i]$.\nIn terms of time complexity, initializing the iterator requires $O(n)$ time, where $n$ is the number of nodes in the binary search tree. Each call to $next()$ and $prev()$ requires $O(1)$ time. In terms of space complexity, we need $O(n)$ space to store the values of all nodes in the binary search tree. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a non-negative integer num, return true if num can be expressed as the sum of any non-negative integer and its reverse, or false otherwise.\n\u00a0\nExample 1:\n\nInput: num = 443\nOutput: true\nExplanation: 172 + 271 = 443 so we return true.\n\nExample 2:\n\nInput: num = 63\nOutput: false\nExplanation: 63 cannot be expressed as the sum of a non-negative integer and its reverse so we return false.\n\nExample 3:\n\nInput: num = 181\nOutput: true\nExplanation: 140 + 041 = 181 so we return true. Note that when a number is reversed, there may be leading zeros.\n\n\u00a0\nConstraints:\n\n0 <= num <= 105 Explanation:\n\nSolution 1: Brute Force Enumeration\nEnumerate $k$ in the range $[0,.., num]$, and check whether $k + reverse(k)$ equals $num$.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the size of $num$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two integer arrays nums1 and nums2.\nFrom nums1 two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable x.\nAs a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.\nReturn the minimum possible integer x that achieves this equivalence.\n\u00a0\nExample 1:\n\nInput: nums1 = [4,20,16,12,8], nums2 = [14,18,10]\nOutput: -2\nExplanation:\nAfter removing elements at indices [0,4] and adding -2, nums1 becomes [18,14,10].\n\nExample 2:\n\nInput: nums1 = [3,5,5,3], nums2 = [7,7]\nOutput: 2\nExplanation:\nAfter removing elements at indices [0,3] and adding 2, nums1 becomes [7,7].\n\n\u00a0\nConstraints:\n\n3 <= nums1.length <= 200\nnums2.length == nums1.length - 2\n0 <= nums1[i], nums2[i] <= 1000\nThe test cases are generated in a way that there is an integer x such that nums1 can become equal to nums2 by removing two elements and adding x to each element of nums1. Explanation:\n\nSolution 1: Sorting + Enumeration + Two Pointers\nFirst, we sort the arrays $nums1$ and $nums2$. Since we need to remove two elements from $nums1$, we only need to consider the first three elements of $nums1$, denoted as $a_1, a_2, a_3$. We can enumerate the first element $b_1$ of $nums2$, then we can get $x = b_1 - a_i$, where $i \\in {1, 2, 3}$. Then we can use the two pointers method to determine whether there exists an integer $x$ that makes $nums1$ and $nums2$ equal, and take the smallest $x$ that satisfies the condition.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Where $n$ is the length of the array. \n\n", "problem_ids": ["binary-search-tree-iterator-ii", "sum-of-number-and-its-reverse", "find-the-integer-added-to-array-ii"]}, "3114": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.\nAfter converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.\n\u00a0\nExample 1:\n\nInput: n = 34, k = 6\nOutput: 9\nExplanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.\n\nExample 2:\n\nInput: n = 10, k = 10\nOutput: 1\nExplanation: n is already in base 10. 1 + 0 = 1.\n\n\u00a0\nConstraints:\n\n1 <= n <= 100\n2 <= k <= 10 Explanation:\n\nSolution 1: Mathematics\nWe divide $n$ by $k$ and take the remainder until it is $0$. The sum of the remainders gives the result.\nThe time complexity is $O(\\log_{k}n)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array nums and an integer k. Find the largest even sum of any subsequence of nums that has a length of k.\nReturn this sum, or -1 if such a sum does not exist.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\nExample 1:\n\nInput: nums = [4,1,5,3,1], k = 3\nOutput: 12\nExplanation:\nThe subsequence with the largest possible even sum is [4,5,3]. It has a sum of 4 + 5 + 3 = 12.\n\nExample 2:\n\nInput: nums = [4,6,2], k = 3\nOutput: 12\nExplanation:\nThe subsequence with the largest possible even sum is [4,6,2]. It has a sum of 4 + 6 + 2 = 12.\n\nExample 3:\n\nInput: nums = [1,3,5], k = 1\nOutput: -1\nExplanation:\nNo subsequence of nums with length 1 has an even sum.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 105\n1 <= k <= nums.length Explanation:\n\nSolution 1: Greedy + Sorting\nWe notice that the problem involves selecting a subsequence, so we can consider sorting the array first.\nNext, we greedily select the largest $k$ numbers. If the sum of these numbers is even, we directly return this sum $ans$.\nOtherwise, we have two greedy strategies:\n\nAmong the largest $k$ numbers, find the smallest even number $mi1$, and then among the remaining $n - k$ numbers, find the largest odd number $mx1$. Replace $mi1$ with $mx1$. If such a replacement exists, then the sum after replacement $ans - mi1 + mx1$ is guaranteed to be even;\nAmong the largest $k$ numbers, find the smallest odd number $mi2$, and then among the remaining $n - k$ numbers, find the largest even number $mx2$. Replace $mi2$ with $mx2$. If such a replacement exists, then the sum after replacement $ans - mi2 + mx2$ is guaranteed to be even.\n\nWe take the largest even sum as the answer. If no even sum exists, return $-1$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nAn integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.\nGiven an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.\n\u00a0\nExample 1:\n\nInput: changed = [1,3,4,2,6,8]\nOutput: [1,3,4]\nExplanation: One possible original array could be [1,3,4]:\n- Twice the value of 1 is 1 * 2 = 2.\n- Twice the value of 3 is 3 * 2 = 6.\n- Twice the value of 4 is 4 * 2 = 8.\nOther original arrays could be [4,3,1] or [3,1,4].\n\nExample 2:\n\nInput: changed = [6,3,0,1]\nOutput: []\nExplanation: changed is not a doubled array.\n\nExample 3:\n\nInput: changed = [1]\nOutput: []\nExplanation: changed is not a doubled array.\n\n\u00a0\nConstraints:\n\n1 <= changed.length <= 105\n0 <= changed[i] <= 105 Explanation:\n\nSolution 1: Sorting\nWe notice that if the array changed is a double array, then the smallest element in the array changed must also be an element in the original array. Therefore, we can first sort the array changed, and then start from the first element to traverse the array changed in ascending order.\nWe use a hash table or array $cnt$ to count the occurrence of each element in the array changed. For each element $x$ in the array changed, we first check whether $x$ exists in $cnt$. If it does not exist, we skip this element. Otherwise, we subtract one from $cnt[x]$, and check whether $x \\times 2$ exists in $cnt$. If it does not exist, we return an empty array directly. Otherwise, we subtract one from $cnt[x \\times 2]$, and add $x$ to the answer array.\nAfter the traversal, we return the answer array.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$, where $n$ is the length of the array changed. \n\n", "problem_ids": ["sum-of-digits-in-base-k", "subsequence-of-size-k-with-the-largest-even-sum", "find-original-array-from-doubled-array"]}, "3141": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums of length n.\nYou can perform the following operation as many times as you want:\n\nPick an index i that you haven\u2019t picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i].\n\nReturn true if you can make nums a strictly increasing array using the above operation and false otherwise.\nA strictly increasing array is an array whose each element is strictly greater than its preceding element.\n\u00a0\nExample 1:\n\nInput: nums = [4,9,6,10]\nOutput: true\nExplanation: In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].\nIn the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].\nAfter the second operation, nums is sorted in strictly increasing order, so the answer is true.\nExample 2:\n\nInput: nums = [6,8,11,12]\nOutput: true\nExplanation: Initially nums is sorted in strictly increasing order, so we don't need to make any operations.\nExample 3:\n\nInput: nums = [5,8,3]\nOutput: false\nExplanation: It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000\nnums.length == n Explanation:\n\nSolution 1: Preprocessing prime numbers + binary search\nWe first preprocess all the primes within $1000$ and record them in the array $p$.\nFor each element $nums[i]$ in the array $nums$, we need to find a prime $p[j]$ such that $p[j] \\gt nums[i] - nums[i + 1]$ and $p[j]$ is as small as possible. If there is no such prime, it means that it cannot be strictly increased by subtraction operations, return false. If there is such a prime, we will subtract $p[j]$ from $nums[i]$ and continue to process the next element.\nIf all the elements in $nums$ are processed, it means that it can be strictly increased by subtraction operations, return true.\nThe time complexity is $O(n \\log n)$ and the space complexity is $O(n)$. where $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou want to water n plants in your garden with a watering can. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i. There is a river at x = -1 that you can refill your watering can at.\nEach plant needs a specific amount of water. You will water the plants in the following way:\n\nWater the plants in order from left to right.\nAfter watering the current plant, if you do not have enough water to completely water the next plant, return to the river to fully refill the watering can.\nYou cannot refill the watering can early.\n\nYou are initially at the river (i.e., x = -1). It takes one step to move one unit on the x-axis.\nGiven a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and an integer capacity representing the watering can capacity, return the number of steps needed to water all the plants.\n\u00a0\nExample 1:\n\nInput: plants = [2,2,3,3], capacity = 5\nOutput: 14\nExplanation: Start at the river with a full watering can:\n- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.\n- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.\n- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).\n- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.\n- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).\n- Walk to plant 3 (4 steps) and water it.\nSteps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.\n\nExample 2:\n\nInput: plants = [1,1,1,4,2,3], capacity = 4\nOutput: 30\nExplanation: Start at the river with a full watering can:\n- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).\n- Water plant 3 (4 steps). Return to river (4 steps).\n- Water plant 4 (5 steps). Return to river (5 steps).\n- Water plant 5 (6 steps).\nSteps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.\n\nExample 3:\n\nInput: plants = [7,7,7,7,7,7,7], capacity = 8\nOutput: 49\nExplanation: You have to refill before watering each plant.\nSteps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.\n\n\u00a0\nConstraints:\n\nn == plants.length\n1 <= n <= 1000\n1 <= plants[i] <= 106\nmax(plants[i]) <= capacity <= 109 Explanation:\n\nSolution 1: Simulation\nWe can simulate the process of watering the plants. We use a variable $\\textit{water}$ to represent the current amount of water in the watering can, initially $\\textit{water} = \\textit{capacity}$.\nWe traverse the plants. For each plant:\n\nIf the current amount of water in the watering can is enough to water this plant, we move forward one step, water this plant, and update $\\textit{water} = \\textit{water} - \\textit{plants}[i]$.\nOtherwise, we need to return to the river to refill the watering can, walk back to the current position, and then move forward one step. The number of steps we need is $i \\times 2 + 1$. Then we water this plant and update $\\textit{water} = \\textit{capacity} - \\textit{plants}[i]$.\n\nFinally, return the total number of steps.\nThe time complexity is $O(n)$, where $n$ is the number of plants. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\n\u00a0\nExample 1:\n\n\nInput: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.\n\nExample 2:\n\n\nInput: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.\n\n\u00a0\nConstraints:\n\nn == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique. Explanation:\n\nSolution 1: Simulation\nWe first use the array $pos$ to record the coordinates of the grid visited by the knight, and then traverse the $pos$ array to check whether the difference between the adjacent two grid coordinates is $(1, 2)$ or $(2, 1)$. If not, return false.\nOtherwise, return true after the traversal ends.\nThe time complexity is $O(n^2)$ and the space complexity is $O(n^2)$, where $n$ is the length of the chessboard. \n\n", "problem_ids": ["prime-subtraction-operation", "watering-plants", "check-knight-tour-configuration"]}, "3150": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:\n\nA land cell if grid[r][c] = 0, or\nA water cell containing grid[r][c] fish, if grid[r][c] > 0.\n\nA fisher can start at any water cell (r, c) and can do the following operations any number of times:\n\nCatch all the fish at cell (r, c), or\nMove to any adjacent water cell.\n\nReturn the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.\nAn adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.\n\u00a0\nExample 1:\n\n\nInput: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\nOutput: 7\nExplanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3)\u00a0and collect 4 fish.\n\nExample 2:\n\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\nOutput: 1\nExplanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. \n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 10\n0 <= grid[i][j] <= 10 Explanation:\n\nSolution 1: DFS\nAccording to the problem description, we only need to find the number of fish in each connected water area and then take the maximum value. Therefore, we can use the depth-first search method to solve this problem.\nWe define a function $dfs(i, j)$, which indicates the maximum number of fish that can be caught starting from the cell in the $i$-th row and the $j$-th column. The execution logic of the function $dfs(i, j)$ is as follows:\nWe use a variable $cnt$ to record the number of fish in the current cell, and then set the number of fish in the current cell to $0$, indicating that it has been fished. Then we traverse the four directions of the current cell, if the cell $(x, y)$ in a certain direction is in the grid and is a water cell, then we recursively call the $dfs(x, y)$ function and add the return value to $cnt$. Finally, return $cnt$.\nIn the main function, we traverse all the cells $(i, j)$. If the current cell is a water cell, we call the $dfs(i, j)$ function, take the maximum value of the return value as the answer, and return it.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. where $m$ and $n$ are the number of rows and columns of the grid graph respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.\nReturn the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\n\u00a0\nExample 1:\n\nInput: dominoes = [[1,2],[2,1],[3,4],[5,6]]\nOutput: 1\n\nExample 2:\n\nInput: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]\nOutput: 3\n\n\u00a0\nConstraints:\n\n1 <= dominoes.length <= 4 * 104\ndominoes[i].length == 2\n1 <= dominoes[i][j] <= 9 Explanation:\n\nSolution 1: Counting\nWe can concatenate the two numbers of each domino in order of size to form a two-digit number, so that equivalent dominoes can be concatenated into the same two-digit number. For example, both [1, 2] and [2, 1] are concatenated into the two-digit number 12, and both [3, 4] and [4, 3] are concatenated into the two-digit number 34.\nThen we traverse all the dominoes, using an array $cnt$ of length $100$ to record the number of occurrences of each two-digit number. For each domino, the two-digit number we concatenate is $x$, then the answer will increase by $cnt[x]$, and then we add $1$ to the value of $cnt[x]$. Continue to traverse the next domino, and we can count the number of all equivalent domino pairs.\nThe time complexity is $O(n)$, and the space complexity is $O(C)$. Here, $n$ is the number of dominoes, and $C$ is the maximum number of two-digit numbers concatenated in the dominoes, which is $100$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two 0-indexed integer arrays player1 and player2, representing the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hits xi pins in the ith turn. The value of the ith turn for the player is:\n\n2xi if the player hits 10 pins in either (i - 1)th or (i - 2)th turn.\nOtherwise, it is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.\n\n\u00a0\nExample 1:\n\nInput: player1 = [5,10,3,2], player2 = [6,5,7,3]\nOutput: 1\nExplanation:\nThe score of player 1 is 5 + 10 + 2*3 + 2*2 = 25.\nThe score of player 2 is 6 + 5 + 7 + 3 = 21.\n\nExample 2:\n\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation:\nThe score of player 1 is 3 + 5 + 7 + 6 = 21.\nThe score of player 2 is 8 + 10 + 2*10 + 2*2 = 42.\n\nExample 3:\n\nInput: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation:\nThe score of player1 is 2 + 3 = 5.\nThe score of player2 is 4 + 1 = 5.\n\nExample 4:\n\nInput: player1 = [1,1,1,10,10,10,10], player2 = [10,10,10,10,1,1,1]\nOutput: 2\nExplanation:\nThe score of player1 is 1 + 1 + 1 + 10 + 2*10 + 2*10 + 2*10 = 73.\nThe score of player2 is 10 + 2*10 + 2*10 + 2*10 + 2*1 + 2*1 + 1 = 75.\n\n\u00a0\nConstraints:\n\nn == player1.length == player2.length\n1 <= n <= 1000\n0 <= player1[i], player2[i] <= 10 Explanation:\n\nSolution 1: Simulation\nWe can define a function $f(arr)$ to calculate the scores of the two players, denoted as $a$ and $b$, respectively, and then return the answer based on the relationship between $a$ and $b$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-number-of-fish-in-a-grid", "number-of-equivalent-domino-pairs", "determine-the-winner-of-a-bowling-game"]}, "3151": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a non-negative integer num, return true if num can be expressed as the sum of any non-negative integer and its reverse, or false otherwise.\n\u00a0\nExample 1:\n\nInput: num = 443\nOutput: true\nExplanation: 172 + 271 = 443 so we return true.\n\nExample 2:\n\nInput: num = 63\nOutput: false\nExplanation: 63 cannot be expressed as the sum of a non-negative integer and its reverse so we return false.\n\nExample 3:\n\nInput: num = 181\nOutput: true\nExplanation: 140 + 041 = 181 so we return true. Note that when a number is reversed, there may be leading zeros.\n\n\u00a0\nConstraints:\n\n0 <= num <= 105 Explanation:\n\nSolution 1: Brute Force Enumeration\nEnumerate $k$ in the range $[0,.., num]$, and check whether $k + reverse(k)$ equals $num$.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the size of $num$. \n\nSimilar Problem 2 \n\n Problem:\n\nA 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col grid of integers, how many 3 x 3 magic square subgrids are there?\nNote: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.\n\u00a0\nExample 1:\n\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.\n\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n\n\u00a0\nConstraints:\n\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15 Explanation:\n\nSolution 1: Enumeration\nWe directly enumerate the top-left coordinates $(i, j)$ of each $3 \\times 3$ sub-matrix, then check whether the sub-matrix satisfies the \"magic square\" condition. If it does, increment the answer by one. After enumeration, return the answer.\nTime complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. Space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums of size 3 which can form the sides of a triangle.\n\nA triangle is called equilateral if it has all sides of equal length.\nA triangle is called isosceles if it has exactly two sides of equal length.\nA triangle is called scalene if all its sides are of different lengths.\n\nReturn a string representing the type of triangle that can be formed or \"none\" if it cannot form a triangle.\n\u00a0\nExample 1:\n\nInput: nums = [3,3,3]\nOutput: \"equilateral\"\nExplanation: Since all the sides are of equal length, therefore, it will form an equilateral triangle.\n\nExample 2:\n\nInput: nums = [3,4,5]\nOutput: \"scalene\"\nExplanation: \nnums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.\nnums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.\nnums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3. \nSince the sum of the two sides is greater than the third side for all three cases, therefore, it can form a triangle.\nAs all the sides are of different lengths, it will form a scalene triangle.\n\n\u00a0\nConstraints:\n\nnums.length == 3\n1 <= nums[i] <= 100 Explanation:\n\nSolution 1: Sorting + Case Discussion\nFirst, we sort the array, and then we can classify and discuss according to the definition of a triangle.\n\nIf the sum of the smallest two numbers is less than or equal to the largest number, then it cannot form a triangle, return \"none\".\nIf the smallest number is equal to the largest number, then it is an equilateral triangle, return \"equilateral\".\nIf the smallest number is equal to the middle number or the middle number is equal to the largest number, then it is an isosceles triangle, return \"isosceles\".\nOtherwise, return \"scalene\".\n\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["sum-of-number-and-its-reverse", "magic-squares-in-grid", "type-of-triangle"]}, "3153": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non\u00a0included elements in such subsequence.\u00a0\nIf there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.\u00a0\nNote that the solution with the given constraints is guaranteed to be\u00a0unique. Also return the answer sorted in non-increasing order.\n\u00a0\nExample 1:\n\nInput: nums = [4,3,10,9,8]\nOutput: [10,9] \nExplanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements.\u00a0\n\nExample 2:\n\nInput: nums = [4,4,7,6,7]\nOutput: [7,7,6] \nExplanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-increasing order.  \n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 500\n1 <= nums[i] <= 100 Explanation:\n\nSolution 1: Sorting\nWe can first sort the array $nums$ in descending order, then add the elements to the array from largest to smallest. After each addition, we check whether the sum of the current elements is greater than the sum of the remaining elements. If it is, we return the current array.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Where $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven two integers n and k, return an array of all the integers of length n where the difference between every two consecutive digits is k. You may return the answer in any order.\nNote that the integers should not have leading zeros. Integers as 02 and 043 are not allowed.\n\u00a0\nExample 1:\n\nInput: n = 3, k = 7\nOutput: [181,292,707,818,929]\nExplanation: Note that 070 is not a valid number, because it has leading zeroes.\n\nExample 2:\n\nInput: n = 2, k = 1\nOutput: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]\n\n\u00a0\nConstraints:\n\n2 <= n <= 9\n0 <= k <= 9 Explanation:\n\nSolution 1: DFS\nWe can enumerate the first digit of all numbers of length $n$, and then use the depth-first search method to recursively construct all numbers that meet the conditions.\nSpecifically, we first define a boundary value $\\textit{boundary} = 10^{n-1}$, which represents the minimum value of the number we need to construct. Then, we enumerate the first digit from $1$ to $9$. For each digit $i$, we recursively construct the number of length $n$ with $i$ as the first digit.\nThe time complexity is $(n \\times 2^n \\times |\\Sigma|)$, where $|\\Sigma|$ represents the set of digits, and in this problem $|\\Sigma| = 9$. The space complexity is $O(2^n)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed array of integers nums.\nA prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential.\nReturn the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,2,5]\nOutput: 6\nExplanation: The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.\n\nExample 2:\n\nInput: nums = [3,4,5,1,12,14,13]\nOutput: 15\nExplanation: The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Simulation + Hash Table\nFirst, we calculate the longest prefix sum $s$ of the array $nums$. Then, starting from $s$, we enumerate the integer $x$. If $x$ is not in the array $nums$, then $x$ is the answer. Here, we can use a hash table to quickly determine whether an integer is in the array $nums$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["minimum-subsequence-in-non-increasing-order", "numbers-with-same-consecutive-differences", "smallest-missing-integer-greater-than-sequential-prefix-sum"]}, "3154": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed m x n matrix grid consisting of positive integers.\nYou can start at any cell in the first column of the matrix, and traverse the grid in the following way:\n\nFrom a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.\n\nReturn the maximum number of moves that you can perform.\n\u00a0\nExample 1:\n\n\nInput: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\nOutput: 3\nExplanation: We can start at the cell (0, 0) and make the following moves:\n- (0, 0) -> (0, 1).\n- (0, 1) -> (1, 2).\n- (1, 2) -> (2, 3).\nIt can be shown that it is the maximum number of moves that can be made.\nExample 2:\n\n\nInput: grid = [[3,2,4],[2,1,9],[1,1,7]]\nOutput: 0\nExplanation: Starting from any cell in the first column we cannot perform any moves.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n1 <= grid[i][j] <= 106 Explanation:\n\nSolution 1: BFS\nWe define a queue $q$, and initially add all the row coordinates of the first column to the queue.\nNext, we start from the first column and traverse column by column. For each column, we take out all the row coordinates in the queue one by one. For each row coordinate $i$, we get all possible row coordinates $k$ of the next column, and satisfy $grid[i][j] < grid[k][j + 1]$, and add these row coordinates to a new set $t$. If $t$ is empty, it means that we cannot continue to move, so we return the current column number. Otherwise, we assign $t$ to $q$ and continue to traverse the next column.\nFinally, if we have traversed all the columns, it means that we can move to the last column, so we return $n - 1$.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m)$. Where $m$ and $n$ are the number of rows and columns in the matrix, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nA subsequence of a string s is considered a good palindromic subsequence if:\n\nIt is a subsequence of s.\nIt is a palindrome (has the same value if reversed).\nIt has an even length.\nNo two consecutive characters are equal, except the two middle ones.\n\nFor example, if s = \"abcabcabb\", then \"abba\" is considered a good palindromic subsequence, while \"bcb\" (not even length) and \"bbbb\" (has equal consecutive characters) are not.\nGiven a string s, return the length of the longest good palindromic subsequence in s.\n\u00a0\nExample 1:\n\nInput: s = \"bbabab\"\nOutput: 4\nExplanation: The longest good palindromic subsequence of s is \"baab\".\n\nExample 2:\n\nInput: s = \"dcbccacdb\"\nOutput: 4\nExplanation: The longest good palindromic subsequence of s is \"dccd\".\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 250\ns consists of lowercase English letters. Explanation:\n\nSolution 1: Memorization Search\nWe design a function $dfs(i, j, x)$ to represent the length of the longest \"good\" palindrome subsequence ending with character $x$ in the index range $[i, j]$ of string $s$. The answer is $dfs(0, n - 1, 26)$.\nThe calculation process of the function $dfs(i, j, x)$ is as follows:\n\nIf $i >= j$, then $dfs(i, j, x) = 0$;\nIf $s[i] = s[j]$ and $s[i] \\neq x$, then $dfs(i, j, x) = dfs(i + 1, j - 1, s[i]) + 2$;\nIf $s[i] \\neq s[j]$, then $dfs(i, j, x) = max(dfs(i + 1, j, x), dfs(i, j - 1, x))$.\n\nDuring the process, we can use memorization search to avoid repeated calculations.\nThe time complexity is $O(n^2 \\times C)$. Where $n$ is the length of the string $s$, and $C$ is the size of the character set. In this problem, $C = 26$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard.\nBelow is the chessboard for reference.\n\nReturn true if these two squares have the same color and false otherwise.\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).\n\u00a0\nExample 1:\n\nInput: coordinate1 = \"a1\", coordinate2 = \"c3\"\nOutput: true\nExplanation:\nBoth squares are black.\n\nExample 2:\n\nInput: coordinate1 = \"a1\", coordinate2 = \"h3\"\nOutput: false\nExplanation:\nSquare \"a1\" is black and \"h3\" is white.\n\n\u00a0\nConstraints:\n\ncoordinate1.length == coordinate2.length == 2\n'a' <= coordinate1[0], coordinate2[0] <= 'h'\n'1' <= coordinate1[1], coordinate2[1] <= '8' Explanation:\n\nSolution 1: Mathematics\nWe calculate the differences in the x-coordinates and y-coordinates of the two points. If the sum of these differences is even, then the colors of the squares at these two coordinates are the same; otherwise, they are different.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-number-of-moves-in-a-grid", "longest-palindromic-subsequence-ii", "check-if-two-chessboard-squares-have-the-same-color"]}, "3163": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a singly-linked list head and we want to delete a node node in it.\nYou are given the node to be deleted node. You will not be given access to the first node of head.\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\nThe value of the given node should not exist in the linked list.\nThe number of nodes in the linked list should decrease by one.\nAll the values before node should be in the same order.\nAll the values after node should be in the same order.\n\nCustom testing:\n\nFor the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.\nWe will build the linked list and pass the node to your function.\nThe output will be the entire list after calling your function.\n\n\u00a0\nExample 1:\n\n\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\nExample 2:\n\n\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n\n\u00a0\nConstraints:\n\nThe number of the nodes in the given list is in the range [2, 1000].\n-1000 <= Node.val <= 1000\nThe value of each node in the list is unique.\nThe node to be deleted is in the list and is not a tail node. Explanation:\n\nSolution 1: Node assignment\nWe can replace the value of the current node with the value of the next node, and then delete the next node. This can achieve the purpose of deleting the current node.\nTime complexity $O(1)$, space complexity $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nA string is a valid parentheses string\u00a0(denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and:\n\nIt is the empty string, or\nIt can be written as\u00a0AB\u00a0(A\u00a0concatenated with\u00a0B), where\u00a0A\u00a0and\u00a0B\u00a0are VPS's, or\nIt can be written as\u00a0(A), where\u00a0A\u00a0is a VPS.\n\nWe can\u00a0similarly define the nesting depth depth(S) of any VPS S as follows:\n\ndepth(\"\") = 0\ndepth(A + B) = max(depth(A), depth(B)), where A and B are VPS's\ndepth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.\n\nFor example,\u00a0 \"\",\u00a0\"()()\", and\u00a0\"()(()())\"\u00a0are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's.\n\u00a0\nGiven a VPS seq, split it into two disjoint subsequences A and B, such that\u00a0A and B are VPS's (and\u00a0A.length + B.length = seq.length).\nNow choose any such A and B such that\u00a0max(depth(A), depth(B)) is the minimum possible value.\nReturn an answer array (of length seq.length) that encodes such a\u00a0choice of A and B:\u00a0 answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.\u00a0 Note that even though multiple answers may exist, you may return any of them.\n\u00a0\nExample 1:\n\nInput: seq = \"(()())\"\nOutput: [0,1,1,1,1,0]\n\nExample 2:\n\nInput: seq = \"()(())()\"\nOutput: [0,0,0,1,1,0,1,1]\n\n\u00a0\nConstraints:\n\n1 <= seq.size <= 10000 Explanation:\n\nSolution 1: Greedy\nWe use a variable $x$ to maintain the current balance of parentheses, which is the number of left parentheses minus the number of right parentheses.\nWe traverse the string $seq$, updating the value of $x$. If $x$ is odd, we assign the current left parenthesis to $A$, otherwise we assign it to $B$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $seq$. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed string word and an integer k.\nAt every second, you must perform the following operations:\n\nRemove the first k characters of word.\nAdd any k characters to the end of word.\n\nNote that you do not necessarily need to add the same characters that you removed. However, you must perform both operations at every second.\nReturn the minimum time greater than zero required for word to revert to its initial state.\n\u00a0\nExample 1:\n\nInput: word = \"abacaba\", k = 3\nOutput: 2\nExplanation: At the 1st second, we remove characters \"aba\" from the prefix of word, and add characters \"bac\" to the end of word. Thus, word becomes equal to \"cababac\".\nAt the 2nd second, we remove characters \"cab\" from the prefix of word, and add \"aba\" to the end of word. Thus, word becomes equal to \"abacaba\" and reverts to its initial state.\nIt can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state.\n\nExample 2:\n\nInput: word = \"abacaba\", k = 4\nOutput: 1\nExplanation: At the 1st second, we remove characters \"abac\" from the prefix of word, and add characters \"caba\" to the end of word. Thus, word becomes equal to \"abacaba\" and reverts to its initial state.\nIt can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state.\n\nExample 3:\n\nInput: word = \"abcbabcd\", k = 2\nOutput: 4\nExplanation: At every second, we will remove the first 2 characters of word, and add the same characters to the end of word.\nAfter 4 seconds, word becomes equal to \"abcbabcd\" and reverts to its initial state.\nIt can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 50 \n1 <= k <= word.length\nword consists only of lowercase English letters. Explanation:\n\nSolution 1: Enumeration\nLet's assume that if we can restore word to its initial state with only one operation, it means that word[k:] is a prefix of word, i.e., word[k:] == word[:n-k].\nIf there are multiple operations, let's assume $i$ is the number of operations, then it means that word[k*i:] is a prefix of word, i.e., word[k*i:] == word[:n-k*i].\nTherefore, we can enumerate the number of operations and check whether word[k*i:] is a prefix of word. If it is, then return $i$.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n)$. Here, $n$ is the length of word. \n\n", "problem_ids": ["delete-node-in-a-linked-list", "maximum-nesting-depth-of-two-valid-parentheses-strings", "minimum-time-to-revert-word-to-initial-state-i"]}, "3164": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string, message, and a positive integer, limit.\nYou must split message into one or more parts based on limit. Each resulting part should have the suffix \"<a/b>\", where \"b\" is to be replaced with the total number of parts and \"a\" is to be replaced with the index of the part, starting from 1 and going up to b. Additionally, the length of each resulting part (including its suffix) should be equal to limit, except for the last part whose length can be at most limit.\nThe resulting parts should be formed such that when their suffixes are removed and they are all concatenated in order, they should be equal to message. Also, the result should contain as few parts as possible.\nReturn the parts message would be split into as an array of strings. If it is impossible to split message as required, return an empty array.\n\u00a0\nExample 1:\n\nInput: message = \"this is really a very awesome message\", limit = 9\nOutput: [\"thi<1/14>\",\"s i<2/14>\",\"s r<3/14>\",\"eal<4/14>\",\"ly <5/14>\",\"a v<6/14>\",\"ery<7/14>\",\" aw<8/14>\",\"eso<9/14>\",\"me<10/14>\",\" m<11/14>\",\"es<12/14>\",\"sa<13/14>\",\"ge<14/14>\"]\nExplanation:\nThe first 9 parts take 3 characters each from the beginning of message.\nThe next 5 parts take 2 characters each to finish splitting message. \nIn this example, each part, including the last, has length 9. \nIt can be shown it is not possible to split message into less than 14 parts.\n\nExample 2:\n\nInput: message = \"short message\", limit = 15\nOutput: [\"short mess<1/2>\",\"age<2/2>\"]\nExplanation:\nUnder the given constraints, the string can be split into two parts: \n- The first part comprises of the first 10 characters, and has a length 15.\n- The next part comprises of the last 3 characters, and has a length 8.\n\n\u00a0\nConstraints:\n\n1 <= message.length <= 104\nmessage consists only of lowercase English letters and ' '.\n1 <= limit <= 104 Explanation:\n\nSolution 1: Enumerate the Number of Segments + Simulation\nWe denote the length of the string message as $n$, and the number of segments as $k$.\nAccording to the problem, if $k > n$, it means that we can divide the string into more than $n$ segments. Since the length of the string is only $n$, dividing it into more than $n$ segments will inevitably lead to some segments with a length of $0$, which can be deleted. Therefore, we only need to limit the range of $k$ to $[1,.. n]$.\nWe enumerate the number of segments $k$ from small to large. Let the length of $a$ segments in all segments be $sa$, the length of $b$ segments in all segments be $sb$, and the length of all symbols (including angle brackets and slashes) in all segments be $sc$.\nThen the value of $sa$ is ${\\textstyle \\sum_{j=1}^{k}} len(s_j)$, which can be directly obtained through the prefix sum; the value of $sb$ is $len(str(k)) \\times k$; and the value of $sc$ is $3 \\times k$.\nTherefore, the number of characters that can be filled in all segments is $limit\\times k - (sa + sb + sc)$. If this value is greater than or equal to $n$, it means that the string can be divided into $k$ segments, and we can directly construct the answer and return it.\nThe time complexity is $O(n\\times \\log n)$, where $n$ is the length of the string message. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an array of positive integers nums and want to erase a subarray containing\u00a0unique elements. The score you get by erasing the subarray is equal to the sum of its elements.\nReturn the maximum score you can get by erasing exactly one subarray.\nAn array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).\n\u00a0\nExample 1:\n\nInput: nums = [4,2,4,5,6]\nOutput: 17\nExplanation: The optimal subarray here is [2,4,5,6].\n\nExample 2:\n\nInput: nums = [5,2,1,2,5,2,1,2,5]\nOutput: 8\nExplanation: The optimal subarray here is [5,2,1] or [1,2,5].\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 104 Explanation:\n\nSolution 1: Array or Hash Table + Prefix Sum\nWe use an array or hash table $d$ to record the last occurrence of each number, use $s$ to record the prefix sum, and use $j$ to record the left endpoint of the current non-repeating subarray.\nWe traverse the array, for each number $v$, if $d[v]$ exists, then we update $j$ to $max(j, d[v])$, which ensures that the current non-repeating subarray does not contain $v$. Then we update the answer to $max(ans, s[i] - s[j])$, and finally update $d[v]$ to $i$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are painting a fence of n posts with k different colors. You must paint the posts following these rules:\n\nEvery post must be painted exactly one color.\nThere cannot be three or more consecutive posts with the same color.\n\nGiven the two integers n and k, return the number of ways you can paint the fence.\n\u00a0\nExample 1:\n\n\nInput: n = 3, k = 2\nOutput: 6\nExplanation: All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n\nExample 2:\n\nInput: n = 1, k = 1\nOutput: 1\n\nExample 3:\n\nInput: n = 7, k = 2\nOutput: 42\n\n\u00a0\nConstraints:\n\n1 <= n <= 50\n1 <= k <= 105\nThe testcases are generated such that the answer is in the range [0, 231 - 1] for the given n and k. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i]$ to represent the number of ways to paint the fence posts from $[0..i]$ such that the last two posts have different colors, and $g[i]$ to represent the number of ways to paint the fence posts from $[0..i]$ such that the last two posts have the same color. Initially, $f[0] = k$ and $g[0] = 0$.\nWhen $i > 0$, we have the following state transition equations:\n$$\n\\begin{aligned}\nf[i] & = (f[i - 1] + g[i - 1]) \\times (k - 1) \\\ng[i] & = f[i - 1]\n\\end{aligned}\n$$\nThe final answer is $f[n - 1] + g[n - 1]$.\nThe time complexity is $O(n)$ and the space complexity is $O(n)$, where $n$ is the number of fence posts. \n\n", "problem_ids": ["split-message-based-on-limit", "maximum-erasure-value", "paint-fence"]}, "3166": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array nums of non-negative integers and an integer k.\nAn array is called special if the bitwise OR of all of its elements is at least k.\nReturn the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3], k = 2\nOutput: 1\nExplanation:\nThe subarray [3] has OR value of 3. Hence, we return 1.\n\nExample 2:\n\nInput: nums = [2,1,8], k = 10\nOutput: 3\nExplanation:\nThe subarray [2,1,8] has OR value of 11. Hence, we return 3.\n\nExample 3:\n\nInput: nums = [1,2], k = 0\nOutput: 1\nExplanation:\nThe subarray [1] has OR value of 1. Hence, we return 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 2 * 105\n0 <= nums[i] <= 109\n0 <= k <= 109 Explanation:\n\nSolution 1: Two Pointers + Counting\nWe can observe that if we fix the left endpoint of the subarray, as the right endpoint moves to the right, the bitwise OR value of the subarray will only increase, not decrease. Therefore, we can use the double pointers method to maintain a subarray that meets the conditions.\nSpecifically, we use two pointers $i$ and $j$ to represent the left and right endpoints of the subarray, respectively. Initially, both pointers are at the first element of the array. We use a variable $s$ to represent the bitwise OR value of the subarray, and initially, the value of $s$ is $0$. We also need to maintain an array $cnt$ of length $32$, which represents the occurrence times of each bit in the binary representation of each element in the subarray.\nIn each step, we move $j$ to the right by one position, and update $s$ and $cnt$. If the value of $s$ is greater than or equal to $k$, we continuously update the minimum length of the subarray and move $i$ to the right by one position until the value of $s$ is less than $k$. In this process, we also need to update $s$ and $cnt$.\nFinally, we return the minimum length. If there is no subarray that meets the conditions, we return $-1$.\nThe time complexity is $O(n \\times \\log M)$ and the space complexity is $O(\\log M)$, where $n$ and $M$ are the length of the array and the maximum value of the elements in the array, respectively.\nSimilar Problems:\n\n3171. Find Subarray With Bitwise AND Closest to K \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer array nums, find the subarray with the largest sum, and return its sum.\n\u00a0\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n\u00a0\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i]$ to represent the maximum sum of the continuous subarray ending with the element $nums[i]$. Initially, $f[0] = nums[0]$. The final answer we are looking for is $\\max_{0 \\leq i < n} f[i]$.\nConsider $f[i]$, where $i \\geq 1$, its state transition equation is:\n$$\nf[i] = \\max { f[i - 1] + nums[i], nums[i] }\n$$\nWhich is also:\n$$\nf[i] = \\max { f[i - 1], 0 } + nums[i]\n$$\nSince $f[i]$ is only related to $f[i - 1]$, we can use a single variable $f$ to maintain the current value of $f[i]$, and then perform state transition. The answer is $\\max_{0 \\leq i < n} f$.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. We only need to traverse the array once to get the answer. The space complexity is $O(1)$, we only need constant space to store several variables. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a string s consisting of n characters which are either 'X' or 'O'.\nA move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.\nReturn the minimum number of moves required so that all the characters of s are converted to 'O'.\n\u00a0\nExample 1:\n\nInput: s = \"XXX\"\nOutput: 1\nExplanation: XXX -> OOO\nWe select all the 3 characters and convert them in one move.\n\nExample 2:\n\nInput: s = \"XXOX\"\nOutput: 2\nExplanation: XXOX -> OOOX -> OOOO\nWe select the first 3 characters in the first move, and convert them to 'O'.\nThen we select the last 3 characters and convert them so that the final string contains all 'O's.\nExample 3:\n\nInput: s = \"OOOO\"\nOutput: 0\nExplanation: There are no 'X's in s to convert.\n\n\u00a0\nConstraints:\n\n3 <= s.length <= 1000\ns[i] is either 'X' or 'O'. Explanation:\n\nSolution 1: Greedy Algorithm\nTraverse the string $s$. Whenever you encounter 'X', move the pointer $i$ three steps forward and add $1$ to the answer; otherwise, move the pointer $i$ one step forward.\nThe time complexity is $O(n)$, where $n$ represents the length of the string $s$. \n\n", "problem_ids": ["shortest-subarray-with-or-at-least-k-ii", "maximum-subarray", "minimum-moves-to-convert-string"]}, "3171": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\n\u00a0\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums is guaranteed to be rotated at some pivot.\n-104 <= target <= 104\n\n\u00a0\nFollow up: This problem is similar to\u00a0Search in Rotated Sorted Array, but\u00a0nums may contain duplicates. Would this affect the runtime complexity? How and why? Explanation:\n\nSolution 1: Binary Search\nWe define the left boundary $l=0$ and the right boundary $r=n-1$ for the binary search, where $n$ is the length of the array.\nDuring each binary search process, we get the current midpoint $mid=(l+r)/2$.\n\nIf $nums[mid] \\gt nums[r]$, it means that $[l,mid]$ is ordered. At this time, if $nums[l] \\le target \\le nums[mid]$, it means that $target$ is in $[l,mid]$, otherwise $target$ is in $[mid+1,r]$.\nIf $nums[mid] \\lt nums[r]$, it means that $[mid+1,r]$ is ordered. At this time, if $nums[mid] \\lt target \\le nums[r]$, it means that $target$ is in $[mid+1,r]$, otherwise $target$ is in $[l,mid]$.\nIf $nums[mid] = nums[r]$, it means that the elements $nums[mid]$ and $nums[r]$ are equal. At this time, we cannot determine which interval $target$ is in, so we can only decrease $r$ by $1$.\n\nAfter the binary search ends, if $nums[l] = target$, it means that the target value $target$ exists in the array, otherwise it means it does not exist.\nThe time complexity is approximately $O(\\log n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 2D matrix grid consisting of positive integers.\nYou have to select one or more cells from the matrix such that the following conditions are satisfied:\n\nNo two selected cells are in the same row of the matrix.\nThe values in the set of selected cells are unique.\n\nYour score will be the sum of the values of the selected cells.\nReturn the maximum score you can achieve.\n\u00a0\nExample 1:\n\nInput: grid = [[1,2,3],[4,3,2],[1,1,1]]\nOutput: 8\nExplanation:\n\nWe can select the cells with values 1, 3, and 4 that are colored above.\n\nExample 2:\n\nInput: grid = [[8,7,6],[8,3,2]]\nOutput: 15\nExplanation:\n\nWe can select the cells with values 7 and 8 that are colored above.\n\n\u00a0\nConstraints:\n\n1 <= grid.length, grid[i].length <= 10\n1 <= grid[i][j] <= 100 Explanation:\n\nSolution 1: State Compression Dynamic Programming\nWe define $f[i][j]$ to represent the maximum score when selecting numbers from $[1,..i]$ and the state of the rows corresponding to the selected numbers is $j$. Initially, $f[i][j] = 0$, and the answer is $f[\\textit{mx}][2^m - 1]$, where $\\textit{mx}$ represents the maximum value in the matrix, and $m$ represents the number of rows in the matrix.\nFirst, we preprocess the matrix using a hash table $g$ to record the set of rows corresponding to each number. Then, we can use state compression dynamic programming to solve the problem.\nFor the state $f[i][j]$, we can choose not to select the number $i$, in which case $f[i][j] = f[i-1][j]$. Alternatively, we can choose the number $i$. In this case, we need to enumerate each row $k$ in the set $g[i]$ corresponding to the number $i$. If the $k$-th bit of $j$ is $1$, it means we can select the number $i$. Thus, $f[i][j] = \\max(f[i][j], f[i-1][j \\oplus 2^k] + i)$.\nFinally, we return $f[\\textit{mx}][2^m - 1]$.\nThe time complexity is $O(m \\times 2^m \\times \\textit{mx})$, and the space complexity is $O(\\textit{mx} \\times 2^m)$. Here, $m$ is the number of rows in the matrix, and $\\textit{mx}$ is the maximum value in the matrix. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.\nReturn the sum of encrypted elements.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: 6\nExplanation: The encrypted elements are\u00a0[1,2,3]. The sum of encrypted elements is 1 + 2 + 3 == 6.\n\nExample 2:\n\nInput: nums = [10,21,31]\nOutput: 66\nExplanation: The encrypted elements are [11,22,33]. The sum of encrypted elements is 11 + 22 + 33 == 66.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 1000 Explanation:\n\nSolution 1: Simulation\nWe directly simulate the encryption process by defining a function $encrypt(x)$, which replaces each digit in an integer $x$ with the maximum digit in $x$. The implementation of the function is as follows:\nWe can obtain each digit of $x$ by continuously taking the modulus and integer division of $x$ by $10$, and find the maximum digit, denoted as $mx$. During the loop, we can also use a variable $p$ to record the base number of $mx$, i.e., $p = 1, 11, 111, \\cdots$. Finally, return $mx \\times p$.\nThe time complexity is $O(n \\times \\log M)$, where $n$ is the length of the array, and $M$ is the maximum value in the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["search-in-rotated-sorted-array-ii", "select-cells-in-grid-with-maximum-score", "find-the-sum-of-encrypted-integers"]}, "3172": {"text": "Similar Problem 1 \n\n Problem:\n\nAn array A is larger than some array B if for the first index i where A[i] != B[i], A[i] > B[i].\nFor example, consider 0-indexing:\n\n[1,3,2,4] > [1,2,2,4], since at index 1, 3 > 2.\n[1,4,4,4] < [2,1,1,1], since at index 0, 1 < 2.\n\nA subarray is a contiguous subsequence of the array.\nGiven an integer array nums of distinct integers, return the largest subarray of nums of length k.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,5,2,3], k = 3\nOutput: [5,2,3]\nExplanation: The subarrays of size 3 are: [1,4,5], [4,5,2], and [5,2,3].\nOf these, [5,2,3] is the largest.\nExample 2:\n\nInput: nums = [1,4,5,2,3], k = 4\nOutput: [4,5,2,3]\nExplanation: The subarrays of size 4 are: [1,4,5,2], and [4,5,2,3].\nOf these, [4,5,2,3] is the largest.\nExample 3:\n\nInput: nums = [1,4,5,2,3], k = 1\nOutput: [5]\n\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 105\n1 <= nums[i] <= 109\nAll the integers of nums are unique.\n\n\u00a0\nFollow up: What if the integers in nums are not distinct? Explanation:\n\nSolution 1: Simulation\nAll integers in the array are distinct, so we can first find the index of the maximum element in the range $[0,..n-k]$, and then take $k$ elements starting from this index.\nThe time complexity is $O(n)$, where $n$ is the length of the array. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer array arr and an integer k, modify the array by repeating it k times.\nFor example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].\nReturn the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.\nAs the answer can be very large, return the answer modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: arr = [1,2], k = 3\nOutput: 9\n\nExample 2:\n\nInput: arr = [1,-2,1], k = 5\nOutput: 2\n\nExample 3:\n\nInput: arr = [-1,-2], k = 7\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 105\n1 <= k <= 105\n-104 <= arr[i] <= 104 Explanation:\n\nSolution 1: Prefix Sum + Case Discussion\nWe denote the sum of all elements in the array $arr$ as $s$, the maximum prefix sum as $mxPre$, the minimum prefix sum as $miPre$, and the maximum subarray sum as $mxSub$.\nWe traverse the array $arr$. For each element $x$, we update $s = s + x$, $mxPre = \\max(mxPre, s)$, $miPre = \\min(miPre, s)$, $mxSub = \\max(mxSub, s - miPre)$.\nNext, we consider the value of $k$:\n\nWhen $k = 1$, the answer is $mxSub$.\nWhen $k \\ge 2$, if the maximum subarray spans two $arr$, then the answer is $mxPre + mxSuf$, where $mxSuf = s - miPre$.\nWhen $k \\ge 2$ and $s > 0$, if the maximum subarray spans three $arr$, then the answer is $(k - 2) \\times s + mxPre + mxSuf$.\n\nFinally, we return the result of the answer modulo $10^9 + 7$.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array $arr$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.\nNote that:\n\nA number greater than 1 is called prime if it is divisible by only 1 and itself.\nAn integer val1 is a factor of another integer val2 if val2 / val1 is an integer.\n\n\u00a0\nExample 1:\n\nInput: nums = [2,4,3,7,10,6]\nOutput: 4\nExplanation:\nThe product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7.\nThere are 4 distinct prime factors so we return 4.\n\nExample 2:\n\nInput: nums = [2,4,8,16]\nOutput: 1\nExplanation:\nThe product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210.\nThere is 1 distinct prime factor so we return 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n2 <= nums[i] <= 1000 Explanation:\n\nSolution 1: Hash Table + Prime Factorization\nFor each element in the array, first perform prime factorization on it, and then add the decomposed prime factors to the hash table. Finally, return the size of the hash table.\nThe time complexity is $O(n \\times \\sqrt{m})$, and the space complexity is $O(\\frac{m}{\\log m})$. Where $n$ and $m$ are the length of the array and the maximum value in the array, respectively. \n\n", "problem_ids": ["largest-subarray-length-k", "k-concatenation-maximum-sum", "distinct-prime-factors-of-product-of-array"]}, "3174": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two strings low and high that represent two integers low and high where low <= high, return the number of strobogrammatic numbers in the range [low, high].\nA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\u00a0\nExample 1:\nInput: low = \"50\", high = \"100\"\nOutput: 3\n\nExample 2:\nInput: low = \"0\", high = \"0\"\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= low.length, high.length <= 15\nlow and high consist of only digits.\nlow <= high\nlow and high do not contain any leading zeros except for zero itself. Explanation:\n\nSolution 1: Recursion\nIf the length is $1$, then the strobogrammatic numbers are only $0, 1, 8$; if the length is $2$, then the strobogrammatic numbers are only $11, 69, 88, 96$.\nWe design a recursive function $dfs(u)$, which returns the strobogrammatic numbers of length $u$.\nIf $u$ is $0$, return a list containing an empty string, i.e., [\"\"]; if $u$ is $1$, return the list [\"0\", \"1\", \"8\"].\nIf $u$ is greater than $1$, we traverse all the strobogrammatic numbers of length $u - 2$. For each strobogrammatic number $v$, we add $1, 8, 6, 9$ to both sides of it, and we can get the strobogrammatic numbers of length $u$.\nNote that if $u \\neq n$, we can also add $0$ to both sides of the strobogrammatic number.\nLet the lengths of $low$ and $high$ be $a$ and $b$ respectively.\nNext, we traverse all lengths in the range $[a,..b]$. For each length $n$, we get all strobogrammatic numbers $dfs(n)$, and then check whether they are in the range $[low, high]$. If they are, we increment the answer.\nThe time complexity is $O(2^{n+2} \\times \\log n)$.\nSimilar problems:\n\n247. Strobogrammatic Number II \n\nSimilar Problem 2 \n\n Problem:\n\nIn a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\nReturn the maximum amount of gold you can collect under the conditions:\n\nEvery time you are located in a cell you will collect all the gold in that cell.\nFrom your position, you can walk one step to the left, right, up, or down.\nYou can't visit the same cell more than once.\nNever visit a cell with 0 gold.\nYou can start and stop collecting gold from any position in the grid that has some gold.\n\n\u00a0\nExample 1:\n\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n\nExample 2:\n\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 15\n0 <= grid[i][j] <= 100\nThere are at most 25 cells containing gold. Explanation:\n\nSolution 1: DFS\nWe can enumerate each cell as the starting point, and then start a depth-first search from the starting point. During the search process, whenever we encounter a non-zero cell, we turn it into zero and continue the search. When we can no longer continue the search, we calculate the total amount of gold in the current path, then turn the current cell back into a non-zero cell, thus performing backtracking.\nThe time complexity is $O(m \\times n \\times 3^k)$, where $k$ is the maximum length of each path. Since each cell can only be visited once at most, the time complexity will not exceed $O(m \\times n \\times 3^k)$. The space complexity is $O(m \\times n)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed array nums and a 0-indexed array queries.\nYou can do the following operation at the beginning at most once:\n\nReplace nums with a subsequence of nums.\n\nWe start processing queries in the given order; for each query, we do the following:\n\nIf the first and the last element of nums is less than queries[i], the processing of queries ends.\nOtherwise, we choose either the first or the last element of nums if it is greater than or equal to queries[i], and we remove the chosen element from nums.\n\nReturn the maximum number of queries that can be processed by doing the operation optimally.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4,5], queries = [1,2,3,4,6]\nOutput: 4\nExplanation: We don't do any operation and process the queries as follows:\n1- We choose and remove nums[0] since 1 <= 1, then nums becomes [2,3,4,5].\n2- We choose and remove nums[0] since 2 <= 2, then nums becomes [3,4,5].\n3- We choose and remove nums[0] since 3 <= 3, then nums becomes [4,5].\n4- We choose and remove nums[0] since 4 <= 4, then nums becomes [5].\n5- We can not choose any elements from nums since they are not greater than or equal to 5.\nHence, the answer is 4.\nIt can be shown that we can't process more than 4 queries.\n\nExample 2:\n\nInput: nums = [2,3,2], queries = [2,2,3]\nOutput: 3\nExplanation: We don't do any operation and process the queries as follows:\n1- We choose and remove nums[0] since 2 <= 2, then nums becomes [3,2].\n2- We choose and remove nums[1] since 2 <= 2, then nums becomes [3].\n3- We choose and remove nums[0] since 3 <= 3, then nums becomes [].\nHence, the answer is 3.\nIt can be shown that we can't process more than 3 queries.\n\nExample 3:\n\nInput: nums = [3,4,3], queries = [4,3,2]\nOutput: 2\nExplanation: First we replace nums with the subsequence of nums [4,3].\nThen we can process the queries as follows:\n1- We choose and remove nums[0] since 4 <= 4, then nums becomes [3].\n2- We choose and remove nums[0] since 3 <= 3, then nums becomes [].\n3- We can not process any more queries since nums is empty.\nHence, the answer is 2.\nIt can be shown that we can't process more than 2 queries.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= queries.length <= 1000\n1 <= nums[i], queries[i] <= 109 Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i][j]$ as the maximum number of queries we can handle when the numbers in the interval $[i, j]$ have not been deleted yet.\nConsider $f[i][j]$:\n\nIf $i > 0$, the value of $f[i][j]$ can be transferred from $f[i - 1][j]$. If $nums[i - 1] \\ge queries[f[i - 1][j]]$, we can choose to delete $nums[i - 1]$. Therefore, we have $f[i][j] = f[i - 1][j] + (nums[i - 1] \\ge queries[f[i - 1][j]])$.\nIf $j + 1 < n$, the value of $f[i][j]$ can be transferred from $f[i][j + 1]$. If $nums[j + 1] \\ge queries[f[i][j + 1]]$, we can choose to delete $nums[j + 1]$. Therefore, we have $f[i][j] = f[i][j + 1] + (nums[j + 1] \\ge queries[f[i][j + 1]])$.\nIf $f[i][j] = m$, we can directly return $m$.\n\nThe final answer is $\\max\\limits_{0 \\le i < n} f[i][i] + (nums[i] \\ge queries[f[i][i]])$.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["strobogrammatic-number-iii", "path-with-maximum-gold", "maximum-number-of-removal-queries-that-can-be-processed-i"]}, "3176": {"text": "Similar Problem 1 \n\n Problem:\n\nThere are n people in a social group labeled from 0 to n - 1. You are given an array logs where logs[i] = [timestampi, xi, yi] indicates that xi and yi will be friends at the time timestampi.\nFriendship is symmetric. That means if a is friends with b, then b is friends with a. Also, person a is acquainted with a person b if a is friends with b, or a is a friend of someone acquainted with b.\nReturn the earliest time for which every person became acquainted with every other person. If there is no such earliest time, return -1.\n\u00a0\nExample 1:\n\nInput: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], n = 6\nOutput: 20190301\nExplanation: \nThe first event occurs at timestamp = 20190101, and after 0 and 1 become friends, we have the following friendship groups [0,1], [2], [3], [4], [5].\nThe second event occurs at timestamp = 20190104, and after 3 and 4 become friends, we have the following friendship groups [0,1], [2], [3,4], [5].\nThe third event occurs at timestamp = 20190107, and after 2 and 3 become friends, we have the following friendship groups [0,1], [2,3,4], [5].\nThe fourth event occurs at timestamp = 20190211, and after 1 and 5 become friends, we have the following friendship groups [0,1,5], [2,3,4].\nThe fifth event occurs at timestamp = 20190224, and as 2 and 4 are already friends, nothing happens.\nThe sixth event occurs at timestamp = 20190301, and after 0 and 3 become friends, we all become friends.\n\nExample 2:\n\nInput: logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4\nOutput: 3\nExplanation: At timestamp = 3, all the persons (i.e., 0, 1, 2, and 3) become friends.\n\n\u00a0\nConstraints:\n\n2 <= n <= 100\n1 <= logs.length <= 104\nlogs[i].length == 3\n0 <= timestampi <= 109\n0 <= xi, yi <= n - 1\nxi != yi\nAll the values timestampi are unique.\nAll the pairs (xi, yi) occur at most one time in the input. Explanation:\n\nSolution 1: Sorting + Union-Find\nWe sort all the logs in ascending order by timestamp, then traverse the sorted logs. Using a union-find set, we check whether the two people in the current log are already friends. If they are not friends, we merge them into one friend circle, until everyone is in one friend circle, then return the timestamp of the current log.\nIf we have traversed all the logs and not everyone is in one friend circle, then return $-1$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the number of logs. \n\nSimilar Problem 2 \n\n Problem:\n\nWe call a string s of even length n an anti-palindrome if for each index 0 <= i < n, s[i] != s[n - i - 1].\nGiven a string s, your task is to make s an anti-palindrome by doing any number of operations (including zero).\nIn one operation, you can select two characters from s and swap them.\nReturn the resulting string. If multiple strings meet the conditions, return the lexicographically smallest one. If it can't be made into an anti-palindrome, return \"-1\".\n\u00a0\nExample 1:\n\nInput: s = \"abca\"\nOutput: \"aabc\"\nExplanation:\n\"aabc\" is an anti-palindrome string since s[0] != s[3] and s[1] != s[2]. Also, it is a rearrangement of \"abca\".\n\nExample 2:\n\nInput: s = \"abba\"\nOutput: \"aabb\"\nExplanation:\n\"aabb\" is an anti-palindrome string since s[0] != s[3] and s[1] != s[2]. Also, it is a rearrangement of \"abba\".\n\nExample 3:\n\nInput: s = \"cccd\"\nOutput: \"-1\"\nExplanation:\nYou can see that no matter how you rearrange the characters of \"cccd\", either s[0] == s[3] or s[1] == s[2]. So it can not form an anti-palindrome string.\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 105\ns.length % 2 == 0\ns consists only of lowercase English letters. Explanation:\n\nSolution 1: Greedy + Sorting\nThe problem asks us to transform the string $s$ into the lexicographically smallest non-palindrome string. We might as well sort the string $s$ first.\nNext, we only need to compare whether the two middle characters $s[m]$ and $s[m-1]$ are equal. If they are equal, we find the first character $s[i]$ in the second half that is not equal to $s[m]$, use a pointer $j$ to point to $m$, and then swap $s[i]$ and $s[j]$. If we can't find such a character $s[i]$, it means that the string $s$ cannot be transformed into a non-palindrome string, return \"1\". Otherwise, perform the swap operation, move $i$ and $j$ to the right, compare whether $s[j]$ and $s[n-j-1]$ are equal, if they are equal, continue to perform the swap operation until $i$ exceeds the length of the string.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the string $s$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed string s, and a 2D array of integers queries, where queries[i] = [li, ri] indicates a substring of s starting from the index li and ending at the index ri (both inclusive), i.e. s[li..ri].\nReturn an array ans where ans[i] is the number of same-end substrings of queries[i].\nA 0-indexed string t of length n is called same-end if it has the same character at both of its ends, i.e., t[0] == t[n - 1].\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nExample 1:\n\nInput: s = \"abcaab\", queries = [[0,0],[1,4],[2,5],[0,5]]\nOutput: [1,5,5,10]\nExplanation: Here is the same-end substrings of each query:\n1st query: s[0..0] is \"a\" which has 1 same-end substring: \"a\".\n2nd query: s[1..4] is \"bcaa\" which has 5 same-end substrings: \"bcaa\", \"bcaa\", \"bcaa\", \"bcaa\", \"bcaa\".\n3rd query: s[2..5] is \"caab\" which has 5 same-end substrings: \"caab\", \"caab\", \"caab\", \"caab\", \"caab\".\n4th query: s[0..5] is \"abcaab\" which has 10 same-end substrings: \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\".\n\nExample 2:\n\nInput: s = \"abcd\", queries = [[0,3]]\nOutput: [4]\nExplanation: The only query is s[0..3] which is \"abcd\". It has 4 same-end substrings: \"abcd\", \"abcd\", \"abcd\", \"abcd\".\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 3 * 104\ns consists only of lowercase English letters.\n1 <= queries.length <= 3 * 104\nqueries[i] = [li, ri]\n0 <= li <= ri < s.length Explanation:\n\nSolution 1: Prefix Sum + Enumeration\nWe can preprocess the prefix sum for each letter and record it in the array $cnt$, where $cnt[i][j]$ represents the number of times the $i$-th letter appears in the first $j$ characters. In this way, for each interval $[l, r]$, we can enumerate each letter $c$ in the interval, quickly calculate the number of times $c$ appears in the interval $x$ using the prefix sum array. We can arbitrarily choose two of them to form a tail-equal substring, the number of substrings is $C_x^2=\\frac{x(x-1)}{2}$, plus the situation where each letter in the interval can form a tail-equal substring alone, there are $r - l + 1$ letters in total. Therefore, for each query $[l, r]$, the number of tail-equal substrings that meet the conditions is $r - l + 1 + \\sum_{c \\in \\Sigma} \\frac{x_c(x_c-1)}{2}$, where $x_c$ represents the number of times the letter $c$ appears in the interval $[l, r]$.\nThe time complexity is $O((n + m) \\times |\\Sigma|)$, and the space complexity is $O(n \\times |\\Sigma|)$. Here, $n$ and $m$ are the lengths of the string $s$ and the number of queries, respectively, and $\\Sigma$ represents the set of letters appearing in the string $s$, in this problem $|\\Sigma|=26$. \n\n", "problem_ids": ["the-earliest-moment-when-everyone-become-friends", "make-string-anti-palindrome", "number-of-same-end-substrings"]}, "3183": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a list of strings of the same length words and a string target.\nYour task is to form target using the given words under the following rules:\n\ntarget should be formed from left to right.\nTo form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].\nOnce you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\nRepeat the process until you form the string target.\n\nNotice that you can use multiple characters from the same string in words provided the conditions above are met.\nReturn the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\nOutput: 6\nExplanation: There are 6 ways to form target.\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\nExample 2:\n\nInput: words = [\"abba\",\"baab\"], target = \"bab\"\nOutput: 4\nExplanation: There are 4 ways to form target.\n\"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 2 (\"abba\")\n\"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 3 (\"baab\")\n\"bab\" -> index 0 (\"baab\"), index 2 (\"baab\"), index 3 (\"baab\")\n\"bab\" -> index 1 (\"abba\"), index 2 (\"baab\"), index 3 (\"baab\")\n\n\u00a0\nConstraints:\n\n1 <= words.length <= 1000\n1 <= words[i].length <= 1000\nAll strings in words have the same length.\n1 <= target.length <= 1000\nwords[i] and target contain only lowercase English letters. Explanation:\n\nSolution 1: Preprocessing + Memory Search\nWe noticed that the length of each string in the string array $words$ is the same, so let's remember $n$, then we can preprocess a two-dimensional array $cnt$, where $cnt[j][c]$ represents the string array $words$ The number of characters $c$ in the $j$-th position of.\nNext, we design a function $dfs(i, j)$, which represents the number of schemes that construct $target[i,..]$ and the currently selected character position from $words$ is $j$. Then the answer is $dfs(0, 0)$.\nThe calculation logic of function $dfs(i, j)$ is as follows:\n\nIf $i \\geq m$, it means that all characters in $target$ have been selected, then the number of schemes is $1$.\nIf $j \\geq n$, it means that all characters in $words$ have been selected, then the number of schemes is $0$.\nOtherwise, we can choose not to select the character in the $j$-th position of $words$, then the number of schemes is $dfs(i, j + 1)$; or we choose the character in the $j$-th position of $words$, then the number of schemes is $dfs(i + 1, j + 1) \\times cnt[j][target[i] - 'a']$.\n\nFinally, we return $dfs(0, 0)$. Note that the answer is taken in modulo operation.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Where $m$ is the length of the string $target$, and $n$ is the length of each string in the string array $words$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\u00a0\nExample 1:\n\nInput: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.\n\nExample 2:\n\nInput: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".\n\nExample 3:\n\nInput: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned.\n\n\u00a0\nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters. Explanation:\n\nSolution 1: Simulation\nWe iterate through the array words, for each string w, we determine if it is a palindrome. If it is, then we return w; otherwise, we continue to iterate.\nTo determine if a string is a palindrome, we can use two pointers, one pointing to the start and the other to the end of the string, moving towards the center, and checking if the corresponding characters are equal. If, after traversing the entire string, no unequal characters are found, then the string is a palindrome.\nThe time complexity is $O(L)$, where $L$ is the sum of the lengths of all strings in the array words. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an integer array nums and an integer k, return the number of good subarrays of nums.\nA subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,1,1,1], k = 10\nOutput: 1\nExplanation: The only good subarray is the array nums itself.\n\nExample 2:\n\nInput: nums = [3,1,4,3,2,2,4], k = 2\nOutput: 4\nExplanation: There are 4 different good subarrays:\n- [3,1,4,3,2,2] that has 2 pairs.\n- [3,1,4,3,2,2,4] that has 3 pairs.\n- [1,4,3,2,2,4] that has 2 pairs.\n- [4,3,2,2,4] that has 2 pairs.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i], k <= 109 Explanation:\n\nSolution 1: Hash Table + Two Pointers\nIf a subarray contains $k$ pairs of identical elements, then an array that contains this subarray must contain at least $k$ pairs of identical elements.\nWe use a hash table $cnt$ to count the number of occurrences of each element in the window, use $cur$ to count the number of pairs of identical elements in the window, and use $i$ to maintain the left endpoint of the window.\nWe traverse the array $nums$, take the current element $x$ as the right endpoint, then the number of pairs of identical elements in the window will increase by $cnt[x]$, and the occurrence times of $x$ will be increased by one, i.e., $cnt[x] \\leftarrow cnt[x] + 1$. Next, we loop to judge whether the number of pairs of identical elements in the window is greater than or equal to $k$ after removing the left endpoint. If it is greater than or equal to $k$, then we decrease the occurrence times of the left endpoint element by one, i.e., $cnt[nums[i]] \\leftarrow cnt[nums[i]] - 1$, and decrease the number of pairs of identical elements in the window by $cnt[nums[i]]$, i.e., $cur \\leftarrow cur - cnt[nums[i]]$, and move the left endpoint to the right, i.e., $i \\leftarrow i + 1$. At this time, all elements to the left of the window left endpoint and the left endpoint itself can be used as the left endpoint of the current right endpoint, so the answer is increased by $i + 1$.\nFinally, we return the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["number-of-ways-to-form-a-target-string-given-a-dictionary", "find-first-palindromic-string-in-the-array", "count-the-number-of-good-subarrays"]}, "3184": {"text": "Similar Problem 1 \n\n Problem:\n\nAn ant is on a boundary. It sometimes goes left and sometimes right.\nYou are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element:\n\nIf nums[i] < 0, it moves left by -nums[i] units.\nIf nums[i] > 0, it moves right by nums[i] units.\n\nReturn the number of times the ant returns to the boundary.\nNotes:\n\nThere is an infinite space on both sides of the boundary.\nWe check whether the ant is on the boundary only after it has moved |nums[i]| units. In other words, if the ant crosses the boundary during its movement, it does not count.\n\n\u00a0\nExample 1:\n\nInput: nums = [2,3,-5]\nOutput: 1\nExplanation: After the first step, the ant is 2 steps to the right of the boundary.\nAfter the second step, the ant is 5 steps to the right of the boundary.\nAfter the third step, the ant is on the boundary.\nSo the answer is 1.\n\nExample 2:\n\nInput: nums = [3,2,-3,-4]\nOutput: 0\nExplanation: After the first step, the ant is 3 steps to the right of the boundary.\nAfter the second step, the ant is 5 steps to the right of the boundary.\nAfter the third step, the ant is 2 steps to the right of the boundary.\nAfter the fourth step, the ant is 2 steps to the left of the boundary.\nThe ant never returned to the boundary, so the answer is 0.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100\n-10 <= nums[i] <= 10\nnums[i] != 0 Explanation:\n\nSolution 1: Prefix Sum\nBased on the problem description, we only need to calculate how many zeros are in all prefix sums of nums.\nThe time complexity is $O(n)$, where $n$ is the length of nums. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n\nA board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.\nA board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.\n\nWe drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a \"V\" shaped pattern between two boards or if a board redirects the ball into either wall of the box.\nReturn an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\nOutput: [1,-1,-1,-1,-1]\nExplanation: This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n\nExample 2:\n\nInput: grid = [[-1]]\nOutput: [-1]\nExplanation: The ball gets stuck against the left wall.\n\nExample 3:\n\nInput: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\nOutput: [0,1,2,3,4,-1]\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\ngrid[i][j] is 1 or -1. Explanation:\n\nSolution 1: Case Discussion + DFS\nWe can use DFS to simulate the movement of the ball. We design a function $dfs(i, j)$, which represents that the ball starts from the $i$th row and the $j$th column, and finally falls in which column. The ball will get stuck in the following situations:\n\nThe ball is in the leftmost column, and the cell's vane directs the ball to the left.\nThe ball is in the rightmost column, and the cell's vane directs the ball to the right.\nThe cell's vane where the ball is located directs the ball to the right, and the vane of the cell adjacent to the right of the ball directs the ball to the left.\nThe cell's vane where the ball is located directs the ball to the left, and the vane of the cell adjacent to the left of the ball directs the ball to the right.\n\nIf any of the above situations are met, we can judge that the ball will get stuck and return $-1$. Otherwise, we can continue to recursively find the next position of the ball. Finally, if the ball reaches the last row, we can return the current column number.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m)$. Where $m$ and $n$ are the number of rows and columns of the array $grid$, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an integer n, return the maximum integer x such that x <= n, and the bitwise AND of all the numbers in the range [x, n] is 0.\n\u00a0\nExample 1:\n\nInput: n = 7\nOutput: 3\nExplanation:\nThe bitwise AND of [6, 7] is 6.\nThe bitwise AND of [5, 6, 7] is 4.\nThe bitwise AND of [4, 5, 6, 7] is 4.\nThe bitwise AND of [3, 4, 5, 6, 7] is 0.\n\nExample 2:\n\nInput: n = 9\nOutput: 7\nExplanation:\nThe bitwise AND of [7, 8, 9] is 0.\n\nExample 3:\n\nInput: n = 17\nOutput: 15\nExplanation:\nThe bitwise AND of [15, 16, 17] is 0.\n\n\u00a0\nConstraints:\n\n1 <= n <= 1015 Explanation:\n\nSolution 1: Bit Manipulation\nWe can find the highest bit of $1$ in the binary representation of $n$. The maximum $x$ must be less than $n$ and this bit is $0$, and all other lower bits are $1$, i.e., $x = 2^{\\textit{number of the highest bit}} - 1$. This is because $x \\textit{ and } (x + 1) = 0$ must hold.\nThe time complexity is $O(\\log n)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["ant-on-the-boundary", "where-will-the-ball-fall", "maximum-number-that-makes-result-of-bitwise-and-zero"]}, "3188": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums sorted in non-decreasing order and an integer k, return true if this array can be divided into one or more disjoint increasing subsequences of length at least k, or false otherwise.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,2,3,3,4,4], k = 3\nOutput: true\nExplanation: The array can be divided into two subsequences [1,2,3,4] and [2,3,4] with lengths at least 3 each.\n\nExample 2:\n\nInput: nums = [5,6,6,7,8], k = 3\nOutput: false\nExplanation: There is no way to divide the array using the conditions required.\n\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 105\n1 <= nums[i] <= 105\nnums is sorted in non-decreasing order. Explanation:\n\nSolution 1: Quick Thinking\nWe assume that the array can be divided into $m$ strictly increasing subsequences of length at least $k$. If the number of the most frequent number in the array is $cnt$, then these $cnt$ numbers must be in different subsequences, so $m \\geq cnt$. Also, since the length of $m$ subsequences is at least $k$, the fewer the number of subsequences, the better, so $m = cnt$. Therefore, $cnt \\times k \\leq n$ must be satisfied. Hence, we only need to count the number of the most frequent number $cnt$ in the array, and then judge whether $cnt \\times k \\leq n$. If it is, return true, otherwise return false.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed n x n grid where n is odd, and grid[r][c] is 0, 1, or 2.\nWe say that a cell belongs to the Letter Y if it belongs to one of the following:\n\nThe diagonal starting at the top-left cell and ending at the center cell of the grid.\nThe diagonal starting at the top-right cell and ending at the center cell of the grid.\nThe vertical line starting at the center cell and ending at the bottom border of the grid.\n\nThe Letter Y is written on the grid if and only if:\n\nAll values at cells belonging to the Y are equal.\nAll values at cells not belonging to the Y are equal.\nThe values at cells belonging to the Y are different from the values at cells not belonging to the Y.\n\nReturn the minimum number of operations needed to write the letter Y on the grid given that in one operation you can change the value at any cell to 0, 1, or 2.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,2,2],[1,1,0],[0,1,0]]\nOutput: 3\nExplanation: We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 1 while those that do not belong to Y are equal to 0.\nIt can be shown that 3 is the minimum number of operations needed to write Y on the grid.\n\nExample 2:\n\n\nInput: grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\nOutput: 12\nExplanation: We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 0 while those that do not belong to Y are equal to 2. \nIt can be shown that 12 is the minimum number of operations needed to write Y on the grid.\n\u00a0\nConstraints:\n\n3 <= n <= 49 \nn == grid.length == grid[i].length\n0 <= grid[i][j] <= 2\nn is odd. Explanation:\n\nSolution 1: Counting\nWe use two arrays of length 3, cnt1 and cnt2, to record the counts of cell values that belong to Y and do not belong to Y, respectively. Then we enumerate i and j, which represent the values of cells that belong to Y and do not belong to Y, respectively, to calculate the minimum number of operations.\nThe time complexity is $O(n^2)$, where $n$ is the size of the matrix. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\u00a0\nExample 1:\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\nInput: n = 1\nOutput: [\"()\"]\n\n\u00a0\nConstraints:\n\n1 <= n <= 8 Explanation:\n\nSolution 1: DFS + Pruning\nThe range of $n$ in the problem is $[1, 8]$, so we can directly solve this problem through \"brute force search + pruning\".\nWe design a function $dfs(l, r, t)$, where $l$ and $r$ represent the number of left and right brackets respectively, and $t$ represents the current bracket sequence. Then we can get the following recursive structure:\n\nIf $l \\gt n$ or $r \\gt n$ or $l \\lt r$, then the current bracket combination $t$ is invalid, return directly;\nIf $l = n$ and $r = n$, then the current bracket combination $t$ is valid, add it to the answer array ans, and return directly;\nWe can choose to add a left bracket, and recursively execute dfs(l + 1, r, t + \"(\");\nWe can also choose to add a right bracket, and recursively execute dfs(l, r + 1, t + \")\").\n\nThe time complexity is $O(2^{n\\times 2} \\times n)$, and the space complexity is $O(n)$. \n\n", "problem_ids": ["divide-array-into-increasing-sequences", "minimum-operations-to-write-the-letter-y-on-a-grid", "generate-parentheses"]}, "3190": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\u00a0\nExample 1:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n\nExample 2:\n\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\nExample 3:\n\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\u00a0\nConstraints:\n\nnums1.length == m + n\nnums2.length == n\n0 <= m, n <= 200\n1 <= m + n <= 200\n-109 <= nums1[i], nums2[j] <= 109\n\n\u00a0\nFollow up: Can you come up with an algorithm that runs in O(m + n) time? Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers $i$ and $j$ pointing to the end of two arrays, and a pointer $k$ pointing to the end of the merged array.\nEvery time we compare the two elements at the end of the two arrays, and move the larger one to the end of the merged array. Then we move the pointer one step forward, and repeat this process until the two pointers reach the start of the arrays.\nThe time complexity is $O(m + n)$, where $m$ and $n$ are the lengths of two arrays. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a binary string s and a positive integer k.\nA substring of s is beautiful if the number of 1's in it is exactly k.\nLet len be the length of the shortest beautiful substring.\nReturn the lexicographically smallest beautiful substring of string s with length equal to len. If s doesn't contain a beautiful substring, return an empty string.\nA string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.\n\nFor example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c.\n\n\u00a0\nExample 1:\n\nInput: s = \"100011001\", k = 3\nOutput: \"11001\"\nExplanation: There are 7 beautiful substrings in this example:\n1. The substring \"100011001\".\n2. The substring \"100011001\".\n3. The substring \"100011001\".\n4. The substring \"100011001\".\n5. The substring \"100011001\".\n6. The substring \"100011001\".\n7. The substring \"100011001\".\nThe length of the shortest beautiful substring is 5.\nThe lexicographically smallest beautiful substring with length 5 is the substring \"11001\".\n\nExample 2:\n\nInput: s = \"1011\", k = 2\nOutput: \"11\"\nExplanation: There are 3 beautiful substrings in this example:\n1. The substring \"1011\".\n2. The substring \"1011\".\n3. The substring \"1011\".\nThe length of the shortest beautiful substring is 2.\nThe lexicographically smallest beautiful substring with length 2 is the substring \"11\".\n\nExample 3:\n\nInput: s = \"000\", k = 1\nOutput: \"\"\nExplanation: There are no beautiful substrings in this example.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 100\n1 <= k <= s.length Explanation:\n\nSolution 1: Enumeration\nWe can enumerate all substrings $s[i: j]$, where $i \\lt j$, and check if they are beautiful substrings. If so, we update the answer.\nThe time complexity is $O(n^3)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string $s$. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\n\u00a0\nExample 1:\n\n\nInput: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\nOutput: true\nExplanation: There are two paths from vertex 0 to vertex 2:\n- 0 \u2192 1 \u2192 2\n- 0 \u2192 2\n\nExample 2:\n\n\nInput: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\nOutput: false\nExplanation: There is no path from vertex 0 to vertex 5.\n\n\u00a0\nConstraints:\n\n1 <= n <= 2 * 105\n0 <= edges.length <= 2 * 105\nedges[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\n0 <= source, destination <= n - 1\nThere are no duplicate edges.\nThere are no self edges. Explanation:\n\nSolution 1: DFS\nFirst, we convert edges into an adjacency list $g$, then use DFS to determine whether there is a path from source to destination.\nDuring the process, we use an array vis to record the vertices that have been visited to avoid repeated visits.\nThe time complexity is $O(n + m)$, and the space complexity is $O(n + m)$. Where $n$ and $m$ are the number of nodes and edges, respectively. \n\n", "problem_ids": ["merge-sorted-array", "shortest-and-lexicographically-smallest-beautiful-string", "find-if-path-exists-in-graph"]}, "3192": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array nums. We define a running sum of an array as\u00a0runningSum[i] = sum(nums[0]\u2026nums[i]).\nReturn the running sum of nums.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: [1,3,6,10]\nExplanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\nExample 2:\n\nInput: nums = [1,1,1,1,1]\nOutput: [1,2,3,4,5]\nExplanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].\nExample 3:\n\nInput: nums = [3,1,2,10,1]\nOutput: [3,4,6,16,17]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n-10^6\u00a0<= nums[i] <=\u00a010^6 Explanation:\n\nSolution 1: Prefix Sum\nWe directly traverse the array. For the current element $nums[i]$, we add it with the prefix sum $nums[i-1]$ to get the prefix sum $nums[i]$ of the current element.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.\nAn index i is good if the following formula holds:\n\n0 <= i < variables.length\n((aibi % 10)ci) % mi == target\n\nReturn an array consisting of good indices in any order.\n\u00a0\nExample 1:\n\nInput: variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2\nOutput: [0,2]\nExplanation: For each index i in the variables array:\n1) For the index 0, variables[0] = [2,3,3,10], (23 % 10)3 % 10 = 2.\n2) For the index 1, variables[1] = [3,3,3,1], (33 % 10)3 % 1 = 0.\n3) For the index 2, variables[2] = [6,1,1,4], (61 % 10)1 % 4 = 2.\nTherefore we return [0,2] as the answer.\n\nExample 2:\n\nInput: variables = [[39,3,1000,1000]], target = 17\nOutput: []\nExplanation: For each index i in the variables array:\n1) For the index 0, variables[0] = [39,3,1000,1000], (393 % 10)1000 % 1000 = 1.\nTherefore we return [] as the answer.\n\n\u00a0\nConstraints:\n\n1 <= variables.length <= 100\nvariables[i] == [ai, bi, ci, mi]\n1 <= ai, bi, ci, mi <= 103\n0 <= target <= 103 Explanation:\n\nSolution 1: Simulation + Fast Power\nWe can directly simulate according to the problem description. For the power operation modulo, we can use the fast power method to speed up the calculation.\nThe time complexity is $O(n \\times \\log M)$, where $n$ is the length of the array $variables$; and $M$ is the maximum value in $b_i$ and $c_i$, in this problem $M \\le 10^3$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two arrays of equal length, nums1 and nums2.\nEach element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x.\nAs a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.\nReturn the integer x.\n\u00a0\nExample 1:\n\nInput: nums1 = [2,6,4], nums2 = [9,7,5]\nOutput: 3\nExplanation:\nThe integer added to each element of nums1 is 3.\n\nExample 2:\n\nInput: nums1 = [10], nums2 = [5]\nOutput: -5\nExplanation:\nThe integer added to each element of nums1 is -5.\n\nExample 3:\n\nInput: nums1 = [1,1,1,1], nums2 = [1,1,1,1]\nOutput: 0\nExplanation:\nThe integer added to each element of nums1 is 0.\n\n\u00a0\nConstraints:\n\n1 <= nums1.length == nums2.length <= 100\n0 <= nums1[i], nums2[i] <= 1000\nThe test cases are generated in a way that there is an integer x such that nums1 can become equal to nums2 by adding x to each element of nums1. Explanation:\n\nSolution 1: Calculate Minimum Difference\nWe can find the minimum value of each array, then return the difference between the two minimum values.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["running-sum-of-1d-array", "double-modular-exponentiation", "find-the-integer-added-to-array-i"]}, "3193": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\u00a0\nExample 1:\n\n\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n\nExample 2:\n\n\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\n-100 <= Node.val <= 100\n\n\u00a0\nFollow up: Could you solve it both recursively and iteratively? Explanation:\n\nSolution 1: Recursion\nWe design a function $dfs(root1, root2)$ to determine whether two binary trees are symmetric. The answer is $dfs(root, root)$.\nThe logic of the function $dfs(root1, root2)$ is as follows:\n\nIf both $root1$ and $root2$ are null, then the two binary trees are symmetric, return true.\nIf only one of $root1$ and $root2$ is null, or if $root1.val \\neq root2.val$, then the two binary trees are not symmetric, return false.\nOtherwise, determine whether the left subtree of $root1$ is symmetric to the right subtree of $root2$, and whether the right subtree of $root1$ is symmetric to the left subtree of $root2$. Here we use recursion.\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\nReturn the number of hills and valleys in nums.\n\u00a0\nExample 1:\n\nInput: nums = [2,4,1,1,6,5]\nOutput: 3\nExplanation:\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\nExample 2:\n\nInput: nums = [6,6,5,5,4,1]\nOutput: 0\nExplanation:\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n\n\u00a0\nConstraints:\n\n3 <= nums.length <= 100\n1 <= nums[i] <= 100 Explanation:\n\nSolution 1: Traversal\nWe initialize a pointer $j$ to point to the position with index $0$, and then traverse the array in the range $[1, n-1]$. For each position $i$:\n\nIf $nums[i] = nums[i+1]$, then skip.\nOtherwise, if $nums[i]$ is greater than $nums[j]$ and $nums[i]$ is greater than $nums[i+1]$, then $i$ is a peak; if $nums[i]$ is less than $nums[j]$ and $nums[i]$ is less than $nums[i+1]$, then $i$ is a valley.\nThen, we update $j$ to $i$ and continue to traverse.\n\nAfter the traversal, we can get the number of peaks and valleys.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.\nThe array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.\nReturn the minimum number of moves required to make nums complementary.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,4,3], limit = 4\nOutput: 1\nExplanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed).\nnums[0] + nums[3] = 1 + 3 = 4.\nnums[1] + nums[2] = 2 + 2 = 4.\nnums[2] + nums[1] = 2 + 2 = 4.\nnums[3] + nums[0] = 3 + 1 = 4.\nTherefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.\n\nExample 2:\n\nInput: nums = [1,2,2,1], limit = 2\nOutput: 2\nExplanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit.\n\nExample 3:\n\nInput: nums = [1,2,1,2], limit = 2\nOutput: 0\nExplanation: nums is already complementary.\n\n\u00a0\nConstraints:\n\nn == nums.length\n2 <= n\u00a0<=\u00a0105\n1 <= nums[i]\u00a0<= limit <=\u00a0105\nn is even. Explanation:\n\nSolution 1: Difference Array\nAssume that in the final array, the sum of the pair $\\textit{nums}[i]$ and $\\textit{nums}[n-i-1]$ is $s$.\nLet's denote $x$ as the smaller value between $\\textit{nums}[i]$ and $\\textit{nums}[n-i-1]$, and $y$ as the larger value.\nFor each pair of numbers, we have the following scenarios:\n\nIf no replacement is needed, then $x + y = s$.\nIf one replacement is made, then $x + 1 \\le s \\le y + \\textit{limit}$.\nIf two replacements are made, then $2 \\le s \\le x$ or $y + \\textit{limit} + 1 \\le s \\le 2 \\times \\textit{limit}$.\n\nThat is:\n\nIn the range $[2,..x]$, $2$ replacements are needed.\nIn the range $[x+1,..x+y-1]$, $1$ replacement is needed.\nAt $[x+y]$, no replacement is needed.\nIn the range $[x+y+1,..y + \\textit{limit}]$, $1$ replacement is needed.\nIn the range $[y + \\textit{limit} + 1,..2 \\times \\textit{limit}]$, $2$ replacements are needed.\n\nWe enumerate each pair of numbers and use a difference array to update the number of replacements needed in different ranges for each pair.\nFinally, we find the minimum value among the prefix sums from index $2$ to $2 \\times \\textit{limit}$, which is the minimum number of replacements needed.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $\\textit{nums}$.\nSimilar problems:\n\n3224. Minimum Array Changes to Make Differences Equal \n\n", "problem_ids": ["symmetric-tree", "count-hills-and-valleys-in-an-array", "minimum-moves-to-make-array-complementary"]}, "3194": {"text": "Similar Problem 1 \n\n Problem:\n\nA school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.\nYou are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).\nReturn the number of indices where heights[i] != expected[i].\n\u00a0\nExample 1:\n\nInput: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation: \nheights:  [1,1,4,2,1,3]\nexpected: [1,1,1,2,3,4]\nIndices 2, 4, and 5 do not match.\n\nExample 2:\n\nInput: heights = [5,1,2,3,4]\nOutput: 5\nExplanation:\nheights:  [5,1,2,3,4]\nexpected: [1,2,3,4,5]\nAll indices do not match.\n\nExample 3:\n\nInput: heights = [1,2,3,4,5]\nOutput: 0\nExplanation:\nheights:  [1,2,3,4,5]\nexpected: [1,2,3,4,5]\nAll indices match.\n\n\u00a0\nConstraints:\n\n1 <= heights.length <= 100\n1 <= heights[i] <= 100 Explanation:\n\nSolution 1: Sorting\nWe can first sort the heights of the students, then compare the sorted heights with the original heights, and count the positions that are different.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the number of students. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an m x n picture consisting of black 'B' and white 'W' pixels, return the number of black lonely pixels.\nA black lonely pixel is a character 'B' that located at a specific position where the same row and same column don't have any other black pixels.\n\u00a0\nExample 1:\n\n\nInput: picture = [[\"W\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"W\"]]\nOutput: 3\nExplanation: All the three 'B's are black lonely pixels.\n\nExample 2:\n\n\nInput: picture = [[\"B\",\"B\",\"B\"],[\"B\",\"B\",\"W\"],[\"B\",\"B\",\"B\"]]\nOutput: 0\n\n\u00a0\nConstraints:\n\nm ==\u00a0picture.length\nn ==\u00a0picture[i].length\n1 <= m, n <= 500\npicture[i][j] is 'W' or 'B'. Explanation:\n\nSolution 1: Counting + Enumeration\nAccording to the problem description, we need to count the number of black pixels in each row and column, which are recorded in the arrays rows and cols respectively. Then we traverse each black pixel, check whether there is only one black pixel in its row and column. If so, we increment the answer by one.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m + n)$, where $m$ and $n$ are the number of rows and columns in the matrix respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].\nReturn the maximum difference. If no such i and j exists, return -1.\n\u00a0\nExample 1:\n\nInput: nums = [7,1,5,4]\nOutput: 4\nExplanation:\nThe maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.\nNote that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.\n\nExample 2:\n\nInput: nums = [9,4,3,2]\nOutput: -1\nExplanation:\nThere is no i and j such that i < j and nums[i] < nums[j].\n\nExample 3:\n\nInput: nums = [1,5,2,10]\nOutput: 9\nExplanation:\nThe maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.\n\n\u00a0\nConstraints:\n\nn == nums.length\n2 <= n <= 1000\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Maintaining Prefix Minimum\nWe use a variable $\\textit{mi}$ to represent the minimum value among the elements currently being traversed, and a variable $\\textit{ans}$ to represent the maximum difference. Initially, $\\textit{mi}$ is set to $+\\infty$, and $\\textit{ans}$ is set to $-1$.\nTraverse the array. For the current element $x$, if $x \\gt \\textit{mi}$, update $\\textit{ans}$ to $\\max(\\textit{ans}, x - \\textit{mi})$. Otherwise, update $\\textit{mi}$ to $x$.\nAfter the traversal, return $\\textit{ans}$.\nTime complexity is $O(n)$, where $n$ is the length of the array. Space complexity is $O(1)$. \n\n", "problem_ids": ["height-checker", "lonely-pixel-i", "maximum-difference-between-increasing-elements"]}, "3195": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array nums and an integer m, with each element nums[i] satisfying 0 <= nums[i] < 2m, return an array answer. The answer array should be of the same length as nums, where each element answer[i] represents the maximum Hamming distance between nums[i] and any other element nums[j] in the array.\nThe Hamming distance between two binary integers is defined as the number of positions at which the corresponding bits differ (add leading zeroes if needed).\n\u00a0\nExample 1:\n\nInput: nums = [9,12,9,11], m = 4\nOutput: [2,3,2,3]\nExplanation:\nThe binary representation of nums = [1001,1100,1001,1011].\nThe maximum hamming distances for each index are:\n\nnums[0]: 1001 and 1100 have a distance of 2.\nnums[1]: 1100 and 1011 have a distance of 3.\nnums[2]: 1001 and 1100 have a distance of 2.\nnums[3]: 1011 and 1100 have a distance of 3.\n\n\nExample 2:\n\nInput: nums = [3,4,6,10], m = 4\nOutput: [3,3,2,3]\nExplanation:\nThe binary representation of nums = [0011,0100,0110,1010].\nThe maximum hamming distances for each index are:\n\nnums[0]: 0011 and 0100 have a distance of 3.\nnums[1]: 0100 and 0011 have a distance of 3.\nnums[2]: 0110 and 1010 have a distance of 2.\nnums[3]: 1010 and 0100 have a distance of 3.\n\n\n\u00a0\nConstraints:\n\n1 <= m <= 17\n2 <= nums.length <= 2m\n0 <= nums[i] < 2m Explanation:\n\nSolution 1: Reverse Thinking + BFS\nThe problem requires us to find the maximum Hamming distance between each element and other elements in the array. We can think in reverse: for each element, we take its complement and find the minimum Hamming distance to other elements in the array. Then, the maximum Hamming distance we are looking for is $m$ minus this minimum Hamming distance.\nWe can use Breadth-First Search (BFS) to find the minimum Hamming distance from each complemented element to other elements.\nThe specific steps are as follows:\n\nInitialize an array $\\textit{dist}$ with a length of $2^m$ to record the minimum Hamming distance from each complemented element to other elements. Initially, all are set to $-1$.\nTraverse the array $\\textit{nums}$, set the complement of each element to $0$, and add it to the queue $\\textit{q}$.\nStarting from $k = 1$, continuously traverse the queue $\\textit{q}$. Each time, take out the elements in the queue, perform $m$ complement operations on them, add the complemented elements to the queue $\\textit{t}$, and set the minimum Hamming distance to the original element to $k$.\nRepeat step 3 until the queue is empty.\n\nFinally, we traverse the array $\\textit{nums}$, take the complement of each element as the index, and take out the corresponding minimum Hamming distance from the $\\textit{dist}$ array. Then, $m$ minus this value is the maximum Hamming distance we are looking for.\nThe time complexity is $O(2^m)$, and the space complexity is $O(2^m)$, where $m$ is the integer given in the problem. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].\nReturn the maximum difference. If no such i and j exists, return -1.\n\u00a0\nExample 1:\n\nInput: nums = [7,1,5,4]\nOutput: 4\nExplanation:\nThe maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.\nNote that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.\n\nExample 2:\n\nInput: nums = [9,4,3,2]\nOutput: -1\nExplanation:\nThere is no i and j such that i < j and nums[i] < nums[j].\n\nExample 3:\n\nInput: nums = [1,5,2,10]\nOutput: 9\nExplanation:\nThe maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.\n\n\u00a0\nConstraints:\n\nn == nums.length\n2 <= n <= 1000\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Maintaining Prefix Minimum\nWe use a variable $\\textit{mi}$ to represent the minimum value among the elements currently being traversed, and a variable $\\textit{ans}$ to represent the maximum difference. Initially, $\\textit{mi}$ is set to $+\\infty$, and $\\textit{ans}$ is set to $-1$.\nTraverse the array. For the current element $x$, if $x \\gt \\textit{mi}$, update $\\textit{ans}$ to $\\max(\\textit{ans}, x - \\textit{mi})$. Otherwise, update $\\textit{mi}$ to $x$.\nAfter the traversal, return $\\textit{ans}$.\nTime complexity is $O(n)$, where $n$ is the length of the array. Space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums. You can apply the following operation any number of times:\n\nPick any element from nums and put it at the end of nums.\n\nThe prefix sum array of nums is an array prefix of the same length as nums such that prefix[i] is the sum of all the integers nums[j] where j is in the inclusive range [0, i].\nReturn the minimum number of operations such that the prefix sum array does not contain negative integers. The test cases are generated such that it is always possible to make the prefix sum array non-negative.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,-5,4]\nOutput: 0\nExplanation: we do not need to do any operations.\nThe array is [2,3,-5,4]. The prefix sum array is [2, 5, 0, 4].\n\nExample 2:\n\nInput: nums = [3,-5,-2,6]\nOutput: 1\nExplanation: we can do one operation on index 1.\nThe array after the operation is [3,-2,6,-5]. The prefix sum array is [3, 1, 7, 2].\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109 Explanation:\n\nSolution 1: Greedy + Priority Queue (Min Heap)\nWe use a variable $s$ to record the prefix sum of the current array.\nTraverse the array $nums$, add the current element $x$ to the prefix sum $s$. If $x$ is a negative number, add $x$ to the min heap. If $s$ is negative at this time, greedily take out the smallest negative number and subtract it from $s$, and add one to the answer. Finally, return the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["maximum-hamming-distances", "maximum-difference-between-increasing-elements", "make-the-prefix-sum-non-negative"]}, "3196": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.\n\u00a0\nExample 1:\n\nInput: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\nOutput: 16\nExplanation: The two words can be \"abcw\", \"xtfn\".\n\nExample 2:\n\nInput: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\nOutput: 4\nExplanation: The two words can be \"ab\", \"cd\".\n\nExample 3:\n\nInput: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\nOutput: 0\nExplanation: No such pair of words.\n\n\u00a0\nConstraints:\n\n2 <= words.length <= 1000\n1 <= words[i].length <= 1000\nwords[i] consists only of lowercase English letters. Explanation:\n\nSolution 1: Bit Manipulation\nThe problem requires us to find two strings without common letters, so that their length product is maximized. We can represent each string with a binary number $mask[i]$, where each bit of this binary number indicates whether the string contains a certain letter. If two strings do not have common letters, then the bitwise AND result of the two binary numbers corresponding to these strings is $0$, that is, $mask[i] \\& mask[j] = 0$.\nWe traverse each string. For the current string $words[i]$ we are traversing, we first calculate the corresponding binary number $mask[i]$, and then traverse all strings $words[j]$ where $j \\in [0, i)$. We check whether $mask[i] \\& mask[j] = 0$ holds. If it holds, we update the answer to $\\max(ans, |words[i]| \\times |words[j]|)$.\nAfter the traversal, we return the answer.\nThe time complexity is $O(n^2 + L)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string array $words$, and $L$ is the sum of the lengths of all strings in the string array. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven two arrays nums1\u00a0and nums2.\nReturn the maximum dot product\u00a0between\u00a0non-empty subsequences of nums1 and nums2 with the same length.\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie,\u00a0[2,3,5]\u00a0is a subsequence of\u00a0[1,2,3,4,5]\u00a0while [1,5,3]\u00a0is not).\n\u00a0\nExample 1:\n\nInput: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\nOutput: 18\nExplanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\nTheir dot product is (2*3 + (-2)*(-6)) = 18.\nExample 2:\n\nInput: nums1 = [3,-2], nums2 = [2,-6,7]\nOutput: 21\nExplanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\nTheir dot product is (3*7) = 21.\nExample 3:\n\nInput: nums1 = [-1,-1], nums2 = [1,1]\nOutput: -1\nExplanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\nTheir dot product is -1.\n\u00a0\nConstraints:\n\n1 <= nums1.length, nums2.length <= 500\n-1000 <= nums1[i], nums2[i] <= 1000 Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i][j]$ to represent the maximum dot product of two subsequences formed by the first $i$ elements of $\\textit{nums1}$ and the first $j$ elements of $\\textit{nums2}$. Initially, $f[i][j] = -\\infty$.\nFor $f[i][j]$, we have the following cases:\n\nDo not select $\\textit{nums1}[i-1]$ or do not select $\\textit{nums2}[j-1]$, i.e., $f[i][j] = \\max(f[i-1][j], f[i][j-1])$;\nSelect $\\textit{nums1}[i-1]$ and $\\textit{nums2}[j-1]$, i.e., $f[i][j] = \\max(f[i][j], \\max(0, f[i-1][j-1]) + \\textit{nums1}[i-1] \\times \\textit{nums2}[j-1])$.\n\nThe final answer is $f[m][n]$.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the lengths of the arrays $\\textit{nums1}$ and $\\textit{nums2}$, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed string array words.\nLet's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:\n\nisPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise.\n\nFor example, isPrefixAndSuffix(\"aba\", \"ababa\") is true because \"aba\" is a prefix of \"ababa\" and also a suffix, but isPrefixAndSuffix(\"abc\", \"abcd\") is false.\nReturn an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.\n\u00a0\nExample 1:\n\nInput: words = [\"a\",\"aba\",\"ababa\",\"aa\"]\nOutput: 4\nExplanation: In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"a\", \"aba\") is true.\ni = 0 and j = 2 because isPrefixAndSuffix(\"a\", \"ababa\") is true.\ni = 0 and j = 3 because isPrefixAndSuffix(\"a\", \"aa\") is true.\ni = 1 and j = 2 because isPrefixAndSuffix(\"aba\", \"ababa\") is true.\nTherefore, the answer is 4.\nExample 2:\n\nInput: words = [\"pa\",\"papa\",\"ma\",\"mama\"]\nOutput: 2\nExplanation: In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"pa\", \"papa\") is true.\ni = 2 and j = 3 because isPrefixAndSuffix(\"ma\", \"mama\") is true.\nTherefore, the answer is 2.  \nExample 3:\n\nInput: words = [\"abab\",\"ab\"]\nOutput: 0\nExplanation: In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(\"abab\", \"ab\") is false.\nTherefore, the answer is 0.\n\u00a0\nConstraints:\n\n1 <= words.length <= 50\n1 <= words[i].length <= 10\nwords[i] consists only of lowercase English letters. Explanation:\n\nSolution 1: Enumeration\nWe can enumerate all index pairs $(i, j)$, where $i < j$, and then determine whether words[i] is a prefix or suffix of words[j]. If it is, we increment the count.\nThe time complexity is $O(n^2 \\times m)$, where $n$ and $m$ are the length of words and the maximum length of the strings, respectively. \n\n", "problem_ids": ["maximum-product-of-word-lengths", "max-dot-product-of-two-subsequences", "count-prefix-and-suffix-pairs-i"]}, "3199": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer n and an array sick sorted in increasing order, representing positions of infected people in a line of n people.\nAt each step, one uninfected person adjacent to an infected person gets infected. This process continues until everyone is infected.\nAn infection sequence is the order in which uninfected people become infected, excluding those initially infected.\nReturn the number of different infection sequences possible, modulo 109+7.\n\u00a0\nExample 1:\n\nInput: n = 5, sick = [0,4]\nOutput: 4\nExplanation:\nThere is a total of 6 different sequences overall.\n\nValid infection sequences are [1,2,3], [1,3,2], [3,2,1] and [3,1,2].\n[2,3,1] and [2,1,3] are not valid infection sequences because the person at index 2 cannot be infected at the first step.\n\n\nExample 2:\n\nInput: n = 4, sick = [1]\nOutput: 3\nExplanation:\nThere is a total of 6 different sequences overall.\n\nValid infection sequences are [0,2,3], [2,0,3] and [2,3,0].\n[3,2,0], [3,0,2], and [0,3,2] are not valid infection sequences because the infection starts at the person at index 1, then the order of infection is 2, then 3, and hence 3 cannot be infected earlier than 2.\n\n\n\u00a0\nConstraints:\n\n2 <= n <= 105\n1 <= sick.length <= n - 1\n0 <= sick[i] <= n - 1\nsick is sorted in increasing order. Explanation:\n\nSolution 1: Combinatorial Mathematics + Multiplicative Inverse + Fast Power\nAccording to the problem description, the children who have a cold have divided the children who have not yet caught a cold into several continuous segments. We can use an array $nums$ to record the number of children who are not cold in each segment, and there are a total of $s = \\sum_{i=0}^{k} nums[k]$ children who are not cold. We can find that the number of cold sequences is the number of permutations of $s$ different elements, that is, $s!$.\nAssuming that there is only one transmission scheme for each segment of children who are not cold, there are $\\frac{s!}{\\prod_{i=0}^{k} nums[k]!}$ cold sequences in total.\nNext, we consider the transmission scheme of each segment of children who are not cold. Suppose there are $x$ children in a segment who are not cold, then they have $2^{x-1}$ transmission schemes, because each time you can choose one end from the left and right ends of a segment to transmit, that is: two choices, there are a total of $x-1$ transmissions. However, if it is the first segment or the last segment, there is only one choice.\nIn summary, the total number of cold sequences is:\n$$\n\\frac{s!}{\\prod_{i=0}^{k} nums[k]!} \\prod_{i=1}^{k-1} 2^{nums[i]-1}\n$$\nFinally, we need to consider that the answer may be very large and need to be modulo $10^9 + 7$. Therefore, we need to preprocess the factorial and multiplicative inverse.\nThe time complexity is $O(m)$, where $m$ is the length of the array $sick$. Ignoring the space consumption of the preprocessing array, the space complexity is $O(m)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.\n\u00a0\nExample 1:\n\nInput: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.\nExample 2:\n\nInput: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.\n\nExample 3:\n\nInput: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 2000\n0 <= nums[i] <= 105 Explanation:\n\nSolution 1: Hash Table\nWe use a hash table $cnt$ to count the occurrence of all even elements, and then find the even element with the highest occurrence and the smallest value.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nThere are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\nThe positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\nAt any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.\nReturn the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.\nNote that\n\nAll robots move at the same speed.\nIf two robots move in the same direction, they will never collide.\nIf two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\nIf a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\nIf the robot moved from a position x to a position y, the distance it moved is |y - x|.\n\n\u00a0\nExample 1:\n\n\nInput: robot = [0,4,6], factory = [[2,2],[6,2]]\nOutput: 4\nExplanation: As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n\nExample 2:\n\n\nInput: robot = [1,-1], factory = [[-2,1],[2,1]]\nOutput: 2\nExplanation: As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.\n\n\u00a0\nConstraints:\n\n1 <= robot.length, factory.length <= 100\nfactory[j].length == 2\n-109 <= robot[i], positionj <= 109\n0 <= limitj <= robot.length\nThe input will be generated such that it is always possible to repair every robot. Explanation:\n\nSolution 1: Memoization Search\nFirst, we sort the robots and factories in ascending order. Then we define a function $dfs(i, j)$ to represent the minimum total moving distance starting from the $i$-th robot and the $j$-th factory.\nFor $dfs(i, j)$, if the $j$-th factory does not repair the robot, then $dfs(i, j) = dfs(i, j+1)$. If the $j$-th factory repairs the robot, we can enumerate the number of robots repaired by the $j$-th factory and find the minimum total moving distance. That is, $dfs(i, j) = min(dfs(i + k + 1, j + 1) + \\sum_{t = 0}^{k} |robot[i + t] - factory[j][0]|)$.\nThe time complexity is $O(m^2 \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of robots and factories, respectively. \n\n", "problem_ids": ["count-the-number-of-infection-sequences", "most-frequent-even-element", "minimum-total-distance-traveled"]}, "3200": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two strings, word1 and word2. You want to construct a string in the following manner:\n\nChoose some non-empty subsequence subsequence1 from word1.\nChoose some non-empty subsequence subsequence2 from word2.\nConcatenate the subsequences: subsequence1 + subsequence2, to make the string.\n\nReturn the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0.\nA subsequence of a string s is a string that can be made by deleting some (possibly none) characters from s without changing the order of the remaining characters.\nA palindrome is a string that reads the same forward\u00a0as well as backward.\n\u00a0\nExample 1:\n\nInput: word1 = \"cacb\", word2 = \"cbba\"\nOutput: 5\nExplanation: Choose \"ab\" from word1 and \"cba\" from word2 to make \"abcba\", which is a palindrome.\nExample 2:\n\nInput: word1 = \"ab\", word2 = \"ab\"\nOutput: 3\nExplanation: Choose \"ab\" from word1 and \"a\" from word2 to make \"aba\", which is a palindrome.\nExample 3:\n\nInput: word1 = \"aa\", word2 = \"bb\"\nOutput: 0\nExplanation: You cannot construct a palindrome from the described method, so return 0.\n\u00a0\nConstraints:\n\n1 <= word1.length, word2.length <= 1000\nword1 and word2 consist of lowercase English letters. Explanation:\n\nSolution 1: Dynamic Programming\nFirst, we concatenate strings word1 and word2 to get string $s$. Then we can transform the problem into finding the length of the longest palindromic subsequence in string $s$. However, when calculating the final answer, we need to ensure that at least one character in the palindrome string comes from word1 and another character comes from word2.\nWe define $f[i][j]$ as the length of the longest palindromic subsequence in the substring of string $s$ with index range $[i, j]$.\nIf $s[i] = s[j]$, then $s[i]$ and $s[j]$ must be in the longest palindromic subsequence, at this time $f[i][j] = f[i + 1][j - 1] + 2$. At this point, we also need to judge whether $s[i]$ and $s[j]$ come from word1 and word2. If so, we update the maximum value of the answer to $ans=\\max(ans, f[i][j])$.\nIf $s[i] \\neq s[j]$, then $s[i]$ and $s[j]$ will definitely not appear in the longest palindromic subsequence at the same time, at this time $f[i][j] = max(f[i + 1][j], f[i][j - 1])$.\nFinally, we return the answer.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of string $s$. \n\nSimilar Problem 2 \n\n Problem:\n\nTwo players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n.\nInitially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue.\nThen, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\nIf (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\nYou are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false.\n\u00a0\nExample 1:\n\n\nInput: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\nOutput: true\nExplanation: The second player can choose the node with value 2.\n\nExample 2:\n\nInput: root = [1,2,3], n = 3, x = 1\nOutput: false\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is n.\n1 <= x <= n <= 100\nn is odd.\n1 <= Node.val <= n\nAll the values of the tree are unique. Explanation:\n\nSolution 1: DFS\nFirst, we use DFS to find the node where player 1's colored point $x$ is located, denoted as $node$.\nNext, we count the number of nodes in the left and right subtrees of $node$, denoted as $l$ and $r$ respectively, and the number of nodes in the direction of $node$'s parent node is $n - l - r - 1$. As long as $\\max(l, r, n - l - r - 1) > \\frac{n}{2}$, player 2 has a winning strategy.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the total number of nodes. \n\nSimilar Problem 3 \n\n Problem:\n\nA sentence is a list of words that are separated by a single space with no leading or trailing spaces. For example, \"Hello World\", \"HELLO\", \"hello world hello world\" are all sentences. Words consist of only uppercase and lowercase English letters.\nTwo sentences sentence1 and sentence2 are similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences such that the two sentences become equal. For example, sentence1 = \"Hello my name is Jane\" and sentence2 = \"Hello Jane\" can be made equal by inserting \"my name is\" between \"Hello\" and \"Jane\" in sentence2.\nGiven two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.\n\u00a0\nExample 1:\n\nInput: sentence1 = \"My name is Haley\", sentence2 = \"My Haley\"\nOutput: true\nExplanation: sentence2 can be turned to sentence1 by inserting \"name is\" between \"My\" and \"Haley\".\n\nExample 2:\n\nInput: sentence1 = \"of\", sentence2 = \"A lot of words\"\nOutput: false\nExplanation: No single sentence can be inserted inside one of the sentences to make it equal to the other.\n\nExample 3:\n\nInput: sentence1 = \"Eating right now\", sentence2 = \"Eating\"\nOutput: true\nExplanation: sentence2 can be turned to sentence1 by inserting \"right now\" at the end of the sentence.\n\n\u00a0\nConstraints:\n\n1 <= sentence1.length, sentence2.length <= 100\nsentence1 and sentence2 consist of lowercase and uppercase English letters and spaces.\nThe words in sentence1 and sentence2 are separated by a single space. Explanation:\n\nSolution 1: Two Pointers\nWe split the two sentences into two word arrays words1 and words2 by spaces. Let the lengths of words1 and words2 be $m$ and $n$, respectively, and assume that $m \\ge nn.\nWe use two pointers $i$ and $j$, initially $i = j = 0$. Next, we loop to check whether words1[i] is equal to words2[i], and if so, pointer $i$ continues to move right; then we loop to check whether words1[m - 1 - j] is equal to words2[n - 1 - j], and if so, pointer $j$ continues to move right.\nAfter the loop, if $i + j \\ge n$, it means that the two sentences are similar, and we return true; otherwise, we return false.\nThe time complexity is $O(L)$, and the space complexity is $O(L)$, where $L$ is the sum of the lengths of the two sentences. \n\n", "problem_ids": ["maximize-palindrome-length-from-subsequences", "binary-tree-coloring-game", "sentence-similarity-iii"]}, "3203": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.\nThe elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\nReturn an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.\n\u00a0\nExample 1:\n\n\nInput: original = [1,2,3,4], m = 2, n = 2\nOutput: [[1,2],[3,4]]\nExplanation: The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n\nExample 2:\n\nInput: original = [1,2,3], m = 1, n = 3\nOutput: [[1,2,3]]\nExplanation: The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n\nExample 3:\n\nInput: original = [1,2], m = 1, n = 1\nOutput: []\nExplanation: There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.\n\n\u00a0\nConstraints:\n\n1 <= original.length <= 5 * 104\n1 <= original[i] <= 105\n1 <= m, n <= 4 * 104 Explanation:\n\nSolution 1: Simulation\nAccording to the problem description, we know that to construct an $m$-row and $n$-column two-dimensional array, it needs to satisfy that $m \\times n$ equals the length of the original array. If it does not satisfy, return an empty array directly.\nIf it does satisfy, we can follow the process described in the problem, and put the elements from the original array into the two-dimensional array in order.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the two-dimensional array, respectively. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\n\na 1-day pass is sold for costs[0] dollars,\na 7-day pass is sold for costs[1] dollars, and\na 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n\u00a0\nExample 1:\n\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n\nExample 2:\n\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n\n\u00a0\nConstraints:\n\n1 <= days.length <= 365\n1 <= days[i] <= 365\ndays is in strictly increasing order.\ncosts.length == 3\n1 <= costs[i] <= 1000 Explanation:\n\nSolution 1: Memoization Search + Binary Search\nWe define a function $\\textit{dfs(i)}$, which represents the minimum cost required from the $i$-th trip to the last trip. Thus, the answer is $\\textit{dfs(0)}$.\nThe execution process of the function $\\textit{dfs(i)}$ is as follows:\n\nIf $i \\geq n$, it means all trips have ended, return $0$;\nOtherwise, we need to consider three types of purchases: buying a 1-day pass, buying a 7-day pass, and buying a 30-day pass. We calculate the cost for these three purchasing methods separately and use binary search to find the index $j$ of the next trip, then recursively call $\\textit{dfs(j)}$, and finally return the minimum cost among these three purchasing methods.\n\nTo avoid repeated calculations, we use memoization search to save the results that have already been calculated.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ represents the number of trips. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums of length n, and a positive integer k.\nThe power of a subsequence is defined as the minimum absolute difference between any two elements in the subsequence.\nReturn the sum of powers of all subsequences of nums which have length equal to k.\nSince the answer may be large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4], k = 3\nOutput: 4\nExplanation:\nThere are 4 subsequences in nums which have length 3: [1,2,3], [1,3,4], [1,2,4], and [2,3,4]. The sum of powers is |2 - 3| + |3 - 4| + |2 - 1| + |3 - 4| = 4.\n\nExample 2:\n\nInput: nums = [2,2], k = 2\nOutput: 0\nExplanation:\nThe only subsequence in nums which has length 2 is\u00a0[2,2]. The sum of powers is |2 - 2| = 0.\n\nExample 3:\n\nInput: nums = [4,3,-1], k = 2\nOutput: 10\nExplanation:\nThere are 3 subsequences in nums which have length 2: [4,3], [4,-1], and [3,-1]. The sum of powers is |4 - 3| + |4 - (-1)| + |3 - (-1)| = 10.\n\n\u00a0\nConstraints:\n\n2 <= n == nums.length <= 50\n-108 <= nums[i] <= 108 \n2 <= k <= n Explanation:\n\nSolution 1: Memoization Search\nGiven the problem involves the minimum difference between elements of a subsequence, we might as well sort the array $\\textit{nums}$, which facilitates the calculation of the minimum difference between subsequence elements.\nNext, we design a function $dfs(i, j, k, mi)$, representing the value of the energy sum when processing the $i$-th element, the last selected element is the $j$-th element, $k$ more elements need to be selected, and the current minimum difference is $mi$. Therefore, the answer is $dfs(0, n, k, +\\infty)$ (If the last selected element is the $n$-th element, it indicates that no element has been selected before).\nThe execution process of the function $dfs(i, j, k, mi)$ is as follows:\n\nIf $i \\geq n$, it means all elements have been processed. If $k = 0$, return $mi$; otherwise, return $0$.\nIf the remaining number of elements $n - i$ is less than $k$, return $0$.\nOtherwise, we can choose not to select the $i$-th element, and the energy sum obtained is $dfs(i + 1, j, k, mi)$.\nWe can also choose to select the $i$-th element. If $j = n$, it means no element has been selected before, then the energy sum obtained is $dfs(i + 1, i, k - 1, mi)$; otherwise, the energy sum obtained is $dfs(i + 1, i, k - 1, \\min(mi, \\textit{nums}[i] - \\textit{nums}[j]))$.\nWe add up the above results and return the result modulo $10^9 + 7$.\n\nTo avoid repeated calculations, we can use memoization, saving the results that have already been calculated.\nThe time complexity is $O(n^4 \\times k)$, and the space complexity is $O(n^4 \\times k)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["convert-1d-array-into-2d-array", "minimum-cost-for-tickets", "find-the-sum-of-subsequence-powers"]}, "3206": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: cities\n\n+-------------+---------+\n| Column Name | Type    | \n+-------------+---------+\n| state       | varchar |\n| city        | varchar |\n+-------------+---------+\n(state, city) is the primary key (combination of columns with unique values) for this table.\nEach row of this table contains the state name and the city name within that state.\n\nWrite a solution to find all the cities in each state and combine them into a single comma-separated string.\nReturn the result table ordered by state in ascending order.\nThe result format is in the following example.\n\u00a0\nExample:\n\nInput:\ncities table:\n\n+-------------+---------------+\n| state       | city          |\n+-------------+---------------+\n| California  | Los Angeles   |\n| California  | San Francisco |\n| California  | San Diego     |\n| Texas       | Houston       |\n| Texas       | Austin        |\n| Texas       | Dallas        |\n| New York    | New York City |\n| New York    | Buffalo       |\n| New York    | Rochester     |\n+-------------+---------------+\n\nOutput:\n\n+-------------+---------------------------------------+\n| state       | cities                                |\n+-------------+---------------------------------------+\n| California  | Los Angeles, San Diego, San Francisco |\n| New York    | Buffalo, New York City, Rochester     |\n| Texas       | Austin, Dallas, Houston               |\n+-------------+---------------------------------------+\n\nExplanation:\n\nCalifornia: All cities (\"Los Angeles\", \"San Diego\", \"San Francisco\") are listed in a comma-separated string.\nNew York: All cities (\"Buffalo\", \"New York City\", \"Rochester\") are listed in a comma-separated string.\nTexas: All cities (\"Austin\", \"Dallas\", \"Houston\") are listed in a comma-separated string.\n\nNote: The output table is ordered by the state name in ascending order. Explanation:\n\nSolution 1: Grouping and Aggregation\nWe can first group by the state field, then sort the city field within each group, and finally use the GROUP_CONCAT function to concatenate the sorted city names into a comma-separated string.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nSELECT\n    state,\n    GROUP_CONCAT(city ORDER BY city SEPARATOR ', ') cities\nFROM cities\nGROUP BY 1\nORDER BY 1;\n```\nPandas\n```python\nimport pandas as pd\ndef find_cities(cities: pd.DataFrame) -> pd.DataFrame:\n    result = (\n        cities.groupby(\"state\")[\"city\"]\n        .apply(lambda x: \", \".join(sorted(x)))\n        .reset_index()\n    )\n    result.columns = [\"state\", \"cities\"]\n    return result\n``` \n\nSimilar Problem 2 \n\n Problem:\n\nAlice and Bob are playing a game on a string.\nYou are given a string s, Alice and Bob will take turns playing the following game where Alice starts first:\n\nOn Alice's turn, she has to remove any non-empty substring from s that contains an odd number of vowels.\nOn Bob's turn, he has to remove any non-empty substring from s that contains an even number of vowels.\n\nThe first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play optimally.\nReturn true if Alice wins the game, and false otherwise.\nThe English vowels are: a, e, i, o, and u.\n\u00a0\nExample 1:\n\nInput: s = \"leetcoder\"\nOutput: true\nExplanation:\nAlice can win the game as follows:\n\nAlice plays first, she can delete the underlined substring in s = \"leetcoder\" which contains 3 vowels. The resulting string is s = \"der\".\nBob plays second, he can delete the underlined substring in s = \"der\" which contains 0 vowels. The resulting string is s = \"er\".\nAlice plays third, she can delete the whole string s = \"er\" which contains 1 vowel.\nBob plays fourth, since the string is empty, there is no valid play for Bob. So Alice wins the game.\n\n\nExample 2:\n\nInput: s = \"bbcd\"\nOutput: false\nExplanation:\nThere is no valid play for Alice in her first turn, so Alice loses the game.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists only of lowercase English letters. Explanation:\n\nSolution 1: Brain Teaser\nLet's denote the number of vowels in the string as $k$.\nIf $k = 0$, meaning there are no vowels in the string, then Little Red cannot remove any substring, and Little Ming wins directly.\nIf $k$ is odd, then Little Red can remove the entire string, resulting in a direct win for Little Red.\nIf $k$ is even, then Little Red can remove $k - 1$ vowels, leaving one vowel in the string. In this case, Little Ming cannot remove any substring, leading to a direct win for Little Red.\nIn conclusion, if the string contains vowels, then Little Red wins; otherwise, Little Ming wins.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.\n\u00a0\nExample 1:\n\nInput: skill = [3,2,5,1,3,4]\nOutput: 22\nExplanation: \nDivide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\nThe sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.\n\nExample 2:\n\nInput: skill = [3,4]\nOutput: 12\nExplanation: \nThe two players form a team with a total skill of 7.\nThe chemistry of the team is 3 * 4 = 12.\n\nExample 3:\n\nInput: skill = [1,1,2,3]\nOutput: -1\nExplanation: \nThere is no way to divide the players into teams such that the total skill of each team is equal.\n\n\u00a0\nConstraints:\n\n2 <= skill.length <= 105\nskill.length is even.\n1 <= skill[i] <= 1000 Explanation:\n\nSolution 1: Sorting\nTo make all 2-person teams have equal skill points, the minimum value must match the maximum value. Therefore, we sort the skill array, and then use two pointers $i$ and $j$ to point to the beginning and end of the array respectively, match them in pairs, and judge whether their sum is the same number.\nIf not, it means that the skill points cannot be equal, and we directly return $-1$. Otherwise, we add the chemical reaction to the answer.\nAt the end of the traversal, we return the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Where $n$ is the length of the skill array. \n\n", "problem_ids": ["find-cities-in-each-state", "vowels-game-in-a-string", "divide-players-into-teams-of-equal-skill"]}, "3207": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two positive integers x and y, denoting the number of coins with values 75 and 10 respectively.\nAlice and Bob are playing a game. Each turn, starting with Alice, the player must pick up coins with a total value 115. If the player is unable to do so, they lose the game.\nReturn the name of the player who wins the game if both players play optimally.\n\u00a0\nExample 1:\n\nInput: x = 2, y = 7\nOutput: \"Alice\"\nExplanation:\nThe game ends in a single turn:\n\nAlice picks 1 coin with a value of 75 and 4 coins with a value of 10.\n\n\nExample 2:\n\nInput: x = 4, y = 11\nOutput: \"Bob\"\nExplanation:\nThe game ends in 2 turns:\n\nAlice picks 1 coin with a value of 75 and 4 coins with a value of 10.\nBob picks 1 coin with a value of 75 and 4 coins with a value of 10.\n\n\n\u00a0\nConstraints:\n\n1 <= x, y <= 100 Explanation:\n\nSolution 1: Mathematics\nSince each round of operation consumes $2$ coins valued at $75$ and $8$ coins valued at $10$, we can calculate the number of rounds $k = \\min(x / 2, y / 8)$, and then update the values of $x$ and $y$, where $x$ and $y$ are the remaining number of coins after $k$ rounds of operations.\nIf $x > 0$ and $y \\geq 4$, then Alice can continue the operation, and Bob loses, return \"Alice\"; otherwise, return \"Bob\".\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a string s consisting only of lowercase English letters. We call a substring special if it contains no character which has occurred at least twice (in other words, it does not contain a repeating character). Your task is to count the number of special substrings. For example, in the string \"pop\", the substring \"po\" is a special substring, however, \"pop\" is not special (since 'p' has occurred twice).\nReturn the number of special substrings.\nA substring is a contiguous sequence of characters within a string. For example, \"abc\" is a substring of \"abcd\", but \"acd\" is not.\n\u00a0\nExample 1:\n\nInput: s = \"abcd\"\nOutput: 10\nExplanation: Since each character occurs once, every substring is a special substring. We have 4 substrings of length one, 3 of length two, 2 of length three, and 1 substring of length four. So overall there are 4 + 3 + 2 + 1 = 10 special substrings.\n\nExample 2:\n\nInput: s = \"ooo\"\nOutput: 3\nExplanation: Any substring with a length of at least two contains a repeating character. So we have to count the number of substrings of length one, which is 3.\n\nExample 3:\n\nInput: s = \"abab\"\nOutput: 7\nExplanation: Special substrings are as follows (sorted by their start positions):\nSpecial substrings of length 1: \"a\", \"b\", \"a\", \"b\"\nSpecial substrings of length 2: \"ab\", \"ba\", \"ab\"\nAnd it can be shown that there are no special substrings with a length of at least three. So the answer would be 4 + 3 = 7.\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists of lowercase English letters Explanation:\n\nSolution 1: Counting + Two Pointers\nWe use two pointers $j$ and $i$ to represent the left and right boundaries of the current substring, and an array $cnt$ of length $26$ to count the occurrence of each character in the current substring. We traverse the string from left to right. Each time we traverse to position $i$, we increase the occurrence of $s[i]$, and then check whether $s[i]$ appears at least twice. If so, we need to decrease the occurrence of $s[j]$ and move $j$ one step to the right, until the occurrence of $s[i]$ does not exceed once. In this way, we get the length of the longest special substring ending with $s[i]$, which is $i - j + 1$, so the number of special substrings ending with $s[i]$ is $i - j + 1$. Finally, we add up the number of special substrings ending at each position to get the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(C)$. Here, $n$ is the length of the string $s$, and $C$ is the size of the character set. In this problem, the character set consists of lowercase English letters, so $C = 26$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given positive integers low, high, and k.\nA number is beautiful if it meets both of the following conditions:\n\nThe count of even digits in the number is equal to the count of odd digits.\nThe number is divisible by k.\n\nReturn the number of beautiful integers in the range [low, high].\n\u00a0\nExample 1:\n\nInput: low = 10, high = 20, k = 3\nOutput: 2\nExplanation: There are 2 beautiful integers in the given range: [12,18]. \n- 12 is beautiful because it contains 1 odd digit and 1 even digit, and is divisible by k = 3.\n- 18 is beautiful because it contains 1 odd digit and 1 even digit, and is divisible by k = 3.\nAdditionally we can see that:\n- 16 is not beautiful because it is not divisible by k = 3.\n- 15 is not beautiful because it does not contain equal counts even and odd digits.\nIt can be shown that there are only 2 beautiful integers in the given range.\n\nExample 2:\n\nInput: low = 1, high = 10, k = 1\nOutput: 1\nExplanation: There is 1 beautiful integer in the given range: [10].\n- 10 is beautiful because it contains 1 odd digit and 1 even digit, and is divisible by k = 1.\nIt can be shown that there is only 1 beautiful integer in the given range.\n\nExample 3:\n\nInput: low = 5, high = 5, k = 2\nOutput: 0\nExplanation: There are 0 beautiful integers in the given range.\n- 5 is not beautiful because it is not divisible by k = 2 and it does not contain equal even and odd digits.\n\n\u00a0\nConstraints:\n\n0 < low <= high <= 109\n0 < k <= 20 Explanation:\n\nSolution 1: Digit DP\nWe notice that the problem is asking for the number of beautiful integers in the interval $[low, high]$. For such an interval $[l,..r]$ problem, we can usually consider transforming it into finding the answers for $[1, r]$ and $[1, l-1]$, and then subtracting the latter from the former. Moreover, the problem only involves the relationship between different digits, not the specific values, so we can consider using Digit DP to solve it.\nWe design a function $dfs(pos, mod, diff, lead, limit)$, which represents the number of schemes when we are currently processing the $pos$-th digit, the result of the current number modulo $k$ is $mod$, the difference between the odd and even digits of the current number is $diff$, whether the current number has leading zeros is $lead$, and whether the current number has reached the upper limit is $limit$.\nThe execution logic of the function $dfs(pos, mod, diff, lead, limit)$ is as follows:\nIf $pos$ exceeds the length of $num$, it means that we have processed all the digits. If $mod=0$ and $diff=0$ at this time, it means that the current number meets the requirements of the problem, so we return $1$, otherwise we return $0$.\nOtherwise, we calculate the upper limit $up$ of the current digit, and then enumerate the digit $i$ in the range $[0,..up]$:\n\nIf $i=0$ and $lead$ is true, it means that the current number only contains leading zeros. We recursively calculate the value of $dfs(pos + 1, mod, diff, 1, limit\\ and\\ i=up)$ and add it to the answer.\nOtherwise, we update the value of $diff$ according to the parity of $i$, and then recursively calculate the value of $dfs(pos + 1, (mod \\times 10 + i) \\bmod k, diff, 0, limit\\ and\\ i=up)$ and add it to the answer.\n\nFinally, we return the answer.\nIn the main function, we calculate the answers $a$ and $b$ for $[1, high]$ and $[1, low-1]$ respectively. The final answer is $a-b$.\nThe time complexity is $O((\\log M)^2 \\times k \\times |\\Sigma|)$, and the space complexity is $O((\\log M)^2 \\times k)$, where $M$ represents the size of the number $high$, and $|\\Sigma|$ represents the digit set.\nSimilar problems:\n\n2719. Count of Integers \n\n", "problem_ids": ["find-the-winning-player-in-coin-game", "count-substrings-without-repeating-character", "number-of-beautiful-integers-in-the-range"]}, "3209": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e., the\u00a0length of the garden is n).\nThere are n + 1 taps located at points [0, 1, ..., n] in the garden.\nGiven an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.\nReturn the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.\n\u00a0\nExample 1:\n\n\nInput: n = 5, ranges = [3,4,1,1,0,0]\nOutput: 1\nExplanation: The tap at point 0 can cover the interval [-3,3]\nThe tap at point 1 can cover the interval [-3,5]\nThe tap at point 2 can cover the interval [1,3]\nThe tap at point 3 can cover the interval [2,4]\nThe tap at point 4 can cover the interval [4,4]\nThe tap at point 5 can cover the interval [5,5]\nOpening Only the second tap will water the whole garden [0,5]\n\nExample 2:\n\nInput: n = 3, ranges = [0,0,0,0]\nOutput: -1\nExplanation: Even if you activate all the four taps you cannot water the whole garden.\n\n\u00a0\nConstraints:\n\n1 <= n <= 104\nranges.length == n + 1\n0 <= ranges[i] <= 100 Explanation:\n\nSolution 1: Greedy\nWe note that for all taps that can cover a certain left endpoint, choosing the tap that can cover the farthest right endpoint is optimal.\nTherefore, we can preprocess the array $ranges$. For the $i$-th tap, it can cover the left endpoint $l = \\max(0, i - ranges[i])$ and the right endpoint $r = i + ranges[i]$. We calculate the position of the tap that can cover the left endpoint $l$ with the farthest right endpoint and record it in the array $last[i]$.\nThen we define the following three variables:\n\nVariable $ans$ represents the final answer, i.e., the minimum number of taps;\nVariable $mx$ represents the farthest right endpoint that can currently be covered;\nVariable $pre$ represents the farthest right endpoint covered by the previous tap.\n\nWe traverse all positions in the range $[0, \\ldots, n-1]$. For the current position $i$, we use $last[i]$ to update $mx$, i.e., $mx = \\max(mx, last[i])$.\n\nIf $mx \\leq i$, it means the next position cannot be covered, so we return $-1$.\nIf $pre = i$, it means a new subinterval needs to be used, so we increment $ans$ by $1$ and update $pre = mx$.\n\nAfter the traversal, we return $ans$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the garden.\nSimilar problems:\n\n45. Jump Game II\n55. Jump Game\n1024. Video Stitching \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.\nReturn true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.\nAn integer x is covered by an interval ranges[i] = [starti, endi] if starti <= x <= endi.\n\u00a0\nExample 1:\n\nInput: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\nOutput: true\nExplanation: Every integer between 2 and 5 is covered:\n- 2 is covered by the first range.\n- 3 and 4 are covered by the second range.\n- 5 is covered by the third range.\n\nExample 2:\n\nInput: ranges = [[1,10],[10,20]], left = 21, right = 21\nOutput: false\nExplanation: 21 is not covered by any range.\n\n\u00a0\nConstraints:\n\n1 <= ranges.length <= 50\n1 <= starti <= endi <= 50\n1 <= left <= right <= 50 Explanation:\n\nSolution 1: Difference Array\nWe can use the idea of a difference array to create a difference array $\\textit{diff}$ of length $52$.\nNext, we iterate through the array $\\textit{ranges}$. For each interval $[l, r]$, we increment $\\textit{diff}[l]$ by $1$ and decrement $\\textit{diff}[r + 1]$ by $1$.\nThen, we iterate through the difference array $\\textit{diff}$, maintaining a prefix sum $s$. For each position $i$, we increment $s$ by $\\textit{diff}[i]$. If $s \\le 0$ and $left \\le i \\le right$, it indicates that an integer $i$ within the interval $[left, right]$ is not covered, and we return $\\textit{false}$.\nIf we finish iterating through the difference array $\\textit{diff}$ without returning $\\textit{false}$, it means that every integer within the interval $[left, right]$ is covered by at least one interval in $\\textit{ranges}$, and we return $\\textit{true}$.\nThe time complexity is $O(n + M)$, and the space complexity is $O(M)$. Here, $n$ is the length of the array $\\textit{ranges}$, and $M$ is the maximum value of the interval, which in this case is $M \\le 50$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 2D matrix grid consisting of positive integers.\nYou have to select one or more cells from the matrix such that the following conditions are satisfied:\n\nNo two selected cells are in the same row of the matrix.\nThe values in the set of selected cells are unique.\n\nYour score will be the sum of the values of the selected cells.\nReturn the maximum score you can achieve.\n\u00a0\nExample 1:\n\nInput: grid = [[1,2,3],[4,3,2],[1,1,1]]\nOutput: 8\nExplanation:\n\nWe can select the cells with values 1, 3, and 4 that are colored above.\n\nExample 2:\n\nInput: grid = [[8,7,6],[8,3,2]]\nOutput: 15\nExplanation:\n\nWe can select the cells with values 7 and 8 that are colored above.\n\n\u00a0\nConstraints:\n\n1 <= grid.length, grid[i].length <= 10\n1 <= grid[i][j] <= 100 Explanation:\n\nSolution 1: State Compression Dynamic Programming\nWe define $f[i][j]$ to represent the maximum score when selecting numbers from $[1,..i]$ and the state of the rows corresponding to the selected numbers is $j$. Initially, $f[i][j] = 0$, and the answer is $f[\\textit{mx}][2^m - 1]$, where $\\textit{mx}$ represents the maximum value in the matrix, and $m$ represents the number of rows in the matrix.\nFirst, we preprocess the matrix using a hash table $g$ to record the set of rows corresponding to each number. Then, we can use state compression dynamic programming to solve the problem.\nFor the state $f[i][j]$, we can choose not to select the number $i$, in which case $f[i][j] = f[i-1][j]$. Alternatively, we can choose the number $i$. In this case, we need to enumerate each row $k$ in the set $g[i]$ corresponding to the number $i$. If the $k$-th bit of $j$ is $1$, it means we can select the number $i$. Thus, $f[i][j] = \\max(f[i][j], f[i-1][j \\oplus 2^k] + i)$.\nFinally, we return $f[\\textit{mx}][2^m - 1]$.\nThe time complexity is $O(m \\times 2^m \\times \\textit{mx})$, and the space complexity is $O(\\textit{mx} \\times 2^m)$. Here, $m$ is the number of rows in the matrix, and $\\textit{mx}$ is the maximum value in the matrix. \n\n", "problem_ids": ["minimum-number-of-taps-to-open-to-water-a-garden", "check-if-all-the-integers-in-a-range-are-covered", "select-cells-in-grid-with-maximum-score"]}, "3210": {"text": "Similar Problem 1 \n\n Problem:\n\nIn the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\" and use the dial to spell a specific keyword to open the door.\nGiven a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.\nInitially, the first character of the ring is aligned at the \"12:00\" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the \"12:00\" direction and then by pressing the center button.\nAt the stage of rotating the ring to spell the key character key[i]:\n\nYou can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the \"12:00\" direction, where this character must equal key[i].\nIf the character key[i] has been aligned at the \"12:00\" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\n\n\u00a0\nExample 1:\n\n\nInput: ring = \"godding\", key = \"gd\"\nOutput: 4\nExplanation:\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n\nExample 2:\n\nInput: ring = \"godding\", key = \"godding\"\nOutput: 13\n\n\u00a0\nConstraints:\n\n1 <= ring.length, key.length <= 100\nring and key consist of only lower case English letters.\nIt is guaranteed that key could always be spelled by rotating ring. Explanation:\n\nSolution 1: Dynamic Programming\nFirst, we preprocess the positions of each character $c$ in the string $ring$, and record them in the array $pos[c]$. Suppose the lengths of the strings $key$ and $ring$ are $m$ and $n$, respectively.\nThen we define $f[i][j]$ as the minimum number of steps to spell the first $i+1$ characters of the string $key$, and the $j$-th character of $ring$ is aligned with the $12:00$ direction. Initially, $f[i][j]=+\\infty$. The answer is $\\min_{0 \\leq j < n} f[m - 1][j]$.\nWe can first initialize $f[0][j]$, where $j$ is the position where the character $key[0]$ appears in $ring$. Since the $j$-th character of $ring$ is aligned with the $12:00$ direction, we only need $1$ step to spell $key[0]$. In addition, we need $min(j, n - j)$ steps to rotate $ring$ to the $12:00$ direction. Therefore, $f[0][j]=min(j, n - j) + 1$.\nNext, we consider how the state transitions when $i \\geq 1$. We can enumerate the position list $pos[key[i]]$ where $key[i]$ appears in $ring$, and enumerate the position list $pos[key[i-1]]$ where $key[i-1]$ appears in $ring$, and then update $f[i][j]$, i.e., $f[i][j]=\\min_{k \\in pos[key[i-1]]} f[i-1][k] + \\min(\\textit{abs}(j - k), n - \\textit{abs}(j - k)) + 1$.\nFinally, we return $\\min_{0 \\leq j \\lt n} f[m - 1][j]$.\nThe time complexity is $O(m \\times n^2)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the lengths of the strings $key$ and $ring$, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an array nums of integers, return the length of the longest arithmetic subsequence in nums.\nNote that:\n\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nA sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 <= i < seq.length - 1).\n\n\u00a0\nExample 1:\n\nInput: nums = [3,6,9,12]\nOutput: 4\nExplanation:  The whole array is an arithmetic sequence with steps of length = 3.\n\nExample 2:\n\nInput: nums = [9,4,7,2,10]\nOutput: 3\nExplanation:  The longest arithmetic subsequence is [4,7,10].\n\nExample 3:\n\nInput: nums = [20,1,15,3,10,5,8]\nOutput: 4\nExplanation:  The longest arithmetic subsequence is [20,15,10,5].\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 1000\n0 <= nums[i] <= 500 Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i][j]$ as the maximum length of the arithmetic sequence ending with $nums[i]$ and having a common difference of $j$. Initially, $f[i][j]=1$, that is, each element itself is an arithmetic sequence of length $1$.\n\nSince the common difference may be negative, and the maximum difference is $500$, we can uniformly add $500$ to the common difference, so the range of the common difference becomes $[0, 1000]$.\n\nConsidering $f[i]$, we can enumerate the previous element $nums[k]$ of $nums[i]$, then the common difference $j=nums[i]-nums[k]+500$, at this time $f[i][j]=\\max(f[i][j], f[k][j]+1)$, then we update the answer $ans=\\max(ans, f[i][j])$.\nFinally, return the answer.\n\nIf initially $f[i][j]=0$, then we need to add $1$ to the answer when returning the answer.\n\nThe time complexity is $O(n \\times (d + n))$, and the space complexity is $O(n \\times d)$. Where $n$ and $d$ are the length of the array $nums$ and the difference between the maximum and minimum values in the array $nums$, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nA series of highways connect n cities numbered from 0 to n - 1. You are given a 2D integer array highways where highways[i] = [city1i, city2i, tolli] indicates that there is a highway that connects city1i and city2i, allowing a car to go from city1i to city2i and vice versa for a cost of tolli.\nYou are also given an integer k. You are going on a trip that crosses exactly k highways. You may start at any city, but you may only visit each city at most once during your trip.\nReturn the maximum cost of your trip. If there is no trip that meets the requirements, return -1.\n\u00a0\nExample 1:\n\n\nInput: n = 5, highways = [[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]], k = 3\nOutput: 17\nExplanation:\nOne possible trip is to go from 0 -> 1 -> 4 -> 3. The cost of this trip is 4 + 11 + 2 = 17.\nAnother possible trip is to go from 4 -> 1 -> 2 -> 3. The cost of this trip is 11 + 3 + 3 = 17.\nIt can be proven that 17 is the maximum possible cost of any valid trip.\n\nNote that the trip 4 -> 1 -> 0 -> 1 is not allowed because you visit the city 1 twice.\n\n\nExample 2:\n\n\nInput: n = 4, highways = [[0,1,3],[2,3,2]], k = 2\nOutput: -1\nExplanation: There are no valid trips of length 2, so return -1.\n\n\u00a0\nConstraints:\n\n2 <= n <= 15\n1 <= highways.length <= 50\nhighways[i].length == 3\n0 <= city1i, city2i <= n - 1\ncity1i != city2i\n0 <= tolli <= 100\n1 <= k <= 50\nThere are no duplicate highways. Explanation:\n\nSolution 1: State Compression Dynamic Programming\nWe notice that the problem requires exactly $k$ roads to be passed, and each city can only be visited once. The number of cities is $n$, so we can pass at most $n - 1$ roads. Therefore, if $k \\ge n$, we cannot meet the requirements of the problem, and we can directly return $-1$.\nIn addition, we can also find that the number of cities $n$ does not exceed $15$, which suggests that we can consider using the method of state compression dynamic programming to solve this problem. We use a binary number of length $n$ to represent the cities that have been passed, where the $i$-th bit is $1$ indicates that the $i$-th city has been passed, and $0$ indicates that the $i$-th city has not been passed yet.\nWe use $f[i][j]$ to represent the maximum travel cost when the cities that have been passed are $i$ and the last city passed is $j$. Initially, $f[2^i][i]=0$, and the rest $f[i][j]=-\\infty$.\nConsider how $f[i][j]$ transitions. For $f[i]$, we enumerate all cities $j$. If the $j$-th bit of $i$ is $1$, then we can reach city $j$ from other city $h$ through the road, at this time the value of $f[i][j]$ is the maximum value of $f[i][h]+cost(h, j)$, where $cost(h, j)$ represents the travel cost from city $h$ to city $j$. Therefore, we can get the state transition equation:\n$$\nf[i][j]=\\max_{h \\in \\textit{city}}{f[i \\backslash j][h]+cost(h, j)}\n$$\nwhere $i \\backslash j$ represents changing the $j$-th bit of $i$ to $0$.\nAfter calculating $f[i][j]$, we judge whether the number of cities passed is $k+1$, that is, whether the number of $1$s in the binary representation of $i$ is $k+1$. If so, we update the answer as $ans = \\max(ans, f[i][j])$.\nThe time complexity is $O(2^n \\times n^2)$, and the space complexity is $O(2^n \\times n)$, where $n$ represents the number of cities. \n\n", "problem_ids": ["freedom-trail", "longest-arithmetic-subsequence", "maximum-cost-of-trip-with-k-highways"]}, "3211": {"text": "Similar Problem 1 \n\n Problem:\n\nIn an infinite binary tree where every node has two children, the nodes are labelled in row order.\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\nGiven the label of a node in this tree, return the labels in the path from the root of the tree to the\u00a0node with that label.\n\u00a0\nExample 1:\n\nInput: label = 14\nOutput: [1,3,4,14]\n\nExample 2:\n\nInput: label = 26\nOutput: [1,2,6,10,26]\n\n\u00a0\nConstraints:\n\n1 <= label <= 10^6 Explanation:\n\nSolution 1: Mathematics\nFor a complete binary tree, the number of nodes in the $i$th row is $2^{i-1}$, and the range of node labels in the $i$th row is $[2^{i-1}, 2^i - 1]$. In the problem, for odd-numbered rows, the nodes are labeled from left to right, while for even-numbered rows, the nodes are labeled from right to left. Therefore, for the node $label$ in the $i$th row, its complementary node label is $2^{i-1} + 2^i - 1 - label$. So the actual parent node label of node $label$ is $(2^{i-1} + 2^i - 1 - label) / 2$. We can find the path from the root node to node $label$ by continuously finding the complementary node label and the parent node label until we reach the root node.\nFinally, we need to reverse the path, because the problem requires the path from the root node to node $label$.\nThe time complexity is $O(\\log n)$, where $n$ is the label of the node. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two strings s1 and s2 of equal length consisting of letters \"x\" and \"y\" only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].\nReturn the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.\n\u00a0\nExample 1:\n\nInput: s1 = \"xx\", s2 = \"yy\"\nOutput: 1\nExplanation: Swap s1[0] and s2[1], s1 = \"yx\", s2 = \"yx\".\n\nExample 2:\n\nInput: s1 = \"xy\", s2 = \"yx\"\nOutput: 2\nExplanation: Swap s1[0] and s2[0], s1 = \"yy\", s2 = \"xx\".\nSwap s1[0] and s2[1], s1 = \"xy\", s2 = \"xy\".\nNote that you cannot swap s1[0] and s1[1] to make s1 equal to \"yx\", cause we can only swap chars in different strings.\n\nExample 3:\n\nInput: s1 = \"xx\", s2 = \"xy\"\nOutput: -1\n\n\u00a0\nConstraints:\n\n1 <= s1.length, s2.length <= 1000\ns1.length == s2.length\ns1, s2 only contain 'x' or 'y'. Explanation:\n\nSolution 1: Greedy\nAccording to the problem description, both strings $s1$ and $s2$ only contain characters $x$ and $y$, and have the same length. Therefore, we can pair the characters in $s1$ and $s2$, i.e., $s1[i]$ and $s2[i]$.\nIf $s1[i] = s2[i]$, no swap is needed, and we can skip it. If $s1[i] \\neq s2[i]$, a swap is needed. We count the combination of $s1[i]$ and $s2[i]$, i.e., the situation where $s1[i] = x$ and $s2[i] = y$, denoted as $xy$, and the situation where $s1[i] = y$ and $s2[i] = x$, denoted as $yx$.\nIf $xy + yx$ is odd, the swap cannot be completed, and we return $-1$. If $xy + yx$ is even, the number of swaps needed is $\\left \\lfloor \\frac{x}{2} \\right \\rfloor$ + $\\left \\lfloor \\frac{y}{2} \\right \\rfloor$ + $xy \\bmod{2}$ + $yx \\bmod{2}$.\nThe time complexity is $O(n)$, where $n$ is the length of the strings $s1$ and $s2$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 2D integer array coordinates and an integer k, where coordinates[i] = [xi, yi] are the coordinates of the ith point in a 2D plane.\nWe define the distance between two points (x1, y1) and (x2, y2) as (x1 XOR x2) + (y1 XOR y2) where XOR is the bitwise XOR operation.\nReturn the number of pairs (i, j) such that i < j and the distance between points i and j is equal to k.\n\u00a0\nExample 1:\n\nInput: coordinates = [[1,2],[4,2],[1,3],[5,2]], k = 5\nOutput: 2\nExplanation: We can choose the following pairs:\n- (0,1): Because we have (1 XOR 4) + (2 XOR 2) = 5.\n- (2,3): Because we have (1 XOR 5) + (3 XOR 2) = 5.\n\nExample 2:\n\nInput: coordinates = [[1,3],[1,3],[1,3],[1,3],[1,3]], k = 0\nOutput: 10\nExplanation: Any two chosen pairs will have a distance of 0. There are 10 ways to choose two pairs.\n\n\u00a0\nConstraints:\n\n2 <= coordinates.length <= 50000\n0 <= xi, yi <= 106\n0 <= k <= 100 Explanation:\n\nSolution 1: Hash Table + Enumeration\nWe can use a hash table $cnt$ to count the occurrence of each point in the array $coordinates$.\nNext, we enumerate each point $(x_2, y_2)$ in the array $coordinates$. Since the range of $k$ is $[0, 100]$, and the result of $x_1 \\oplus x_2$ or $y_1 \\oplus y_2$ is always greater than or equal to $0$, we can enumerate the result $a$ of $x_1 \\oplus x_2$ in the range $[0,..k]$. Then, the result of $y_1 \\oplus y_2$ is $b = k - a$. In this way, we can calculate the values of $x_1$ and $y_1$, and add the occurrence of $(x_1, y_1)$ to the answer.\nThe time complexity is $O(n \\times k)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $coordinates$. \n\n", "problem_ids": ["path-in-zigzag-labelled-binary-tree", "minimum-swaps-to-make-strings-equal", "count-pairs-of-points-with-distance-k"]}, "3212": {"text": "Similar Problem 1 \n\n Problem:\n\nYou have an array of floating point numbers averages which is initially empty. You are given an array nums of n integers where n is even.\nYou repeat the following procedure n / 2 times:\n\nRemove the smallest element, minElement, and the largest element maxElement,\u00a0from nums.\nAdd (minElement + maxElement) / 2 to averages.\n\nReturn the minimum element in averages.\n\u00a0\nExample 1:\n\nInput: nums = [7,8,3,4,15,13,4,1]\nOutput: 5.5\nExplanation:\n\n\n\nstep\nnums\naverages\n\n\n0\n[7,8,3,4,15,13,4,1]\n[]\n\n\n1\n[7,8,3,4,13,4]\n[8]\n\n\n2\n[7,8,4,4]\n[8,8]\n\n\n3\n[7,4]\n[8,8,6]\n\n\n4\n[]\n[8,8,6,5.5]\n\n\n\nThe smallest element of averages, 5.5, is returned.\nExample 2:\n\nInput: nums = [1,9,8,3,10,5]\nOutput: 5.5\nExplanation:\n\n\n\nstep\nnums\naverages\n\n\n0\n[1,9,8,3,10,5]\n[]\n\n\n1\n[9,8,3,5]\n[5.5]\n\n\n2\n[8,5]\n[5.5,6]\n\n\n3\n[]\n[5.5,6,6.5]\n\n\n\n\nExample 3:\n\nInput: nums = [1,2,3,7,8,9]\nOutput: 5.0\nExplanation:\n\n\n\nstep\nnums\naverages\n\n\n0\n[1,2,3,7,8,9]\n[]\n\n\n1\n[2,3,7,8]\n[5]\n\n\n2\n[3,7]\n[5,5]\n\n\n3\n[]\n[5,5,5]\n\n\n\n\n\u00a0\nConstraints:\n\n2 <= n == nums.length <= 50\nn is even.\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Sorting\nFirst, we sort the array $\\textit{nums}$. Then, we start taking elements from both ends of the array, calculating the sum of the two elements, and taking the minimum value. Finally, we return the minimum value divided by 2 as the answer.\nThe time complexity is $O(n \\log n)$, and the space complexity is $O(\\log n)$, where $n$ is the length of the array $\\textit{nums}$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i].\nExecute all the valid transactions. A transaction is valid if:\n\nThe given account number(s) are between 1 and n, and\nThe amount of money withdrawn or transferred from is less than or equal to the balance of the account.\n\nImplement the Bank class:\n\nBank(long[] balance) Initializes the object with the 0-indexed integer array balance.\nboolean transfer(int account1, int account2, long money) Transfers money dollars from the account numbered account1 to the account numbered account2. Return true if the transaction was successful, false otherwise.\nboolean deposit(int account, long money) Deposit money dollars into the account numbered account. Return true if the transaction was successful, false otherwise.\nboolean withdraw(int account, long money) Withdraw money dollars from the account numbered account. Return true if the transaction was successful, false otherwise.\n\n\u00a0\nExample 1:\n\nInput\n[\"Bank\", \"withdraw\", \"transfer\", \"deposit\", \"transfer\", \"withdraw\"]\n[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]\nOutput\n[null, true, true, true, false, false]\n\nExplanation\nBank bank = new Bank([10, 100, 20, 50, 30]);\nbank.withdraw(3, 10);    // return true, account 3 has a balance of $20, so it is valid to withdraw $10.\n                         // Account 3 has $20 - $10 = $10.\nbank.transfer(5, 1, 20); // return true, account 5 has a balance of $30, so it is valid to transfer $20.\n                         // Account 5 has $30 - $20 = $10, and account 1 has $10 + $20 = $30.\nbank.deposit(5, 20);     // return true, it is valid to deposit $20 to account 5.\n                         // Account 5 has $10 + $20 = $30.\nbank.transfer(3, 4, 15); // return false, the current balance of account 3 is $10,\n                         // so it is invalid to transfer $15 from it.\nbank.withdraw(10, 50);   // return false, it is invalid because account 10 does not exist.\n\n\u00a0\nConstraints:\n\nn == balance.length\n1 <= n, account, account1, account2 <= 105\n0 <= balance[i], money <= 1012\nAt most 104 calls will be made to each function transfer, deposit, withdraw. Explanation:\n\nSolution 1: Simulation\nAccording to the problem description, we can use an array balance to simulate the balance of bank accounts. The array index starts from 0, and the value of the array represents the balance of the account.\n\nDuring initialization, we assign the balance array to the member variable this.balance, and assign the length of balance to the member variable this.n.\nIn the transfer function, if account1 or account2 is greater than n or balance[account1 - 1] is less than money, return false. Otherwise, subtract money from balance[account1 - 1], add money to balance[account2 - 1], and return true.\nIn the deposit function, if account is greater than n, return false. Otherwise, add money to balance[account - 1], and return true.\nIn the withdraw function, if account is greater than n or balance[account - 1] is less than money, return false. Otherwise, subtract money from balance[account - 1], and return true.\n\nThe time complexity of the above operations is $O(1)$, and the space complexity is $O(n)$. Here, $n$ is the length of balance. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.\nReturn the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4], n = 4, left = 1, right = 5\nOutput: 13 \nExplanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. \n\nExample 2:\n\nInput: nums = [1,2,3,4], n = 4, left = 3, right = 4\nOutput: 6\nExplanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.\n\nExample 3:\n\nInput: nums = [1,2,3,4], n = 4, left = 1, right = 10\nOutput: 50\n\n\u00a0\nConstraints:\n\nn == nums.length\n1 <= nums.length <= 1000\n1 <= nums[i] <= 100\n1 <= left <= right <= n * (n + 1) / 2 Explanation:\n\nSolution 1: Sorting\nAccording to the problem statement, generate the arr array, sort it, and then sum all the elements in the range $[left-1,.. right-1]$ to get the result.\nTime complexity is $O(n^2 \\times \\log n)$, and space complexity is $O(n^2)$. Here, $n$ is the length of the array given in the problem. \n\n", "problem_ids": ["minimum-average-of-smallest-and-largest-elements", "simple-bank-system", "range-sum-of-sorted-subarray-sums"]}, "3213": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. You can spend part or all of your money to buy multiple quantities (or none) of each kind of writing utensil.\nReturn the number of distinct ways you can buy some number of pens and pencils.\n\u00a0\nExample 1:\n\nInput: total = 20, cost1 = 10, cost2 = 5\nOutput: 9\nExplanation: The price of a pen is 10 and the price of a pencil is 5.\n- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\n- If you buy 1 pen, you can buy 0, 1, or 2 pencils.\n- If you buy 2 pens, you cannot buy any pencils.\nThe total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\n\nExample 2:\n\nInput: total = 5, cost1 = 10, cost2 = 10\nOutput: 1\nExplanation: The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils.\n\n\u00a0\nConstraints:\n\n1 <= total, cost1, cost2 <= 106 Explanation:\n\nSolution 1: Enumeration\nWe can enumerate the number of pens to buy, denoted as $x$. For each $x$, the maximum number of pencils we can buy is $\\frac{\\textit{total} - x \\times \\textit{cost1}}{\\textit{cost2}}$. The number of ways for each $x$ is this value plus 1. We sum up the number of ways for all $x$ to get the answer.\nThe time complexity is $O(\\frac{\\textit{total}}{\\textit{cost1}})$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\u00a0\nExample 1:\n\n\nInput: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]\n\nExample 2:\n\n\nInput: root = [4,2,7,1,3], val = 5\nOutput: []\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107 Explanation:\n\nSolution 1: Recursion\nWe check if the current node is null or if the current node's value equals the target value. If so, we return the current node.\nOtherwise, if the current node's value is greater than the target value, we recursively search the left subtree; otherwise, we recursively search the right subtree.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\nThe right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j.\nReturn an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.\n\u00a0\nExample 1:\n\nInput: intervals = [[1,2]]\nOutput: [-1]\nExplanation: There is only one interval in the collection, so it outputs -1.\n\nExample 2:\n\nInput: intervals = [[3,4],[2,3],[1,2]]\nOutput: [-1,0,1]\nExplanation: There is no right interval for [3,4].\nThe right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.\nThe right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.\n\nExample 3:\n\nInput: intervals = [[1,4],[2,3],[3,4]]\nOutput: [-1,2,-1]\nExplanation: There is no right interval for [1,4] and [3,4].\nThe right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.\n\n\u00a0\nConstraints:\n\n1 <= intervals.length <= 2 * 104\nintervals[i].length == 2\n-106 <= starti <= endi <= 106\nThe start point of each interval is unique. Explanation:\n\nSolution 1: Sorting + Binary Search\nWe can store the start point and index of each interval into an array arr, and sort it by the start point. Then we iterate through the interval array, for each interval [_, ed], we can use binary search to find the first interval whose start point is greater than or equal to ed, which is its right-side interval. If found, we store its index into the answer array, otherwise, we store -1.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the intervals. \n\n", "problem_ids": ["number-of-ways-to-buy-pens-and-pencils", "search-in-a-binary-search-tree", "find-right-interval"]}, "3219": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\n\u00a0\nExample 1:\n\nInput: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.\n\nExample 2:\n\nInput: grid = [[3,2],[1,0]]\nOutput: 0\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100\n\n\u00a0\nFollow up: Could you find an O(n + m) solution? Explanation:\n\nSolution 1: Start Traversing from the Bottom Left or Top Right\nAccording to the characteristic that both rows and columns are arranged in non-increasing order, we can start traversing from the bottom left corner towards the top right direction.\nWhen encountering a negative number, it indicates that all elements to the right of the current position in this row are negative. We add the number of remaining elements in this row to the answer, that is, $n - j$, and move up a row, that is, $i \\leftarrow i - 1$. Otherwise, move to the right column, that is, $j \\leftarrow j + 1$.\nAfter the traversal is over, return the answer.\nThe time complexity is $O(m + n)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nTable: Employee\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the name of an employee, their department, and the id of their manager.\nIf managerId is null, then the employee does not have a manager.\nNo employee will be the manager of themself.\n\n\u00a0\nWrite a solution to find managers with at least five direct reports.\nReturn the result table in any order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nEmployee table:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | null      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\nOutput: \n+------+\n| name |\n+------+\n| John |\n+------+ Explanation:\n\nSolution 1: Grouping and Joining\nWe can first count the number of direct subordinates for each manager, and then join the Employee table to find the managers whose number of direct subordinates is greater than or equal to $5$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a string of length 5 called time, representing the current time on a digital clock in the format \"hh:mm\". The earliest possible time is \"00:00\" and the latest possible time is \"23:59\".\nIn the string time, the digits represented by the ?\u00a0symbol are unknown, and must be replaced with a digit from 0 to 9.\nReturn an integer answer, the number of valid clock times that can be created by replacing every ?\u00a0with a digit from 0 to 9.\n\u00a0\nExample 1:\n\nInput: time = \"?5:00\"\nOutput: 2\nExplanation: We can replace the ? with either a 0 or 1, producing \"05:00\" or \"15:00\". Note that we cannot replace it with a 2, since the time \"25:00\" is invalid. In total, we have two choices.\n\nExample 2:\n\nInput: time = \"0?:0?\"\nOutput: 100\nExplanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.\n\nExample 3:\n\nInput: time = \"??:??\"\nOutput: 1440\nExplanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices.\n\n\u00a0\nConstraints:\n\ntime is a valid string of length 5 in the format \"hh:mm\".\n\"00\" <= hh <= \"23\"\n\"00\" <= mm <= \"59\"\nSome of the digits might be replaced with '?' and need to be replaced with digits from 0 to 9. Explanation:\n\nSolution 1: Enumeration\nWe can directly enumerate all times from $00:00$ to $23:59$, then judge whether each time is valid, if so, increment the answer.\nAfter the enumeration ends, return the answer.\nThe time complexity is $O(24 \\times 60)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["count-negative-numbers-in-a-sorted-matrix", "managers-with-at-least-5-direct-reports", "number-of-valid-clock-times"]}, "3220": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and a positive integer k.\nWe call an index i k-big if the following conditions are satisfied:\n\nThere exist at least k different indices idx1 such that idx1 < i and nums[idx1] < nums[i].\nThere exist at least k different indices idx2 such that idx2 > i and nums[idx2] < nums[i].\n\nReturn the number of k-big indices.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,6,5,2,3], k = 2\nOutput: 2\nExplanation: There are only two 2-big indices in nums:\n- i = 2 --> There are two valid idx1: 0 and 1. There are three valid idx2: 2, 3, and 4.\n- i = 3 --> There are two valid idx1: 0 and 1. There are two valid idx2: 3 and 4.\n\nExample 2:\n\nInput: nums = [1,1,1], k = 3\nOutput: 0\nExplanation: There are no 3-big indices in nums.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i], k <= nums.length Explanation:\n\nSolution 1: Binary Indexed Tree\nWe maintain two binary indexed trees, one records the number of elements smaller than the current position on the left, and the other records the number of elements smaller than the current position on the right.\nWe traverse the array, and for the current position, if the number of elements smaller than the current position on the left is greater than or equal to $k$, and the number of elements smaller than the current position on the right is greater than or equal to $k$, then the current position is a k-big, and we increment the answer by one.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$, where $n$ is the length of the array. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.\n\u00a0\nExample 1:\n\n\nInput: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n\nExample 2:\n\n\nInput: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph.\n\n\u00a0\nConstraints:\n\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i Explanation:\n\nSolution 1: Traverse Starting Points\nWe can traverse each node in the range $[0,..,n-1]$. If a node has not been visited, we start from this node and search for adjacent nodes until we encounter a cycle or a node that has already been visited. If we encounter a cycle, we update the answer.\nThe time complexity is $O(n)$ and the space complexity is $O(n)$, where $n$ is the number of nodes.\nSimilar problems:\n\n2127. Maximum Employees to Be Invited to a Meeting \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an m x n grid where each cell can have one of three values:\n\n0 representing an empty cell,\n1 representing a fresh orange, or\n2 representing a rotten orange.\n\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\n\u00a0\nExample 1:\n\n\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n\nExample 2:\n\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\nExample 3:\n\nInput: grid = [[0,2]]\nOutput: 0\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 10\ngrid[i][j] is 0, 1, or 2. Explanation:\n\nSolution 1: BFS\nFirst, we traverse the entire grid once, count the number of fresh oranges, denoted as $\\textit{cnt}$, and add the coordinates of all rotten oranges to the queue $q$.\nNext, we perform a breadth-first search. In each round of the search, we let all the rotten oranges in the queue rot the fresh oranges in four directions, until the queue is empty or the number of fresh oranges is $0$.\nFinally, if the number of fresh oranges is $0$, we return the current round number, otherwise, we return $-1$.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows and columns of the grid, respectively. \n\n", "problem_ids": ["count-the-number-of-k-big-indices", "longest-cycle-in-a-graph", "rotting-oranges"]}, "3221": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string moves of length n consisting only of characters 'L', 'R', and '_'. The string represents your movement on a number line starting from the origin 0.\nIn the ith move, you can choose one of the following directions:\n\nmove to the left if moves[i] = 'L' or moves[i] = '_'\nmove to the right if moves[i] = 'R' or moves[i] = '_'\n\nReturn the distance from the origin of the furthest point you can get to after n moves.\n\u00a0\nExample 1:\n\nInput: moves = \"L_RL__R\"\nOutput: 3\nExplanation: The furthest point we can reach from the origin 0 is point -3 through the following sequence of moves \"LLRLLLR\".\n\nExample 2:\n\nInput: moves = \"_R__LL_\"\nOutput: 5\nExplanation: The furthest point we can reach from the origin 0 is point -5 through the following sequence of moves \"LRLLLLL\".\n\nExample 3:\n\nInput: moves = \"_______\"\nOutput: 7\nExplanation: The furthest point we can reach from the origin 0 is point 7 through the following sequence of moves \"RRRRRRR\".\n\n\u00a0\nConstraints:\n\n1 <= moves.length == n <= 50\nmoves consists only of characters 'L', 'R' and '_'. Explanation:\n\nSolution 1: Greedy\nWhen encountering the character '', we can choose to move left or right. The problem requires us to find the farthest point from the origin. Therefore, we can first traverse once, greedily move all '' to the left, and find the farthest point from the origin at this time. Then traverse again, greedily move all '_' to the right, and find the farthest point from the origin at this time. Finally, take the maximum of the two traversals.\nFurther, we only need to calculate the difference between the number of 'L' and 'R' in the string, and then add the number of '_'.\nThe time complexity is $O(n)$, where $n$ is the length of the string. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nDesign a data structure that efficiently finds the majority element of a given subarray.\nThe majority element of a subarray is an element that occurs threshold times or more in the subarray.\nImplementing the MajorityChecker class:\n\nMajorityChecker(int[] arr) Initializes the instance of the class with the given array arr.\nint query(int left, int right, int threshold) returns the element in the subarray arr[left...right] that occurs at least threshold times, or -1 if no such element exists.\n\n\u00a0\nExample 1:\n\nInput\n[\"MajorityChecker\", \"query\", \"query\", \"query\"]\n[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]\nOutput\n[null, 1, -1, 2]\n\nExplanation\nMajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]);\nmajorityChecker.query(0, 5, 4); // return 1\nmajorityChecker.query(0, 3, 3); // return -1\nmajorityChecker.query(2, 3, 2); // return 2\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 2 * 104\n1 <= arr[i] <= 2 * 104\n0 <= left <= right < arr.length\nthreshold <= right - left + 1\n2 * threshold > right - left + 1\nAt most 104 calls will be made to query. Explanation:\n\nSolution 1: Segment Tree + Boyer-Moore Voting Algorithm + Binary Search\nWe notice that the problem requires us to find the possible majority element in a specific interval, so we consider using a segment tree to maintain the candidate majority element and its occurrence in each interval.\nWe define each node of the segment tree as Node, each node contains the following attributes:\n\nl: The left endpoint of the node, the index starts from $1$.\nr: The right endpoint of the node, the index starts from $1$.\nx: The candidate majority element of the node.\ncnt: The occurrence of the candidate majority element of the node.\n\nThe segment tree mainly has the following operations:\n\nbuild(u, l, r): Build the segment tree.\npushup(u): Use the information of the child nodes to update the information of the parent node.\nquery(u, l, r): Query the interval sum.\n\nIn the initialization method of the main function, we first create a segment tree, and use a hash table $d$ to record all indexes of each element in the array.\nIn the query(left, right, threshold) method, we directly call the query method of the segment tree to get the candidate majority element $x$. Then use binary search to find the first index $l$ in the array that is greater than or equal to $left$, and the first index $r$ that is greater than $right$. If $r - l \\ge threshold$, return $x$, otherwise return $-1$.\nIn terms of time complexity, the time complexity of the initialization method is $O(n)$, and the time complexity of the query method is $O(\\log n)$. The space complexity is $O(n)$. Here, $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nTable: Employee\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the name of an employee, their department, and the id of their manager.\nIf managerId is null, then the employee does not have a manager.\nNo employee will be the manager of themself.\n\n\u00a0\nWrite a solution to find managers with at least five direct reports.\nReturn the result table in any order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nEmployee table:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | null      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\nOutput: \n+------+\n| name |\n+------+\n| John |\n+------+ Explanation:\n\nSolution 1: Grouping and Joining\nWe can first count the number of direct subordinates for each manager, and then join the Employee table to find the managers whose number of direct subordinates is greater than or equal to $5$. \n\n", "problem_ids": ["furthest-point-from-origin", "online-majority-element-in-subarray", "managers-with-at-least-5-direct-reports"]}, "3223": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a balanced parentheses string s, return the score of the string.\nThe score of a balanced parentheses string is based on the following rule:\n\n\"()\" has score 1.\nAB has score A + B, where A and B are balanced parentheses strings.\n(A) has score 2 * A, where A is a balanced parentheses string.\n\n\u00a0\nExample 1:\n\nInput: s = \"()\"\nOutput: 1\n\nExample 2:\n\nInput: s = \"(())\"\nOutput: 2\n\nExample 3:\n\nInput: s = \"()()\"\nOutput: 2\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 50\ns consists of only '(' and ')'.\ns is a balanced parentheses string. Explanation:\n\nSolution 1: Counting\nBy observing, we find that () is the only structure that contributes to the score, and the outer parentheses just add some multipliers to this structure. So, we only need to focus on ().\nWe use $d$ to maintain the current depth of parentheses. For each (, we increase the depth by one, and for each ), we decrease the depth by one. When we encounter (), we add $2^d$ to the answer.\nLet's take (()(())) as an example. We first find the two closed parentheses () inside, and then add the corresponding $2^d$ to the score. In fact, we are calculating the score of (()) + ((())).\n```bash\n( ( ) ( ( ) ) )\n  ^ ^   ^ ^\n( ( ) ) + ( ( ( ) ) )\n  ^ ^         ^ ^\n```\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the string.\nRelated problems about parentheses:\n\n678. Valid Parenthesis String\n1021. Remove Outermost Parentheses\n1096. Brace Expansion II\n1249. Minimum Remove to Make Valid Parentheses\n1541. Minimum Insertions to Balance a Parentheses String\n2116. Check if a Parentheses String Can Be Valid \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a positive integer n.\nWe call an integer k fair if the number of even digits in k is equal to the number of odd digits in it.\nReturn the smallest fair integer that is greater than or equal to n.\n\u00a0\nExample 1:\n\nInput: n = 2\nOutput: 10\nExplanation: The smallest fair integer that is greater than or equal to 2 is 10.\n10 is fair because it has an equal number of even and odd digits (one odd digit and one even digit).\nExample 2:\n\nInput: n = 403\nOutput: 1001\nExplanation: The smallest fair integer that is greater than or equal to 403 is 1001.\n1001 is fair because it has an equal number of even and odd digits (two odd digits and two even digits).\n\n\u00a0\nConstraints:\n\n1 <= n <= 109 Explanation:\n\nSolution 1: Case Discussion\nWe denote the number of digits of $n$ as $k$, and the number of odd and even digits as $a$ and $b$ respectively.\n\nIf $a = b$, then $n$ itself is fair, and we can directly return $n$;\nOtherwise, if $k$ is odd, we can find the smallest fair number with $k+1$ digits, in the form of 10000111. If $k$ is even, we can directly brute force closestFair(n+1).\n\nThe time complexity is $O(\\sqrt{n} \\times \\log_{10} n)$. \n\nSimilar Problem 3 \n\n Problem:\n\nThe hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function:\n\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\n\nWhere val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26.\nYou are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue.\nThe test cases will be generated such that an answer always exists.\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nExample 1:\n\nInput: s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0\nOutput: \"ee\"\nExplanation: The hash of \"ee\" can be computed to be hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. \n\"ee\" is the first substring of length 2 with hashValue 0. Hence, we return \"ee\".\n\nExample 2:\n\nInput: s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32\nOutput: \"fbx\"\nExplanation: The hash of \"fbx\" can be computed to be hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. \nThe hash of \"bxz\" can be computed to be hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. \n\"fbx\" is the first substring of length 3 with hashValue 32. Hence, we return \"fbx\".\nNote that \"bxz\" also has a hash of 32 but it appears later than \"fbx\".\n\n\u00a0\nConstraints:\n\n1 <= k <= s.length <= 2 * 104\n1 <= power, modulo <= 109\n0 <= hashValue < modulo\ns consists of lowercase English letters only.\nThe test cases are generated such that an answer always exists. Explanation:\n\nSolution 1: Sliding Window + Reverse Traversal\nWe can maintain a sliding window of length $k$ to calculate the hash value of the substring. Considering that if we traverse the string in the forward order, the calculation of the hash value involves division and modulo operations, which are relatively complicated to handle. Therefore, we can traverse the string in reverse order, so that when calculating the hash value, only multiplication and modulo operations are needed.\nFirst, we calculate the hash value of the last $k$ characters of the string, and then start to traverse the string in reverse order from the end of the string. Each time we calculate the hash value of the current window, if it is equal to the given hash value, we find a substring that meets the conditions and update the starting position of the answer string.\nFinally, return the answer string.\nThe time complexity is $O(n)$, where $n$ is the length of the string. The space complexity is $O(1)$. \n\n", "problem_ids": ["score-of-parentheses", "closest-fair-integer", "find-substring-with-given-hash-value"]}, "3224": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of positive integers arr (not necessarily distinct), return the lexicographically largest permutation that is smaller than arr, that can be made with exactly one swap. If it cannot be done, then return the same array.\nNote that a swap exchanges the positions of two numbers arr[i] and arr[j]\n\u00a0\nExample 1:\n\nInput: arr = [3,2,1]\nOutput: [3,1,2]\nExplanation: Swapping 2 and 1.\n\nExample 2:\n\nInput: arr = [1,1,5]\nOutput: [1,1,5]\nExplanation: This is already the smallest permutation.\n\nExample 3:\n\nInput: arr = [1,9,4,6,7]\nOutput: [1,7,4,6,9]\nExplanation: Swapping 9 and 7.\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 104\n1 <= arr[i] <= 104 Explanation:\n\nSolution 1: Greedy\nFirst, we traverse the array from right to left, find the first index $i$ that satisfies $arr[i - 1] > arr[i]$, then $arr[i - 1]$ is the number we need to swap. Next, we traverse the array from right to left again, find the first index $j$ that satisfies $arr[j] < arr[i - 1]$ and $arr[j] \\neq arr[j - 1]$. Now, we swap $arr[i - 1]$ and $arr[j]$ and return the array.\nIf we traverse the entire array and do not find an index $i$ that meets the conditions, it means the array is already the smallest permutation, so we just return the original array.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nA perfectly straight street is represented by a number line. The street has street lamp(s) on it and is represented by a 2D integer array lights. Each lights[i] = [positioni, rangei] indicates that there is a street lamp at position positioni that lights up the area from [positioni - rangei, positioni + rangei] (inclusive).\nThe brightness of a position p is defined as the number of street lamp that light up the position p.\nGiven lights, return the brightest position on the street. If there are multiple brightest positions, return the smallest one.\n\u00a0\nExample 1:\n\n\nInput: lights = [[-3,2],[1,2],[3,3]]\nOutput: -1\nExplanation:\nThe first street lamp lights up the area from [(-3) - 2, (-3) + 2] = [-5, -1].\nThe second street lamp lights up the area from [1 - 2, 1 + 2] = [-1, 3].\nThe third street lamp lights up the area from [3 - 3, 3 + 3] = [0, 6].\n\nPosition -1 has a brightness of 2, illuminated by the first and second street light.\nPositions 0, 1, 2, and 3 have a brightness of 2, illuminated by the second and third street light.\nOut of all these positions, -1 is the smallest, so return it.\n\n\nExample 2:\n\nInput: lights = [[1,0],[0,1]]\nOutput: 1\nExplanation:\nThe first street lamp lights up the area from [1 - 0, 1 + 0] = [1, 1].\nThe second street lamp lights up the area from [0 - 1, 0 + 1] = [-1, 1].\n\nPosition 1 has a brightness of 2, illuminated by the first and second street light.\nReturn 1 because it is the brightest position on the street.\n\nExample 3:\n\nInput: lights = [[1,2]]\nOutput: -1\nExplanation:\nThe first street lamp lights up the area from [1 - 2, 1 + 2] = [-1, 3].\n\nPositions -1, 0, 1, 2, and 3 have a brightness of 1, illuminated by the first street light.\nOut of all these positions, -1 is the smallest, so return it.\n\n\u00a0\nConstraints:\n\n1 <= lights.length <= 105\nlights[i].length == 2\n-108 <= positioni <= 108\n0 <= rangei <= 108 Explanation:\n\nSolution 1: Difference Array + Hash Table + Sorting\nWe can consider the range illuminated by each street light as an interval, with the left endpoint $l = position_i - range_i$ and the right endpoint $r = position_i + range_i$. We can use the idea of a difference array. For each interval $[l, r]$, we add $1$ to the value at position $l$ and subtract $1$ from the value at position $r + 1$. We use a hash table to maintain the change value at each position.\nThen we traverse each position in ascending order, calculate the brightness $s$ at the current position. If the previous maximum brightness $mx < s$, then update the maximum brightness $mx = s$ and record the current position $ans = i$.\nFinally, return $ans$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of lights. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.\n\n\u00a0\nExample 1:\n\nInput: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].\n\nExample 2:\n\nInput: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = [].\n\n\u00a0\nConstraints:\n\n1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique. Explanation:\n\nSolution 1: Hash Table + Sorting\nWe use a hash table cnt to record the number of matches each player has lost.\nThen we traverse the hash table, put the players who lost 0 matches into ans[0], and put the players who lost 1 match into ans[1].\nFinally, we sort ans[0] and ans[1] in ascending order and return the result.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the number of matches. \n\n", "problem_ids": ["previous-permutation-with-one-swap", "brightest-position-on-street", "find-players-with-zero-or-one-losses"]}, "3225": {"text": "Similar Problem 1 \n\n Problem:\n\nThere are n teams numbered from 0 to n - 1 in a tournament.\nGiven a 0-indexed 2D boolean matrix grid of size n * n. For all i, j that 0 <= i, j <= n - 1 and i != j team i is stronger than team j if grid[i][j] == 1, otherwise, team j is stronger than team i.\nTeam a will be the champion of the tournament if there is no team b that is stronger than team a.\nReturn the team that will be the champion of the tournament.\n\u00a0\nExample 1:\n\nInput: grid = [[0,1],[0,0]]\nOutput: 0\nExplanation: There are two teams in this tournament.\ngrid[0][1] == 1 means that team 0 is stronger than team 1. So team 0 will be the champion.\n\nExample 2:\n\nInput: grid = [[0,0,1],[1,0,1],[0,0,0]]\nOutput: 1\nExplanation: There are three teams in this tournament.\ngrid[1][0] == 1 means that team 1 is stronger than team 0.\ngrid[1][2] == 1 means that team 1 is stronger than team 2.\nSo team 1 will be the champion.\n\n\u00a0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nFor all i grid[i][i] is 0.\nFor all i, j that i != j, grid[i][j] != grid[j][i].\nThe input is generated such that if team a is stronger than team b and team b is stronger than team c, then team a is stronger than team c. Explanation:\n\nSolution 1: Enumeration\nWe can enumerate each team $i$. If team $i$ has won every match, then team $i$ is the champion, and we can directly return $i$.\nThe time complexity is $O(n^2)$, where $n$ is the number of teams. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,3,3,2]\nOutput: 2\nExplanation:\nThe strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].\nThe strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].\nHence, we return 2.\n\nExample 2:\n\nInput: nums = [3,3,3,3]\nOutput: 1\nExplanation:\nThe strictly increasing subarrays of nums are [3], [3], [3], and [3].\nThe strictly decreasing subarrays of nums are [3], [3], [3], and [3].\nHence, we return 1.\n\nExample 3:\n\nInput: nums = [3,2,1]\nOutput: 3\nExplanation:\nThe strictly increasing subarrays of nums are [3], [2], and [1].\nThe strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].\nHence, we return 3.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Two Passes\nWe first perform a pass to find the length of the longest strictly increasing subarray, and update the answer. Then we perform another pass to find the length of the longest strictly decreasing subarray, and update the answer again.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a\u00a00-indexed\u00a0integer array\u00a0nums\u00a0containing\u00a0n\u00a0distinct positive integers. A permutation of\u00a0nums\u00a0is called special if:\n\nFor all indexes\u00a00 <= i < n - 1, either\u00a0nums[i] % nums[i+1] == 0\u00a0or\u00a0nums[i+1] % nums[i] == 0.\n\nReturn\u00a0the total number of special permutations.\u00a0As the answer could be large, return it\u00a0modulo\u00a0109\u00a0+ 7.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,6]\nOutput: 2\nExplanation: [3,6,2] and [2,6,3] are the two special permutations of nums.\n\nExample 2:\n\nInput: nums = [1,4,3]\nOutput: 2\nExplanation: [3,1,4] and [4,1,3] are the two special permutations of nums.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 14\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: State Compression Dynamic Programming\nWe notice that the maximum length of the array in the problem does not exceed $14$. Therefore, we can use an integer to represent the current state, where the $i$-th bit is $1$ if the $i$-th number in the array has been selected, and $0$ if it has not been selected.\nWe define $f[i][j]$ as the number of schemes where the current selected integer state is $i$, and the index of the last selected integer is $j$. Initially, $f[0][0]=0$, and the answer is $\\sum_{j=0}^{n-1}f[2^n-1][j]$.\nConsidering $f[i][j]$, if only one number is currently selected, then $f[i][j]=1$. Otherwise, we can enumerate the index $k$ of the last selected number. If the numbers corresponding to $k$ and $j$ meet the requirements of the problem, then $f[i][j]$ can be transferred from $f[i \\oplus 2^j][k]$. That is:\n$$\nf[i][j]=\n\\begin{cases}\n1, & i=2^j\\\n\\sum_{k=0}^{n-1}f[i \\oplus 2^j][k], & i \\neq 2^j \\textit{ and nums}[j] \\textit{ and nums}[k] \\textit{ meet the requirements of the problem}\\\n\\end{cases}\n$$\nThe final answer is $\\sum_{j=0}^{n-1}f[2^n-1][j]$. Note that the answer may be very large, so we need to take the modulus of $10^9+7$.\nThe time complexity is $O(n^2 \\times 2^n)$, and the space complexity is $O(n \\times 2^n)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["find-champion-i", "longest-strictly-increasing-or-strictly-decreasing-subarray", "special-permutations"]}, "3226": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted.\nReturn the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\n\nInput: m = 1, n = 1\nOutput: 3\nExplanation: The three possible colorings are shown in the image above.\n\nExample 2:\n\n\nInput: m = 1, n = 2\nOutput: 6\nExplanation: The six possible colorings are shown in the image above.\n\nExample 3:\n\nInput: m = 5, n = 5\nOutput: 580986\n\n\u00a0\nConstraints:\n\n1 <= m <= 5\n1 <= n <= 1000 Explanation:\n\nSolution 1: State Compression + Dynamic Programming\nWe notice that the number of rows in the grid does not exceed $5$, so there are at most $3^5=243$ different color schemes in a column.\nTherefore, we define $f[i][j]$ to represent the number of schemes in the first $i$ columns, where the coloring state of the $i$th column is $j$. The state $f[i][j]$ is transferred from $f[i - 1][k]$, where $k$ is the coloring state of the $i - 1$th column, and $k$ and $j$ meet the requirement of different colors being adjacent. That is:\n$$\nf[i][j] = \\sum_{k \\in \\textit{valid}(j)} f[i - 1][k]\n$$\nwhere $\\textit{valid}(j)$ represents all legal predecessor states of state $j$.\nThe final answer is the sum of $f[n][j]$, where $j$ is any legal state.\nWe notice that $f[i][j]$ is only related to $f[i - 1][k]$, so we can use a rolling array to optimize the space complexity.\nThe time complexity is $O((m + n) \\times 3^{2m})$, and the space complexity is $O(3^m)$. Here, $m$ and $n$ are the number of rows and columns of the grid, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.\n\n\u00a0\nExample 1:\nInput: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]\n\nExample 2:\nInput: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n\nExample 3:\nInput: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n\n\u00a0\nConstraints:\n\n1 <= n <= 104 Explanation:\n\nSolution 1: Simulation\nWe iterate through each integer from 1 to $n$. For each integer, we check whether it is a multiple of both 3 and 5, or just a multiple of 3, or just a multiple of 5. Based on the check result, we add the corresponding string to the answer array.\nThe time complexity is $O(n)$, where $n$ is the integer given in the problem. Ignoring the space consumption of the answer array, the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\nThe right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j.\nReturn an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.\n\u00a0\nExample 1:\n\nInput: intervals = [[1,2]]\nOutput: [-1]\nExplanation: There is only one interval in the collection, so it outputs -1.\n\nExample 2:\n\nInput: intervals = [[3,4],[2,3],[1,2]]\nOutput: [-1,0,1]\nExplanation: There is no right interval for [3,4].\nThe right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.\nThe right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.\n\nExample 3:\n\nInput: intervals = [[1,4],[2,3],[3,4]]\nOutput: [-1,2,-1]\nExplanation: There is no right interval for [1,4] and [3,4].\nThe right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.\n\n\u00a0\nConstraints:\n\n1 <= intervals.length <= 2 * 104\nintervals[i].length == 2\n-106 <= starti <= endi <= 106\nThe start point of each interval is unique. Explanation:\n\nSolution 1: Sorting + Binary Search\nWe can store the start point and index of each interval into an array arr, and sort it by the start point. Then we iterate through the interval array, for each interval [_, ed], we can use binary search to find the first interval whose start point is greater than or equal to ed, which is its right-side interval. If found, we store its index into the answer array, otherwise, we store -1.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the intervals. \n\n", "problem_ids": ["painting-a-grid-with-three-different-colors", "fizz-buzz", "find-right-interval"]}, "3227": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed string num representing a non-negative integer.\nIn one operation, you can pick any digit of num and delete it. Note that if you delete all the digits of num, num becomes 0.\nReturn the minimum number of operations required to make num special.\nAn integer x is considered special if it is divisible by 25.\n\u00a0\nExample 1:\n\nInput: num = \"2245047\"\nOutput: 2\nExplanation: Delete digits num[5] and num[6]. The resulting number is \"22450\" which is special since it is divisible by 25.\nIt can be shown that 2 is the minimum number of operations required to get a special number.\nExample 2:\n\nInput: num = \"2908305\"\nOutput: 3\nExplanation: Delete digits num[3], num[4], and num[6]. The resulting number is \"2900\" which is special since it is divisible by 25.\nIt can be shown that 3 is the minimum number of operations required to get a special number.\nExample 3:\n\nInput: num = \"10\"\nOutput: 1\nExplanation: Delete digit num[0]. The resulting number is \"0\" which is special since it is divisible by 25.\nIt can be shown that 1 is the minimum number of operations required to get a special number.\n\n\n\u00a0\nConstraints:\n\n1 <= num.length <= 100\nnum only consists of digits '0' through '9'.\nnum does not contain any leading zeros. Explanation:\n\nSolution 1: Memoization Search\nWe notice that an integer $x$ can be divisible by $25$, i.e., $x \\bmod 25 = 0$. Therefore, we can design a function $dfs(i, k)$, which represents the minimum number of digits to be deleted to make the number a special number, starting from the $i$th digit of the string $num$, and the current number modulo $25$ is $k$. The answer is $dfs(0, 0)$.\nThe execution logic of the function $dfs(i, k)$ is as follows:\n\nIf $i = n$, i.e., all digits of the string $num$ have been processed, then if $k = 0$, the current number can be divisible by $25$, return $0$, otherwise return $n$;\nOtherwise, the $i$th digit can be deleted, in this case one digit needs to be deleted, i.e., $dfs(i + 1, k) + 1$; if the $i$th digit is not deleted, then the value of $k$ becomes $(k \\times 10 + \\textit{num}[i]) \\bmod 25$, i.e., $dfs(i + 1, (k \\times 10 + \\textit{num}[i]) \\bmod 25)$. Take the minimum of these two.\n\nTo prevent repeated calculations, we can use memoization to optimize the time complexity.\nThe time complexity is $O(n \\times 25)$, and the space complexity is $O(n \\times 25)$. Here, $n$ is the length of the string $num$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 2D integer array orders, where each orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have been placed of type orderTypei at the price pricei. The orderTypei is:\n\n0 if it is a batch of buy orders, or\n1 if it is a batch of sell orders.\n\nNote that orders[i] represents a batch of amounti independent orders with the same price and order type. All orders represented by orders[i] will be placed before all orders represented by orders[i+1] for all valid i.\nThere is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:\n\nIf the order is a buy order, you look at the sell order with the smallest price in the backlog. If that sell order's price is smaller than or equal to the current buy order's price, they will match and be executed, and that sell order will be removed from the backlog. Else, the buy order is added to the backlog.\nVice versa, if the order is a sell order, you look at the buy order with the largest price in the backlog. If that buy order's price is larger than or equal to the current sell order's price, they will match and be executed, and that buy order will be removed from the backlog. Else, the sell order is added to the backlog.\n\nReturn the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\n\n\nInput: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]\n\nOutput: 6\n\nExplanation: Here is what happens with the orders:\n\n- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.\n\n- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.\n\n- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.\n\n- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.\n\nFinally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.\n\n\nExample 2:\n\n\n\nInput: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\n\nOutput: 999999984\n\nExplanation: Here is what happens with the orders:\n\n- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.\n\n- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.\n\n- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.\n\n- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.\n\nFinally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).\n\n\n\u00a0\nConstraints:\n\n1 <= orders.length <= 105\norders[i].length == 3\n1 <= pricei, amounti <= 109\norderTypei is either 0 or 1. Explanation:\n\nSolution 1: Priority Queue (Max-Min Heap) + Simulation\nWe can use a priority queue (max-min heap) to maintain the current backlog of orders, where the max heap buy maintains the backlog of purchase orders, and the min heap sell maintains the backlog of sales orders. Each element in the heap is a tuple $(price, amount)$, indicating that the number of orders at price price is amount.\nNext, we traverse the order array orders, and simulate according to the problem's requirements.\nAfter the traversal, we add the order quantities in buy and sell, which is the final backlog of orders. Note that the answer may be very large, so we need to take the modulus of $10^9 + 7$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of orders. \n\nSimilar Problem 3 \n\n Problem:\n\nA string s can be partitioned into groups of size k using the following procedure:\n\nThe first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group.\nFor the last group, if the string does not have k characters remaining, a character fill is used to complete the group.\n\nNote that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.\nGiven the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.\n\u00a0\nExample 1:\n\nInput: s = \"abcdefghi\", k = 3, fill = \"x\"\nOutput: [\"abc\",\"def\",\"ghi\"]\nExplanation:\nThe first 3 characters \"abc\" form the first group.\nThe next 3 characters \"def\" form the second group.\nThe last 3 characters \"ghi\" form the third group.\nSince all groups can be completely filled by characters from the string, we do not need to use fill.\nThus, the groups formed are \"abc\", \"def\", and \"ghi\".\n\nExample 2:\n\nInput: s = \"abcdefghij\", k = 3, fill = \"x\"\nOutput: [\"abc\",\"def\",\"ghi\",\"jxx\"]\nExplanation:\nSimilar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\".\nFor the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.\nThus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\".\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 100\ns consists of lowercase English letters only.\n1 <= k <= 100\nfill is a lowercase English letter. Explanation:\n\nSolution 1: Simulation\nWe can directly simulate the process described in the problem statement, dividing the string $s$ into groups of length $k$. For the last group, if it contains fewer than $k$ characters, we use the character $\\textit{fill}$ to pad it.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string $s$. \n\n", "problem_ids": ["minimum-operations-to-make-a-special-number", "number-of-orders-in-the-backlog", "divide-a-string-into-groups-of-size-k"]}, "3228": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a positive integer num, split it into two non-negative integers num1 and num2 such that:\n\nThe concatenation of num1 and num2 is a permutation of num.\n\n    \nIn other words, the sum of the number of occurrences of each digit in num1 and num2 is equal to the number of occurrences of that digit in num.\n\n\nnum1 and num2 can contain leading zeros.\n\nReturn the minimum possible sum of num1 and num2.\nNotes:\n\nIt is guaranteed that num does not contain any leading zeros.\nThe order of occurrence of the digits in num1 and num2 may differ from the order of occurrence of num.\n\n\u00a0\nExample 1:\n\nInput: num = 4325\nOutput: 59\nExplanation: We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.\n\nExample 2:\n\nInput: num = 687\nOutput: 75\nExplanation: We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75.\n\n\u00a0\nConstraints:\n\n10 <= num <= 109 Explanation:\n\nSolution 1: Counting + Greedy\nFirst, we use a hash table or array $cnt$ to count the occurrences of each digit in $num$, and use a variable $n$ to record the number of digits in $num$.\nNext, we enumerate all the digits $i$ in $nums$, and alternately allocate the digits in $cnt$ to $num1$ and $num2$ in ascending order, recording them in an array $ans$ of length $2$. Finally, we return the sum of the two numbers in $ans$.\nThe time complexity is $O(n)$, and the space complexity is $O(C)$. Where $n$ is the number of digits in $num$; and $C$ is the number of different digits in $num$, in this problem, $C \\leq 10$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an array of integers nums containing\u00a0n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this\u00a0repeated\u00a0number.\nYou must solve the problem without modifying the array nums\u00a0and uses only constant extra space.\n\u00a0\nExample 1:\n\nInput: nums = [1,3,4,2,2]\nOutput: 2\n\nExample 2:\n\nInput: nums = [3,1,3,4,2]\nOutput: 3\n\nExample 3:\n\nInput: nums = [3,3,3,3,3]\nOutput: 3\n\u00a0\nConstraints:\n\n1 <= n <= 105\nnums.length == n + 1\n1 <= nums[i] <= n\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\n\n\u00a0\nFollow up:\n\nHow can we prove that at least one duplicate number must exist in nums?\nCan you solve the problem in linear runtime complexity? Explanation:\n\nSolution 1: Binary Search\nWe can observe that if the number of elements in $[1,..x]$ is greater than $x$, then the duplicate number must be in $[1,..x]$, otherwise the duplicate number must be in $[x+1,..n]$.\nTherefore, we can use binary search to find $x$, and check whether the number of elements in $[1,..x]$ is greater than $x$ at each iteration. This way, we can determine which interval the duplicate number is in, and narrow down the search range until we find the duplicate number.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums consisting of n elements, and an integer k.\nFind a contiguous subarray whose length is greater than or equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.\n\u00a0\nExample 1:\n\nInput: nums = [1,12,-5,-6,50,3], k = 4\nOutput: 12.75000\nExplanation:\n- When the length is 4, averages are [0.5, 12.75, 10.5] and the maximum average is 12.75\n- When the length is 5, averages are [10.4, 10.8] and the maximum average is 10.8\n- When the length is 6, averages are [9.16667] and the maximum average is 9.16667\nThe maximum average is when we choose a subarray of length 4 (i.e., the sub array [12, -5, -6, 50]) which has the max average 12.75, so we return 12.75\nNote that we do not consider the subarrays of length < 4.\n\nExample 2:\n\nInput: nums = [5], k = 1\nOutput: 5.00000\n\n\u00a0\nConstraints:\n\nn == nums.length\n1 <= k <= n <= 104\n-104 <= nums[i] <= 104 Explanation:\n\nSolution 1: Binary Search\nWe note that if the average value of a subarray with length greater than or equal to $k$ is $v$, then the maximum average number must be greater than or equal to $v$, otherwise the maximum average number must be less than $v$. Therefore, we can use binary search to find the maximum average number.\nWhat are the left and right boundaries of binary search? The left boundary $l$ must be the minimum value in the array, and the right boundary $r$ is the maximum value in the array. Next, we binary search the midpoint $mid$, and judge whether there exists a subarray with length greater than or equal to $k$ whose average value is greater than or equal to $mid$. If it exists, then we update the left boundary $l$ to $mid$, otherwise we update the right boundary $r$ to $mid$. When the difference between the left and right boundaries is less than a very small non-negative number, i.e., $r - l < \\epsilon$, we can get the maximum average number, where $\\epsilon$ represents a very small positive number, which can be $10^{-5}$.\nThe key to the problem is how to judge whether the average value of a subarray with length greater than or equal to $k$ is greater than or equal to $v$.\nWe assume that in the array $nums$, there is a subarray with length $j$, the elements are $a_1, a_2, \\cdots, a_j$, and its average value is greater than or equal to $v$, i.e.,\n$$\n\\frac{a_1 + a_2 + \\cdots + a_j}{j} \\geq v\n$$\nThen,\n$$\na_1 + a_2 + \\cdots + a_j \\geq v \\times j\n$$\nThat is,\n$$\n(a_1 - v) + (a_2 - v) + \\cdots + (a_j - v) \\geq 0\n$$\nWe can find that if we subtract $v$ from each element in the array $nums$, the original problem is transformed into a problem of whether the sum of the elements of a subarray with length greater than or equal to $k$ is greater than or equal to $0$. We can use a sliding window to solve this problem.\nFirst, we calculate the sum $s$ of the differences between the first $k$ elements and $v$. If $s \\geq 0$, it means that there exists a subarray with length greater than or equal to $k$ whose element sum is greater than or equal to $0$.\nOtherwise, we continue to traverse the element $nums[j]$. Suppose the current sum of the differences between the first $j$ elements and $v$ is $s_j$. Then we can maintain the minimum value $mi$ of the sum of the differences between the prefix sum and $v$ in the range $[0,..j-k]$. If $s_j \\geq mi$ exists, it means that there exists a subarray with length greater than or equal to $k$ whose element sum is greater than or equal to $0$, and we return $true$.\nOtherwise, we continue to traverse the element $nums[j]$ until the entire array is traversed.\nThe time complexity is $O(n \\times \\log M)$, where $n$ and $M$ are the length of the array $nums$ and the difference between the maximum and minimum values in the array, respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["split-with-minimum-sum", "find-the-duplicate-number", "maximum-average-subarray-ii"]}, "3229": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.\n\u00a0\nExample 1:\n\n\nInput: root = [3,0,0]\nOutput: 2\nExplanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.\n\nExample 2:\n\n\nInput: root = [0,3,0]\nOutput: 3\nExplanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is n.\n1 <= n <= 100\n0 <= Node.val <= n\nThe sum of all Node.val is n. Explanation:\n\nSolution 1: DFS\nWe define a function $\\textit{dfs(node)}$, which represents the coin overload in the subtree rooted at $\\textit{node}$, i.e., the number of coins minus the number of nodes. If $\\textit{dfs(node)}$ is positive, it means the subtree has more coins than nodes, and the excess coins need to be moved out of the subtree; if $\\textit{dfs(node)}$ is negative, it means the subtree has fewer coins than nodes, and the shortfall needs to be moved into the subtree.\nIn the function $\\textit{dfs(node)}$, we first traverse the left and right subtrees to obtain the coin overload $\\textit{left}$ and $\\textit{right}$ of the left and right subtrees, respectively. Then, the current number of moves needs to be increased by $|\\textit{left}| + |\\textit{right}|$, which means moving the coins from the left and right subtrees to the current node. After that, we return the coin overload of the entire subtree, which is $\\textit{left} + \\textit{right} + \\textit{node.val} - 1$.\nFinally, we return the number of moves.\nThe time complexity is $O(n)$, and the space complexity is $O(h)$. Here, $n$ and $h$ respectively represent the number of nodes and the height of the binary tree. \n\nSimilar Problem 2 \n\n Problem:\n\nThere is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented by a given 2D integer array edges, where edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nReturn the length of the shortest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.\n\u00a0\nExample 1:\n\n\nInput: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\nOutput: 3\nExplanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0 \n\nExample 2:\n\n\nInput: n = 4, edges = [[0,1],[0,2]]\nOutput: -1\nExplanation: There are no cycles in this graph.\n\n\u00a0\nConstraints:\n\n2 <= n <= 1000\n1 <= edges.length <= 1000\nedges[i].length == 2\n0 <= ui, vi < n\nui != vi\nThere are no repeated edges. Explanation:\n\nSolution 1: Enumerate edges + BFS\nWe first construct the adjacency list $g$ of the graph according to the array $edges$, where $g[u]$ represents all the adjacent vertices of vertex $u$.\nThen we enumerate the two-directional edge $(u, v)$, if the path from vertex $u$ to vertex $v$ still exists after deleting this edge, then the length of the shortest cycle containing this edge is $dist[v] + 1$, where $dist[v]$ represents the shortest path length from vertex $u$ to vertex $v$. We take the minimum of all these cycles.\nThe time complexity is $O(m^2)$ and the space complexity is $O(m + n)$, where $m$ and $n$ are the length of the array $edges$ and the number of vertices. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person.\nThe population of some year x is the number of people alive during that year. The ith person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die.\nReturn the earliest year with the maximum population.\n\u00a0\nExample 1:\n\nInput: logs = [[1993,1999],[2000,2010]]\nOutput: 1993\nExplanation: The maximum population is 1, and 1993 is the earliest year with this population.\n\nExample 2:\n\nInput: logs = [[1950,1961],[1960,1971],[1970,1981]]\nOutput: 1960\nExplanation: \nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960.\n\u00a0\nConstraints:\n\n1 <= logs.length <= 100\n1950 <= birthi < deathi <= 2050 Explanation:\n\nSolution 1: Difference Array\nWe notice that the range of years is $[1950,..2050]$. Therefore, we can map these years to an array $d$ of length $101$, where the index of the array represents the value of the year minus $1950$.\nNext, we traverse $logs$. For each person, we increment $d[birth_i - 1950]$ by $1$ and decrement $d[death_i - 1950]$ by $1$. Finally, we traverse the array $d$, find the maximum value of the prefix sum, which is the year with the most population, and add $1950$ to get the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(C)$. Where $n$ is the length of the array $logs$, and $C$ is the range size of the years, i.e., $2050 - 1950 + 1 = 101$. \n\n", "problem_ids": ["distribute-coins-in-binary-tree", "shortest-cycle-in-a-graph", "maximum-population-year"]}, "3230": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an m x n matrix, return all elements of the matrix in spiral order.\n\u00a0\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\n\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\u00a0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 10\n-100 <= matrix[i][j] <= 100 Explanation:\n\nSolution 1: Simulation\nWe use $i$ and $j$ to represent the row and column of the current element, use $k$ to represent the current direction, and use an array or hash table $vis$ to record whether each element has been visited. Each time we visit an element, we mark it as visited, then move forward in the current direction. If we find that it is out of bounds or has been visited after moving forward, we change the direction and continue to move forward until the entire matrix is traversed.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, respectively.\nFor visited elements, we can also add a constant $300$ to their values, so we don't need an extra $vis$ array or hash table to record whether they have been visited, thereby reducing the space complexity to $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed array nums of integers.\nA triplet of indices (i, j, k) is a mountain if:\n\ni < j < k\nnums[i] < nums[j] and nums[k] < nums[j]\n\nReturn the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.\n\u00a0\nExample 1:\n\nInput: nums = [8,6,1,5,3]\nOutput: 9\nExplanation: Triplet (2, 3, 4) is a mountain triplet of sum 9 since: \n- 2 < 3 < 4\n- nums[2] < nums[3] and nums[4] < nums[3]\nAnd the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.\n\nExample 2:\n\nInput: nums = [5,4,8,7,10,2]\nOutput: 13\nExplanation: Triplet (1, 3, 5) is a mountain triplet of sum 13 since: \n- 1 < 3 < 5\n- nums[1] < nums[3] and nums[5] < nums[3]\nAnd the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.\n\nExample 3:\n\nInput: nums = [6,5,4,3,4,5]\nOutput: -1\nExplanation: It can be shown that there are no mountain triplets in nums.\n\n\u00a0\nConstraints:\n\n3 <= nums.length <= 50\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Preprocessing + Enumeration\nWe can preprocess the minimum value on the right side of each position and record it in the array $right[i]$, where $right[i]$ represents the minimum value in $nums[i+1..n-1]$.\nNext, we enumerate the middle element $nums[i]$ of the mountain triplet from left to right, and use a variable $left$ to represent the minimum value in $ums[0..i-1]$, and a variable $ans$ to represent the current minimum element sum found. For each $i$, we need to find the element $nums[i]$ that satisfies $left < nums[i]$ and $right[i+1] < nums[i]$, and update $ans$.\nFinally, if $ans$ is still the initial value, it means that there is no mountain triplet, and we return $-1$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nTable: Activity\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n(player_id, event_date) is the primary key (combination of columns with unique values) of this table.\nThis table shows the activity of players of some games.\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.\n\n\u00a0\nWrite a solution to find the first login date for each player.\nReturn the result table in any order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nActivity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-05-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\nOutput: \n+-----------+-------------+\n| player_id | first_login |\n+-----------+-------------+\n| 1         | 2016-03-01  |\n| 2         | 2017-06-25  |\n| 3         | 2016-03-02  |\n+-----------+-------------+ Explanation:\n\nSolution 1: Group By + Min Function\nWe can use GROUP BY to group the player_id and then take the minimum event_date in each group as the date when the player first logged into the platform. \n\n", "problem_ids": ["spiral-matrix", "minimum-sum-of-mountain-triplets-i", "game-play-analysis-i"]}, "3231": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s consisting of only lowercase English letters. In one operation, you can:\n\nDelete the entire string s, or\nDelete the first i letters of s if the first i letters of s are equal to the following i letters in s, for any i in the range 1 <= i <= s.length / 2.\n\nFor example, if s = \"ababc\", then in one operation, you could delete the first two letters of s to get \"abc\", since the first two letters of s and the following two letters of s are both equal to \"ab\".\nReturn the maximum number of operations needed to delete all of s.\n\u00a0\nExample 1:\n\nInput: s = \"abcabcdabc\"\nOutput: 2\nExplanation:\n- Delete the first 3 letters (\"abc\") since the next 3 letters are equal. Now, s = \"abcdabc\".\n- Delete all the letters.\nWe used 2 operations so return 2. It can be proven that 2 is the maximum number of operations needed.\nNote that in the second operation we cannot delete \"abc\" again because the next occurrence of \"abc\" does not happen in the next 3 letters.\n\nExample 2:\n\nInput: s = \"aaabaab\"\nOutput: 4\nExplanation:\n- Delete the first letter (\"a\") since the next letter is equal. Now, s = \"aabaab\".\n- Delete the first 3 letters (\"aab\") since the next 3 letters are equal. Now, s = \"aab\".\n- Delete the first letter (\"a\") since the next letter is equal. Now, s = \"ab\".\n- Delete all the letters.\nWe used 4 operations so return 4. It can be proven that 4 is the maximum number of operations needed.\n\nExample 3:\n\nInput: s = \"aaaaa\"\nOutput: 5\nExplanation: In each operation, we can delete the first letter of s.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 4000\ns consists only of lowercase English letters. Explanation:\n\nSolution 1: Memoization Search\nWe design a function $dfs(i)$, which represents the maximum number of operations needed to delete all characters from $s[i..]$. The answer is $dfs(0)$.\nThe calculation process of the function $dfs(i)$ is as follows:\n\nIf $i \\geq n$, then $dfs(i) = 0$, return directly.\nOtherwise, we enumerate the length of the string $j$, where $1 \\leq j \\leq (n-1)/2$. If $s[i..i+j] = s[i+j..i+j+j]$, we can delete $s[i..i+j]$, then $dfs(i)=max(dfs(i), dfs(i+j)+1)$. We need to enumerate all $j$ to find the maximum value of $dfs(i)$.\n\nHere we need to quickly determine whether $s[i..i+j]$ is equal to $s[i+j..i+j+j]$. We can preprocess all the longest common prefixes of string $s$, that is, $g[i][j]$ represents the length of the longest common prefix of $s[i..]$ and $s[j..]$. In this way, we can quickly determine whether $s[i..i+j]$ is equal to $s[i+j..i+j+j]$, that is, $g[i][i+j] \\geq j$.\nTo avoid repeated calculations, we can use memoization search and use an array $f$ to record the value of the function $dfs(i)$.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of the string $s$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\n\u00a0\nExample 1:\n\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= n <= 500\n-500 <= Node.val <= 500\n1 <= left <= right <= n\n\n\u00a0\nFollow up: Could you do it in one pass? Explanation:\n\nSolution 1: Simulation\nDefine a dummy head node dummy, pointing to the head node head of the linked list. Then define a pointer pre pointing to dummy. Start traversing the linked list from the dummy head node. When you traverse to the left node, point pre to this node. Then start traversing right - left + 1 times from this node, and insert the nodes you traverse into the back of pre. Finally, return dummy.next.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the linked list. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.\n\u00a0\nExample 1:\n\nInput: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\nOutput: 16\nExplanation: The two words can be \"abcw\", \"xtfn\".\n\nExample 2:\n\nInput: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\nOutput: 4\nExplanation: The two words can be \"ab\", \"cd\".\n\nExample 3:\n\nInput: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\nOutput: 0\nExplanation: No such pair of words.\n\n\u00a0\nConstraints:\n\n2 <= words.length <= 1000\n1 <= words[i].length <= 1000\nwords[i] consists only of lowercase English letters. Explanation:\n\nSolution 1: Bit Manipulation\nThe problem requires us to find two strings without common letters, so that their length product is maximized. We can represent each string with a binary number $mask[i]$, where each bit of this binary number indicates whether the string contains a certain letter. If two strings do not have common letters, then the bitwise AND result of the two binary numbers corresponding to these strings is $0$, that is, $mask[i] \\& mask[j] = 0$.\nWe traverse each string. For the current string $words[i]$ we are traversing, we first calculate the corresponding binary number $mask[i]$, and then traverse all strings $words[j]$ where $j \\in [0, i)$. We check whether $mask[i] \\& mask[j] = 0$ holds. If it holds, we update the answer to $\\max(ans, |words[i]| \\times |words[j]|)$.\nAfter the traversal, we return the answer.\nThe time complexity is $O(n^2 + L)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string array $words$, and $L$ is the sum of the lengths of all strings in the string array. \n\n", "problem_ids": ["maximum-deletions-on-a-string", "reverse-linked-list-ii", "maximum-product-of-word-lengths"]}, "3233": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an m x n integer matrix grid where each entry is only 0 or 1, return the number of corner rectangles.\nA corner rectangle is four distinct 1's on the grid that forms an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1's used must be distinct.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,0,0,1,0],[0,0,1,0,1],[0,0,0,1,0],[1,0,1,0,1]]\nOutput: 1\nExplanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].\n\nExample 2:\n\n\nInput: grid = [[1,1,1],[1,1,1],[1,1,1]]\nOutput: 9\nExplanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.\n\nExample 3:\n\n\nInput: grid = [[1,1,1,1]]\nOutput: 0\nExplanation: Rectangles must have four distinct corners.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\ngrid[i][j] is either 0 or 1.\nThe number of 1's in the grid is in the range [1, 6000]. Explanation:\n\nSolution 1: Hash Table + Enumeration\nWe enumerate each row as the bottom of the rectangle. For the current row, if both column $i$ and column $j$ are $1$, then we use a hash table to find out how many of the previous rows have both columns $i$ and $j$ as $1$. This is the number of rectangles with $(i, j)$ as the bottom right corner, and we add this number to the answer. Then we add $(i, j)$ to the hash table and continue to enumerate the next pair $(i, j)$.\nThe time complexity is $O(m \\times n^2)$, and the space complexity is $O(n^2)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array nums and an integer k.\nFor each index i where 0 <= i < nums.length, change nums[i] to be either nums[i] + k or nums[i] - k.\nThe score of nums is the difference between the maximum and minimum elements in nums.\nReturn the minimum score of nums after changing the values at each index.\n\u00a0\nExample 1:\n\nInput: nums = [1], k = 0\nOutput: 0\nExplanation: The score is max(nums) - min(nums) = 1 - 1 = 0.\n\nExample 2:\n\nInput: nums = [0,10], k = 2\nOutput: 6\nExplanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n\nExample 3:\n\nInput: nums = [1,3,6], k = 3\nOutput: 3\nExplanation: Change nums to be [4, 6, 3]. The score is max(nums) - min(nums) = 6 - 3 = 3.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 104\n0 <= k <= 104 Explanation:\n\nSolution 1: Greedy + Enumeration\nAccording to the problem requirements, we need to find the minimum difference between the maximum and minimum values in the array. Each element can be increased or decreased by $k$, so we can divide the elements in the array into two parts, one part increased by $k$ and the other part decreased by $k$. Therefore, we should decrease the larger values in the array by $k$ and increase the smaller values by $k$ to ensure the minimum difference between the maximum and minimum values.\nTherefore, we can first sort the array, then enumerate each element in the array, divide it into two parts, one part increased by $k$ and the other part decreased by $k$, and calculate the difference between the maximum and minimum values. Finally, take the minimum value among all differences.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$, where $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nThere are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has.\nYou can work on the projects following these two rules:\n\nEvery week, you will finish exactly one milestone of one project. You\u00a0must\u00a0work every week.\nYou cannot work on two milestones from the same project for two consecutive weeks.\n\nOnce all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints.\nReturn the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.\n\u00a0\nExample 1:\n\nInput: milestones = [1,2,3]\nOutput: 6\nExplanation: One possible scenario is:\n\u200b\u200b\u200b\u200b- During the 1st week, you will work on a milestone of project 0.\n- During the 2nd week, you will work on a milestone of project 2.\n- During the 3rd week, you will work on a milestone of project 1.\n- During the 4th week, you will work on a milestone of project 2.\n- During the 5th week, you will work on a milestone of project 1.\n- During the 6th week, you will work on a milestone of project 2.\nThe total number of weeks is 6.\n\nExample 2:\n\nInput: milestones = [5,2,1]\nOutput: 7\nExplanation: One possible scenario is:\n- During the 1st week, you will work on a milestone of project 0.\n- During the 2nd week, you will work on a milestone of project 1.\n- During the 3rd week, you will work on a milestone of project 0.\n- During the 4th week, you will work on a milestone of project 1.\n- During the 5th week, you will work on a milestone of project 0.\n- During the 6th week, you will work on a milestone of project 2.\n- During the 7th week, you will work on a milestone of project 0.\nThe total number of weeks is 7.\nNote that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules.\nThus, one milestone in project 0 will remain unfinished.\n\n\u00a0\nConstraints:\n\nn == milestones.length\n1 <= n <= 105\n1 <= milestones[i] <= 109 Explanation:\n\nSolution 1: Greedy\nWe consider under what circumstances we cannot complete all stage tasks. If there is a project $i$ whose number of stage tasks is greater than the sum of the number of stage tasks of all other projects plus $1$, then we cannot complete all stage tasks. Otherwise, we can definitely complete all stage tasks by interlacing between different projects.\nWe denote the sum of the number of stage tasks of all projects as $s$, and the maximum number of stage tasks as $mx$, then the sum of the number of stage tasks of all other projects is $rest = s - mx$.\nIf $mx > rest + 1$, then we cannot complete all stage tasks, and at most we can complete $rest \\times 2 + 1$ stage tasks. Otherwise, we can complete all stage tasks, the number is $s$.\nThe time complexity is $O(n)$, where $n$ is the number of projects. The space complexity is $O(1)$. \n\n", "problem_ids": ["number-of-corner-rectangles", "smallest-range-ii", "maximum-number-of-weeks-for-which-you-can-work"]}, "3234": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string array features where features[i] is a single word that represents the name of a feature of the latest product you are working on. You have made a survey where users have reported which features they like. You are given a string array responses, where each responses[i] is a string containing space-separated words.\nThe popularity of a feature is the number of responses[i] that contain the feature. You want to sort the features in non-increasing order by their popularity. If two features have the same popularity, order them by their original index in features. Notice that one response could contain the same feature multiple times; this feature is only counted once in its popularity.\nReturn the features in sorted order.\n\u00a0\nExample 1:\n\nInput: features = [\"cooler\",\"lock\",\"touch\"], responses = [\"i like cooler cooler\",\"lock touch cool\",\"locker like touch\"]\nOutput: [\"touch\",\"cooler\",\"lock\"]\nExplanation: appearances(\"cooler\") = 1, appearances(\"lock\") = 1, appearances(\"touch\") = 2. Since \"cooler\" and \"lock\" both had 1 appearance, \"cooler\" comes first because \"cooler\" came first in the features array.\n\nExample 2:\n\nInput: features = [\"a\",\"aa\",\"b\",\"c\"], responses = [\"a\",\"a aa\",\"a a a a a\",\"b a\"]\nOutput: [\"a\",\"aa\",\"b\",\"c\"]\n\n\u00a0\nConstraints:\n\n1 <= features.length <= 104\n1 <= features[i].length <= 10\nfeatures contains no duplicates.\nfeatures[i] consists of lowercase letters.\n1 <= responses.length <= 102\n1 <= responses[i].length <= 103\nresponses[i] consists of lowercase letters and spaces.\nresponses[i] contains no two consecutive spaces.\nresponses[i] has no leading or trailing spaces. Explanation:\n\nSolution 1: Hash Table + Custom Sorting\nWe traverse responses, and for each word in responses[i], we temporarily store it in a hash table vis. Next, we record the words in vis into the hash table cnt, recording the number of times each word appears.\nNext, we use custom sorting to sort the words in features in descending order of occurrence. If the number of occurrences is the same, we sort them in ascending order of the index where they appear.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the length of features. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.\n\u00a0\nExample 1:\n\nInput: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.\n\nExample 2:\n\nInput: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104\n\n\u00a0 Explanation:\n\nSolution 1: Simulation\nStarting from both ends of the array, we take out one element at a time, concatenate it with another element, and then add the concatenated result to the answer. We repeat this process until the array is empty.\nThe time complexity is $O(n \\times \\log M)$, and the space complexity is $O(\\log M)$. Here, $n$ and $M$ are the length of the array and the maximum value in the array, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a string s and an integer k, return true if s is a k-palindrome.\nA string is k-palindrome if it can be transformed into a palindrome by removing at most k characters from it.\n\u00a0\nExample 1:\n\nInput: s = \"abcdeca\", k = 2\nOutput: true\nExplanation: Remove 'b' and 'e' characters.\n\nExample 2:\n\nInput: s = \"abbababa\", k = 1\nOutput: true\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 1000\ns consists of only lowercase English letters.\n1 <= k <= s.length Explanation:\n\nSolution 1: Dynamic Programming\nThe problem requires us to remove at most $k$ characters to make the remaining string a palindrome. This can be transformed into finding the longest palindromic subsequence.\nWe define $f[i][j]$ as the length of the longest palindromic subsequence in the substring $s[i..j]$. Initially, we have $f[i][i] = 1$ for all $i$, since each single character is a palindrome.\nIf $s[i] = s[j]$, then we have $f[i][j] = f[i+1][j-1] + 2$, since we can add both $s[i]$ and $s[j]$ to the longest palindromic subsequence of $s[i+1..j-1]$.\nIf $s[i] \\neq s[j]$, then we have $f[i][j] = \\max(f[i+1][j], f[i][j-1])$, since we need to remove either $s[i]$ or $s[j]$ to make the remaining substring a palindrome.\nFinally, we check whether there exists $f[i][j] + k \\geq n$, where $n$ is the length of the string $s$. If so, it means that we can remove at most $k$ characters to make the remaining string a palindrome.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of the string $s$. \n\n", "problem_ids": ["sort-features-by-popularity", "find-the-array-concatenation-value", "valid-palindrome-iii"]}, "3235": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string s, your task is to find the length of the longest self-contained substring of s.\nA substring t of a string s is called self-contained if t != s and for every character in t, it doesn't exist in the rest of s.\nReturn the length of the longest self-contained substring of s if it exists, otherwise, return -1.\n\u00a0\nExample 1:\n\nInput: s = \"abba\"\nOutput: 2\nExplanation:\nLet's check the substring \"bb\". You can see that no other \"b\" is outside of this substring. Hence the answer is 2.\n\nExample 2:\n\nInput: s = \"abab\"\nOutput: -1\nExplanation:\nEvery substring we choose does not satisfy the described property (there is some character which is inside and outside of that substring). So the answer would be -1.\n\nExample 3:\n\nInput: s = \"abacd\"\nOutput: 4\nExplanation:\nLet's check the substring \"abac\". There is only one character outside of this substring and that is \"d\". There is no \"d\" inside the chosen substring, so it satisfies the condition and the answer is 4.\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 5 * 104\ns consists only of lowercase English letters. Explanation:\n\nSolution 1: Enumeration\nWe notice that the start of a substring that meets the conditions must be the position where a character appears for the first time.\nTherefore, we can use two arrays or hash tables first and last to record the positions where each character appears for the first time and the last time, respectively.\nNext, we enumerate each character c. Suppose the position where c first appears is $i$, and the position where it last appears is $mx$. Then we can start traversing from $i$. For each position $j$, we find the position $a$ where $s[j]$ first appears and the position $b$ where it last appears. If $a < i$, it means that $s[j]$ is on the left of $c$, which does not meet the enumeration conditions, and we can exit the loop directly. Otherwise, we update $mx = \\max(mx, b)$. If $mx = j$ and $j - i + 1 < n$, we update the answer to $ans = \\max(ans, j - i + 1)$.\nFinally, return the answer.\nThe time complexity is $O(n \\times |\\Sigma|)$, and the space complexity is $O(|\\Sigma|)$. Where $n$ is the length of the string $s$; and $|\\Sigma|$ is the size of the character set. In this problem, the character set is lowercase letters, so $|\\Sigma| = 26$. \n\nSimilar Problem 2 \n\n Problem:\n\nA trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nint countWordsEqualTo(String word) Returns the number of instances of the string word in the trie.\nint countWordsStartingWith(String prefix) Returns the number of strings in the trie that have the string prefix as a prefix.\nvoid erase(String word) Erases the string word from the trie.\n\n\u00a0\nExample 1:\n\nInput\n[\"Trie\", \"insert\", \"insert\", \"countWordsEqualTo\", \"countWordsStartingWith\", \"erase\", \"countWordsEqualTo\", \"countWordsStartingWith\", \"erase\", \"countWordsStartingWith\"]\n[[], [\"apple\"], [\"apple\"], [\"apple\"], [\"app\"], [\"apple\"], [\"apple\"], [\"app\"], [\"apple\"], [\"app\"]]\nOutput\n[null, null, null, 2, 2, null, 1, 1, null, 0]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");               // Inserts \"apple\".\ntrie.insert(\"apple\");               // Inserts another \"apple\".\ntrie.countWordsEqualTo(\"apple\");    // There are two instances of \"apple\" so return 2.\ntrie.countWordsStartingWith(\"app\"); // \"app\" is a prefix of \"apple\" so return 2.\ntrie.erase(\"apple\");                // Erases one \"apple\".\ntrie.countWordsEqualTo(\"apple\");    // Now there is only one instance of \"apple\" so return 1.\ntrie.countWordsStartingWith(\"app\"); // return 1\ntrie.erase(\"apple\");                // Erases \"apple\". Now the trie is empty.\ntrie.countWordsStartingWith(\"app\"); // return 0\n\n\u00a0\nConstraints:\n\n1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, countWordsEqualTo, countWordsStartingWith, and erase.\nIt is guaranteed that for any function call to erase, the string word will exist in the trie. Explanation:\n\nSolution 1: Implement Trie with Array\nEach node in the Trie includes three parts:\n\nAn array of pointers children pointing to child nodes. For this problem, the array length is 26, which is the number of lowercase English letters. children[0] corresponds to the lowercase letter a, ..., children[25] corresponds to the lowercase letter z.\nAn int variable v, representing the number of strings ending with this node.\nAn int variable pv, representing the number of strings with this node as the prefix node.\n\n1. Insert String\nWe start from the root of the Trie and insert the string. For the child node corresponding to the current character, there are two cases:\n\nThe child node exists. Move to the child node along the pointer and continue to process the next character.\nThe child node does not exist. Create a new child node, record it in the corresponding position of the children array, then move to the child node along the pointer, and increase the pv value of the child node by 1. Continue to search for the next character.\n\nRepeat the above steps until the last character of the string is processed, then increase the v value of the current node by 1.\nThe time complexity is $O(n)$, where $n$ is the length of the string.\n2. Search Prefix\nWe start from the root of the Trie and search for the prefix. For the child node corresponding to the current character, there are two cases:\n\nThe child node exists. Move to the child node along the pointer and continue to search for the next character.\nThe child node does not exist. This means that the Trie does not contain this prefix, return a null pointer.\n\nRepeat the above steps until a null pointer is returned or the last character of the prefix is searched.\nThe time complexity is $O(n)$, where $n$ is the length of the string.\n3. Remove String\nWe start from the root node of the Trie, and sequentially reduce the pv value of the corresponding child node by 1, until the last character of the string is searched. Then reduce the v value of the current node by 1.\nThe time complexity is $O(n)$, where $n$ is the length of the string. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nExample 1:\nInput: nums = [1,1,1], k = 2\nOutput: 2\n\nExample 2:\nInput: nums = [1,2,3], k = 3\nOutput: 2\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 2 * 104\n-1000 <= nums[i] <= 1000\n-107 <= k <= 107 Explanation:\n\nSolution 1: Hash Table + Prefix Sum\nWe define a hash table cnt to store the number of times the prefix sum of the array nums appears. Initially, we set the value of cnt[0] to 1, indicating that the prefix sum 0 appears once.\nWe traverse the array nums, calculate the prefix sum s, then add the value of cnt[s - k] to the answer, and increase the value of cnt[s] by 1.\nAfter the traversal, we return the answer.\nThe time complexity is O(n), and the space complexity is O(n). Where n is the length of the array nums. \n\n", "problem_ids": ["find-longest-self-contained-substring", "implement-trie-ii-(prefix-tree)", "subarray-sum-equals-k"]}, "3236": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.\nWe will remove exactly one node from initial, completely removing it and any connections from this node to any other node.\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n\u00a0\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\n\nExample 2:\nInput: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\nOutput: 1\n\nExample 3:\nInput: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\nOutput: 1\n\n\u00a0\nConstraints:\n\nn == graph.length\nn == graph[i].length\n2 <= n <= 300\ngraph[i][j] is 0 or 1.\ngraph[i][j] == graph[j][i]\ngraph[i][i] == 1\n1 <= initial.length <\u00a0n\n0 <= initial[i] <= n - 1\nAll the integers in initial are unique. Explanation:\n\nSolution 1: Union-Find\nWe can use the union-find data structure to merge all nodes that are not in $initial$ and satisfy $graph[i][j] = 1$.\nNext, we create a hash table $g$, where $g[i]$ represents the root node of the connected component that is connected to node $i$. We also need a counter $cnt$ to count how many initial nodes each root node is infected by.\nFor each initially infected node $i$, we traverse all nodes $j$ connected to node $i$. If node $j$ is not in $initial$, we add the root node of node $j$ to the set $g[i]$. At the same time, we count how many initial nodes each root node is infected by and save the result in the counter $cnt$.\nThen, we use a variable $ans$ to record the answer, and $mx$ to record the maximum number of infected nodes that can be reduced. Initially, $ans = 0$, $mx = -1$.\nWe traverse all initially infected nodes. For each node $i$, we traverse all root nodes in $g[i]$. If a root node is only infected by one initial node, we add the size of the connected component where the root node is located to $t$. If $t > mx$ or $t = mx$ and $i < ans$, we update $ans = i$, $mx = t$.\nFinally, we return $ans$.\nThe time complexity is $O(n^2 \\times \\alpha(n))$, and the space complexity is $O(n^2)$. Where $n$ is the number of nodes, and $\\alpha(n)$ is the inverse Ackermann function. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven three integer arrays a, b, and c, return the number of triplets (a[i], b[j], c[k]), such that the bitwise XOR between the elements of each triplet has an even number of set bits.\n\u00a0\nExample 1:\n\nInput: a = [1], b = [2], c = [3]\nOutput: 1\nExplanation:\nThe only triplet is (a[0], b[0], c[0]) and their XOR is: 1 XOR 2 XOR 3 = 002.\n\nExample 2:\n\nInput: a = [1,1], b = [2,3], c = [1,5]\nOutput: 4\nExplanation:\nConsider these four triplets:\n\n(a[0], b[1], c[0]): 1 XOR 3 XOR 1 = 0112\n(a[1], b[1], c[0]): 1 XOR 3 XOR 1 = 0112\n(a[0], b[0], c[1]): 1 XOR 2 XOR 5 = 1102\n(a[1], b[0], c[1]): 1 XOR 2 XOR 5 = 1102\n\n\n\u00a0\nConstraints:\n\n1 <= a.length, b.length, c.length <= 105\n0 <= a[i], b[i], c[i] <= 109 Explanation:\n\nSolution 1: Bit Manipulation\nFor two integers, the parity of the number of $1$s in the XOR result depends on the parity of the number of $1$s in the binary representations of the two integers.\nWe can use three arrays cnt1, cnt2, cnt3 to record the parity of the number of $1$s in the binary representations of each number in arrays a, b, c, respectively.\nThen, we enumerate the parity of the number of $1$s in the binary representations of each number in the three arrays within the range $[0, 1]$. If the sum of the parity of the number of $1$s in the binary representations of three numbers is even, then the number of $1$s in the XOR result of these three numbers is also even. At this time, we multiply the combination of these three numbers and accumulate it into the answer.\nFinally, return the answer.\nThe time complexity is $O(n)$, where $n$ is the length of arrays a, b, c. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums, and an integer k. Let's introduce\u00a0K-or operation by extending the standard bitwise OR. In K-or, a bit position in the result is set to 1\u00a0if at least k numbers in nums have a 1 in that position.\nReturn the K-or of nums.\n\u00a0\nExample 1: \n\nInput: nums = [7,12,9,8,9,15], k = 4 \nOutput: 9 \nExplanation: \nRepresent numbers in binary:\n\n\n\nNumber\nBit 3\nBit 2\nBit 1\nBit 0\n\n\n7\n0\n1\n1\n1\n\n\n12\n1\n1\n0\n0\n\n\n9\n1\n0\n0\n1\n\n\n8\n1\n0\n0\n0\n\n\n9\n1\n0\n0\n1\n\n\n15\n1\n1\n1\n1\n\n\nResult = 9\n1\n0\n0\n1\n\n\n\nBit 0 is set in 7, 9, 9, and 15. Bit 3 is set in 12, 9, 8, 9, and 15.\nOnly bits 0 and 3 qualify. The result is (1001)2 = 9.\n\nExample 2: \n\nInput: nums = [2,12,1,11,4,5], k = 6 \nOutput: 0 \nExplanation:\u00a0No bit appears as 1 in all six array numbers, as required for K-or with k = 6. Thus, the result is 0.\n\nExample 3: \n\nInput: nums = [10,8,5,9,11,6,8], k = 1 \nOutput: 15 \nExplanation:  Since k == 1, the 1-or of the array is equal to the bitwise OR of all its elements. Hence, the answer is 10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n0 <= nums[i] < 231\n1 <= k <= nums.length Explanation:\n\nSolution 1: Enumeration\nWe can enumerate each bit $i$ in the range $[0, 32)$, and count the number of numbers in the array $nums$ whose $i$-th bit is $1$, denoted as $cnt$. If $cnt \\ge k$, we add $2^i$ to the answer.\nAfter the enumeration, we return the answer.\nThe time complexity is $O(n \\times \\log M)$, where $n$ and $M$ are the length of the array $nums$ and the maximum value in $nums$, respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["minimize-malware-spread-ii", "count-triplets-with-even-xor-set-bits-ii", "find-the-k-or-of-an-array"]}, "3239": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two strings initial and target, your task is to modify initial by performing a series of operations to make it equal to target.\nIn one operation, you can add or remove one character only at the beginning or the end of the string initial.\nReturn the minimum number of operations required to transform initial into target.\n\u00a0\nExample 1:\n\nInput: initial = \"abcde\", target = \"cdef\"\nOutput: 3\nExplanation:\nRemove 'a' and 'b' from the beginning of initial, then add 'f' to the end.\n\nExample 2:\n\nInput: initial = \"axxy\", target = \"yabx\"\nOutput: 6\nExplanation:\n\n\n\nOperation\nResulting String\n\n\nAdd 'y' to the beginning\n\"yaxxy\"\n\n\nRemove from end\n\"yaxx\"\n\n\nRemove from end\n\"yax\"\n\n\nRemove from end\n\"ya\"\n\n\nAdd 'b' to the end\n\"yab\"\n\n\nAdd 'x' to the end\n\"yabx\"\n\n\n\n\nExample 3:\n\nInput: initial = \"xyz\", target = \"xyz\"\nOutput: 0\nExplanation:\nNo operations are needed as the strings are already equal.\n\n\u00a0\nConstraints:\n\n1 <= initial.length, target.length <= 1000\ninitial and target consist only of lowercase English letters. Explanation:\n\nSolution 1: Dynamic Programming\nLet's assume that the lengths of the strings initial and target are $m$ and $n$, respectively.\nAccording to the problem description, we only need to find the length $mx$ of the longest common substring of initial and target. Then, we can delete $m - mx$ characters from initial and add $n - mx$ characters to transform initial into target. Therefore, the answer is $m + n - 2 \\times mx$.\nWe can use dynamic programming to find the length $mx$ of the longest common substring of initial and target. We define a two-dimensional array $f$, where $f[i][j]$ represents the length of the longest common substring ending with initial[i - 1] and target[j - 1]. Then, we can get the state transition equation:\n$$\nf[i][j] = \\begin{cases}\nf[i - 1][j - 1] + 1, & \\textit{if } \\textit{initial}[i - 1] = \\textit{target}[j - 1], \\\n0, & \\textit{otherwise}.\n\\end{cases}\n$$\nThen $mx = \\max f[i][j]$, and the final answer is $m + n - 2 \\times mx$.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the lengths of the strings initial and target, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:\n\nThe first ten characters consist of the phone number of passengers.\nThe next character denotes the gender of the person.\nThe following two characters are used to indicate the age of the person.\nThe last two characters determine the seat allotted to that person.\n\nReturn the number of passengers who are strictly more than 60 years old.\n\u00a0\nExample 1:\n\nInput: details = [\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"]\nOutput: 2\nExplanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.\n\nExample 2:\n\nInput: details = [\"1313579440F2036\",\"2921522980M5644\"]\nOutput: 0\nExplanation: None of the passengers are older than 60.\n\n\u00a0\nConstraints:\n\n1 <= details.length <= 100\ndetails[i].length == 15\ndetails[i] consists of digits from '0' to '9'.\ndetails[i][10] is either 'M' or 'F' or 'O'.\nThe phone numbers and seat numbers of the passengers are distinct. Explanation:\n\nSolution 1: Traversal and Counting\nWe can traverse each string $x$ in details and convert the $12$th and $13$th characters (indexed at $11$ and $12$) of $x$ to integers, and check if they are greater than $60$. If so, we add one to the answer.\nAfter the traversal, we return the answer.\nThe time complexity is $O(n)$, where $n$ is the length of details. The space complexity is $O(1)`. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\n\u00a0\nExample 1:\n\n\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\nExample 2:\n\n\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [2, 1000].\n-231 <= Node.val <= 231 - 1\n\n\u00a0\nFollow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution? Explanation:\n\nSolution 1: In-order Traversal\nIn-order traversal of a binary search tree results in an increasing sequence. If two nodes' values are mistakenly swapped, there will definitely be two reverse pairs in the sequence obtained from the in-order traversal. We use first and second to record the smaller and larger values of these two reverse pairs, respectively. Finally, swapping the values of these two nodes will correct the mistake.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary search tree. \n\n", "problem_ids": ["equalize-strings-by-adding-or-removing-characters-at-ends", "number-of-senior-citizens", "recover-binary-search-tree"]}, "3240": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\nFor example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.\nThe test cases are generated so that the answer fits in a 32-bits integer.\n\u00a0\nExample 1:\n\n\nInput: root = [1,0,1,0,1,0,1]\nOutput: 22\nExplanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\nExample 2:\n\nInput: root = [0]\nOutput: 0\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\nNode.val is 0 or 1. Explanation:\n\nSolution 1: Recursion\nWe design a recursive function dfs(root, t), which takes two parameters: the current node root and the binary number corresponding to the parent node t. The return value of the function is the sum of the binary numbers represented by the path from the current node to the leaf node. The answer is dfs(root, 0).\nThe logic of the recursive function is as follows:\n\nIf the current node root is null, then return 0. Otherwise, calculate the binary number t corresponding to the current node, i.e., t = t << 1 | root.val.\nIf the current node is a leaf node, then return t. Otherwise, return the sum of dfs(root.left, t) and dfs(root.right, t).\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the binary tree. Each node is visited once; the recursion stack requires $O(n)$ space. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given three positive integers:\u00a0n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:\n\nnums.length == n\nnums[i] is a positive integer where 0 <= i < n.\nabs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.\nThe sum of all the elements of nums does not exceed maxSum.\nnums[index] is maximized.\n\nReturn nums[index] of the constructed array.\nNote that abs(x) equals x if x >= 0, and -x otherwise.\n\u00a0\nExample 1:\n\nInput: n = 4, index = 2,  maxSum = 6\nOutput: 2\nExplanation: nums = [1,2,2,1] is one array that satisfies all the conditions.\nThere are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].\n\nExample 2:\n\nInput: n = 6, index = 1,  maxSum = 10\nOutput: 3\n\n\u00a0\nConstraints:\n\n1 <= n <= maxSum <= 109\n0 <= index < n Explanation:\n\nSolution 1: Binary Search\nAccording to the problem description, if we determine the value of $nums[index]$ as $x$, we can find a minimum array sum. That is, the elements on the left side of $index$ in the array decrease from $x-1$ to $1$, and if there are remaining elements, the remaining elements are all $1$; similarly, the elements at $index$ and on the right side of the array decrease from $x$ to $1$, and if there are remaining elements, the remaining elements are all $1$.\nIn this way, we can calculate the sum of the array. If the sum is less than or equal to $maxSum$, then the current $x$ is valid. As $x$ increases, the sum of the array will also increase, so we can use the binary search method to find the maximum $x$ that meets the conditions.\nTo facilitate the calculation of the sum of the elements on the left and right sides of the array, we define a function $sum(x, cnt)$, which represents the sum of an array with $cnt$ elements and a maximum value of $x$. The function $sum(x, cnt)$ can be divided into two cases:\n\nIf $x \\geq cnt$, then the sum of the array is $\\frac{(x + x - cnt + 1) \\times cnt}{2}$\nIf $x \\lt cnt$, then the sum of the array is $\\frac{(x + 1) \\times x}{2} + cnt - x$\n\nNext, define the left boundary of the binary search as $left = 1$, the right boundary as $right = maxSum$, and then binary search for the value $mid$ of $nums[index]$. If $sum(mid - 1, index) + sum(mid, n - index) \\leq maxSum$, then the current $mid$ is valid, we can update $left$ to $mid$, otherwise we update $right$ to $mid - 1$.\nFinally, return $left$ as the answer.\nThe time complexity is $O(\\log M)$, where $M=maxSum$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a string road, consisting only of characters \"x\" and \".\", where each \"x\" denotes a pothole and each \".\" denotes a smooth road, and an integer budget.\nIn one repair operation, you can repair n consecutive potholes for a price of n + 1.\nReturn the maximum number of potholes that can be fixed such that the sum of the prices of all of the fixes doesn't go over the given budget.\n\u00a0\nExample 1:\n\nInput: road = \"..\", budget = 5\nOutput: 0\nExplanation:\nThere are no potholes to be fixed.\n\nExample 2:\n\nInput: road = \"..xxxxx\", budget = 4\nOutput: 3\nExplanation:\nWe fix the first three potholes (they are consecutive). The budget needed for this task is 3 + 1 = 4.\n\nExample 3:\n\nInput: road = \"x.x.xxx...x\", budget = 14\nOutput: 6\nExplanation:\nWe can fix all the potholes. The total cost would be (1 + 1) + (1 + 1) + (3 + 1) + (1 + 1) = 10 which is within our budget of 14.\n\n\u00a0\nConstraints:\n\n1 <= road.length <= 105\n1 <= budget <= 105 + 1\nroad consists only of characters '.' and 'x'. Explanation:\n\nSolution 1: Counting + Greedy\nFirst, we count the number of each continuous pothole, recorded in the array $cnt$, i.e., $cnt[k]$ represents there are $cnt[k]$ continuous potholes of length $k$.\nSince we want to repair as many potholes as possible, and for a continuous pothole of length $k$, we need to spend a cost of $k + 1$, we should prioritize repairing longer potholes to minimize the cost.\nTherefore, we start repairing from the longest pothole. For a pothole of length $k$, the maximum number we can repair is $t = \\min(\\textit{budget} / (k + 1), \\textit{cnt}[k])$. We add the number of repairs multiplied by the length $k$ to the answer, then update the remaining budget. For the remaining $cnt[k] - t$ potholes of length $k$, we merge them into the potholes of length $k - 1$. Continue this process until all potholes are traversed.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string $road$. \n\n", "problem_ids": ["sum-of-root-to-leaf-binary-numbers", "maximum-value-at-a-given-index-in-a-bounded-array", "maximum-number-of-potholes-that-can-be-fixed"]}, "3242": {"text": "Similar Problem 1 \n\n Problem:\n\nThe demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\nTo reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\nReturn the knight's minimum initial health so that he can rescue the princess.\nNote that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n\u00a0\nExample 1:\n\n\nInput: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\nOutput: 7\nExplanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\nExample 2:\n\nInput: dungeon = [[0]]\nOutput: 1\n\n\u00a0\nConstraints:\n\nm == dungeon.length\nn == dungeon[i].length\n1 <= m, n <= 200\n-1000 <= dungeon[i][j] <= 1000 Explanation:\n\nSolution 1: Dynamic Programming\nWe define $dp[i][j]$ as the minimum initial value needed from $(i, j)$ to the end point. The value of $dp[i][j]$ can be obtained from $dp[i+1][j]$ and $dp[i][j+1]$, that is:\n$$\ndp[i][j] = \\max(\\min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\n$$\nInitially, $dp[m][n-1]$ and $dp[m-1][n]$ are both $1$, and the values at other positions are maximum.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows and columns of the dungeon, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.\nYou are restricted with the following rules:\n\nThe division operator '/' represents real division, not integer division.\n\n    \nFor example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.\n\n\nEvery operation done is between two numbers. In particular, we cannot use '-' as a unary operator.\n    \nFor example, if cards = [1, 1, 1, 1], the expression \"-1 - 1 - 1 - 1\" is not allowed.\n\n\nYou cannot concatenate numbers together\n    \nFor example, if cards = [1, 2, 1, 2], the expression \"12 + 12\" is not valid.\n\n\n\nReturn true if you can get such expression that evaluates to 24, and false otherwise.\n\u00a0\nExample 1:\n\nInput: cards = [4,1,8,7]\nOutput: true\nExplanation: (8-4) * (7-1) = 24\n\nExample 2:\n\nInput: cards = [1,2,1,2]\nOutput: false\n\n\u00a0\nConstraints:\n\ncards.length == 4\n1 <= cards[i] <= 9 Explanation:\n\nSolution 1: DFS\nWe design a function $dfs(nums)$, where $nums$ represents the current number sequence. The function returns a boolean value indicating whether there exists a permutation that makes this number sequence equal to $24$.\nIf the length of $nums$ is $1$, we return $true$ only when this number is $24$, otherwise we return $false$.\nOtherwise, we can enumerate any two numbers $a$ and $b$ in $nums$ as the left and right operands, and enumerate the operator $op$ between $a$ and $b$. The result of $a\\ op\\ b$ can be used as an element of the new number sequence. We add it to the new number sequence and remove $a$ and $b$ from $nums$, then recursively call the $dfs$ function. If it returns $true$, it means we have found a permutation that makes this number sequence equal to $24$, and we return $true$.\nIf none of the enumerated cases return $true$, we return $false$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.\nReturn the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\n\u00a0\nExample 1:\n\nInput: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2\nOutput: 3\nExplanation:\nPlace 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now [2,3,4,4].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3.\n\nExample 2:\n\nInput: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100\nOutput: 3\nExplanation:\nPlace 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now [10,2,2].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks.\n\n\u00a0\nConstraints:\n\nn == capacity.length == rocks.length\n1 <= n <= 5 * 104\n1 <= capacity[i] <= 109\n0 <= rocks[i] <= capacity[i]\n1 <= additionalRocks <= 109 Explanation:\n\nSolution 1: Sorting + Greedy\nFirst, we calculate the remaining capacity of each bag, then sort the remaining capacities. Next, we traverse the remaining capacities from smallest to largest, putting the extra stones into the bags until the extra stones are used up or the remaining capacities of the bags are exhausted. Finally, we return the number of bags at this point.\nTime complexity is $O(n \\times \\log n)$, and space complexity is $O(\\log n)$. Here, $n$ is the number of bags. \n\n", "problem_ids": ["dungeon-game", "24-game", "maximum-bags-with-full-capacity-of-rocks"]}, "3243": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.\n\u00a0\nExample 1:\n\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n\nExample 2:\n\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n-104 < nums[i], target < 104\nAll the integers in nums are unique.\nnums is sorted in ascending order. Explanation:\n\nSolution 1: Binary Search\nWe define the left boundary $l=0$ and the right boundary $r=n-1$ for binary search.\nIn each iteration, we calculate the middle position $\\textit{mid}=(l+r)/2$, then compare the size of $\\textit{nums}[\\textit{mid}]$ and $\\textit{target}$.\n\nIf $\\textit{nums}[\\textit{mid}] \\geq \\textit{target}$, it means $\\textit{target}$ is in the left half, so we move the right boundary $r$ to $\\textit{mid}$;\nOtherwise, it means $\\textit{target}$ is in the right half, so we move the left boundary $l$ to $\\textit{mid}+1$.\n\nThe loop ends when $l<r$, at this point $\\textit{nums}[l]$ is the target value we are looking for. If $\\textit{nums}[l]=\\textit{target}$, return $l$; otherwise, return $-1$.\nThe time complexity is $O(\\log n)$, where $n$ is the length of the array $\\textit{nums}$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nTable: Customers\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID and name of a customer.\n\n\u00a0\nTable: Orders\n\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\ncustomerId is a foreign key (reference columns) of the ID from the Customers table.\nEach row of this table indicates the ID of an order and the ID of the customer who ordered it.\n\n\u00a0\nWrite a solution to find all customers who never order anything.\nReturn the result table in any order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\nOutput: \n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+ Explanation:\n\nSolution 1: NOT IN\nList all customer IDs of existing orders, and use NOT IN to find customers who are not in the list. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums and two integers indexDiff and valueDiff.\nFind a pair of indices (i, j) such that:\n\ni != j,\nabs(i - j) <= indexDiff.\nabs(nums[i] - nums[j]) <= valueDiff, and\n\nReturn true if such pair exists or false otherwise.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\n\nExample 2:\n\nInput: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false\nExplanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 105\n-109 <= nums[i] <= 109\n1 <= indexDiff <= nums.length\n0 <= valueDiff <= 109 Explanation:\n\nSolution 1: Sliding Window + Ordered Set\nWe maintain a sliding window of size $k$, and the elements in the window are kept in order.\nWe traverse the array nums. For each element $nums[i]$, we look for the first element in the ordered set that is greater than or equal to $nums[i] - t$. If the element exists, and this element is less than or equal to $nums[i] + t$, it means we have found a pair of elements that meet the conditions, and we return true. Otherwise, we insert $nums[i]$ into the ordered set, and if the size of the ordered set exceeds $k$, we need to remove the earliest added element from the ordered set.\nThe time complexity is $O(n \\times \\log k)$, where $n$ is the length of the array nums. For each element, we need $O(\\log k)$ time to find the element in the ordered set, and there are $n$ elements in total, so the total time complexity is $O(n \\times \\log k)$. \n\n", "problem_ids": ["binary-search", "customers-who-never-order", "contains-duplicate-iii"]}, "3244": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array nums of n integers, and an integer k.\nThe k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.\nBuild and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.\nThe average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.\n\nFor example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.\n\n\u00a0\nExample 1:\n\n\nInput: nums = [7,4,3,9,1,8,5,2,6], k = 3\nOutput: [-1,-1,-1,5,4,4,-1,-1,-1]\nExplanation:\n- avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.\n- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.\n  Using integer division, avg[3] = 37 / 7 = 5.\n- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.\n- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.\n- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.\n\nExample 2:\n\nInput: nums = [100000], k = 0\nOutput: [100000]\nExplanation:\n- The sum of the subarray centered at index 0 with radius 0 is: 100000.\n  avg[0] = 100000 / 1 = 100000.\n\nExample 3:\n\nInput: nums = [8], k = 100000\nOutput: [-1]\nExplanation: \n- avg[0] is -1 because there are less than k elements before and after index 0.\n\n\u00a0\nConstraints:\n\nn == nums.length\n1 <= n <= 105\n0 <= nums[i], k <= 105 Explanation:\n\nSolution 1: Sliding Window\nThe number of elements in a subarray with radius $k$ is $k \\times 2 + 1$. Therefore, we can redefine $k$ as $k \\times 2 + 1$.\nWe create an answer array $ans$ of length $n$, initially each element is $-1$.\nNext, we first check whether $k$ is greater than the length $n$ of the array nums. If it is, we directly return the answer array.\nOtherwise, we calculate the sum $s$ of the first $k$ elements of the array nums, and assign the quotient of $s$ divided by $k$ to the $j$-th element of the answer array $ans$, where $j = k / 2$.\nThen, we start traversing the array nums from $k$. For each iteration, we add the value of $nums[i]$ to $s$ and subtract the value of $nums[i - k]$, and update $j = j + 1$. Then we get the sum $s$ of the subarray with the $j$-th element as the center and radius $k$, and assign the quotient of $s$ divided by $k$ to the $j$-th element of the answer array $ans$.\nFinally, we return the answer array.\nThe time complexity is $O(n)$, where $n$ is the length of the array nums. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] < target.\n\u00a0\nExample 1:\n\nInput: nums = [-1,1,2,3,1], target = 2\nOutput: 3\nExplanation: There are 3 pairs of indices that satisfy the conditions in the statement:\n- (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target\n- (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target \n- (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target\nNote that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.\n\nExample 2:\n\nInput: nums = [-6,2,5,-2,-7,-1,3], target = -2\nOutput: 10\nExplanation: There are 10 pairs of indices that satisfy the conditions in the statement:\n- (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target\n- (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target\n- (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target\n- (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target\n- (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target\n- (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target\n- (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target\n- (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target\n- (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target\n- (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target\n\n\u00a0\nConstraints:\n\n1 <= nums.length == n <= 50\n-50 <= nums[i], target <= 50 Explanation:\n\nSolution 1: Sorting + Binary Search\nFirst, we sort the array $nums$. Then, for each $j$, we use binary search in the range $[0, j)$ to find the first index $i$ that is greater than or equal to $target - nums[j]$. All indices $k$ in the range $[0, i)$ meet the condition, so the answer increases by $i$.\nAfter the traversal, we return the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 3 \n\n Problem:\n\nThe power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps:\n\nif x is even then x = x / 2\nif x is odd then x = 3 * x + 1\n\nFor example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).\nGiven three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, if two or more integers have the same power value sort them by ascending order.\nReturn the kth integer in the range [lo, hi] sorted by the power value.\nNotice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in a 32-bit signed integer.\n\u00a0\nExample 1:\n\nInput: lo = 12, hi = 15, k = 2\nOutput: 13\nExplanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)\nThe power of 13 is 9\nThe power of 14 is 17\nThe power of 15 is 17\nThe interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13.\nNotice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.\n\nExample 2:\n\nInput: lo = 7, hi = 11, k = 4\nOutput: 7\nExplanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14].\nThe interval sorted by power is [8, 10, 11, 7, 9].\nThe fourth number in the sorted array is 7.\n\n\u00a0\nConstraints:\n\n1 <= lo <= hi <= 1000\n1 <= k <= hi - lo + 1 Explanation:\n\nSolution 1: Custom Sorting\nFirst, we define a function $f(x)$, which represents the number of steps required to change the number $x$ to $1$, i.e., the weight of the number $x$.\nThen, we sort all the numbers in the interval $[lo, hi]$ in ascending order of weight. If the weights are the same, we sort them in ascending order of the numbers themselves.\nFinally, we return the $k$-th number after sorting.\nThe time complexity is $O(n \\times \\log n \\times M)$, and the space complexity is $O(n)$. Where $n$ is the number of numbers in the interval $[lo, hi]$, and $M$ is the maximum value of $f(x)$. In this problem, the maximum value of $M$ is $178$. \n\n", "problem_ids": ["k-radius-subarray-averages", "count-pairs-whose-sum-is-less-than-target", "sort-integers-by-the-power-value"]}, "3245": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,1,1,1], target = 2\nOutput: 2\nExplanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n\nExample 2:\n\nInput: nums = [-1,3,5,1,4,2,-9], target = 6\nOutput: 2\nExplanation: There are 3 subarrays with sum equal to 6.\n([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n0 <= target <= 106 Explanation:\n\nSolution 1: Greedy + Prefix Sum + Hash Table\nWe traverse the array $nums$, using the method of prefix sum + hash table, to find subarrays with a sum of $target$. If found, we increment the answer by one, then we set the prefix sum to $0$ and continue to traverse the array $nums$ until the entire array is traversed.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an integer n. Consider an equilateral triangle of side length n, broken up into n2 unit equilateral triangles. The triangle has n 1-indexed rows where the ith row has 2i - 1 unit equilateral triangles.\nThe triangles in the ith row are also 1-indexed with coordinates from (i, 1) to (i, 2i - 1). The following image shows a triangle of side length 4 with the indexing of its triangle.\n\nTwo triangles are neighbors if they share a side. For example:\n\nTriangles (1,1) and (2,2) are neighbors\nTriangles (3,2) and (3,3) are neighbors.\nTriangles (2,2) and (3,3) are not neighbors because they do not share any side.\n\nInitially, all the unit triangles are white. You want to choose k triangles and color them red. We will then run the following algorithm:\n\nChoose a white triangle that has at least two red neighbors.\n\n    \nIf there is no such triangle, stop the algorithm.\n\n\nColor that triangle red.\nGo to step 1.\n\nChoose the minimum k possible and set k triangles red before running this algorithm such that after the algorithm stops, all unit triangles are colored red.\nReturn a 2D list of the coordinates of the triangles that you will color red initially. The answer has to be of the smallest size possible. If there are multiple valid solutions, return any.\n\u00a0\nExample 1:\n\n\nInput: n = 3\nOutput: [[1,1],[2,1],[2,3],[3,1],[3,5]]\nExplanation: Initially, we choose the shown 5 triangles to be red. Then, we run the algorithm:\n- Choose (2,2) that has three red neighbors and color it red.\n- Choose (3,2) that has two red neighbors and color it red.\n- Choose (3,4) that has three red neighbors and color it red.\n- Choose (3,3) that has three red neighbors and color it red.\nIt can be shown that choosing any 4 triangles and running the algorithm will not make all triangles red.\n\nExample 2:\n\n\nInput: n = 2\nOutput: [[1,1],[2,1],[2,3]]\nExplanation: Initially, we choose the shown 3 triangles to be red. Then, we run the algorithm:\n- Choose (2,2) that has three red neighbors and color it red.\nIt can be shown that choosing any 2 triangles and running the algorithm will not make all triangles red.\n\n\u00a0\nConstraints:\n\n1 <= n <= 1000 Explanation:\n\nSolution 1: Find the Pattern\nWe draw a graph to observe, and we can find that the first row only has one triangle and must be colored, and from the last row to the second row, the coloring scheme of every four rows is the same:\n\nThe last row is colored at $(n, 1)$, $(n, 3)$, ..., $(n, 2n - 1)$.\nThe $n - 1$ row is colored at $(n - 1, 2)$.\nThe $n - 2$ row is colored at $(n - 2, 3)$, $(n - 2, 5)$, ..., $(n - 2, 2n - 5)$.\nThe $n - 3$ row is colored at $(n - 3, 1)$.\n\n\nTherefore, we can color the first row according to the above rules, and then start from the last row, and color every four rows once until the second row ends.\n\nThe time complexity is $(n^2)$, where $n$ is the parameter given in the problem. Ignoring the space consumption of the answer array, the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\nA sudoku solution must satisfy all of the following rules:\n\nEach of the digits 1-9 must occur exactly once in each row.\nEach of the digits 1-9 must occur exactly once in each column.\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n\nThe '.' character indicates empty cells.\n\u00a0\nExample 1:\n\n\nInput: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation:\u00a0The input board is shown above and the only valid solution is shown below:\n\n\n\n\u00a0\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit or '.'.\nIt is guaranteed that the input board has only one solution. Explanation:\n\nSolution 1: Backtracking\nWe use arrays row, col, and box to record whether a number has appeared in each row, each column, and each 3x3 grid respectively. If the number i has appeared in the rth row, the cth column, and the bth 3x3 grid, then row[r][i], col[c][i], and box[b][i] are all true.\nWe traverse each empty space in board, enumerate the numbers v that it can fill in. If v has not appeared in the current row, the current column, and the current 3x3 grid, then we can try to fill in the number v and continue to search for the next empty space. If we search to the end and all spaces are filled, it means that a feasible solution has been found.\nThe time complexity is $O(9^{81})$, and the space complexity is $O(9^2)$. \n\n", "problem_ids": ["maximum-number-of-non-overlapping-subarrays-with-sum-equals-target", "color-the-triangle-red", "sudoku-solver"]}, "3246": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.\n\n\u00a0\nExample 1:\n\nInput: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].\n\nExample 2:\n\nInput: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = [].\n\n\u00a0\nConstraints:\n\n1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique. Explanation:\n\nSolution 1: Hash Table + Sorting\nWe use a hash table cnt to record the number of matches each player has lost.\nThen we traverse the hash table, put the players who lost 0 matches into ans[0], and put the players who lost 1 match into ans[1].\nFinally, we sort ans[0] and ans[1] in ascending order and return the result.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the number of matches. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given an m x n integer array grid where grid[i][j] could be:\n\n1 representing the starting square. There is exactly one starting square.\n2 representing the ending square. There is exactly one ending square.\n0 representing empty squares we can walk over.\n-1 representing obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\nExample 2:\n\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\nExample 3:\n\n\nInput: grid = [[0,1],[2,0]]\nOutput: 0\nExplanation: There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 20\n1 <= m * n <= 20\n-1 <= grid[i][j] <= 2\nThere is exactly one starting cell and one ending cell. Explanation:\n\nSolution 1: Backtracking\nWe can first traverse the entire grid, find the starting point $(x, y)$, and count the number of blank spaces $cnt$.\nNext, we can start searching from the starting point to get all the path numbers. We design a function $dfs(i, j, k)$ to indicate that the path number is $k$ and the starting point is $(i, j)$.\nIn the function, we first determine whether the current cell is the end point. If it is, we determine whether $k$ is equal to $cnt + 1$. If it is, the current path is a valid path, and $1$ is returned, otherwise $0$ is returned.\nIf the current cell is not the end point, we enumerate the four adjacent cells of the current cell. If the adjacent cell has not been visited, we mark the adjacent cell as visited, and then continue to search the path number from the adjacent cell. After the search is completed, we mark the adjacent cell as unvisited. After the search is completed, we return the sum of the path numbers of all adjacent cells.\nFinally, we return the path number from the starting point, that is, $dfs(x, y, 1)$.\nThe time complexity is $O(3^{m \\times n})$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows and columns of the grid, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nAlice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:\n\nAlice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.\nIt takes the same amount of time to water each plant regardless of how much water it needs.\nAlice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.\nIn case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.\n\u00a0\nExample 1:\n\nInput: plants = [2,2,3,3], capacityA = 5, capacityB = 5\nOutput: 1\nExplanation:\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.\n\nExample 2:\n\nInput: plants = [2,2,3,3], capacityA = 3, capacityB = 4\nOutput: 2\nExplanation:\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.\n\nExample 3:\n\nInput: plants = [5], capacityA = 10, capacityB = 8\nOutput: 0\nExplanation:\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0.\n\n\u00a0\nConstraints:\n\nn == plants.length\n1 <= n <= 105\n1 <= plants[i] <= 106\nmax(plants[i]) <= capacityA, capacityB <= 109 Explanation:\n\nSolution 1: Two Pointers + Simulation\nWe use two variables $a$ and $b$ to represent the amount of water Alice and Bob have, initially $a = \\textit{capacityA}$, $b = \\textit{capacityB}$. Then we use two pointers $i$ and $j$ to point to the head and tail of the plant array, and simulate the process of Alice and Bob watering from both ends to the middle.\nWhen $i < j$, we judge whether Alice and Bob have enough water to water the plants. If not, we refill the watering cans. Then we update the amount of water $a$ and $b$, and move the pointers $i$ and $j$. Finally, we need to judge whether $i$ and $j$ are equal. If they are equal, we need to judge whether $\\max(a, b)$ is less than the amount of water the plant needs. If it is less, we need to refill the watering cans again.\nThe time complexity is $O(n)$, where $n$ is the length of the plant array. The space complexity is $O(1)$. \n\n", "problem_ids": ["find-players-with-zero-or-one-losses", "unique-paths-iii", "watering-plants-ii"]}, "3249": {"text": "Similar Problem 1 \n\n Problem:\n\nYou have some coins.\u00a0 The i-th\u00a0coin has a probability\u00a0prob[i] of facing heads when tossed.\nReturn the probability that the number of coins facing heads equals target if you toss every coin exactly once.\n\u00a0\nExample 1:\nInput: prob = [0.4], target = 1\nOutput: 0.40000\n\nExample 2:\nInput: prob = [0.5,0.5,0.5,0.5,0.5], target = 0\nOutput: 0.03125\n\n\u00a0\nConstraints:\n\n1 <= prob.length <= 1000\n0 <= prob[i] <= 1\n0 <= target\u00a0<= prob.length\nAnswers will be accepted as correct if they are within 10^-5 of the correct answer. Explanation:\n\nSolution 1: Dynamic Programming\nLet $f[i][j]$ represent the probability of having $j$ coins facing up in the first $i$ coins, and initially $f[0][0]=1$. The answer is $f[n][target]$.\nConsider $f[i][j]$, where $i \\geq 1$. If the current coin is facing down, then $f[i][j] = (1 - p) \\times f[i - 1][j]$; If the current coin is facing up and $j \\gt 0$, then $f[i][j] = p \\times f[i - 1][j - 1]$. Therefore, the state transition equation is:\n$$\nf[i][j] = \\begin{cases}\n(1 - p) \\times f[i - 1][j], & j = 0 \\\n(1 - p) \\times f[i - 1][j] + p \\times f[i - 1][j - 1], & j \\gt 0\n\\end{cases}\n$$\nwhere $p$ represents the probability of the $i$-th coin facing up.\nWe note that the state $f[i][j]$ is only related to $f[i - 1][j]$ and $f[i - 1][j - 1]$, so we can optimize the two-dimensional space into one-dimensional space.\nThe time complexity is $O(n \\times target)$, and the space complexity is $O(target)$. Where $n$ is the number of coins. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven a string word to which you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times, return the minimum number of letters that must be inserted so that word becomes valid.\nA string is called valid if it can be formed by concatenating the string \"abc\" several times.\n\u00a0\nExample 1:\n\nInput: word = \"b\"\nOutput: 2\nExplanation: Insert the letter \"a\" right before \"b\", and the letter \"c\" right next to \"b\" to obtain the valid string \"abc\".\n\nExample 2:\n\nInput: word = \"aaa\"\nOutput: 6\nExplanation: Insert letters \"b\" and \"c\" next to each \"a\" to obtain the valid string \"abcabcabc\".\n\nExample 3:\n\nInput: word = \"abc\"\nOutput: 0\nExplanation: word is already valid. No modifications are needed. \n\n\u00a0\nConstraints:\n\n1 <= word.length <= 50\nword consists of letters \"a\", \"b\"\u00a0and \"c\" only.\u00a0 Explanation:\n\nSolution 1: Greedy + Two Pointers\nWe define the string $s$ as \"abc\", and use pointers $i$ and $j$ to point to $s$ and $word$ respectively.\nIf $word[j] \\neq s[i]$, we need to insert $s[i]$, and we add $1$ to the answer; otherwise, it means that $word[j]$ can match with $s[i]$, and we move $j$ one step to the right.\nThen, we move $i$ one step to the right, i.e., $i = (i + 1) \\bmod 3$. We continue the above operations until $j$ reaches the end of the string $word$.\nFinally, we check whether the last character of $word$ is 'b' or 'a'. If it is, we need to insert 'c' or 'bc', and we add $1$ or $2$ to the answer and return it.\nThe time complexity is $O(n)$, where $n$ is the length of the string $word$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and an integer k.\nReturn an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.\nThe set bits in an integer are the 1's present when it is written in binary.\n\nFor example, the binary representation of 21 is 10101, which has 3 set bits.\n\n\u00a0\nExample 1:\n\nInput: nums = [5,10,1,5,2], k = 1\nOutput: 13\nExplanation: The binary representation of the indices are: \n0 = 0002\n1 = 0012\n2 = 0102\n3 = 0112\n4 = 1002 \nIndices 1, 2, and 4 have k = 1 set bits in their binary representation.\nHence, the answer is nums[1] + nums[2] + nums[4] = 13.\nExample 2:\n\nInput: nums = [4,3,2,1], k = 2\nOutput: 1\nExplanation: The binary representation of the indices are:\n0 = 002\n1 = 012\n2 = 102\n3 = 112\nOnly index 3 has k = 2 set bits in its binary representation.\nHence, the answer is nums[3] = 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 105\n0 <= k <= 10 Explanation:\n\nSolution 1: Simulation\nWe directly traverse each index $i$, and check whether the number of $1$s in its binary representation is equal to $k$. If it is, we add the corresponding element to the answer $ans$.\nAfter the traversal ends, we return the answer.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\n", "problem_ids": ["toss-strange-coins", "minimum-additions-to-make-valid-string", "sum-of-values-at-indices-with-k-set-bits"]}, "3251": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a non-negative integer k. There exists a staircase with an infinite number of stairs, with the lowest stair numbered 0.\nAlice has an integer jump, with an initial value of 0. She starts on stair 1 and wants to reach stair k using any number of operations. If she is on stair i, in one operation she can:\n\nGo down to stair i - 1. This operation cannot be used consecutively or on stair 0.\nGo up to stair i + 2jump. And then, jump becomes jump + 1.\n\nReturn the total number of ways Alice can reach stair k.\nNote that it is possible that Alice reaches the stair k, and performs some operations to reach the stair k again.\n\u00a0\nExample 1:\n\nInput: k = 0\nOutput: 2\nExplanation:\nThe 2 possible ways of reaching stair 0 are:\n\nAlice starts at stair 1.\n    \nUsing an operation of the first type, she goes down 1 stair to reach stair 0.\n\n\nAlice starts at stair 1.\n    \nUsing an operation of the first type, she goes down 1 stair to reach stair 0.\nUsing an operation of the second type, she goes up 20 stairs to reach stair 1.\nUsing an operation of the first type, she goes down 1 stair to reach stair 0.\n\n\n\n\nExample 2:\n\nInput: k = 1\nOutput: 4\nExplanation:\nThe 4 possible ways of reaching stair 1 are:\n\nAlice starts at stair 1. Alice is at stair 1.\nAlice starts at stair 1.\n    \nUsing an operation of the first type, she goes down 1 stair to reach stair 0.\nUsing an operation of the second type, she goes up 20 stairs to reach stair 1.\n\n\nAlice starts at stair 1.\n    \nUsing an operation of the second type, she goes up 20 stairs to reach stair 2.\nUsing an operation of the first type, she goes down 1 stair to reach stair 1.\n\n\nAlice starts at stair 1.\n    \nUsing an operation of the first type, she goes down 1 stair to reach stair 0.\nUsing an operation of the second type, she goes up 20 stairs to reach stair 1.\nUsing an operation of the first type, she goes down 1 stair to reach stair 0.\nUsing an operation of the second type, she goes up 21 stairs to reach stair 2.\nUsing an operation of the first type, she goes down 1 stair to reach stair 1.\n\n\n\n\n\u00a0\nConstraints:\n\n0 <= k <= 109 Explanation:\n\nSolution 1: Memoization Search\nWe design a function dfs(i, j, jump), which represents the number of ways to reach the $k$th step when currently at the $i$th step, having performed $j$ operation 1's and jump operation 2's. The answer is dfs(1, 0, 0).\nThe calculation process of the function dfs(i, j, jump) is as follows:\n\nIf $i > k + 1$, since we cannot go down twice in a row, we cannot reach the $k$th step again, so return $0$;\nIf $i = k$, it means that we have reached the $k$th step. The answer is initialized to $1$, and then continue to calculate;\nIf $i > 0$ and $j = 0$, it means that we can go down, recursively calculate dfs(i - 1, 1, jump);\nRecursively calculate dfs(i + 2^{jump}, 0, jump + 1), and add it to the answer.\n\nTo avoid repeated calculations, we use memoization search to save the calculated states.\nThe time complexity is $O(\\log^2 k)$, and the space complexity is $O(\\log^2 k)$. \n\nSimilar Problem 2 \n\n Problem:\n\nRoman numerals are represented by seven different symbols:\u00a0I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,\u00a02 is written as II\u00a0in Roman numeral, just two ones added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\u00a0\nX can be placed before L (50) and C (100) to make 40 and 90.\u00a0\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\n\u00a0\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\n\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 15\ns contains only\u00a0the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed\u00a0that s is a valid roman numeral in the range [1, 3999]. Explanation:\n\nSolution 1: Hash Table + Simulation\nFirst, we use a hash table $d$ to record the numerical value corresponding to each character. Then, we traverse the string $s$ from left to right. If the numerical value corresponding to the current character is less than the numerical value corresponding to the character on the right, we subtract the numerical value corresponding to the current character. Otherwise, we add the numerical value corresponding to the current character.\nThe time complexity is $O(n)$, and the space complexity is $O(m)$. Here, $n$ and $m$ are the length of the string $s$ and the size of the character set, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a 0-indexed m x n binary matrix grid.\nA 0-indexed m x n difference matrix diff is created with the following procedure:\n\nLet the number of ones in the ith row be onesRowi.\nLet the number of ones in the jth column be onesColj.\nLet the number of zeros in the ith row be zerosRowi.\nLet the number of zeros in the jth column be zerosColj.\ndiff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\n\nReturn the difference matrix diff.\n\u00a0\nExample 1:\n\n\nInput: grid = [[0,1,1],[1,0,1],[0,0,1]]\nOutput: [[0,0,4],[0,0,4],[-2,-2,2]]\nExplanation:\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2\n\nExample 2:\n\n\nInput: grid = [[1,1,1],[1,1,1]]\nOutput: [[5,5,5],[5,5,5]]\nExplanation:\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1. Explanation:\n\nSolution 1: Simulation\nWe can solve this problem by simulating the process as described in the problem statement.\nThe time complexity is $O(m \\times n)$, and if we ignore the space used by the answer, the space complexity is $O(m + n)$. Here, $m$ and $n$ are the number of rows and columns in the matrix, respectively. \n\n", "problem_ids": ["find-number-of-ways-to-reach-the-k-th-stair", "roman-to-integer", "difference-between-ones-and-zeros-in-row-and-column"]}, "3252": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array of integers nums. Perform the following steps:\n\nFind any two adjacent numbers in nums that are non-coprime.\nIf no such numbers are found, stop the process.\nOtherwise, delete the two numbers and replace them with their LCM (Least Common Multiple).\nRepeat this process as long as you keep finding two adjacent non-coprime numbers.\n\nReturn the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\nThe test cases are generated such that the values in the final array are less than or equal to 108.\nTwo values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.\n\u00a0\nExample 1:\n\nInput: nums = [6,4,3,2,7,6,2]\nOutput: [12,7,6]\nExplanation: \n- (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2].\n- (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2].\n- (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2].\n- (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is [12,7,6].\nNote that there are other ways to obtain the same resultant array.\n\nExample 2:\n\nInput: nums = [2,2,1,1,3,3,3]\nOutput: [2,1,1,3]\nExplanation: \n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3].\n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3].\n- (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is [2,1,1,3].\nNote that there are other ways to obtain the same resultant array.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\nThe test cases are generated such that the values in the final array are less than or equal to 108. Explanation:\n\nSolution 1: Stack\nIf there exist three adjacent numbers $x$, $y$, $z$ that can be merged, then the result of first merging $x$ and $y$, then merging $z$, is the same as the result of first merging $y$ and $z$, then merging $x$. Both results are $\\textit{LCM}(x, y, z)$.\nTherefore, we can always prefer to merge the adjacent numbers on the left, and then merge the result with the adjacent number on the right.\nWe use a stack to simulate this process. We traverse the array, and for each number, we push it into the stack. Then we continuously check whether the top two numbers of the stack are coprime. If they are not coprime, we pop these two numbers out of the stack, and then push their least common multiple into the stack, until the top two numbers of the stack are coprime, or there are less than two elements in the stack.\nThe final elements in the stack are the final result.\nThe time complexity is $O(n \\times \\log M)$, and the space complexity is $O(n)$. Where $M$ is the maximum value in the array. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n0 <= j <= nums[i] and\ni + j < n\n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n\u00a0\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [2,3,0,1,4]\nOutput: 2\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 1000\nIt's guaranteed that you can reach nums[n - 1]. Explanation:\n\nSolution 1: Greedy Algorithm\nWe can use a variable $mx$ to record the farthest position that can be reached from the current position, a variable $last$ to record the position of the last jump, and a variable $ans$ to record the number of jumps.\nNext, we traverse each position $i$ in $[0,..n - 2]$. For each position $i$, we can calculate the farthest position that can be reached from the current position through $i + nums[i]$. We use $mx$ to record this farthest position, that is, $mx = max(mx, i + nums[i])$. Then, we check whether the current position has reached the boundary of the last jump, that is, $i = last$. If it has reached, then we need to make a jump, update $last$ to $mx$, and increase the number of jumps $ans$ by $1$.\nFinally, we return the number of jumps $ans$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$.\nSimilar problems:\n\n55. Jump Game\n1024. Video Stitching\n1326. Minimum Number of Taps to Open to Water a Garden \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a binary tree\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\n\u00a0\nExample 1:\n\n\nInput: root = [1,2,3,4,5,null,7]\nOutput: [1,#,2,3,#,4,5,7,#]\nExplanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n\nExample 2:\n\nInput: root = []\nOutput: []\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 6000].\n-100 <= Node.val <= 100\n\n\u00a0\nFollow-up:\n\nYou may only use constant extra space.\nThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem. Explanation:\n\nSolution 1: BFS\nWe use a queue $q$ for level order traversal. Each time we traverse a level, we connect the nodes of the current level in order.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["replace-non-coprime-numbers-in-array", "jump-game-ii", "populating-next-right-pointers-in-each-node-ii"]}, "3261": {"text": "Similar Problem 1 \n\n Problem:\n\nReturn the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer\u00a0is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers\u00a0both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.\n\u00a0\nExample 1:\n\nInput: n = 5\nOutput: 12\nExplanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.\n\nExample 2:\n\nInput: n = 100\nOutput: 682289015\n\n\u00a0\nConstraints:\n\n1 <= n <= 100 Explanation:\n\nSolution 1: Mathematics\nFirst, count the number of prime numbers within the range $[1,n]$, which we denote as $cnt$. Then, calculate the product of the factorial of $cnt$ and $n-cnt$ to get the answer, remember to perform the modulo operation.\nHere, we use the \"Sieve of Eratosthenes\" to count prime numbers.\nIf $x$ is a prime number, then multiples of $x$ greater than $x$, such as $2x$, $3x$, ... are definitely not prime numbers, so we can start from here.\nLet $primes[i]$ indicate whether the number $i$ is a prime number. If it is a prime number, it is $true$, otherwise it is $false$.\nWe sequentially traverse each number $i$ in the range $[2,n]$. If this number is a prime number, the number of prime numbers increases by $1$, and then all its multiples $j$ are marked as composite numbers (except for the prime number itself), that is, $primes[j]=false$. In this way, at the end of the run, we can know the number of prime numbers.\nThe time complexity is $O(n \\times \\log \\log n)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\nThe middle node of a linked list of size n is the \u230an / 2\u230bth node from the start using 0-based indexing, where \u230ax\u230b denotes the largest integer less than or equal to x.\n\nFor n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\n\n\u00a0\nExample 1:\n\n\nInput: head = [1,3,4,7,1,2,6]\nOutput: [1,3,4,1,2,6]\nExplanation:\nThe above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node. \n\nExample 2:\n\n\nInput: head = [1,2,3,4]\nOutput: [1,2,4]\nExplanation:\nThe above figure represents the given linked list.\nFor n = 4, node 2 with value 3 is the middle node, which is marked in red.\n\nExample 3:\n\n\nInput: head = [2,1]\nOutput: [2]\nExplanation:\nThe above figure represents the given linked list.\nFor n = 2, node 1 with value 1 is the middle node, which is marked in red.\nNode 0 with value 2 is the only node remaining after removing node 1.\n\u00a0\nConstraints:\n\nThe number of nodes in the list is in the range [1, 105].\n1 <= Node.val <= 105 Explanation:\n\nSolution 1: Fast and Slow Pointers\nThe fast and slow pointer technique is a common method used to solve problems related to linked lists. We can maintain two pointers, a slow pointer $\\textit{slow}$ and a fast pointer $\\textit{fast}$. Initially, $\\textit{slow}$ points to a dummy node, whose $\\textit{next}$ pointer points to the head node $\\textit{head}$ of the list, while $\\textit{fast}$ points to the head node $\\textit{head}$.\nThen, we move the slow pointer one position backward and the fast pointer two positions backward each time, until the fast pointer reaches the end of the list. At this point, the node next to the node pointed by the slow pointer is the middle node of the list. We can remove the middle node by setting the $\\textit{next}$ pointer of the node pointed by the slow pointer to point to the next next node.\nThe time complexity is $O(n)$, where $n$ is the length of the list. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven two nodes of a\u00a0binary tree p and q, return their\u00a0lowest common ancestor (LCA).\nEach node will have a reference to its parent node. The definition for Node is below:\n\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\n\nAccording to the definition of LCA on Wikipedia: \"The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself).\"\n\u00a0\nExample 1:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n\nExample 2:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.\n\nExample 3:\n\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val are unique.\np != q\np and q exist in the tree. Explanation:\n\nSolution 1: Hash Table\nWe use a hash table $vis$ to record all nodes on the path from node $p$ to the root node. Then we start from node $q$ and traverse towards the root node. If we encounter a node that exists in the hash table $vis$, then this node is the nearest common ancestor of $p$ and $q$, and we can return it directly.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["prime-arrangements", "delete-the-middle-node-of-a-linked-list", "lowest-common-ancestor-of-a-binary-tree-iii"]}, "3262": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.\n\u00a0\nExample 1:\n\nInput: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).\n\nExample 2:\n\nInput: nums = [6,5,4,8]\nOutput: [2,1,0,3]\n\nExample 3:\n\nInput: nums = [7,7,7,7]\nOutput: [0,0,0,0]\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 500\n0 <= nums[i] <= 100 Explanation:\n\nSolution 1: Sorting + Binary Search\nWe can make a copy of the array $nums$, denoted as $arr$, and then sort $arr$ in ascending order.\nNext, for each element $x$ in $nums$, we can use binary search to find the index $j$ of the first element that is greater than or equal to $x$. Then $j$ is the number of elements that are smaller than $x$. We can store $j$ in the answer array.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nAlice and Bob are traveling to Rome for separate business meetings.\nYou are given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice will be in the city from the dates arriveAlice to leaveAlice (inclusive), while Bob will be in the city from the dates arriveBob to leaveBob (inclusive). Each will be a 5-character string in the format \"MM-DD\", corresponding to the month and day of the date.\nReturn the total number of days that Alice and Bob are in Rome together.\nYou can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].\n\u00a0\nExample 1:\n\nInput: arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"\nOutput: 3\nExplanation: Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n\nExample 2:\n\nInput: arriveAlice = \"10-01\", leaveAlice = \"10-31\", arriveBob = \"11-01\", leaveBob = \"12-31\"\nOutput: 0\nExplanation: There is no day when Alice and Bob are in Rome together, so we return 0.\n\n\u00a0\nConstraints:\n\nAll dates are provided in the format \"MM-DD\".\nAlice and Bob's arrival dates are earlier than or equal to their leaving dates.\nThe given dates are valid dates of a non-leap year. Explanation:\n\nSolution 1: Simulation\nWe convert the dates into days, and then calculate the number of days both people are in Rome.\nThe time complexity is $O(C)$, and the space complexity is $O(C)$. Here, $C$ is a constant. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive).\nReturn the count of days when the employee is available for work but no meetings are scheduled.\nNote: The meetings may overlap.\n\u00a0\nExample 1:\n\nInput: days = 10, meetings = [[5,7],[1,3],[9,10]]\nOutput: 2\nExplanation:\nThere is no meeting scheduled on the 4th and 8th days.\n\nExample 2:\n\nInput: days = 5, meetings = [[2,4],[1,3]]\nOutput: 1\nExplanation:\nThere is no meeting scheduled on the 5th day.\n\nExample 3:\n\nInput: days = 6, meetings = [[1,6]]\nOutput: 0\nExplanation:\nMeetings are scheduled for all working days.\n\n\u00a0\nConstraints:\n\n1 <= days <= 109\n1 <= meetings.length <= 105\nmeetings[i].length == 2\n1 <= meetings[i][0] <= meetings[i][1] <= days Explanation:\n\nSolution 1: Sorting\nWe can sort all the meetings by their start time, and use a variable last to record the latest end time of the previous meetings.\nThen we traverse all the meetings. For each meeting $(st, ed)$, if last < st, it means that the time period from last to st is a time period when employees can work and no meetings are scheduled. We add this time period to the answer. Then we update last = max(last, ed).\nFinally, if last < days, it means that there is a time period after the end of the last meeting when employees can work and no meetings are scheduled. We add this time period to the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Where $n$ is the number of meetings. \n\n", "problem_ids": ["how-many-numbers-are-smaller-than-the-current-number", "count-days-spent-together", "count-days-without-meetings"]}, "3263": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums and a positive integer k.\nWe call an index i k-big if the following conditions are satisfied:\n\nThere exist at least k different indices idx1 such that idx1 < i and nums[idx1] < nums[i].\nThere exist at least k different indices idx2 such that idx2 > i and nums[idx2] < nums[i].\n\nReturn the number of k-big indices.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,6,5,2,3], k = 2\nOutput: 2\nExplanation: There are only two 2-big indices in nums:\n- i = 2 --> There are two valid idx1: 0 and 1. There are three valid idx2: 2, 3, and 4.\n- i = 3 --> There are two valid idx1: 0 and 1. There are two valid idx2: 3 and 4.\n\nExample 2:\n\nInput: nums = [1,1,1], k = 3\nOutput: 0\nExplanation: There are no 3-big indices in nums.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i], k <= nums.length Explanation:\n\nSolution 1: Binary Indexed Tree\nWe maintain two binary indexed trees, one records the number of elements smaller than the current position on the left, and the other records the number of elements smaller than the current position on the right.\nWe traverse the array, and for the current position, if the number of elements smaller than the current position on the left is greater than or equal to $k$, and the number of elements smaller than the current position on the right is greater than or equal to $k$, then the current position is a k-big, and we increment the answer by one.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$, where $n$ is the length of the array. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\n\nanswer[0] is a list of all distinct integers in nums1 which are not present in nums2.\nanswer[1] is a list of all distinct integers in nums2 which are not present in nums1.\n\nNote that the integers in the lists may be returned in any order.\n\u00a0\nExample 1:\n\nInput: nums1 = [1,2,3], nums2 = [2,4,6]\nOutput: [[1,3],[4,6]]\nExplanation:\nFor nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\nFor nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].\nExample 2:\n\nInput: nums1 = [1,2,3,3], nums2 = [1,1,2,2]\nOutput: [[3],[]]\nExplanation:\nFor nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\nEvery integer in nums2 is present in nums1. Therefore, answer[1] = [].\n\n\u00a0\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n-1000 <= nums1[i], nums2[i] <= 1000 Explanation:\n\nSolution 1: Hash Table\nWe define two hash tables $s1$ and $s2$ to store the elements in arrays $nums1$ and $nums2$ respectively. Then we traverse each element in $s1$. If this element is not in $s2$, we add it to the first list in the answer. Similarly, we traverse each element in $s2$. If this element is not in $s1$, we add it to the second list in the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array. \n\nSimilar Problem 3 \n\n Problem:\n\nA complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the real part and is an integer in the range [-100, 100].\nimaginary is the imaginary part and is an integer in the range [-100, 100].\ni2 == -1.\n\nGiven two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.\n\u00a0\nExample 1:\n\nInput: num1 = \"1+1i\", num2 = \"1+1i\"\nOutput: \"0+2i\"\nExplanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\n\nExample 2:\n\nInput: num1 = \"1+-1i\", num2 = \"1+-1i\"\nOutput: \"0+-2i\"\nExplanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n\n\u00a0\nConstraints:\n\nnum1 and num2 are valid complex numbers. Explanation:\n\nSolution 1: Simulation\nWe can convert the complex number string into its real part $a$ and imaginary part $b$, and then use the formula for complex number multiplication $(a_1 + b_1i) \\times (a_2 + b_2i) = (a_1a_2 - b_1b_2) + (a_1b_2 + a_2b_1)i$ to calculate the result.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["count-the-number-of-k-big-indices", "find-the-difference-of-two-arrays", "complex-number-multiplication"]}, "3265": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given the head of a linked list with n nodes.\nFor each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.\nReturn an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.\n\u00a0\nExample 1:\n\n\nInput: head = [2,1,5]\nOutput: [5,5,0]\n\nExample 2:\n\n\nInput: head = [2,7,4,3,5]\nOutput: [7,0,5,5,0]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= n <= 104\n1 <= Node.val <= 109 Explanation:\n\nSolution 1: Monotonic Stack\nThe problem requires finding the next larger node for each node in the linked list, that is, finding the first node to the right of each node in the linked list that is larger than it. We first traverse the linked list and store the values in the linked list in an array $nums$. For each element in the array $nums$, we just need to find the first element to its right that is larger than it. The problem of finding the next larger element can be solved using a monotonic stack.\nWe traverse the array $nums$ from back to front, maintaining a stack $stk$ that is monotonically decreasing from the bottom to the top. During the traversal, if the top element of the stack is less than or equal to the current element, we loop to pop the top element of the stack until the top element of the stack is larger than the current element or the stack is empty.\nIf the stack is empty at this time, it means that the current element does not have a next larger element, otherwise, the next larger element of the current element is the top element of the stack, and we update the answer array $ans$. Then we push the current element into the stack and continue the traversal.\nAfter the traversal is over, we return the answer array $ans$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the linked list. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,3,2]\nOutput: 4\nExplanation: All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\nExample 2:\n\nInput: nums = [6,2,6,5,1,2]\nOutput: 9\nExplanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n\n\u00a0\nConstraints:\n\n1 <= n <= 104\nnums.length == 2 * n\n-104 <= nums[i] <= 104 Explanation:\n\nSolution 1: Sorting\nFor a pair of numbers $(a, b)$, we can assume $a \\leq b$, then $\\min(a, b) = a$. In order to make the sum as large as possible, the $b$ we choose should be as close to $a$ as possible, so as to retain a larger number.\nTherefore, we can sort the array $nums$, then divide every two adjacent numbers into a group, and add the first number of each group.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Where $n$ is the length of the array $nums$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.\n\u00a0\nExample 1:\n\nInput: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\nOutput: true\nExplanation: We might do the following sequence:\npush(1), push(2), push(3), push(4),\npop() -> 4,\npush(5),\npop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\nExample 2:\n\nInput: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\nOutput: false\nExplanation: 1 cannot be popped before 2.\n\n\u00a0\nConstraints:\n\n1 <= pushed.length <= 1000\n0 <= pushed[i] <= 1000\nAll the elements of pushed are unique.\npopped.length == pushed.length\npopped is a permutation of pushed. Explanation:\n\nSolution 1: Stack Simulation\nWe iterate through the $\\textit{pushed}$ array. For the current element $x$ being iterated, we push it into the stack $\\textit{stk}$. Then, we check if the top element of the stack is equal to the next element to be popped in the $\\textit{popped}$ array. If they are equal, we pop the top element from the stack and increment the index $i$ of the next element to be popped in the $\\textit{popped}$ array. Finally, if all elements can be popped in the order specified by the $\\textit{popped}$ array, return $\\textit{true}$; otherwise, return $\\textit{false}$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the $\\textit{pushed}$ array. \n\n", "problem_ids": ["next-greater-node-in-linked-list", "array-partition", "validate-stack-sequences"]}, "3267": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two integers tomatoSlices and cheeseSlices. The ingredients of different burgers are as follows:\n\nJumbo Burger: 4 tomato slices and 1 cheese slice.\nSmall Burger: 2 Tomato slices and 1 cheese slice.\n\nReturn [total_jumbo, total_small] so that the number of remaining tomatoSlices equal to 0 and the number of remaining cheeseSlices equal to 0. If it is not possible to make the remaining tomatoSlices and cheeseSlices equal to 0 return [].\n\u00a0\nExample 1:\n\nInput: tomatoSlices = 16, cheeseSlices = 7\nOutput: [1,6]\nExplantion: To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese.\nThere will be no remaining ingredients.\n\nExample 2:\n\nInput: tomatoSlices = 17, cheeseSlices = 4\nOutput: []\nExplantion: There will be no way to use all ingredients to make small and jumbo burgers.\n\nExample 3:\n\nInput: tomatoSlices = 4, cheeseSlices = 17\nOutput: []\nExplantion: Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining.\n\n\u00a0\nConstraints:\n\n0 <= tomatoSlices, cheeseSlices <= 107 Explanation:\n\nSolution 1: Mathematics\nWe set the number of Jumbo Burgers as $x$ and the number of Small Burgers as $y$, then we have:\n$$\n\\begin{aligned}\n4x + 2y &= tomatoSlices \\\nx + y &= cheeseSlices\n\\end{aligned}\n$$\nTransforming the above two equations, we can get:\n$$\n\\begin{aligned}\ny = (4 \\times cheeseSlices - tomatoSlices) / 2 \\\nx = cheeseSlices - y\n\\end{aligned}\n$$\nWhere $x$ and $y$ must be non-negative integers.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nAlice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them.\nThe game proceeds as follows:\n\nAlice takes the first turn.\nIn each turn, a player must choose either the clockwise or anti-clockwise direction and pick one flower from that side.\nAt the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.\n\nGiven two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:\n\nAlice must win the game according to the described rules.\nThe number of flowers x in the clockwise direction must be in the range [1,n].\nThe number of flowers y in the anti-clockwise direction must be in the range [1,m].\n\nReturn the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.\n\u00a0\nExample 1:\n\nInput: n = 3, m = 2\nOutput: 3\nExplanation: The following pairs satisfy conditions described in the statement: (1,2), (3,2), (2,1).\n\nExample 2:\n\nInput: n = 1, m = 1\nOutput: 0\nExplanation: No pairs satisfy the conditions described in the statement.\n\n\u00a0\nConstraints:\n\n1 <= n, m <= 105 Explanation:\n\nSolution 1: Mathematics\nAccording to the problem description, in each move, the player will choose to move in a clockwise or counterclockwise direction and then pick a flower. Since Alice moves first, when $x + y$ is odd, Alice will definitely win the game.\nTherefore, the number of flowers $x$ and $y$ meet the following conditions:\n\n$x + y$ is odd;\n$1 \\le x \\le n$;\n$1 \\le y \\le m$.\n\nIf $x$ is odd, $y$ must be even. At this time, the number of values of $x$ is $\\lceil \\frac{n}{2} \\rceil$, the number of values of $y$ is $\\lfloor \\frac{m}{2} \\rfloor$, so the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor$.\nIf $x$ is even, $y$ must be odd. At this time, the number of values of $x$ is $\\lfloor \\frac{n}{2} \\rfloor$, the number of values of $y$ is $\\lceil \\frac{m}{2} \\rceil$, so the number of pairs that meet the conditions is $\\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$.\nTherefore, the number of pairs that meet the conditions is $\\lceil \\frac{n}{2} \\rceil \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lceil \\frac{m}{2} \\rceil$, which is $\\lfloor \\frac{n + 1}{2} \\rfloor \\times \\lfloor \\frac{m}{2} \\rfloor + \\lfloor \\frac{n}{2} \\rfloor \\times \\lfloor \\frac{m + 1}{2} \\rfloor$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.\nReturn the sum of encrypted elements.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: 6\nExplanation: The encrypted elements are\u00a0[1,2,3]. The sum of encrypted elements is 1 + 2 + 3 == 6.\n\nExample 2:\n\nInput: nums = [10,21,31]\nOutput: 66\nExplanation: The encrypted elements are [11,22,33]. The sum of encrypted elements is 11 + 22 + 33 == 66.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 1000 Explanation:\n\nSolution 1: Simulation\nWe directly simulate the encryption process by defining a function $encrypt(x)$, which replaces each digit in an integer $x$ with the maximum digit in $x$. The implementation of the function is as follows:\nWe can obtain each digit of $x$ by continuously taking the modulus and integer division of $x$ by $10$, and find the maximum digit, denoted as $mx$. During the loop, we can also use a variable $p$ to record the base number of $mx$, i.e., $p = 1, 11, 111, \\cdots$. Finally, return $mx \\times p$.\nThe time complexity is $O(n \\times \\log M)$, where $n$ is the length of the array, and $M$ is the maximum value in the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["number-of-burgers-with-no-waste-of-ingredients", "alice-and-bob-playing-flower-game", "find-the-sum-of-encrypted-integers"]}, "3269": {"text": "Similar Problem 1 \n\n Problem:\n\nReverse bits of a given 32 bits unsigned integer.\nNote:\n\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\nIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.\n\n\u00a0\nExample 1:\n\nInput: n = 00000010100101000001111010011100\nOutput:    964176192 (00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\n\nExample 2:\n\nInput: n = 11111111111111111111111111111101\nOutput:   3221225471 (10111111111111111111111111111111)\nExplanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.\n\n\u00a0\nConstraints:\n\nThe input must be a binary string of length 32\n\n\u00a0\nFollow up: If this function is called many times, how would you optimize it? Explanation:\n\nSolution 1: Bit Manipulation\nWe can extract each bit of n from the least significant bit to the most significant bit, and then place it in the corresponding position of ans.\nFor example, for the $i$-th bit, we can use (n & 1) << (31 - i) to extract the $i$-th bit of n and place it on the $31 - i$-th bit of ans, then right shift n by one bit.\nThe time complexity is $O(\\log n)$, and the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven the 0-indexed arrays prices and profits of length n. There are n items in an store where the ith item has a price of prices[i] and a profit of profits[i].\nWe have to pick three items with the following condition:\n\nprices[i] < prices[j] < prices[k] where i < j < k.\n\nIf we pick items with indices i, j and k satisfying the above condition, the profit would be profits[i] + profits[j] + profits[k].\nReturn the maximum profit we can get, and -1 if it's not possible to pick three items with the given condition.\n\u00a0\nExample 1:\n\nInput: prices = [10,2,3,4], profits = [100,2,7,10]\nOutput: 19\nExplanation: We can't pick the item with index i=0 since there are no indices j and k such that the condition holds.\nSo the only triplet we can pick, are the items with indices 1, 2 and 3 and it's a valid pick since prices[1] < prices[2] < prices[3].\nThe answer would be sum of their profits which is 2 + 7 + 10 = 19.\nExample 2:\n\nInput: prices = [1,2,3,4,5], profits = [1,5,3,4,6]\nOutput: 15\nExplanation: We can select any triplet of items since for each triplet of indices i, j and k such that i < j < k, the condition holds.\nTherefore the maximum profit we can get would be the 3 most profitable items which are indices 1, 3 and 4.\nThe answer would be sum of their profits which is 5 + 4 + 6 = 15.\nExample 3:\n\nInput: prices = [4,3,2,1], profits = [33,20,19,87]\nOutput: -1\nExplanation: We can't select any triplet of indices such that the condition holds, so we return -1.\n\n\u00a0\nConstraints:\n\n3 <= prices.length == profits.length <= 2000\n1 <= prices[i] <= 106\n1 <= profits[i] <= 106 Explanation:\n\nSolution 1: Enumerate the Middle Element\nWe can enumerate the middle element $profits[j]$, and then enumerate the left element $profits[i]$ and the right element $profits[k]$. For each $profits[j]$, we need to find the maximum $profits[i]$ and the maximum $profits[k]$ such that $prices[i] < prices[j] < prices[k]$. We define $left$ as the maximum value on the left of $profits[j]$, and $right$ as the maximum value on the right of $profits[j]$. If they exist, we update the answer as $ans = \\max(ans, left + profits[j] + right)$.\nThe time complexity is $O(n^2)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.\n\u00a0\nExample 1:\n\n\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n\nExample 2:\n\n\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. \n\n\u00a0\nConstraints:\n\n1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n Explanation:\n\nSolution 1: BFS\nFirst, based on the undirected tree edges given in the problem, we construct an adjacency list $g$, where $g[u]$ represents all adjacent vertices of vertex $u$.\nThen, we define the following data structures:\n\nQueue $q$, used to store the vertices and their probabilities for each round of search. Initially, $q = [(1, 1.0)]$, indicating that the probability of the frog being at vertex $1$ is $1.0$;\nArray $vis$, used to record whether each vertex has been visited. Initially, $vis[1] = true$, and all other elements are $false$.\n\nNext, we start the breadth-first search.\nIn each round of search, we take out the head element $(u, p)$ of the queue, where $u$ and $p$ represent the current vertex and its probability, respectively. The number of unvisited adjacent vertices of the current vertex $u$ is denoted as $cnt$.\n\nIf $u = target$, it means that the frog has reached the target vertex. At this time, we judge whether the frog reaches the target vertex in $t$ seconds, or it reaches the target vertex in less than $t$ seconds but cannot jump to other vertices (i.e., $t=0$ or $cnt=0$). If so, return $p$, otherwise return $0$.\nIf $u \\neq target$, we evenly distribute the probability $p$ to all unvisited adjacent vertices of $u$, then add these vertices to the queue $q$, and mark these vertices as visited.\n\nAt the end of a round of search, we decrease $t$ by $1$, and then continue the next round of search until the queue is empty or $t \\lt 0$. \n\n", "problem_ids": ["reverse-bits", "maximum-profitable-triplets-with-increasing-prices-i", "frog-position-after-t-seconds"]}, "3279": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\u00a0\nExample 1:\n\nInput: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.\n\nExample 2:\n\nInput: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".\n\nExample 3:\n\nInput: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned.\n\n\u00a0\nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters. Explanation:\n\nSolution 1: Simulation\nWe iterate through the array words, for each string w, we determine if it is a palindrome. If it is, then we return w; otherwise, we continue to iterate.\nTo determine if a string is a palindrome, we can use two pointers, one pointing to the start and the other to the end of the string, moving towards the center, and checking if the corresponding characters are equal. If, after traversing the entire string, no unequal characters are found, then the string is a palindrome.\nThe time complexity is $O(L)$, where $L$ is the sum of the lengths of all strings in the array words. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nTable: Boxes\n\n+--------------+------+\n| Column Name  | Type |\n+--------------+------+\n| box_id       | int  |\n| chest_id     | int  |\n| apple_count  | int  |\n| orange_count | int  |\n+--------------+------+\nbox_id is the column with unique values for this table.\nchest_id is a foreign key (reference column) of the chests table.\nThis table contains information about the boxes and the number of oranges and apples they have. Each box may include a chest, which also can contain oranges and apples.\n\n\u00a0\nTable: Chests\n\n+--------------+------+\n| Column Name  | Type |\n+--------------+------+\n| chest_id     | int  |\n| apple_count  | int  |\n| orange_count | int  |\n+--------------+------+\nchest_id is the column with unique values for this table.\nThis table contains information about the chests and the corresponding number of oranges and apples they have.\n\n\u00a0\nWrite a solution to count the number of apples and oranges in all the boxes. If a box contains a chest, you should also include the number of apples and oranges it has.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nBoxes table:\n+--------+----------+-------------+--------------+\n| box_id | chest_id | apple_count | orange_count |\n+--------+----------+-------------+--------------+\n| 2      | null     | 6           | 15           |\n| 18     | 14       | 4           | 15           |\n| 19     | 3        | 8           | 4            |\n| 12     | 2        | 19          | 20           |\n| 20     | 6        | 12          | 9            |\n| 8      | 6        | 9           | 9            |\n| 3      | 14       | 16          | 7            |\n+--------+----------+-------------+--------------+\nChests table:\n+----------+-------------+--------------+\n| chest_id | apple_count | orange_count |\n+----------+-------------+--------------+\n| 6        | 5           | 6            |\n| 14       | 20          | 10           |\n| 2        | 8           | 8            |\n| 3        | 19          | 4            |\n| 16       | 19          | 19           |\n+----------+-------------+--------------+\nOutput: \n+-------------+--------------+\n| apple_count | orange_count |\n+-------------+--------------+\n| 151         | 123          |\n+-------------+--------------+\nExplanation: \nbox 2 has 6 apples and 15 oranges.\nbox 18 has 4 + 20 (from the chest) = 24 apples and 15 + 10 (from the chest) = 25 oranges.\nbox 19 has 8 + 19 (from the chest) = 27 apples and 4 + 4 (from the chest) = 8 oranges.\nbox 12 has 19 + 8 (from the chest) = 27 apples and 20 + 8 (from the chest) = 28 oranges.\nbox 20 has 12 + 5 (from the chest) = 17 apples and 9 + 6 (from the chest) = 15 oranges.\nbox 8 has 9 + 5 (from the chest) = 14 apples and 9 + 6 (from the chest) = 15 oranges.\nbox 3 has 16 + 20 (from the chest) = 36 apples and 7 + 10 (from the chest) = 17 oranges.\nTotal number of apples = 6 + 24 + 27 + 27 + 17 + 14 + 36 = 151\nTotal number of oranges = 15 + 25 + 8 + 28 + 15 + 15 + 17 = 123 Explanation:\n\nSolution 1: Left Join + Summation\nWe can perform a left join on the Boxes table and the Chests table based on chest_id, and then calculate the total number of apples and oranges respectively. Note that if a box does not contain any small boxes, then the corresponding chest_id will be null. In this case, we need to consider the number of apples and oranges in the small boxes within that box to be 0.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nSELECT\n    SUM(IFNULL(b.apple_count, 0) + IFNULL(c.apple_count, 0)) AS apple_count,\n    SUM(IFNULL(b.orange_count, 0) + IFNULL(c.orange_count, 0)) AS orange_count\nFROM\n    Boxes AS b\n    LEFT JOIN Chests AS c USING (chest_id);\n```\nPandas\n```python\nimport pandas as pd\ndef count_apples_and_oranges(boxes: pd.DataFrame, chests: pd.DataFrame) -> pd.DataFrame:\n    merged_df = boxes.merge(\n        chests, on=\"chest_id\", how=\"left\", suffixes=(\"_box\", \"_chest\")\n    )\n    apple_count = (\n        merged_df[\"apple_count_box\"].fillna(0)\n        + merged_df[\"apple_count_chest\"].fillna(0)\n    ).sum()\n    orange_count = (\n        merged_df[\"orange_count_box\"].fillna(0)\n        + merged_df[\"orange_count_chest\"].fillna(0)\n    ).sum()\n    return pd.DataFrame({\"apple_count\": [apple_count], \"orange_count\": [orange_count]})\n``` \n\nSimilar Problem 3 \n\n Problem:\n\nTable: Tweets\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| tweet_id    | int     |\n| tweet_date  | date    |\n| tweet       | varchar |\n+-------------+---------+\ntweet_id is the primary key (column with unique values) for this table.\nEach row of this table contains user_id, tweet_id, tweet_date and tweet.\n\nWrite a solution to find the top 3 trending hashtags\u00a0in\u00a0February 2024. Each tweet only contains one hashtag.\nReturn the result table orderd by count of hashtag, hashtag in descending order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput:\nTweets table:\n\n+---------+----------+----------------------------------------------+------------+\n| user_id | tweet_id | tweet                                        | tweet_date |\n+---------+----------+----------------------------------------------+------------+\n| 135     | 13       | Enjoying a great start to the day! #HappyDay | 2024-02-01 |\n| 136     | 14       | Another #HappyDay with good vibes!           | 2024-02-03 |\n| 137     | 15       | Productivity peaks! #WorkLife                | 2024-02-04 |\n| 138     | 16       | Exploring new tech frontiers. #TechLife      | 2024-02-04 |\n| 139     | 17       | Gratitude for today's moments. #HappyDay     | 2024-02-05 |\n| 140     | 18       | Innovation drives us. #TechLife              | 2024-02-07 |\n| 141     | 19       | Connecting with nature's serenity. #Nature   | 2024-02-09 |\n+---------+----------+----------------------------------------------+------------+\n \nOutput:\n\n+-----------+--------------+\n| hashtag   | hashtag_count|\n+-----------+--------------+\n| #HappyDay | 3            |\n| #TechLife | 2            |\n| #WorkLife | 1            |\n+-----------+--------------+\n\n\nExplanation:\n\n#HappyDay: Appeared in tweet IDs 13, 14, and 17, with a total count of 3 mentions.\n#TechLife: Appeared in tweet IDs 16 and 18, with a total count of 2 mentions.\n#WorkLife: Appeared in tweet ID 15, with a total count of 1 mention.\n\nNote: Output table is sorted in descending order by hashtag_count and hashtag respectively. Explanation:\n\nSolution 1: Extract Substring + Grouping\nWe can query all tweets from February 2024, use the SUBSTRING_INDEX function to extract Hashtags, then use the GROUP BY and COUNT functions to count the occurrences of each Hashtag. Finally, we sort by the number of occurrences in descending order and by Hashtag in descending order, and take the top three popular Hashtags.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nSELECT\n    CONCAT('#', SUBSTRING_INDEX(SUBSTRING_INDEX(tweet, '#', -1), ' ', 1)) AS hashtag,\n    COUNT(1) AS hashtag_count\nFROM Tweets\nWHERE DATE_FORMAT(tweet_date, '%Y%m') = '202402'\nGROUP BY 1\nORDER BY 2 DESC, 1 DESC\nLIMIT 3;\n``` \n\n", "problem_ids": ["find-first-palindromic-string-in-the-array", "count-apples-and-oranges", "find-trending-hashtags"]}, "3291": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle.\n\u00a0\nExample 1:\n\n\nInput: n = 2, m = 3\nOutput: 3\nExplanation: 3 squares are necessary to cover the rectangle.\n2 (squares of 1x1)\n1 (square of 2x2)\nExample 2:\n\n\nInput: n = 5, m = 8\nOutput: 5\n\nExample 3:\n\n\nInput: n = 11, m = 13\nOutput: 6\n\n\u00a0\nConstraints:\n\n1 <= n, m <= 13 Explanation:\n\nSolution 1: Recursive Backtracking + State Compression\nWe can perform recursive backtracking by position, during which we use a variable $t$ to record the current number of tiles used.\n\nIf $j = m$, i.e., the $i$-th row has been completely filled, then we recurse to the next row, i.e., $(i + 1, 0)$.\nIf $i = n$, it means that all positions have been filled, we update the answer and return.\nIf the current position $(i, j)$ has been filled, then directly recurse to the next position $(i, j + 1)$.\nOtherwise, we enumerate the maximum square side length $w$ that the current position $(i, j)$ can fill, and fill all positions from $(i, j)$ to $(i + w - 1, j + w - 1)$, then recurse to the next position $(i, j + w)$. When backtracking, we need to clear all positions from $(i, j)$ to $(i + w - 1, j + w - 1)$.\n\nSince each position only has two states: filled or not filled, we can use an integer to represent the current state. We use an integer array $filled$ of length $n$, where $filled[i]$ represents the state of the $i$-th row. If the $j$-th bit of $filled[i]$ is $1$, it means that the $i$-th row and the $j$-th column have been filled, otherwise it means not filled. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\nAll the numbers of\u00a0nums are unique. Explanation:\n\nSolution 1: DFS (Backtracking)\nWe design a function $dfs(i)$, which represents starting the search from the $i$th element of the array for all subsets. The execution logic of the function $dfs(i)$ is as follows:\n\nIf $i = n$, it means the current search has ended. Add the current subset $t$ to the answer array $ans$, and then return.\nOtherwise, we can choose not to select the current element and directly execute $dfs(i + 1)$; or we can choose the current element, i.e., add the current element $nums[i]$ to the subset $t$, and then execute $dfs(i + 1)$. Note that we need to remove $nums[i]$ from the subset $t$ after executing $dfs(i + 1)$ (backtracking).\n\nIn the main function, we call $dfs(0)$, i.e., start searching all subsets from the first element of the array. Finally, return the answer array $ans$.\nThe time complexity is $O(n \\times 2^n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. There are a total of $2^n$ subsets, and each subset takes $O(n)$ time to construct. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is an infinite 2D plane.\nYou are given a positive integer k. You are also given a 2D array queries, which contains the following queries:\n\nqueries[i] = [x, y]: Build an obstacle at coordinate (x, y) in the plane. It is guaranteed that there is no obstacle at this coordinate when this query is made.\n\nAfter each query, you need to find the distance of the kth nearest obstacle from the origin.\nReturn an integer array results where results[i] denotes the kth nearest obstacle after query i, or results[i] == -1 if there are less than k obstacles.\nNote that initially there are no obstacles anywhere.\nThe distance of an obstacle at coordinate (x, y) from the origin is given by |x| + |y|.\n\u00a0\nExample 1:\n\nInput: queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2\nOutput: [-1,7,5,3]\nExplanation:\n\nInitially, there are 0 obstacles.\nAfter queries[0], there are less than 2 obstacles.\nAfter queries[1], there are obstacles at distances 3 and 7.\nAfter queries[2], there are obstacles at distances 3, 5, and 7.\nAfter queries[3], there are obstacles at distances 3, 3, 5, and 7.\n\n\nExample 2:\n\nInput: queries = [[5,5],[4,4],[3,3]], k = 1\nOutput: [10,8,6]\nExplanation:\n\nAfter queries[0], there is an obstacle at distance 10.\nAfter queries[1], there are obstacles at distances 8 and 10.\nAfter queries[2], there are obstacles at distances 6, 8, and 10.\n\n\n\u00a0\nConstraints:\n\n1 <= queries.length <= 2 * 105\nAll queries[i] are unique.\n-109 <= queries[i][0], queries[i][1] <= 109\n1 <= k <= 105 Explanation:\n\nSolution 1: Priority Queue (Max-Heap)\nWe can use a priority queue (max-heap) to maintain the $k$ obstacles closest to the origin.\nTraverse $\\textit{queries}$, and for each query, calculate the sum of the absolute values of $x$ and $y$, then add it to the priority queue. If the size of the priority queue exceeds $k$, pop the top element. If the current size of the priority queue is equal to $k$, add the top element to the answer array; otherwise, add $-1$ to the answer array.\nAfter the traversal, return the answer array.\nThe time complexity is $O(n \\times \\log k)$, and the space complexity is $O(k)$. Here, $n$ is the length of the array $\\textit{queries}$. \n\n", "problem_ids": ["tiling-a-rectangle-with-the-fewest-squares", "subsets", "k-th-nearest-obstacle-queries"]}, "3292": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array nums that consists of n distinct positive integers. Apply m operations to this array, where in the ith operation you replace the number operations[i][0] with operations[i][1].\nIt is guaranteed that in the ith operation:\n\noperations[i][0] exists in nums.\noperations[i][1] does not exist in nums.\n\nReturn the array obtained after applying all the operations.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]\nOutput: [3,2,7,1]\nExplanation: We perform the following operations on nums:\n- Replace the number 1 with 3. nums becomes [3,2,4,6].\n- Replace the number 4 with 7. nums becomes [3,2,7,6].\n- Replace the number 6 with 1. nums becomes [3,2,7,1].\nWe return the final array [3,2,7,1].\n\nExample 2:\n\nInput: nums = [1,2], operations = [[1,3],[2,1],[3,2]]\nOutput: [2,1]\nExplanation: We perform the following operations to nums:\n- Replace the number 1 with 3. nums becomes [3,2].\n- Replace the number 2 with 1. nums becomes [3,1].\n- Replace the number 3 with 2. nums becomes [2,1].\nWe return the array [2,1].\n\n\u00a0\nConstraints:\n\nn == nums.length\nm == operations.length\n1 <= n, m <= 105\nAll the values of nums are distinct.\noperations[i].length == 2\n1 <= nums[i], operations[i][0], operations[i][1] <= 106\noperations[i][0] will exist in nums when applying the ith operation.\noperations[i][1] will not exist in nums when applying the ith operation. Explanation:\n\nSolution 1: Hash Table\nFirst, we use a hash table $d$ to record the indices of each number in the array $\\textit{nums}$. Then, we iterate through the operation array $\\textit{operations}$. For each operation $[x, y]$, we replace the number at index $d[x]$ in $\\textit{nums}$ with $y$, and update the index of $y$ in $d$ to $d[x]$.\nFinally, we return $\\textit{nums}$.\nThe time complexity is $O(n + m)$, and the space complexity is $O(n)$. Here, $n$ and $m$ are the lengths of the array $\\textit{nums}$ and the operation array $\\textit{operations}$, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed m * n integer matrix values, representing the values of m * n different items in m different shops. Each shop has n items where the jth item in the ith shop has a value of values[i][j]. Additionally, the items in the ith shop are sorted in non-increasing order of value. That is, values[i][j] >= values[i][j + 1] for all 0 <= j < n - 1.\nOn each day, you would like to buy a single item from one of the shops. Specifically, On the dth day you can:\n\nPick any shop i.\nBuy the rightmost available item j for the price of values[i][j] * d. That is, find the greatest index j such that item j was never bought before, and buy it for the price of values[i][j] * d.\n\nNote that all items are pairwise different. For example, if you have bought item 0 from shop 1, you can still buy item 0 from any other shop.\nReturn the maximum amount of money that can be spent on buying all  m * n products.\n\u00a0\nExample 1:\n\nInput: values = [[8,5,2],[6,4,1],[9,7,3]]\nOutput: 285\nExplanation: On the first day, we buy product 2 from shop 1 for a price of values[1][2] * 1 = 1.\nOn the second day, we buy product 2 from shop 0 for a price of values[0][2] * 2 = 4.\nOn the third day, we buy product 2 from shop 2 for a price of values[2][2] * 3 = 9.\nOn the fourth day, we buy product 1 from shop 1 for a price of values[1][1] * 4 = 16.\nOn the fifth day, we buy product 1 from shop 0 for a price of values[0][1] * 5 = 25.\nOn the sixth day, we buy product 0 from shop 1 for a price of values[1][0] * 6 = 36.\nOn the seventh day, we buy product 1 from shop 2 for a price of values[2][1] * 7 = 49.\nOn the eighth day, we buy product 0 from shop 0 for a price of values[0][0] * 8 = 64.\nOn the ninth day, we buy product 0 from shop 2 for a price of values[2][0] * 9 = 81.\nHence, our total spending is equal to 285.\nIt can be shown that 285 is the maximum amount of money that can be spent buying all m * n products. \n\nExample 2:\n\nInput: values = [[10,8,6,4,2],[9,7,5,3,2]]\nOutput: 386\nExplanation: On the first day, we buy product 4 from shop 0 for a price of values[0][4] * 1 = 2.\nOn the second day, we buy product 4 from shop 1 for a price of values[1][4] * 2 = 4.\nOn the third day, we buy product 3 from shop 1 for a price of values[1][3] * 3 = 9.\nOn the fourth day, we buy product 3 from shop 0 for a price of values[0][3] * 4 = 16.\nOn the fifth day, we buy product 2 from shop 1 for a price of values[1][2] * 5 = 25.\nOn the sixth day, we buy product 2 from shop 0 for a price of values[0][2] * 6 = 36.\nOn the seventh day, we buy product 1 from shop 1 for a price of values[1][1] * 7 = 49.\nOn the eighth day, we buy product 1 from shop 0 for a price of values[0][1] * 8 = 64\nOn the ninth day, we buy product 0 from shop 1 for a price of values[1][0] * 9 = 81.\nOn the tenth day, we buy product 0 from shop 0 for a price of values[0][0] * 10 = 100.\nHence, our total spending is equal to 386.\nIt can be shown that 386 is the maximum amount of money that can be spent buying all m * n products.\n\n\u00a0\nConstraints:\n\n1 <= m == values.length <= 10\n1 <= n == values[i].length <= 104\n1 <= values[i][j] <= 106\nvalues[i] are sorted in non-increasing order. Explanation:\n\nSolution 1: Greedy + Priority Queue\nAccording to the problem description, we should prioritize purchasing items with smaller values and leave items with larger values to be purchased later in order to maximize the total cost. Therefore, we use a priority queue (min-heap) to store the smallest value item that has not been purchased in each store. Initially, we add the rightmost item in each store to the priority queue.\nEach day, we take out the item with the smallest value from the priority queue, add it to the answer, and add the previous item in the store where the item is located to the priority queue. We repeat the above operation until the priority queue is empty.\nThe time complexity is $O(m \\times n \\times \\log m)$, and the space complexity is $O(m)$. Here, $m$ and $n$ are the number of rows and columns of the array $values$, respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nThere is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c.\nA city's skyline is the\u00a0outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different.\nWe are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction.\nReturn the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\n\u00a0\nExample 1:\n\n\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n\nExample 2:\n\nInput: grid = [[0,0,0],[0,0,0],[0,0,0]]\nOutput: 0\nExplanation: Increasing the height of any building will result in the skyline changing.\n\n\u00a0\nConstraints:\n\nn == grid.length\nn == grid[r].length\n2 <= n <= 50\n0 <= grid[r][c] <= 100 Explanation:\n\nSolution 1: Greedy\nAccording to the problem description, we can increase the value of each cell $(i, j)$ to the smaller value between the maximum value of the $i$-th row and the $j$-th column, ensuring it does not affect the skyline. Thus, the height added to each cell is $\\min(\\textit{rowMax}[i], \\textit{colMax}[j]) - \\textit{grid}[i][j]$.\nTherefore, we can first traverse the matrix once to calculate the maximum value of each row and column, storing them in the arrays $\\textit{rowMax}$ and $\\textit{colMax}$, respectively. Then, we traverse the matrix again to compute the answer.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n)$, where $n$ is the side length of the matrix $\\textit{grid}$. \n\n", "problem_ids": ["replace-elements-in-an-array", "maximum-spending-after-buying-items", "max-increase-to-keep-city-skyline"]}, "3297": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.\nYou have a memory allocator with the following functionalities:\n\nAllocate a block of size consecutive free memory units and assign it the id mID.\nFree all memory units with the given id mID.\n\nNote that:\n\nMultiple blocks can be allocated to the same mID.\nYou should free all the memory units with mID, even if they were allocated in different blocks.\n\nImplement the Allocator class:\n\nAllocator(int n) Initializes an Allocator object with a memory array of size n.\nint allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1.\nint free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.\n\n\u00a0\nExample 1:\n\nInput\n[\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]\n[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]\nOutput\n[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\n\nExplanation\nAllocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.\nloc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.\nloc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.\nloc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.\nloc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.\nloc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.\nloc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.\nloc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.\nloc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.\nloc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.\nloc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.\n\n\u00a0\nConstraints:\n\n1 <= n, size, mID <= 1000\nAt most 1000 calls will be made to allocate and free. Explanation:\n\nSolution 1: Brute Force Simulation\nThe data range of the problem is not large, so we can directly use an array to simulate the memory space.\nDuring initialization, set each element in the array to $0$, indicating it's free.\nWhen the allocate method is called, traverse the array, find size consecutive free memory units, set them to mID, and return the first index.\nWhen the free method is called, traverse the array, set all memory units equal to mID to $0$, indicating they are free.\nThe time complexity is $O(n \\times q)$, and the space complexity is $O(n)$, where $n$ and $q$ are the size of the memory space and the number of method calls, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two strings s1 and s2, both of length 4, consisting of lowercase English letters.\nYou can apply the following operation on any of the two strings any number of times:\n\nChoose any two indices i and j such that j - i = 2, then swap the two characters at those indices in the string.\n\nReturn true if you can make the strings s1 and s2 equal, and false otherwise.\n\u00a0\nExample 1:\n\nInput: s1 = \"abcd\", s2 = \"cdab\"\nOutput: true\nExplanation: We can do the following operations on s1:\n- Choose the indices i = 0, j = 2. The resulting string is s1 = \"cbad\".\n- Choose the indices i = 1, j = 3. The resulting string is s1 = \"cdab\" = s2.\n\nExample 2:\n\nInput: s1 = \"abcd\", s2 = \"dacb\"\nOutput: false\nExplanation: It is not possible to make the two strings equal.\n\n\u00a0\nConstraints:\n\ns1.length == s2.length == 4\ns1 and s2 consist only of lowercase English letters. Explanation:\n\nSolution 1: Counting\nWe observe the operation in the problem, and find that if the parity of the two indices $i$ and $j$ of the string is the same, then their order can be changed by swapping.\nTherefore, we can count the occurrence times of the characters at odd indices and even indices in the two strings. If the counting results of the two strings are the same, then we can make the two strings equal through the operation.\nThe time complexity is $O(n + |\\Sigma|)$, and the space complexity is $O(|\\Sigma|)$. Here, $n$ is the length of the string, and $\\Sigma$ is the character set.\nSimilar problems:\n\n2840. Check if Strings Can be Made Equal With Operations II \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an n-ary tree, return the level order traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n\u00a0\nExample 1:\n\n\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [[1],[3,2,4],[5,6]]\n\nExample 2:\n\n\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n\n\u00a0\nConstraints:\n\nThe height of the n-ary tree is less than or equal to 1000\nThe total number of nodes is between [0, 104] Explanation:\n\nSolution 1: BFS\nFirst, we check if the root node is null. If it is, we return an empty list directly.\nOtherwise, we create a queue $q$ and initially add the root node to the queue.\nWhen the queue is not empty, we loop through the following operations:\n\nCreate an empty list $t$ to store the values of the current level nodes.\nFor each node in the queue, add its value to $t$ and add its child nodes to the queue.\nAdd $t$ to the result list $ans$.\n\nFinally, return the result list $ans$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the N-ary tree. \n\n", "problem_ids": ["design-memory-allocator", "check-if-strings-can-be-made-equal-with-operations-i", "n-ary-tree-level-order-traversal"]}, "3298": {"text": "Similar Problem 1 \n\n Problem:\n\nAn alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string \"abcdefghijklmnopqrstuvwxyz\".\n\nFor example, \"abc\" is an alphabetical continuous string, while \"acb\" and \"za\" are not.\n\nGiven a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.\n\u00a0\nExample 1:\n\nInput: s = \"abacaba\"\nOutput: 2\nExplanation: There are 4 distinct continuous substrings: \"a\", \"b\", \"c\" and \"ab\".\n\"ab\" is the longest continuous substring.\n\nExample 2:\n\nInput: s = \"abcde\"\nOutput: 5\nExplanation: \"abcde\" is the longest continuous substring.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists of only English lowercase letters. Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers $i$ and $j$ to point to the start and end of the current consecutive substring respectively. Traverse the string $s$, if the current character $s[j]$ is greater than $s[j-1]$, then move $j$ one step to the right, otherwise update $i$ to $j$, and update the length of the longest consecutive substring.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.\n\u00a0\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\nExample 2:\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\u00a0\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique. Explanation:\n\nSolution 1: Topological Sorting\nFor this problem, we can consider the courses as nodes in a graph, and prerequisites as edges in the graph. Thus, we can transform this problem into determining whether there is a cycle in the directed graph.\nSpecifically, we can use the idea of topological sorting. For each node with an in-degree of $0$, we reduce the in-degree of its out-degree nodes by $1$, until all nodes have been traversed.\nIf all nodes have been traversed, it means there is no cycle in the graph, and we can complete all courses; otherwise, we cannot complete all courses.\nThe time complexity is $O(n + m)$, and the space complexity is $O(n + m)$. Here, $n$ and $m$ are the number of courses and prerequisites respectively. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,4,6]\nOutput: 8\nExplanation: There are 8 valid tuples:\n(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)\n(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)\n\nExample 2:\n\nInput: nums = [1,2,4,5,10]\nOutput: 16\nExplanation: There are 16 valid tuples:\n(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)\n(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)\n(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)\n(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104\nAll elements in nums are distinct. Explanation:\n\nSolution 1: Combination + Hash Table\nAssuming there are $n$ pairs of numbers, for any two pairs of numbers $a, b$ and $c, d$ that satisfy the condition $a \\times b = c \\times d$, there are a total of $\\mathrm{C}_n^2 = \\frac{n \\times (n-1)}{2}$ such combinations.\nAccording to the problem description, each combination that satisfies the above condition can form $8$ tuples that satisfy the problem requirements. Therefore, we can multiply the number of combinations with the same product by $8$ (equivalent to left shifting by $3$ bits) and add them up to get the result.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["length-of-the-longest-alphabetical-continuous-substring", "course-schedule", "tuple-with-same-product"]}, "3299": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:\n\nThe value of the first element in arr must be 1.\nThe absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.\n\nThere are 2 types of operations that you can perform any number of times:\n\nDecrease the value of any element of arr to a smaller positive integer.\nRearrange the elements of arr to be in any order.\n\nReturn the maximum possible value of an element in arr after performing the operations to satisfy the conditions.\n\u00a0\nExample 1:\n\nInput: arr = [2,2,1,2,1]\nOutput: 2\nExplanation: \nWe can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].\nThe largest element in arr is 2.\n\nExample 2:\n\nInput: arr = [100,1,1000]\nOutput: 3\nExplanation: \nOne possible way to satisfy the conditions is by doing the following:\n1. Rearrange arr so it becomes [1,100,1000].\n2. Decrease the value of the second element to 2.\n3. Decrease the value of the third element to 3.\nNow arr = [1,2,3], which satisfies the conditions.\nThe largest element in arr is 3.\n\nExample 3:\n\nInput: arr = [1,2,3,4,5]\nOutput: 5\nExplanation: The array already satisfies the conditions, and the largest element is 5.\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 105\n1 <= arr[i] <= 109 Explanation:\n\nSolution 1: Sorting + Greedy Algorithm\nFirst, we sort the array and then set the first element of the array to $1$.\nNext, we start traversing the array from the second element. If the difference between the current element and the previous one is more than $1$, we greedily reduce the current element to the previous element plus $1$.\nFinally, we return the maximum element in the array.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Where $n$ is the length of the array. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\n\u00a0\nExample 1:\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n\nExample 2:\nInput: nums = [0]\nOutput: [0]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\n\n\u00a0\nFollow up: Could you minimize the total number of operations done? Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers $i$ and $j$, where pointer $i$ points to the end of the sequence that has been processed, and pointer $j$ points to the head of the sequence to be processed. Initially, $i=-1$.\nNext, we traverse $j \\in [0,n)$, if $nums[j] \\neq 0$, then we swap the next number pointed by pointer $i$ with $nums[j]$, and move $i$ forward. Continue to traverse until $j$ reaches the end of the array, all non-zero elements of the array are moved to the front of the array in the original order, and all zero elements are moved to the end of the array.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nTable: Tweets\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| tweet_id    | int     |\n| tweet_date  | date    |\n| tweet       | varchar |\n+-------------+---------+\ntweet_id is the primary key (column with unique values) for this table.\nEach row of this table contains user_id, tweet_id, tweet_date and tweet.\n\nWrite a solution to find the top 3 trending hashtags in February 2024. Every tweet may contain several hashtags.\nReturn the result table ordered by count of hashtag, hashtag in descending order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput:\nTweets table:\n\n+---------+----------+------------------------------------------------------------+------------+\n| user_id | tweet_id | tweet                                                      | tweet_date |\n+---------+----------+------------------------------------------------------------+------------+\n| 135     | 13       | Enjoying a great start to the day. #HappyDay #MorningVibes | 2024-02-01 |\n| 136     | 14       | Another #HappyDay with good vibes! #FeelGood               | 2024-02-03 |\n| 137     | 15       | Productivity peaks! #WorkLife #ProductiveDay               | 2024-02-04 |\n| 138     | 16       | Exploring new tech frontiers. #TechLife #Innovation        | 2024-02-04 |\n| 139     | 17       | Gratitude for today's moments. #HappyDay #Thankful         | 2024-02-05 |\n| 140     | 18       | Innovation drives us. #TechLife #FutureTech                | 2024-02-07 |\n| 141     | 19       | Connecting with nature's serenity. #Nature #Peaceful       | 2024-02-09 |\n+---------+----------+------------------------------------------------------------+------------+\n \nOutput:\n\n+-----------+-------+\n| hashtag   | count |\n+-----------+-------+\n| #HappyDay | 3     |\n| #TechLife | 2     |\n| #WorkLife | 1     |\n+-----------+-------+\n\n\nExplanation:\n\n#HappyDay: Appeared in tweet IDs 13, 14, and 17, with a total count of 3 mentions.\n#TechLife: Appeared in tweet IDs 16 and 18, with a total count of 2 mentions.\n#WorkLife: Appeared in tweet ID 15, with a total count of 1 mention.\n\nNote: Output table is sorted in descending order by count and hashtag respectively. Explanation:\n\nSolution 1: Regular Expression Matching\nWe can use regular expressions to match all tags in each tweet, and then count the occurrence of each tag. Finally, we can sort the tags in descending order by the number of occurrences. If the number of occurrences is the same, we sort them in descending order by the tag name, and return the top three tags. \n\n", "problem_ids": ["maximum-element-after-decreasing-and-rearranging", "move-zeroes", "find-trending-hashtags-ii"]}, "3308": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array nums and a non-negative integer k. In one operation, you can increase or decrease any element by 1.\nReturn the minimum number of operations needed to make the median of nums equal to k.\nThe median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the larger of the two values is taken.\n\u00a0\nExample 1:\n\nInput: nums = [2,5,6,8,5], k = 4\nOutput: 2\nExplanation:\nWe can subtract one from nums[1] and nums[4] to obtain [2, 4, 6, 8, 4]. The median of the resulting array is equal to k.\n\nExample 2:\n\nInput: nums = [2,5,6,8,5], k = 7\nOutput: 3\nExplanation:\nWe can add one to nums[1] twice and add one to nums[2] once to obtain [2, 7, 7, 8, 5].\n\nExample 3:\n\nInput: nums = [1,2,3,4,5,6], k = 4\nOutput: 0\nExplanation:\nThe median of the array is already equal to k.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 2 * 105\n1 <= nums[i] <= 109\n1 <= k <= 109 Explanation:\n\nSolution 1: Greedy + Sorting\nFirst, we sort the array $nums$ and find the position $m$ of the median. The initial number of operations we need is $|nums[m] - k|$.\nNext, we discuss in two cases:\n\nIf $nums[m] > k$, then all elements to the right of $m$ are greater than or equal to $k$. We only need to reduce the elements greater than $k$ on the left of $m$ to $k$.\nIf $nums[m] \\le k$, then all elements to the left of $m$ are less than or equal to $k$. We only need to increase the elements less than $k$ on the right of $m$ to $k$.\n\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of the array $nums$. \n\nSimilar Problem 2 \n\n Problem:\n\nKoko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\n\u00a0\nExample 1:\n\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n\nExample 2:\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n\nExample 3:\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n\n\u00a0\nConstraints:\n\n1 <= piles.length <= 104\npiles.length <= h <= 109\n1 <= piles[i] <= 109 Explanation:\n\nSolution 1: Binary Search\nWe notice that if Koko can eat all the bananas at a speed of $k$ within $h$ hours, then she can also eat all the bananas at a speed of $k' > k$ within $h$ hours. This shows monotonicity, so we can use binary search to find the smallest $k$ that satisfies the condition.\nWe define the left boundary of the binary search as $l = 1$, and the right boundary as $r = \\max(\\textit{piles})$. For each binary search, we take the middle value $mid = \\frac{l + r}{2}$, and then calculate the time $s$ required to eat bananas at a speed of $mid$. If $s \\leq h$, it means that the speed of $mid$ can meet the condition, and we update the right boundary $r$ to $mid$; otherwise, we update the left boundary $l$ to $mid + 1$. Finally, when $l = r$, we find the smallest $k$ that satisfies the condition.\nThe time complexity is $O(n \\times \\log M)$, where $n$ and $M$ are the length and maximum value of the array piles respectively. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nAlice and Bob are traveling to Rome for separate business meetings.\nYou are given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice will be in the city from the dates arriveAlice to leaveAlice (inclusive), while Bob will be in the city from the dates arriveBob to leaveBob (inclusive). Each will be a 5-character string in the format \"MM-DD\", corresponding to the month and day of the date.\nReturn the total number of days that Alice and Bob are in Rome together.\nYou can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].\n\u00a0\nExample 1:\n\nInput: arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"\nOutput: 3\nExplanation: Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n\nExample 2:\n\nInput: arriveAlice = \"10-01\", leaveAlice = \"10-31\", arriveBob = \"11-01\", leaveBob = \"12-31\"\nOutput: 0\nExplanation: There is no day when Alice and Bob are in Rome together, so we return 0.\n\n\u00a0\nConstraints:\n\nAll dates are provided in the format \"MM-DD\".\nAlice and Bob's arrival dates are earlier than or equal to their leaving dates.\nThe given dates are valid dates of a non-leap year. Explanation:\n\nSolution 1: Simulation\nWe convert the dates into days, and then calculate the number of days both people are in Rome.\nThe time complexity is $O(C)$, and the space complexity is $O(C)$. Here, $C$ is a constant. \n\n", "problem_ids": ["minimum-operations-to-make-median-of-array-equal-to-k", "koko-eating-bananas", "count-days-spent-together"]}, "3309": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string num which represents an integer, return true if num is a strobogrammatic number.\nA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\u00a0\nExample 1:\n\nInput: num = \"69\"\nOutput: true\n\nExample 2:\n\nInput: num = \"88\"\nOutput: true\n\nExample 3:\n\nInput: num = \"962\"\nOutput: false\n\n\u00a0\nConstraints:\n\n1 <= num.length <= 50\nnum consists of only digits.\nnum does not contain any leading zeros except for zero itself. Explanation:\n\nSolution 1: Two Pointers Simulation\nWe define an array $d$, where $d[i]$ represents the number after rotating the digit $i$ by 180\u00b0. If $d[i]$ is $-1$, it means that the digit $i$ cannot be rotated 180\u00b0 to get a valid digit.\nWe define two pointers $i$ and $j$, pointing to the left and right ends of the string, respectively. Then we continuously move the pointers towards the center, checking whether $d[num[i]]$ and $num[j]$ are equal. If they are not equal, it means that the string is not a strobogrammatic number, and we can directly return $false$. If $i > j$, it means that we have traversed the entire string, and we return $true$.\nThe time complexity is $O(n)$, where $n$ is the length of the string. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nGiven an array arr of positive integers, consider all binary trees such that:\n\nEach node has either 0 or 2 children;\nThe values of arr correspond to the values of each leaf in an in-order traversal of the tree.\nThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n\nAmong all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.\nA node is a leaf if and only if it has zero children.\n\u00a0\nExample 1:\n\n\nInput: arr = [6,2,4]\nOutput: 32\nExplanation: There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n\nExample 2:\n\n\nInput: arr = [4,11]\nOutput: 44\n\n\u00a0\nConstraints:\n\n2 <= arr.length <= 40\n1 <= arr[i] <= 15\nIt is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231). Explanation:\n\nSolution 1: Memoization Search\nAccording to the problem description, the values in the array $arr$ correspond one-to-one with the values in the inorder traversal of each leaf node of the tree. We can divide the array into two non-empty sub-arrays, corresponding to the left and right subtrees of the tree, and recursively solve for the minimum possible sum of all non-leaf node values in each subtree.\nWe design a function $dfs(i, j)$, which represents the minimum possible sum of all non-leaf node values in the index range $[i, j]$ of the array $arr$. The answer is $dfs(0, n - 1)$, where $n$ is the length of the array $arr$.\nThe calculation process of the function $dfs(i, j)$ is as follows:\n\nIf $i = j$, it means that there is only one element in the array $arr[i..j]$, and there are no non-leaf nodes, so $dfs(i, j) = 0$.\nOtherwise, we enumerate $k \\in [i, j - 1]$, divide the array $arr$ into two sub-arrays $arr[i..k]$ and $arr[k + 1..j]$. For each $k$, we recursively calculate $dfs(i, k)$ and $dfs(k + 1, j)$. Here, $dfs(i, k)$ represents the minimum possible sum of all non-leaf node values in the index range $[i, k]$ of the array $arr$, and $dfs(k + 1, j)$ represents the minimum possible sum of all non-leaf node values in the index range $[k + 1, j]$ of the array $arr$. So $dfs(i, j) = \\min_{i \\leq k < j} {dfs(i, k) + dfs(k + 1, j) + \\max_{i \\leq t \\leq k} {arr[t]} \\max_{k < t \\leq j} {arr[t]}}$.\n\nIn summary, we can get:\n$$\ndfs(i, j) = \\begin{cases}\n0, & \\textit{if } i = j \\\n\\min_{i \\leq k < j} {dfs(i, k) + dfs(k + 1, j) + \\max_{i \\leq t \\leq k} {arr[t]} \\max_{k < t \\leq j} {arr[t]}}, & \\textit{if } i < j\n\\end{cases}\n$$\nIn the above recursive process, we can use the method of memoization search to avoid repeated calculations. Additionally, we can use an array $g$ to record the maximum value of all leaf nodes in the index range $[i, j]$ of the array $arr$. This allows us to optimize the calculation process of $dfs(i, j)$:\n$$\ndfs(i, j) = \\begin{cases}\n0, & \\textit{if } i = j \\\n\\min_{i \\leq k < j} {dfs(i, k) + dfs(k + 1, j) + g[i][k] \\cdot g[k + 1][j]}, & \\textit{if } i < j\n\\end{cases}\n$$\nFinally, we return $dfs(0, n - 1)$.\nThe time complexity is $O(n^3)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of the array $arr$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\u00a0\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\n\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nAll the integers of nums are unique. Explanation:\n\nSolution 1: DFS (Backtracking)\nWe design a function $dfs(i)$ to represent that the first $i$ positions have been filled, and now we need to fill the $i+1$ position. We enumerate all possible numbers, if this number has not been filled, we fill in this number, and then continue to fill the next position, until all positions are filled.\nThe time complexity is $O(n \\times n!)$, where $n$ is the length of the array. There are $n!$ permutations in total, and each permutation takes $O(n)$ time to construct.\nSimilar problems:\n\n47. Permutations II \n\n", "problem_ids": ["strobogrammatic-number", "minimum-cost-tree-from-leaf-values", "permutations"]}, "3311": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.\nBattleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).\n\u00a0\nExample 1:\n\n\nInput: board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\nOutput: 2\n\nExample 2:\n\nInput: board = [[\".\"]]\nOutput: 0\n\n\u00a0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 200\nboard[i][j] is either '.' or 'X'.\n\n\u00a0\nFollow up: Could you do it in one-pass, using only O(1) extra memory and without modifying the values board? Explanation:\n\nSolution 1: Direct Iteration\nWe can iterate through the matrix, find the top-left corner of each battleship, i.e., the position where the current position is X and both the top and left are not X, and increment the answer by one.\nAfter the iteration ends, return the answer.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. The space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nThere are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse.\nA point of the cheese with index i (0-indexed) is:\n\nreward1[i] if the first mouse eats it.\nreward2[i] if the second mouse eats it.\n\nYou are given a positive integer array reward1, a positive integer array reward2, and a non-negative integer k.\nReturn the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.\n\u00a0\nExample 1:\n\nInput: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\nOutput: 15\nExplanation: In this example, the first mouse eats the 2nd\u00a0(0-indexed) and the 3rd\u00a0types of cheese, and the second mouse eats the 0th\u00a0and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\nExample 2:\n\nInput: reward1 = [1,1], reward2 = [1,1], k = 2\nOutput: 2\nExplanation: In this example, the first mouse eats the 0th\u00a0(0-indexed) and 1st\u00a0types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n\u00a0\nConstraints:\n\n1 <= n == reward1.length == reward2.length <= 105\n1 <= reward1[i],\u00a0reward2[i] <= 1000\n0 <= k <= n Explanation:\n\nSolution 1: Greedy + Sort\nWe can first give all the cheese to the second mouse. Next, consider giving $k$ pieces of cheese to the first mouse. How should we choose these $k$ pieces of cheese? Obviously, if we give the $i$-th piece of cheese from the second mouse to the first mouse, the change in the score is $reward1[i] - reward2[i]$. We hope that this change is as large as possible, so that the total score is maximized.\nTherefore, we sort the cheese in decreasing order of reward1[i] - reward2[i]. The first $k$ pieces of cheese are eaten by the first mouse, and the remaining cheese is eaten by the second mouse to obtain the maximum score.\nTime complexity $O(n \\times \\log n)$, space complexity $O(n)$. Where $n$ is the number of cheeses. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven two sparse matrices mat1 of size m x k and mat2 of size k x n, return the result of mat1 x mat2. You may assume that multiplication is always possible.\n\u00a0\nExample 1:\n\n\nInput: mat1 = [[1,0,0],[-1,0,3]], mat2 = [[7,0,0],[0,0,0],[0,0,1]]\nOutput: [[7,0,0],[-7,0,3]]\n\nExample 2:\n\nInput: mat1 = [[0]], mat2 = [[0]]\nOutput: [[0]]\n\n\u00a0\nConstraints:\n\nm == mat1.length\nk == mat1[i].length == mat2.length\nn == mat2[i].length\n1 <= m, n, k <= 100\n-100 <= mat1[i][j], mat2[i][j] <= 100 Explanation:\n\nSolution 1: Direct Multiplication\nWe can directly calculate each element in the result matrix according to the definition of matrix multiplication.\nThe time complexity is $O(m \\times n \\times k)$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows of matrix $mat1$ and the number of columns of matrix $mat2$ respectively, and $k$ is the number of columns of matrix $mat1$ or the number of rows of matrix $mat2$. \n\n", "problem_ids": ["battleships-in-a-board", "mice-and-cheese", "sparse-matrix-multiplication"]}, "3312": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".\n\nA common subsequence of two strings is a subsequence that is common to both strings.\n\u00a0\nExample 1:\n\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n\nExample 2:\n\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n\nExample 3:\n\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n\n\u00a0\nConstraints:\n\n1 <= text1.length, text2.length <= 1000\ntext1 and text2 consist of only lowercase English characters. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i][j]$ as the length of the longest common subsequence of the first $i$ characters of $text1$ and the first $j$ characters of $text2$. Therefore, the answer is $f[m][n]$, where $m$ and $n$ are the lengths of $text1$ and $text2$, respectively.\nIf the $i$th character of $text1$ and the $j$th character of $text2$ are the same, then $f[i][j] = f[i - 1][j - 1] + 1$; if the $i$th character of $text1$ and the $j$th character of $text2$ are different, then $f[i][j] = max(f[i - 1][j], f[i][j - 1])$. The state transition equation is:\n$$\nf[i][j] =\n\\begin{cases}\nf[i - 1][j - 1] + 1, & \\textit{if } text1[i - 1] = text2[j - 1] \\\n\\max(f[i - 1][j], f[i][j - 1]), & \\textit{if } text1[i - 1] \\neq text2[j - 1]\n\\end{cases}\n$$\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the lengths of $text1$ and $text2$, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.\nReturn true if the edges of the given graph make up a valid tree, and false otherwise.\n\u00a0\nExample 1:\n\n\nInput: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]\nOutput: true\n\nExample 2:\n\n\nInput: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]\nOutput: false\n\n\u00a0\nConstraints:\n\n1 <= n <= 2000\n0 <= edges.length <= 5000\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nThere are no self-loops or repeated edges. Explanation:\n\nSolution 1: Union-Find\nTo determine whether it is a tree, the following two conditions must be met:\n\nThe number of edges is equal to the number of nodes minus one;\nThere is no cycle.\n\nWe can use a union-find set to determine whether there is a cycle. We traverse the edges, if two nodes are already in the same set, it means there is a cycle. Otherwise, we merge the two nodes into the same set. Then we decrease the number of connected components by one, and finally check whether the number of connected components is $1$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$, where $n$ is the number of nodes. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven a 2D character matrix grid, where grid[i][j] is either 'X', 'Y', or '.', return the number of submatrices that contain:\n\ngrid[0][0]\nan equal frequency of 'X' and 'Y'.\nat least one 'X'.\n\n\u00a0\nExample 1:\n\nInput: grid = [[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]\nOutput: 3\nExplanation:\n\n\nExample 2:\n\nInput: grid = [[\"X\",\"X\"],[\"X\",\"Y\"]]\nOutput: 0\nExplanation:\nNo submatrix has an equal frequency of 'X' and 'Y'.\n\nExample 3:\n\nInput: grid = [[\".\",\".\"],[\".\",\".\"]]\nOutput: 0\nExplanation:\nNo submatrix has at least one 'X'.\n\n\u00a0\nConstraints:\n\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] is either 'X', 'Y', or '.'. Explanation:\n\nSolution 1: 2D Prefix Sum\nAccording to the problem description, we only need to calculate the prefix sums $s[i][j][0]$ and $s[i][j][1]$ for each position $(i, j)$, which represent the number of characters X and Y in the submatrix from $(0, 0)$ to $(i, j)$, respectively. If $s[i][j][0] > 0$ and $s[i][j][0] = s[i][j][1]$, it means the condition is met, and we increment the answer by one.\nAfter traversing all positions, return the answer.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ represent the number of rows and columns of the matrix, respectively. \n\n", "problem_ids": ["longest-common-subsequence", "graph-valid-tree", "count-submatrices-with-equal-frequency-of-x-and-y"]}, "3317": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: Customers\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID and name of a customer.\n\n\u00a0\nTable: Orders\n\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\ncustomerId is a foreign key (reference columns) of the ID from the Customers table.\nEach row of this table indicates the ID of an order and the ID of the customer who ordered it.\n\n\u00a0\nWrite a solution to find all customers who never order anything.\nReturn the result table in any order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\nOutput: \n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+ Explanation:\n\nSolution 1: NOT IN\nList all customer IDs of existing orders, and use NOT IN to find customers who are not in the list. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed integer array nums having length n, and an integer k.\nYou can perform the following increment operation any number of times (including zero):\n\nChoose an index i in the range [0, n - 1], and increase nums[i] by 1.\n\nAn array is considered beautiful if, for any subarray with a size of 3 or more, its maximum element is greater than or equal to k.\nReturn an integer denoting the minimum number of increment operations needed to make nums beautiful.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,0,0,2], k = 4\nOutput: 3\nExplanation: We can perform the following increment operations to make nums beautiful:\nChoose index i = 1 and increase nums[1] by 1 -> [2,4,0,0,2].\nChoose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,3].\nChoose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,4].\nThe subarrays with a size of 3 or more are: [2,4,0], [4,0,0], [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4].\nIn all the subarrays, the maximum element is equal to k = 4, so nums is now beautiful.\nIt can be shown that nums cannot be made beautiful with fewer than 3 increment operations.\nHence, the answer is 3.\n\nExample 2:\n\nInput: nums = [0,1,3,3], k = 5\nOutput: 2\nExplanation: We can perform the following increment operations to make nums beautiful:\nChoose index i = 2 and increase nums[2] by 1 -> [0,1,4,3].\nChoose index i = 2 and increase nums[2] by 1 -> [0,1,5,3].\nThe subarrays with a size of 3 or more are: [0,1,5], [1,5,3], [0,1,5,3].\nIn all the subarrays, the maximum element is equal to k = 5, so nums is now beautiful.\nIt can be shown that nums cannot be made beautiful with fewer than 2 increment operations.\nHence, the answer is 2.\n\nExample 3:\n\nInput: nums = [1,1,2], k = 1\nOutput: 0\nExplanation: The only subarray with a size of 3 or more in this example is [1,1,2].\nThe maximum element, 2, is already greater than k = 1, so we don't need any increment operation.\nHence, the answer is 0.\n\n\u00a0\nConstraints:\n\n3 <= n == nums.length <= 105\n0 <= nums[i] <= 109\n0 <= k <= 109 Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f$, $g$, and $h$ as the minimum number of increment operations needed to get the maximum value from the last three items in the first $i$ items, initially $f = 0$, $g = 0$, $h = 0$.\nNext, we traverse the array $nums$. For each $x$, we need to update the values of $f$, $g$, and $h$ to meet the requirements of the problem, that is:\n$$\n\\begin{aligned}\nf' &= g \\\ng' &= h \\\nh' &= \\min(f, g, h) + \\max(k - x, 0)\n\\end{aligned}\n$$\nFinally, we only need to return the minimum value among $f$, $g$, and $h$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n\u00a0\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n\n\u00a0\nConstraints:\n\n-231 <= dividend, divisor <= 231 - 1\ndivisor != 0 Explanation:\n\nSolution 1: Simulation + Fast Power\nDivision is essentially subtraction. The problem requires us to calculate the integer result after dividing two numbers, which is actually calculating how many divisors and a number less than the divisor constitute the dividend. However, only one subtraction can be done in one loop, which is too inefficient and will lead to timeout. This can be optimized by using the idea of fast power.\nIt should be noted that since the problem explicitly requires that only 32-bit signed integers can be used at most, the divisor and dividend need to be converted to negative numbers for calculation. Because converting to positive numbers may cause overflow, such as when the dividend is INT32_MIN, it will be greater than INT32_MAX when converted to a positive number.\nAssuming the dividend is $a$ and the divisor is $b$, the time complexity is $O(\\log a \\times \\log b)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["customers-who-never-order", "minimum-increment-operations-to-make-array-beautiful", "divide-two-integers"]}, "3320": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an m x n picture consisting of black 'B' and white 'W' pixels, return the number of black lonely pixels.\nA black lonely pixel is a character 'B' that located at a specific position where the same row and same column don't have any other black pixels.\n\u00a0\nExample 1:\n\n\nInput: picture = [[\"W\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"W\"]]\nOutput: 3\nExplanation: All the three 'B's are black lonely pixels.\n\nExample 2:\n\n\nInput: picture = [[\"B\",\"B\",\"B\"],[\"B\",\"B\",\"W\"],[\"B\",\"B\",\"B\"]]\nOutput: 0\n\n\u00a0\nConstraints:\n\nm ==\u00a0picture.length\nn ==\u00a0picture[i].length\n1 <= m, n <= 500\npicture[i][j] is 'W' or 'B'. Explanation:\n\nSolution 1: Counting + Enumeration\nAccording to the problem description, we need to count the number of black pixels in each row and column, which are recorded in the arrays rows and cols respectively. Then we traverse each black pixel, check whether there is only one black pixel in its row and column. If so, we increment the answer by one.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m + n)$, where $m$ and $n$ are the number of rows and columns in the matrix respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.\nReturn the minimum possible value of nums[n - 1].\n\u00a0\nExample 1:\n\nInput: n = 3, x = 4\nOutput: 6\nExplanation:\nnums can be [4,5,6] and its last element is 6.\n\nExample 2:\n\nInput: n = 2, x = 7\nOutput: 15\nExplanation:\nnums can be [7,15] and its last element is 15.\n\n\u00a0\nConstraints:\n\n1 <= n, x <= 108 Explanation:\n\nSolution 1: Greedy + Bit Manipulation\nAccording to the problem description, to make the last element of the array as small as possible and the bitwise AND result of the elements in the array is $x$, the first element of the array must be $x$.\nAssume the binary representation of $x$ is $\\underline{1}00\\underline{1}00$, then the array sequence is $\\underline{1}00\\underline{1}00$, $\\underline{1}00\\underline{1}01$, $\\underline{1}00\\underline{1}10$, $\\underline{1}00\\underline{1}11$...\nIf we ignore the underlined part, then the array sequence is $0000$, $0001$, $0010$, $0011$..., the first item is $0$, then the $n$-th item is $n-1$.\nTherefore, the answer is to fill each bit of the binary of $n-1$ into the $0$ bit of the binary of $x$ based on $x$.\nThe time complexity is $O(\\log x)$, and the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nYou are given two integers numBottles and numExchange.\nnumBottles represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations:\n\nDrink any number of full water bottles turning them into empty bottles.\nExchange numExchange empty bottles with one full water bottle. Then, increase numExchange by one.\n\nNote that you cannot exchange multiple batches of empty bottles for the same value of numExchange. For example, if numBottles == 3 and numExchange == 1, you cannot exchange 3 empty water bottles for 3 full bottles.\nReturn the maximum number of water bottles you can drink.\n\u00a0\nExample 1:\n\n\nInput: numBottles = 13, numExchange = 6\nOutput: 15\nExplanation: The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.\n\nExample 2:\n\n\nInput: numBottles = 10, numExchange = 3\nOutput: 13\nExplanation: The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.\n\n\u00a0\nConstraints:\n\n1 <= numBottles <= 100 \n1 <= numExchange <= 100 Explanation:\n\nSolution 1: Simulation\nWe can drink all the full water bottles at the beginning, so the initial amount of water we drink is numBottles. Then we continuously perform the following operations:\n\nIf we currently have numExchange empty water bottles, we can exchange them for a full water bottle, after which the value of numExchange increases by 1. Then, we drink this bottle of water, the amount of water we drink increases by $1$, and the number of empty water bottles increases by $1$.\nIf we currently do not have numExchange empty water bottles, then we can no longer exchange for water, at which point we can stop the operation.\n\nWe continuously perform the above operations until we can no longer exchange for water. The final amount of water we drink is the answer.\nThe time complexity is $O(\\sqrt{numBottles})$ and the space complexity is $O(1)$. \n\n", "problem_ids": ["lonely-pixel-i", "minimum-array-end", "water-bottles-ii"]}, "3324": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed string word and an integer k.\nAt every second, you must perform the following operations:\n\nRemove the first k characters of word.\nAdd any k characters to the end of word.\n\nNote that you do not necessarily need to add the same characters that you removed. However, you must perform both operations at every second.\nReturn the minimum time greater than zero required for word to revert to its initial state.\n\u00a0\nExample 1:\n\nInput: word = \"abacaba\", k = 3\nOutput: 2\nExplanation: At the 1st second, we remove characters \"aba\" from the prefix of word, and add characters \"bac\" to the end of word. Thus, word becomes equal to \"cababac\".\nAt the 2nd second, we remove characters \"cab\" from the prefix of word, and add \"aba\" to the end of word. Thus, word becomes equal to \"abacaba\" and reverts to its initial state.\nIt can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state.\n\nExample 2:\n\nInput: word = \"abacaba\", k = 4\nOutput: 1\nExplanation: At the 1st second, we remove characters \"abac\" from the prefix of word, and add characters \"caba\" to the end of word. Thus, word becomes equal to \"abacaba\" and reverts to its initial state.\nIt can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state.\n\nExample 3:\n\nInput: word = \"abcbabcd\", k = 2\nOutput: 4\nExplanation: At every second, we will remove the first 2 characters of word, and add the same characters to the end of word.\nAfter 4 seconds, word becomes equal to \"abcbabcd\" and reverts to its initial state.\nIt can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 50 \n1 <= k <= word.length\nword consists only of lowercase English letters. Explanation:\n\nSolution 1: Enumeration\nLet's assume that if we can restore word to its initial state with only one operation, it means that word[k:] is a prefix of word, i.e., word[k:] == word[:n-k].\nIf there are multiple operations, let's assume $i$ is the number of operations, then it means that word[k*i:] is a prefix of word, i.e., word[k*i:] == word[:n-k*i].\nTherefore, we can enumerate the number of operations and check whether word[k*i:] is a prefix of word. If it is, then return $i$.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n)$. Here, $n$ is the length of word. \n\nSimilar Problem 2 \n\n Problem:\n\nWe can use run-length encoding (i.e., RLE) to encode a sequence of integers. In a run-length encoded array of even length encoding (0-indexed), for all even i, encoding[i] tells us the number of times that the non-negative integer value encoding[i + 1] is repeated in the sequence.\n\nFor example, the sequence arr = [8,8,8,5,5] can be encoded to be encoding = [3,8,2,5]. encoding = [3,8,0,9,2,5] and encoding = [2,8,1,8,2,5] are also valid RLE of arr.\n\nGiven a run-length encoded array, design an iterator that iterates through it.\nImplement the RLEIterator class:\n\nRLEIterator(int[] encoded) Initializes the object with the encoded array encoded.\nint next(int n) Exhausts the next n elements and returns the last element exhausted in this way. If there is no element left to exhaust, return -1 instead.\n\n\u00a0\nExample 1:\n\nInput\n[\"RLEIterator\", \"next\", \"next\", \"next\", \"next\"]\n[[[3, 8, 0, 9, 2, 5]], [2], [1], [1], [2]]\nOutput\n[null, 8, 8, 5, -1]\n\nExplanation\nRLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // This maps to the sequence [8,8,8,5,5].\nrLEIterator.next(2); // exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5].\nrLEIterator.next(1); // exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5].\nrLEIterator.next(1); // exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5].\nrLEIterator.next(2); // exhausts 2 terms, returning -1. This is because the first term exhausted was 5,\nbut the second term did not exist. Since the last term exhausted does not exist, we return -1.\n\n\u00a0\nConstraints:\n\n2 <= encoding.length <= 1000\nencoding.length is even.\n0 <= encoding[i] <= 109\n1 <= n <= 109\nAt most 1000 calls will be made to next. Explanation:\n\nSolution 1: Maintain Two Pointers\nWe define two pointers $i$ and $j$, where pointer $i$ points to the current run-length encoding being read, and pointer $j$ points to which character in the current run-length encoding is being read. Initially, $i = 0$, $j = 0$.\nEach time we call next(n), we judge whether the remaining number of characters in the current run-length encoding $encoding[i] - j$ is less than $n$. If it is, we subtract $n$ by $encoding[i] - j$, add $2$ to $i$, and set $j$ to $0$, then continue to judge the next run-length encoding. If it is not, we add $n$ to $j$ and return $encoding[i + 1]$.\nIf $i$ exceeds the length of the run-length encoding and there is still no return value, it means that there are no remaining elements to be exhausted, and we return $-1$.\nThe time complexity is $O(n + q)$, and the space complexity is $O(n)$. Here, $n$ is the length of the run-length encoding, and $q$ is the number of times next(n) is called. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the root of an n-ary tree, return the preorder traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\n\u00a0\nExample 1:\n\n\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [1,3,5,6,2,4]\n\nExample 2:\n\n\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 104].\n0 <= Node.val <= 104\nThe height of the n-ary tree is less than or equal to 1000.\n\n\u00a0\nFollow up: Recursive solution is trivial, could you do it iteratively? Explanation:\n\nSolution 1: Recursion\nWe can recursively traverse the entire tree. For each node, we first add the node's value to the answer, then recursively call the function for each of the node's children.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes. \n\n", "problem_ids": ["minimum-time-to-revert-word-to-initial-state-i", "rle-iterator", "n-ary-tree-preorder-traversal"]}, "3329": {"text": "Similar Problem 1 \n\n Problem:\n\nA storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.\nThe game is represented by an m x n grid of characters grid where each element is a wall, floor, or box.\nYour task is to move the box 'B' to the target position 'T' under the following rules:\n\nThe character 'S' represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell).\nThe character '.' represents the floor which means a free cell to walk.\nThe character\u00a0'#'\u00a0represents the wall which means an obstacle (impossible to walk there).\nThere is only one box 'B' and one target cell 'T' in the grid.\nThe box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.\nThe player cannot walk through the box.\n\nReturn the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.\n\u00a0\nExample 1:\n\n\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: 3\nExplanation: We return only the number of times the box is pushed.\nExample 2:\n\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: -1\n\nExample 3:\n\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: 5\nExplanation: push the box down, left, left, up and up.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid contains only characters '.', '#', 'S', 'T', or 'B'.\nThere is only one character 'S', 'B', and 'T' in the grid. Explanation:\n\nSolution 1: Double-ended Queue + BFS\nWe consider the player's position and the box's position as a state, i.e., $(s_i, s_j, b_i, b_j)$, where $(s_i, s_j)$ is the player's position, and $(b_i, b_j)$ is the box's position. In the code implementation, we define a function $f(i, j)$, which maps the two-dimensional coordinates $(i, j)$ to a one-dimensional state number, i.e., $f(i, j) = i \\times n + j$, where $n$ is the number of columns in the grid. So the player and the box's state is $(f(s_i, s_j), f(b_i, b_j))$.\nFirst, we traverse the grid to find the initial positions of the player and the box, denoted as $(s_i, s_j)$ and $(b_i, b_j)$.\nThen, we define a double-ended queue $q$, where each element is a triplet $(f(s_i, s_j), f(b_i, b_j), d)$, indicating that the player is at $(s_i, s_j)$, the box is at $(b_i, b_j)$, and $d$ pushes have been made. Initially, we add $(f(s_i, s_j), f(b_i, b_j), 0)$ to the queue $q$.\nAdditionally, we use a two-dimensional array $vis$ to record whether each state has been visited. Initially, $vis[f(s_i, s_j), f(b_i, b_j)]$ is marked as visited.\nNext, we start the breadth-first search.\nIn each step of the search, we take out the queue head element $(f(s_i, s_j), f(b_i, b_j), d)$, and check whether $grid[b_i][b_j] = 'T'$ is satisfied. If it is, it means the box has been pushed to the target position, and now $d$ can be returned as the answer.\nOtherwise, we enumerate the player's next move direction. The player's new position is denoted as $(s_x, s_y)$. If $(s_x, s_y)$ is a valid position, we judge whether $(s_x, s_y)$ is the same as the box's position $(b_i, b_j)$:\n\nIf they are the same, it means the player has reached the box's position and pushed the box forward by one step. The box's new position is $(b_x, b_y)$. If $(b_x, b_y)$ is a valid position, and the state $(f(s_x, s_y), f(b_x, b_y))$ has not been visited, then we add $(f(s_x, s_y), f(b_x, b_y), d + 1)$ to the end of the queue $q$, and mark $vis[f(s_x, s_y), f(b_x, b_y)]$ as visited.\nIf they are different, it means the player has not pushed the box. Then we only need to judge whether the state $(f(s_x, s_y), f(b_i, b_j))$ has been visited. If it has not been visited, then we add $(f(s_x, s_y), f(b_i, b_j), d)$ to the head of the queue $q$, and mark $vis[f(s_x, s_y), f(b_i, b_j)]$ as visited.\n\nWe continue the breadth-first search until the queue is empty.\n\nNote, if the box is pushed, the push count $d$ needs to be incremented by $1$, and the new state is added to the end of the queue $q$. If the box is not pushed, the push count $d$ remains unchanged, and the new state is added to the head of the queue $q$.\n\nFinally, if no valid push scheme is found, then return $-1$.\nThe time complexity is $O(m^2 \\times n^2)$, and the space complexity is $O(m^2 \\times n^2)$. Where $m$ and $n$ are the number of rows and columns in the grid, respectively. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 2D 0-indexed array of strings, access_times, with size n. For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of an employee, and access_times[i][1] represents the access time of that employee. All entries in access_times are within the same day.\nThe access time is represented as four digits using a 24-hour time format, for example, \"0800\" or \"2250\".\nAn employee is said to be high-access if he has accessed the system three or more times within a one-hour period.\nTimes with exactly one hour of difference are not considered part of the same one-hour period. For example, \"0815\" and \"0915\" are not part of the same one-hour period.\nAccess times at the start and end of the day are not counted within the same one-hour period. For example, \"0005\" and \"2350\" are not part of the same one-hour period.\nReturn a list that contains the names of high-access employees with any order you want.\n\u00a0\nExample 1:\n\nInput: access_times = [[\"a\",\"0549\"],[\"b\",\"0457\"],[\"a\",\"0532\"],[\"a\",\"0621\"],[\"b\",\"0540\"]]\nOutput: [\"a\"]\nExplanation: \"a\" has three access times in the one-hour period of [05:32, 06:31] which are 05:32, 05:49, and 06:21.\nBut \"b\" does not have more than two access times at all.\nSo the answer is [\"a\"].\nExample 2:\n\nInput: access_times = [[\"d\",\"0002\"],[\"c\",\"0808\"],[\"c\",\"0829\"],[\"e\",\"0215\"],[\"d\",\"1508\"],[\"d\",\"1444\"],[\"d\",\"1410\"],[\"c\",\"0809\"]]\nOutput: [\"c\",\"d\"]\nExplanation: \"c\" has three access times in the one-hour period of [08:08, 09:07] which are 08:08, 08:09, and 08:29.\n\"d\" has also three access times in the one-hour period of [14:10, 15:09] which are 14:10, 14:44, and 15:08.\nHowever, \"e\" has just one access time, so it can not be in the answer and the final answer is [\"c\",\"d\"].\nExample 3:\n\nInput: access_times = [[\"cd\",\"1025\"],[\"ab\",\"1025\"],[\"cd\",\"1046\"],[\"cd\",\"1055\"],[\"ab\",\"1124\"],[\"ab\",\"1120\"]]\nOutput: [\"ab\",\"cd\"]\nExplanation: \"ab\" has three access times in the one-hour period of [10:25, 11:24] which are 10:25, 11:20, and 11:24.\n\"cd\" has also three access times in the one-hour period of [10:25, 11:24] which are 10:25, 10:46, and 10:55.\nSo the answer is [\"ab\",\"cd\"].\n\u00a0\nConstraints:\n\n1 <= access_times.length <= 100\naccess_times[i].length == 2\n1 <= access_times[i][0].length <= 10\naccess_times[i][0] consists only of English small letters.\naccess_times[i][1].length == 4\naccess_times[i][1] is in 24-hour time format.\naccess_times[i][1] consists only of '0' to '9'. Explanation:\n\nSolution 1: Hash Table + Sorting\nWe use a hash table $d$ to store all access times of each employee, where the key is the employee's name, and the value is an integer array, representing all access times of the employee, which are the number of minutes from the start of the day at 00:00.\nFor each employee, we sort all their access times in ascending order. Then we traverse all access times of the employee. If there are three consecutive access times $t_1, t_2, t_3$ that satisfy $t_3 - t_1 < 60$, then the employee is a high-frequency visitor, and we add their name to the answer array.\nFinally, we return the answer array.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the number of access records. \n\nSimilar Problem 3 \n\n Problem:\n\nTable: Sessions\n\n+---------------+----------+\n| Column Name   | Type     |\n+---------------+----------+\n| user_id       | int      |\n| session_start | datetime |\n| session_end   | datetime |\n| session_id    | int      |\n| session_type  | enum     |\n+---------------+----------+\nsession_id is column of unique values for this table.\nsession_type is an ENUM (category) type of (Viewer, Streamer).\nThis table contains user id, session start, session end, session id and session type.\n\nWrite a solution to find the the users who have had at least one consecutive session of the same type (either 'Viewer' or 'Streamer') with a maximum gap of 12 hours between sessions.\nReturn the result table ordered by user_id in ascending order.\nThe result format is in the following example.\n\u00a0\nExample:\n\nInput: \nSessions table:\n+---------+---------------------+---------------------+------------+--------------+\n| user_id | session_start       | session_end         | session_id | session_type | \n+---------+---------------------+---------------------+------------+--------------+\n| 101     | 2023-11-01 08:00:00 | 2023-11-01 09:00:00 | 1          | Viewer       |  \n| 101     | 2023-11-01 10:00:00 | 2023-11-01 11:00:00 | 2          | Streamer     |   \n| 102     | 2023-11-01 13:00:00 | 2023-11-01 14:00:00 | 3          | Viewer       | \n| 102     | 2023-11-01 15:00:00 | 2023-11-01 16:00:00 | 4          | Viewer       | \n| 101     | 2023-11-02 09:00:00 | 2023-11-02 10:00:00 | 5          | Viewer       | \n| 102     | 2023-11-02 12:00:00 | 2023-11-02 13:00:00 | 6          | Streamer     | \n| 101     | 2023-11-02 13:00:00 | 2023-11-02 14:00:00 | 7          | Streamer     | \n| 102     | 2023-11-02 16:00:00 | 2023-11-02 17:00:00 | 8          | Viewer       | \n| 103     | 2023-11-01 08:00:00 | 2023-11-01 09:00:00 | 9          | Viewer       | \n| 103     | 2023-11-02 20:00:00 | 2023-11-02 23:00:00 | 10         | Viewer       | \n| 103     | 2023-11-03 09:00:00 | 2023-11-03 10:00:00 | 11         | Viewer       | \n+---------+---------------------+---------------------+------------+--------------+\nOutput: \n+---------+\n| user_id |\n+---------+\n| 102     |\n| 103     |\n+---------+\nExplanation:\n- User ID 101 will not be included in the final output as they do not have any consecutive sessions of the same session type.\n- User ID 102 will be included in the final output as they had two viewer sessions with session IDs 3 and 4, respectively, and the time gap between them was less than 12 hours.\n- User ID 103 participated in two viewer sessions with a gap of less than 12 hours between them, identified by session IDs 10 and 11. Therefore, user 103 will be included in the final output.\nOutput table is ordered by user_id in increasing order. Explanation:\n\nSolution 1: Window Function + Time Function\nFirst, we use the LAG window function to find the end time of the previous session of the same type for each user, denoted as prev_session_end. Then we use the TIMESTAMPDIFF function to calculate the time difference between the start time of the current session and the end time of the previous session. If the time difference is less than or equal to 12 hours, then this user meets the requirements of the problem.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nWITH\n    T AS (\n        SELECT\n            user_id,\n            session_start,\n            LAG(session_end) OVER (\n                PARTITION BY user_id, session_type\n                ORDER BY session_end\n            ) AS prev_session_end\n        FROM Sessions\n    )\nSELECT DISTINCT\n    user_id\nFROM T\nWHERE TIMESTAMPDIFF(HOUR, prev_session_end, session_start) <= 12;\n``` \n\n", "problem_ids": ["minimum-moves-to-move-a-box-to-their-target-location", "high-access-employees", "user-activities-within-time-bounds"]}, "3331": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer n. Consider an equilateral triangle of side length n, broken up into n2 unit equilateral triangles. The triangle has n 1-indexed rows where the ith row has 2i - 1 unit equilateral triangles.\nThe triangles in the ith row are also 1-indexed with coordinates from (i, 1) to (i, 2i - 1). The following image shows a triangle of side length 4 with the indexing of its triangle.\n\nTwo triangles are neighbors if they share a side. For example:\n\nTriangles (1,1) and (2,2) are neighbors\nTriangles (3,2) and (3,3) are neighbors.\nTriangles (2,2) and (3,3) are not neighbors because they do not share any side.\n\nInitially, all the unit triangles are white. You want to choose k triangles and color them red. We will then run the following algorithm:\n\nChoose a white triangle that has at least two red neighbors.\n\n    \nIf there is no such triangle, stop the algorithm.\n\n\nColor that triangle red.\nGo to step 1.\n\nChoose the minimum k possible and set k triangles red before running this algorithm such that after the algorithm stops, all unit triangles are colored red.\nReturn a 2D list of the coordinates of the triangles that you will color red initially. The answer has to be of the smallest size possible. If there are multiple valid solutions, return any.\n\u00a0\nExample 1:\n\n\nInput: n = 3\nOutput: [[1,1],[2,1],[2,3],[3,1],[3,5]]\nExplanation: Initially, we choose the shown 5 triangles to be red. Then, we run the algorithm:\n- Choose (2,2) that has three red neighbors and color it red.\n- Choose (3,2) that has two red neighbors and color it red.\n- Choose (3,4) that has three red neighbors and color it red.\n- Choose (3,3) that has three red neighbors and color it red.\nIt can be shown that choosing any 4 triangles and running the algorithm will not make all triangles red.\n\nExample 2:\n\n\nInput: n = 2\nOutput: [[1,1],[2,1],[2,3]]\nExplanation: Initially, we choose the shown 3 triangles to be red. Then, we run the algorithm:\n- Choose (2,2) that has three red neighbors and color it red.\nIt can be shown that choosing any 2 triangles and running the algorithm will not make all triangles red.\n\n\u00a0\nConstraints:\n\n1 <= n <= 1000 Explanation:\n\nSolution 1: Find the Pattern\nWe draw a graph to observe, and we can find that the first row only has one triangle and must be colored, and from the last row to the second row, the coloring scheme of every four rows is the same:\n\nThe last row is colored at $(n, 1)$, $(n, 3)$, ..., $(n, 2n - 1)$.\nThe $n - 1$ row is colored at $(n - 1, 2)$.\nThe $n - 2$ row is colored at $(n - 2, 3)$, $(n - 2, 5)$, ..., $(n - 2, 2n - 5)$.\nThe $n - 3$ row is colored at $(n - 3, 1)$.\n\n\nTherefore, we can color the first row according to the above rules, and then start from the last row, and color every four rows once until the second row ends.\n\nThe time complexity is $(n^2)$, where $n$ is the parameter given in the problem. Ignoring the space consumption of the answer array, the space complexity is $O(1)$. \n\nSimilar Problem 2 \n\n Problem:\n\nYou are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\nReturn the minimum possible difference.\n\u00a0\nExample 1:\n\nInput: nums = [90], k = 1\nOutput: 0\nExplanation: There is one way to pick score(s) of one student:\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\n\nExample 2:\n\nInput: nums = [9,4,1,7], k = 2\nOutput: 2\nExplanation: There are six ways to pick score(s) of two students:\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 1000\n0 <= nums[i] <= 105 Explanation:\n\nSolution 1: Sorting + Sliding Window\nWe can sort the students' scores in ascending order, then use a sliding window of size $k$ to calculate the difference between the maximum and minimum values in the window, and finally take the minimum of the differences of all windows.\nWhy do we take the scores of $k$ consecutive students? Because if they are not consecutive, the difference between the maximum and minimum values may remain the same or increase, but it will definitely not decrease. Therefore, we only need to consider the scores of $k$ consecutive students after sorting.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the number of students. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest.\n\u00a0\nExample 1:\n\n\nInput: root = [4,2,5,1,3], target = 3.714286\nOutput: 4\n\nExample 2:\n\nInput: root = [1], target = 4.428571\nOutput: 1\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 104].\n0 <= Node.val <= 109\n-109 <= target <= 109 Explanation:\n\nSolution 1: Recursion\nWe define a recursive function dfs(node), which starts from the current node node and finds the node closest to the target value target. We can update the answer by comparing the absolute difference between the current node's value and the target value. If the target value is less than the current node's value, we recursively search the left subtree; otherwise, we recursively search the right subtree.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the binary search tree. \n\n", "problem_ids": ["color-the-triangle-red", "minimum-difference-between-highest-and-lowest-of-k-scores", "closest-binary-search-tree-value"]}, "3347": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: Logs\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nIn SQL, id is the primary key for this table.\nid is an autoincrement column.\n\n\u00a0\nFind all numbers that appear at least three times consecutively.\nReturn the result table in any order.\nThe\u00a0result format is in the following example.\n\u00a0\nExample 1:\n\nInput: \nLogs table:\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\nOutput: \n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\nExplanation: 1 is the only number that appears consecutively for at least three times. Explanation:\n\nSolution 1: Two Joins\nWe can use two joins to solve this problem.\nFirst, we perform a self-join with the condition l1.num = l2.num and l1.id = l2.id - 1, so that we can find all numbers that appear at least twice in a row. Then, we perform another self-join with the condition l2.num = l3.num and l2.id = l3.id - 1, so that we can find all numbers that appear at least three times in a row. Finally, we only need to select the distinct l2.num. \n\nSimilar Problem 2 \n\n Problem:\n\nAccording to\u00a0Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.\n\u00a0\nExample 1:\n\n\nInput: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n\nExample 2:\n\n\nInput: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]\n\n\u00a0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 25\nboard[i][j] is 0 or 1.\n\n\u00a0\nFollow up:\n\nCould you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems? Explanation:\n\nSolution 1: In-place marking\nLet's define two new states. State $2$ indicates that the living cell becomes dead in the next state, and state $-1$ indicates that the dead cell becomes alive in the next state. Therefore, for the current grid we are traversing, if the grid is greater than $0$, it means that the current grid is a living cell, otherwise it is a dead cell.\nSo we can traverse the entire board, for each grid, count the number of living neighbors around the grid, and use the variable $live$ to represent it. If the current grid is a living cell, then when $live \\lt 2$ or $live \\gt 3$, the next state of the current grid is a dead cell, that is, state $2$; if the current grid is a dead cell, then when $live = 3$, the next state of the current grid is an active cell, that is, state $-1$.\nFinally, we traverse the board again, and update the grid with state $2$ to a dead cell, and update the grid with state $-1$ to an active cell.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the board, respectively. We need to traverse the entire board. And the space complexity is $O(1)$. \n\nSimilar Problem 3 \n\n Problem:\n\nGiven an integer array nums sorted in non-decreasing order and an integer k, return true if this array can be divided into one or more disjoint increasing subsequences of length at least k, or false otherwise.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,2,3,3,4,4], k = 3\nOutput: true\nExplanation: The array can be divided into two subsequences [1,2,3,4] and [2,3,4] with lengths at least 3 each.\n\nExample 2:\n\nInput: nums = [5,6,6,7,8], k = 3\nOutput: false\nExplanation: There is no way to divide the array using the conditions required.\n\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 105\n1 <= nums[i] <= 105\nnums is sorted in non-decreasing order. Explanation:\n\nSolution 1: Quick Thinking\nWe assume that the array can be divided into $m$ strictly increasing subsequences of length at least $k$. If the number of the most frequent number in the array is $cnt$, then these $cnt$ numbers must be in different subsequences, so $m \\geq cnt$. Also, since the length of $m$ subsequences is at least $k$, the fewer the number of subsequences, the better, so $m = cnt$. Therefore, $cnt \\times k \\leq n$ must be satisfied. Hence, we only need to count the number of the most frequent number $cnt$ in the array, and then judge whether $cnt \\times k \\leq n$. If it is, return true, otherwise return false.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["consecutive-numbers", "game-of-life", "divide-array-into-increasing-sequences"]}, "abc301_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a weighted undirected graph \\( G \\) with \\( N \\) vertices, numbered from 1 to \\( N \\). Initially, the graph \\( G \\) has no edges.\n\nYou will perform \\( M \\) operations to add edges to the graph \\( G \\). The \\( i \\)-th operation \\((1 \\leq i \\leq M)\\) is as follows:\n\n- You are given a subset of vertices \\( S_i = \\{ A_{i,1}, A_{i,2}, \\dots, A_{i,K_i} \\} \\) consisting of \\( K_i \\) vertices.\n- For every pair of vertices \\( u, v \\) such that \\( u, v \\in S_i \\) and \\( u < v \\), add an edge between vertices \\( u \\) and \\( v \\) with weight \\( C_i \\).\n\nAfter performing all \\( M \\) operations, determine whether the graph \\( G \\) is connected. If it is connected, find the total weight of the edges in a minimum spanning tree of \\( G \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq K_i \\leq N \\)\n- \\( \\sum_{i=1}^{M} K_i \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq A_{i,1} < A_{i,2} < \\dots < A_{i,K_i} \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nK_1 C_1\nA_{1,1} A_{1,2} \\dots A_{1,K_1}\nK_2 C_2\nA_{2,1} A_{2,2} \\dots A_{2,K_2}\n...\nK_M C_M\nA_{M,1} A_{M,2} \\dots A_{M,K_M}\n```\n\n**Output Format**\n\nIf the graph \\( G \\) is not connected after all \\( M \\) operations, print `-1`. If \\( G \\) is connected, print the total weight of the edges in a minimum spanning tree of \\( G \\).\n\nSolution:\n\n\n[BEGIN TEXT]\nOne of the algorithms to find the spanning tree is Kruskal\u2019s algorithm. Starting from a state where no edge is added to the graph, inspect the edges in ascending order of weight. If the edge currently being inspected between vertices \\(u\\) and \\(v\\) is not connected yet, add it to the graph. By managing the connectivity of the graph using a data structure like Disjoint Set Union (DSU), the algorithm runs in a total of \\(O(E\\log E)\\) time, where sorting is the bottleneck. (\\(E\\) is the number of edges.)\n\nIn this problem, there are at most \\(O((\\sum K)^2)\\) edges, making it infeasible to apply the algorithm directly within the time limit. Instead, we use the following property about the minimum spanning tree: if there is an edge \\(e=(u,v)\\) that satisfies the condition where there exists a path connecting vertex \\(u\\) and vertex \\(v\\) consisting of edges with weights not greater than that of edge \\(e\\), but not containing edge \\(e\\), removing edge \\(e\\) from the candidates does not change the total weight of the minimum spanning tree.\n\nThis is due to the behavior of Kruskal's algorithm. On edge \\(e\\)\u2019s turn, \\(u\\) and \\(v\\) are already connected, so edge \\(e\\) is never used. In this problem, the edges added are: an edge of weight \\(C_i\\) connecting vertices \\(u\\) and \\(v\\) for all pairs of different vertices contained in \\(\\lbrace A_{i,1},A_{i,2},\\dots,A_{i,K_i}\\rbrace\\).\n\nBy the property above, we find it sufficient to add only the following edges: an edge of weight \\(C_i\\) connecting vertices \\(A_{i,1}\\) and \\(A_{i,j}\\) for each \\(j=2,3,\\dots,K_i\\). This modification reduces the total number of edges to \\(O(\\sum K)\\), making it feasible to apply Kruskal\u2019s algorithm to solve the problem.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 650 points\n\nProblem Statement:\nThere is a special grid with \\( N \\) rows. (\\( N \\) is even.) The \\( i \\)-th row from the top has \\(\\left \\lceil \\frac{i}{2} \\right \\rceil \\times 2\\) cells from the left end. For example, when \\( N = 6 \\), the grid looks like the following:\n\nLet \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Each cell is either an empty cell or a wall cell. There are \\( M \\) wall cells, and the \\( i \\)-th wall cell is \\((a_i, b_i)\\). Here, \\((1, 1)\\) and \\((N, N)\\) are empty.\n\nStarting from \\((1, 1)\\), how many ways are there to reach \\((N, N)\\) by repeatedly moving right or down to an adjacent empty cell? Find the count modulo 998244353.\n\nConstraints:\n- \\( 2 \\leq N \\leq 2.5 \\times 10^5 \\)\n- \\( N \\) is even.\n- \\( 0 \\leq M \\leq 50 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- \\( 1 \\leq b_i \\leq \\left \\lceil \\frac{a_i}{2} \\right \\rceil \\times 2 \\)\n- \\((a_i, b_i) \\neq (1, 1)\\) and \\((a_i, b_i) \\neq (N, N)\\).\n- \\((a_i, b_i) \\neq (a_j, b_j)\\) if \\( i \\neq j \\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\na_1 b_1\na_2 b_2\n...\na_M b_M\n```\n\nOutput:\nPrint the number of ways to reach \\((N, N)\\) from \\((1, 1)\\) by repeatedly moving right or down to an adjacent empty cell, modulo 998244353.\n\nSample Input 1:\n```\n4 2\n2 1\n4 2\n```\nSample Output 1:\n```\n2\n```\nThere are two paths that satisfy the conditions of the problem:\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (3, 4) \\to (4, 4)\\)\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (4, 3) \\to (4, 4)\\)\n\nSample Input 2:\n```\n6 3\n2 1\n3 3\n4 2\n```\nSample Output 2:\n```\n0\n```\n\nSample Input 3:\n```\n100 10\n36 9\n38 5\n38 30\n45 1\n48 40\n71 52\n85 27\n86 52\n92 34\n98 37\n```\nSample Output 3:\n```\n619611437\n```\n\nSample Input 4:\n```\n100000 10\n552 24\n4817 255\n7800 954\n23347 9307\n28028 17652\n39207 11859\n48670 22013\n74678 53158\n75345 45891\n88455 4693\n```\nSample Output 4:\n```\n175892766\n```\n\nSolution:\n\nSure, here is the editorial with all code translated to Python3:\n\n```python\ndef g(a, b):\n    \"\"\"Calculate the number of shortest paths from a to b.\"\"\"\n    # This function implementation depends on the specific grid configuration\n    pass\n\ndef calculate_dp_and_x(wall_squares, grid_size):\n    \"\"\"Calculate dp values and the sought count X using the wall squares.\"\"\"\n    S = wall_squares\n    N, M = grid_size\n    \n    # Initialize dp with base values\n    w = [(1, 1)] + S + [(N, N)]\n    dp = [0] * (len(S) + 2)\n    dp[0] = 1\n    \n    # Fill dp array according to the derived relations\n    for i in range(1, len(S) + 2):\n        dp_i_sum = sum(g(w[j], w[i]) * dp[j] for j in range(i))\n        dp[i] = -dp_i_sum\n    \n    # Calculate the sought count X\n    X = -dp[len(S) + 1]\n    \n    return X\n\n# Example usage\noriginal_wall_squares = []  # Replace with actual coordinates of original wall squares\ncalculate_dp_and_x(original_wall_squares, (N, M))\n```\n\nNote: In the provided code, `g(a, b)` is a placeholder function that needs actual implementation based on the specific problem constraints. The function `calculate_dp_and_x` calculates the dp values and the sought count `X` using the dynamic programming approach described in the editorial.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nGiven integers \\(N\\) and \\(M\\), compute the sum \\(\\sum_{k=0}^{N} \\text{popcount}(k \\& M)\\), modulo \\(998244353\\).\n\nHere, \\(\\&\\) represents the bitwise AND operation.\n\n**What is the bitwise AND operation?**\n\nThe result \\(x = a \\& b\\) of the bitwise AND operation between non-negative integers \\(a\\) and \\(b\\) is defined as follows:\n\n- \\(x\\) is the unique non-negative integer that satisfies the following conditions for all non-negative integers \\(k\\):\n  - If the \\(2^k\\) place in the binary representation of \\(a\\) and \\(b\\) are both \\(1\\), then the \\(2^k\\) place in the binary representation of \\(x\\) is \\(1\\).\n  - Otherwise, the \\(2^k\\) place in the binary representation of \\(x\\) is \\(0\\).\n\nFor example, \\(3=11_{(2)}\\) and \\(5=101_{(2)}\\), so \\(3 \\& 5 = 1\\).\n\n**What is popcount?**\n\n\\(\\text{popcount}(x)\\) represents the number of \\(1\\)s in the binary representation of \\(x\\).\n\nFor example, \\(13=1101_{(2)}\\), so \\(\\text{popcount}(13) = 3\\).\n\n**Constraints:**\n\n- \\(N\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n- \\(M\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\n```\n\n**Output:**\n\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 3\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n- \\(\\text{popcount}(0 \\& 3) = 0\\)\n- \\(\\text{popcount}(1 \\& 3) = 1\\)\n- \\(\\text{popcount}(2 \\& 3) = 1\\)\n- \\(\\text{popcount}(3 \\& 3) = 2\\)\n- \\(\\text{popcount}(4 \\& 3) = 0\\)\n\nThe sum of these values is \\(4\\).\n\n**Sample Input 2:**\n```\n0 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\nIt is possible that \\(N = 0\\) or \\(M = 0\\).\n\n**Sample Input 3:**\n```\n1152921504606846975 1152921504606846975\n```\n\n**Sample Output 3:**\n```\n499791890\n```\n\nRemember to compute the result modulo \\(998244353\\).\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial presents the solution to a problem from AtCoder Beginner Contest 356, specifically the \"D - Masked Popcount\" problem. The goal is to compute the sum of set bits in the result of bitwise AND operations between each integer from 0 to N and a given integer M with the following steps:\n\n1. Iterate over each bit position \\( j \\) from 0 to 59.\n2. If the \\( j \\)-th bit of \\( M \\) is set, for each \\( j \\), add to the result the count of integers between 0 and N whose \\( j \\)-th bit is set.\n3. The number of integers with the \\( j \\)-th bit set is calculated by examining ranges defined by powers of two.\n4. During computation, handle overflow by taking results modulo 998244353.\n\nThe solution involves efficiently counting set bits using bit operations and properties of numbers, ensuring accurate summing even under large values.\n[END TEXT]\n \n\n", "problem_ids": ["abc352_e", "abc357_g", "abc356_d"]}, "abc301_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 700 points\n\nProblem Statement:  \nYou are given a positive integer \\( N \\). There is an empty set \\( S \\), and you can perform the following operation any number of times:  \n- Choose any positive integer \\( x \\). For each of \\( x \\), \\( 2x \\), and \\( 3x \\), add it to \\( S \\) if it is not already in \\( S \\).\n\nFind the minimum number of operations required to satisfy \\( \\{1, 2, \\dots, N\\} \\subseteq S \\).\n\nConstraints:  \n- \\( 1 \\leq N \\leq 10^9 \\)\n\nInput:  \nThe input is given from Standard Input in the following format:  \n\\( N \\)\n\nOutput:  \nPrint the answer in one line.\n\nSample Input 1:  \n```\n7\n```\n\nSample Output 1:  \n```\n4\n```\n\nExplanation:  \nChoosing \\( 1, 2, 5, \\) and \\( 7 \\) yields \\( S = \\{1, 2, 3, 4, 5, 6, 7, 10, 14, 15, 21\\} \\), which satisfies the condition. It is impossible to satisfy the condition with three or fewer operations.\n\nSample Input 2:  \n```\n25\n```\n\nSample Output 2:  \n```\n14\n```\n\nSolution:\n\n        Editorial - AtCoder Regular Contest 184\n\nProblem B - 123 Set\n\nFirst, divide the problem into sub-problems for each multiset of prime factors other than \\(2\\) and \\(3\\). For each non-negative integer \\(u \\leq N\\) that is neither a multiple of \\(2\\) nor \\(3\\), consider the following:\n\nLet \\(T(u)\\) be the set of integers not greater than \\(\\frac{N}{u}\\) that can be expressed as \\(2^a 3^b\\) using non-negative integers \\(a\\) and \\(b\\). Find the minimum number of operations required so that \\(T(u) \\subseteq S\\) is satisfied.\n\nBy summing up the answers for all \\(u\\), we find the solution to the original problem. Consider the \\(ab\\) plane, associating \\(2^a 3^b\\) with the point \\((a, b)\\). An operation corresponds to selecting \\((x, y)\\) and adding the integers at \\((x, y), (x + 1, y), (x, y + 1)\\) to \\(S\\).\n\nDefine a bit DP:\n\n\\(\\mathrm{dp}[i][s]\\) is the minimum number of operations for all points with \\(a < i\\) added to \\(S\\), and for points with \\(a = i\\), the integers in \\(S\\) correspond to \\(s\\).\n\nThis DP uses fast zeta transform and transitions with time \\(\\displaystyle O\\left(\\left(\\frac{N}{u}\\right)^{0.64} \\log^2 \\frac{N}{u}\\right)\\).\n\nThe number of different choices of \\(u\\) ensuring distinct \\(T(u)\\) is approximately \\((1 + \\log_2 N)(1 + \\log_3 N)\\), and the DP is fast for large \\(u\\). The intended C++ solution runs in about 700 ms. Slower languages can still achieve acceptance with optimized DP implementations.\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 150 points\n\nProblem Statement:\nThere are \\(2N\\) people standing in a row, and the person at the \\(i\\)-th position from the left is wearing clothes of color \\(A_i\\). The clothes have \\(N\\) colors from \\(1\\) to \\(N\\), and exactly two people are wearing clothes of each color.\n\nFind how many of the integers \\(i=1,2,\\ldots,N\\) satisfy the following condition:\n- There is exactly one person between the two people wearing clothes of color \\(i\\).\n\nConstraints:\n- \\(2 \\leq N \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- Each integer from \\(1\\) through \\(N\\) appears exactly twice in \\(A\\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{2N}\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n3\n1 2 1 3 2 3\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation:\nThere are two values of \\(i\\) that satisfy the condition: \\(1\\) and \\(3\\).\nIn fact, the people wearing clothes of color \\(1\\) are at the 1st and 3rd positions from the left, with exactly one person in between.\n\nSample Input 2:\n```\n2\n1 1 2 2\n```\n\nSample Output 2:\n```\n0\n```\n\nExplanation:\nThere may be no \\(i\\) that satisfies the condition.\n\nSample Input 3:\n```\n4\n4 3 2 3 2 1 4 1\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nB - Couples Editorial by en_translator\n\nBy mathematically interpreting the problem statement, it turns out that it is asking to count \\(i\\) such that \\(A_i=A_{i+2}\\). Use for and if statements to check if each \\(i\\) satisfies the condition. Sample code (Python3):\n\n```python\nn = int(input())\na = [int(input()) for _ in range(n * 2)]\nres = 0\nfor i in range(n * 2 - 2):\n    if a[i] == a[i + 2]:\n        res += 1\nprint(res)\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 500 points\n\nProblem Statement\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- You are given a positive integer \\( N \\).\n- The judge has a hidden positive integer \\( R \\) and \\( N \\) integers \\( A_1, A_2, \\ldots, A_N \\). It is guaranteed that \\(|A_i| \\le R\\) and \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\).\n- There is a blackboard on which you can write integers with absolute values not exceeding \\( R \\). Initially, the blackboard is empty.\n- The judge has written the values \\( A_1, A_2, \\ldots, A_N \\) on the blackboard in this order. Your task is to make the blackboard contain only one value \\(\\sum_{i=1}^{N} A_i\\).\n- You cannot learn the values of \\( R \\) and \\( A_i \\) directly, but you can interact with the judge up to 25000 times.\n\nFor a positive integer \\( i \\), let \\( X_i \\) be the \\( i \\)-th integer written on the blackboard. Specifically, \\( X_i = A_i \\) for \\( i = 1, 2, \\ldots, N \\).\n\nIn one interaction, you can specify two distinct positive integers \\( i \\) and \\( j \\) and choose one of the following actions:\n\n1. Perform addition. The judge will erase \\( X_i \\) and \\( X_j \\) from the blackboard and write \\( X_i + X_j \\) on the blackboard.\n   - \\(|X_i + X_j| \\leq R\\) must hold.\n\n2. Perform comparison. The judge will tell you whether \\( X_i < X_j \\) is true or false.\n\nNote: At the beginning of each interaction, the \\( i \\)-th and \\( j \\)-th integers written on the blackboard must not have been erased.\n\nPerform the interactions appropriately so that after all interactions, the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\nThe values of \\( R \\) and \\( A_i \\) are determined before the start of the conversation between your program and the judge.\n\nConstraints:\n- \\( 2 \\leq N \\leq 1000 \\)\n- \\( 1 \\leq R \\leq 10^9 \\)\n- \\(|A_i| \\leq R\\)\n- \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\)\n- \\( N, R, \\) and \\( A_i \\) are integers.\n\nInput and Output\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- First, read \\( N \\) from Standard Input.\n\n  ```\n  N\n  ```\n\n- Next, repeat the interactions until the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\n- When performing addition, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  + i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  P\n  ```\n\n  Here, \\( P \\) is an integer:\n\n  - If \\( P \\geq N + 1 \\), it means that the value \\( X_i + X_j \\) has been written on the blackboard, and it is the \\( P \\)-th integer written.\n  - If \\( P = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\n- When performing comparison, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  ? i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  Q\n  ```\n\n  Here, \\( Q \\) is an integer:\n\n  - If \\( Q = 1 \\), it means that \\( X_i < X_j \\) is true.\n  - If \\( Q = 0 \\), it means that \\( X_i < X_j \\) is false.\n  - If \\( Q = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\nFor both types of interactions, if the judge's response is -1, your program is already considered incorrect. In this case, terminate your program immediately.\n\nWhen the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), report this to the judge in the following format. This does not count towards the number of interactions. Then, terminate your program immediately.\n\n  ```\n  !\n  ```\n\nIf you make an output in a format that does not match any of the above, -1 will be given from Standard Input.\n\n  ```\n  -1\n  ```\n\nIn this case, your program is already considered incorrect. Terminate your program immediately.\n\nNotes\n\n- For each output, append a newline at the end and flush Standard Output. Otherwise, the verdict may be TLE.\n- Terminate your program immediately after outputting the result (or receiving -1). Otherwise, the verdict will be indeterminate.\n- Extra newlines will be considered as malformed output.\n\nSample Input and Output\n\nHere is a possible conversation with \\( N=3, R=10, A_1=-1, A_2=10, A_3=1 \\).\n\n**Input:**\n```\n3\n```\n\n**Output:**\n```\n? 1 2\n1\n+ 1 3\n4\n+ 2 4\n5\n!\n```\n\n**Explanation:**\n\n1. First, the integer \\( N \\) is given.\n2. Perform a comparison between \\( X_1 \\) and \\( X_2 \\). The judge returns 1 because \\( X_1 < X_2 \\) (-1 < 10).\n3. Perform an addition of \\( X_1 \\) and \\( X_3 \\). The judge erases \\( X_1 = -1 \\) and \\( X_3 = 1 \\) from the blackboard and writes \\( X_1 + X_3 = 0 \\). This is the fourth integer written.\n4. Perform an addition of \\( X_2 \\) and \\( X_4 \\). The judge erases \\( X_2 = 10 \\) and \\( X_4 = 0 \\) from the blackboard and writes \\( X_2 + X_4 = 10 \\). This is the fifth integer written.\n5. The blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), so report this to the judge.\n\nSolution:\n\nBelow is the editorial as provided, since there's no code to translate to Python3:\n\n```\nAtCoder Regular Contest 179 - C: Beware of Overflow Editorial\n\nTo have only one integer on the blackboard, we need to perform exactly \\(N-1\\) additions. When there are two or more integers left on the blackboard, we should add the maximum and minimum values. The absolute value of their sum does not exceed \\(R\\). Let \\(X\\) be the multiset of integers on the blackboard, with maximum \\(M\\) and minimum \\(m\\). The absolute value of every element in \\(X\\) is at most \\(R\\), and \\(\\displaystyle\\left|\\sum_{x\\in X}x\\right|\\leq R\\).\n\n1. If \\(m \\geq 0\\), all integers are non-negative: \\(0 \\leq m + M \\leq R\\), so \\(|m + M| \\leq R\\).\n2. If \\(M \\leq 0\\), all integers are non-positive: \\(0 \\geq m + M \\geq -R\\), so \\(|m + M| \\leq R\\).\n3. If \\(m \\leq 0\\) and \\(M \\geq 0\\), \\(-R \\leq m \\leq m + M \\leq M \\leq R\\), so \\(|m + M| \\leq R\\).\n\nWe should add the maximum and minimum values. Use merge sort to arrange values in ascending order. Perform addition interactions to add the minimum and maximum values. Remove the first and last elements and insert the sum. Binary search determines the insertion position.\n\nEstimate interactions: Merge sort on a list of length \\(2^n\\) requires at most \\(a_n = n2^n\\) comparisons. Under \\(N \\leq 1000 \\leq 2^{10}\\), at most 10240 comparisons are needed. Finding insertion positions requires at most \\(10 \\times (N-1) \\leq 9990\\) comparisons. In total, at most 20230 comparisons plus \\(N-1 \\leq 999\\) additions remain well within the limit of 25000 interactions.\n```\n \n\n", "problem_ids": ["arc184_b", "abc359_b", "arc179_c"]}, "abc301_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a bottle of disinfectant that can disinfect exactly \\( M \\) hands. \\( N \\) aliens come one by one to disinfect their hands. The \\( i \\)-th alien (\\( 1 \\leq i \\leq N \\)) has \\( H_i \\) hands and wants to disinfect all of their hands once. Determine how many aliens can disinfect all of their hands. Here, even if there is not enough disinfectant left for an alien to disinfect all of their hands when they start, they will use up the remaining disinfectant.\n\n**Constraints**\n\n- \\( 1 \\leq N, M \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the number of aliens who can disinfect all of their hands.\n\n**Sample Input 1**\n\n```\n5 10\n2 3 2 5 3\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\n*Explanation:*\n\n1. The first alien disinfects their two hands. The remaining disinfectant can disinfect \\( 10-2=8 \\) hands.\n2. The second alien disinfects their three hands. The remaining disinfectant can disinfect \\( 8-3=5 \\) hands.\n3. The third alien disinfects their two hands. The remaining disinfectant can disinfect \\( 5-2=3 \\) hands.\n4. The fourth alien has five hands, but there is only enough disinfectant for three hands, so they use up the disinfectant without disinfecting all of their hands.\n\nThus, the first three aliens can disinfect all of their hands, so print 3.\n\n**Sample Input 2**\n\n```\n5 10\n2 3 2 3 5\n```\n\n**Sample Output 2**\n\n```\n4\n```\n\n**Sample Input 3**\n\n```\n1 5\n1\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\nAll aliens can disinfect their hands.\n\nSolution:\n\n[BEGIN TEXT]\nHere is the simplified version of the editorial:\n\nThe problem can be solved by simulating the remaining amount of disinfectant. Start from \\(M\\) and subtract \\(H_1, H_2, \\ldots, H_N\\) from it in order. If it never goes below \\(0\\), all aliens can disinfect their hands, and the answer is \\(N\\). If it becomes less than \\(0\\) for the first time when subtracting \\(H_i\\), the answer is \\(i-1\\). Ensure to use an appropriate conditional inequality to handle the case when the disinfectant is used up completely.\n\nSample code in Python:\n\n```python\nn, m = map(int, input().split())\nh = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n    m -= h[i]\n    if m >= 0:\n        ans += 1\nprint(ans)\n```\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a simple connected undirected graph with \\( N \\) vertices and \\( M \\) edges. Each vertex \\( i \\,(1 \\leq i \\leq N) \\) has a weight \\( A_i \\). Each edge \\( j \\,(1 \\leq j \\leq M) \\) connects vertices \\( U_j \\) and \\( V_j \\) bidirectionally and has a weight \\( B_j \\).\n\nThe weight of a path in this graph is defined as the sum of the weights of the vertices and edges that appear on the path.\n\nFor each \\( i = 2, 3, \\dots, N \\), solve the following problem:\n- Find the minimum weight of a path from vertex 1 to vertex \\( i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_j < V_j \\leq N \\)\n- \\( (U_i, V_i) \\neq (U_j, V_j) \\) if \\( i \\neq j \\).\n- The graph is connected.\n- \\( 0 \\leq A_i \\leq 10^9 \\)\n- \\( 0 \\leq B_j \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format: \n\n```\nN M\nA_1 A_2 \\dots A_N\nU_1 V_1 B_1\nU_2 V_2 B_2\n\\vdots\nU_M V_M B_M\n```\n\n**Output:**\n\nPrint the answers for \\( i = 2, 3, \\dots, N \\) in a single line, separated by spaces.\n\n**Sample Input 1:**\n\n```\n3 3\n1 2 3\n1 2 1\n1 3 6\n2 3 2\n```\n\n**Sample Output 1:**\n\n```\n4 9\n```\n\n**Explanation:**\n\nConsider the paths from vertex 1 to vertex 2. The weight of the path \\( 1 \\to 2 \\) is \\( A_1 + B_1 + A_2 = 1 + 1 + 2 = 4 \\), and the weight of the path \\( 1 \\to 3 \\to 2 \\) is \\( A_1 + B_2 + A_3 + B_3 + A_2 = 1 + 6 + 3 + 2 + 2 = 14 \\). The minimum weight is 4.\n\nConsider the paths from vertex 1 to vertex 3. The weight of the path \\( 1 \\to 3 \\) is \\( A_1 + B_2 + A_3 = 1 + 6 + 3 = 10 \\), and the weight of the path \\( 1 \\to 2 \\to 3 \\) is \\( A_1 + B_1 + A_2 + B_3 + A_3 = 1 + 1 + 2 + 2 + 3 = 9 \\). The minimum weight is 9.\n\n**Sample Input 2:**\n\n```\n2 1\n0 1\n1 2 3\n```\n\n**Sample Output 2:**\n\n```\n4\n```\n\n**Sample Input 3:**\n\n```\n5 8\n928448202 994752369 906965437 942744902 907560126\n2 5 975090662\n1 2 908843627\n1 5 969061140\n3 4 964249326\n2 3 957690728\n2 4 942986477\n4 5 948404113\n1 3 988716403\n```\n\n**Sample Output 3:**\n\n```\n2832044198 2824130042 4696218483 2805069468\n```\n\nNote that the answers may not fit in a 32-bit integer.\n\nSolution:\n\n```python\n\"\"\"\nEditorial - Toyota Programming Contest 2024#7 (AtCoder Beginner Contest 362)\n\nD - Shortest Path 3 Editorial\n\nThis is an exercise of an algorithm to find the shortest length of a path on a graph. For a graph with non-negative edge weights, the shortest length of a path can be found fast with Dijkstra\u2019s algorithm. In this problem, vertices have weights too, so we cannot directly apply Dijkstra\u2019s algorithm. Instead, we rephrase it into an edge-weighted problem. When traveling from vertex \\(U_i\\) to vertex \\(V_j\\) only via edge \\(j\\), the cost newly imposed is the cost to use edge \\(j\\) and to visit vertex \\(V_j\\), for a total of \\(B_j + A_{V_j}\\). Conversely, when traveling from vertex \\(V_i\\) to vertex \\(U_j\\) only via edge \\(j\\), the cost newly imposed is the cost to use edge \\(j\\) and to visit vertex \\(U_j\\), for a total of \\(B_j + A_{U_j}\\). Thus, by adding an edge of weight \\(B_j + A_{V_j}\\) in the direction of \\(U_j \\to V_j\\) and an edge of weight \\(B_j + A_{U_j}\\) in the direction of \\(V_j \\to U_j\\), every cost can be represented only with edge weights. By applying Dijkstra\u2019s algorithm on this graph and finally adding the weight of the initial point \\(A_1\\), one can find the answer. The time complexity is \\(O(M \\log N)\\).\n\"\"\"\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 600 points\n\nProblem Statement\n\nYou are given a simple undirected graph with \\(N\\) vertices and \\(M\\) edges. The \\(i\\)-th edge connects vertices \\(u_i\\) and \\(v_i\\) bidirectionally.\n\nDetermine if there exists a way to write an integer between \\(1\\) and \\(2^{60} - 1\\), inclusive, on each vertex of this graph so that the following condition is satisfied:\n\n- For every vertex \\(v\\) with a degree of at least \\(1\\), the total XOR of the numbers written on its adjacent vertices (excluding \\(v\\) itself) is \\(0\\).\n\nWhat is XOR?\n\nThe XOR of two non-negative integers \\(A\\) and \\(B\\), denoted as \\(A \\oplus B\\), is defined as follows:\n\n- In the binary representation of \\(A \\oplus B\\), the bit at position \\(2^k \\, (k \\geq 0)\\) is \\(1\\) if and only if exactly one of the bits at position \\(2^k\\) in the binary representations of \\(A\\) and \\(B\\) is \\(1\\). Otherwise, it is \\(0\\).\n\nFor example, \\(3 \\oplus 5 = 6\\) (in binary: \\(011 \\oplus 101 = 110\\)).\n\nIn general, the bitwise XOR of \\(k\\) integers \\(p_1, \\dots, p_k\\) is defined as \\((\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k)\\). It can be proved that this is independent of the order of \\(p_1, \\dots, p_k\\).\n\nConstraints\n- \\(1 \\leq N \\leq 60\\)\n- \\(0 \\leq M \\leq N(N-1)/2\\)\n- \\(1 \\leq u_i < v_i \\leq N\\)\n- \\((u_i, v_i) \\neq (u_j, v_j)\\) for \\(i \\neq j\\).\n- All input values are integers.\n\nInput\n\nThe input is given from Standard Input in the following format:\n```\nN M\nu_1 v_1\nu_2 v_2\n\\vdots\nu_M v_M\n```\n\nOutput\n\nIf there is no way to write integers satisfying the condition, print `No`.\n\nOtherwise, let \\(X_v\\) be the integer written on vertex \\(v\\), and print your solution in the following format. If multiple solutions exist, any of them will be accepted.\n```\nYes\nX_1 X_2 \\dots X_N\n```\n\nSample Input 1\n```\n3 3\n1 2\n1 3\n2 3\n```\n\nSample Output 1\n```\nYes\n4 4 4\n```\nOther acceptable solutions include writing \\((2,2,2)\\) or \\((3,3,3)\\).\n\nSample Input 2\n```\n2 1\n1 2\n```\n\nSample Output 2\n```\nNo\n```\n\nSample Input 3\n```\n1 0\n```\n\nSample Output 3\n```\nYes\n1\n```\nAny integer between \\(1\\) and \\(2^{60} - 1\\) can be written.\n\nSample Input 4\n```\n4 5\n1 2\n1 3\n2 3\n2 4\n3 4\n```\n\nSample Output 4\n```\nYes\n12 4 4 8\n```\n\nSolution:\n\n```python\n# Given: Adjacency matrix A of the graph, dimensions N x N\n# Output: N-dimensional vectors that satisfy Ax = 0 and other conditions\n\n# This function applies Gaussian elimination to find a basis for Ax=0\ndef find_basis(A, N):\n    # Initializing vectors as zero\n    basis = []\n    for row in range(N):\n        if A[row][row] == 0:  # If diagonal is zero, try to find a nonzero pivot\n            for i in range(row + 1, N):\n                if A[i][row] == 1:\n                    A[i], A[row] = A[row], A[i]  # Swap rows\n                    break\n        if A[row][row] == 1:\n            # Eliminate all other 1s in the current column\n            for i in range(N):\n                if i != row and A[i][row] == 1:\n                    A[i] = [A[i][j] ^ A[row][j] for j in range(N)]\n            basis.append(A[row])\n    return basis\n\n# Example usage:\n# Let's assume a sample adjacency matrix A\nA = [\n    [0, 1, 1], \n    [1, 0, 1], \n    [1, 1, 0]\n]\nN = len(A)\n\n# Find basis for Ax=0\nbasis = find_basis(A, N)\n\n# Display basis\nprint(\"Basis vectors:\")\nfor b in basis:\n    print(b)\n```\n\nThis Python function applies Gaussian elimination to compute a basis for the system of bitwise equations described in the editorial. The input \\(A\\) is assumed to be an adjacency matrix, and the algorithm operates on matrices dimensioned according to the problem statement.\n \n\n", "problem_ids": ["abc357_a", "abc362_d", "abc366_g"]}, "abc301_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nFor strings \\( x \\) and \\( y \\), define \\( f(x, y) \\) as follows:  \n\\( f(x, y) \\) is the length of the longest common prefix of \\( x \\) and \\( y \\).\n\nYou are given \\( N \\) strings \\((S_1, S_2, \\ldots, S_N)\\) consisting of lowercase English letters. Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j) \\]\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 3 \\times 10^5 \\)\n- \\( S_i \\) is a string consisting of lowercase English letters.\n- \\( 1 \\leq |S_i| \\) (where \\(|S_i|\\) denotes the length of the string \\( S_i \\))\n- \\( |S_1| + |S_2| + \\ldots + |S_N| \\leq 3 \\times 10^5 \\)\n- All input numbers are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1\nS_2\n...\nS_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\nab\nabc\narc\n```\n\n**Sample Output 1:**\n\n```\n4\n```\n\n**Explanation:**\n\n- \\( f(S_1, S_2) = 2 \\)\n- \\( f(S_1, S_3) = 1 \\)\n- \\( f(S_2, S_3) = 1 \\)\n\nThus, the answer is \\( f(S_1, S_2) + f(S_1, S_3) + f(S_2, S_3) = 4 \\).\n\n**Sample Input 2:**\n\n```\n11\nab\nbb\naaa\nbba\nbaba\nbabb\naaaba\naabbb\na\na\nb\n```\n\n**Sample Output 2:**\n\n```\n32\n```\n\nSolution:\n\n```python\nEditorial - AtCoder Beginner Contest 353\n\nE - Yet Another Sigma Problem Editorial by en_translator\n\nThis problem can be solved with a data structure called Trie. The length of the longest common prefix of \\(S_i\\) and \\(S_j\\) equals the number of common prefixes of \\(S_i\\) and \\(S_j\\). For example, the longest common prefix of \"abc\" and \"abde\" has a length of two, and they have two common prefixes \"a\" and \"ab\". Thus, it is sufficient to enumerate all prefixes \\(T\\) of \\(S_j\\) for all \\(S_j\\), and count the number of \\(S_i\\ (1\\leq i < j)\\) that has \\(T\\) as its suffix. This can be done by inserting \\(S_i\\) in a Trie for each \\(i=1,2,\\ldots,N\\) in order, each of whose node manages the number of strings that has the string represented by the node as a suffix.\n\nSample code (Python 3):\n\n```python\nclass Trie:\n    def __init__(self, len):\n        self.pos = []\n        self.cnt = []\n        self.def_ = [-1] * 26\n        self.now_sz = 0\n        self.ans = 0\n        self.make_node()\n    \n    def make_node(self):\n        self.pos.append(self.def_[:])\n        self.cnt.append(0)\n        self.now_sz += 1\n        return self.now_sz - 1\n    \n    def add(self, s):\n        now = 0\n        for char in s:\n            d = ord(char) - ord('a')\n            nx = self.pos[now][d]\n            if nx == -1:\n                nx = self.make_node()\n                self.pos[now][d] = nx\n            now = nx\n            self.ans += self.cnt[now]\n            self.cnt[now] += 1\n\ndef main():\n    n = int(input())\n    tr = Trie(300000)\n    for _ in range(n):\n        s = input().strip()\n        tr.add(s)\n    print(tr.ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are trying to implement collision detection in a 3D game.\n\nIn a 3-dimensional space, let \\( C(a,b,c,d,e,f) \\) denote the cuboid with a diagonal connecting \\((a,b,c)\\) and \\((d,e,f)\\), with all faces parallel to the xy-plane, yz-plane, or zx-plane. This definition uniquely determines \\( C(a,b,c,d,e,f) \\).\n\nGiven two cuboids \\( C(a,b,c,d,e,f) \\) and \\( C(g,h,i,j,k,l) \\), determine whether their intersection has a positive volume.\n\n**Constraints**\n\n- \\( 0 \\leq a < d \\leq 1000 \\)\n- \\( 0 \\leq b < e \\leq 1000 \\)\n- \\( 0 \\leq c < f \\leq 1000 \\)\n- \\( 0 \\leq g < j \\leq 1000 \\)\n- \\( 0 \\leq h < k \\leq 1000 \\)\n- \\( 0 \\leq i < l \\leq 1000 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from standard input in the following format:\n\n```\na b c d e f\ng h i j k l\n```\n\n**Output**\n\nPrint `Yes` if the intersection of the two cuboids has a positive volume, and `No` otherwise.\n\n**Sample Input 1**\n```\n0 0 0 4 5 6\n2 3 4 5 6 7\n```\n\n**Sample Output 1**\n```\nYes\n```\nThe positional relationship of the two cuboids is shown in the figure below, and their intersection has a volume of 8.\n\n**Sample Input 2**\n\n```\n0 0 0 2 2 2\n0 0 2 2 2 4\n```\n\n**Sample Output 2**\n```\nNo\n```\nThe two cuboids touch at a face, where the volume of the intersection is 0.\n\n**Sample Input 3**\n```\n0 0 0 1000 1000 1000\n10 10 10 100 100 100\n```\n\n**Sample Output 3**\n```\nYes\n```\n\nSolution:\n\n```\nHere is a cleaned version of the editorial:\n\nOfficial Editorial: B - Intersection of Cuboids\n\nLet \\([x,y]\\) denote the segment formed by all real numbers between \\(x\\) and \\(y\\), inclusive. \n\n**Problem:** Determine if two segments \\([a,b]\\) and \\([c,d]\\) have an intersection of a positive length. The length of intersection is \\(0\\) for one of the following cases:\n\n- \\([a,b]\\) is to the left of \\([c,d]\\).\n- \\([a,b]\\) is to the right of \\([c,d]\\).\n\nIn Pythonic pseudocode:\n```python\nif b <= c or d <= a:\n    print(\"0 intersection\")\nelse:\n    print(\"positive intersection\")\n```\n\nFor a three-dimensional problem, solve the one-dimensional problem for the three coordinates \\(x\\), \\(y\\), and \\(z\\). If the length of intersection for all coordinates is positive, the intersection of the cuboids has a positive volume; otherwise, it is \\(0\\). \n\nPython code:\n```python\nx1, y1, z1, x2, y2, z2 = map(int, input().split())\nx3, y3, z3, x4, y4, z4 = map(int, input().split())\n\ndef f(l1, r1, l2, r2):\n    # Returns True if the intersection of [l1, r1] and [l2, r2] has a positive length\n    return not (r1 <= l2 or r2 <= l1)\n\nif f(x1, x2, x3, x4) and f(y1, y2, y3, y4) and f(z1, z2, z3, z4):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nProblem Statement:\nYou are given a horizontally written text. Convert it to vertical writing, filling spaces with `*`.\n\nYou are given \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\) consisting of lowercase English letters. Let \\( M \\) be the maximum length of these strings.\n\nPrint \\( M \\) strings \\( T_1, T_2, \\dots, T_M \\) that satisfy the following conditions:\n\n1. Each \\( T_i \\) consists of lowercase English letters and `*`.\n2. Each \\( T_i \\) does not end with `*`.\n3. For each \\( 1 \\leq i \\leq N \\), the following holds:\n    - For each \\( 1 \\leq j \\leq |S_i| \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) exists, and the concatenation of the \\( (N-i+1) \\)-th characters of \\( T_1, T_2, \\dots, T_{|S_i|} \\) in this order equals \\( S_i \\).\n    - For each \\( |S_i| + 1 \\leq j \\leq M \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) either does not exist or is `*`.\n\nHere, \\( |S_i| \\) denotes the length of the string \\( S_i \\).\n\nConstraints:\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is a string of lowercase English letters with length between 1 and 100, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\nOutput:\nPrint the answer in the following format:\n```\nT_1\nT_2\n\u22ee\nT_M\n```\n\nSample Input 1:\n```\n3\nabc\nde\nfghi\n```\n\nSample Output 1:\n```\nfda\ngeb\nh*c\ni\n```\n\nSample Input 2:\n```\n3\natcoder\nbeginner\ncontest\n```\n\nSample Output 2:\n```\ncba\noet\nngc\ntio\nend\nsne\nter\n*r\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        First, ignore the condition that \\(T_i\\) does not end with *. Initialize \\(T_1,T_2,\\dots,T_M\\) with a length-\\(N\\) string of *. For each \\(i\\) and \\(j\\), assign the \\(j\\)-th character of \\(S_i\\) to the \\((N-i+1)\\)-th character of \\(T_j\\). To satisfy the second condition, for each \\(T_i\\), remove the last character while it ends with *. \n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(map(len, S))\nT = [[\"*\"] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i][-1] == \"*\":\n        T[i].pop()\n    print(\"\".join(T[i]))\n```\n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(len(s) for s in S)\nT = [['*'] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i] and T[i][-1] == '*':\n        T[i].pop()\n    print(''.join(T[i]))\n}\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc353_e", "abc361_b", "abc366_b"]}, "abc301_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:  \nIn the \\( xy \\)-plane, there are three points \\( A(x_A, y_A) \\), \\( B(x_B, y_B) \\), and \\( C(x_C, y_C) \\) that are not collinear. Determine whether the triangle \\( ABC \\) is a right triangle.\n\nConstraints:  \n- \\( -1000 \\leq x_A, y_A, x_B, y_B, x_C, y_C \\leq 1000 \\)\n- The three points \\( A \\), \\( B \\), and \\( C \\) are not collinear.\n- All input values are integers.\n\nInput:  \nThe input is given from Standard Input in the following format:\n\n```\nx_A y_A  \nx_B y_B  \nx_C y_C  \n```\n\nOutput:  \nPrint `Yes` if the triangle \\( ABC \\) is a right triangle, and `No` otherwise.\n\nSample Input 1:  \n```\n0 0  \n4 0  \n0 3  \n```\n\nSample Output 1:  \n```\nYes\n```\n\nThe triangle \\( ABC \\) is a right triangle.\n\nSample Input 2:  \n```\n-4 3  \n2 1  \n3 4  \n```\n\nSample Output 2:  \n```\nYes\n```\n\nThe triangle \\( ABC \\) is a right triangle.\n\nSample Input 3:  \n```\n2 4  \n-3 2  \n1 -2  \n```\n\nSample Output 3:  \n```\nNo\n```\n\nThe triangle \\( ABC \\) is not a right triangle.\n\nSolution:\n\n```python\nxA, yA = map(int, input().split())\nxB, yB = map(int, input().split())\nxC, yC = map(int, input().split())\n\nAB2 = (xA - xB) ** 2 + (yA - yB) ** 2\nBC2 = (xB - xC) ** 2 + (yB - yC) ** 2\nCA2 = (xC - xA) ** 2 + (yC - yA) ** 2\n\nif AB2 + BC2 == CA2 or BC2 + CA2 == AB2 or CA2 + AB2 == BC2:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a tree with \\(N\\) vertices numbered from 1 to \\(N\\). The \\(i\\)-th edge connects vertices \\(A_i\\) and \\(B_i\\). Here, \\(N\\) is even, and furthermore, this tree has a perfect matching. Specifically, for each \\(i\\) (\\(1 \\leq i \\leq N/2\\)), it is guaranteed that \\(A_i = i \\times 2 - 1\\) and \\(B_i = i \\times 2\\).\n\nYou will perform the following operation \\(N/2\\) times:\n- Choose two leaves (vertices with degree exactly 1) and remove them from the tree. Here, the tree after removal must still have a perfect matching. In this problem, we consider a graph with zero vertices to be a tree as well.\n\nFor each operation, its score is defined as the distance between the two chosen vertices (the number of edges on the simple path connecting the two vertices).\n\nShow one procedure that maximizes the total score. It can be proved that there always exists a procedure to complete \\(N/2\\) operations under the constraints of this problem.\n\n**Constraints**\n- \\(2 \\leq N \\leq 250000\\)\n- \\(N\\) is even.\n- \\(1 \\leq A_i < B_i \\leq N\\) (\\(1 \\leq i \\leq N-1\\))\n- \\(A_i = i \\times 2 - 1\\), \\(B_i = i \\times 2\\) (\\(1 \\leq i \\leq N/2\\))\n- The given graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_{N-1} B_{N-1}\n```\n\n**Output**\n\nPrint a solution in the following format:\n```\nX_1 Y_1\nX_2 Y_2\n...\nX_{N/2} Y_{N/2}\n```\n\nHere, \\(X_i\\) and \\(Y_i\\) are the two vertices chosen in the \\(i\\)-th operation. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n```\n4\n1 2\n3 4\n2 3\n```\n\n**Sample Output 1**\n```\n4 1\n2 3\n```\n\nThe procedure in the sample output is as follows:\n- 1st operation: Remove vertices 4 and 1. The remaining tree has vertices 2 and 3, and a perfect matching. The score of this operation is 3.\n- 2nd operation: Remove vertices 2 and 3. The remaining tree has zero vertices and a perfect matching. The score of this operation is 1.\n- The total score is \\(3 + 1 = 4\\).\n\nIt is impossible to make the total score greater than 4, so this output solves this sample input.\n\n**Sample Input 2**\n```\n8\n1 2\n3 4\n5 6\n7 8\n2 3\n1 5\n1 7\n```\n\n**Sample Output 2**\n```\n4 8\n7 6\n5 3\n2 1\n```\n\n**Sample Input 3**\n```\n14\n1 2\n3 4\n5 6\n7 8\n9 10\n11 12\n13 14\n2 8\n4 11\n5 12\n7 13\n11 14\n9 13\n```\n\n**Sample Output 3**\n```\n1 6\n5 2\n8 12\n3 7\n10 4\n11 9\n13 14\n```\n\n**Sample Input 4**\n```\n20\n1 2\n3 4\n5 6\n7 8\n9 10\n11 12\n13 14\n15 16\n17 18\n19 20\n8 10\n16 18\n16 19\n5 9\n10 17\n2 13\n7 14\n3 7\n3 12\n```\n\n**Sample Output 4**\n```\n6 1\n2 15\n20 13\n14 19\n16 4\n11 18\n17 12\n3 5\n9 7\n8 10\n```\n\nSolution:\n\n```python\n# Problem: Keep Perfectly Matched (Translated to Python3)\n\n# Editorial Explanation:\n# For each edge, consider how many times it contributes to the score. An upper bound is the size\n# of the smaller of the two subtrees created when the edge is cut. This upper bound can be achieved\n# by treating the input tree as a rooted tree with the centroid R as the root. Let v1, v2, ..., vk \n# be the direct children of the root, and T1, T2, ..., Tk be their respective subtrees. Leaves \n# should be chosen from two different subtrees and removed, except for the last operation. Assume \n# the root is initially matched with v1. In the first operation, leaves of T1 and Tj (j != 1) must \n# be chosen. After this operation, the root is matched with vj. Choose Tj next, and so on. By \n# choosing the Tj with the largest size each time, all operations finish successfully. Though this \n# guarantees valid subtree vertex counts, it doesn't ensure proper leaf selection. Leaves can be \n# removed within each subtree by considering vertices top-down from the root. Assume focus is on \n# vertex v. If matched with a child, choose a leaf from that child\u2019s subtree. Otherwise, choose \n# another child and select a leaf from its subtree. This process leads to a leaf that can be \n# removed. The leaf removal procedure has a worst-case total time complexity of O(N^2), but by \n# modifying the procedure slightly, an efficient order to remove each vertex as a leaf can be \n# found. Perform a DFS prioritizing edges used in the matching and use vertices along the postorder \n# traversal. The problem can be solved in O(N log N) time.\n\n# Please note: The editorial does not contain specific code snippets, so this explanation outlines \n# the algorithmic approach described in the original editorial in Pythonic terms.\n```\n\nMarubeni Programming Contest 2024 (AtCoder Regular Contest 183)\n\nD - Keep Perfectly Matched Editorial by evima\n\nFor each edge, consider how many times it contributes to the score. An upper bound is the size of the smaller of the two subtrees created when the edge is cut. This upper bound can be achieved by treating the input tree as a rooted tree with the centroid \\(R\\) as the root. Let \\(v_1, v_2, \\cdots, v_k\\) be the direct children of the root, and \\(T_1, T_2, \\cdots, T_k\\) be their respective subtrees. Leaves should be chosen from two different subtrees and removed, except for the last operation. Assume the root is initially matched with \\(v_1\\). In the first operation, leaves of \\(T_1\\) and \\(T_j\\) (\\(j \\neq 1\\)) must be chosen. After this operation, the root is matched with \\(v_j\\). Choose \\(T_j\\) next, and so on. By choosing the \\(T_j\\) with the largest size each time, all operations finish successfully. Though this guarantees valid subtree vertex counts, it doesn't ensure proper leaf selection. Leaves can be removed within each subtree by considering vertices top-down from the root. Assume focus is on vertex \\(v\\). If matched with a child, choose a leaf from that child\u2019s subtree. Otherwise, choose another child and select a leaf from its subtree. This process leads to a leaf that can be removed. The leaf removal procedure has a worst-case total time complexity of \\(O(N^2)\\), but by modifying the procedure slightly, an efficient order to remove each vertex as a leaf can be found. Perform a DFS prioritizing edges used in the matching and use vertices along the postorder traversal. The problem can be solved in \\(O(N\\log N)\\) time.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( A \\), \\( B \\), \\( X \\), \\( Y \\), and \\( N \\). The following conditions are guaranteed:\n\n- \\( A < B \\)\n- \\(\\gcd(A, B) = 1\\)\n- \\( 1 \\leq N \\leq A+B-1 \\)\n\nFor an integer \\( n \\), define \\( f(n) \\) as follows: You start with an integer \\( x = 0 \\). \\( f(n) \\) is the minimum total cost to achieve \\( x = n \\) by repeatedly performing the following operations:\n\n- Replace the value of \\( x \\) with \\( x + A \\). The cost of this operation is \\( X \\).\n- Replace the value of \\( x \\) with \\( x - A \\). The cost of this operation is \\( X \\).\n- Replace the value of \\( x \\) with \\( x + B \\). The cost of this operation is \\( Y \\).\n- Replace the value of \\( x \\) with \\( x - B \\). The cost of this operation is \\( Y \\).\n\nIt can be proved from the constraints on \\( A \\) and \\( B \\) that \\( f(n) \\) is defined for any integer \\( n \\).\n\nFind the value of \\( \\sum_{1 \\leq n \\leq N} f(n) \\), modulo \\( 998244353 \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 1000 \\)\n- \\( 1 \\leq A < B \\leq 10^9 \\)\n- \\(\\gcd(A, B) = 1\\)\n- \\( 1 \\leq X, Y \\leq 10^9 \\)\n- \\( 1 \\leq N \\leq A + B - 1 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nA B X Y N\n```\n\n**Output**\n\nPrint the answer for each test case.\n\n**Sample Input**\n\n```\n4\n1 2 1 1 2\n3 5 2 4 6\n79 85 72 95 4\n80980429 110892168 22712439 520643153 66132787\n```\n\n**Sample Output**\n\n```\n2\n34\n18111\n785776602\n```\n\nIn the first test case, \\( f(1) = 1 \\) and \\( f(2) = 1 \\).\n\nIn the second test case, \\( f(1) = 8 \\), \\( f(2) = 6 \\), \\( f(3) = 2 \\), \\( f(4) = 10 \\), \\( f(5) = 4 \\), and \\( f(6) = 4 \\).\n\nSolution:\n\n        The solution discusses how to find the shortest path in an operation sequence defined by integers \\(A, B, C, N\\), and elements \\(AX, AY, BX, BY\\) of a monoid \\(M\\). The problem focuses on modifying an integer \\(x\\) initially set to 0 and updating elements \\(cur\\) and \\(ans\\) in \\(M\\) over \\(N\\) operations. The operations are performed based on whether \\(x\\) is less than \\(B\\) or not, adjusting \\(ans\\) with products involving \\(AX, AY, BX, BY\\). The approach leverages a cycle structure of moves to ensure optimal paths, achieved through combinations of operations that mimic mathematical floor functions. Solutions are designed to work efficiently, leveraging logarithmic complexity relative to \\(A + B\\).\n \n\n", "problem_ids": ["abc362_b", "arc183_d", "arc183_f"]}, "abc301_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a bottle of disinfectant that can disinfect exactly \\( M \\) hands. \\( N \\) aliens come one by one to disinfect their hands. The \\( i \\)-th alien (\\( 1 \\leq i \\leq N \\)) has \\( H_i \\) hands and wants to disinfect all of their hands once. Determine how many aliens can disinfect all of their hands. Here, even if there is not enough disinfectant left for an alien to disinfect all of their hands when they start, they will use up the remaining disinfectant.\n\n**Constraints**\n\n- \\( 1 \\leq N, M \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the number of aliens who can disinfect all of their hands.\n\n**Sample Input 1**\n\n```\n5 10\n2 3 2 5 3\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\n*Explanation:*\n\n1. The first alien disinfects their two hands. The remaining disinfectant can disinfect \\( 10-2=8 \\) hands.\n2. The second alien disinfects their three hands. The remaining disinfectant can disinfect \\( 8-3=5 \\) hands.\n3. The third alien disinfects their two hands. The remaining disinfectant can disinfect \\( 5-2=3 \\) hands.\n4. The fourth alien has five hands, but there is only enough disinfectant for three hands, so they use up the disinfectant without disinfecting all of their hands.\n\nThus, the first three aliens can disinfect all of their hands, so print 3.\n\n**Sample Input 2**\n\n```\n5 10\n2 3 2 3 5\n```\n\n**Sample Output 2**\n\n```\n4\n```\n\n**Sample Input 3**\n\n```\n1 5\n1\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\nAll aliens can disinfect their hands.\n\nSolution:\n\n[BEGIN TEXT]\nHere is the simplified version of the editorial:\n\nThe problem can be solved by simulating the remaining amount of disinfectant. Start from \\(M\\) and subtract \\(H_1, H_2, \\ldots, H_N\\) from it in order. If it never goes below \\(0\\), all aliens can disinfect their hands, and the answer is \\(N\\). If it becomes less than \\(0\\) for the first time when subtracting \\(H_i\\), the answer is \\(i-1\\). Ensure to use an appropriate conditional inequality to handle the case when the disinfectant is used up completely.\n\nSample code in Python:\n\n```python\nn, m = map(int, input().split())\nh = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n    m -= h[i]\n    if m >= 0:\n        ans += 1\nprint(ans)\n```\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\). You are also given \\(Q\\) queries to process in order. There are three types of queries:\n\n1. `1 l r x`: Add \\(x\\) to each of \\(A_l, A_{l+1}, \\ldots, A_r\\).\n2. `2 l r x`: Add \\(x\\) to each of \\(B_l, B_{l+1}, \\ldots, B_r\\).\n3. `3 l r`: Print the remainder of \\(\\sum_{i=l}^r (A_i \\times B_i)\\) when divided by 998244353.\n\n**Constraints:**\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(0 \\leq A_i, B_i \\leq 10^9\\)\n- \\(1 \\leq l \\leq r \\leq N\\)\n- \\(1 \\leq x \\leq 10^9\\)\n- All input values are integers.\n- There is at least one query of the third type.\n\n**Input:**\n\nThe input is given from Standard Input in the following format. Here, \\(\\text{query}_i (1 \\leq i \\leq Q)\\) is the \\(i\\)-th query to be processed.\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n\\text{query}_1\n\\text{query}_2\n\\vdots\n\\text{query}_Q\n```\n\nEach query is given in one of the following formats:\n\n```\n1 l r x\n```\n\n```\n2 l r x\n```\n\n```\n3 l r\n```\n\n**Output:**\n\nIf there are \\(K\\) queries of the third type, print \\(K\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq K)\\) should contain the output for the \\(i\\)-th query of the third type.\n\n**Sample Input 1:**\n\n```\n5 6\n1 3 5 6 8\n3 1 2 1 2\n3 1 3\n1 2 5 3\n3 1 3\n1 1 3 1\n2 5 5 2\n3 1 5\n```\n\n**Sample Output 1:**\n\n```\n16\n25\n84\n```\n\nInitially, \\(A = (1, 3, 5, 6, 8)\\) and \\(B = (3, 1, 2, 1, 2)\\). The queries are processed in the following order:\n\n1. For the first query, print \\((1 \\times 3) + (3 \\times 1) + (5 \\times 2) = 16\\) modulo 998244353, which is 16.\n2. For the second query, add 3 to \\(A_2, A_3, A_4, A_5\\). Now \\(A = (1, 6, 8, 9, 11)\\).\n3. For the third query, print \\((1 \\times 3) + (6 \\times 1) + (8 \\times 2) = 25\\) modulo 998244353, which is 25.\n4. For the fourth query, add 1 to \\(A_1, A_2, A_3\\). Now \\(A = (2, 7, 9, 9, 11)\\).\n5. For the fifth query, add 2 to \\(B_5\\). Now \\(B = (3, 1, 2, 1, 4)\\).\n6. For the sixth query, print \\((2 \\times 3) + (7 \\times 1) + (9 \\times 2) + (9 \\times 1) + (11 \\times 4) = 84\\) modulo 998244353, which is 84.\n\nThus, the first, second, and third lines should contain 16, 25, and 84, respectively.\n\n**Sample Input 2:**\n\n```\n2 3\n1000000000 1000000000\n1000000000 1000000000\n3 1 1\n1 2 2 1000000000\n3 1 2\n```\n\n**Sample Output 2:**\n\n```\n2716070898\n151723988\n```\n\nMake sure to print the sum modulo 998244353 for the third type of query.\n\nSolution:\n\n[BEGIN TEXT]\nConsider solving this problem using a lazy segment tree. For details on lazy segment trees, please refer to other editorials and the AtCoder Library explanation. Specifically, for each segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) for integers \\(a,k\\geq 0\\) and \\(2^k(a+1)\\leq N\\), we want to manage the sum of \\(A_i\\times B_i\\) within the segment, and apply addition to \\(A_i\\) and \\(B_i\\) fast enough (in \\(O(1)\\) time). The set of actions consists of \u201cadding \\(x\\) to each element of \\(A\\) and \\(y\\) to that of \\(B\\) (within the segment)\u201d for all integers \\(x\\) and \\(y\\). \n\nFor a segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) (where \\(L=a\\cdot2^k+1\\) and \\(R=(a+1)2^k\\)), it is insufficient to store the values \\(\\sum_{i=L}^R (A_i\\times B_i)\\) for each segment. Instead, manage the length \\((R-L+1)\\), and three kinds of sum: \\(\\sum_{i=L}^R A_i\\), \\(\\sum_{i=L}^R B_i\\), and \\(\\sum_{i=L}^R (A_i\\times B_i)\\), for each segment. Then, one can update the value \\(\\sum_{i=L}^R (A_i\\times B_i)\\) in \\(O(1)\\) time. \n\nThe key updates are:\n\\[\n\\sum_{i=L}^R ((A_i+x)\\times (B_i+y)) = \\sum_{i=L}^R (A_i\\times B_i) + y\\sum_{i=L}^R A_i + x\\sum_{i=L}^R B_i + (R-L+1)xy\n\\]\n\\[\n\\sum_{i=L}^R (A_i+x) = \\sum_{i=L}^R A_i+(R-L+1)x, \n\\]\n\\[\n\\sum_{i=L}^R (B_i+y) = \\sum_{i=L}^R B_i+(R-L+1)y\n\\]\n\nTherefore, the lazy segment tree can find the answer with a complexity of \\(O(Q\\log N)\\), which is efficient. The answer should be printed modulo \\(998244353\\).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\) and a prime \\( P \\).\n\nCount the number, modulo \\( P \\), of undirected connected graphs \\( G \\) of \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) that satisfy the following conditions:\n\n1. There are no self-loops in \\( G \\). Note that multiple edges are allowed.\n2. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) remains connected. In other words, \\( G \\) is edge-biconnected.\n3. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) is no longer edge-biconnected.\n\nTwo graphs are considered different if and only if there exists a pair of distinct vertices \\( (u,v) \\) such that the numbers of edges connecting \\( u \\) and \\( v \\) in the two graphs are different.\n\n**Constraints**\n\n- \\( 2 \\le N \\le 50 \\)\n- \\( 10^9 < P < 1.01 \\times 10^9 \\)\n- \\( P \\) is prime.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**  \n```\n2 1005976817\n```\n\n**Sample Output 1**  \n```\n1\n```\n\n**Sample Input 2**  \n```\n5 1000837403\n```\n\n**Sample Output 2**  \n```\n372\n```\n\n**Sample Input 3**  \n```\n10 1001160547\n```\n\n**Sample Output 3**  \n```\n789846604\n```\n\n**Sample Input 4**  \n```\n20 1006779551\n```\n\n**Sample Output 4**  \n```\n888612770\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Grand Contest 067 - E: Biconnected Graph Editorial by Kubic\n\nIf an edge is deleted, the remaining graph will form a chain after shrinking biconnected components; it will become a cycle if the edge is added back. Solve the problem for each biconnected component and multiply the answers. In the subproblem, there's an additional edge connecting two vertices, allowing them to reach each other through the cycle. Repeat this method by taking an edge connected to vertex \\(1\\), leading to subproblems formatted as:\n\nCount good graphs of \\(n\\) vertices with the first \\(k\\) vertices able to reach each other externally.\n\nConsider the distribution of the first \\(k\\) vertices:\n\n\\(\\forall 1\\le u,v\\le k\\), \\(C(u),C(v)\\) are not adjacent in the cycle, where \\(C(u)\\) is the biconnected component containing \\(u\\).\n\nDP through the cycle without constraining the edge choice so every good graph is counted \\(\\deg(1)\\) times. Store \\(\\deg(1)\\) in the DP state and divide the final answer by it.\n\nTime complexity: \\(O(n^5)\\). Some \\(O(n^6)\\) solutions with small constants may pass.\n        [END TEXT]\n \n\n", "problem_ids": ["abc357_a", "abc357_f", "agc067_e"]}, "abc302_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\n\nFor a non-negative integer \\( K \\), we define a level-\\( K \\) carpet as follows:\n\n- A level-0 carpet is a \\( 1 \\times 1 \\) grid consisting of a single black cell.\n- For \\( K > 0 \\), a level-\\( K \\) carpet is a \\( 3^K \\times 3^K \\) grid. When this grid is divided into nine \\( 3^{K-1} \\times 3^{K-1} \\) blocks:\n  - The central block consists entirely of white cells.\n  - The other eight blocks are level-\\( (K-1) \\) carpets.\n\nYou are given a non-negative integer \\( N \\). Print a level-\\( N \\) carpet according to the specified format.\n\nConstraints:\n- \\( 0 \\leq N \\leq 6 \\)\n- \\( N \\) is an integer.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\n```\n\nOutput:\nPrint \\( 3^N \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq 3^N \\)) should contain a string \\( S_i \\) of length \\( 3^N \\) consisting of `.` and `#`. The \\( j \\)-th character of \\( S_i \\) (\\( 1 \\leq j \\leq 3^N \\)) should be `#` if the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left of a level-\\( N \\) carpet is black, and `.` if it is white.\n\nSample Input 1:\n```\n1\n```\n\nSample Output 1:\n```\n###\n#.#\n###\n```\n\nA level-1 carpet is a \\( 3 \\times 3 \\) grid as follows. When output according to the specified format, it looks like the sample output.\n\nSample Input 2:\n```\n2\n```\n\nSample Output 2:\n```\n#########\n#.##.##.#\n#########\n###...###\n#.#...#.#\n###...###\n#########\n#.##.##.#\n#########\n```\n\nA level-2 carpet is a \\( 9 \\times 9 \\) grid.\n\nSolution:\n\n```python\ndef main():\n    n = int(input())\n    l = 1\n    a = [['\\0' for _ in range(730)] for _ in range(729)]\n    \n    a[0][0] = '#'\n    for k in range(n):\n        for x in range(3):\n            for y in range(3):\n                if (x == 0) and (y == 0):\n                    continue\n                if (x == 1) and (y == 1):\n                    for i in range(l):\n                        for j in range(l):\n                            a[x * l + i][y * l + j] = '.'\n                else:\n                    for i in range(l):\n                        for j in range(l):\n                            a[x * l + i][y * l + j] = a[i][j]\n        l *= 3\n    \n    for i in range(l):\n        print(''.join(a[i]))\n\nmain()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere are \\( N \\) types of items. The \\( i \\)-th type of item has a weight of \\( w_i \\) and a value of \\( v_i \\). Each type has \\( 10^{10} \\) items available.\n\nTakahashi is going to choose some items and put them into a bag with capacity \\( W \\). He wants to maximize the value of the selected items while avoiding choosing too many items of the same type. Hence, he defines the **happiness** of choosing \\( k_i \\) items of type \\( i \\) as \\( k_i v_i - k_i^2 \\). He wants to choose items to maximize the total happiness over all types while keeping the total weight at most \\( W \\). Calculate the maximum total happiness he can achieve.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 3000 \\)\n- \\( 1 \\leq W \\leq 3000 \\)\n- \\( 1 \\leq w_i \\leq W \\)\n- \\( 1 \\leq v_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN W\nw_1 v_1\nw_2 v_2\n\\vdots\nw_N v_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n2 10\n3 4\n3 2\n```\n\n**Sample Output 1:**\n```\n5\n```\n\nBy choosing 2 items of type 1 and 1 item of type 2, the total happiness can be 5, which is optimal. Here, the happiness for type 1 is \\( 2 \\times 4 - 2^2 = 4 \\), and the happiness for type 2 is \\( 1 \\times 2 - 1^2 = 1 \\). The total weight is 9, which is within the capacity 10.\n\n**Sample Input 2:**\n```\n3 6\n1 4\n2 3\n2 7\n```\n\n**Sample Output 2:**\n```\n14\n```\n\n**Sample Input 3:**\n```\n1 10\n1 7\n```\n\n**Sample Output 3:**\n```\n12\n```\n\nSolution:\n\n```python\n# Here is a streamlined version focusing on the core solution:\n\ndef dp_happiness(N, W, items):\n    # Initialize dp table\n    dp = [[0] * (W + 1) for _ in range(max_weight + 1)]\n    \n    for w in range(1, max_weight + 1):\n        values = [v for v_i, w_i in items if w_i == w]\n        m = len(values)\n        \n        def f_w(k):\n            happiness = 0\n            # Priority queue to maximize happiness delta\n            deltas = [v - 1 for v in values]\n            deltas.sort(reverse=True)\n            for i in range(k):\n                if deltas:\n                    happiness += deltas[0]\n                    deltas[0] -= 2\n                    deltas.sort(reverse=True)\n            return happiness\n        \n        for j in range(W + 1):\n            dp[w][j] = dp[w-1][j]\n            for k in range(0, j // w + 1):\n                dp[w][j] = max(dp[w][j], dp[w-1][j - k * w] + f_w(k))\n    \n    return dp[max_weight][W]\n\n# Example usage:\n# N: number of items\n# W: maximum weight\n# Items: list of tuples, each tuple is (value, weight)\nN = 5\nW = 10\nitems = [(3, 2), (2, 2), (4, 3), (5, 5)]\nmax_weight = max(item[1] for item in items)\n\nmax_happiness = dp_happiness(N, W, items)\nprint(f\"Maximum total happiness: {max_happiness}\")\n```\n\nThis Python code implements the Dynamic Programming approach described in the editorial, fully translated from the explanation provided. The function `dp_happiness` takes the number of items, maximum weight, and a list of items (each defined by a tuple of value and weight) and computes the maximum total happiness.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n## Problem Statement\n\nThere is a grid with \\( N \\) rows and \\( N \\) columns. Let \\( (i, j) \\) \\((1 \\leq i \\leq N, 1 \\leq j \\leq N)\\) denote the cell at the \\( i \\)-th row from the top and the \\( j \\)-th column from the left. Each cell is initially painted red or blue, with cell \\( (i, j) \\) being red if \\( c_{i,j} = R \\) and blue if \\( c_{i,j} = B \\). You want to change the colors of some cells to purple so that the following two conditions are simultaneously satisfied:\n\n- **Condition 1:** You can move from cell \\( (1, 1) \\) to cell \\( (N, N) \\) by only passing through cells that are red or purple.\n- **Condition 2:** You can move from cell \\( (1, N) \\) to cell \\( (N, 1) \\) by only passing through cells that are blue or purple.\n\nHere, \"You can move\" means that you can reach the destination from the starting point by repeatedly moving to a horizontally or vertically adjacent cell of the relevant colors.\n\nWhat is the minimum number of cells that must be changed to purple to satisfy these conditions?\n\n## Constraints\n\n- \\( 3 \\leq N \\leq 500 \\)\n- Each \\( c_{i,j} \\) is \\( R \\) or \\( B \\).\n- \\( c_{1,1} \\) and \\( c_{N,N} \\) are \\( R \\).\n- \\( c_{1,N} \\) and \\( c_{N,1} \\) are \\( B \\).\n- \\( N \\) is an integer.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nc_{1,1}c_{1,2}\\cdots c_{1,N}\nc_{2,1}c_{2,2}\\cdots c_{2,N}\n\u22ee\nc_{N,1}c_{N,2}\\cdots c_{N,N}\n```\n\n## Output\n\nPrint the answer.\n\n## Sample Input 1\n\n```\n5\nRBRBB\nRBRRR\nRRRBR\nRBBRB\nBBRBR\n```\n\n## Sample Output 1\n\n```\n3\n```\n\nAs shown in the figure below, changing cells \\( (1, 3) \\), \\( (3, 2) \\), \\( (4, 5) \\) to purple satisfies the conditions.\n\n## Sample Input 2\n\n```\n5\nRBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBR\n```\n\n## Sample Output 2\n\n```\n7\n```\n\nAs shown in the figure below, changing cells \\( (1, 2) \\), \\( (2, 2) \\), \\( (2, 3) \\), \\( (3, 3) \\), \\( (3, 4) \\), \\( (4, 4) \\), \\( (4, 5) \\) to purple satisfies the conditions.\n\n## Sample Input 3\n\n```\n10\nRRBBBBBBBB\nBRRBBBBBBB\nBBRRBBBBBB\nBBBRRBBBBB\nBBBBRRBBBB\nBBBBBRRBBB\nBBBBBBRRBB\nBBBBBBBRRB\nBBBBBBBBRR\nBBBBBBBBBR\n```\n\n## Sample Output 3\n\n```\n2\n```\n\n## Sample Input 4\n\n```\n17\nRBBRRBRRRRRBBBBBB\nBBRBRBRRBRRBRRBBR\nBRBRBBBRBBRBBRBBB\nRBRRBBBBBBRRBRRRR\nRRRRRBRBRRRBBRBBR\nRRRRRBRRBRBBRRRBB\nBBBRRRBRBRBBRRRBB\nBBRRRBRBBBRBRRRBR\nRRBBBBBBBBBBBRBRR\nRRRBRRBRBRBRBRBBB\nRRBRRRRBRBRRBRBBR\nRRRBBRBRBBBRBBRBR\nBBRBBRRBRRRBBRBBB\nBBBRBRRRRRRRBBRBB\nRRRRRBRBRBBRRBRRR\nBRRRRBBBRRRBRRBBB\nBBRRBBRRRBBBRBBBR\n```\n\n## Sample Output 4\n\n```\n8\n```\n\nSolution:\n\n```python\n[BEGIN TEXT]\n**Editorial - AtCoder Regular Contest 177**\n\n**C - Routing Editorial by evima**\n\n**Step 1:** Consider solving the Sample Input 1 manually:  \nGrid:  \n5  \nRBRBB  \nRBRRR  \nRRRBR  \nRBBRB  \nBBRBR  \n\nThe problem involves these conditions:  \n1. Move from top-left to bottom-right only through red or purple cells.  \n2. Move from top-right to bottom-left only through blue or purple cells.  \n\nDivide the grid; red cells represent only the left side painted, and blue cells represent only the right side painted. Purple cells are where both sides are painted.\n\n**Operations:**  \n- Blue \u2192 Purple: Paint an unpainted cell in the left grid.  \n- Red \u2192 Purple: Paint an unpainted cell in the right grid.\n\n**Satisfying Conditions:**  \n- Condition 1 requires one \"Blue \u2192 Purple\" operation.  \n- Condition 2 requires two \"Red \u2192 Purple\" operations.  \n\nThe answer is \\(1+2=3\\).\n\n**Step 2:** For the general case, divide the grid and consider red and blue independently. Solve for red, then add results.  \n\n**Properties:**  \n- Minimum cells to repaint red = minimum white cells passed from top-left to bottom-right.  \nLet \\(a\\) be cells repainted red, and \\(b\\) be white cells passed.  \n- \\(b \\geq a\\): A path through \\(b\\) white cells can be repainted to move.  \n- \\(b \\leq a\\): A method with \\(a\\) repaintings moves without more than \\(a\\) white cells.  \nThus, \\(a = b\\).\n\n**Find Minimum White Cells Passed:**  \nReduce to shortest path problem:  \n- Each cell is a vertex; cost is 1 for white and 0 otherwise.  \n- Use Dijkstra\u2019s algorithm (\\(O(N^2 \\log N)\\) time). Constraint \\(N \\leq 500\\).\n\n**Sample Implementation (Python 3):**\n```python\nimport heapq\n\nN = int(input())\nC = [input().strip() for _ in range(N)]\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ndef solve(sx, sy, gx, gy, target):\n    dist = [[float('inf')] * N for _ in range(N)]\n    dist[sx][sy] = 0\n    used = [[False] * N for _ in range(N)]\n    queue = [(0, sx, sy)]\n\n    while queue:\n        cost, ax, ay = heapq.heappop(queue)\n        if used[ax][ay]:\n            continue\n        used[ax][ay] = True\n        for i in range(4):\n            bx = ax + dx[i]\n            by = ay + dy[i]\n            if 0 <= bx < N and 0 <= by < N:\n                new_cost = cost + (0 if C[bx][by] == target else 1)\n                if dist[bx][by] > new_cost:\n                    dist[bx][by] = new_cost\n                    heapq.heappush(queue, (new_cost, bx, by))\n\n    return dist[gx][gy]\n\ndist1 = solve(0, 0, N-1, N-1, 'R')\ndist2 = solve(0, N-1, N-1, 0, 'B')\nprint(dist1 + dist2)\n```\n[END TEXT]\n```\n \n\n", "problem_ids": ["abc357_c", "abc373_f", "arc177_c"]}, "abc302_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nAn election is being held with \\( N \\) candidates numbered \\( 1, 2, \\ldots, N \\). There are \\( K \\) votes, some of which have been counted so far. Up until now, candidate \\( i \\) has received \\( A_i \\) votes.\n\nAfter all ballots are counted, candidate \\( i \\) (\\( 1 \\leq i \\leq N \\)) will be elected if and only if the number of candidates who have received more votes than them is less than \\( M \\). There may be multiple candidates elected.\n\nFor each candidate, find the minimum number of additional votes they need from the remaining ballots to guarantee their victory regardless of how the other candidates receive votes. Formally, solve the following problem for each \\( i = 1,2,\\ldots,N \\).\n\nDetermine if there is a non-negative integer \\( X \\) not exceeding \\( K - \\displaystyle{\\sum_{i=1}^{N}} A_i \\) satisfying the following condition. If it exists, find the minimum possible such integer.\n\n- If candidate \\( i \\) receives \\( X \\) additional votes, then candidate \\( i \\) will always be elected.\n\n### Constraints\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq K \\leq 10^{12} \\)\n- \\( 0 \\leq A_i \\leq 10^{12} \\)\n- \\( \\displaystyle{\\sum_{i=1}^{N} A_i} \\leq K \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nLet \\( C_i \\) be the minimum number of additional votes candidate \\( i \\) needs from the remaining ballots to guarantee their victory regardless of how other candidates receive votes. Print \\( C_1, C_2, \\ldots, C_N \\) separated by spaces.\n\nIf candidate \\( i \\) has already secured their victory, then let \\( C_i = 0 \\). If candidate \\( i \\) cannot secure their victory under any circumstances, then let \\( C_i = -1 \\).\n\n### Sample Input 1\n\n```\n5 2 16\n3 1 4 1 5\n```\n\n### Sample Output 1\n\n```\n2 -1 1 -1 0\n```\n\n14 votes have been counted so far, and 2 votes are left. The \\( C \\) to output is \\((2, -1, 1, -1, 0)\\). For example:\n- Candidate 1 can secure their victory by obtaining 2 more votes, while not by obtaining 1 more vote. Thus, \\( C_1 = 2 \\).\n- Candidate 2 can never (even if they obtain 2 more votes) secure their victory, so \\( C_2 = -1 \\).\n\n### Sample Input 2\n\n```\n12 1 570\n81 62 17 5 5 86 15 7 79 26 6 28\n```\n\n### Sample Output 2\n\n```\n79 89 111 117 117 74 112 116 80 107 117 106\n```\n\nSolution:\n\n```python\nfrom itertools import accumulate\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    rem = k - sum(a)\n\n    if n == m:\n        print(' '.join(['0'] * n))\n        return\n\n    ord = list(range(n))\n    ord.sort(key=lambda i: a[i])\n    b = sorted(a)\n    sumb = [0] + list(accumulate(b))\n\n    ans = [-1] * n\n    for i in range(n):\n        l, r = -1, rem + 1\n        while r - l > 1:\n            mid = (l + r) // 2\n            rid = next((idx for idx, val in enumerate(b) if val >= b[i] + mid + 1), n)\n            lid = n - m - (1 if i >= n - m else 0)\n            cnt = 0\n            if rid > lid:\n                cnt += (rid - lid) * (b[i] + mid + 1) - (sumb[rid] - sumb[lid])\n            if lid <= i < rid:\n                cnt -= 1\n            else:\n                cnt += mid\n            if cnt > rem:\n                r = mid\n            else:\n                l = mid\n        ans[ord[i]] = -1 if l == rem else r\n\n    print(' '.join(map(str, ans)))\n\nmain()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given two permutations \\( P = (P_1, P_2, \\dots, P_N) \\) and \\( Q = (Q_1, Q_2, \\dots, Q_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nWrite one of the characters '0' and '1' in each cell of an \\( N \\)-by-\\( N \\) grid so that all of the following conditions are satisfied:\n\n1. Let \\( S_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th row from the 1st to the \\( N \\)-th column. Then, \\( S_{P_1} < S_{P_2} < \\dots < S_{P_N} \\) in lexicographical order.\n\n2. Let \\( T_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th column from the 1st to the \\( N \\)-th row. Then, \\( T_{Q_1} < T_{Q_2} < \\dots < T_{Q_N} \\) in lexicographical order.\n\nIt can be proved that for any \\( P \\) and \\( Q \\), there is at least one way to write the characters that satisfies all the conditions.\n\n**Lexicographical Order Explanation:**\n\nFor strings \\( X = X_1 X_2 \\dots X_{|X|} \\) and \\( Y = Y_1 Y_2 \\dots Y_{|Y|} \\), \" \\( X < Y \\) in lexicographical order\" means that condition 1 or 2 below holds:\n\n1. \\( |X| < |Y| \\) and \\( X_1 X_2 \\ldots X_{|X|} = Y_1 Y_2 \\ldots Y_{|X|} \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\lbrace |X|, |Y| \\rbrace \\) such that both of the following are true:\n   - \\( X_1 X_2 \\ldots X_{i-1} = Y_1 Y_2 \\ldots Y_{i-1} \\)\n   - \\( X_i \\) is less than \\( Y_i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( P \\) and \\( Q \\) are permutations of \\( (1, 2, \\dots, N) \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n\n```\nN\nP_1 P_2 \\dots P_N\nQ_1 Q_2 \\dots Q_N\n```\n\n**Output:**\n\nPrint a way to fill the grid that satisfies the conditions in the following format, where \\( A_{ij} \\) is the character written at the \\( i \\)-th row and \\( j \\)-th column:\n\n```\nA_{11} A_{12} \\dots A_{1N}\n...\nA_{N1} A_{N2} \\dots A_{NN}\n```\n\nIf there are multiple ways to satisfy the conditions, any of them will be accepted.\n\n**Sample Input 1:**\n\n```\n3\n1 2 3\n2 1 3\n```\n\n**Sample Output 1:**\n\n```\n001\n101\n110\n```\n\nIn this sample, \\( S_1 = \\) \"001\", \\( S_2 = \\) \"101\", \\( S_3 = \\) \"110\", and \\( T_1 = \\) \"011\", \\( T_2 = \\) \"001\", \\( T_3 = \\) \"110\". Therefore, \\( S_1 < S_2 < S_3 \\) and \\( T_2 < T_1 < T_3 \\) hold, satisfying the conditions.\n\n**Sample Input 2:**\n\n```\n15\n8 15 10 2 4 3 1 13 5 12 9 6 14 11 7\n4 1 5 14 3 12 13 7 11 8 6 2 9 15 10\n```\n\n**Sample Output 2:**\n\n```\n010001111110101\n001000000101001\n010001001100010\n010000011110010\n010011101101101\n100101110100000\n111100011001000\n000001001100000\n100011011000101\n000111101011110\n101010101010101\n011010101011110\n010011000010011\n100110010110101\n000101101100100\n```\n\nSolution:\n\n```python\ndef fill_grid(N, P, Q):\n    grid = [[None] * N for _ in range(N)]\n\n    # Step 1: Write 0 in all cells of row P_1\n    for j in range(N):\n        grid[P[0]][j] = 0\n\n    # Step 2: Write 1 in all cells of column Q_N that are still empty\n    for i in range(N):\n        if grid[i][Q[N-1]] is None:\n            grid[i][Q[N-1]] = 1\n\n    # Recursive filling for remaining (N-1) x (N-1) cells\n    def fill_recursive(start, end, P, Q):\n        if start >= end:\n            return\n        # Write in row P[start]\n        for j in range(N):\n            if grid[P[start]][j] is None:\n                grid[P[start]][j] = 0\n        # Write in column Q[end]\n        for i in range(N):\n            if grid[i][Q[end]] is None:\n                grid[i][Q[end]] = 1\n        # Recurse on remaining subproblem\n        fill_recursive(start + 1, end - 1, P, Q)\n\n    fill_recursive(1, N-1, P, Q)\n\n    return grid\n\n# Example usage\nN = 3\nP = [0, 1, 2]  # Row order\nQ = [2, 1, 0]  # Column order\ngrid = fill_grid(N, P, Q)\nfor row in grid:\n    print(row)\n```\n\n**C - Row and Column Order Editorial by evima**\n\n**Solution**\n\n1. Write 0 in all cells of row \\(P_1\\).\n2. Write 1 in all cells of column \\(Q_N\\) that are still empty.\n3. For the remaining \\((N-1) \\times (N-1)\\) cells, let \\(S'_i\\) be the string obtained by concatenating row \\(i\\) excluding column \\(Q_N\\), and \\(T'_j\\) be the string obtained by concatenating column \\(j\\) excluding row \\(P_1\\). Then, recursively write in the same way so that \\(S'_{P_2} < S'_{P_3} < \\dots < S'_{P_N}\\) and \\(T'_{Q_2} < T'_{Q_3} < \\dots < T'_{Q_N}\\) hold.\n\nThe grid filled by this algorithm will satisfy the problem's conditions. Additionally, each column will contain at least one cell with 0, as 0 is always written in row \\(P_1\\). The lexicographical order of \\(S_{P_i}\\) and \\(T_{Q_i}\\) is maintained through recursive writing. The order of writing is \\(i=1,2,\\dots,N\\): first, write 0 in row \\(P_i\\) cells not yet written, then write 1 in column \\(Q_{N+1-i}\\) cells still empty.\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 575 points\n\nProblem Statement:\nThere are infinitely many cells on a plane. Each cell is defined by a pair of integers (x, y), referred to as cell(x, y). Each cell is either an empty cell or a wall cell.\n\nYou are given two sequences of positive integers of length N: L = (L_1, L_2, ..., L_N) and U = (U_1, U_2, ..., U_N). For each i (1 \u2264 i \u2264 N), it is guaranteed that 1 \u2264 L_i \u2264 U_i \u2264 10^9. All cells (x, y) where 1 \u2264 x \u2264 N and L_x \u2264 y \u2264 U_x are empty cells, and all others are wall cells.\n\nTakahashi can move between empty cells by the following actions:\n- If cell (x+1, y) is an empty cell, move to cell (x+1, y).\n- If cell (x-1, y) is an empty cell, move to cell (x-1, y).\n- If cell (x, y+1) is an empty cell, move to cell (x, y+1).\n- If cell (x, y-1) is an empty cell, move to cell (x, y-1).\n\nIt is guaranteed that any two empty cells can be connected through a sequence of movements.\n\nYou are tasked to answer Q queries. For the i-th query (1 \u2264 i \u2264 Q), you are given four integers (s_x[i], s_y[i], t_x[i], t_y[i]). Your task is to find the minimum number of actions required for Takahashi to move from cell(s_x[i], s_y[i]) to cell(t_x[i], t_y[i]). You can assume that both of these cells are empty.\n\nConstraints:\n- 1 \u2264 N \u2264 2 \u00d7 10^5\n- 1 \u2264 L_i \u2264 U_i \u2264 10^9 for each i (1 \u2264 i \u2264 N)\n- The ranges [L_i, U_i] and [L_{i+1}, U_{i+1}] overlap for all 1 \u2264 i < N\n- 1 \u2264 Q \u2264 2 \u00d7 10^5\n- 1 \u2264 s_x[i], t_x[i] \u2264 N, and L_{s_x[i]} \u2264 s_y[i] \u2264 U_{s_x[i]}, L_{t_x[i]} \u2264 t_y[i] \u2264 U_{t_x[i]}\n\nInput:\nThe input is given in the following format:\n```\nN\nL_1 U_1\nL_2 U_2\n...\nL_N U_N\nQ\ns_x[1] s_y[1] t_x[1] t_y[1]\ns_x[2] s_y[2] t_x[2] t_y[2]\n...\ns_x[Q] s_y[Q] t_x[Q] t_y[Q]\n```\n\nOutput:\nPrint Q lines. The i-th line should contain the answer to the i-th query.\n\nExample:\nInput:\n```\n7\n1 5\n3 3\n1 3\n1 1\n1 4\n2 4\n3 5\n3\n1 4 6 3\n1 4 1 1\n7 5 1 5\n```\n\nOutput:\n```\n10\n3\n14\n```\n\nExample:\nInput:\n```\n12\n1 1000000000\n1000000000 1000000000\n1 1000000000\n1 1\n1 1000000000\n1000000000 1000000000\n1 1000000000\n1 1\n1 1000000000\n1000000000 1000000000\n1 1000000000\n1 1\n1\n1 1 12 1\n```\n\nOutput:\n```\n6000000005\n```\n\nThe output may exceed a 32-bit integer.\n\nSolution:\n\n```python\nimport sys\nfrom atcoder.segtree import SegTree\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    class Block:\n        def __init__(self, fL, fU, gL, gU, C):\n            self.fL = fL\n            self.fU = fU\n            self.gL = gL\n            self.gU = gU\n            self.C = C\n\n        def __call__(self, y):\n            clamped_y = max(self.fL, min(self.fU, y))\n            cost = self.C + max(0, self.gL - y, y - self.gU)\n            return clamped_y, cost\n\n    def op(lhs, rhs):\n        new_fL = max(rhs.fL, min(rhs.fU, lhs.fL))\n        new_fU = max(rhs.fL, min(rhs.fU, lhs.fU))\n        new_gL = max(lhs.gL, min(lhs.gU, rhs.gL))\n        new_gU = max(lhs.gL, min(lhs.gU, rhs.gU))\n        new_C = lhs.C + rhs(lhs(new_gU)[0])[1]\n        return Block(new_fL, new_fU, new_gL, new_gU, new_C)\n\n    def e():\n        return Block(0, 1000000001, 0, 1000000001, 0)\n\n    data_ptr = 0\n    N = int(data[data_ptr])\n    data_ptr += 1\n    intervals = []\n    for _ in range(N):\n        L = int(data[data_ptr])\n        U = int(data[data_ptr + 1])\n        data_ptr += 2\n        intervals.append(Block(L, U, L, U, 1))\n\n    seg_tree = SegTree(op, e, intervals)\n\n    Q = int(data[data_ptr])\n    data_ptr += 1\n    result = []\n    for _ in range(Q):\n        sx = int(data[data_ptr])\n        sy = int(data[data_ptr + 1])\n        tx = int(data[data_ptr + 2])\n        ty = int(data[data_ptr + 3])\n        data_ptr += 4\n\n        if sx > tx:\n            sx, tx = tx, sx\n            sy, ty = ty, sy\n\n        out, cost = seg_tree.prod(sx, tx)(sy)\n        result.append(str(max(out, ty) - min(out, ty) + cost))\n\n    sys.stdout.write(\"\\n\".join(result) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc373_e", "arc181_c", "abc365_f"]}, "abc302_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a string \\( S \\) consisting of lowercase English letters and periods (`.`). Your task is to find the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Constraints**\n\n- \\( S \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters and periods (`.`).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\( S \\)\n\n**Output**\n\nPrint the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Sample Input 1**\n\n```\n.v.\n```\n\n**Sample Output 1**\n\n```\nv\n```\n\nRemoving all periods (`.`) from `.v.` yields `v`, so we print `v`.\n\n**Sample Input 2**\n\n```\nchokudai\n```\n\n**Sample Output 2**\n\n```\nchokudai\n```\n\nThere are cases where \\( S \\) does not contain periods (`.`).\n\n**Sample Input 3**\n\n```\n...\n```\n\n**Sample Output 3**\n\n```\n\n```\n\nThere are also cases where all characters in \\( S \\) are periods (`.`).\n\nSolution:\n\n```python\n# Python equivalent of C++ code\n\n# Standard implementation\n\nS = input()\nT = \"\"\nfor c in S:\n    if c != '.':\n        T += c\nprint(T)\n\n# Concise implementation\n\nS = input()\nS = S.replace('.', '')\nprint(S)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an \\( N \\times N \\) integer matrix \\( A = (A_{i,j})_{1 \\leq i \\leq N, 1 \\leq j \\leq N} \\) and an integer \\( M \\).\n\nFor an integer sequence \\( x = (x_1, x_2, \\cdots, x_M) \\) of length \\( M \\), consisting of integers between \\( 1 \\) and \\( N \\), inclusive, define \\( f(x) \\) as follows:\n\n- Let \\( y = (y_1, y_2, \\cdots, y_M) \\) be the sequence obtained by sorting the elements of \\( x \\) to be non-decreasing.\n- Define \\( f(x) = \\prod_{1 \\leq i \\leq M} A_{x_i, y_i} \\).\n\nFor each \\( k = 1, 2, \\cdots, N \\), solve the following problem:\n\n- Find the sum of \\( f(x) \\) over all sequences \\( x \\) satisfying \\( x_1 = k \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 50 \\)\n- \\( 1 \\leq M \\leq 50 \\)\n- \\( 0 \\leq A_{i,j} < 998244353 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1,1} A_{1,2} \\cdots A_{1,N}\nA_{2,1} A_{2,2} \\cdots A_{2,N}\n\\vdots\nA_{N,1} A_{N,2} \\cdots A_{N,N}\n```\n\n**Output**\n\nPrint the answer for each \\( k = 1, 2, \\cdots, N \\) in this order.\n\n**Sample Input 1**\n\n```\n2 2\n1 2\n3 4\n```\n\n**Sample Output 1**\n\n```\n5 22\n```\n\nAll possible \\( x \\) and the corresponding values of \\( f(x) \\) are as follows:\n- \\( x = (1, 1): y = (1, 1), f(x) = A_{1,1} \\times A_{1,1} = 1 \\)\n- \\( x = (1, 2): y = (1, 2), f(x) = A_{1,1} \\times A_{2,2} = 4 \\)\n- \\( x = (2, 1): y = (1, 2), f(x) = A_{2,1} \\times A_{1,2} = 6 \\)\n- \\( x = (2, 2): y = (2, 2), f(x) = A_{2,2} \\times A_{2,2} = 16 \\)\n\nThus, the answer is \\( 1 + 4 = 5 \\) for \\( k = 1 \\), and \\( 6 + 16 = 22 \\) for \\( k = 2 \\).\n\n**Sample Input 2**\n\n```\n2 3\n1 2\n3 4\n```\n\n**Sample Output 2**\n\n```\n27 118\n```\n\n**Sample Input 3**\n\n```\n5 4\n785439575 250040585 709423541 945005786 19237225\n404191279 250876592 22672563 519729086 344065186\n273714212 560047125 139793596 542901248 520999410\n855572558 498896932 418633758 742973826 248730678\n238856535 319502970 908902333 164543594 245101681\n```\n\n**Sample Output 3**\n\n```\n216530400 726773157 717209375 797938347 957133905\n```\n\n**Sample Input 4**\n\n```\n10 50\n197971506 714635866 966125570 768080799 80565655 459117401 256810168 775681305 582857561 948631706\n437330820 321722967 531470304 255908811 45459908 504089816 695016247 91058795 905527130 30860430\n151769562 979797105 619322493 298241991 360690308 480124392 297323928 284686636 922571073 627798362\n753705854 712639027 721488863 69714419 485979799 88704853 758288417 423073188 595934547 86264514\n272481811 622712481 221745114 225051881 433378197 985573661 210619166 851716760 283615535 834897126\n366075547 933505674 858395194 490049033 22039836 361481447 735151983 518458804 422209788 28981946\n907645400 111982636 978445563 686621115 486475154 734616351 587635888 527524079 454844580 826849288\n868863954 490627044 967828344 887235558 138021910 435784230 343307056 118718683 547282350 757693154\n32344652 101428952 585897722 693817619 790433406 848494439 873744405 604427602 951889915 989125209\n865548541 642980476 603592935 911086893 466178404 79002814 902745597 825893950 147052664 805753279\n```\n\n**Sample Output 4**\n\n```\n862518623 606960987 762676180 606184511 762408948 47716007 968649097 788324707 140177479 484063588\n```\n\nSolution:\n\n[BEGIN TEXT]\nOfficial Solution:\n\nPrepare \\(N\\) vertices and draw edges \\(y_i \\to x_i\\). In this graph, the out-degree and in-degree of each vertex are equal, and outgoing edges have a determined order for each vertex. Start at vertex \\(1\\) and traverse edges, choosing the next edge based on this order. This traversal ends at vertex \\(1\\), using all edges touching it. Repeat from vertices \\(2, 3, \\cdots, N\\) to use all edges. Solve for the number of ways to traverse by using dynamic programming: \\(dp[i][j]\\) is the number of ways to reach vertex \\(i\\) after \\(j\\) edges. Consider \\(x_1\\) as the first edge destination. Trying all \\(N\\) choices involves solving \\(N\\) similar problems, which can be optimized by reversing the movement order. The complexity is \\(O(N^3 M)\\).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given two permutations \\( P = (P_1, P_2, \\dots, P_N) \\) and \\( Q = (Q_1, Q_2, \\dots, Q_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nWrite one of the characters '0' and '1' in each cell of an \\( N \\)-by-\\( N \\) grid so that all of the following conditions are satisfied:\n\n1. Let \\( S_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th row from the 1st to the \\( N \\)-th column. Then, \\( S_{P_1} < S_{P_2} < \\dots < S_{P_N} \\) in lexicographical order.\n\n2. Let \\( T_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th column from the 1st to the \\( N \\)-th row. Then, \\( T_{Q_1} < T_{Q_2} < \\dots < T_{Q_N} \\) in lexicographical order.\n\nIt can be proved that for any \\( P \\) and \\( Q \\), there is at least one way to write the characters that satisfies all the conditions.\n\n**Lexicographical Order Explanation:**\n\nFor strings \\( X = X_1 X_2 \\dots X_{|X|} \\) and \\( Y = Y_1 Y_2 \\dots Y_{|Y|} \\), \" \\( X < Y \\) in lexicographical order\" means that condition 1 or 2 below holds:\n\n1. \\( |X| < |Y| \\) and \\( X_1 X_2 \\ldots X_{|X|} = Y_1 Y_2 \\ldots Y_{|X|} \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\lbrace |X|, |Y| \\rbrace \\) such that both of the following are true:\n   - \\( X_1 X_2 \\ldots X_{i-1} = Y_1 Y_2 \\ldots Y_{i-1} \\)\n   - \\( X_i \\) is less than \\( Y_i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( P \\) and \\( Q \\) are permutations of \\( (1, 2, \\dots, N) \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n\n```\nN\nP_1 P_2 \\dots P_N\nQ_1 Q_2 \\dots Q_N\n```\n\n**Output:**\n\nPrint a way to fill the grid that satisfies the conditions in the following format, where \\( A_{ij} \\) is the character written at the \\( i \\)-th row and \\( j \\)-th column:\n\n```\nA_{11} A_{12} \\dots A_{1N}\n...\nA_{N1} A_{N2} \\dots A_{NN}\n```\n\nIf there are multiple ways to satisfy the conditions, any of them will be accepted.\n\n**Sample Input 1:**\n\n```\n3\n1 2 3\n2 1 3\n```\n\n**Sample Output 1:**\n\n```\n001\n101\n110\n```\n\nIn this sample, \\( S_1 = \\) \"001\", \\( S_2 = \\) \"101\", \\( S_3 = \\) \"110\", and \\( T_1 = \\) \"011\", \\( T_2 = \\) \"001\", \\( T_3 = \\) \"110\". Therefore, \\( S_1 < S_2 < S_3 \\) and \\( T_2 < T_1 < T_3 \\) hold, satisfying the conditions.\n\n**Sample Input 2:**\n\n```\n15\n8 15 10 2 4 3 1 13 5 12 9 6 14 11 7\n4 1 5 14 3 12 13 7 11 8 6 2 9 15 10\n```\n\n**Sample Output 2:**\n\n```\n010001111110101\n001000000101001\n010001001100010\n010000011110010\n010011101101101\n100101110100000\n111100011001000\n000001001100000\n100011011000101\n000111101011110\n101010101010101\n011010101011110\n010011000010011\n100110010110101\n000101101100100\n```\n\nSolution:\n\n```python\ndef fill_grid(N, P, Q):\n    grid = [[None] * N for _ in range(N)]\n\n    # Step 1: Write 0 in all cells of row P_1\n    for j in range(N):\n        grid[P[0]][j] = 0\n\n    # Step 2: Write 1 in all cells of column Q_N that are still empty\n    for i in range(N):\n        if grid[i][Q[N-1]] is None:\n            grid[i][Q[N-1]] = 1\n\n    # Recursive filling for remaining (N-1) x (N-1) cells\n    def fill_recursive(start, end, P, Q):\n        if start >= end:\n            return\n        # Write in row P[start]\n        for j in range(N):\n            if grid[P[start]][j] is None:\n                grid[P[start]][j] = 0\n        # Write in column Q[end]\n        for i in range(N):\n            if grid[i][Q[end]] is None:\n                grid[i][Q[end]] = 1\n        # Recurse on remaining subproblem\n        fill_recursive(start + 1, end - 1, P, Q)\n\n    fill_recursive(1, N-1, P, Q)\n\n    return grid\n\n# Example usage\nN = 3\nP = [0, 1, 2]  # Row order\nQ = [2, 1, 0]  # Column order\ngrid = fill_grid(N, P, Q)\nfor row in grid:\n    print(row)\n```\n\n**C - Row and Column Order Editorial by evima**\n\n**Solution**\n\n1. Write 0 in all cells of row \\(P_1\\).\n2. Write 1 in all cells of column \\(Q_N\\) that are still empty.\n3. For the remaining \\((N-1) \\times (N-1)\\) cells, let \\(S'_i\\) be the string obtained by concatenating row \\(i\\) excluding column \\(Q_N\\), and \\(T'_j\\) be the string obtained by concatenating column \\(j\\) excluding row \\(P_1\\). Then, recursively write in the same way so that \\(S'_{P_2} < S'_{P_3} < \\dots < S'_{P_N}\\) and \\(T'_{Q_2} < T'_{Q_3} < \\dots < T'_{Q_N}\\) hold.\n\nThe grid filled by this algorithm will satisfy the problem's conditions. Additionally, each column will contain at least one cell with 0, as 0 is always written in row \\(P_1\\). The lexicographical order of \\(S_{P_i}\\) and \\(T_{Q_i}\\) is maintained through recursive writing. The order of writing is \\(i=1,2,\\dots,N\\): first, write 0 in row \\(P_i\\) cells not yet written, then write 1 in column \\(Q_{N+1-i}\\) cells still empty.\n\n \n\n", "problem_ids": ["abc372_a", "agc068_e", "arc181_c"]}, "abc302_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( A_1, A_2, A_3 \\). Find the number of tuples of positive integers \\( (X_1, X_2, X_3) \\) that satisfy all of the following conditions, modulo \\( 998244353 \\):\n\n1. \\( X_1 \\) is a positive integer with \\( A_1 \\) digits in decimal notation.\n2. \\( X_2 \\) is a positive integer with \\( A_2 \\) digits in decimal notation.\n3. \\( X_3 \\) is a positive integer with \\( A_3 \\) digits in decimal notation.\n4. \\( X_1 + X_2 = X_3 \\).\n\nYou are given \\( T \\) test cases per input file; solve each of them.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\) for \\( i = 1, 2, 3 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is provided from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach case is given in the following format:\n\n```\nA_1 A_2 A_3\n```\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for \\( case_i \\).\n\n**Sample Input 1**\n\n```\n4\n1 1 1\n1 6 7\n167 167 167\n111 666 777\n```\n\n**Sample Output 1**\n\n```\n36\n45\n731780675\n0\n```\n\n- For the first case, tuples such as \\( (X_1, X_2, X_3) = (1, 6, 7), (2, 1, 3) \\) satisfy the conditions. On the other hand, tuples such as \\( (X_1, X_2, X_3) = (6, 7, 13), (3, 4, 5) \\) do not. There are 36 tuples \\( (X_1, X_2, X_3) \\) that satisfy the conditions, so print 36.\n- For the third case, remember to print the result modulo 998244353.\n- For the fourth case, there may be no tuples \\( (X_1, X_2, X_3) \\) that satisfy the conditions.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nB - 1 + 6 = 7 Editorial by evima\n\nWe aim to find the number of pairs of integers \\((X_{1}, X_{2})\\) satisfying:\n\n\\(10^{A_{1} - 1} \\leq X_{1}\\)\n\n\\(10^{A_{2}-1} \\leq X_{2}\\)\n\n\\(X_{1} + X_{2} < 10^{A_{3}}\\)\n\n\\(10^{A_{1}} \\leq X_{1}\\) does not hold.\n\n\\(10^{A_{2}} \\leq X_{2}\\) does not hold.\n\n\\(X_{1} + X_{2} < 10^{A_{3}-1}\\) does not hold.\n\nUsing the inclusion-exclusion principle, the answer can be expressed as:\n\\[\\sum_{i=0}^{1}\\sum_{j=0}^{1}\\sum_{k=0}^{1}f(A_{1} - i, A_{2} - j, A_{3} - k)(-1)^{i+j+k} \\]\n\nFor \\(f(B_{1}, B_{2}, B_{3})\\):\n\nIf \\(B_{3} \\leq \\max(B_{1}, B_{2})\\), \\(f(B_{1}, B_{2}, B_{3}) = 0\\).\n\nIf \\(B_{3} > \\max(B_{1}, B_{2})\\), \\(f(B_{1}, B_{2}, B_{3}) = \\dfrac{(10^{B_{3}}-10^{B_{1}}-10^{B_{2}})(10^{B_{3}}-10^{B_{1}}-10^{B_{2}} + 1)}{2}\\).\n\nThis computation can be done in \\(O(\\log(A_{3}))\\) time per test case.\n\nPython Implementation Example:\n```python\nMOD = 998244353\n\ndef f(b1, b2, b3):\n    if max(b1, b2) >= b3:\n        return 0\n    tmp = pow(10, b3, MOD) - pow(10, b1, MOD) - pow(10, b2, MOD)\n    return (tmp + 1) * tmp // 2\n\nT = int(input())\nfor _ in range(T):\n    a1, a2, a3 = map(int, input().split())\n    ans = 0\n    pm = 1\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                ans = (ans + f(a1 - i, a2 - j, a3 - k) * pm) % MOD\n                pm *= -1\n            pm *= -1\n        pm *= -1\n    print(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi is heading to AtCoder Land. There is a signboard in front of him, and he wants to determine whether it says \"AtCoder Land.\"\n\nYou are given two strings \\( S \\) and \\( T \\) separated by a space. Determine whether \\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of uppercase and lowercase English letters, with lengths between 1 and 10, inclusive.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nIf \\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\), print \"Yes\"; otherwise, print \"No\".\n\n**Sample Input 1**\n```\nAtCoder Land\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n\\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\).\n\n**Sample Input 2**\n```\nCodeQUEEN Land\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n\\( S \\) is not \"AtCoder\".\n\n**Sample Input 3**\n```\naTcodeR lANd\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nUppercase and lowercase letters are distinguished.\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nIf you are new to learning programming, try Problem A \u201cWelcome to AtCoder\u201d from the practice contest, which provides sample code for each language. Also, explore the \u201cAtCoder Beginners Selection\u201d for more practice problems.\n\nReceive two strings as input, and implement a conditional branch to print the answer. In the conditional expression, compare strings and evaluate the logical sum of two conditions. Refer to the sample code below.\n\nSample code (Python):\n```python\ns, t = input().split()\nif s == \"AtCoder\" and t == \"Land\":\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given positive integers \\( N \\) and \\( L \\), and a sequence of positive integers \\( A = (A_{1}, A_{2}, \\dots, A_{N}) \\) of length \\( N \\).\n\nFor each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nDetermine if there exists a sequence of \\( L \\) non-negative integers \\( B = (B_{1}, B_{2}, \\dots, B_{L}) \\) such that:\n\n\\[\n\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = A_{i}\n\\]\n\nIf it exists, find the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^{5} \\)\n- \\( 2 \\leq L \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq A_{i} \\leq 2 \\times 10^{5} \\)\n\nAll input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN L\nA_{1} A_{2} \\cdots A_{N}\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain \\(-1\\) if no sequence \\( B \\) satisfies the condition for \\( i = k \\); otherwise, it should contain the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Sample Input 1:**\n\n```\n2 4\n10 5\n```\n\n**Sample Output 1:**\n\n```\n3\n-1\n```\n\n*Explanation*:\n- For \\( A_{1} = 10 \\), if we take \\( B = (1, 0, 2, 3) \\), then \\(\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = 10\\), where \\( \\max(B) = 3 \\). No non-negative integer sequence \\( B \\) satisfies the condition with \\( \\max(B) < 3 \\), so print 3 in the first line.\n- For \\( A_{2} = 5 \\), there is no non-negative integer sequence \\( B \\) that satisfies the condition, so print -1 in the second line.\n\n**Sample Input 2:**\n\n```\n6 8\n167 924 167167 167924 116677 154308\n```\n\n**Sample Output 2:**\n\n```\n11\n58\n10448\n10496\n7293\n9645\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 178\n\nC - Sum of Abs 2 Editorial by evima\n\nIn this explanation, the \u201csum of abs\u201d refers to the following formula: \n\\[\\sum_{j=1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}|\\]\n\nWhen \\(B\\) exists, one \\(B\\) that minimizes \\(\\max(B)\\) satisfies the following two conditions:\n- \\(B\\) is sorted in ascending order.\n- \\(B_{1} = 0\\).\n\nThe sum of abs does not depend on the order of \\(B\\). If all elements of \\(B\\) are positive, subtracting \\(1\\) from all elements can reduce \\(\\max(B)\\) without changing the sum of abs. When \\(B\\) is sorted in ascending order, the sum of abs can be expressed as follows: \n\\[\\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}| = \\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} (B_{k} - B_{j}) =\\sum_{k = 1} ^ {L - 1} k(L - k)(B_{k + 1} - B_{k})\\]\n\nThis transformation is correct because \\(B_{a}-B_{b}=(B_{a}-B_{a-1}) + (B_{a-1}+B_{a-2}) + \\cdots +(B_{b+1}-B_{b})\\) for integers \\(a, b\\) satisfying \\(1\\leq b<a\\leq L\\), and the number of pairs \\((a, b)\\) satisfying \\(b\\leq k\\) and \\(k+1\\leq a\\) is \\(k(L-k)\\).\n\nIf we let \\(C_{k} = B_{k + 1} - B_{k}\\), then when \\(B\\) is sorted in ascending order and \\(B_{1} = 0\\), the following holds:\n- \\(0 \\leq C_{k}\\).\n- The sum of abs is equal to \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}\\).\n- \\(\\displaystyle\\max(B) = B_{L} = \\sum_{k = 1} ^ {L - 1} C_{k}\\).\n\nTherefore, we need to solve the following problem: Determine if there exists a sequence of non-negative integers \\(C\\) of length \\(L - 1\\) such that \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}  = A_{i}\\), and if it exists, find the minimum sum of such \\(C\\).\n\nThis can be solved using dynamic programming in the same manner as the knapsack problem, and it can be computed simultaneously for all \\(i\\). Since \\(C_{k} = 0\\) always holds for \\(k\\) satisfying \\(\\max(A)<k(L-k)\\), our solution has a space complexity of \\(O(\\max(A))\\) and a time complexity of \\(O(N + \\max(A)\\sqrt{\\max(A)})\\).\n\nPython implementation example:\n\n```python\nN, L = map(int, input().split())\nA = list(map(int, input().split()))\n\nM = 2 * 10 ** 5\nINF = 10 ** 9\ndp = [INF] * (M + 1)\ndp[0] = 0\nk = 1\n\nwhile k * (L - k) <= M and k * 2 <= L:\n    w = k * (L - k)\n    for i in range(w, M + 1):\n        dp[i] = min(dp[i], dp[i - w] + 1)\n    k += 1\n\nfor a in A:\n    print(-1 if dp[a] == INF else dp[a])\n``` \n```\n \n\n", "problem_ids": ["arc178_b", "abc358_a", "arc178_c"]}, "abc302_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree with \\( N \\) vertices. The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally. Additionally, you are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\).\n\nDefine \\( f(i, j) \\) as follows:\n\n- If \\( A_i = A_j \\), then \\( f(i, j) \\) is the minimum number of edges needed to traverse from vertex \\( i \\) to vertex \\( j \\).\n- If \\( A_i \\neq A_j \\), then \\( f(i, j) = 0 \\).\n\nCalculate the value of the following expression:\n\n\\[\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(i,j)\n\\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- The input graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nu_1 v_1\n...\nu_{N-1} v_{N-1}\nA_1 A_2 ... A_N\n```\n\n**Output**\n\nPrint the computed answer.\n\n**Sample Input 1**\n\n```\n4\n3 4\n4 2\n1 2\n2 1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nExplanation: \\( f(1,4)=2, f(2,3)=2 \\). For all other \\( i, j \\) \\((1 \\leq i < j \\leq N)\\), we have \\( f(i,j)=0 \\), so the answer is \\( 2+2=4 \\).\n\n**Sample Input 2**\n\n```\n8\n8 6\n3 8\n1 4\n7 8\n4 5\n3 4\n8 2\n1 2 2 2 3 1 1 3\n```\n\n**Sample Output 2**\n\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nApplying the centroid decomposition, it is sufficient to find the answer for paths passing through the root. We consider two cases depending on whether the endpoint of the path is the root or not. If it is root, one can naively perform BFS (Breadth-First Search). Otherwise, for each vertex \\(v\\), count how many times the path between vertex \\(v\\) and the root contributes to the answer. Let \\(c_1,\\ldots,c_k\\) be the children of the root, and suppose that vertex \\(v\\) is contained in the subtree \\(c_i\\). Then, the number of times the path between vertex \\(v\\) and the root contributes to the answer is found as (the number of vertices \\(u\\) contained in the current tree such that \\(A_v = A_u\\)) - (the number of vertices \\(u\\) in the subtree \\(c_i\\) such that \\(A_v = A_u\\)). The values required can all be found using a DFS (Depth-First Search), so the problem has been solved.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nYou will perform the following operation exactly once:\n\n- Choose a non-empty subsequence of \\( A \\) (not necessarily contiguous) and replace it with its cumulative sums.\nMore precisely, first choose a sequence of indices \\( (i_1, i_2, \\ldots, i_k) \\) such that \\( 1 \\leq i_1 < i_2 < \\cdots < i_k \\leq N \\).\n  The length of the sequence \\( k \\) (\\( 1 \\leq k \\leq N \\)) can be chosen freely.\n  Then, for each \\( j \\) (\\( 1 \\leq j \\leq k \\)), replace the value of \\( A_{i_j} \\) with \\( \\sum_{1 \\leq x \\leq j} A_{i_x} \\).\n  This replacement is done simultaneously for all chosen indices.\n\nFind, modulo \\( 10^9 + 7 \\), the number of possible sequences \\( A \\) after the operation.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\(-10 \\leq A_i \\leq 10 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\[\nN \\\\\nA_1\\ A_2\\ \\cdots\\ A_N\n\\]\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n3\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nThe possible sequences \\( A \\) after the operation are as follows:\n- \\( A = (1, 1, 2) \\): This can be achieved with \\( k = 1 \\) and \\( (i_1) = (1) \\).\n- \\( A = (1, 2, 2) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 2) \\).\n- \\( A = (1, 1, 3) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 3) \\).\n- \\( A = (1, 2, 4) \\): This can be achieved with \\( k = 3 \\) and \\( (i_1, i_2, i_3) = (1, 2, 3) \\).\n\n**Sample Input 2**\n\n```\n4\n1 -1 1 -1\n```\n\n**Sample Output 2**\n\n```\n8\n```\n\n**Sample Input 3**\n\n```\n5\n0 0 0 0 0\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\n**Sample Input 4**\n\n```\n40\n2 -2 1 3 -3 -1 -2 -3 0 -1 -2 0 -3 0 0 2 0 -1 2 -2 -2 -1 3 -2 -2 -2 2 3 2 -3 0 -2 2 1 3 0 -1 0 -2 -3\n```\n\n**Sample Output 4**\n\n```\n420429545\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Regular Contest 180\n\nC - Subsequence and Prefix Sum Editorial by evima\n\nConsider the following DP: \\(dp[i][j]=\\) The number of ways to perform the operation on the first \\(i\\) terms so that \\(A_i\\) changes to \\(A_i+j\\) (\\(j \\neq 0\\)). Because \\(j \\neq 0\\), the operation counted in \\(dp[i][j]\\) always selects \\(A_i\\) for the operation. The next term will increase by \\(A_i+j\\). The transition for \\(A_i+j \\neq 0\\) is straightforward. For \\(A_i+j=0\\), let \\(A_k\\) be the next term to change. To change \\(A_k \\to A_k+v\\), select \\(v\\) from \\(A_{i+1},\\cdots,A_{k-1}\\). Implementing these covers all transitions. This problem can be solved in \\(O(N^3 \\max(|A_i|))\\) time.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). Takahashi will perform the following operation exactly once:\n\n- Choose an integer \\( x \\) between 1 and \\( N \\), inclusive, and an arbitrary integer \\( y \\). Replace \\( A_x \\) with \\( y \\).\n\nFind the maximum possible length of a longest increasing subsequence (LIS) of \\( A \\) after performing the operation.\n\n**What is the longest increasing subsequence?**\n\nA subsequence of a sequence \\( A \\) is a sequence that can be derived from \\( A \\) by extracting some elements without changing the order.\n\nA longest increasing subsequence of a sequence \\( A \\) is a longest subsequence of \\( A \\) that is strictly increasing.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n\n```\n4\n3 2 2 4\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n*Explanation:*\n\nThe length of a LIS of the given sequence \\( A \\) is 2. For example, if you replace \\( A_1 \\) with 1, the length of a LIS of \\( A \\) becomes 3, which is the maximum.\n\n**Sample Input 2:**\n\n```\n5\n4 5 3 6 7\n```\n\n**Sample Output 2:**\n\n```\n4\n```\n\nSolution:\n\n```python\nimport sys\n\nclass RangeMaxSegmentTree:\n    def __init__(self, size, initial_value):\n        self.size = size\n        self.data = [initial_value] * (2 * size)\n        self.initial_value = initial_value\n\n    def update(self, index, value):\n        index += self.size\n        self.data[index] = value\n        while index > 1:\n            index //= 2\n            self.data[index] = max(self.data[2 * index], self.data[2 * index + 1])\n\n    def calc_max(self, left, right):\n        left += self.size\n        right += self.size\n        max_value = self.initial_value\n        while left < right:\n            if left % 2 == 1:\n                max_value = max(max_value, self.data[left])\n                left += 1\n            if right % 2 == 1:\n                right -= 1\n                max_value = max(max_value, self.data[right])\n            left //= 2\n            right //= 2\n        return max_value\n\ndef longest_increasing_subsequence(A):\n    N = len(A)\n    dp = [[-float('inf')] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, N + 1):\n        max_value = 0\n        for j in range(0, A[i-1]):\n            max_value = max(max_value, dp[i - 1][j])\n        dp[i][A[i-1]] = max_value + 1\n\n    max_lis_length = max(dp[N])\n    return max_lis_length\n\ndef longest_increasing_subsequence_with_segment_tree(A):\n    N = len(A)\n    dp = RangeMaxSegmentTree(N + 1, -float('inf'))\n    dp.update(0, 0)\n\n    for i in range(1, N + 1):\n        max_for_ai = dp.calc_max(0, A[i-1])\n        dp.update(A[i-1], max_for_ai + 1)\n\n    max_lis_length = max(dp.data[N + 1:])\n    return max_lis_length\n\n# Example array A for testing purposes\nA = [3, 10, 2, 1, 20]\nprint(\"LIS length using DP:\", longest_increasing_subsequence(A))\nprint(\"LIS length using segment tree:\", longest_increasing_subsequence_with_segment_tree(A))\n```\n\n \n\n", "problem_ids": ["abc359_g", "arc180_c", "abc360_g"]}, "abc302_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two strings, \\( S \\) and \\( T \\), consisting of lowercase English letters. Determine if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the following condition is satisfied. Here, \\( |S| \\) denotes the length of the string \\( S \\). Note that \\( w \\) must be less than \\( |S| \\).\n\n- If \\( S \\) is split at every \\( w \\) characters from the beginning, the concatenation of the \\( c \\)-th characters of the substrings of length at least \\( c \\) in order equals \\( T \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters.\n- \\( 1 \\leq |T| \\leq |S| \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nPrint `Yes` if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the condition is satisfied, and `No` otherwise.\n\n**Sample Input 1**\n```\natcoder toe\n```\n\n**Sample Output 1**\n```\nYes\n```\n\nExplanation: If \\( S \\) is split at every two characters, it looks like this:\n```\nat\nco\nde\nr\n```\nThen, the concatenation of the 2nd characters of the substrings of length at least 2 is `toe`, which equals \\( T \\). Thus, print `Yes`.\n\n**Sample Input 2**\n```\nbeginner r\n```\n\n**Sample Output 2**\n```\nNo\n```\n\nExplanation: \\( w = |S| \\) is not allowed, and no pair of integers \\( 1 \\leq c \\leq w < |S| \\) satisfies the condition. Thus, print `No`.\n\n**Sample Input 3**\n```\nverticalreading agh\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        Below is a clean version of the text with only the relevant solution details:\n\nEnumerate all possible \\(c\\) and \\(w\\), and determine if a conforming pair \\(c,w\\) exists. One can construct a string for \\(c\\) and \\(w\\) using a for statement and concatenation of strings. For more details, please refer to the sample code.\n\nSample code (Python 3):\n\n```python\ndef main():\n    s = input().strip()\n    t = input().strip()\n    for w in range(1, len(s)):\n        for c in range(w):\n            now = \"\"\n            for i in range(c, len(s), w):\n                now += s[i]\n            if now == t:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou have 12 strings \\( S_1, S_2, \\ldots, S_{12} \\) consisting of lowercase English letters. Determine how many integers \\( i \\) (where \\( 1 \\leq i \\leq 12 \\)) satisfy the condition that the length of the string \\( S_i \\) is exactly \\( i \\).\n\n**Constraints:**\n\n- Each \\( S_i \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters for \\( 1 \\leq i \\leq 12 \\).\n\n**Input:**\n\nThe input consists of 12 lines, where each line contains a single string representing \\( S_1, S_2, \\ldots, S_{12} \\).\n\n**Output:**\n\nPrint the number of integers \\( i \\) (where \\( 1 \\leq i \\leq 12 \\)) such that the length of \\( S_i \\) is \\( i \\).\n\n**Sample Input 1:**\n\n```\njanuary\nfebruary\nmarch\napril\nmay\njune\njuly\naugust\nseptember\noctober\nnovember\ndecember\n```\n\n**Sample Output 1:**\n\n```\n1\n```\n\nExplanation: There is only one integer \\( i \\) such that the length of \\( S_i \\) is \\( i \\): 9. Thus, print 1.\n\n**Sample Input 2:**\n\n```\nve\ninrtfa\nnpccxva\ndjiq\nlmbkktngaovl\nmlfiv\nfmbvcmuxuwggfq\nqgmtwxmb\njii\nts\nbfxrvs\neqvy\n```\n\n**Sample Output 2:**\n\n```\n2\n```\n\nExplanation: There are two integers \\( i \\) such that the length of \\( S_i \\) is \\( i \\): 4 and 8. Thus, print 2.\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 373\n\nThis problem requires the usage of a for statement and the retrieval of the length of a string. Use a for statement to repeat the operation for \\(i=1,2,\\ldots, 12\\):\n\n1. Read a string.\n2. If its length equals \\(i\\), add \\(1\\) to the answer.\n\nTo implement this, use the appropriate function for string length retrieval provided by your programming language. In C++, a string type is represented by `std::string`; for a `std::string s`, its length can be obtained as `s.size()`. In Python, the length of `s` can be obtained as `len(s)`. Here are sample codes:\n\n**Sample code (Python3):**\n```python\nans = 0\n\nfor i in range(1, 12 + 1):\n    s = input()  # Read string s\n    if len(s) == i:  # Check if its length equals i\n        ans += 1  # If so, add 1 to the answer\n\nprint(ans)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\). Additionally, you are given an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n1. Choose integers \\( l \\) and \\( r \\) such that \\( 1 \\leq l < r \\leq N \\).\n   - The pair \\((l, r)\\) must satisfy the following conditions:\n     - \\( K \\leq r - l \\).\n     - \\( P_l > P_r \\) at the time of the operation.\n     - The pair \\((l, r)\\) has never been chosen before.\n\n2. Swap the values of \\( P_l \\) and \\( P_r \\).\n\nYour goal is to maximize the number of operations. Find one way to achieve this.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( 1 \\leq K \\leq N - 1 \\)\n- \\( (P_1, P_2, \\ldots, P_N) \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\ldots P_N\n```\n\n### Output\n\nPrint the answer in the following format:\n```\nm\nl_1 r_1\nl_2 r_2\n\\vdots\nl_m r_m\n```\n\nHere, \\( m \\) is the maximum number of operations, and \\( l_i \\) and \\( r_i \\) are the values of \\( l \\) and \\( r \\) chosen in the \\( i \\)-th operation, respectively. If multiple solutions exist, you can print any of them.\n\n### Sample Input 1\n```\n3 1\n3 2 1\n```\n\n### Sample Output 1\n```\n3\n2 3\n1 3\n1 2\n```\n\nIn this example, the maximum number of operations is \\( 3 \\). The operations in the sample output proceed as follows:\n\n1. Choose \\((l, r) = (2, 3)\\). We have \\( 1 \\leq 3 - 2 \\) and \\( P_2 > P_3 \\), and \\((2, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_2 \\) and \\( P_3 \\), resulting in \\( P = (3, 1, 2) \\).\n\n2. Choose \\((l, r) = (1, 3)\\). We have \\( 1 \\leq 3 - 1 \\) and \\( P_1 > P_3 \\), and \\((1, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_3 \\), resulting in \\( P = (2, 1, 3) \\).\n\n3. Choose \\((l, r) = (1, 2)\\). We have \\( 1 \\leq 2 - 1 \\) and \\( P_1 > P_2 \\), and \\((1, 2)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_2 \\), resulting in \\( P = (1, 2, 3) \\).\n\nSolution:\n\n[BEGIN TEXT]\nLet\u2019s consider the inverse permutation \\(Q\\) of \\(P\\). In other words, \\(Q_{P_i} = i\\). Rephrasing the operation with \\(Q\\) as the main focus, it becomes: Choose \\(i, j\\) such that \\(1 \\leq i < j \\leq N\\) and \\(Q_i - Q_j \\geq K\\). Here, the pair \\((Q_i, Q_j)\\) must not have been chosen before. Swap \\(Q_i\\) and \\(Q_j\\).\n\nWe define the pseudo-inversion count of \\(Q\\) as the number of integer pairs \\((i, j)\\) such that \\(i < j\\) and \\(Q_i - Q_j \\geq K\\). Performing the operation decreases the pseudo-inversion count by at least \\(1\\). It is possible to construct a sequence of operations that decreases the pseudo-inversion count by \\(1\\) each time. Specifically, proceed as follows: Iterate \\(x = 1, 2, \\cdots, N\\). Assume that, when processing a certain \\(x\\), the pseudo-inversion count of \\(Q_1, \\cdots, Q_{x-1}\\) is \\(0\\). Enumerate \\(Q_i\\) that satisfy \\(i < x\\) and \\(Q_i - Q_x \\geq K\\), and denote them as \\(i_1, i_2, \\cdots, i_s\\). Then, process \\((i_s, x), (i_{s-1}, i_s), \\cdots, (i_1, i_2)\\) in this order. This decreases the pseudo-inversion count by \\(1\\) with each operation. The same pair \\((Q_i, Q_j)\\) will not be operated on more than once. A straightforward implementation of these steps yields an \\(O(N^2)\\) time solution.\n[END TEXT]\n \n\n", "problem_ids": ["abc360_b", "abc373_a", "arc180_b"]}, "abc303_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nCertainly! Here is a cleaned and structured version of the problem statement:\n\n---\n\n**Score**: 250 points\n\n### Problem Statement\n\nThere are \\( N \\) dishes, and the \\( i \\)-th dish has a **sweetness** of \\( A_i \\) and a **saltiness** of \\( B_i \\).\n\nTakahashi plans to arrange these \\( N \\) dishes in any order he likes and eat them in that order. He will stop eating as soon as the total sweetness of the dishes he has eaten exceeds \\( X \\) or the total saltiness exceeds \\( Y \\).\n\nFind the minimum possible number of dishes that he will end up eating.\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq X, Y \\leq 2 \\times 10^{14} \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN X Y\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n4 7 18\n2 3 5 1\n8 8 1 4\n```\n\n### Sample Output 1\n\n```\n2\n```\n\n**Explanation**\n\nThe \\( i \\)-th dish will be denoted as dish \\( i \\). If he arranges the four dishes in the order \\( 2, 3, 1, 4 \\), as soon as he eats dishes \\( 2 \\) and \\( 3 \\), their total sweetness is 8, which is greater than 7. Therefore, in this case, he will end up eating two dishes. The number of dishes he will eat cannot be 1 or less, so print 2.\n\n### Sample Input 2\n\n```\n5 200000000000000 200000000000000\n1 1 1 1 1\n2 2 2 2 2\n```\n\n### Sample Output 2\n\n```\n5\n```\n\n### Sample Input 3\n\n```\n8 30 30\n1 2 3 4 5 6 7 8\n8 7 6 5 4 3 2 1\n```\n\n### Sample Output 3\n\n```\n6\n```\n\n--- \n\nThis is a structured and detailed explanation capturing the essence and rules of the problem.\n\nSolution:\n\nHere is a clean version of the provided editorial:\n\n**C - Minimum Glutton Editorial**\n\nConsider the following Problem A and Problem B:\n- **Problem A**: Arrange the \\(N\\) dishes and eat them in order until the total sweetness exceeds \\(X\\). What is the minimum number of dishes eaten?\n- **Problem B**: Arrange the \\(N\\) dishes and eat them in order until the total saltiness exceeds \\(Y\\). What is the minimum number of dishes eaten?\n\nFor a fixed arrangement, once the stopping condition in Problem A or Problem B is satisfied, the original problem's condition is satisfied. Thus, the answer to the original problem equals the minimum of the answers to Problems A and B. Sort the dishes in descending order of \\(A_i\\) and \\(B_i\\), respectively, and eat them from the first in order to achieve the minimum value.\n\n**Sample code:**\n```python\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort(reverse=True)\nb.sort(reverse=True)\n\nc1 = 0\nc2 = 0\nsx = 0\nsy = 0\n\nfor ai in a:\n    sx += ai\n    c1 += 1\n    if sx > x:\n        break\n\nfor bi in b:\n    sy += bi\n    c2 += 1\n    if sy > y:\n        break\n\nprint(min(c1, c2))\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a grid with \\( H \\) rows and \\( W \\) columns. Let \\( (i, j) \\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Initially, there is one wall in each cell. After processing \\( Q \\) queries as explained below, determine the number of remaining walls.\n\nIn the \\( q \\)-th query, you are given two integers \\( R_q \\) and \\( C_q \\). A bomb is placed at \\( (R_q, C_q) \\) to destroy walls. The following process occurs:\n\n- If there is a wall at \\( (R_q, C_q) \\), destroy that wall and end the process.\n- If there is no wall at \\( (R_q, C_q) \\), destroy the first walls that appear when looking up, down, left, and right from \\( (R_q, C_q) \\). Specifically, the following four processes occur simultaneously:\n  - If there exists an \\( i < R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( i < k < R_q \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists an \\( i > R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( R_q < k < i \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists a \\( j < C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( j < k < C_q \\), destroy the wall at \\( (R_q, j) \\).\n  - If there exists a \\( j > C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( C_q < k < j \\), destroy the wall at \\( (R_q, j) \\).\n\n**Constraints:**\n\n- \\( 1 \\leq H, W \\)\n- \\( H \\times W \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq R_q \\leq H \\)\n- \\( 1 \\leq C_q \\leq W \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nH W Q\nR_1 C_1\nR_2 C_2\n...\nR_Q C_Q\n```\n\n**Output:**\n\nPrint the number of remaining walls after processing all queries.\n\n**Sample Input 1:**\n\n```\n2 4 3\n1 2\n1 2\n1 3\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- In the 1st query, \\( (R_1, C_1) = (1, 2) \\). There is a wall at \\( (1, 2) \\), so it is destroyed.\n- In the 2nd query, \\( (R_2, C_2) = (1, 2) \\). No wall at \\( (1, 2) \\), so destroy the nearest walls at \\( (2,2) \\), \\( (1,1) \\), and \\( (1,3) \\).\n- In the 3rd query, \\( (R_3, C_3) = (1, 3) \\). No wall at \\( (1, 3) \\), so destroy the nearest walls at \\( (2,3) \\) and \\( (1,4) \\).\n\nAfter all queries, two walls remain, at \\( (2, 1) \\) and \\( (2, 4) \\).\n\nSolution:\n\n        Here is a cleaned version of the text focusing on the solution:\n\n---\n\nTo solve the problem efficiently, manage the remaining walls using data structures. Use two ordered sets (such as `std::set` in C++):\n\n1. `g1`: An array where each element is an ordered set maintaining column indices of the remaining walls in each row.\n2. `g2`: An array where each element is an ordered set maintaining row indices of the remaining walls in each column.\n\nBy utilizing binary search in these ordered sets (using `set::lower_bound`), each query can be processed in \\(\\mathrm{O}(\\log H + \\log W)\\) time. The overall time complexity for solving the problem is \\(\\mathrm{O}((HW + Q)(\\log H + \\log W))\\).\n\nSample Python3 code demonstrates this approach:\n\n```python\nimport sys\nfrom sortedcontainers import SortedSet\n\ninput = sys.stdin.read\ndata = input().split()\n\nH = int(data[0])\nW = int(data[1])\nQ = int(data[2])\nindex = 3\n\ng1 = [SortedSet() for _ in range(H)]\ng2 = [SortedSet() for _ in range(W)]\n\nfor i in range(H):\n    for j in range(W):\n        g1[i].add(j)\n        g2[j].add(i)\n\ndef erase(i, j):\n    g1[i].discard(j)\n    g2[j].discard(i)\n\nfor _ in range(Q):\n    R = int(data[index]) - 1\n    C = int(data[index + 1]) - 1\n    index += 2\n\n    if C in g1[R]:\n        erase(R, C)\n        continue\n\n    # up\n    it = g2[C].bisect_left(R)\n    if it > 0:\n        erase(g2[C][it - 1], C)\n    # down\n    if it < len(g2[C]):\n        erase(g2[C][it], C)\n    # left\n    it = g1[R].bisect_left(C)\n    if it > 0:\n        erase(R, g1[R][it - 1])\n    # right\n    if it < len(g1[R]):\n        erase(R, g1[R][it])\n\nans = sum(len(row) for row in g1)\nprint(ans)\n```\n\n---\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree with \\( N \\) vertices. The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally. Additionally, you are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\).\n\nDefine \\( f(i, j) \\) as follows:\n\n- If \\( A_i = A_j \\), then \\( f(i, j) \\) is the minimum number of edges needed to traverse from vertex \\( i \\) to vertex \\( j \\).\n- If \\( A_i \\neq A_j \\), then \\( f(i, j) = 0 \\).\n\nCalculate the value of the following expression:\n\n\\[\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(i,j)\n\\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- The input graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nu_1 v_1\n...\nu_{N-1} v_{N-1}\nA_1 A_2 ... A_N\n```\n\n**Output**\n\nPrint the computed answer.\n\n**Sample Input 1**\n\n```\n4\n3 4\n4 2\n1 2\n2 1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nExplanation: \\( f(1,4)=2, f(2,3)=2 \\). For all other \\( i, j \\) \\((1 \\leq i < j \\leq N)\\), we have \\( f(i,j)=0 \\), so the answer is \\( 2+2=4 \\).\n\n**Sample Input 2**\n\n```\n8\n8 6\n3 8\n1 4\n7 8\n4 5\n3 4\n8 2\n1 2 2 2 3 1 1 3\n```\n\n**Sample Output 2**\n\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nApplying the centroid decomposition, it is sufficient to find the answer for paths passing through the root. We consider two cases depending on whether the endpoint of the path is the root or not. If it is root, one can naively perform BFS (Breadth-First Search). Otherwise, for each vertex \\(v\\), count how many times the path between vertex \\(v\\) and the root contributes to the answer. Let \\(c_1,\\ldots,c_k\\) be the children of the root, and suppose that vertex \\(v\\) is contained in the subtree \\(c_i\\). Then, the number of times the path between vertex \\(v\\) and the root contributes to the answer is found as (the number of vertices \\(u\\) contained in the current tree such that \\(A_v = A_u\\)) - (the number of vertices \\(u\\) in the subtree \\(c_i\\) such that \\(A_v = A_u\\)). The values required can all be found using a DFS (Depth-First Search), so the problem has been solved.\n[END TEXT]\n \n\n", "problem_ids": ["abc364_c", "abc370_d", "abc359_g"]}, "abc303_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a weighted undirected graph \\( G \\) with \\( N \\) vertices, numbered from 1 to \\( N \\). Initially, the graph \\( G \\) has no edges.\n\nYou will perform \\( M \\) operations to add edges to the graph \\( G \\). The \\( i \\)-th operation \\((1 \\leq i \\leq M)\\) is as follows:\n\n- You are given a subset of vertices \\( S_i = \\{ A_{i,1}, A_{i,2}, \\dots, A_{i,K_i} \\} \\) consisting of \\( K_i \\) vertices.\n- For every pair of vertices \\( u, v \\) such that \\( u, v \\in S_i \\) and \\( u < v \\), add an edge between vertices \\( u \\) and \\( v \\) with weight \\( C_i \\).\n\nAfter performing all \\( M \\) operations, determine whether the graph \\( G \\) is connected. If it is connected, find the total weight of the edges in a minimum spanning tree of \\( G \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq K_i \\leq N \\)\n- \\( \\sum_{i=1}^{M} K_i \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq A_{i,1} < A_{i,2} < \\dots < A_{i,K_i} \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nK_1 C_1\nA_{1,1} A_{1,2} \\dots A_{1,K_1}\nK_2 C_2\nA_{2,1} A_{2,2} \\dots A_{2,K_2}\n...\nK_M C_M\nA_{M,1} A_{M,2} \\dots A_{M,K_M}\n```\n\n**Output Format**\n\nIf the graph \\( G \\) is not connected after all \\( M \\) operations, print `-1`. If \\( G \\) is connected, print the total weight of the edges in a minimum spanning tree of \\( G \\).\n\nSolution:\n\n\n[BEGIN TEXT]\nOne of the algorithms to find the spanning tree is Kruskal\u2019s algorithm. Starting from a state where no edge is added to the graph, inspect the edges in ascending order of weight. If the edge currently being inspected between vertices \\(u\\) and \\(v\\) is not connected yet, add it to the graph. By managing the connectivity of the graph using a data structure like Disjoint Set Union (DSU), the algorithm runs in a total of \\(O(E\\log E)\\) time, where sorting is the bottleneck. (\\(E\\) is the number of edges.)\n\nIn this problem, there are at most \\(O((\\sum K)^2)\\) edges, making it infeasible to apply the algorithm directly within the time limit. Instead, we use the following property about the minimum spanning tree: if there is an edge \\(e=(u,v)\\) that satisfies the condition where there exists a path connecting vertex \\(u\\) and vertex \\(v\\) consisting of edges with weights not greater than that of edge \\(e\\), but not containing edge \\(e\\), removing edge \\(e\\) from the candidates does not change the total weight of the minimum spanning tree.\n\nThis is due to the behavior of Kruskal's algorithm. On edge \\(e\\)\u2019s turn, \\(u\\) and \\(v\\) are already connected, so edge \\(e\\) is never used. In this problem, the edges added are: an edge of weight \\(C_i\\) connecting vertices \\(u\\) and \\(v\\) for all pairs of different vertices contained in \\(\\lbrace A_{i,1},A_{i,2},\\dots,A_{i,K_i}\\rbrace\\).\n\nBy the property above, we find it sufficient to add only the following edges: an edge of weight \\(C_i\\) connecting vertices \\(A_{i,1}\\) and \\(A_{i,j}\\) for each \\(j=2,3,\\dots,K_i\\). This modification reduces the total number of edges to \\(O(\\sum K)\\), making it feasible to apply Kruskal\u2019s algorithm to solve the problem.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence \\( A \\) of length \\( N \\). Freely choose exactly \\( K \\) elements from \\( A \\) and remove them, then concatenate the remaining elements in their original order to form a new sequence \\( B \\). Find the minimum possible value of this: the maximum value of \\( B \\) minus the minimum value of \\( B \\).\n\n**Constraints**\n\n- All inputs are integers.\n- \\( 1 \\le K < N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le A_i \\le 10^9 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n5 2\n3 1 5 4 9\n```\n\n**Sample Output 1**\n```\n2\n```\n\n**Sample Input 2**\n```\n6 5\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n8 3\n31 43 26 6 18 36 22 13\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Editorial - Denso Create Programming Contest 2024 (AtCoder Beginner Contest 361)\n\nRemoving \\(K\\) elements of \\(A\\) is equivalent to retaining \\((N-K)\\) elements to form \\(B\\). To minimize (maximum value of \\(B\\)) - (minimum value of \\(B\\)), it is optimal to retain the \\((N-K)\\) smallest elements among the elements of \\(A\\) greater than or equal to \\(A_x\\), the fixed minimum of \\(B\\). In other words, it is optimal to choose \\((N-K)\\) consecutive elements in \\(A\\) sorted in ascending order.\n\nSolution: \n1. Sort \\(A\\) such that \\(A_1 \\le A_2 \\le \\dots \\le A_N\\).\n2. The answer is the minimum of \\(A_{l+(N-K)-1} - A_l\\) for \\(1 \\le l \\le K+1\\).\n3. Implement with sorting and a for loop, with a total time complexity of \\(O(N \\log N)\\).\n\nSample code (Python3):\n\n```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\nres = int(2e9)\nfor i in range(k + 1):\n    res = min(res, a[i + (n - k) - 1] - a[i])\n\nprint(res)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\(N\\) and a prime \\(P\\).\n\nWe call a sequence of \\(N\\) intervals \\(([L_1,R_1],[L_2,R_2], \\ldots, [L_N,R_N])\\) **good** if and only if both of the following conditions are satisfied:\n\n1. \\(1 \\leq L_i \\leq R_i \\leq N\\) holds for all \\(1 \\leq i \\leq N\\).\n2. There exists a **unique** permutation \\(x = (x_1, x_2, \\ldots, x_N)\\) of \\((1, 2, \\ldots, N)\\) such that \\(L_i \\leq x_i \\leq R_i\\) holds for all \\(1 \\leq i \\leq N\\).\n\nCount the number of **good** sequences of intervals, modulo \\(P\\).\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 5000\\)\n- \\(10^9 < P < 1.01 \\times 10^9\\)\n- \\(P\\) is a prime number.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1005488041\n```\n\n**Sample Output 1**\n\n```\n6\n```\n\nThe following 6 sequences are good:\n1. \\(([1,1],[2,2])\\)\n2. \\(([1,2],[2,2])\\)\n3. \\(([1,1],[1,2])\\)\n4. \\(([2,2],[1,1])\\)\n5. \\(([2,2],[1,2])\\)\n6. \\(([1,2],[1,1])\\)\n\n**Sample Input 2**\n\n```\n5 1005488041\n```\n\n**Sample Output 2**\n\n```\n102960\n```\n\n**Sample Input 3**\n\n```\n100 1005488041\n```\n\n**Sample Output 3**\n\n```\n47599495\n```\n\n**Sample Input 4**\n\n```\n1000 1005488041\n```\n\n**Sample Output 4**\n\n```\n632708165\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Grand Contest 067\n\nD - Unique Matching Editorial by Kubic\n\nObviously, the intervals \\([l_i,r_i]\\) are distinct. So we can just let \\(x_i=i\\) and finally multiply the answer by \\(n!\\). Consider the uniqueness of bipartite graph matching. Fix a perfect matching; it is equivalent to not existing augmenting cycles. We claim that \\(l,r\\) is good if and only if there isn\u2019t \\(i,j\\) such that \\(1\\le i<j\\le n,r_i\\ge j,l_j\\le i\\). It means there is no cycle of length \\(2\\). Moreover, it can be proven that there will be no cycle under this condition. View \\(l\\) as constraints on \\(r\\), \\(\\forall l_i\\le j<i\\), then \\(r_j<i\\) must hold. Let \\(a_i=\\min\\limits_{l_j\\le i<j}j\\) (if \\(j\\) doesn\u2019t exist, then \\(a_i=n+1\\)). We need to calculate the sum of \\(\\prod (a_i-i)\\) for all possible sequences of \\(l\\). Fixing \\(a\\), we consider the number of \\(l\\) that generates \\(a\\). The main idea is to consider all maximums of \\(a\\) and divide \\(a\\) into several independent parts. Let \\(f_{i,j}\\) denote the answer when only considering \\([i,j]\\), requiring all \\(a_i\\dots a_j\\le j+1\\), with \\(l_{j+1}\\) determined (\\(l_{j+1}<i\\)). Let \\(g_{i,j}\\) denote the answer when \\(l_{j+1}\\) is undetermined (\\(l_{j+1}\\ge i\\)). Particularly, \\(f_{i+1,i}=g_{i+1,i}=1\\). The final answer is \\(f_{1,n}\\). Find the smallest \\(k\\) such that \\(i\\le k\\le j\\) and \\(a_k=j+1\\) (obviously \\(a_j=j+1\\), then such \\(k\\) exists). Now, \\([i,k-1]\\) and \\([k+1,j]\\) are independent subproblems. Thus, we have:\n\n```python\ndef f_i_j(i, j):\n    return sum((j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n\ndef g_i_j(i, j):\n    return sum((k - i + 1) * (j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n```\n\nFurthermore, \\(f_{i,j}\\) is only related to \\(j-i+1\\), thus it can be rewritten as follows:\n\n```python\ndef f_i(i):\n    return sum((i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n\ndef g_i(i):\n    return sum(j * (i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n```\n\nBrute force runs in \\(O(n^2)\\) and is allowed to pass. DC & FFT solution runs in \\(O(n\\log^2 n)\\).\n[END TEXT]\n \n\n", "problem_ids": ["abc352_e", "abc361_c", "agc067_d"]}, "abc303_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nIn the nation of AtCoder, there are \\( N \\) cities numbered from 1 to \\( N \\) and \\( N-1 \\) roads. Each road \\( i \\) connects cities \\( A_i \\) and \\( B_i \\) bidirectionally, with a length of \\( C_i \\). Every city can be reached from any other city by traveling through some roads.\n\nThe task is to find the minimum travel distance required to start from a city and visit all cities at least once using the roads.\n\n### Constraints\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- All input values are integers.\n- Any pair of cities can be reached from each other by traveling through some roads.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_{N-1} B_{N-1} C_{N-1}\n```\n\n### Output\nPrint the minimum travel distance required.\n\n### Sample Input 1\n```\n4\n1 2 2\n1 3 3\n1 4 4\n```\n\n### Sample Output 1\n```\n11\n```\n\n*Explanation*: If you travel as 4 \u2192 1 \u2192 2 \u2192 1 \u2192 3, the total travel distance is 11, which is the minimum. You do not need to return to the starting city.\n\n### Sample Input 2\n```\n10\n10 9 1000000000\n9 8 1000000000\n8 7 1000000000\n7 6 1000000000\n6 5 1000000000\n5 4 1000000000\n4 3 1000000000\n3 2 1000000000\n2 1 1000000000\n```\n\n### Sample Output 2\n```\n9000000000\n```\n\n*Note*: Beware of overflow.\n\nSolution:\n\n```\nConsider a graph with the vertices representing cities and the edges representing roads. This graph is a tree. Let \\(D\\) be the diameter of this tree. The solution is \\(2\\sum C_i - D\\). The diameter of the tree can be found in \\(O(N)\\) time using the following steps: From an arbitrary vertex \\(v\\), find the furthest vertex \\(u\\). From \\(u\\), find the furthest vertex \\(s\\). \\(u\\) and \\(v\\) are the endpoints of a diameter.\n\nWe won't explain why the diameter can be found this way. The original problem's answer is \\(2\\sum C_i - D\\). Consider the minimum travel distance for visiting all vertices and returning to the start. For each edge, consider the two components obtained by removing the edge; every edge must be passed at least twice. By performing a DFS from an arbitrary vertex and visiting all vertices, you can return to the start after passing each edge twice. Thus, the answer is \\(2\\sum C_i\\).\n\nReturn to the original problem. A tour visiting every vertex once can be extended to return to the start. The minimum for this is \\(2\\sum C_i\\), while the maximum distance from end to start equals the tree's diameter. So, the minimum tour distance visiting all vertices at least once is \\(2\\sum C_i-D\\). \n\nChoose a diameter with endpoints \\(x\\) and \\(y\\). By performing DFS such that the next vertex doesn't move closer to \\(y\\), each edge on the shortest path between \\(x\\) and \\(y\\) is passed once. This tour visits each vertex once with travel distance \\(2\\sum C_i-D\\). Therefore, the sought minimum value is \\(2\\sum C_i-D\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a positive integer \\( N \\), and an integer \\( A_{x,y,z} \\) for each triple of integers \\( (x, y, z) \\) such that \\( 1 \\leq x, y, z \\leq N \\).\n\nYou will be given \\( Q \\) queries in the following format, which must be processed in order.\n\nFor the \\( i \\)-th query \\( (1 \\leq i \\leq Q) \\), you are given a tuple of integers \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\) such that \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\), \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\), and \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\). Find:\n\n\\[\n\\displaystyle{\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}}\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 0 \\leq A_{x,y,z} \\leq 999 \\) where \\( 1 \\leq x, y, z \\leq N \\)\n- \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n- The integer \\( N \\)\n- An \\( N \\times N \\times N \\) array \\( A \\) of integers, given in the order \\( A_{1,1,1}, A_{1,1,2}, \\ldots \\), i.e., iterating through \\( x \\), then \\( y \\), then \\( z \\).\n- The integer \\( Q \\)\n- \\( Q \\) lines, each containing six integers representing \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\)\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n\n```\n2\n1 2\n3 4\n5 6\n7 8\n2\n1 2 2 2 1 1\n2 2 1 2 1 2\n```\n\n**Sample Output 1:**\n\n```\n10\n26\n```\n\n**Explanation:**\n\nFor the 1st query, the sought value is \\( A_{1,2,1} + A_{2,2,1} = 3 + 7 = 10 \\). Thus, print 10.\n\nFor the 2nd query, the sought value is \\( A_{2,1,1} + A_{2,1,2} + A_{2,2,1} + A_{2,2,2} = 5 + 6 + 7 + 8 = 26 \\). Thus, print 26.\n\n**Sample Input 2:**\n\n```\n3\n733 857 714\n956 208 257\n123 719 648\n840 881 245\n245 112 746\n306 942 694\n58 870 849\n13 208 789\n687 906 783\n8\n3 3 3 3 1 1\n1 3 2 3 3 3\n2 2 2 3 1 1\n1 3 1 1 1 1\n2 3 2 3 2 3\n1 2 1 1 1 2\n3 3 2 2 1 3\n1 2 2 3 2 3\n```\n\n**Sample Output 2:**\n\n```\n687\n3917\n551\n1631\n5180\n3311\n1010\n4326\n```\n\nSolution:\n\n```plaintext\nD - Cuboid Sum Query Editorial\n\nThis problem is an exercise of cumulative sums. We assume the knowledge of cumulative sums for a sequence (one-dimensional cumulative sums).\n\nGiven a length-\\(N\\) sequence \\(A\\), process \\(Q\\) queries. In the \\(i\\)-th query, given an integer pair \\((L_i,R_i)\\) satisfying \\(1 \\leq L_i \\leq R_i \\leq N\\), find \\(\\sum_{k=L_i}^{R_i}A_k\\).\n\nA solution to this problem is as follows: Define a length-\\((N+1)\\) sequence \\(S=(S_0,S_1,\\ldots S_N)\\) by \\(S_0=0,S_i=\\sum_{k=1}^{i-1}A_k\\), and use \\(\\sum_{k=L_i}^{R_i}A_k=S_{R_i+1}-S_{L_i}\\) to answer the query fast. The sequence \\(S\\) is called the cumulative sums of \\(A\\).\n\nThe original problem is an extension of this one-dimensional cumulative sum problem into three dimensions.\n\nConsider \\(S\\) such that \\(S_{i,j,k}=\\sum_{x=1}^{i-1} \\sum_{y=1}^{j-1}\\sum_{z=1}^{k-1}A_{x,y,z}\\) for \\(1 \\leq i,j,k \\leq N+1\\). If \\(i\\), \\(j\\), or \\(k\\) is \\(0\\), define \\(S_{i,j,k}=0\\).\n\nIt holds that \\(\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}=S_{Rx_i+1,Ry_i+1,Rz_i+1}-S_{Lx_i,Rx_i+1,Rz_i+1}-S_{Rx_i+1,Ly_i,Rz_i+1}-S_{Rx_i+1,Ry_i+1,Lz_i}+S_{Lx_i,Ly_i,Rz_i+1}+S_{Lx_i,Ry_i+1,Lz_i}+S_{Rx_i+1,Ly_i,Lz_i}-S_{Lx_i,Ly_i,Lz_i}\\).\n\nTherefore, if one can compute \\(S\\) fast, then each query can be answered in constant time.\n\n\\(S\\) can be found by the property that \\(S_{i,j,k}=S_{i-1,j,k}+S_{i,j-1,k}+S_{i,j,k-1}-S_{i-1,j-1,k}-S_{i-1,j,k-1}-S_{i,j-1,k-1}+S_{i-1,j-1,k-1}+A_{i-1,j-1,k-1}\\). The time complexity is \\(O(N^3+Q)\\).\n\nSample code (Python):\n```python\nn = int(input())\n\na = [[[0] * n for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        a[i][j]=list(map(int,input().split()))\n\nsum = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            sum[i + 1][j + 1][k + 1] = (sum[i][j+1][k+1]\n                                        + sum[i+1][j][k+1]\n                                        + sum[i+1][j+1][k]\n                                        - sum[i][j][k+1]\n                                        - sum[i][j+1][k]\n                                        - sum[i+1][j][k]\n                                        + sum[i][j][k]\n                                        + a[i][j][k])\n\nq = int(input())\nfor _ in range(q):\n    lx, rx, ly, ry, lz, rz = map(int, input().split())\n    lx -= 1\n    ly -= 1\n    lz -= 1\n\n    result = (sum[rx][ry][rz]\n                - sum[lx][ry][rz]\n                - sum[rx][ly][rz]\n                - sum[rx][ry][lz]\n                + sum[lx][ly][rz]\n                + sum[lx][ry][lz]\n                + sum[rx][ly][lz]\n                - sum[lx][ly][lz])\n    print(result)\n```\n```\n```\n \n\n", "problem_ids": ["abc361_e", "abc361_a", "abc366_d"]}, "abc303_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Score:** 900 points\n\n**Problem Statement:**  \nThere is a circle with circumference \\( L \\), and \\( L \\) people are standing equally spaced along the circumference. They are labeled as person \\( 0, 1, \\cdots, L-1 \\) in clockwise order. Consider choosing \\( N \\) from these \\( L \\) people. The **cost** of a choice is defined as follows:\n\n- For every pair of persons among the \\( N \\) chosen people, find the minimum distance one person has to move along the circumference to reach the other person's position. The maximum value among these distances is the cost.\n\nFind the sum of costs over all possible choices, modulo \\( 998244353 \\).\n\n**Constraints:**\n- \\( 2 \\leq N \\leq L \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**  \nThe input is given from Standard Input in the following format:\n```\nL N\n```\n\n**Output:**  \nPrint the answer.\n\n**Sample Input 1:**  \n```\n4 2\n```\n\n**Sample Output 1:**  \n```\n8\n```\n\nExplanation for Sample Input 1:  \nThe choices of \\( N \\) people and their corresponding costs are as follows:\n- \\( (0,1) \\): cost \\( 1 \\)\n- \\( (0,2) \\): cost \\( 2 \\)\n- \\( (0,3) \\): cost \\( 1 \\)\n- \\( (1,2) \\): cost \\( 1 \\)\n- \\( (1,3) \\): cost \\( 2 \\)\n- \\( (2,3) \\): cost \\( 1 \\)\n\nThe sum of these costs, \\( 8 \\), is the answer.\n\n**Sample Input 2:**  \n```\n5 5\n```\n\n**Sample Output 2:**  \n```\n2\n```\n\nExplanation for Sample Input 2:  \nWe can only choose all of them. In this case, the cost is \\( 2 \\).\n\n**Sample Input 3:**  \n```\n13 5\n```\n\n**Sample Output 3:**  \n```\n7618\n```\n\n**Sample Input 4:**  \n```\n1000000 100000\n```\n\n**Sample Output 4:**  \n```\n664396470\n```\n\nSolution:\n\n```python\nIf we know the answer when person 0 is always chosen, we can multiply it by L / N to get the original answer. Let\u2019s assume that person 0 is always chosen. For each D = 1, 2, ..., it suffices to find the number of ways to choose people so that the cost is less than D. First, people D, ..., L - D cannot be chosen. Next, consider whom to choose among people 1, 2, ..., D - 1. They can be chosen freely without interfering with each other. Finally, consider whom to choose among people L - D + 1, ..., L - 1. The condition for choosing person i is that none of the people in [i - L + D, i - D] have been chosen so far. Here, this interval is basically included within [1, D - 1]. If 2 * D <= i, this interval extends beyond that range, but the exceeding part is included in [D, L - D], from which we already know we are not choosing anyone, so we don\u2019t need to consider it specially. Let W = L - 2 * D + 1. We can regard the operation of choosing people from L - D + 1, ..., L - 1 as the operation of choosing intervals of length W among people 1, ..., D - 1. Then, what we need to consider is selecting people and intervals from people 1, ..., D - 1 so that they do not overlap (it\u2019s acceptable for intervals themselves to overlap). We will call a person chosen in the people selection as a red person. Also, in the interval selection, we will call the starting person of the interval as a blue person. If we fix the number of times red and blue alternate, the total number of ways to choose can be expressed using binomial coefficients. Also, the number of alternations is at most N // W. Therefore, if we perform this calculation for all D, the total computational complexity is O(N + N // 2 + N // 3 + ...) = O(N log N), so it runs sufficiently fast.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a sequence of integers \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nDefine \\( f(l, r) \\) as the number of distinct values in the subsequence \\( (A_l, A_{l+1}, \\ldots, A_r) \\).\n\nEvaluate the following sum:\n\n\\[\n\\sum_{i=1}^{N}\\sum_{j=i}^N f(i,j)\n\\]\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\n\nThe input is given in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n3\n1 2 2\n```\n\n### Sample Output 1\n\n```\n8\n```\n\nConsider \\( f(1, 2) \\). The subsequence \\( (A_1, A_2) = (1, 2) \\) contains 2 distinct values, so \\( f(1,2) = 2 \\).\n\nConsider \\( f(2, 3) \\). The subsequence \\( (A_2, A_3) = (2, 2) \\) contains 1 distinct value, so \\( f(2,3) = 1 \\).\n\nThe sum of \\( f \\) is 8.\n\n### Sample Input 2\n\n```\n9\n5 4 2 2 3 2 4 4 1\n```\n\n### Sample Output 2\n\n```\n111\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 371\n\nE - I Hate Sigma Problems Editorial\n\nThe answer is the number of subarrays containing \\(1\\) \\(+\\) the number of subarrays containing \\(2\\) \\(+\\ldots+\\) the number of subarrays containing \\(N\\). We will explain how to count subarrays containing \\(i\\) in \\(\\mathrm{O}(C_i)\\) time (where \\(C_i\\) is the number of occurrences of \\(i\\) in \\(A\\)). Once this is possible, the problem can be solved in a total of \\(\\mathrm{O}(N)\\) time. A common technique of combinatorics is to consider complementary events. Let\u2019s count the number of subarrays not containing \\(i\\), subtracting the sum from the all. For simplicity, let us insert \\(i\\) to both ends of \\(A\\). Then, the indices \\(x\\) with \\(A_x = i\\) arranged in ascending order are represented as \\(x=(x_0=0,x_1,\\ldots,x_{C_i+1} = N+1)\\). The number of subarrays not containing \\(i\\) equals the number of subarrays whose left end is \\(x_0+1\\) or greater, and right end is \\(x_1-1\\) or less, plus subarrays whose left end is \\(x_1+1\\) or greater, and right end is \\(x_2-1\\) or less, and so on. This can be evaluated in \\(\\mathrm{O}(C_i)\\) time. Hence, the problem has been solved.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), and a sequence of non-negative integers: \\( A = (A_1,A_2,\\ldots,A_N) \\).\n\nFor a non-empty non-negative integer sequence \\( B = (B_1,B_2,\\ldots,B_{|B|}) \\), we define its **score** as follows:\n- If the length of \\( B \\) is a multiple of \\( M \\): \\( (B_1 \\oplus B_2 \\oplus \\dots \\oplus B_{|B|})^K \\)\n- Otherwise: \\( 0 \\)\n\nHere, \\( \\oplus \\) represents the bitwise XOR.\n\nFind the sum, modulo \\( 998244353 \\), of the scores of the \\( 2^N-1 \\) non-empty subsequences of \\( A \\).\n\n### Constraints\n- \\( 1 \\leq N, K \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 0 \\leq A_i < 2^{20} \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n3 2 2\n1 2 3\n```\n\n### Sample Output 1\n```\n14\n```\n\nHere are the scores of the \\( 2^3-1=7 \\) non-empty subsequences of \\( A \\).\n- \\( (1) \\): \\( 0 \\)\n- \\( (2) \\): \\( 0 \\)\n- \\( (3) \\): \\( 0 \\)\n- \\( (1,2) \\): \\( (1 \\oplus 2)^2 = 9 \\)\n- \\( (1,3) \\): \\( (1 \\oplus 3)^2 = 4 \\)\n- \\( (2,3) \\): \\( (2 \\oplus 3)^2 = 1 \\)\n- \\( (1,2,3) \\): \\( 0 \\)\n\nTherefore, the sought sum is \\( 0 + 0 + 0 + 9 + 4 + 1 + 0 = 14 \\).\n\n### Sample Input 2\n```\n10 5 3\n100 100 100 100 100 100 100 100 100 100\n```\n\n### Sample Output 2\n```\n252000000\n```\n\n### Sample Input 3\n```\n16 4 100\n7053 3876 3178 8422 7802 5998 2334 6757 6889 6637 7365 9495 7848 9026 7312 6558\n```\n\n### Sample Output 3\n```\n432440016\n```\n\n\nSolution:\n\nThe problem requires knowledge of XOR convolution and Hadamard transform. Define \\(C_i\\) as the number of subsequences of \\(A\\) with length as a multiple of \\(M\\) and total XOR equals \\(i\\). We need to find \\(C_0, C_1, \\ldots, C_{2^L-1}\\) such that \\(\\sum_{i=0}^{2^L-1} C_i \\cdot i^K\\) is calculated, where \\(L=20\\).\n\nDefine sequences \\(v_i\\) such that each sequence term is a polynomial, with the 0-th term being 1, the \\(A_i\\)-th term as \\(x\\), and others 0. If \\(A_i=0\\), the 0-th term is \\(1+x\\). For two sequences \\(a, b\\), define the XOR convolution as \\((a \\ast b)_k = \\sum_{i \\oplus j = k} a_i \\times b_j\\). \n\nCompute the XOR convolution \\(V = v_1 \\ast v_2 \\ast \\cdots \\ast v_N\\). The coefficient of \\(x^j\\) of the \\(i\\)-th term (\\([x^j]V_i\\)) equals the number of length-\\(j\\) subsequences of \\(A\\) with a total XOR of \\(i\\), resulting in \\(C_i = [x^0]V_i + [x^M]V_i + \\cdots = [x^0]V_i \\, (\\text{mod } 1-x^M)\\).\n\nUtilize Hadamard conversion \\(H\\), where \\(H(a \\ast b)_i = H(a)_i \\times H(b)_i\\). Therefore, \\(H(V)_i = H(v_1)_i \\times \\cdots \\times H(v_N)_i\\). Compute \\(H(V)\\) using Hadamard conversion on sequences \\(v_1, v_2, \\ldots\\).\n\nGiven sequences that have 1 at the 0-th term and \\(x\\) at the \\(A_i\\)-th term, \\(H(v_i)\\) becomes \\((1+x)\\) or \\((1-x)\\). Thus, \\(H(V)_i\\) can be represented as \\((1+x)^{B_i}(1-x)^{N-B_i}\\). Calculate \\(B_i\\) efficiently using a combination of Hadamard conversion and population count divide-and-conquer strategy, allowing \\(O(L2^L)\\) calculation time. Alternatively, use \\(B_i = \\frac{H(\\text{cnt})_i + N}{2}\\).\n\nFind \\([x^0](1+x)^{B_i}(1-x)^{N-B_i} \\, (\\text{mod } 1-x^M)\\) in \\(O(NM)\\) using precalculated sequences for \\((1+x)^n\\) and \\((1-x)^n \\, (\\text{mod } 1-x^M)\\). Thus, the overall problem can be solved in \\(O(NM + 2^L (L + \\log K))\\) time.\n\nHere's the implementation:\n\n```python\nmod = 998244353\n\ndef hadamard(a, m):\n    for k in range(m):\n        i = 1 << k\n        for j in range(1 << m):\n            if not i & j:\n                a[j], a[i | j] = (a[j] + a[i | j]), (a[j] - a[i | j])\n\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nL = 20\ncnt = [0] * (1 << L)\nfor i in range(N):\n    cnt[A[i]] += 1\n\nF = [[0] * M for i in range(N + 1)]\nG = [[0] * M for i in range(N + 1)]\n\nF[0][0], G[0][0] = 1, 1\n\nfor i in range(N):\n    for j in range(M):\n        F[i + 1][j] = (F[i][j] + F[i][j - 1]) % mod\n        G[i + 1][j] = (G[i][j] - G[i][j - 1]) % mod\n\nres = [0] * (N + 1)\nfor i in range(N + 1):\n    for j in range(M):\n        res[i] += F[i][j] * G[N - i][-j]\n        res[i] %= mod\n\nhadamard(cnt, L)\nB = [(cnt[i] + N) // 2 for i in range(1 << L)]\nC = [res[B[i]] for i in range(1 << L)]\nhadamard(C, L)\n\ninv = pow(1 << L, mod - 2, mod)\nans = 0\nfor i in range(1 << L):\n    C[i] = C[i] % mod * inv % mod\n    ans += C[i] * pow(i, K, mod)\n    ans %= mod\n\nprint(ans)\n```\n\nCalculate \\(B\\) using divide-and-conquer:\n\n```python\ndef calc(off, k):\n    if k == 0:\n        return ([cnt[off]], cnt[off])\n    H0, c0 = calc(off, k - 1)\n    H1, c1 = calc(off | (1 << (k - 1)), k - 1)\n    H = [0] * (1 << k)\n    for i in range(1 << (k - 1)):\n        H[i] = H0[i] + H1[i]\n        H[i | (1 << (k - 1))] = H0[i] + c1 - H1[i]\n    return (H, c0 + c1)\n\nB = calc(0, L)[0]\n```\n \n\n", "problem_ids": ["agc068_a", "abc371_e", "abc367_g"]}, "abc303_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an \\( N \\times N \\) integer matrix \\( A = (A_{i,j})_{1 \\leq i \\leq N, 1 \\leq j \\leq N} \\) and an integer \\( M \\).\n\nFor an integer sequence \\( x = (x_1, x_2, \\cdots, x_M) \\) of length \\( M \\), consisting of integers between \\( 1 \\) and \\( N \\), inclusive, define \\( f(x) \\) as follows:\n\n- Let \\( y = (y_1, y_2, \\cdots, y_M) \\) be the sequence obtained by sorting the elements of \\( x \\) to be non-decreasing.\n- Define \\( f(x) = \\prod_{1 \\leq i \\leq M} A_{x_i, y_i} \\).\n\nFor each \\( k = 1, 2, \\cdots, N \\), solve the following problem:\n\n- Find the sum of \\( f(x) \\) over all sequences \\( x \\) satisfying \\( x_1 = k \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 50 \\)\n- \\( 1 \\leq M \\leq 50 \\)\n- \\( 0 \\leq A_{i,j} < 998244353 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1,1} A_{1,2} \\cdots A_{1,N}\nA_{2,1} A_{2,2} \\cdots A_{2,N}\n\\vdots\nA_{N,1} A_{N,2} \\cdots A_{N,N}\n```\n\n**Output**\n\nPrint the answer for each \\( k = 1, 2, \\cdots, N \\) in this order.\n\n**Sample Input 1**\n\n```\n2 2\n1 2\n3 4\n```\n\n**Sample Output 1**\n\n```\n5 22\n```\n\nAll possible \\( x \\) and the corresponding values of \\( f(x) \\) are as follows:\n- \\( x = (1, 1): y = (1, 1), f(x) = A_{1,1} \\times A_{1,1} = 1 \\)\n- \\( x = (1, 2): y = (1, 2), f(x) = A_{1,1} \\times A_{2,2} = 4 \\)\n- \\( x = (2, 1): y = (1, 2), f(x) = A_{2,1} \\times A_{1,2} = 6 \\)\n- \\( x = (2, 2): y = (2, 2), f(x) = A_{2,2} \\times A_{2,2} = 16 \\)\n\nThus, the answer is \\( 1 + 4 = 5 \\) for \\( k = 1 \\), and \\( 6 + 16 = 22 \\) for \\( k = 2 \\).\n\n**Sample Input 2**\n\n```\n2 3\n1 2\n3 4\n```\n\n**Sample Output 2**\n\n```\n27 118\n```\n\n**Sample Input 3**\n\n```\n5 4\n785439575 250040585 709423541 945005786 19237225\n404191279 250876592 22672563 519729086 344065186\n273714212 560047125 139793596 542901248 520999410\n855572558 498896932 418633758 742973826 248730678\n238856535 319502970 908902333 164543594 245101681\n```\n\n**Sample Output 3**\n\n```\n216530400 726773157 717209375 797938347 957133905\n```\n\n**Sample Input 4**\n\n```\n10 50\n197971506 714635866 966125570 768080799 80565655 459117401 256810168 775681305 582857561 948631706\n437330820 321722967 531470304 255908811 45459908 504089816 695016247 91058795 905527130 30860430\n151769562 979797105 619322493 298241991 360690308 480124392 297323928 284686636 922571073 627798362\n753705854 712639027 721488863 69714419 485979799 88704853 758288417 423073188 595934547 86264514\n272481811 622712481 221745114 225051881 433378197 985573661 210619166 851716760 283615535 834897126\n366075547 933505674 858395194 490049033 22039836 361481447 735151983 518458804 422209788 28981946\n907645400 111982636 978445563 686621115 486475154 734616351 587635888 527524079 454844580 826849288\n868863954 490627044 967828344 887235558 138021910 435784230 343307056 118718683 547282350 757693154\n32344652 101428952 585897722 693817619 790433406 848494439 873744405 604427602 951889915 989125209\n865548541 642980476 603592935 911086893 466178404 79002814 902745597 825893950 147052664 805753279\n```\n\n**Sample Output 4**\n\n```\n862518623 606960987 762676180 606184511 762408948 47716007 968649097 788324707 140177479 484063588\n```\n\nSolution:\n\n[BEGIN TEXT]\nOfficial Solution:\n\nPrepare \\(N\\) vertices and draw edges \\(y_i \\to x_i\\). In this graph, the out-degree and in-degree of each vertex are equal, and outgoing edges have a determined order for each vertex. Start at vertex \\(1\\) and traverse edges, choosing the next edge based on this order. This traversal ends at vertex \\(1\\), using all edges touching it. Repeat from vertices \\(2, 3, \\cdots, N\\) to use all edges. Solve for the number of ways to traverse by using dynamic programming: \\(dp[i][j]\\) is the number of ways to reach vertex \\(i\\) after \\(j\\) edges. Consider \\(x_1\\) as the first edge destination. Trying all \\(N\\) choices involves solving \\(N\\) similar problems, which can be optimized by reversing the movement order. The complexity is \\(O(N^3 M)\\).\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree with \\( N \\) vertices. The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally. Additionally, you are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\).\n\nDefine \\( f(i, j) \\) as follows:\n\n- If \\( A_i = A_j \\), then \\( f(i, j) \\) is the minimum number of edges needed to traverse from vertex \\( i \\) to vertex \\( j \\).\n- If \\( A_i \\neq A_j \\), then \\( f(i, j) = 0 \\).\n\nCalculate the value of the following expression:\n\n\\[\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(i,j)\n\\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- The input graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nu_1 v_1\n...\nu_{N-1} v_{N-1}\nA_1 A_2 ... A_N\n```\n\n**Output**\n\nPrint the computed answer.\n\n**Sample Input 1**\n\n```\n4\n3 4\n4 2\n1 2\n2 1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nExplanation: \\( f(1,4)=2, f(2,3)=2 \\). For all other \\( i, j \\) \\((1 \\leq i < j \\leq N)\\), we have \\( f(i,j)=0 \\), so the answer is \\( 2+2=4 \\).\n\n**Sample Input 2**\n\n```\n8\n8 6\n3 8\n1 4\n7 8\n4 5\n3 4\n8 2\n1 2 2 2 3 1 1 3\n```\n\n**Sample Output 2**\n\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nApplying the centroid decomposition, it is sufficient to find the answer for paths passing through the root. We consider two cases depending on whether the endpoint of the path is the root or not. If it is root, one can naively perform BFS (Breadth-First Search). Otherwise, for each vertex \\(v\\), count how many times the path between vertex \\(v\\) and the root contributes to the answer. Let \\(c_1,\\ldots,c_k\\) be the children of the root, and suppose that vertex \\(v\\) is contained in the subtree \\(c_i\\). Then, the number of times the path between vertex \\(v\\) and the root contributes to the answer is found as (the number of vertices \\(u\\) contained in the current tree such that \\(A_v = A_u\\)) - (the number of vertices \\(u\\) in the subtree \\(c_i\\) such that \\(A_v = A_u\\)). The values required can all be found using a DFS (Depth-First Search), so the problem has been solved.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Here, \\( A_1, A_2, \\ldots, A_N \\) are all distinct. Which element in \\( A \\) is the second largest?\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( A_1, A_2, \\ldots, A_N \\) are all distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{N}\n```\n\n**Output**\n\nPrint the integer \\( X \\) such that the \\( X \\)-th element in \\( A \\) is the second largest.\n\n**Sample Input 1**\n```\n4\n8 2 5 1\n```\n\n**Sample Output 1**\n```\n3\n```\n\nThe second largest element in \\( A \\) is \\( A_3 \\), so print \\( 3 \\).\n\n**Sample Input 2**\n```\n8\n1 2 3 4 5 10 9 11\n```\n\n**Sample Output 2**\n```\n6\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Toyota Programming Contest 2024#8\uff08AtCoder Beginner Contest 365\uff09\n\nThe second largest value can be found in the sequence \\(A'\\) obtained by sorting \\(A\\). When \\(A\\) is sorted in ascending order, the second last value, or \\(A'_{N-1}\\), is the second largest value. Next, find the position of that value in \\(A\\) using for and if statements.\n\nSample code (Python3):\n\n```python\nn = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\ntar = b[n - 2]\nfor i in range(n):\n    if a[i] == tar:\n        print(i + 1)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["agc068_e", "abc359_g", "abc365_b"]}, "abc304_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 550 points\n\n## Problem Statement\n\nYou are given a weighted undirected connected graph \\( G \\) with \\( N \\) vertices and \\( N-1 \\) edges, where vertices are numbered from \\( 1 \\) to \\( N \\) and edges are numbered from \\( 1 \\) to \\( N-1 \\). Edge \\( i \\) connects vertices \\( a_i \\) and \\( b_i \\) with a weight of \\( c_i \\).\n\nYou are given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- You are given integers \\( u_i, v_i, w_i \\). Add an edge with weight \\( w_i \\) between vertices \\( u_i \\) and \\( v_i \\) in \\( G \\). Then, print the sum of the weights of the edges in a minimum spanning tree of \\( G \\).\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i < b_i \\leq N \\)\n- \\( 1 \\leq u_i < v_i \\leq N \\)\n- \\( 1 \\leq c_i, w_i \\leq 10 \\)\n- The graph is connected before processing the queries.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\na_1 b_1 c_1\n.\n.\n.\na_{N-1} b_{N-1} c_{N-1}\nu_1 v_1 w_1\n.\n.\n.\nu_Q v_Q w_Q\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n## Sample Input 1\n\n```\n4 4\n1 2 6\n2 3 5\n2 4 4\n1 3 3\n1 2 3\n1 4 10\n3 4 1\n```\n\n## Sample Output 1\n\n```\n12\n10\n10\n7\n```\n\nHere is the graph after adding the edge for each query. The edges included in the minimum spanning tree are colored red.\n\n## Sample Input 2\n\n```\n8 6\n1 8 8\n1 6 10\n1 5 8\n2 6 6\n6 7 6\n1 3 9\n2 4 7\n1 3 4\n1 6 7\n3 4 6\n1 5 1\n7 8 4\n3 5 3\n```\n\n## Sample Output 2\n\n```\n49\n46\n45\n38\n34\n33\n```\n\nSolution:\n\n```\nHere is the trimmed editorial:\n\n---\n\n**F - MST Query Editorial**\n\nLet \\(W=10\\) be the maximum edge weight. Let \\(G_k (0\\leq k\\leq W)\\) be the (unweighted) subgraph of \\(G\\) consisting of the edges of \\(G\\) with weights not more than \\(k\\). Let \\(H\\) be the number of connected components of a graph \\(H\\), then the sum of weights of edges in an MST of graph \\(G\\) equals \\(\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Proof) Approach 1:** Among the edges in an MST of \\(G\\), there are \\(N-c(G_k)\\) edges whose weight is not greater than \\(k\\). Therefore, there are \\(\\left(N-c(G_k)\\right)-\\left(N-c(G_{k-1})\\right)=c(G_{k-1})-c(G_k)\\) edges whose weight is exactly \\(k\\), so the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle \\sum_{k=1}^{W}k\\left(c(G_{k-1})-c(G_k)\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)\\right)-W\\cdot c(G_W)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Approach 2):** Among the edges in an MST of \\(G\\), there are \\(c(G_{k-1})-1\\) edges whose weight is not greater than \\(c(G_{k-1})-1\\). Thus, the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle\\sum_{k=1}^{W}\\left(c(G_{k-1})-1\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left(c(G_k)-1\\right)\\).\n\nFor each \\(k(0\\leq k\\lt W)\\), one can manage the number of connected components of \\(G_k\\) with a disjoint set union (DSU) to solve this problem in a total of \\(O(W(N+Q)\\alpha(N))\\). The complexity can be reduced to \\(O((WN+Q)\\alpha(N))\\).\n\n**Sample Code:**\n\n```python\nfrom atcoder.dsu import DSU\n\nN, Q = map(int, input().split())\nuf = [DSU(N + 1) for i in range(10)]\nans = 10 * N - 10\nfor i in range(N - 1 + Q):\n    a, b, c = map(int, input().split())\n    for j in range(c, 10):\n        if not uf[j].same(a, b):\n            ans -= 1\n            uf[j].merge(a, b)\n    if i >= N - 1:\n        print(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 350 points\n\n**Problem Statement:**\n\nA souvenir shop at AtCoder Land sells \\(N\\) boxes. The boxes are numbered from 1 to \\(N\\), and box \\(i\\) has a price of \\(A_i\\) yen and contains \\(A_i\\) pieces of candy. Takahashi wants to buy \\(M\\) out of the \\(N\\) boxes and give one box each to \\(M\\) people named 1, 2, ..., \\(M\\).\n\nHe wants to select the boxes such that:\n- For each \\(i = 1, 2, \\ldots, M\\), person \\(i\\) is given a box containing at least \\(B_i\\) pieces of candy.\n\nIt is not allowed to give more than one box to a single person or to give the same box to multiple people.\n\nDetermine whether it is possible to buy \\(M\\) boxes that can satisfy the condition. If it is possible, compute the minimum total cost Takahashi needs to pay.\n\n**Constraints:**\n- \\(1 \\leq M \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq A_i, B_i \\leq 10^9\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_M\n```\n\n**Output:**\n\nIf it is possible to buy \\(M\\) boxes that can satisfy the condition, print the minimum total amount of money Takahashi needs to pay. Otherwise, print \\(-1\\).\n\n**Sample Input 1:**\n```\n4 2\n3 4 5 4\n1 4\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n*Takahashi can buy boxes 1 and 4, and give box 1 to person 1 and box 4 to person 2 to satisfy the condition. In this case, he needs to pay 7 yen in total, and it is impossible to satisfy the condition by paying less than 7 yen, so print 7.*\n\n**Sample Input 2:**\n```\n3 3\n1 1 1\n1000000000 1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n-1\n```\n\n**Sample Input 3:**\n```\n7 3\n2 6 8 9 5 1 11\n3 5 7\n```\n\n**Sample Output 3:**\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nConsider determining the box to give to people \\(1, 2, \\ldots, M\\) in this order. The following greedy strategy executed for each \\(i = 1, 2, \\ldots , M\\) in order is valid.\n\nTo person \\(i\\), give the undistributed box containing at least \\(B_i\\) candies with the smallest number of candies in it. (Let us call this strategy \\((\\bigstar)\\).)\n\nWe will assume that this solution is not optimal to deduce a contradiction. Take an optimal solution. In this optimal solution, there is an \\(i\\) that violates the strategy \\((\\bigstar)\\). Take the minimum such \\(i\\). Let box \\(X\\) be the box that you would give to person \\(i\\) if you obey the strategy \\((\\bigstar)\\) up to \\(1,2,\\ldots, i-1, i\\). In the taken optimal solution, if box \\(X\\) is not given to anyone, then giving person \\(i\\) box \\(X\\) improves the solution, which contradicts the optimality. Thus you will give it to a person \\(j\\). Consider swapping the boxes to give to person \\(i\\) and to person \\(j\\). This operation keeps optimality, but the minimum \\(i\\) that violates \\((\\bigstar)\\) strictly increases, so repeating this yields a contradiction. Hence, the greedy algorithm has been justified.\n\nTherefore, it is sufficient to simulate this greedy algorithm fast enough. This can be done by using a data structure like `sortedcontainers.SortedList` in Python, or using the sliding window trick by using the fact that \\(A\\) and \\(B\\) can be sorted without changing the answer.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is an integer sequence \\( S \\) of length \\( N \\). Initially, all elements of \\( S \\) are \\( 0 \\).\n\nYou are also given two integer sequences of length \\( Q \\): \\( P = (P_1, P_2, \\dots, P_Q) \\) and \\( V = (V_1, V_2, \\dots, V_Q) \\).\n\nSnuke wants to perform \\( Q \\) operations on the sequence \\( S \\) in order. The \\( i \\)-th operation is as follows:\n\n- Perform one of the following:\n  - Replace each of the elements \\( S_1, S_2, \\dots, S_{P_i} \\) with \\( V_i \\). However, before this operation, if there is an element among \\( S_1, S_2, \\dots, S_{P_i} \\) that is strictly greater than \\( V_i \\), Snuke will start crying.\n  - Replace each of the elements \\( S_{P_i}, S_{P_i+1}, \\dots, S_N \\) with \\( V_i \\). However, before this operation, if there is an element among \\( S_{P_i}, S_{P_i+1}, \\dots, S_N \\) that is strictly greater than \\( V_i \\), Snuke will start crying.\n\nFind the number of sequences of \\( Q \\) operations where Snuke can perform all operations without crying, modulo \\( 998244353 \\).\n\nTwo sequences of operations are distinguished if and only if there is \\( 1 \\leq i \\leq Q \\) such that the choice for the \\( i \\)-th operation is different.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 5000 \\)\n- \\( 1 \\leq Q \\leq 5000 \\)\n- \\( 1 \\leq P_i \\leq N \\)\n- \\( 1 \\leq V_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nP_1 V_1\nP_2 V_2\n\\vdots\nP_Q V_Q\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n\n```\n8 3\n1 8\n8 1\n2 1\n```\n\n**Sample Output 1**\n\n```\n1\n```\n\nSnuke can perform the three operations without crying as follows:\n1. Replace \\( S_1 \\) with \\( 8 \\).\n2. Replace \\( S_8 \\) with \\( 1 \\).\n3. Replace \\( S_2, S_3, \\dots, S_8 \\) with \\( 1 \\).\n\nNo other sequences of operations satisfy the conditions, so the answer is \\( 1 \\). For example, if he replaces \\( S_1, S_2, \\dots, S_8 \\) with \\( 8 \\) in the first operation, he will cry in the second operation regardless of the choice.\n\n**Sample Input 2**\n\n```\n8 3\n8 1\n1 8\n1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\nNo matter how he performs the first two operations, he will cry in the third operation.\n\n**Sample Input 3**\n\n```\n241 82\n190 3207371\n229 3639088\n61 4428925\n84 17258698\n34 42692503\n207 59753183\n180 67198566\n78 99285033\n60 102449991\n234 122146510\n111 126959145\n141 152331579\n78 159855439\n11 169658471\n22 189991287\n37 204602946\n73 209329065\n72 215363269\n152 236450854\n175 237822921\n22 261431608\n144 252550201\n54 268889550\n238 276997357\n69 313065279\n226 330144323\n6 335788783\n126 345410019\n220 348318997\n166 365778763\n142 382251905\n200 406191336\n234 392702679\n83 409660987\n183 410908761\n142 445707116\n205 470279207\n230 486436406\n156 494269002\n113 495687706\n200 500005738\n162 505246499\n201 548652987\n86 449551554\n62 459527873\n32 574001635\n230 601073337\n175 610244315\n174 613857555\n181 637452273\n158 637866397\n148 648101378\n172 646898076\n144 682578257\n239 703460335\n192 713255331\n28 727075136\n196 730768166\n111 751850547\n90 762445737\n204 762552166\n72 773170159\n240 803415865\n32 798873367\n195 814999380\n72 842641864\n125 851815348\n116 858041919\n200 869948671\n195 873324903\n5 877767414\n105 877710280\n150 877719360\n9 884707717\n230 880263190\n88 967344715\n49 977643789\n167 979463984\n70 981400941\n114 991068035\n94 991951735\n141 995762200\n```\n\n**Sample Output 3**\n\n```\n682155965\n```\n\nRemember to take the count modulo \\( 998244353 \\).\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nA - Chmax Rush! Editorial by evima\n\nSolution: Let\u2019s denote the \\(i\\)-th operation as operation \\(i\\). For each operation, we will refer to the former choice as the left operation and the latter choice as the right operation. Consider the relationship between operations \\(i\\) and \\(j\\) for all integer pairs \\((i, j)\\) such that \\(1 \\leq i < j \\leq Q\\).\n\n- When \\(V_i \\leq V_j\\): Any choice is fine.\n- When \\(V_i > V_j\\) and \\(P_i = P_j\\): No matter what, Snuke will cry during operation \\(j\\), so the answer is \\(0\\).\n- When \\(V_i > V_j\\) and \\(P_i < P_j\\): Operation \\(i\\) must be a left operation, and operation \\(j\\) must be a right operation.\n- When \\(V_i > V_j\\) and \\(P_i > P_j\\): Operation \\(i\\) must be a right operation, and operation \\(j\\) must be a left operation.\n\nAfter determining the direction of each operation in this way, if there is a contradiction, it is clear that the answer is \\(0\\). If there is no contradiction, the answer is at least \\(1\\). This is because, for any operation, the direction is set so that it can be performed after the previous operations. For those operations whose direction is not set, either choice is fine, so let \\(x\\) be the number of such operations, and the answer is \\(2^x\\) modulo \\(998244353\\). Therefore, by implementing this directly, we can find the answer in \\(O(Q^2)\\) time. This is fast enough to solve this problem.\n\nJudge\u2019s Solution (PyPy3):\n```python\ndef change(p,k):\n    global kind\n    if kind[p]==0:\n        kind[p]=k\n    elif kind[p]!=k:\n        print(0)\n        exit()\n\nN,Q=map(int,input().split())\nope=[tuple(map(int,input().split())) for i in range(Q)]\nkind=[0]*Q\nfor i in range(Q):\n    for j in range(i+1,Q):\n        if ope[i][1]<=ope[j][1]:\n            continue\n        if ope[i][0]==ope[j][0]:\n            print(0)\n            exit()\n        elif ope[i][0]<ope[j][0]:\n            change(i,-1)\n            change(j,1)\n        else:\n            change(i,1)\n            change(j,-1)\nprint(pow(2,kind.count(0),998244353))\n```\n\nBonus: Consider how to solve this problem quickly even when \\(N, Q \\leq 2 \\times 10^5\\).\n```\n \n\n", "problem_ids": ["abc355_f", "abc358_d", "arc182_a"]}, "abc304_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi eats three plates for breakfast: rice, miso soup, and salad. His table is long and narrow, so he arranged the three plates in a row. The arrangement is given by a string \\( S \\), where the \\( i \\)-th plate from the left is rice if \\( S_i \\) is \\( R \\), miso soup if \\( S_i \\) is \\( M \\), and salad if \\( S_i \\) is \\( S \\).\n\nDetermine whether the plate of rice is to the left of the plate of miso soup.\n\n**Constraints**\n\n- \\(|S| = 3\\)\n- \\( S \\) contains one \\( R \\), one \\( M \\), and one \\( S \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n**Output**\n\nPrint `Yes` if the plate of rice is to the left of the plate of miso soup, and `No` otherwise.\n\n**Sample Input 1**\n\n```\nRSM\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nThe plate of rice is at the 1st position from the left, and the plate of miso soup is at the 3rd position from the left. Since the plate of rice is to the left, print `Yes`.\n\n**Sample Input 2**\n\n```\nSMR\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nThe plates are arranged as salad, miso soup, and rice from left to right.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 360\n\nA - A Healthy Breakfast Editorial by en_translator\n\nFor beginners: If you are new to learning programming, please try \"Welcome to AtCoder\" from the practice contest. There you can find a sample code for each language. If you are not familiar with programming contests, try some problems in \"AtCoder Beginners Selection.\" \"C++\u5165\u9580 AtCoder Programming Guide for beginners (APG4b)\" is a C++ tutorial for competitive programmers (in Japanese).\n\nSolution: Prepare a string variable s. Read input into s. Use a for loop to determine positions of R and M in s. Let pos_r and pos_m be those indices. Use an if statement to print 'Yes' if pos_r < pos_m, otherwise print 'No'. With only six possible strings for \\(S\\), you can manually determine the answer using a conditional branch. Sample code in C++ provided.\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nYou are given a string \\( S \\) consisting of lowercase and uppercase English letters. The length of \\( S \\) is odd. If the number of uppercase letters in \\( S \\) is greater than the number of lowercase letters, convert all lowercase letters in \\( S \\) to uppercase. Otherwise, convert all uppercase letters in \\( S \\) to lowercase.\n\nConstraints:\n- \\( S \\) is a string consisting of lowercase and uppercase English letters.\n- The length of \\( S \\) is an odd number between 1 and 99, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n\\( S \\)\n\nOutput:\nPrint the string \\( S \\) after converting the letters according to the problem statement.\n\nSample Input 1:\n```\nAtCoder\n```\n\nSample Output 1:\n```\natcoder\n```\nThe string `AtCoder` contains five lowercase letters and two uppercase letters. Thus, convert all uppercase letters in `AtCoder` to lowercase, which results in `atcoder`.\n\nSample Input 2:\n```\nSunTORY\n```\n\nSample Output 2:\n```\nSUNTORY\n```\nThe string `SunTORY` contains two lowercase letters and five uppercase letters. Thus, convert all lowercase letters in `SunTORY` to uppercase, which results in `SUNTORY`.\n\nSample Input 3:\n```\na\n```\n\nSample Output 3:\n```\na\n```\n\nSolution:\n\n        Here is the text:\n\n        [BEGIN TEXT]\n        Here is a succinct version of the editorial content relevant to the solution:\n\nThis problem requires processing strings by counting the occurrences of lowercase and uppercase letters in \\(S\\), and comparing them. If the number of lowercase letters is fewer, convert all uppercase letters to lowercase. Otherwise, convert all lowercase letters to uppercase. Most programming languages have functions for handling letter cases, such as:\n\n- `islower(c)`: checks if `c` is lowercase.\n- `isupper(c)`: checks if `c` is uppercase.\n- `tolower(c)`: converts `c` to lowercase.\n- `toupper(c)`: converts `c` to uppercase.\n\nThese functions can be used to implement the solution efficiently with a complexity of \\(\\mathrm{O}(|S|)\\).\n\nSample code (Python 3):\n\n```python\ndef process_string(S):\n    lower = sum(1 for c in S if c.islower())\n    upper = sum(1 for c in S if c.isupper())\n\n    if lower < upper:\n        S = ''.join(c.upper() for c in S)\n    else:\n        S = ''.join(c.lower() for c in S)\n\n    return S\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(process_string(S))\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\).\nAnswer the following \\( Q \\) queries.\n\nFor the \\( i \\)-th query, you are given integers \\( L_i \\) and \\( R_i \\).\nSolve the following problem for \\( B = (A_{L_i}, A_{L_{i}+1}, \\cdots, A_{R_i}) \\).\n\nDivide \\( B \\) into three non-empty contiguous subsequences. For each contiguous subsequence, find the maximum value of its elements. The task is to find the minimum possible sum of these maximum values.\n\nIt is guaranteed that the length of \\( B \\) is at least 3, so there is always at least one way to divide it into three non-empty contiguous subsequences.\n\n### Constraints\n\n- \\( 3 \\leq N \\leq 250000 \\)\n- \\( 1 \\leq Q \\leq 250000 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- \\( 1 \\leq L_i \\leq R_i \\leq N \\)\n- \\( R_i - L_i \\geq 2 \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from standard input in the following format:\n```\nN Q\nA_1 A_2 \\ldots A_N\nL_1 R_1\nL_2 R_2\n\u22ee\nL_Q R_Q\n```\n\n### Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n### Sample Input 1\n```\n7 5\n4 3 1 1 4 5 2\n1 7\n2 4\n3 5\n1 5\n4 7\n```\n\n### Sample Output 1\n```\n10\n5\n6\n9\n8\n```\n\nExplanation for the first query: We have \\( B = (4, 3, 1, 1, 4, 5, 2) \\). If you divide it into \\( (4, 3), (1, 1), (4, 5, 2) \\), the maximum values of the contiguous subsequences are 4, 1, and 5 respectively, and their sum is 10. There is no way to make this sum smaller, so the answer to this query is 10.\n\n### Sample Input 2\n```\n10 15\n8 3 8 10 1 5 3 1 6 4\n4 6\n2 5\n6 9\n8 10\n2 9\n4 10\n1 5\n1 8\n1 3\n4 8\n1 10\n2 10\n6 10\n2 6\n2 6\n```\n\n### Sample Output 2\n```\n16\n14\n12\n11\n17\n17\n19\n14\n19\n14\n17\n17\n12\n16\n16\n```\n\n\nSolution:\n\n        [BEGIN TEXT]\n        First, consider the case with one query. Suppose the input is \\(B=(B_1,\\cdots,B_N)\\). Let \\(B_m=\\max(B)\\). When decomposing \\(B\\) into \\(XYZ\\), consider the scenarios based on where \\(B_m\\) is included among \\(X, Y, Z\\). If \\(B_m\\) is in \\(Y\\), \\(\\max(Y)\\) is \\(B_m\\), so make \\(Y\\) larger: \\(X=(B_1), Y=(B_2,\\cdots,B_{N-1}), Z=(B_N)\\). If \\(B_m\\) is in \\(X\\), assume \\(Y\\) has one element. Try all possible positions for \\(Y\\) to calculate the answer. If \\(B_m\\) is in \\(Z\\), reverse the sequence to solve it similarly. For multiple queries, if \\(B_m\\) is in \\(Y\\), handle it with a simple RMQ. When \\(B_m\\) is in \\(X\\), use two main approaches: manage \\(\\max(Z)\\) for each \\(Y\\) by processing queries in ascending order of \\(R_i\\) with a segment tree for range addition and range minimum query or manage \\(Y\\) for each \\(\\max(Z)\\) with a stack and a segment tree for range minimum query. Using either approach, the time complexity is \\(O((N+Q) \\log N)\\).\n        [END TEXT]\n \n\n", "problem_ids": ["abc360_a", "abc357_b", "arc180_d"]}, "abc304_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a string \\( S \\) consisting of lowercase English letters and periods (`.`). Your task is to find the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Constraints**\n\n- \\( S \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters and periods (`.`).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\( S \\)\n\n**Output**\n\nPrint the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Sample Input 1**\n\n```\n.v.\n```\n\n**Sample Output 1**\n\n```\nv\n```\n\nRemoving all periods (`.`) from `.v.` yields `v`, so we print `v`.\n\n**Sample Input 2**\n\n```\nchokudai\n```\n\n**Sample Output 2**\n\n```\nchokudai\n```\n\nThere are cases where \\( S \\) does not contain periods (`.`).\n\n**Sample Input 3**\n\n```\n...\n```\n\n**Sample Output 3**\n\n```\n\n```\n\nThere are also cases where all characters in \\( S \\) are periods (`.`).\n\nSolution:\n\n```python\n# Python equivalent of C++ code\n\n# Standard implementation\n\nS = input()\nT = \"\"\nfor c in S:\n    if c != '.':\n        T += c\nprint(T)\n\n# Concise implementation\n\nS = input()\nS = S.replace('.', '')\nprint(S)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Your task is to find the value of:\n\n\\[\n\\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} \\left\\lfloor \\frac{\\max(A_i, A_j)}{\\min(A_i, A_j)} \\right\\rfloor\n\\]\n\nHere, \\(\\lfloor x \\rfloor\\) represents the greatest integer not greater than \\( x \\). For example, \\(\\lfloor 3.14 \\rfloor = 3\\) and \\(\\lfloor 2 \\rfloor = 2\\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n3 1 4\n```\n\n**Sample Output 1:**\n\n```\n8\n```\n\n*Explanation:* The sought value is:\n\n\\[\n\\left\\lfloor \\frac{\\max(3, 1)}{\\min(3, 1)} \\right\\rfloor + \\left\\lfloor \\frac{\\max(3, 4)}{\\min(3, 4)} \\right\\rfloor + \\left\\lfloor \\frac{\\max(1, 4)}{\\min(1, 4)} \\right\\rfloor = \\left\\lfloor \\frac{3}{1} \\right\\rfloor + \\left\\lfloor \\frac{4}{3} \\right\\rfloor + \\left\\lfloor \\frac{4}{1} \\right\\rfloor = 3 + 1 + 4 = 8\n\\]\n\n**Sample Input 2:**\n\n```\n6\n2 7 1 8 2 8\n```\n\n**Sample Output 2:**\n\n```\n53\n```\n\n**Sample Input 3:**\n\n```\n12\n3 31 314 3141 31415 314159 2 27 271 2718 27182 271828\n```\n\n**Sample Output 3:**\n\n```\n592622\n```\n\nSolution:\n\n```python\ndef calculate_max_min_sum(N, M, A):\n    # A should be sorted in ascending order\n    A.sort()\n    \n    # Pre-calculate the cumulative sum of C\n    C = [0] * (M + 1)\n    \n    # Count frequency of each element in A\n    for a in A:\n        C[a] += 1\n    \n    # Convert frequency to cumulative\n    for i in range(1, M + 1):\n        C[i] += C[i - 1]\n    \n    # Calculate the sum\n    max_min_sum = 0\n    for i in range(N - 1):\n        for n in range(1, M // A[i] + 1):\n            # Get count of j where floor(A_j/A[i]) = n\n            j_count = C[min(M, n * A[i])] - C[n * A[i] - 1]\n            max_min_sum += n * j_count\n    \n    return max_min_sum\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:  \nIn the \\( xy \\)-plane, there are three points \\( A(x_A, y_A) \\), \\( B(x_B, y_B) \\), and \\( C(x_C, y_C) \\) that are not collinear. Determine whether the triangle \\( ABC \\) is a right triangle.\n\nConstraints:  \n- \\( -1000 \\leq x_A, y_A, x_B, y_B, x_C, y_C \\leq 1000 \\)\n- The three points \\( A \\), \\( B \\), and \\( C \\) are not collinear.\n- All input values are integers.\n\nInput:  \nThe input is given from Standard Input in the following format:\n\n```\nx_A y_A  \nx_B y_B  \nx_C y_C  \n```\n\nOutput:  \nPrint `Yes` if the triangle \\( ABC \\) is a right triangle, and `No` otherwise.\n\nSample Input 1:  \n```\n0 0  \n4 0  \n0 3  \n```\n\nSample Output 1:  \n```\nYes\n```\n\nThe triangle \\( ABC \\) is a right triangle.\n\nSample Input 2:  \n```\n-4 3  \n2 1  \n3 4  \n```\n\nSample Output 2:  \n```\nYes\n```\n\nThe triangle \\( ABC \\) is a right triangle.\n\nSample Input 3:  \n```\n2 4  \n-3 2  \n1 -2  \n```\n\nSample Output 3:  \n```\nNo\n```\n\nThe triangle \\( ABC \\) is not a right triangle.\n\nSolution:\n\n```python\nxA, yA = map(int, input().split())\nxB, yB = map(int, input().split())\nxC, yC = map(int, input().split())\n\nAB2 = (xA - xB) ** 2 + (yA - yB) ** 2\nBC2 = (xB - xC) ** 2 + (yB - yC) ** 2\nCA2 = (xC - xA) ** 2 + (yC - yA) ** 2\n\nif AB2 + BC2 == CA2 or BC2 + CA2 == AB2 or CA2 + AB2 == BC2:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\n", "problem_ids": ["abc372_a", "abc356_e", "abc362_b"]}, "abc304_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), and a sequence of non-negative integers: \\( A = (A_1,A_2,\\ldots,A_N) \\).\n\nFor a non-empty non-negative integer sequence \\( B = (B_1,B_2,\\ldots,B_{|B|}) \\), we define its **score** as follows:\n- If the length of \\( B \\) is a multiple of \\( M \\): \\( (B_1 \\oplus B_2 \\oplus \\dots \\oplus B_{|B|})^K \\)\n- Otherwise: \\( 0 \\)\n\nHere, \\( \\oplus \\) represents the bitwise XOR.\n\nFind the sum, modulo \\( 998244353 \\), of the scores of the \\( 2^N-1 \\) non-empty subsequences of \\( A \\).\n\n### Constraints\n- \\( 1 \\leq N, K \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 0 \\leq A_i < 2^{20} \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n3 2 2\n1 2 3\n```\n\n### Sample Output 1\n```\n14\n```\n\nHere are the scores of the \\( 2^3-1=7 \\) non-empty subsequences of \\( A \\).\n- \\( (1) \\): \\( 0 \\)\n- \\( (2) \\): \\( 0 \\)\n- \\( (3) \\): \\( 0 \\)\n- \\( (1,2) \\): \\( (1 \\oplus 2)^2 = 9 \\)\n- \\( (1,3) \\): \\( (1 \\oplus 3)^2 = 4 \\)\n- \\( (2,3) \\): \\( (2 \\oplus 3)^2 = 1 \\)\n- \\( (1,2,3) \\): \\( 0 \\)\n\nTherefore, the sought sum is \\( 0 + 0 + 0 + 9 + 4 + 1 + 0 = 14 \\).\n\n### Sample Input 2\n```\n10 5 3\n100 100 100 100 100 100 100 100 100 100\n```\n\n### Sample Output 2\n```\n252000000\n```\n\n### Sample Input 3\n```\n16 4 100\n7053 3876 3178 8422 7802 5998 2334 6757 6889 6637 7365 9495 7848 9026 7312 6558\n```\n\n### Sample Output 3\n```\n432440016\n```\n\n\nSolution:\n\nThe problem requires knowledge of XOR convolution and Hadamard transform. Define \\(C_i\\) as the number of subsequences of \\(A\\) with length as a multiple of \\(M\\) and total XOR equals \\(i\\). We need to find \\(C_0, C_1, \\ldots, C_{2^L-1}\\) such that \\(\\sum_{i=0}^{2^L-1} C_i \\cdot i^K\\) is calculated, where \\(L=20\\).\n\nDefine sequences \\(v_i\\) such that each sequence term is a polynomial, with the 0-th term being 1, the \\(A_i\\)-th term as \\(x\\), and others 0. If \\(A_i=0\\), the 0-th term is \\(1+x\\). For two sequences \\(a, b\\), define the XOR convolution as \\((a \\ast b)_k = \\sum_{i \\oplus j = k} a_i \\times b_j\\). \n\nCompute the XOR convolution \\(V = v_1 \\ast v_2 \\ast \\cdots \\ast v_N\\). The coefficient of \\(x^j\\) of the \\(i\\)-th term (\\([x^j]V_i\\)) equals the number of length-\\(j\\) subsequences of \\(A\\) with a total XOR of \\(i\\), resulting in \\(C_i = [x^0]V_i + [x^M]V_i + \\cdots = [x^0]V_i \\, (\\text{mod } 1-x^M)\\).\n\nUtilize Hadamard conversion \\(H\\), where \\(H(a \\ast b)_i = H(a)_i \\times H(b)_i\\). Therefore, \\(H(V)_i = H(v_1)_i \\times \\cdots \\times H(v_N)_i\\). Compute \\(H(V)\\) using Hadamard conversion on sequences \\(v_1, v_2, \\ldots\\).\n\nGiven sequences that have 1 at the 0-th term and \\(x\\) at the \\(A_i\\)-th term, \\(H(v_i)\\) becomes \\((1+x)\\) or \\((1-x)\\). Thus, \\(H(V)_i\\) can be represented as \\((1+x)^{B_i}(1-x)^{N-B_i}\\). Calculate \\(B_i\\) efficiently using a combination of Hadamard conversion and population count divide-and-conquer strategy, allowing \\(O(L2^L)\\) calculation time. Alternatively, use \\(B_i = \\frac{H(\\text{cnt})_i + N}{2}\\).\n\nFind \\([x^0](1+x)^{B_i}(1-x)^{N-B_i} \\, (\\text{mod } 1-x^M)\\) in \\(O(NM)\\) using precalculated sequences for \\((1+x)^n\\) and \\((1-x)^n \\, (\\text{mod } 1-x^M)\\). Thus, the overall problem can be solved in \\(O(NM + 2^L (L + \\log K))\\) time.\n\nHere's the implementation:\n\n```python\nmod = 998244353\n\ndef hadamard(a, m):\n    for k in range(m):\n        i = 1 << k\n        for j in range(1 << m):\n            if not i & j:\n                a[j], a[i | j] = (a[j] + a[i | j]), (a[j] - a[i | j])\n\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nL = 20\ncnt = [0] * (1 << L)\nfor i in range(N):\n    cnt[A[i]] += 1\n\nF = [[0] * M for i in range(N + 1)]\nG = [[0] * M for i in range(N + 1)]\n\nF[0][0], G[0][0] = 1, 1\n\nfor i in range(N):\n    for j in range(M):\n        F[i + 1][j] = (F[i][j] + F[i][j - 1]) % mod\n        G[i + 1][j] = (G[i][j] - G[i][j - 1]) % mod\n\nres = [0] * (N + 1)\nfor i in range(N + 1):\n    for j in range(M):\n        res[i] += F[i][j] * G[N - i][-j]\n        res[i] %= mod\n\nhadamard(cnt, L)\nB = [(cnt[i] + N) // 2 for i in range(1 << L)]\nC = [res[B[i]] for i in range(1 << L)]\nhadamard(C, L)\n\ninv = pow(1 << L, mod - 2, mod)\nans = 0\nfor i in range(1 << L):\n    C[i] = C[i] % mod * inv % mod\n    ans += C[i] * pow(i, K, mod)\n    ans %= mod\n\nprint(ans)\n```\n\nCalculate \\(B\\) using divide-and-conquer:\n\n```python\ndef calc(off, k):\n    if k == 0:\n        return ([cnt[off]], cnt[off])\n    H0, c0 = calc(off, k - 1)\n    H1, c1 = calc(off | (1 << (k - 1)), k - 1)\n    H = [0] * (1 << k)\n    for i in range(1 << (k - 1)):\n        H[i] = H0[i] + H1[i]\n        H[i | (1 << (k - 1))] = H0[i] + c1 - H1[i]\n    return (H, c0 + c1)\n\nB = calc(0, L)[0]\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) boxes numbered from 1 to \\( N \\) and \\( N \\) items also numbered from 1 to \\( N \\). Item \\( i \\) (\\( 1 \\leq i \\leq N \\)) is located in box \\( A_i \\) and has a weight of \\( W_i \\).\n\nYou can repeatedly perform the operation of selecting an item and moving it to another box. The cost of moving an item with weight \\( w \\) is \\( w \\).\n\nFind the minimum total cost required to ensure that each box contains exactly one item.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\) (\\( 1 \\leq i \\leq N \\))\n- \\( 1 \\leq W_i \\leq 10^4 \\) (\\( 1 \\leq i \\leq N \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given in the following format from Standard Input:\n```\nN\nA_1 A_2 \\ldots A_N\nW_1 W_2 \\ldots W_N\n```\n\n**Output**\n\nPrint the minimum total cost required to make each box contain exactly one item.\n\n**Sample Input 1**\n```\n5\n2 2 3 3 5\n33 40 2 12 16\n```\n\n**Sample Output 1**\n```\n35\n```\n\n*Explanation*: With the following two moves, you can make each box contain exactly one item:\n1. Move item 1 from box 2 to box 1. The cost is 33.\n2. Move item 3 from box 3 to box 4. The cost is 2.\n\nThe total cost of these two moves is 35. It is impossible to make each box contain exactly one item with a cost less than 35, so print 35.\n\n**Sample Input 2**\n```\n12\n3 6 7 4 12 4 8 11 11 1 8 11\n3925 9785 9752 3587 4013 1117 3937 7045 6437 6208 3391 6309\n```\n\n**Sample Output 2**\n```\n17254\n```\n\n\nSolution:\n\n```python\n# Python3 translation of the given C++ code\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n\n    max_weight = [0] * n\n    for i in range(n):\n        a[i] -= 1\n        max_weight[a[i]] = max(max_weight[a[i]], w[i])\n\n    sum_w = sum(w)\n    sum_max = sum(max_weight)\n    print(sum_w - sum_max)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\n", "problem_ids": ["abc367_g", "abc360_c", "abc366_e"]}, "abc304_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe AtCoder railway line has \\( N \\) stations, numbered \\( 1, 2, \\ldots, N \\).\n\nOn this line, there are **inbound trains** that start at station \\( 1 \\) and stop at the stations \\( 2, 3, \\ldots, N \\) in order, and **outbound trains** that start at station \\( N \\) and stop at the stations \\( N - 1, N - 2, \\ldots, 1 \\) in order.\n\nTakahashi is about to travel from station \\( X \\) to station \\( Y \\) using only one of the inbound and outbound trains.\n\nDetermine whether the train stops at station \\( Z \\) during this travel.\n\n**Constraints**\n- \\( 3 \\leq N \\leq 100 \\)\n- \\( 1 \\leq X, Y, Z \\leq N \\)\n- \\( X \\), \\( Y \\), and \\( Z \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN X Y Z\n```\n\n**Output**\n\nIf the train stops at station \\( Z \\) during the travel from station \\( X \\) to station \\( Y \\), print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n```\n7 6 1 3\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Explanation:* To travel from station 6 to station 1, Takahashi will take an outbound train. After departing from station 6, the train stops at stations 5, 4, 3, 2, 1 in order, which include station 3, so you should print `Yes`.\n\n**Sample Input 2**\n```\n10 3 2 9\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n100 23 67 45\n```\n\n**Sample Output 3**\n```\nYes\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial content: \n\n---\n\nTakahashi takes an inbound train if \\(X < Y\\) and an outbound train if \\(X > Y\\). Takahashi\u2019s train will stop at station \\(Z\\) if and only if \\(X < Z < Y\\) if \\(X < Y\\), and \\(X > Z > Y\\) if \\(X > Y\\).\n\nSample code:\n```python\nn, x, y, z = map(int, input().split())\nif (x < z < y) or (y < z < x):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( A \\). You will perform the following operations:\n\n1. Generate \\( N \\) real numbers uniformly at random between 0 and 1, inclusive. All generations are independent, and the random numbers are uniformly distributed.\n   \n2. Call the generated \\( N \\) real numbers \\( x_1, x_2, \\ldots, x_N \\) in ascending order. That is, \\( 0 \\leq x_1 \\leq x_2 \\leq \\ldots \\leq x_N \\leq 1 \\).\n\n3. Your score is given by the following formula:\n\n   \\[\n   \\prod_{i=1}^{N} \\left(1 + \\sum_{j=i+1}^N x_j^A \\right)\n   \\]\n\nCalculate the expected value, modulo \\( 10^9+7 \\), of the score.\n\n**Definition of expected value modulo \\( 10^9+7 \\)**\n\nIt can be proved that the sought expected value is always rational. Furthermore, under the constraints of this problem, it can be proved that if the expected value is expressed as an irreducible fraction \\(\\frac{P}{Q}\\), then \\( Q \\not\\equiv 0 \\pmod{10^9+7} \\). Therefore, there exists a unique integer \\( R \\) such that \\( R \\times Q \\equiv P \\pmod{10^9+7} \\) and \\( 0 \\leq R < 10^9+7 \\). Report this \\( R \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq A \\leq 5 \\times 10^4 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1\n```\n\n**Sample Output 1**\n\n```\n666666673\n```\n\nThe expected value of the score is \\( \\frac{5}{3} \\).\n\n**Sample Input 2**\n\n```\n1 1\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\n**Sample Input 3**\n\n```\n2 2\n```\n\n**Sample Output 3**\n\n```\n500000005\n```\n\n**Sample Input 4**\n\n```\n3 2\n```\n\n**Sample Output 4**\n\n```\n142857147\n```\n\n**Sample Input 5**\n\n```\n5 3\n```\n\n**Sample Output 5**\n\n```\n758371066\n```\n\n**Sample Input 6**\n\n```\n10000 12345\n```\n\n**Sample Output 6**\n\n```\n32201773\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Let \\(a_n(y)\\) be the expected value for a real number \\(y\\) (\\(0 \\leq y \\leq 1\\)) and a non-negative integer \\(n\\). Generate \\(n\\) real numbers within \\([0,1]\\) as \\(x_1, \\cdots, x_n\\). If \\(x_1 < \\cdots < x_n < y\\) is not satisfied, output \\(0\\). If they are in ascending order, output \\(\\prod_{1 \\leq i \\leq n} (y^A + \\sum_{i < j \\leq n} x_j^A)\\).\n\nDefine \\(f(y,x) = \\sum_{0 \\leq n} a_n(y)x^n\\). \\(a_n(y)\\) is a polynomial in \\(y\\), and \\(f\\) is a formal power series. We aim to find \\(N! [x^N]f(1,x)\\). Consider choosing one term from \\(y^A, x_{i+1}^A, \\cdots x_N^A\\) for each \\(i\\) and calculating their product, forming a tree. We draw arrows based on choices: from \\(i\\) to \\(j\\) for \\(x_j^A\\), and \\(i\\) to * for choosing \\(y^A\\). This setup reveals an equation for \\(f\\), decomposed into subproblems for each subtree. The weight of a subtree rooted at child \\(v\\) is \\(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt\\).\n\nIf * has \\(k\\) children, subtrees are ordered and multiplied by \\(1/k!\\). Thus, \\(f\\) satisfies: \\(f(y,x) = \\exp(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt)\\). \\(a_n(y)\\) is a polynomial and a constant multiple of \\(y^{(A+1)n}\\). Write \\(g(z) = f(x,y)\\) with \\(z = y^{A+1}x\\) using power series \\(g(z) = \\sum_{0 \\leq n} b_n z^n\\). Rewrite \\(f\\) for \\(g\\): \\(g(z) = \\exp(\\sum_{0 \\leq n} \\frac{b_n}{(A+1)n+1} z^{n+1})\\).\n\nLet \\(h(z)\\) be inside \\(\\exp\\). Knowing \\([z^n] g\\) allows calculation of \\([z^{n+1}] h(z)\\) and \\([z^{n+1}] g(z)\\). The coefficients of \\(g\\) can be determined in order. Calculate \\([z^{n+1}] g(z)\\) using \\(\\frac{d}{dz}g = \\frac{d}{dz}\\exp(h) = \\frac{d}{dz}h \\times g\\), achievable in \\(O(n)\\). Solve the problem in \\(O(N^2)\\) time overall.\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\n", "problem_ids": ["abc352_a", "arc180_f", "abc368_c"]}, "abc305_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAtCoder Street is represented by a straight line on flat ground, with \\(N\\) utility poles of height \\(H\\) standing on it. These poles are numbered \\(1, 2, \\dots, N\\) in chronological order. Each pole \\(i\\) (where \\(1 \\leq i \\leq N\\)) is vertically positioned at coordinate \\(X_i\\), and the base of each pole is fixed to the ground. Assume the poles are sufficiently thin.\n\nThe street will experience \\(N\\) earthquakes. During the \\(i\\)-th earthquake (for \\(1 \\leq i \\leq N\\)), the following events occur:\n1. If pole \\(i\\) has not yet fallen, it falls to the left or the right on the number line, each with a probability of \\(\\frac{1}{2}\\).\n2. If a falling pole collides with another pole that has not yet fallen (including collision at the base), the latter pole will also fall in the same direction. This may trigger a chain reaction.\n\nThe direction in which a pole falls is independent of the direction in which other poles have fallen.\n\nFor earthquake preparedness, for each \\(t = 1, 2, \\dots, N\\), find the probability that all poles have fallen by exactly the \\(t\\)-th earthquake. Multiply it by \\(2^N\\) and print the result modulo \\(998244353\\). It can be proved that the values to be printed are integers.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq H \\leq 10^9\\)\n- \\(0 \\leq X_i \\leq 10^9\\) (for \\(1 \\leq i \\leq N\\))\n- \\(X_1, X_2, \\dots, X_N\\) are all distinct.\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n```\nN H\nX_1 X_2 \\cdots X_N\n```\n\n**Output:**\n\nPrint the answers for \\(t = 1, 2, \\dots, N\\) in this order, separated by spaces.\n\n**Sample Input 1:**\n```\n3 2\n0 3 1\n```\n\n**Sample Output 1:**\n```\n4 2 2\n```\n\n**Sample Input 2:**\n```\n4 10\n10 55 20 45\n```\n\n**Sample Output 2:**\n```\n0 4 4 8\n```\n\n**Sample Input 3:**\n```\n8 1\n5 0 6 3 8 1 7 2\n```\n\n**Sample Output 3:**\n```\n0 64 32 48 24 28 28 32\n```\n\n**Sample Input 4:**\n```\n40 20\n695 793 11 502 114 861 559 4 212 609 894 435 429 94 91 258 161 45 33 605 673 634 629 163 283 826 409 84 507 548 31 248 588 340 357 168 926 949 322 912\n```\n\n**Sample Output 4:**\n```\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41942627 41942627 360709869\n```\n\nSolution:\n\n```python\ndef find_probability_last_pole_falls(m, s):\n    \"\"\"Calculate the probability that the last pole to fall is the i-th pole.\"\"\"\n    # Step 3: Calculate probability\n    a = calculate_a(m, s)\n    b = calculate_b(m, s)\n    probability = (1 / (2 ** a)) * (b / 2)\n    return probability\n\ndef calculate_a(m, s):\n    \"\"\"Calculate the number of earthquakes for condition in Step 2.\"\"\"\n    count = 0\n    for earthquake in s:\n        if some_condition(earthquake):  # Replace with specific condition\n            count += 1\n    return count\n\ndef calculate_b(m, s):\n    \"\"\"Count conditions like p_i > p_{i+1} or i == m.\"\"\"\n    count = 0\n    for i in range(m):\n        if specific_condition(i, s):  # Replace with specific condition\n            count += 1\n    return count\n\ndef use_stack_for_min_updates(array):\n    \"\"\"Use a stack to manage minimum updates.\"\"\"\n    stack = []\n    result = {}\n    for index, value in enumerate(array):\n        while stack and stack[-1] > value:\n            stack.pop()\n        if not stack or stack[-1] != value:\n            result[index] = value\n        stack.append(value)\n    return result\n\nclass SegmentTree:\n    def __init__(self, data):\n        # Initialize the segment tree with the provided data\n        self.data = data\n        # Additional initialization as needed\n\n    def update(self, index, value):\n        # Update the segment tree at index with the new value\n        pass\n    \n    def calculate_modular_inverse(self, s1_times_sK):\n        # Calculate the modular inverse in real-time\n        pass\n\ndef aggregate_results(poles, earthquakes):\n    \"\"\"Aggregate results for problems concerning the poles.\"\"\"\n    last_pole_falls = []\n    for group in range(len(poles)):\n        if last_pole_falls[group] == group:\n            # Calculate probabilities using defined methods or classes\n            pass\n\n# Example on how the functions and classes could be used\nm = 5\ns = [1, 2, 3, 4, 5]  # Example data, replace with actual\nfind_probability_last_pole_falls(m, s)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n## Problem Statement\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(NK\\) is called a **good** integer sequence if each integer from \\(1\\) to \\(N\\) appears exactly \\(K\\) times in the sequence.\n\nLet \\(S\\) be the number of good integer sequences. Find the \\(\\operatorname{floor}((S+1)/2)\\)-th good integer sequence in lexicographical order. Here, \\(\\operatorname{floor}(x)\\) represents the largest integer not exceeding \\(x\\).\n\n### What is lexicographical order for sequences?\nA sequence \\(S = (S_1,S_2,\\ldots,S_{|S|})\\) is **lexicographically smaller** than a sequence \\(T = (T_1,T_2,\\ldots,T_{|T|})\\) if either 1. or 2. below holds:\n1. \\(|S| < |T|\\) and \\((S_1,S_2,\\ldots,S_{|S|}) = (T_1,T_2,\\ldots,T_{|S|})\\).\n2. There exists an integer \\(1 \\leq i \\leq \\min\\lbrace |S|, |T| \\rbrace\\) such that both of the following hold:\n   - \\((S_1,S_2,\\ldots,S_{i-1}) = (T_1,T_2,\\ldots,T_{i-1})\\)\n   - \\(S_i\\) is (numerically) smaller than \\(T_i\\).\n\n### Constraints\n- \\(1 \\leq N \\leq 500\\)\n- \\(1 \\leq K \\leq 500\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\n```\n\n### Output\nPrint the desired integer sequence, with elements separated by spaces.\n\n### Sample Input 1\n```\n2 2\n```\n\n### Sample Output 1\n```\n1 2 2 1\n```\n\nThere are six good integer sequences:\n- (1,1,2,2)\n- (1,2,1,2)\n- (1,2,2,1)\n- (2,1,1,2)\n- (2,1,2,1)\n- (2,2,1,1)\n\nTherefore, the answer is the 3rd sequence in lexicographical order, (1,2,2,1).\n\n### Sample Input 2\n```\n1 5\n```\n\n### Sample Output 2\n```\n1 1 1 1 1\n```\n\n### Sample Input 3\n```\n6 1\n```\n\n### Sample Output 3\n```\n3 6 5 4 2 1\n```\n\n### Sample Input 4\n```\n3 3\n```\n\n### Sample Output 4\n```\n2 2 2 1 3 3 3 1 1\n```\n\nSolution:\n\n```python\ndef lexicographically_largest_sequence(N, K):\n    sequence = []\n    \n    if N % 2 == 0:\n        # When N is even\n        first_element = N // 2\n        sequence.extend([first_element] * K)\n        remaining_elements = list(range(1, first_element)) + list(range(first_element + 1, N + 1))\n        remaining_elements.sort(reverse=True)\n    else:\n        # When N is odd\n        first_element = (N + 1) // 2\n        sequence.extend([first_element] * K)\n        remaining_elements = list(range(1, first_element)) + list(range(first_element + 1, N + 1))\n        remaining_elements.sort(reverse=True)\n    \n    # Append the remaining elements to form the final sequence\n    sequence.extend(remaining_elements[:N-K])\n    \n    return sequence\n\n# Testing the function with an example case\nN = 7\nK = 3\nresult = lexicographically_largest_sequence(N, K)\nprint(\"Lexicographically largest sequence:\", result)\n```\n\nConsider two cases based on the parity of \\(N\\).\n\nWhen \\(N\\) is even: The number of good sequences starting with \\(1,2,\\cdots,N/2\\) matches exactly with those starting with \\(N/2+1,\\cdots,N\\). Therefore, the desired sequence is the lexicographically largest one among the good sequences that start with \\(N/2\\). This can be obtained simply by sorting the remaining elements in descending order.\n\nWhen \\(N\\) is odd: The number of good sequences starting with \\(1,2,\\cdots,(N-1)/2\\) matches exactly with those starting with \\((N+3)/2,\\cdots,N\\). Thus, the first element of the desired sequence will be \\((N+1)/2\\). The next step is to find the sequence that is exactly at the middle in lexicographical order among the sequences obtained by arranging the remaining elements. Now, let\u2019s consider the second element. If \\((N+1)/2\\) remains, we can apply the same logic, and thus the second element will also be \\((N+1)/2\\). In the end, the first \\(K\\) elements will be \\((N+1)/2\\). The remaining part of the sequence can be obtained in the same way as in the even case, so this case is resolved as well.\n\nImplementing the above steps directly yields an \\(O(NK)\\) time solution.\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a positive integer \\( N \\), and an integer \\( A_{x,y,z} \\) for each triple of integers \\( (x, y, z) \\) such that \\( 1 \\leq x, y, z \\leq N \\).\n\nYou will be given \\( Q \\) queries in the following format, which must be processed in order.\n\nFor the \\( i \\)-th query \\( (1 \\leq i \\leq Q) \\), you are given a tuple of integers \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\) such that \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\), \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\), and \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\). Find:\n\n\\[\n\\displaystyle{\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}}\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 0 \\leq A_{x,y,z} \\leq 999 \\) where \\( 1 \\leq x, y, z \\leq N \\)\n- \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n- The integer \\( N \\)\n- An \\( N \\times N \\times N \\) array \\( A \\) of integers, given in the order \\( A_{1,1,1}, A_{1,1,2}, \\ldots \\), i.e., iterating through \\( x \\), then \\( y \\), then \\( z \\).\n- The integer \\( Q \\)\n- \\( Q \\) lines, each containing six integers representing \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\)\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n\n```\n2\n1 2\n3 4\n5 6\n7 8\n2\n1 2 2 2 1 1\n2 2 1 2 1 2\n```\n\n**Sample Output 1:**\n\n```\n10\n26\n```\n\n**Explanation:**\n\nFor the 1st query, the sought value is \\( A_{1,2,1} + A_{2,2,1} = 3 + 7 = 10 \\). Thus, print 10.\n\nFor the 2nd query, the sought value is \\( A_{2,1,1} + A_{2,1,2} + A_{2,2,1} + A_{2,2,2} = 5 + 6 + 7 + 8 = 26 \\). Thus, print 26.\n\n**Sample Input 2:**\n\n```\n3\n733 857 714\n956 208 257\n123 719 648\n840 881 245\n245 112 746\n306 942 694\n58 870 849\n13 208 789\n687 906 783\n8\n3 3 3 3 1 1\n1 3 2 3 3 3\n2 2 2 3 1 1\n1 3 1 1 1 1\n2 3 2 3 2 3\n1 2 1 1 1 2\n3 3 2 2 1 3\n1 2 2 3 2 3\n```\n\n**Sample Output 2:**\n\n```\n687\n3917\n551\n1631\n5180\n3311\n1010\n4326\n```\n\nSolution:\n\n```plaintext\nD - Cuboid Sum Query Editorial\n\nThis problem is an exercise of cumulative sums. We assume the knowledge of cumulative sums for a sequence (one-dimensional cumulative sums).\n\nGiven a length-\\(N\\) sequence \\(A\\), process \\(Q\\) queries. In the \\(i\\)-th query, given an integer pair \\((L_i,R_i)\\) satisfying \\(1 \\leq L_i \\leq R_i \\leq N\\), find \\(\\sum_{k=L_i}^{R_i}A_k\\).\n\nA solution to this problem is as follows: Define a length-\\((N+1)\\) sequence \\(S=(S_0,S_1,\\ldots S_N)\\) by \\(S_0=0,S_i=\\sum_{k=1}^{i-1}A_k\\), and use \\(\\sum_{k=L_i}^{R_i}A_k=S_{R_i+1}-S_{L_i}\\) to answer the query fast. The sequence \\(S\\) is called the cumulative sums of \\(A\\).\n\nThe original problem is an extension of this one-dimensional cumulative sum problem into three dimensions.\n\nConsider \\(S\\) such that \\(S_{i,j,k}=\\sum_{x=1}^{i-1} \\sum_{y=1}^{j-1}\\sum_{z=1}^{k-1}A_{x,y,z}\\) for \\(1 \\leq i,j,k \\leq N+1\\). If \\(i\\), \\(j\\), or \\(k\\) is \\(0\\), define \\(S_{i,j,k}=0\\).\n\nIt holds that \\(\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}=S_{Rx_i+1,Ry_i+1,Rz_i+1}-S_{Lx_i,Rx_i+1,Rz_i+1}-S_{Rx_i+1,Ly_i,Rz_i+1}-S_{Rx_i+1,Ry_i+1,Lz_i}+S_{Lx_i,Ly_i,Rz_i+1}+S_{Lx_i,Ry_i+1,Lz_i}+S_{Rx_i+1,Ly_i,Lz_i}-S_{Lx_i,Ly_i,Lz_i}\\).\n\nTherefore, if one can compute \\(S\\) fast, then each query can be answered in constant time.\n\n\\(S\\) can be found by the property that \\(S_{i,j,k}=S_{i-1,j,k}+S_{i,j-1,k}+S_{i,j,k-1}-S_{i-1,j-1,k}-S_{i-1,j,k-1}-S_{i,j-1,k-1}+S_{i-1,j-1,k-1}+A_{i-1,j-1,k-1}\\). The time complexity is \\(O(N^3+Q)\\).\n\nSample code (Python):\n```python\nn = int(input())\n\na = [[[0] * n for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        a[i][j]=list(map(int,input().split()))\n\nsum = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            sum[i + 1][j + 1][k + 1] = (sum[i][j+1][k+1]\n                                        + sum[i+1][j][k+1]\n                                        + sum[i+1][j+1][k]\n                                        - sum[i][j][k+1]\n                                        - sum[i][j+1][k]\n                                        - sum[i+1][j][k]\n                                        + sum[i][j][k]\n                                        + a[i][j][k])\n\nq = int(input())\nfor _ in range(q):\n    lx, rx, ly, ry, lz, rz = map(int, input().split())\n    lx -= 1\n    ly -= 1\n    lz -= 1\n\n    result = (sum[rx][ry][rz]\n                - sum[lx][ry][rz]\n                - sum[rx][ly][rz]\n                - sum[rx][ry][lz]\n                + sum[lx][ly][rz]\n                + sum[lx][ry][lz]\n                + sum[rx][ly][lz]\n                - sum[lx][ly][lz])\n    print(result)\n```\n```\n```\n \n\n", "problem_ids": ["arc177_d", "arc183_a", "abc366_d"]}, "abc305_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nIn Japan, there are six types of coins in circulation: 1 yen, 5 yen, 10 yen, 50 yen, 100 yen, and 500 yen. Answer the following question regarding these coins.\n\nMr. AtCoder's wallet contains:\n- \\( A \\) 1-yen coins,\n- \\( B \\) 5-yen coins,\n- \\( C \\) 10-yen coins,\n- \\( D \\) 50-yen coins,\n- \\( E \\) 100-yen coins,\n- \\( F \\) 500-yen coins.\n\nHe plans to shop at \\( N \\) stores in sequence. Specifically, at the \\( i \\)-th store (\\( 1 \\leq i \\leq N \\)), he plans to buy one item that costs \\( X_i \\) yen (including tax).\n\nGiving and receiving change takes time, so he wants to choose his coins so that he can pay the **exact amount** at each store. Determine if this is possible.\n\n**Constraints**\n- \\( 0 \\leq A \\leq 200 \\)\n- \\( 0 \\leq B \\leq 200 \\)\n- \\( 0 \\leq C \\leq 200 \\)\n- \\( 0 \\leq D \\leq 200 \\)\n- \\( 0 \\leq E \\leq 200 \\)\n- \\( 0 \\leq F \\leq 200 \\)\n- \\( 1 \\leq N \\leq 10 \\)\n- \\( 1 \\leq X_i \\leq 10000 \\) (for each \\( i \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C D E F\nN\nX_1 X_2 ... X_N\n```\n\n**Output**\n\nPrint `Yes` if the objective is achievable, and `No` otherwise.\n\n**Sample Input 1**\n```\n0 0 6 3 4 1\n3\n700 250 160\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*For example, he can make exact payments at all three stores as follows:*\n- At the first store: Use two 100-yen coins and one 500-yen coin.\n- At the second store: Use five 10-yen coins and two 100-yen coins.\n- At the third store: Use one 10-yen coin and three 50-yen coins.\n\n**Sample Input 2**\n```\n0 0 0 2 4 0\n3\n100 200 300\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*The total amount in the wallet is 500 yen, but a total payment of 100+200+300=600 yen is required, making it impossible to purchase all the items.*\n\n**Sample Input 3**\n```\n0 0 0 0 8 8\n1\n250\n```\n\n**Sample Output 3**\n```\nNo\n```\n\n*There are no 50-yen or smaller coins in the wallet, so it's impossible to pay exactly 250 yen.*\n\n**Sample Input 4**\n```\n20 5 9 7 10 6\n5\n177 177 177 177 177\n```\n\n**Sample Output 4**\n```\nYes\n```\n\n**Sample Input 5**\n```\n17 5 9 7 10 6\n5\n177 177 177 177 177\n```\n\n**Sample Output 5**\n```\nNo\n```\n\n\nSolution:\n\n\n        Here's the cleaned version focused on the solution:\n\n---\n\nMr. AtCoder has \\(A\\) 1-yen coins and \\(C\\) 10-yen coins, and must shop at \\(N\\) stores, spending \\(X_1, \\dots, X_N\\) yen. The goal is to determine if it is possible to pay the exact amount at each store.\n\nWhen possible, use 10-yen coins first to conserve 1-yen coins. There's no benefit in saving higher-value coins when purchasing with lower-value coins.\n\nThe same strategy applies when dealing with all coin types: \\(1\\), \\(5\\), \\(10\\), \\(50\\), \\(100\\), and \\(500\\)-yen coins. Pay with higher denominations first, until the amount left can be paid with the smaller denominations available, simulating if exact payment is possible at all stores.\n\nSample Python Implementation:\n\n```python\na, b, c, d, e, f = map(int, input().split())\nn = int(input())\nx = list(map(int, input().split()))\n\nans = True\nfor v in x:\n    while v >= 500 and f >= 1:\n        v -= 500\n        f -= 1\n    while v >= 100 and e >= 1:\n        v -= 100\n        e -= 1\n    while v >= 50 and d >= 1:\n        v -= 50\n        d -= 1\n    while v >= 10 and c >= 1:\n        v -= 10\n        c -= 1\n    while v >= 5 and b >= 1:\n        v -= 5\n        b -= 1\n    while v >= 1 and a >= 1:\n        v -= 1\n        a -= 1\n    if v != 0:\n        ans = False\n        break\n\nprint('Yes' if ans else 'No')\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\). Here, it is guaranteed that \\( 0 \\leq A_i < i \\) for each \\( i \\).\n\nThe **score** and **cost** of a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) are defined as follows:\n\n- The score of \\( P \\) is the length of the longest increasing subsequence of \\( P \\).\n- The cost of \\( P \\) is the number of integers \\( i \\) (\\( 1 \\leq i \\leq N \\)) that satisfy the following condition:\n  - There are fewer than \\( A_i \\) integers \\( j \\) such that \\( j < i \\) and \\( P_j > P_i \\).\n\nFor each \\( k = 1, 2, \\ldots, N \\), solve the following problem:\n\n- Find the minimum cost of a permutation \\( P \\) whose score is at least \\( k \\).\n\n### Constraints\n- \\( 1 \\leq N \\leq 250,000 \\)\n- \\( 0 \\leq A_i < i \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answers for \\( k = 1, 2, \\ldots, N \\) in this order.\n\n### Sample Input 1\n```\n4\n0 1 2 1\n```\n\n### Sample Output 1\n```\n0 0 1 3\n```\n\nFor each \\( k \\), a solution \\( P \\) is as follows:\n- \\( k=1 \\): If \\( P=(4, 2, 1, 3) \\), then \\( P \\) has the score of \\( 2 \\) and the cost of \\( 0 \\).\n- \\( k=2 \\): If \\( P=(4, 3, 1, 2) \\), then \\( P \\) has the score of \\( 2 \\) and the cost of \\( 0 \\).\n- \\( k=3 \\): If \\( P=(4, 1, 2, 3) \\), then \\( P \\) has the score of \\( 3 \\) and the cost of \\( 1 \\).\n- \\( k=4 \\): If \\( P=(1, 2, 3, 4) \\), then \\( P \\) has the score of \\( 4 \\) and the cost of \\( 3 \\).\n\n### Sample Input 2\n```\n3\n0 0 0\n```\n\n### Sample Output 2\n```\n0 0 0\n```\n\n### Sample Input 3\n```\n5\n0 1 2 3 4\n```\n\n### Sample Output 3\n```\n0 1 2 3 4\n```\n\n### Sample Input 4\n```\n11\n0 0 2 3 4 5 3 7 8 2 10\n```\n\n### Sample Output 4\n```\n0 0 0 1 2 3 4 5 7 8 9\n```\n\nSolution:\n\n```python\n# Consider the maximum score that can be achieved with a cost of 0.\n# Let's define the DP as:\n\n# dp[i][j] = when the order of P_1, ..., P_i is determined optimally,\n# the maximum length of an increasing subsequence ending with the j-th largest value among them.\n\n# Initialize N as the number of elements\nN = ...\n\n# Function to calculate maximum score with cost 0\ndef calculate_max_score(A):\n    dp = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    \n    # Initialize set S with elements from 1 to N\n    S = set(range(1, N + 1))\n    \n    for i in range(1, N + 1):\n        max_value_in_S = max(S)\n        \n        # Remove the maximum element from S not greater than A[i]\n        if max_value_in_S <= A[i - 1]:\n            S.remove(max_value_in_S)\n        \n        # Add i to S\n        S.add(i)\n        \n        # Calculate dp using set S\n        # The LIS length is the maximum value of dp[i]\n        dp[i] = sorted(list(S), reverse=True)\n\n    # Return the maximum LIS length\n    return len(S)\n\n# Assuming paying a cost of 1 allows setting one A_i to 0\n\ndef calculate_with_cost(A):\n    cost = N\n    result = []\n    \n    # Traverse A in descending order\n    for i in range(N, 0, -1):\n        A[i - 1] = 0\n        \n        # Calculate maximum score with new A\n        score = calculate_max_score(A)\n        result.append((cost, score))\n        \n        cost -= 1\n\n    # Return results in ascending order of cost\n    return sorted(result)\n\n# Example usage:\nA = [your_sequence_here]\nmax_score = calculate_max_score(A)\nprint('Maximum Score with cost 0:', max_score)\n\nscores_with_cost = calculate_with_cost(A)\nfor cost, score in scores_with_cost:\n    print(f'Cost: {cost}, Score: {score}')\n    \n# Time complexity is O(N log N)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 400 points\n\n**Problem Statement**\n\nThere are \\( N \\) buildings, Building 1, Building 2, ..., Building \\( N \\), arranged in a line in this order. The height of Building \\( i \\) (\\( 1 \\leq i \\leq N \\)) is \\( H_i \\).\n\nFor each \\( i = 1, 2, \\ldots, N \\), find the number of integers \\( j \\) (\\( i < j \\leq N \\)) satisfying the following condition:\n\n- There is no building taller than Building \\( j \\) between Buildings \\( i \\) and \\( j \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq N \\)\n- \\( H_i \\neq H_j \\ (i \\neq j) \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nFor each \\( i = 1, 2, \\ldots, N \\), let \\( c_i \\) be the number of \\( j \\) satisfying the condition. Print \\( c_1, c_2, \\ldots, c_N \\) in order, separated by spaces.\n\n**Sample Input 1**\n\n```\n5\n2 1 4 3 5\n```\n\n**Sample Output 1**\n\n```\n3 2 2 1 0\n```\n\nFor \\( i=1 \\), the integers \\( j \\) satisfying the condition are 2, 3, and 5: there are three. (Between Buildings 1 and 4, there is a building taller than Building 4, which is Building 3, so \\( j=4 \\) does not satisfy the condition.) Therefore, the first number in the output is 3.\n\n**Sample Input 2**\n\n```\n4\n1 2 3 4\n```\n\n**Sample Output 2**\n\n```\n3 2 1 0\n```\n\n**Sample Input 3**\n\n```\n10\n1 9 6 5 2 7 10 4 8 3\n```\n\n**Sample Output 3**\n\n```\n2 3 3 3 2 1 2 1 1 0\n```\n\nSolution:\n\n        Here is a clean version of the coding problem editorial:\n\n---\n\n**D - Buildings Editorial**\n\nFor each \\(i\\), let \\(J_i\\) be the sequence of conforming \\(j\\) sorted in ascending order, so that \\(H_{J_{i,1}} < H_{J_{i,2}} < H_{J_{i,3}} < \\ldots\\) holds. For \\(i \\neq N\\), focus on the difference between \\(J_{i+1}\\) and \\(J_i\\). \\(J_i\\) always contains \\((i+1)\\). Any \\(j \\in J_{i+1}\\) with \\(H_{i+1} > H_j\\) is not in \\(J_i\\). Meanwhile, any \\(j \\in J_{i+1}\\) with \\(H_{i+1} < H_i\\) is always in \\(J_i\\). By this order, one can obtain \\(J_{i+1}\\) from \\(J_i\\):\n\nLet \\(A = J_{i+1}\\). While \\(A\\) is non-empty, repeat the following:\n\n1. Let \\(j\\) be the initial element of \\(A\\). If \\(H_{i+1} > H_j\\), remove \\(j\\) from \\(A\\). Otherwise, terminate this loop.\n2. Push \\((i+1)\\) to the front of \\(A\\).\n\nThe current \\(A\\) is \\(J_i\\). Manage \\(J_i\\) in reverse order using a stack. Total complexity is \\(O(N)\\), as each \\(j\\) is put in and out at most once.\n\n```python\nn = int(input())\nh = list(map(int, input().split()))\nans = [0] * n\nstc = []\nfor i in range(n - 2, -1, -1):\n    while stc and h[stc[-1]] < h[i + 1]:\n        stc.pop()\n    stc.append(i + 1)\n    ans[i] = len(stc)\nprint(*ans)\n```\n \n\n", "problem_ids": ["arc177_a", "arc180_e", "abc372_d"]}, "abc305_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 100 points\n\n**Problem Statement**\n\nTakahashi is planning to eat \\( N \\) dishes. \n- The \\( i \\)-th dish he plans to eat is sweet if \\( S_i = \\text{sweet} \\), and salty if \\( S_i = \\text{salty} \\). \n- If he eats two sweet dishes consecutively, he will feel sick and be unable to eat any more dishes. \n\nDetermine whether he can eat all the dishes.\n\n**Constraints**\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is either \\text{sweet} or \\text{salty}.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nS_1\nS_2\n...\nS_N\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can eat all the dishes, and `No` otherwise.\n\n**Sample Input 1**\n```\n5\nsalty\nsweet\nsalty\nsalty\nsweet\n```\n\n**Sample Output 1**\n```\nYes\n```\n*Takahashi will not eat two sweet dishes consecutively, so he can eat all the dishes without feeling sick.*\n\n**Sample Input 2**\n```\n4\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 2**\n```\nYes\n```\n*He will feel sick but can still eat all the dishes.*\n\n**Sample Input 3**\n```\n6\nsalty\nsweet\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 3**\n```\nNo\n```\n*He feels sick when eating the 3rd dish and cannot eat the 4th and subsequent dishes.*\n\nSolution:\n\n        [BEGIN TEXT]\n        Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nIf there exists an integer \\(i\\) between \\(1\\) and \\((N-2)\\) such that the \\(i\\)-th and \\((i+1)\\)-th dishes to eat are both sweet, he cannot eat the \\((i+2)\\)-th dish and cannot eat all of the dishes. Otherwise, he does not get sick until eating the last dish, so he can eat all the dishes. Note that indices start from \\(0\\) in the following sample code.\n\n```python\nn = int(input())\ns = [input().strip() for _ in range(n)]\nans = \"Yes\"\nfor i in range(n - 2):\n    if s[i] == \"sweet\" and s[i + 1] == \"sweet\":\n        ans = \"No\"\nprint(ans)\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThe pattern of AtCoder's wallpaper can be represented on the xy-plane as follows:\n\n- The plane is divided by the following three types of lines:\n  - \\( x = n \\) (where \\( n \\) is an integer)\n  - \\( y = n \\) (where \\( n \\) is an even number)\n  - \\( x + y = n \\) (where \\( n \\) is an even number)\n\n- Each region is painted black or white. Any two regions adjacent along one of these lines are painted in different colors.\n- The region containing (0.5, 0.5) is painted black.\n\nYou are given integers \\( A, B, C, \\) and \\( D \\). Consider a rectangle whose sides are parallel to the x- and y-axes, with its bottom-left vertex at \\( (A, B) \\) and its top-right vertex at \\( (C, D) \\). Calculate the area of the regions painted black inside this rectangle, and print twice that area.\n\nIt can be proved that the output value will be an integer.\n\n**Constraints:**\n\n- \\( -10^9 \\leq A, B, C, D \\leq 10^9 \\)\n- \\( A < C \\) and \\( B < D \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nA B C D\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n\n```\n0 0 3 3\n```\n\n**Sample Output 1:**\n\n```\n10\n```\n\nThe area of the black-painted region inside the following square is 5, so print twice that value: 10.\n\n**Sample Input 2:**\n\n```\n-1 -2 1 3\n```\n\n**Sample Output 2:**\n\n```\n11\n```\n\nThe area is 5.5, but the output value is an integer.\n\n**Sample Input 3:**\n\n```\n-1000000000 -1000000000 1000000000 1000000000\n```\n\n**Sample Output 3:**\n\n```\n4000000000000000000\n```\n\nThis is the case with the largest rectangle, where the output still fits into a 64-bit signed integer.\n\nSolution:\n\n        Editorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nD - AtCoder Wallpaper Editorial by en_translator\n\nThe pattern of the wallpaper is an infinite repetition of this \\(4 \\times 2\\) rectangle. Thus, one can solve this problem by counting for each of the eight \\(1 \\times 1\\) squares how many instances of them are contained in the given rectangle. In order to count the number of squares at each position, it may be difficult to handle boundaries. As an example, we take the following approach in the sample code below.\n\nCount squares along \\(x\\) and \\(y\\) axes independently, and multiply it afterward. To count squares along the \\(x\\) axis, take a sufficiently large constant \\(P\\) that is a multiple of four (such as \\(1.1 \\times 10^9\\)), and compute \\((\\text{The number of squares between }x = -P\\text{ and }x = C) - (\\text{The number of squares between }x = -P\\text{ and }x = A)\\).\n\nWe pick such \\(P\\) to avoid issues on rounding-down division toward \\(0\\). Do the same thing for the \\(y\\) axis.\n\nAlso, when debugging this type of problem, it is effective to generate cases by yourself. In this problem, if it is a boundary issue that matters, it is a good idea to try many cases for \\(0 \\leq A, B, C, D \\leq 8\\).\n\nSample code (Python):\n```python\nmass = [[2, 1, 0, 1],\n        [1, 2, 1, 0]]\n# mass[i][j] : area of rectangle [[j, j + 1], [i, i + 1]] x 2\n\ninf = 4000000000\n\n# input\na, b, c, d = map(int, input().split())\n\n# calculation\nans = 0\nfor fy in range(2):\n    for fx in range(4):\n        x1 = (a - fx + 3 + inf) // 4\n        x2 = (c - fx + 3 + inf) // 4\n        count_x = x2 - x1  # count along x axis\n        y1 = (b - fy + 1 + inf) // 2\n        y2 = (d - fy + 1 + inf) // 2\n        count_y = y2 - y1  # count along y axis\n        ans += count_x * count_y * mass[fy][fx]\n\n# output\nprint(ans)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nTiles are laid out on a coordinate plane. There are two types of tiles: small tiles of size 1\u00d71 and large tiles of size K\u00d7K, laid out according to the following rules:\n\n- For each pair of integers (i,j), the square {(x,y) | i \u2264 x \u2264 i+1 and j \u2264 y \u2264 j+1} is contained within either one small tile or one large tile.\n  - If \u230ai/K\u230b + \u230aj/K\u230b is even, it is contained within a small tile.\n  - Otherwise, it is contained within a large tile.\n\nTiles include their boundaries, and no two different tiles have a positive area of intersection.\n\nFor example, when K = 3, tiles are laid out as follows:\n\nTakahashi starts at the point (S_x + 0.5, S_y + 0.5) on the coordinate plane.\n\nHe can repeat the following movement any number of times:\n- Choose a direction (up, down, left, or right) and a positive integer n. Move n units in that direction.\n\nEach time he crosses from one tile to another, he must pay a toll of 1.\n\nDetermine the minimum toll Takahashi must pay to reach the point (T_x + 0.5, T_y + 0.5).\n\n**Constraints**\n\n- 1 \u2264 K \u2264 10^16\n- 0 \u2264 S_x \u2264 2\u00d710^16\n- 0 \u2264 S_y \u2264 2\u00d710^16\n- 0 \u2264 T_x \u2264 2\u00d710^16\n- 0 \u2264 T_y \u2264 2\u00d710^16\n\nAll input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nK\nS_x S_y\nT_x T_y\n```\n\n**Output**\n\nPrint the minimum toll Takahashi must pay.\n\n**Sample Input 1**\n\n```\n3\n7 2\n1 6\n```\n\n**Sample Output 1**\n\n```\n5\n```\n\nFor example, he can move as follows, paying a toll of 5:\n- Move up by 3. Pay a toll of 1.\n- Move left by 2. Pay a toll of 1.\n- Move up by 1. Pay a toll of 1.\n- Move left by 4. Pay a toll of 2.\n\nThe toll paid cannot be 4 or less, so print 5.\n\n**Sample Input 2**\n\n```\n1\n41 42\n13 56\n```\n\n**Sample Output 2**\n\n```\n42\n```\n\nWhen he moves the shortest distance, he will always pay a toll of 42. The toll paid cannot be 41 or less, so print 42.\n\n**Sample Input 3**\n\n```\n100\n100 99\n199 1\n```\n\n**Sample Output 3**\n\n```\n0\n```\n\nThere are cases where no toll needs to be paid.\n\n**Sample Input 4**\n\n```\n96929423\n5105216413055191 10822465733465225\n1543712011036057 14412421458305526\n```\n\n**Sample Output 4**\n\n```\n79154049\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - AtCoder Beginner Contest 353\n\nOne possible upper bound is \\(|S _ x-T _ x|+|S _ y-T _ y|\\). If \\(K=1\\), it immediately follows that this is equal to the answer. Now, we assume \\(K\\geq2\\). If the answer is strictly less than this upper bound, then optimal paths pass through a large tile.\n\nWe enumerate all possible large tiles passing through for the first and last time in an optimal tour. The possible candidates of the first large tiles are:\n\n- If \\((S _ x+0.5,S _ y+0.5)\\) is on a large tile, then that large tile.\n- Otherwise, for each of the four directions, the first large tile you pass through when moving in that direction, totaling four large tiles.\n\nOne can immediately calculate tolls from the tile containing \\((S _ x+0.5,S _ y+0.5)\\) to each large tile. The last large tile is also limited to four candidates, and the toll required to reach from each large tile to \\((T _ x+0.5,T _ y+0.5)\\) as well. For these at most \\(16\\) pairs, it is sufficient to find the minimum toll required to travel between large tiles. One can use pruning to reduce pairs, but it is fast enough without it.\n\nWe consider how to find the minimum toll required to travel between two tiles. First, one can travel between two large tiles sharing a vertex for a toll of \\(2\\). Also, one can travel between a large tile \\([i,i+K]\\times[j,j+K]\\) and another \\([i+K,i+2K]\\times[j,j+K]\\) for a toll of \\(K=2\\), which must be considered only for \\(K=2\\). The minimum toll required to travel from a large tile \\(|a-c|+|b-d|+\\left\\vert\\dfrac{|a-c|-|b-d|}2\\right\\vert\\) to another \\([cK,(c+1)K]\\times[dK,(d+1)K]\\) is:\n\n- \\(|a-c|+|b-d|+\\left\\vert\\dfrac{|a-c|-|b-d|}2\\right\\vert\\) if \\(K=2\\).\n- \\(|a-c|+|b-d|+\\bigl\\vert|a-c|-|b-d|\\bigr\\vert=|a+b-c-d|+|a-b-c+d|\\) if \\(K\\neq2\\).\n\nThe problem can be solved using this feature.\n\n```python\nimport sys\n\nK = int(sys.stdin.readline().strip())\nSx, Sy, Tx, Ty = map(int, sys.stdin.readline().strip().split())\n\nSx += K\nSy += K\nTx += K\nTy += K\n\ndist = max(Tx, Sx) - min(Tx, Sx) + max(Ty, Sy) - min(Ty, Sy)\n\nif 1 < K:\n    large_start = []\n    if ((Sx // K) ^ (Sy // K)) & 1:\n        large_start.append((Sx // K, Sy // K, 0))\n    else:\n        large_start.append((Sx // K - 1, Sy // K, 1 + Sx % K))\n        large_start.append((Sx // K + 1, Sy // K, K - Sx % K))\n        large_start.append((Sx // K, Sy // K - 1, 1 + Sy % K))\n        large_start.append((Sx // K, Sy // K + 1, K - Sy % K))\n\n    large_goal = []\n    if ((Tx // K) ^ (Ty // K)) & 1:\n        large_goal.append((Tx // K, Ty // K, 0))\n    else:\n        large_goal.append((Tx // K - 1, Ty // K, 1 + Tx % K))\n        large_goal.append((Tx // K + 1, Ty // K, K - Tx % K))\n        large_goal.append((Tx // K, Ty // K - 1, 1 + Ty % K))\n        large_goal.append((Tx // K, Ty // K + 1, K - Ty % K))\n\n    if K == 2:\n        for x, y, d1 in large_start:\n            for z, w, d2 in large_goal:\n                x_diff = abs(x - z)\n                y_diff = abs(y - w)\n                dist = min(dist, d1 + d2 + x_diff + y_diff + (max(x_diff, y_diff) - min(x_diff, y_diff)) // 2)\n    else:\n        for x, y, d1 in large_start:\n            for z, w, d2 in large_goal:\n                dist = min(dist, d1 + d2 + abs(x + y - z - w) + abs(x - w - z + y))\n\nprint(dist)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc364_a", "abc354_d", "abc353_f"]}, "abc305_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nWe define an infinite sequence of positive integers \\( (a_1, a_2, \\ldots) \\) as \"good\" if and only if it satisfies both of the following conditions:\n1. There exists a finite constant \\( C \\) such that \\( a_n \\leq C \\cdot n \\) for all \\( 1 \\leq n \\).\n2. For all pairs of positive integers \\( (n, m) \\), \\( a_n \\mid a_m \\) if and only if \\( n \\mid m \\). Here, \\( x \\mid y \\) denotes that \\( x \\) divides \\( y \\).\n\nYou are given a positive integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\). Check if there exists a good infinite sequence starting with \\( (A_1, A_2, \\ldots, A_N) \\). You have \\( T \\) test cases to solve.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 5000 \\)\n- \\( 1 \\leq N \\leq 5000 \\)\n- \\( 1 \\leq A_i \\leq 10^{18} \\)\n- The sum of \\( N \\) across the test cases in a single input is at most 5000.\n- All input values are integers.\n\n**Input**\n\nThe input is given from standard input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nFor each test case, if there exists a good infinite sequence starting with \\( (A_1, A_2, \\ldots, A_N) \\), print `Yes`, and otherwise print `No`. In printing `Yes` or `No`, you can output each letter in any case (upper or lower).\n\n**Sample Input 1:**\n\n```\n5\n5\n1 2 3 4 5\n5\n1 4 9 16 25\n5\n1 4 6 8 10\n5\n1 2 4 4 5\n5\n1 2 3 5 4\n```\n\n**Sample Output 1:**\n\n```\nYes\nYes\nYes\nNo\nNo\n```\n\nFor the 1st test case, we can let \\( a_n = n \\) and that satisfies the condition.\n\nSolution:\n\n```\nAtCoder Grand Contest 067 - Editorial for Problem C: Divisibility Homomorphism\n\nClearly, all the \\(f(n)\\) are distinct. Let the primes be \\(p_1,p_2,\\cdots,p_k\\) in ascending order. We prove by induction on \\(k\\) that for all \\(u\\), \\(\\frac{f(p_ku)}{f(u)}\\) contains a prime factor at least \\(p_k\\), while \\(f(p_k^N)=C_k p_k^N\\) for sufficiently large \\(N\\).\n\nThe base is trivial for \\(k=0\\). For the induction step, consider an \\(X\\) with sufficient powers of \\(p_1,p_2,\\cdots,p_{k-1}\\). By \\(\\operatorname{LCM}(f(u),f(X))\\mid f(uX)\\) while \\(f(p_ku)\\nmid f(uX)\\), or \\(\\frac{f(p_ku)}{f(u)}\\nmid \\frac{f(uX)}{f(u)}\\), we know that the LHS contains a prime factor bigger than \\(p_{k-1}\\). We conclude \\(f(p_k^{N+1})\\ge p_kf(p_k^N)\\), and the strict inequality can occur at most \\(\\log_{p_{k+1}/p_k}C\\) times, proving the latter.\n\nAfter the induction, if \\(v_p(x)>v_p(y)\\), then \\(v_p (f(x)) > v_p (f(y))\\); otherwise, we can pick \\(Z\\) with sufficient prime powers of \\(f(x)\\) except \\(p\\), contradicting \\(f(x)|f(yZ)\\) and \\(x\\nmid yZ\\). This condition is sufficient as long as the given numbers don\u2019t contradict divisibility.\n\nFor \\(x\\nmid y\\), considering a prime \\(p\\) with \\(v_p(x)>v_p(y)\\), we conclude that \\(f(x)\\nmid f(y)\\). To make \\(f(x)\\mid f(y)\\) for all \\(x\\mid y\\), construct as follows: for each prime and each \u201clayer\u201d (meaning numbers \\(x\\) with \\(v_p(x)=\\text{Const}\\)), let the power of \\(p\\) be the maximum among its descendants (if the layer is empty, make the power all the same, at the minimal nonexisting integer).\n\nChecking all by brute force works in \\(O(n\\log (\\max a_i)+n \\pi (n))\\) time.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 350 points\n\n**Problem Statement**\n\nYou are given a string \\( S \\) of length \\( N \\). You are also given \\( Q \\) queries, which you should process in order.\n\nThe \\( i \\)-th query is as follows:\n- Given an integer \\( X_i \\) and a character \\( C_i \\), replace the \\( X_i \\)-th character of \\( S \\) with \\( C_i \\). Then, print the number of times the string \"ABC\" appears as a substring in \\( S \\).\n\nHere, a **substring** of \\( S \\) is a string obtained by deleting zero or more characters from the beginning and zero or more characters from the end of \\( S \\). For example, \"ab\" is a substring of \"abc\", but \"ac\" is not a substring of \"abc\".\n\n**Constraints**\n\n- \\( 3 \\le N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le Q \\le 2 \\times 10^5 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of uppercase English letters.\n- \\( 1 \\le X_i \\le N \\)\n- \\( C_i \\) is an uppercase English letter.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN Q\nS\nX_1 C_1\nX_2 C_2\n\\vdots\nX_Q C_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (1 \u2264 \\( i \\) \u2264 \\( Q \\)) should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n```\n7 4\nABCDABC\n4 B\n3 A\n5 C\n4 G\n```\n\n**Sample Output 1**\n```\n2\n1\n1\n0\n```\n\nAfter processing each query, \\( S \\) becomes as follows:\n- After the first query: \\( S = \\) \"ABCBABC\". In this string, \"ABC\" appears twice as a substring.\n- After the second query: \\( S = \\) \"ABABABC\". In this string, \"ABC\" appears once as a substring.\n- After the third query: \\( S = \\) \"ABABCBC\". In this string, \"ABC\" appears once as a substring.\n- After the fourth query: \\( S = \\) \"ABAGCBC\". In this string, \"ABC\" appears zero times as a substring.\n\n**Sample Input 2**\n```\n3 3\nABC\n1 A\n2 B\n3 C\n```\n\n**Sample Output 2**\n```\n1\n1\n1\n```\n\nThere are cases where \\( S \\) does not change through processing a query.\n\n**Sample Input 3**\n```\n15 10\nBBCCBCACCBACACA\n9 C\n11 B\n5 B\n11 B\n4 A\n8 C\n8 B\n5 B\n7 B\n14 B\n```\n\n**Sample Output 3**\n```\n0\n0\n0\n0\n1\n1\n2\n2\n1\n1\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nC - Count ABC Again Editorial by en_translator\n\nIf you ignore the constraints, the following solution is valid:\n\nModify the \\(X_i\\)-th character of \\(S\\) to \\(C_i\\). Inspect the \\((N-2)\\) length-\\(3\\) substrings of \\(S\\), check if each coincides with ABC, and print the number of such substrings.\n\nHowever, \\(N\\) and \\(Q\\) can become as large as \\(2\\times 10^5\\), so this solution would result in TLE (Time Limit Exceeded). Now notice that modifying one character of \\(S\\) changes at most three length-\\(3\\) substrings of \\(S\\). For example, suppose that \\(S=\\) ABCDEFGHI has become \\(S=\\) ABCZEFGI. Before the modification, the length-\\(3\\) substrings of \\(S\\) were:\n\nABC, BCD, CDE, DEF, EFG, FGH, GHI.\n\nAfter the modification, it has become:\n\nABC, BCZ, CZE, ZEF, EFG, FGH, GHI.\n\nAmong them, only three substrings have changed. In general, at most three length-\\(3\\) substrings will change. Therefore, it is sufficient to inspect only three substrings that possibly changes, count the number of ABC before and after modifications, and find the answer after the modification based on the difference and the count before the modification. The complexity is \\(O(N+Q)\\).\n\nSample code (Python3)\n```python\nN, Q = map(int, input().split())\nS = list(input())\nans = 0\nfor i in range(N - 2):\n    if S[i] == \"A\" and S[i + 1] == \"B\" and S[i + 2] == \"C\":\n        ans += 1\nfor _ in range(Q):\n    t, c = input().split()\n    t = int(t) - 1\n    for k in range(3):\n        idx = t - k\n        if 0 <= idx and idx + 2 < N:\n            if S[idx] == \"A\" and S[idx + 1] == \"B\" and S[idx + 2] == \"C\":\n                ans -= 1\n    S[t] = c\n    for k in range(3):\n        idx = t - k\n        if 0 <= idx and idx + 2 < N:\n            if S[idx] == \"A\" and S[idx + 1] == \"B\" and S[idx + 2] == \"C\":\n                ans += 1\n    print(ans)\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n## Problem Statement\n\nAn election is being held with \\( N \\) candidates numbered \\( 1, 2, \\ldots, N \\). There are \\( K \\) votes, some of which have been counted so far. Up until now, candidate \\( i \\) has received \\( A_i \\) votes.\n\nAfter all ballots are counted, candidate \\( i \\) (\\( 1 \\leq i \\leq N \\)) will be elected if and only if the number of candidates who have received more votes than them is less than \\( M \\). There may be multiple candidates elected.\n\nFor each candidate, find the minimum number of additional votes they need from the remaining ballots to guarantee their victory regardless of how the other candidates receive votes. Formally, solve the following problem for each \\( i = 1,2,\\ldots,N \\).\n\nDetermine if there is a non-negative integer \\( X \\) not exceeding \\( K - \\displaystyle{\\sum_{i=1}^{N}} A_i \\) satisfying the following condition. If it exists, find the minimum possible such integer.\n\n- If candidate \\( i \\) receives \\( X \\) additional votes, then candidate \\( i \\) will always be elected.\n\n### Constraints\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq K \\leq 10^{12} \\)\n- \\( 0 \\leq A_i \\leq 10^{12} \\)\n- \\( \\displaystyle{\\sum_{i=1}^{N} A_i} \\leq K \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nLet \\( C_i \\) be the minimum number of additional votes candidate \\( i \\) needs from the remaining ballots to guarantee their victory regardless of how other candidates receive votes. Print \\( C_1, C_2, \\ldots, C_N \\) separated by spaces.\n\nIf candidate \\( i \\) has already secured their victory, then let \\( C_i = 0 \\). If candidate \\( i \\) cannot secure their victory under any circumstances, then let \\( C_i = -1 \\).\n\n### Sample Input 1\n\n```\n5 2 16\n3 1 4 1 5\n```\n\n### Sample Output 1\n\n```\n2 -1 1 -1 0\n```\n\n14 votes have been counted so far, and 2 votes are left. The \\( C \\) to output is \\((2, -1, 1, -1, 0)\\). For example:\n- Candidate 1 can secure their victory by obtaining 2 more votes, while not by obtaining 1 more vote. Thus, \\( C_1 = 2 \\).\n- Candidate 2 can never (even if they obtain 2 more votes) secure their victory, so \\( C_2 = -1 \\).\n\n### Sample Input 2\n\n```\n12 1 570\n81 62 17 5 5 86 15 7 79 26 6 28\n```\n\n### Sample Output 2\n\n```\n79 89 111 117 117 74 112 116 80 107 117 106\n```\n\nSolution:\n\n```python\nfrom itertools import accumulate\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    rem = k - sum(a)\n\n    if n == m:\n        print(' '.join(['0'] * n))\n        return\n\n    ord = list(range(n))\n    ord.sort(key=lambda i: a[i])\n    b = sorted(a)\n    sumb = [0] + list(accumulate(b))\n\n    ans = [-1] * n\n    for i in range(n):\n        l, r = -1, rem + 1\n        while r - l > 1:\n            mid = (l + r) // 2\n            rid = next((idx for idx, val in enumerate(b) if val >= b[i] + mid + 1), n)\n            lid = n - m - (1 if i >= n - m else 0)\n            cnt = 0\n            if rid > lid:\n                cnt += (rid - lid) * (b[i] + mid + 1) - (sumb[rid] - sumb[lid])\n            if lid <= i < rid:\n                cnt -= 1\n            else:\n                cnt += mid\n            if cnt > rem:\n                r = mid\n            else:\n                l = mid\n        ans[ord[i]] = -1 if l == rem else r\n\n    print(' '.join(map(str, ans)))\n\nmain()\n```\n \n\n", "problem_ids": ["agc067_c", "abc372_c", "abc373_e"]}, "abc305_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given two sequences of length \\( N \\): \\( D = (D_1, D_2, \\dots, D_N) \\) and \\( P = (P_1, P_2, \\dots, P_N) \\).\n\nProcess \\( Q \\) queries in the order they are given. Each query is given in the following format:\n\n- \\( c \\, x \\, y \\): Change \\( D_c \\) to \\( x \\) and \\( P_c \\) to \\( y \\). Then, solve the following problem and print the answer.\n\nThere are \\( N \\) jobs numbered \\( 1 \\) to \\( N \\).\nStarting from today (consider this as day \\( 1 \\)), you will choose and complete one job per day for \\( N \\) days.\nIf you complete job \\( i \\) on or before day \\( D_i \\), you will receive a reward of \\( P_i \\). (If you do not complete it by day \\( D_i \\), you get nothing.)\nFind the maximum total reward you can achieve by choosing the optimal order of completing the jobs.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq Q \\leq 10^5 \\)\n- \\( 1 \\leq D_i \\leq N \\)\n- \\( 1 \\leq P_i \\leq 10^9 \\)\n- \\( 1 \\leq c \\leq N \\)\n- \\( 1 \\leq x \\leq N \\)\n- \\( 1 \\leq y \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format. Here, \\( \\mathrm{query}_i \\) denotes the \\( i \\)-th query.\n\n```\nN Q\nD_1 D_2 \\dots D_N\nP_1 P_2 \\dots P_N\n\\mathrm{query}_1\n\\mathrm{query}_2\n\\vdots\n\\mathrm{query}_Q\n```\n\nEach query is given in the following format.\n\n```\nc x y\n```\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n\n```\n3 2\n1 2 3\n3 6 3\n3 1 4\n2 3 9\n```\n\n**Sample Output 1**\n\n```\n10\n13\n```\n\nThe first query is as follows:\n\n- Update \\( D_3 \\) to \\( 1 \\) and \\( P_3 \\) to \\( 4 \\). Now, \\( D = (1, 2, 1) \\) and \\( P = (3, 6, 4) \\).\n- In the subproblem, one optimal procedure is to complete job \\( 3 \\) on day \\( 1 \\), job \\( 2 \\) on day \\( 2 \\), and job \\( 1 \\) on day \\( 3 \\). The total reward is \\( 10 \\), so print \\( 10 \\).\n\nThe second query is as follows:\n\n- Update \\( D_2 \\) to \\( 3 \\) and \\( P_2 \\) to \\( 9 \\). Now, \\( D = (1, 3, 1) \\) and \\( P = (3, 9, 4) \\).\n- In the subproblem, one optimal procedure is to complete job \\( 3 \\) on day \\( 1 \\), job \\( 1 \\) on day \\( 2 \\), and job \\( 2 \\) on day \\( 3 \\). The total reward is \\( 13 \\), so print \\( 13 \\).\n\n**Sample Input 2**\n\n```\n5 1\n1 2 3 4 5\n1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1000000000\n```\n\n**Sample Output 2**\n\n```\n5000000000\n```\n\n**Sample Input 3**\n\n```\n10 10\n6 2 4 1 5 1 6 6 5 3\n45 65 71 52 86 52 48 60 40 98\n5 6 5\n8 4 34\n6 7 83\n1 3 21\n7 5 85\n7 4 51\n8 2 81\n2 7 54\n6 1 5\n8 6 30\n```\n\n**Sample Output 3**\n\n```\n394\n379\n462\n457\n459\n414\n443\n479\n401\n396\n```\n\nSolution:\n\nHere is the cleaned-up version of the coding problem editorial:\n\n---\n\nThere are various solutions for this problem, including one that utilizes properties of a matroid. In this editorial, we introduce an approach that formalizes the problem as a cost-flow problem.\n\nThe problem involves preprocessing using segment-tree divide-and-conquer. For offline queries, you can simplify them using segment-tree divide-and-conquer. Queries consist of inserting tasks into a set and removing the last task inserted. Segment-tree divide-and-conquer helps manage these queries efficiently by converting removal queries to undo queries, maintaining computational efficiency.\n\nA segment tree is prepared to manage the timeline of queries. Each node of the segment tree stores a vector that manages elements. After preprocessing, elements are inserted into the segment tree nodes, and a DFS is performed to process these nodes. The complexity is \\(\\mathrm{O}(Q \\log T f(n))\\), with \\(Q\\) as the number of queries, \\(T\\) as the maximum time, and \\(\\mathrm{O}(f(n))\\) as the complexity of insertion and undo queries.\n\nFormalizing the problem as a cost-flow problem, insertions are represented as cost-flow in a graph. The problem is simplified to one kind of query: inserting a new task and printing the answer to the subproblem. If a negative cycle exists when an edge is added, remove the negative cycle with the smallest cost to maintain optimal flow in the graph.\n\nThis cost-flow problem can be rephrased using operations on task sets, representing graph flows with task insertions. Tasks inserted into the set \\(X\\) can potentially fulfill the deadlines. Operations for updating task sets are derived from negative cycle removal in the cost-flow graph.\n\nUsing Hall\u2019s marriage theorem and segment trees, a data structure is constructed to manage task sets efficiently, supporting task insertion and validity checks. The problem solution operates within \\(\\mathrm{O}((N + Q) \\log Q \\log N)\\) time, which is efficient.\n\nBonus: There\u2019s an alternative \\(\\mathrm{O}((N + Q) \\log N)\\) solution the author holds but hasn\u2019t fully proven, left as an exercise to the reader.\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given three sequences of positive integers each of length \\( N \\):  \n\\( A = (A_1, A_2, \\ldots, A_N) \\),  \n\\( B = (B_1, B_2, \\ldots, B_N) \\), and  \n\\( C = (C_1, C_2, \\ldots, C_N) \\).  \n\nFind the number of pairs of positive integers \\( (x, y) \\) that satisfy the following condition for all \\( 1 \\leq i \\leq N \\):  \n\\[ A_i \\times x + B_i \\times y < C_i \\]\n\nIt can be proved that the number of such pairs of positive integers satisfying the condition is finite.\n\nYou are given \\( T \\) test cases, each of which should be solved.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq A_i, B_i, C_i \\leq 10^9 \\)  \n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).  \n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:  \n\\[\n\\begin{align*}\nT & \\\\\n\\mathrm{case}_1 & \\\\\n\\mathrm{case}_2 & \\\\\n\\vdots & \\\\\n\\mathrm{case}_T & \\\\\n\\end{align*}\n\\]\n\nEach test case is given in the following format:  \n\\[\n\\begin{align*}\nN & \\\\\nA_1 & B_1 & C_1 \\\\\nA_2 & B_2 & C_2 \\\\\n\\vdots & \\\\\nA_N & B_N & C_N \\\\\n\\end{align*}\n\\]\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line \\( (1 \\leq i \\leq T) \\) should contain the answer for the \\( i \\)-th test case.\n\n**Sample Input 1**\n\n```\n2\n2\n1 1 4\n1 2 5\n1\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n2\n0\n```\n\nIn the first test case, there are two valid pairs of integers: \\( (x, y) = (1, 1), (2, 1) \\). Thus, the first line should contain 2.  \nIn the second test case, there are no valid pairs of integers. Thus, the second line should contain 0.\n\n**Sample Input 2**\n\n```\n3\n7\n138 16011 918976\n5478 7748 499926\n5234 17727 748589\n1157 10511 643136\n31200 3005 721285\n28839 14469 798851\n1933 5378 864127\n9\n17775 1665 386430\n37001 863 922418\n9756 4182 746671\n12379 9106 807578\n3984 4049 640539\n25333 9869 780810\n20372 7000 688738\n16107 11974 827227\n10779 10531 770510\n5\n4916 14132 460944\n11856 45422 610561\n56014 18216 825793\n10363 6220 945356\n37418 33866 851593\n```\n\n**Sample Output 2**\n\n```\n660\n995\n140\n```\n\nSolution:\n\n```python\n# Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nfrom math import ceil, floor\n\ndef count_lattice_points(N, lines):\n    # Sort the lines in ascending order of their slopes\n    lines.sort(key=lambda line: line[0] / line[1])\n    \n    # Prepare an empty list to manage the lowermost lines\n    L = []\n    \n    # Implement the convex hull algorithm-like approach to filter lines\n    for line in lines:\n        while len(L) >= 2 and is_unnecessary(L[-2], L[-1], line):\n            L.pop()\n        L.append(line)\n    \n    # Adjust N to the number of lines in L\n    N = len(L)\n    \n    # Find X_max\n    X_max = min(ceil(C / A) for A, B, C in L)\n    \n    # Calculate the sum of contributions for each line\n    total = 0\n    for i in range(N):\n        A_i, B_i, C_i = L[i]\n        \n        # Determine x_i\n        x_i = float('inf') if i == N - 1 else ceil((L[i + 1][2] - C_i) / (A_i - L[i + 1][0]))\n        x_prev = -float('inf') if i == 0 else x_i\n        \n        # Sum over the valid x in the range [x_prev, x_i) and [1, X_max)\n        for x in range(max(1, ceil(x_prev)), min(x_i, X_max)):\n            total += floor((C_i - 1 - A_i * x) / B_i)\n    \n    return total\n\ndef is_unnecessary(line1, line2, line3):\n    \"\"\"\n    Determine if the line2 is unnecessary in the convex hull structure. \n    It can be computed by comparing cross products.\n    \"\"\"\n    A1, B1, C1 = line1\n    A2, B2, C2 = line2\n    A3, B3, C3 = line3\n    \n    # Return true if line2 is unnecessary\n    # Cross product comparison: (C2 - C1, A2 - A1) vs (C3 - C1, A3 - A1)\n    return (C2 - C1) * (A3 - A1) <= (C3 - C1) * (A2 - A1)\n```\n\nIn this Python code, we implement the algorithm described in the given editorial. The code converts the explanation into a function that computes the number of lattice points under the given lines, following the steps of sorting the lines, maintaining a valid set using a convex hull-like approach, and then summing contributions using a specified method.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Kingdom of AtCoder has \\( N \\) towns numbered from 1 to \\( N \\). To move from town \\( i \\) to town \\( j \\), you must pay a toll of \\( C \\times |i-j| \\) yen. Takahashi, a merchant, is considering participating in zero or more of \\( M \\) upcoming markets. The \\( i \\)-th market (\\( 1 \\leq i \\leq M \\)) is described by the pair of integers \\((T_i, P_i)\\), where the market is held in town \\( T_i \\) and he will earn \\( P_i \\) yen if he participates.\n\nFor all \\( 1 \\leq i < M \\), the \\( i \\)-th market ends before the \\((i+1)\\)-th market begins. The time it takes for him to move is negligible. He starts with \\( 10^{10^{100}} \\) yen and is initially in town 1. \n\nDetermine the maximum profit he can make by optimally choosing which markets to participate in and how to move. Formally, let \\( 10^{10^{100}} + X \\) be his final amount of money if he maximizes the amount of money he has after the \\( M \\) markets. Find \\( X \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq T_i \\leq N \\) (for \\( 1 \\leq i \\leq M \\))\n- \\( 1 \\leq P_i \\leq 10^{13} \\) (for \\( 1 \\leq i \\leq M \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN C\nM\nT_1 P_1\nT_2 P_2\n...\nT_M P_M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n6 3\n4\n5 30\n2 10\n4 25\n2 15\n```\n\n**Sample Output 1**\n\n```\n49\n```\n\n**Explanation for Sample 1**\n\nFor example, Takahashi can increase his money by 49 yen by acting as follows:\n- Move to town 5. His money becomes \\( 10^{10^{100}} - 12 \\) yen.\n- Participate in the first market. His money becomes \\( 10^{10^{100}} + 18 \\) yen.\n- Move to town 4. His money becomes \\( 10^{10^{100}} + 15 \\) yen.\n- Participate in the third market. His money becomes \\( 10^{10^{100}} + 40 \\) yen.\n- Move to town 2. His money becomes \\( 10^{10^{100}} + 34 \\) yen.\n- Participate in the fourth market. His money becomes \\( 10^{10^{100}} + 49 \\) yen.\n\nIt is impossible to increase his money to \\( 10^{10^{100}} + 50 \\) yen or more, so print 49.\n\n**Sample Input 2**\n\n```\n6 1000000000\n4\n5 30\n2 10\n4 25\n2 15\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Explanation for Sample 2**\n\nThe toll fee is so high that it is optimal for him not to move from town 1.\n\n**Sample Input 3**\n\n```\n50 10\n15\n37 261\n28 404\n49 582\n19 573\n18 633\n3 332\n31 213\n30 377\n50 783\n17 798\n4 561\n41 871\n15 525\n16 444\n26 453\n```\n\n**Sample Output 3**\n\n```\n5000\n```\n\n**Sample Input 4**\n\n```\n50 1000000000\n15\n30 60541209756\n48 49238708511\n1 73787345006\n24 47221018887\n9 20218773368\n34 40025202486\n14 28286410866\n24 82115648680\n37 62913240066\n14 92020110916\n24 20965327730\n32 67598565422\n39 79828753874\n40 52778306283\n40 67894622518\n```\n\n**Sample Output 4**\n\n```\n606214471001\n```\n\nNote that the output value may exceed the range of a 32-bit integer.\n\nSolution:\n\n```python\n# Python translation of the given C++ code\n\nclass SegmentTree:\n    OP = max\n    ID = 0\n\n    def __init__(self, n):\n        self.n = n\n        self.data = [self.ID] * (2 * n)\n\n    def set(self, p, value):\n        p += self.n\n        self.data[p] = value\n        p //= 2\n        while p > 0:\n            self.data[p] = self.OP(self.data[2 * p], self.data[2 * p + 1])\n            p //= 2\n\n    def prod(self, l, r):\n        l += self.n\n        r += self.n\n        result = self.ID\n        while l < r:\n            if l & 1:\n                result = self.OP(result, self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                result = self.OP(result, self.data[r])\n            l //= 2\n            r //= 2\n        return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    C = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    prefix = SegmentTree(N)\n    suffix = SegmentTree(N)\n    \n    offset = 2000000000000000000\n    \n    prefix.set(0, offset)\n    suffix.set(0, offset)\n    \n    ans = offset\n    \n    for _ in range(M):\n        T = int(data[idx]) - 1\n        idx += 1\n        P = int(data[idx])\n        idx += 1\n        \n        best = max(prefix.prod(0, T + 1) - C * T, suffix.prod(T, N) + C * T) + P\n        \n        ans = max(ans, best)\n        \n        prefix.set(T, best + C * T)\n        suffix.set(T, best - C * T)\n    \n    print(ans - offset)\n\n# The following is necessary since we are translating a full program.\n# In an actual competitive programming setting, you'd want to call main directly.\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc363_g", "abc372_g", "abc353_g"]}, "abc306_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nA pair of binary strings \\( (S, T) \\) is called **good** if and only if the following conditions are satisfied:\n\n1. \\( S \\) and \\( T \\) contain the same number of \\( 0 \\)s.\n2. \\( S \\) and \\( T \\) contain the same number of \\( 1 \\)s.\n\nParticularly, for a good string pair \\( (S, T) \\), \\( S \\) and \\( T \\) have the same length.\n\nFor a good string pair \\( (S, T) \\), we define an undirected graph \\( G(S, T) \\) as follows:\n\n- Let \\( L \\) be the length of \\( S \\). Create a graph \\( g \\) with vertices \\( 1, 2, \\cdots, L \\).\n- Let \\( n \\) be the number of \\( 0 \\)s in \\( S \\). Let the indices of \\( 0 \\)s in \\( S \\) be \\( 1 \\leq a_1 < a_2 < \\cdots < a_n \\leq L \\). Let the indices of \\( 0 \\)s in \\( T \\) be \\( 1 \\leq b_1 < b_2 < \\cdots < b_n \\leq L \\). For each \\( 1 \\leq i \\leq n \\), add an edge between vertices \\( a_i \\) and \\( b_i \\) to \\( g \\).\n- Let \\( m \\) be the number of \\( 1 \\)s in \\( S \\). Let the indices of \\( 1 \\)s in \\( S \\) be \\( 1 \\leq c_1 < c_2 < \\cdots < c_m \\leq L \\). Let the indices of \\( 1 \\)s in \\( T \\) be \\( 1 \\leq d_1 < d_2 < \\cdots < d_m \\leq L \\). For each \\( 1 \\leq i \\leq m \\), add an edge between vertices \\( c_i \\) and \\( d_i \\) to \\( g \\).\n\nThe graph \\( g \\) obtained through the above steps is \\( G(S, T) \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\). Find one good string pair \\( (S, T) \\) satisfying all of the following conditions:\n\n- Let \\( L \\) be the length of \\( S \\). It satisfies \\( N \\leq L \\leq 10^5 \\).\n- For each pair \\( 1 \\leq i, j \\leq N \\), vertices \\( i \\) and \\( j \\) belong to the same connected component in \\( G(S, T) \\) if and only if \\( A_i = A_j \\).\n\nIt can be proved that a solution always exists under the constraints of this problem.\n\n### Constraints\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n### Output\nPrint a solution in the following format:\n```\nL\nS\nT\n```\nHere, \\( L \\) is the length of \\( S \\) and \\( T \\).\n\nIf multiple solutions exist, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n1 2 1\n```\n\n### Sample Output 1\n```\n4\n0011\n1100\n```\nFor the \\( S \\) and \\( T \\) in the sample output, we obtain \\( G(S, T) \\) as follows:\n- Prepare a graph \\( g \\) with 4 vertices.\n- The indices of \\( 0 \\)s in \\( S \\) are \\( (1, 2) \\), and the indices of \\( 0 \\)s in \\( T \\) are \\( (3, 4) \\). Add edges \\( (1, 3) \\) and \\( (2, 4) \\) to \\( g \\).\n- The indices of \\( 1 \\)s in \\( S \\) are \\( (3, 4) \\), and the indices of \\( 1 \\)s in \\( T \\) are \\( (1, 2) \\). Add edges \\( (3, 1) \\) and \\( (4, 2) \\) to \\( g \\).\n\n\\( G(S, T) \\) has a connected component with vertices \\( (1, 3) \\) and another with vertices \\( (2, 4) \\). This satisfies all the conditions, so this \\( (S, T) \\) is a valid output.\n\n### Sample Input 2\n```\n5\n1 2 3 4 5\n```\n\n### Sample Output 2\n```\n5\n01010\n01010\n```\n\n### Sample Input 3\n```\n6\n1 1 1 1 1 1\n```\n\n### Sample Output 3\n```\n6\n011111\n111110\n```\n\n### Sample Input 4\n```\n10\n1 2 3 2 4 3 4 4 5 6\n```\n\n### Sample Output 4\n```\n21\n000101010111100011011\n011010000010101111110\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere's the cleaned version of the solution:\n\nFirst, initialize \\(S = 0 \\times N\\) (a string of \\(N\\) 0s), and \\(T = 1 \\times N\\). To satisfy the conditions, perform these operations: \n\n1. Append 0 to the end of \\(S\\), and 0 to the end of \\(T\\).\n2. Append 1 to the end of \\(S\\), and 0 to the end of \\(T\\).\n\nTrack the connected components of unmatched 0s and 1s. Let \\(x_1, x_2, \\cdots, x_k\\) be the components of unmatched 0s in \\(S\\), and \\(y_1, y_2, \\cdots, y_k\\) be for 1s in \\(T\\). Adding 0 to both \\(S\\) and \\(T\\) cyclically shifts \\(x\\) one position left. Adding 1 to \\(S\\) and 0 to \\(T\\) removes \\(x_1\\) and \\(y_1\\) and connects \\(x_1\\) and \\(y_1\\).\n\nTo meet \\(A\\), prepare a permutation \\(P\\) aligning with \\(A\\)'s cycle decomposition and connect \\(x_1\\) and \\(y_1\\) when \\(x_1 = A_{y_1}\\). The operations number is \\(O(N^2)\\).\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n## Problem Statement\n\nAn election is being held with \\( N \\) candidates numbered \\( 1, 2, \\ldots, N \\). There are \\( K \\) votes, some of which have been counted so far. Up until now, candidate \\( i \\) has received \\( A_i \\) votes.\n\nAfter all ballots are counted, candidate \\( i \\) (\\( 1 \\leq i \\leq N \\)) will be elected if and only if the number of candidates who have received more votes than them is less than \\( M \\). There may be multiple candidates elected.\n\nFor each candidate, find the minimum number of additional votes they need from the remaining ballots to guarantee their victory regardless of how the other candidates receive votes. Formally, solve the following problem for each \\( i = 1,2,\\ldots,N \\).\n\nDetermine if there is a non-negative integer \\( X \\) not exceeding \\( K - \\displaystyle{\\sum_{i=1}^{N}} A_i \\) satisfying the following condition. If it exists, find the minimum possible such integer.\n\n- If candidate \\( i \\) receives \\( X \\) additional votes, then candidate \\( i \\) will always be elected.\n\n### Constraints\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq K \\leq 10^{12} \\)\n- \\( 0 \\leq A_i \\leq 10^{12} \\)\n- \\( \\displaystyle{\\sum_{i=1}^{N} A_i} \\leq K \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nLet \\( C_i \\) be the minimum number of additional votes candidate \\( i \\) needs from the remaining ballots to guarantee their victory regardless of how other candidates receive votes. Print \\( C_1, C_2, \\ldots, C_N \\) separated by spaces.\n\nIf candidate \\( i \\) has already secured their victory, then let \\( C_i = 0 \\). If candidate \\( i \\) cannot secure their victory under any circumstances, then let \\( C_i = -1 \\).\n\n### Sample Input 1\n\n```\n5 2 16\n3 1 4 1 5\n```\n\n### Sample Output 1\n\n```\n2 -1 1 -1 0\n```\n\n14 votes have been counted so far, and 2 votes are left. The \\( C \\) to output is \\((2, -1, 1, -1, 0)\\). For example:\n- Candidate 1 can secure their victory by obtaining 2 more votes, while not by obtaining 1 more vote. Thus, \\( C_1 = 2 \\).\n- Candidate 2 can never (even if they obtain 2 more votes) secure their victory, so \\( C_2 = -1 \\).\n\n### Sample Input 2\n\n```\n12 1 570\n81 62 17 5 5 86 15 7 79 26 6 28\n```\n\n### Sample Output 2\n\n```\n79 89 111 117 117 74 112 116 80 107 117 106\n```\n\nSolution:\n\n```python\nfrom itertools import accumulate\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    rem = k - sum(a)\n\n    if n == m:\n        print(' '.join(['0'] * n))\n        return\n\n    ord = list(range(n))\n    ord.sort(key=lambda i: a[i])\n    b = sorted(a)\n    sumb = [0] + list(accumulate(b))\n\n    ans = [-1] * n\n    for i in range(n):\n        l, r = -1, rem + 1\n        while r - l > 1:\n            mid = (l + r) // 2\n            rid = next((idx for idx, val in enumerate(b) if val >= b[i] + mid + 1), n)\n            lid = n - m - (1 if i >= n - m else 0)\n            cnt = 0\n            if rid > lid:\n                cnt += (rid - lid) * (b[i] + mid + 1) - (sumb[rid] - sumb[lid])\n            if lid <= i < rid:\n                cnt -= 1\n            else:\n                cnt += mid\n            if cnt > rem:\n                r = mid\n            else:\n                l = mid\n        ans[ord[i]] = -1 if l == rem else r\n\n    print(' '.join(map(str, ans)))\n\nmain()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere are \\( N \\) types of items. The \\( i \\)-th type of item has a weight of \\( w_i \\) and a value of \\( v_i \\). Each type has \\( 10^{10} \\) items available.\n\nTakahashi is going to choose some items and put them into a bag with capacity \\( W \\). He wants to maximize the value of the selected items while avoiding choosing too many items of the same type. Hence, he defines the **happiness** of choosing \\( k_i \\) items of type \\( i \\) as \\( k_i v_i - k_i^2 \\). He wants to choose items to maximize the total happiness over all types while keeping the total weight at most \\( W \\). Calculate the maximum total happiness he can achieve.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 3000 \\)\n- \\( 1 \\leq W \\leq 3000 \\)\n- \\( 1 \\leq w_i \\leq W \\)\n- \\( 1 \\leq v_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN W\nw_1 v_1\nw_2 v_2\n\\vdots\nw_N v_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n2 10\n3 4\n3 2\n```\n\n**Sample Output 1:**\n```\n5\n```\n\nBy choosing 2 items of type 1 and 1 item of type 2, the total happiness can be 5, which is optimal. Here, the happiness for type 1 is \\( 2 \\times 4 - 2^2 = 4 \\), and the happiness for type 2 is \\( 1 \\times 2 - 1^2 = 1 \\). The total weight is 9, which is within the capacity 10.\n\n**Sample Input 2:**\n```\n3 6\n1 4\n2 3\n2 7\n```\n\n**Sample Output 2:**\n```\n14\n```\n\n**Sample Input 3:**\n```\n1 10\n1 7\n```\n\n**Sample Output 3:**\n```\n12\n```\n\nSolution:\n\n```python\n# Here is a streamlined version focusing on the core solution:\n\ndef dp_happiness(N, W, items):\n    # Initialize dp table\n    dp = [[0] * (W + 1) for _ in range(max_weight + 1)]\n    \n    for w in range(1, max_weight + 1):\n        values = [v for v_i, w_i in items if w_i == w]\n        m = len(values)\n        \n        def f_w(k):\n            happiness = 0\n            # Priority queue to maximize happiness delta\n            deltas = [v - 1 for v in values]\n            deltas.sort(reverse=True)\n            for i in range(k):\n                if deltas:\n                    happiness += deltas[0]\n                    deltas[0] -= 2\n                    deltas.sort(reverse=True)\n            return happiness\n        \n        for j in range(W + 1):\n            dp[w][j] = dp[w-1][j]\n            for k in range(0, j // w + 1):\n                dp[w][j] = max(dp[w][j], dp[w-1][j - k * w] + f_w(k))\n    \n    return dp[max_weight][W]\n\n# Example usage:\n# N: number of items\n# W: maximum weight\n# Items: list of tuples, each tuple is (value, weight)\nN = 5\nW = 10\nitems = [(3, 2), (2, 2), (4, 3), (5, 5)]\nmax_weight = max(item[1] for item in items)\n\nmax_happiness = dp_happiness(N, W, items)\nprint(f\"Maximum total happiness: {max_happiness}\")\n```\n\nThis Python code implements the Dynamic Programming approach described in the editorial, fully translated from the explanation provided. The function `dp_happiness` takes the number of items, maximum weight, and a list of items (each defined by a tuple of value and weight) and computes the maximum total happiness.\n \n\n", "problem_ids": ["agc068_b", "abc373_e", "abc373_f"]}, "abc306_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} (A_i \\oplus A_{i+1} \\oplus \\ldots \\oplus A_j) \\]\n\n**Notes on Bitwise XOR:**\n\nThe bitwise XOR of non-negative integers \\( A \\) and \\( B \\), denoted as \\( A \\oplus B \\), is defined as follows:\n\n- In the binary representation of \\( A \\oplus B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) position is 1 if and only if exactly one of the digits at the \\( 2^k \\) position in the binary representations of \\( A \\) and \\( B \\) is 1; otherwise, it is 0.\n\nFor example, \\( 3 \\oplus 5 = 6 \\) (in binary: \\( 011 \\oplus 101 = 110 \\)).\n\nIn general, the bitwise XOR of \\( k \\) integers \\( p_1, \\dots, p_k \\) is defined as \\( (\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k) \\). It can be proved that this is independent of the order of \\( p_1, \\dots, p_k \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n1 3 2\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n**Explanation:**\n\n\\( A_1 \\oplus A_2 = 2 \\), \\( A_1 \\oplus A_2 \\oplus A_3 = 0 \\), and \\( A_2 \\oplus A_3 = 1 \\), so the answer is \\( 2 + 0 + 1 = 3 \\).\n\n**Sample Input 2:**\n\n```\n7\n2 5 6 5 2 1 7\n```\n\n**Sample Output 2:**\n\n```\n83\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\nE - Xor Sigma Problem Editorial by en_translator\n\nIt is often effective to consider bitwise independently for a problem regarding XOR (exclusive logical sum). For each \\(j=0,1,\\ldots,27\\), define a sequence \\(B\\) of length \\(N\\) such that \\(B_i=1\\) if the \\(j\\)-th bit of \\(A_i\\) is \\(1\\) and \\(B_i=0\\) if it is \\(0\\). Solve the problem against \\(B\\) for each \\(j\\), and the total sum of the answers multiplied by \\(2^j\\) is the solution to the original problem. This simplifies the problem as \\(B\\) takes only zero or one, as opposed to \\(A\\) taking variable values.\n\nNext, the expression \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j)\\) requires the total XOR of a segment. This can be computed fast using cumulative XORs, similar to cumulative sums when computing the total sum on a segment. Define the array of cumulative XORs \\(C\\) by \\(C_0=0\\) and \\(C_i =B_1\\oplus \\ldots \\oplus B_i\\). Then \\(B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j = C_{i-1} \\oplus C_j\\).\n\nThe expression can be rewritten as follows:\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (C_{i-1} \\oplus C_j)  = \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j). \\]\n\nAdjusting the index \\(j\\) to start from \\(i+1\\):\n\\[ \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=0}^{N-1} (C_i\\oplus C_{i+1}) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=1}^{N} B_i. \\]\n\nNow \\(\\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j)\\) is the number of pairs of elements in \\(C\\) with different values, which equals the product of the number of occurrences of \\(0\\) and \\(1\\) in \\(C\\). Thus, the sought value can be evaluated with the total sum of \\(B\\) and the number of occurrences of \\(0\\) and \\(1\\) in the cumulative XORs. The problem is solved in \\(\\mathrm{O}(N \\log {\\mathrm{MAX_A}})\\) time.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(N\\) where all elements are between \\(1\\) and \\(2^K - 1\\), inclusive, is called a **good sequence**.\n\nThe **score** of a good sequence \\(A = (A_1, A_2, \\ldots, A_N)\\) is defined as follows:\n- The number of distinct integers that can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) using an integer \\(i\\) between \\(1\\) and \\(N\\), inclusive, and a non-negative integer \\(k\\).\n\nFor example, for \\(A = (3, 5)\\), five integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3,\\) and \\(5\\), so the score is \\(5\\).\n\nFind one good sequence with the maximum score.\n\nFor each input file, you are given \\(T\\) test cases to solve.\n\n### Constraints\n- \\(1 \\leq T \\leq 10^5\\)\n- \\(1 \\leq N \\leq 10^5\\)\n- \\(1 \\leq K \\leq 30\\)\n- The sum of \\(N\\) across the test cases in a single input file is at most \\(2 \\times 10^5\\).\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format. Here, \\(\\text{case}_i\\) denotes the \\(i\\)-th test case.\n\n```\nT\n\\text{case}_1\n\\text{case}_2\n\\vdots\n\\text{case}_T\n```\n\nEach test case is given in the following format:\n```\nN K\n```\n\n### Output\nPrint \\(T\\) lines.\n\nThe \\(i\\)-th line should contain the answer for \\(\\text{case}_i\\).\n\nIf there are multiple good sequences with the maximum score, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n3 3\n7 2\n8 20\n```\n\n### Sample Output 1\n```\n5 6 7\n2 2 3 3 1 3 3\n662933 967505 876482 840117 1035841 651549 543175 781219\n```\n\n**Explanation for the first test case:**\nFor \\(A = (5, 6, 7)\\), seven integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3, 5, 6,\\) and \\(7\\), so its score is \\(7\\). Outputs such as \\(A = (7, 4, 5)\\) and \\(A = (6, 5, 4)\\) would also be accepted.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nB - |{floor(A_i/2^k)}| Editorial by evima\n\nIn this explanation, we assume that indices start from \\(0\\). First, it is unnecessary to include elements less than \\(2^{K-1}\\) in \\(A\\). This is because replacing elements less than \\(2^{K-1}\\) with their double will result in the same or a higher score. Therefore, we can limit the elements of \\(A\\) to be between \\(2^{K-1}\\) and \\(2^K-1\\).\n\n1. When \\(N \\geq 2^{K-1}\\): We can include all elements between \\(2^{K-1}\\) and \\(2^K-1\\) in \\(A\\) and set \\(A_i = \\max(1, 2^K - 1 - i)\\) \\((0 \\le i < N)\\).\n\n2. When \\(N < 2^{K-1}\\): Consider an upper bound of the score. For \\(0 \\le x < K\\), consider the number of elements that appear as \\(\\displaystyle \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) between \\(2^x\\) and \\(2^{x+1}-1\\). For each \\(A_i\\), there is at most one \\(k\\) that satisfies \\(\\displaystyle 2^x \\le \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor < 2^{x+1}\\), so the number of such elements is at most \\(N\\). On the other hand, there are only \\(2^x\\) integers between \\(2^x\\) and \\(2^{x+1}\\), so the number of elements that appear in this range is at most \\(\\min(N, 2^x)\\). Therefore, by summing over all \\(x\\), the score has an upper bound of \\(\\displaystyle 1 + \\sum_{x=0}^{K-1}\\min(N, 2^x)\\).\n\nThis upper bound can always be achieved. Specifically, construct \\(A\\) as follows: Set \\(A_i\\) to the sum of \\(2^{K-1}\\) and the bit-reversal of \\(i\\). \u201cThe bit-reversal of \\(i\\)\u201d means the value obtained by reversing the \\((K-1)\\)-bit binary representation of \\(i\\).\n\nBy implementing the above, we can solve this problem. The time complexity is \\(O(NK)\\) due to the bit-reversal calculation being the bottleneck.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n\n    def bit_reversal(x):\n        return int(bin(x)[2:].zfill(K - 1)[::-1], 2)\n\n    if N >= 2 ** (K - 1):\n        print(*[max(1, 2**K - i - 1) for i in range(N)])\n    else:\n        print(*[2 ** (K - 1) + bit_reversal(i) for i in range(N)])\n```\n\nAdditionally, you can also solve it by constructing from the highest bit downwards.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n    C = [1]\n    for _ in range(1, K):\n        D = [2 * c for c in C] + [2 * c + 1 for c in C]\n        C = D[:N]\n    while len(C) < N:\n        C.append(1)\n    print(*C)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a tree with \\(N\\) vertices numbered from 1 to \\(N\\). The \\(i\\)-th edge connects vertices \\(A_i\\) and \\(B_i\\). Here, \\(N\\) is even, and furthermore, this tree has a perfect matching. Specifically, for each \\(i\\) (\\(1 \\leq i \\leq N/2\\)), it is guaranteed that \\(A_i = i \\times 2 - 1\\) and \\(B_i = i \\times 2\\).\n\nYou will perform the following operation \\(N/2\\) times:\n- Choose two leaves (vertices with degree exactly 1) and remove them from the tree. Here, the tree after removal must still have a perfect matching. In this problem, we consider a graph with zero vertices to be a tree as well.\n\nFor each operation, its score is defined as the distance between the two chosen vertices (the number of edges on the simple path connecting the two vertices).\n\nShow one procedure that maximizes the total score. It can be proved that there always exists a procedure to complete \\(N/2\\) operations under the constraints of this problem.\n\n**Constraints**\n- \\(2 \\leq N \\leq 250000\\)\n- \\(N\\) is even.\n- \\(1 \\leq A_i < B_i \\leq N\\) (\\(1 \\leq i \\leq N-1\\))\n- \\(A_i = i \\times 2 - 1\\), \\(B_i = i \\times 2\\) (\\(1 \\leq i \\leq N/2\\))\n- The given graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_{N-1} B_{N-1}\n```\n\n**Output**\n\nPrint a solution in the following format:\n```\nX_1 Y_1\nX_2 Y_2\n...\nX_{N/2} Y_{N/2}\n```\n\nHere, \\(X_i\\) and \\(Y_i\\) are the two vertices chosen in the \\(i\\)-th operation. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n```\n4\n1 2\n3 4\n2 3\n```\n\n**Sample Output 1**\n```\n4 1\n2 3\n```\n\nThe procedure in the sample output is as follows:\n- 1st operation: Remove vertices 4 and 1. The remaining tree has vertices 2 and 3, and a perfect matching. The score of this operation is 3.\n- 2nd operation: Remove vertices 2 and 3. The remaining tree has zero vertices and a perfect matching. The score of this operation is 1.\n- The total score is \\(3 + 1 = 4\\).\n\nIt is impossible to make the total score greater than 4, so this output solves this sample input.\n\n**Sample Input 2**\n```\n8\n1 2\n3 4\n5 6\n7 8\n2 3\n1 5\n1 7\n```\n\n**Sample Output 2**\n```\n4 8\n7 6\n5 3\n2 1\n```\n\n**Sample Input 3**\n```\n14\n1 2\n3 4\n5 6\n7 8\n9 10\n11 12\n13 14\n2 8\n4 11\n5 12\n7 13\n11 14\n9 13\n```\n\n**Sample Output 3**\n```\n1 6\n5 2\n8 12\n3 7\n10 4\n11 9\n13 14\n```\n\n**Sample Input 4**\n```\n20\n1 2\n3 4\n5 6\n7 8\n9 10\n11 12\n13 14\n15 16\n17 18\n19 20\n8 10\n16 18\n16 19\n5 9\n10 17\n2 13\n7 14\n3 7\n3 12\n```\n\n**Sample Output 4**\n```\n6 1\n2 15\n20 13\n14 19\n16 4\n11 18\n17 12\n3 5\n9 7\n8 10\n```\n\nSolution:\n\n```python\n# Problem: Keep Perfectly Matched (Translated to Python3)\n\n# Editorial Explanation:\n# For each edge, consider how many times it contributes to the score. An upper bound is the size\n# of the smaller of the two subtrees created when the edge is cut. This upper bound can be achieved\n# by treating the input tree as a rooted tree with the centroid R as the root. Let v1, v2, ..., vk \n# be the direct children of the root, and T1, T2, ..., Tk be their respective subtrees. Leaves \n# should be chosen from two different subtrees and removed, except for the last operation. Assume \n# the root is initially matched with v1. In the first operation, leaves of T1 and Tj (j != 1) must \n# be chosen. After this operation, the root is matched with vj. Choose Tj next, and so on. By \n# choosing the Tj with the largest size each time, all operations finish successfully. Though this \n# guarantees valid subtree vertex counts, it doesn't ensure proper leaf selection. Leaves can be \n# removed within each subtree by considering vertices top-down from the root. Assume focus is on \n# vertex v. If matched with a child, choose a leaf from that child\u2019s subtree. Otherwise, choose \n# another child and select a leaf from its subtree. This process leads to a leaf that can be \n# removed. The leaf removal procedure has a worst-case total time complexity of O(N^2), but by \n# modifying the procedure slightly, an efficient order to remove each vertex as a leaf can be \n# found. Perform a DFS prioritizing edges used in the matching and use vertices along the postorder \n# traversal. The problem can be solved in O(N log N) time.\n\n# Please note: The editorial does not contain specific code snippets, so this explanation outlines \n# the algorithmic approach described in the original editorial in Pythonic terms.\n```\n\nMarubeni Programming Contest 2024 (AtCoder Regular Contest 183)\n\nD - Keep Perfectly Matched Editorial by evima\n\nFor each edge, consider how many times it contributes to the score. An upper bound is the size of the smaller of the two subtrees created when the edge is cut. This upper bound can be achieved by treating the input tree as a rooted tree with the centroid \\(R\\) as the root. Let \\(v_1, v_2, \\cdots, v_k\\) be the direct children of the root, and \\(T_1, T_2, \\cdots, T_k\\) be their respective subtrees. Leaves should be chosen from two different subtrees and removed, except for the last operation. Assume the root is initially matched with \\(v_1\\). In the first operation, leaves of \\(T_1\\) and \\(T_j\\) (\\(j \\neq 1\\)) must be chosen. After this operation, the root is matched with \\(v_j\\). Choose \\(T_j\\) next, and so on. By choosing the \\(T_j\\) with the largest size each time, all operations finish successfully. Though this guarantees valid subtree vertex counts, it doesn't ensure proper leaf selection. Leaves can be removed within each subtree by considering vertices top-down from the root. Assume focus is on vertex \\(v\\). If matched with a child, choose a leaf from that child\u2019s subtree. Otherwise, choose another child and select a leaf from its subtree. This process leads to a leaf that can be removed. The leaf removal procedure has a worst-case total time complexity of \\(O(N^2)\\), but by modifying the procedure slightly, an efficient order to remove each vertex as a leaf can be found. Perform a DFS prioritizing edges used in the matching and use vertices along the postorder traversal. The problem can be solved in \\(O(N\\log N)\\) time.\n \n\n", "problem_ids": ["abc365_e", "arc182_b", "arc183_d"]}, "abc306_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n### Problem Statement\n\nThere is a keyboard with 26 keys arranged on a number line. The arrangement of this keyboard is represented by a string \\( S \\), which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character \\( S_x \\) is located at coordinate \\( x \\) \\((1 \\leq x \\leq 26)\\). Here, \\( S_x \\) denotes the \\( x \\)-th character of \\( S \\).\n\nYou will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key. Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.\n\n### Constraints\n\n- \\( S \\) is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n### Sample Output 1\n```\n25\n```\n\nFrom pressing the key for `A` to pressing the key for `Z`, you need to move your finger 1 unit at a time in the positive direction, resulting in a total traveled distance of 25. It is impossible to press all keys with a total traveled distance less than 25, so print 25.\n\n### Sample Input 2\n```\nMGJYIZDKSBHPVENFLQURTCWOAX\n```\n\n### Sample Output 2\n```\n223\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        For a character \\(c\\), let \\(X_c\\) be the coordinate of the key corresponding to the character \\(c\\). We need to find \\(|X_A-X_B|+|X_B-X_C|+\\ldots+|X_Y-X_Z|\\). If we can find \\(S\\) from \\(X\\), the sought value can be found using a for loop. An array can correspond the integer \\(0\\) to A, \\(1\\) to B, \\(\\ldots\\), and \\(25\\) to Z, so that \\(X\\) can be managed as an array. Alternatively, an associative array with its key as a character type can be used.\n\nSample code in Python3:\n\n```python\ns = input()\nx = [0] * 26\nfor i in range(26):\n    x[ord(s[i]) - ord(\"A\")] = i\nans = 0\nfor i in range(25):\n    ans += abs(x[i] - x[i + 1])\nprint(ans)\n```\n        [END TEXT]\n        \n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Score:** 900 points\n\n**Problem Statement:**  \nThere is a circle with circumference \\( L \\), and \\( L \\) people are standing equally spaced along the circumference. They are labeled as person \\( 0, 1, \\cdots, L-1 \\) in clockwise order. Consider choosing \\( N \\) from these \\( L \\) people. The **cost** of a choice is defined as follows:\n\n- For every pair of persons among the \\( N \\) chosen people, find the minimum distance one person has to move along the circumference to reach the other person's position. The maximum value among these distances is the cost.\n\nFind the sum of costs over all possible choices, modulo \\( 998244353 \\).\n\n**Constraints:**\n- \\( 2 \\leq N \\leq L \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**  \nThe input is given from Standard Input in the following format:\n```\nL N\n```\n\n**Output:**  \nPrint the answer.\n\n**Sample Input 1:**  \n```\n4 2\n```\n\n**Sample Output 1:**  \n```\n8\n```\n\nExplanation for Sample Input 1:  \nThe choices of \\( N \\) people and their corresponding costs are as follows:\n- \\( (0,1) \\): cost \\( 1 \\)\n- \\( (0,2) \\): cost \\( 2 \\)\n- \\( (0,3) \\): cost \\( 1 \\)\n- \\( (1,2) \\): cost \\( 1 \\)\n- \\( (1,3) \\): cost \\( 2 \\)\n- \\( (2,3) \\): cost \\( 1 \\)\n\nThe sum of these costs, \\( 8 \\), is the answer.\n\n**Sample Input 2:**  \n```\n5 5\n```\n\n**Sample Output 2:**  \n```\n2\n```\n\nExplanation for Sample Input 2:  \nWe can only choose all of them. In this case, the cost is \\( 2 \\).\n\n**Sample Input 3:**  \n```\n13 5\n```\n\n**Sample Output 3:**  \n```\n7618\n```\n\n**Sample Input 4:**  \n```\n1000000 100000\n```\n\n**Sample Output 4:**  \n```\n664396470\n```\n\nSolution:\n\n```python\nIf we know the answer when person 0 is always chosen, we can multiply it by L / N to get the original answer. Let\u2019s assume that person 0 is always chosen. For each D = 1, 2, ..., it suffices to find the number of ways to choose people so that the cost is less than D. First, people D, ..., L - D cannot be chosen. Next, consider whom to choose among people 1, 2, ..., D - 1. They can be chosen freely without interfering with each other. Finally, consider whom to choose among people L - D + 1, ..., L - 1. The condition for choosing person i is that none of the people in [i - L + D, i - D] have been chosen so far. Here, this interval is basically included within [1, D - 1]. If 2 * D <= i, this interval extends beyond that range, but the exceeding part is included in [D, L - D], from which we already know we are not choosing anyone, so we don\u2019t need to consider it specially. Let W = L - 2 * D + 1. We can regard the operation of choosing people from L - D + 1, ..., L - 1 as the operation of choosing intervals of length W among people 1, ..., D - 1. Then, what we need to consider is selecting people and intervals from people 1, ..., D - 1 so that they do not overlap (it\u2019s acceptable for intervals themselves to overlap). We will call a person chosen in the people selection as a red person. Also, in the interval selection, we will call the starting person of the interval as a blue person. If we fix the number of times red and blue alternate, the total number of ways to choose can be expressed using binomial coefficients. Also, the number of alternations is at most N // W. Therefore, if we perform this calculation for all D, the total computational complexity is O(N + N // 2 + N // 3 + ...) = O(N log N), so it runs sufficiently fast.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers of length \\( N \\): \\( A = (A_1, A_2, \\ldots, A_N) \\) and \\( B = (B_1, B_2, \\ldots, B_N) \\).\n\nYou are given \\( Q \\) queries to process in order. The \\( i \\)-th query is explained below:\n\n- You are given positive integers \\( l_i, r_i, L_i, R_i \\). Print \"Yes\" if it is possible to rearrange the subsequence \\( (A_{l_i}, A_{l_i+1}, \\ldots, A_{r_i}) \\) to match the subsequence \\( (B_{L_i}, B_{L_i+1}, \\ldots, B_{R_i}) \\), and \"No\" otherwise.\n\n**Constraints**\n\n- \\( 1 \\leq N, Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq l_i \\leq r_i \\leq N \\)\n- \\( 1 \\leq L_i \\leq R_i \\leq N \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nl_1 r_1 L_1 R_1\nl_2 r_2 L_2 R_2\n\\vdots\nl_Q r_Q L_Q R_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n\n```\n5 4\n1 2 3 2 4\n2 3 1 4 2\n1 3 1 3\n1 2 3 5\n1 4 2 5\n1 5 1 5\n```\n\n**Sample Output 1**\n\n```\nYes\nNo\nNo\nYes\n```\n\n**Explanation**\n\n- For the 1st query, it is possible to rearrange \\( (1, 2, 3) \\) to match \\( (2, 3, 1) \\). Hence, we print \"Yes\".\n- For the 2nd query, it is impossible to rearrange \\( (1, 2) \\) in any way to match \\( (1, 4, 2) \\). Hence, we print \"No\".\n- For the 3rd query, it is impossible to rearrange \\( (1, 2, 3, 2) \\) in any way to match \\( (3, 1, 4, 2) \\). Hence, we print \"No\".\n- For the 4th query, it is possible to rearrange \\( (1, 2, 3, 2, 4) \\) to match \\( (2, 3, 1, 4, 2) \\). Hence, we print \"Yes\".\n\n**Sample Input 2**\n\n```\n4 4\n4 4 4 4\n4 4 4 4\n1 2 2 3\n3 3 1 1\n1 3 1 4\n1 4 2 3\n```\n\n**Sample Output 2**\n\n```\nYes\nYes\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe problem requires processing queries to check if \\(\\{A_l,A_{l+1},\\ldots,A_r\\}\\) coincides with \\(\\{B_L,B_{L+1},\\ldots,B_R\\}\\) as a multiset. A method for this involves using Zobrist Hashing to determine set equivalence. The hash function \\(H\\) should meet these requirements: \n\n1. Compute \\(H(S)\\) of a multiset quickly.\n2. If two multisets \\(S\\) and \\(T\\) are equal, then \\(H(S)=H(T)\\).\n3. If \\(S\\) and \\(T\\) are not equal, then \\(H(S)\\neq H(T)\\) with high probability.\n\nTo implement this, assign a hash value to each integer between \\(1\\) and \\(N\\), and define the hash function of \\(S\\) as the sum of its element hash values, modulo \\(P\\) (a large prime). Precalculate cumulative sums of hash values to compute the hash of subsequences in \\(O(1)\\) time. Hence, the total time complexity is \\(O(N+Q)\\).\n\n```python\nimport random\nmod = (1 << 61) - 1\n\nN, Q = map(int, input().split())\nA = list(map(lambda x: int(x) - 1, input().split()))\nB = list(map(lambda x: int(x) - 1, input().split()))\n\nhash = [random.randint(1, mod - 1) for i in range(N)]\ncumA = [0] * (N + 1)\ncumB = [0] * (N + 1)\nfor i in range(N):\n    cumA[i + 1] = (cumA[i] + hash[A[i]]) % mod\n    cumB[i + 1] = (cumB[i] + hash[B[i]]) % mod\n\nfor i in range(Q):\n    l, r, L, R = map(int, input().split())\n    if (cumA[r] - cumA[l - 1]) % mod == (cumB[R] - cumB[L - 1]) % mod:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n[END TEXT]\n \n\n", "problem_ids": ["abc373_b", "agc068_a", "abc367_f"]}, "abc306_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), a non-negative integer \\( C \\), and an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nFind \\( \\displaystyle \\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace \\).\n\n**Constraints**\n\n- \\( 1 \\le N \\le 10^5 \\)\n- \\( 1 \\le M \\le 10^9 \\)\n- \\( 0 \\le C < M \\)\n- \\( 1 \\le K \\le 10^9 \\)\n- \\( 0 \\le A_i < M \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M C K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 5 3 3\n1 3\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nFor \\( k=0 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=3 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=1 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=2 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=2 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=2 \\).\n\nTherefore, the answer is \\( 1+1+2=4 \\). Hence, print 4.\n\n**Sample Input 2**\n\n```\n5 4 3 182\n0 3 2 1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Sample Input 3**\n\n```\n5 718 651 193855\n3 532 44 109 58\n```\n\n**Sample Output 3**\n\n```\n29484897\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 182\n\nE - Sum of Min of Mod of Linear Editorial\n\nAs a prerequisite, you need the floor_sum algorithm. This algorithm calculates \\(\\displaystyle f(n,m,a,b)=\\sum_{i=0}^{n-1}\\left\\lfloor\\frac{ai+b}m\\right\\rfloor\\) in \\(O(\\log m)\\) time.\n\nLet\u2019s assume that \\(A\\) has been sorted and duplicates removed so that \\(A_1 < A_2 < ... < A_N\\) holds. Fix \\(j\\), and let \\(S_j\\) be the set of \\(0\\le k < K\\) such that \\(\\displaystyle \\left\\{(Ck+A_j)\\ \\text{mod}\\ M\\right\\}=\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M\\right\\}\\). If \\(j\\geq 2\\), the condition for \\(k\\in S_j\\) can be rephrased as \\(\\left\\{(Ck+A_{j-1})\\ \\text{mod}\\ M \\right\\} > \\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\), and further as \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor=1\\). Since \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\) can only be \\(0\\) or \\(1\\), we have \\(\\displaystyle |S_j|=\\sum_{k=0}^{K-1}\\left(\\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\right)\\).\n\nTherefore,\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{k \\in S_j}\\left(\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\} - \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\right)\\\\\n&=\\sum_{k \\in S_j} (A_j-A_1-M)\\\\\n&=-(M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\nMeanwhile, for \\(j=1\\), we have\n\\[\n\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=0\n\\]\n\nThus, the answer is\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k\\in S_j}\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\} -\\sum_{j=2}^N(M+A_1-A_j)|S_j|\\\\\n&=\\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}-\\sum_{j=2}^N (M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\n\\(\\displaystyle \\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=\\sum_{k=0}^{K-1}\\left(Ck+A_1-M\\left\\lfloor\\frac{Ck+A_1}M \\right\\rfloor\\right)\\) and \\(|S_j|\\) can both be calculated quickly using the floor_sum algorithm.\n\nNow, the problem is solved. The complexity is \\(O(N(\\log N+\\log M))\\), with the bottlenecks being the sorting of \\(A\\) and the calculation of floor_sum. Be careful with overflow during implementation. You can avoid this issue by using multi-precision integers, 128-bit integers, or by using a modint with two different primes (e.g., \\(10^9+7\\) and \\(10^9+9\\)) and reconstructing the result using CRT. Alternatively, you can use a type like C++\u2019s unsigned long long, which guarantees that the correct value modulo \\(2^{64}\\) is returned even in case of overflow. The AtCoder Library\u2019s floor_sum uses unsigned long long and guarantees the correct answer modulo \\(2^{64}\\).\n\nSample Implementation (Python3):\n```python\nfrom atcoder.math import floor_sum\nn, m, c, k = map(int, input().split())\na = sorted(list(set(map(int, input().split()))))\nn = len(a)\nfl = [floor_sum(k, m, c, a[i]) for i in range(n)]\nans = c * k * (k - 1) // 2 + k * a[0] - m * fl[0]\nfor i in range(1, n):\n  ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\nprint(ans)\n```\n\nSample Implementation (Python3, translated from C++):\n```python\nfrom atcoder.math import floor_sum\n\ndef main():\n    n, m, c, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a = list(dict.fromkeys(a))\n    n = len(a)\n    fl = [floor_sum(k, m, c, a[i]) for i in range(n)]\n    ans = k * (k - 1) // 2 * c + k * a[0] - m * fl[0]\n    for i in range(1, n):\n        ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\n    print(ans)\n\nmain()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nA real number \\( X \\) is given to the third decimal place. Print the real number \\( X \\) under the following conditions:\n\n- The decimal part must not have trailing zeros.\n- There must not be an unnecessary trailing decimal point.\n\n**Constraints**\n\n- \\( 0 \\le X < 100 \\)\n- \\( X \\) is given to the third decimal place.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nX\n```\n\n**Output**\n\nOutput the answer.\n\n**Sample Input 1**\n```\n1.012\n```\n\n**Sample Output 1**\n```\n1.012\n```\n\nExplanation: `1.012` can be printed as it is.\n\n**Sample Input 2**\n```\n12.340\n```\n\n**Sample Output 2**\n```\n12.34\n```\n\nExplanation: Printing `12.340` without the trailing zero results in `12.34`.\n\n**Sample Input 3**\n```\n99.900\n```\n\n**Sample Output 3**\n```\n99.9\n```\n\nExplanation: Printing `99.900` without the trailing zeros results in `99.9`.\n\n**Sample Input 4**\n```\n0.000\n```\n\n**Sample Output 4**\n```\n0\n```\n\nExplanation: Printing `0.000` without trailing zeros or an unnecessary decimal point results in `0`.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 367\n\nB - Cut .0 Editorial\n\nSolution 1: In C++, receive \\(X\\) as a double and print it. This avoids trailing zeros without specifying a format. Other languages might share this feature.\n\nSample code (Python3):\n```python\nx = float(input())\nprint(x)\n```\n\nSolution 2: Treat as a string problem. Receive \\(X\\) as a string, remove trailing zeros, and then remove a trailing '.' if present. The input ensures a decimal point, so trailing zeros are in the decimal part.\n\nSample code (Python3):\n```python\nx = input()\nwhile x[-1] == '0':\n    x = x[:-1]\nif x[-1] == '.':\n    x = x[:-1]\nprint(x)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 300 points\n\nProblem Statement:\n\nIn AtCoder Land, there are \\( N \\) popcorn stands numbered from 1 to \\( N \\). They have \\( M \\) different flavors of popcorn, labeled from 1 to \\( M \\). However, not every stand sells all flavors of popcorn.\n\nTakahashi has obtained information about which flavors of popcorn are sold at each stand. This information is represented by \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\), each of length \\( M \\). If the \\( j \\)-th character of \\( S_i \\) is 'o', it means that stand \\( i \\) sells flavor \\( j \\) of popcorn. If it is 'x', it means that stand \\( i \\) does not sell flavor \\( j \\). Each stand sells at least one flavor of popcorn, and each flavor of popcorn is sold at least at one stand.\n\nTakahashi wants to try all the flavors of popcorn but does not want to move around too much. Determine the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn.\n\nConstraints:\n\n- \\( N \\) and \\( M \\) are integers.\n- \\( 1 \\leq N, M \\leq 10 \\)\n- Each \\( S_i \\) is a string of length \\( M \\) consisting of 'o' and 'x'.\n- For every \\( i \\) (1 \u2264 \\( i \\) \u2264 \\( N \\)), there is at least one 'o' in \\( S_i \\).\n- For every \\( j \\) (1 \u2264 \\( j \\) \u2264 \\( M \\)), there is at least one \\( i \\) such that the \\( j \\)-th character of \\( S_i \\) is 'o'.\n\nInput:\n\nThe input is given from Standard Input in the following format:\n```\nN M\nS_1\nS_2\n...\nS_N\n```\n\nOutput:\n\nPrint the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn.\n\nSample Input 1:\n```\n3 5\noooxx\nxooox\nxxooo\n```\n\nSample Output 1:\n```\n2\n```\n\nBy visiting the 1st and 3rd stands, you can buy all the flavors of popcorn. It is impossible to buy all the flavors from a single stand, so the answer is 2.\n\nSample Input 2:\n```\n3 2\noo\nox\nxo\n```\n\nSample Output 2:\n```\n1\n```\n\nSample Input 3:\n```\n8 6\nxxoxxo\nxxoxxx\nxoxxxx\nxxxoxx\nxxoooo\nxxxxox\nxoxxox\noxoxxo\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n```python\ndef main():\n    n, m = map(int, input().split())\n    s = [input().strip() for _ in range(n)]\n    ans = n\n    for bit in range(1 << n):\n        exist = [False] * m\n        cnt = 0\n        for i in range(n):\n            if (bit >> i) & 1:\n                cnt += 1\n                for j in range(m):\n                    if s[i][j] == 'o':\n                        exist[j] = True\n        all_exist = all(exist[j] for j in range(m))\n        if all_exist:\n            ans = min(ans, cnt)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["arc182_e", "abc367_b", "abc358_c"]}, "abc306_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) servals on a bridge of length \\( L \\). The \\( i \\)-th serval is located at position \\( A_i \\) from the left end of the bridge. Here, \\( 0 < A_1 < A_2 < \\cdots < A_N < L \\) holds. For each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nThe servals will perform the following three actions in order:\n\n1. **Action 1:** The \\( N - 1 \\) servals other than the \\( i \\)-th serval face left or right.\n2. **Action 2:** The \\( i \\)-th serval faces left or right.\n3. **Action 3:** All servals start moving simultaneously. All servals move at a constant speed of exactly 1 unit distance per unit time. When a serval reaches the end of the bridge, it leaves the bridge. If two servals collide, they both reverse their direction and continue moving.\n\nThe \\( i \\)-th serval is smart and loves this bridge, so when choosing a direction in Action 2, it will observe the directions of the other \\( N-1 \\) servals and choose the direction that allows it to stay on the bridge longer during Action 3. \n\nThere are \\( 2^{N-1} \\) possible combinations of directions for the \\( N-1 \\) servals in Action 1. Find the sum, modulo \\( 998244353 \\), over all these combinations, of the durations the \\( i \\)-th serval can stay on the bridge. It can be proved that the output value is an integer.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 10^{5} \\)\n- \\( 0 < A_1 < A_2 < \\cdots < A_N < L \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN L\nA_1 A_2 \\cdots A_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain the answer for \\( i = k \\).\n\n**Sample Input 1:**\n\n```\n2 167\n9 24\n```\n\n**Sample Output 1:**\n\n```\n182\n301\n```\n\nFor \\( i = 1 \\), it is always optimal to face right. For \\( i = 2 \\), it is optimal to face the opposite direction from the first serval.\n\n**Sample Input 2:**\n\n```\n1 924\n167\n```\n\n**Sample Output 2:**\n\n```\n757\n```\n\n**Sample Input 3:**\n\n```\n10 924924167\n46001560 235529797 272749755 301863061 359726177 470023587 667800476 696193062 741860924 809211293\n```\n\n**Sample Output 3:**\n\n```\n112048251\n409175578\n167800512\n997730745\n278651538\n581491882\n884751575\n570877705\n747965896\n80750577\n```\n\nSolution:\n\nHere is the cleaned version of the coding problem editorial:\n\n---\n\n**When and where do they leave the bridge?**  \nAfter Action 2, suppose there are \\(l\\) servals facing left: the \\(X_{1}\\)-th, \\(X_{2}\\)-th, \\(\\cdots\\), \\(X_{l}\\)-th servals from left to right. Also, suppose there are \\(r\\) servals facing right: the \\(Y_{1}\\)-th, \\(Y_{2}\\)-th, \\(\\cdots\\), \\(Y_{r}\\)-th servals from left to right.  \n- If \\(i \\leq l\\), the \\(i\\)-th serval will reach the left end, and the time it can stay on the bridge is \\(A_{X_{i}}\\).\n- If \\(l < i\\), the \\(i\\)-th serval will reach the right end, and the time it can stay on the bridge is \\(L - A_{Y_{N-i}}\\).\n\nThis holds because the relative positions of the servals do not change.\n\n**Optimal direction to face:**  \nGiven the properties, if \\((i \\leq l')\\), it is optimal for the \\(i\\)-th serval to face right to reach the left end. If \\((N+1-i \\leq r')\\), it should face left. If \\((l' = i - 1\\) and \\(r' = N - i)\\), evaluate the serval's optimal direction based on comparisons of \\(A_{i}\\) and \\(L - A_{i}\\).\n\n**Considering contributions:**  \nCalculate contributions for:\n\n1. When \\(i \\leq l'\\) and the time \\(i\\) reaches the left end to be \\(A_{j}\\).\n\n2. When \\(N+1-i \\leq r'\\) and the time \\(i\\) reaches the right end to be \\(L - A_{j}\\).\n\n3. When \\((l' = i - 1)\\) and \\((r' = N - i)\\) for the left. Calculate as a polynomial and evaluate using convolution.\n\nBy calculating all of the above and summing contributions, the final result is obtained with a complexity of \\(O(N(\\log{N})^{2})\\).\n\n**C++ Implementation:**  \nIncludes convolution and addition functions, input handling, and binomial calculations for solving the problem effectively.\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 500 points\n\n### Problem Statement\n\nHow many integers \\( x \\) between 1 and \\( N \\), inclusive, can be expressed as \\( x = a^b \\) using some positive integer \\( a \\) and a positive integer \\( b \\) not less than 2?\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 10^{18} \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\n```\n\n### Output\n\nPrint the answer as an integer.\n\n### Sample Input 1\n\n```\n99\n```\n\n### Sample Output 1\n\n```\n12\n```\n\nThe integers that satisfy the conditions in the problem statement are: 1, 4, 8, 9, 16, 25, 27, 32, 36, 49, 64, 81. There are 12 of these.\n\n### Sample Input 2\n\n```\n1000000000000000000\n```\n\n### Sample Output 2\n\n```\n1001003332\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Denso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09 Editorial - Problem F: x = a^b\n\nWe introduce a rather brute-force solution. As evident from Sample 2, a total of 1001003332 integers can satisfy the condition. Since \\((10^9)^2 = 10^{18}\\), \\(10^9\\) integers among them can be represented as \\(a^2\\). Therefore, there are only \\(10^6\\) integers that cannot be represented as \\(a^2\\). One can enumerate all of them and then add the number of those represented as \\(a^2\\). This enumeration can be done for \\(b=3,4,\\dots,59\\) and then stopped once \\(a^b > N\\) is satisfied; one can determine if an integer \\(x\\) can be represented as \\(a^2\\) by checking if \\((\\lfloor \\sqrt{x} \\rfloor )^2=x\\).\n\nSample code (Python):\n```python\nimport math\n\ndef safe_pow(a, b):\n    res = 1\n    for _ in range(b):\n        dres = res\n        dres *= a\n        if dres > 2e18:\n            return 2e18\n        res *= a\n    return res\n\ndef sqrt_floor(x):\n    l, r = 0, int(2e9)\n    while l <= r:\n        t = (l + r) // 2\n        if t * t > x:\n            r = t - 1\n        else:\n            l = t + 1\n    return r\n\ndef main():\n    n = int(input().strip())\n    st = set()\n    for b in range(3, 60):\n        a = 2\n        while True:\n            x = safe_pow(a, b)\n            if x > n:\n                break\n            s = sqrt_floor(x)\n            if s * s != x:\n                st.add(x)\n            a += 1\n    res = len(st)\n    res += sqrt_floor(n)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a string \\( S \\) consisting of lowercase English letters and periods (`.`). Your task is to find the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Constraints**\n\n- \\( S \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters and periods (`.`).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\( S \\)\n\n**Output**\n\nPrint the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Sample Input 1**\n\n```\n.v.\n```\n\n**Sample Output 1**\n\n```\nv\n```\n\nRemoving all periods (`.`) from `.v.` yields `v`, so we print `v`.\n\n**Sample Input 2**\n\n```\nchokudai\n```\n\n**Sample Output 2**\n\n```\nchokudai\n```\n\nThere are cases where \\( S \\) does not contain periods (`.`).\n\n**Sample Input 3**\n\n```\n...\n```\n\n**Sample Output 3**\n\n```\n\n```\n\nThere are also cases where all characters in \\( S \\) are periods (`.`).\n\nSolution:\n\n```python\n# Python equivalent of C++ code\n\n# Standard implementation\n\nS = input()\nT = \"\"\nfor c in S:\n    if c != '.':\n        T += c\nprint(T)\n\n# Concise implementation\n\nS = input()\nS = S.replace('.', '')\nprint(S)\n```\n \n\n", "problem_ids": ["arc178_e", "abc361_f", "abc372_a"]}, "abc307_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land is represented by a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i, j)\\) denote the cell at the \\(i\\)-th row and \\(j\\)-th column.\n\nTakahashi starts at cell \\((S_i, S_j)\\) and repeats the following action \\(K\\) times:\n- He either stays in the current cell or moves to an adjacent cell. After this action, if he is in cell \\((i, j)\\), he gains a fun value of \\(A_{i, j}\\).\n\nFind the maximum total fun value he can gain.\n\nHere, a cell \\((x', y')\\) is considered adjacent to cell \\((x, y)\\) if and only if \\(|x - x'| + |y - y'| = 1\\).\n\n**Constraints**\n\n- \\(1 \\leq H, W \\leq 50\\)\n- \\(1 \\leq K \\leq 10^9\\)\n- \\(1 \\leq S_i \\leq H\\)\n- \\(1 \\leq S_j \\leq W\\)\n- \\(1 \\leq A_{i, j} \\leq 10^9\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nH W K\nS_i S_j\nA_{1, 1} A_{1, 2} \\ldots A_{1, W}\nA_{2, 1} A_{2, 2} \\ldots A_{2, W}\n\\vdots\nA_{H, 1} A_{H, 2} \\ldots A_{H, W}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 3 3\n1 2\n2 1 2\n3 4 5\n```\n\n**Sample Output 1**\n\n```\n14\n```\n\nTakahashi can gain a total fun value of 14 by acting as follows:\n- Initially, he is at \\((1, 2)\\).\n- He moves to cell \\((2, 2)\\). Then, he gains a fun value of \\(A_{2, 2} = 4\\).\n- He moves to cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n- He stays in cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n\nHe cannot gain a total fun value greater than 14, so print 14.\n\n**Sample Input 2**\n\n```\n2 2 1000000000\n2 1\n100 100\n100 99\n```\n\n**Sample Output 2**\n\n```\n100000000000\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        In an optimal solution, one can assume that Takahashi stays at a cell with the maximum \\(A_{i,j}\\) among those he passes through. This means he can keep staying there indefinitely. Let \\((G_i, G_j)\\) be the final cell. We assume he travels from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) and then stays there zero or more times. In the travel, he never passes through the same cell twice because if he does, he can improve the score by staying more times at \\((G_i, G_j)\\). Paths from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) have a length not greater than \\(HW\\), allowing for a straightforward DP (Dynamic Programming) approach. Specifically, evaluate \\(dp_{i,j,k}\\) as the maximum total fun value after making \\(i\\) moves to end up at \\((j,k)\\). The answer is \\(\\max ((K - i) A_{j,k} + dp_{i,j,k})\\). The DP runs in \\(O((HW)^2)\\) time. Consider cases where \\(K \\leq HW\\).\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThe AtCoder amusement park has an attraction that can accommodate K people. Currently, there are N groups lined up in the queue for this attraction.\n\nThe i-th group from the front (1 \u2264 i \u2264 N) consists of A_i people. For all i (1 \u2264 i \u2264 N), it holds that A_i \u2264 K.\n\nTakahashi, as a staff member of this attraction, will guide the groups in the queue according to the following procedure:\n\n1. Initially, no one has been guided to the attraction, and there are K empty seats.\n2. If there are no groups in the queue, start the attraction and end the guidance.\n3. Compare the number of empty seats in the attraction with the number of people in the group at the front of the queue, and do one of the following:\n   - If the number of empty seats is less than the number of people in the group at the front, start the attraction. Then, the number of empty seats becomes K again.\n   - Otherwise, guide the entire group at the front of the queue to the attraction. The front group is removed from the queue, and the number of empty seats decreases by the number of people in the group.\n4. Go back to step 1.\n\nHere, no additional groups will line up after the guidance has started. Under these conditions, it can be shown that this procedure will end in a finite number of steps.\n\nDetermine how many times the attraction will be started throughout the guidance.\n\nConstraints:\n- 1 \u2264 N \u2264 100\n- 1 \u2264 K \u2264 100\n- 1 \u2264 A_i \u2264 K (1 \u2264 i \u2264 N)\n\nAll input values are integers.\n\nInput\nThe input is given from Standard Input in the following format:\n\nN K\nA_1 A_2 \u2026 A_N\n\nOutput\nPrint the answer.\n\nSample Input 1:\n```\n7 6\n2 5 1 4 1 2 3\n```\n\nSample Output 1:\n```\n4\n```\n\nInitially, the seven groups are lined up as follows. Part of Takahashi's guidance is shown in the following figure:\n\n- Initially, the group at the front has 2 people, and there are 6 empty seats. Thus, he guides the front group to the attraction, leaving 4 empty seats.\n- Next, the group at the front has 5 people, which is more than the 4 empty seats, so the attraction is started.\n- After the attraction is started, there are 6 empty seats again, so the front group is guided to the attraction, leaving 1 empty seat.\n- Next, the group at the front has 1 person, so they are guided to the attraction, leaving 0 empty seats.\n\nIn total, he starts the attraction four times before the guidance is completed. Therefore, print 4.\n\nSample Input 2:\n```\n7 10\n1 10 1 10 1 10 1\n```\n\nSample Output 2:\n```\n7\n```\n\nSample Input 3:\n```\n15 100\n73 8 55 26 97 48 37 47 35 55 5 17 62 2 60\n```\n\nSample Output 3:\n```\n8\n```\n\nSolution:\n\nHere is the cleaned-up version focused on the solution:\n\nScan the queue from the front and repeatedly update the following information to solve the problem: the number of current empty seats and how many times the attraction was started so far. Use for and if statements to update it appropriately. For each group, either \u201cjust guide the group\u201d or \u201cstart the attraction, then guide the group.\u201d\n\nSample code is as follows.\n\nPython:\n```python\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nempty_sheets = K  # Initially there are K empty seats\nstart_count = 0  # The attraction was started 0 times\n\nfor a in A:\n    if empty_sheets < a:  # If there aren't enough empty seats,\n        start_count += 1  # start the attraction,\n        empty_sheets = K  # and prepare K empty seats anew\n    empty_sheets -= a  # a people sit\n    \nstart_count += 1  # Finally, start the attraction once\nprint(start_count)\n```\n\nPython (translated from C++):\n```python\nN, K = map(int, input().split())\n\n# Initially, there are K empty seats and the attraction was started 0 times\nempty_sheets = K\nstart_count = 0\n\nfor _ in range(N):\n    a = int(input())  # Receive the input\n    if empty_sheets < a:  # If there aren't enough empty seats,\n        start_count += 1  # start the attraction,\n        empty_sheets = K  # and prepare K empty seats anew\n    empty_sheets -= a  # a people sit\n\nstart_count += 1  # Finally, start the attraction once\n\nprint(start_count)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers \\( A \\) and \\( B \\) of length \\( N \\). Process \\( Q \\) queries given in the following forms in the order they are given. Each query is of one of the following three types:\n\n1. **Type 1**: Given in the form `1 i x`. Replace \\( A_i \\) with \\( x \\).\n2. **Type 2**: Given in the form `2 i x`. Replace \\( B_i \\) with \\( x \\).\n3. **Type 3**: Given in the form `3 l r`. Solve the following problem and print the answer:\n   - Initially, set \\( v = 0 \\). For \\( i = l, l+1, \\ldots, r \\) in this order, replace \\( v \\) with either \\( v + A_i \\) or \\( v \\times B_i \\). Find the maximum possible value of \\( v \\) at the end.\n\n**It is guaranteed that the answers to the given type 3 queries are at most \\( 10^{18} \\).**\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 10^5 \\)\n- For type 1 and 2 queries, \\( 1 \\leq i \\leq N \\).\n- For type 1 and 2 queries, \\( 1 \\leq x \\leq 10^9 \\).\n- For type 3 queries, \\( 1 \\leq l \\leq r \\leq N \\).\n- For type 3 queries, the value to be printed is at most \\( 10^{18} \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nQ\nquery_1\nquery_2\n\\vdots\nquery_Q\n```\n\nHere, `query_i` is the \\( i \\)-th query, given in one of the following formats:\n- `1 i x`\n- `2 i x`\n- `3 l r`\n\n**Output**\n\nLet \\( q \\) be the number of type 3 queries. Print \\( q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th type 3 query.\n\n**Sample Input 1**\n```\n3\n3 2 4\n1 2 2\n3\n3 1 3\n1 1 1\n3 1 3\n```\n\n**Sample Output 1**\n```\n12\n7\n```\n\nFor the first query, the answer is \\(((0 + A_1) \\times B_2) \\times B_3 = 12\\).\n\nFor the third query, the answer is \\(((0 + A_1) + A_2) + A_3 = 7\\).\n\n**Sample Input 2**\n```\n6\n65 32 12 5 8 312\n4 1 3 15 16 2\n6\n3 2 6\n3 1 5\n1 5 6\n2 4 9\n3 2 6\n3 3 5\n```\n\n**Sample Output 2**\n```\n46080\n69840\n27648\n1728\n```\n\nSolution:\n\n```\nConsider a type-3 query. Let \\(M\\) be the maximum \\(A\\). First, for \\(i = l\\), set \\(v = 0\\) and replace \\(v\\) with \\(v + A[i]\\). By the constraints, \\(v\\) becomes positive. Replace \\(v\\) with \\(v \\times B[i]\\) at most \\(\\log_2 M (< 60)\\) times, since \\(2^{60} > 10^{18}\\) and the input restricts this operation to under 60 times. Thus, the loop iterates a maximum of 59 times:\n\n```python\nv = A[l]\nwhile True:\n    next_l = min(r, smallest_i_after_l_plus_1_such_that_Bi_geq_2)\n    v += sum_a(l + 1, next_l)\n    v = max(v + A[next_l], v * B[next_l])\n    l = next_l\n    if l == r:\n        break\noutput(v)\n```\n\nBy using a segment tree appropriately, the complexity becomes \\(O(N + Q \\log N \\log M)\\). The algorithm is efficient due to the small constant factor.\n```\n \n\n", "problem_ids": ["abc358_g", "abc353_b", "abc368_g"]}, "abc307_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi attempted to type a string \\( S \\) consisting of lowercase English letters using a keyboard. He typed while looking only at the keyboard, not the screen. Whenever he mistakenly typed a different lowercase English letter, he immediately pressed the backspace key. However, since the backspace key was broken, the mistakenly typed letter was not deleted, resulting in the actual string \\( T \\). He did not mistakenly press any keys other than those for lowercase English letters. The characters in \\( T \\) that were not mistakenly typed are called correctly typed characters.\n\nYour task is to determine the positions in \\( T \\) of the correctly typed characters.\n\n**Constraints:**\n\n- \\( S \\) and \\( T \\) are strings of lowercase English letters with lengths between 1 and \\( 2 \\times 10^5 \\), inclusive.\n- \\( T \\) is a string obtained by the procedure described.\n\n**Input:**\n\nThe input is given in the following format:\n\n\\( S \\)  \n\\( T \\)\n\n**Output:**\n\nLet \\(|S|\\) be the length of \\( S \\). If the correctly typed characters are the \\( A_1 \\)-th, \\( A_2 \\)-th, \\(\\ldots\\), \\( A_{|S|} \\)-th characters of \\( T \\), print the values of \\( A_1, A_2, \\ldots, A_{|S|} \\) in this order, separated by spaces. Ensure that the output is in ascending order, i.e., \\( A_i < A_{i + 1} \\) should hold for each \\( 1 \\leq i \\leq |S| - 1 \\).\n\n**Sample Input 1:**\n\n```\nabc\naxbxyc\n```\n\n**Sample Output 1:**\n\n```\n1 3 6\n```\n\n**Sample Input 2:**\n\n```\naaaa\nbbbbaaaa\n```\n\n**Sample Output 2:**\n\n```\n5 6 7 8\n```\n\n**Sample Input 3:**\n\n```\natcoder\natcoder\n```\n\n**Sample Output 3:**\n\n```\n1 2 3 4 5 6 7\n```\nIn Sample 1, the sequence of Takahashi's typing is as follows:\n\n1. Type `a`.\n2. Try to type `b` but mistakenly type `x`.\n3. Press the backspace key, but the character is not deleted.\n4. Type `b`.\n5. Try to type `c` but mistakenly type `x`.\n6. Press the backspace key, but the character is not deleted.\n7. Try to type `c` but mistakenly type `y`.\n8. Press the backspace key, but the character is not deleted.\n9. Type `c`.\n\nThe correctly typed characters are the first, third, and sixth characters.\n\nSolution:\n\n        [BEGIN TEXT]\n        Maintain a variable to manage how many first characters of \\(S\\) have been typed while scanning the characters of \\(T\\).\n\n```python\nn, m = 0, 0\ns, t = input(), input()\nn = len(s)\nm = len(t)\na = [0] * n\nj = 0\nfor i in range(m):\n    if s[j] == t[i]:\n        a[j] = i + 1\n        j += 1\nfor i in range(n):\n    print(a[i], end=\" \\n\" if i == n - 1 else \" \")\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\(N\\) linear functions \\(f_1, f_2, \\ldots, f_N\\), where \\(f_i(x) = A_i x + B_i\\). Your task is to find the maximum possible value of \n\\[ \nf_{p_1}(f_{p_2}(\\ldots f_{p_K}(1) \\ldots )) \n\\]\nfor a sequence \\(p = (p_1, p_2, \\ldots, p_K)\\) composed of \\(K\\) distinct integers between \\(1\\) and \\(N\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq K \\leq \\text{min}(N,10)\\)\n- \\(1 \\leq A_i, B_i \\leq 50\\) for all \\(1 \\leq i \\leq N\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2\n2 3\n1 5\n4 2\n```\n\n**Sample Output 1**\n```\n26\n```\n\n**Explanation for Sample Input 1**\n\nHere are all possible \\(p\\) and the corresponding values of \\(f_{p_1}(f_{p_2}(1))\\):\n- \\(p= (1,2)\\): \\(f_1(f_2(1))=15\\)\n- \\(p= (1,3)\\): \\(f_1(f_3(1))=15\\)\n- \\(p= (2,1)\\): \\(f_2(f_1(1))=10\\)\n- \\(p= (2,3)\\): \\(f_2(f_3(1))=11\\)\n- \\(p= (3,1)\\): \\(f_3(f_1(1))=22\\)\n- \\(p= (3,2)\\): \\(f_3(f_2(1))=26\\)\n\nTherefore, the maximum value is \\(26\\), and you should print \\(26\\).\n\n**Sample Input 2**\n```\n10 3\n48 40\n34 22\n24 37\n45 40\n48 31\n49 44\n45 40\n44 6\n35 22\n39 28\n```\n\n**Sample Output 2**\n```\n216223\n```\n\nSolution:\n\n```python\nn, k = map(int, input().split())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nord_indices = list(range(n))\nord_indices.sort(key=lambda i: b[i] * (a[i] - 1), reverse=True)\n\ndp = [int(-1e9)] * (k + 1)\ndp[0] = 1\n\nfor i in ord_indices:\n    ndp = dp[:]\n    for j in range(k):\n        if dp[j] > int(-1e9):\n            ndp[j + 1] = max(ndp[j + 1], dp[j] * a[i] + b[i])\n    dp = ndp\n\nprint(dp[k])\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAt the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes \\( A \\) seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.\n\nCurrently, there is no one in line at the ticket booth, and \\( N \\) people will come to buy tickets one after another. Specifically, the \\( i \\)-th person will arrive at the ticket booth \\( T_i \\) seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately. Here, \\( T_1 < T_2 < \\dots < T_N \\).\n\nFor each \\( i\\ (1 \\leq i \\leq N) \\), determine how many seconds from now the \\( i \\)-th person will finish purchasing their ticket.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 0 \\leq T_1 < T_2 < \\dots < T_N \\leq 10^6 \\)\n- \\( 1 \\leq A \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\nT_1 T_2 \\dots T_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the number of seconds from now that the \\( i \\)-th person will finish purchasing their ticket.\n\n**Sample Input 1:**\n\n```\n3 4\n0 2 10\n```\n\n**Sample Output 1:**\n\n```\n4\n8\n14\n```\n\nThe events proceed in the following order:\n\n- At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.\n- At 8 seconds: The 2nd person finishes purchasing their ticket.\n- At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 14 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 2:**\n\n```\n3 3\n1 4 7\n```\n\n**Sample Output 2:**\n\n```\n4\n7\n10\n```\n\nThe events proceed in the following order:\n\n- At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.\n- At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 10 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 3:**\n\n```\n10 50000\n120190 165111 196897 456895 540000 552614 561627 743796 757613 991216\n```\n\n**Sample Output 3:**\n\n```\n170190\n220190\n270190\n506895\n590000\n640000\n690000\n793796\n843796\n1041216\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nB - Ticket Counter Editorial by en_translator\n\nSuppose that the \\(i\\)-th person finishes buying a ticket at time \\(x_i\\). For convenience, let \\(x_0=0\\).\nFor each \\(i\\) (1 \\(\\leq i\\leq N\\)), we determine how to represent the value \\(x_i\\) using \\(x_{i-1}\\).\n\nIf \\(x_{i-1} \\leq T_i\\): there is no queue when the \\(i\\)-th person visits the ticket booth, so they can start purchasing instantly. Thus, \\(x_i=T_i+A\\).\nIf \\(x_{i-1} > T_i\\): someone is still purchasing a ticket when the \\(i\\)-th person visits the booth, so they start the process right after the \\((i-1)\\)-th person finishes. Thus, \\(x_i=x_{i-1}+A\\).\n\nTo summarize, \\(x_i=\\max(x_{i-1},T_i)+A\\). Use this to find \\(x_i\\) for each \\(i=1,2,\\dots,N\\).\n\nSample code (Python):\n```python\nn, a = map(int, input().split())\nt = list(map(int, input().split()))\npre = 0\nfor i in range(n):\n    ans = max(pre, t[i]) + a\n    print(ans)\n    pre = ans\n```\n \n\n", "problem_ids": ["abc352_b", "abc366_f", "abc358_b"]}, "abc307_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThis problem is interactive, and the judge is adaptive. See the notes for details. Also, the parameters in the problem statement are fixed at \\( N = 1000 \\), \\( M = 10 \\), \\( Q = 950 \\).\n\nThere are \\( N \\) coins numbered \\( 1, 2, \\dots, N \\). Exactly \\( M \\) of these coins are counterfeit. An appraiser can, in one appraisal, determine whether two coins are of the same type or different types. Specifically:\n- If the two coins are both genuine or both counterfeit, they are judged to be of the same type.\n- Otherwise, they are judged to be of different types.\n\nIdentify all the counterfeit coins using at most \\( Q \\) appraisals.\n\n**Constraints**\n- \\( N = 1000 \\)\n- \\( M = 10 \\)\n- \\( Q = 950 \\)\n\n**Interaction**\n\nThis is an interactive problem. Initially, receive \\( N \\), \\( M \\), and \\( Q \\) from Standard Input:\n\n```\nN M Q\n```\n\nNext, you can perform appraisals between 0 and \\( Q \\) times, inclusive, as follows.\n\nFirst, by outputting to Standard Output in the following format, you indicate that you are appraising coins \\( x \\) and \\( y \\). (Include a newline at the end.)\n\n```\n? x y\n```\n\nHere, \\( x \\) and \\( y \\) must be distinct integers between 1 and \\( N \\), inclusive.\n\nIn response, the judge system will reply with one of the following three responses.\n\n- `0`: If the response is `0`, it means that coins \\( x \\) and \\( y \\) are of the same type.\n- `1`: If the response is `1`, it means that coins \\( x \\) and \\( y \\) are of different types.\n- `-1`: If the response is `-1`, it means that the appraisal is invalid. Specifically, this response is given when at least one of the following conditions is met:\n  - The outputted \\( x \\) and \\( y \\) do not satisfy the constraints.\n  - The number of appraisals exceeds \\( Q \\).\n\nIf you receive this response, your program is considered incorrect. Terminate your program immediately.\n\nFinally, by outputting to Standard Output in the following format, you answer that coins \\( A_1, A_2, \\ldots, A_M \\) are counterfeit. (Include a newline at the end.)\n\n```\n! A_1 A_2 \\dots A_M\n```\n\nHere, \\( A_i \\) must be distinct integers between 1 and \\( N \\), inclusive. After this output, terminate your program immediately.\n\nIf any of your outputs do not meet the specified format, your program will be considered incorrect. The judge will then respond with `-1`, so in that case, terminate your program immediately.\n\n**Notes**\n- Every time you output, include a newline at the end and flush Standard Output. Failure to do so may result in a verdict of Time Limit Exceeded (TLE) or Wrong Answer (WA).\n- After outputting your answer (or receiving `-1`), terminate your program immediately. Otherwise, the verdict is indeterminate.\n- Beware that unnecessary newlines are considered malformed.\n- The judge for this problem is adaptive. That is, at any point, as long as consistency can be maintained, the judge may change which coins are counterfeit. See the sample interaction for details.\n\n**Sample Interaction**\n\nIn this interaction, \\( N = 5 \\), \\( M = 2 \\), \\( Q = 10 \\), and the judge initially considers coins 1 and 2 to be counterfeit.\n\n*Note*: This example does not meet the constraints and is not included in the judge.\n\n**Input**\n```\n5 2 10\n```\n**Output**\n```\n? 1 2\n```\n**Explanation**: You appraise coins 1 and 2.\n\n**Input**\n```\n0\n```\n**Explanation**: Coins 1 and 2 are judged to be of the same type.\n\n**Output**\n```\n? 1 3\n```\n**Explanation**: You appraise coins 1 and 3.\n\n**Input**\n```\n1\n```\n**Explanation**: Coins 1 and 3 are judged to be of different types.\n\n**Output**\n```\n? 1 4\n```\n**Explanation**: You appraise coins 1 and 4.\n\n**Input**\n```\n1\n```\n**Explanation**: Coins 1 and 4 are judged to be of different types.\n\n**Output**\n```\n! 1 2\n```\n**Explanation**: You answer that coins 1 and 2 are counterfeit.\n\nIndeed, coins 1 and 2 are considered counterfeit, but it is also possible to consider coins 3 and 4 as counterfeit while maintaining consistency. Therefore, the judge may change the counterfeit coins to 3 and 4. As a result, the judge may judge this answer as incorrect.\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 184\n\nA - Appraiser Editorial by evima\n\nThe key point of this problem is that there are more genuine coins than counterfeit coins. Since there are \\(10\\) counterfeit coins, any group of \\(11\\) or more coins of the same type must be genuine.\n\nConsider dividing the \\(1000\\) coins into groups of \\(11\\). There will be \\(90\\) groups of \\(11\\) coins and a remainder of \\(10\\) coins. Among these \\(90\\) groups, at most \\(10\\) groups may contain counterfeit coins, so we can obtain at least \\(80\\) groups of \\(11\\) coins that are all of the same type. Also, we need \\(10\\) inspections to divide a group of \\(11\\) coins into two types (without knowing which is genuine).\n\nFirst, use \\(900\\) inspections to divide all the \\(11\\)-coin groups into two types. Next, exclude the coins that have been identified as genuine (where all \\(11\\) coins are of the same type). Record one coin number \\(x\\) identified as genuine. We have up to \\(20\\) groups of coins whose type is undetermined, and the \\(10\\) leftover coins. Using up to an additional \\(30\\) inspections, determine whether each remaining coin is of the same type as \\(x\\) to identify all counterfeit coins. This solution can identify all counterfeit coins using a maximum of \\(930\\) inspections.\n\nSample Implementation (Python 3):\n```python\ndef ask(x, y):\n    print(f\"? {x} {y}\")\n    # Assume here that we get a response from the interaction\n    res = int(input().strip())\n    return res\n\ndef ans(a):\n    print(\"!\", \" \".join(map(str, a)))\n\ndef main():\n    n, m, q = map(int, input().split())  # dummy input\n    ok = None\n    unknown = []\n    for i in range(90):\n        up = i * 11 + 1\n        g1 = [up]\n        g2 = []\n        for j in range(i * 11 + 2, i * 11 + 12):\n            if ask(up, j) == 0:\n                g1.append(j)\n            else:\n                g2.append(j)\n        if not g2:\n            ok = up\n        else:\n            unknown.append(g1)\n            unknown.append(g2)\n    for i in range(991, 1001):\n        unknown.append([i])\n    res = []\n    for nx in unknown:\n        if ask(nx[0], ok) == 1:\n            res.extend(nx)\n    ans(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nN people work at the AtCoder office. The office keeps records of entries and exits, and there have been M such entries and exits since the records began. \n\nEach record is represented by a pair of integers (T_i, P_i), indicating that at time T_i, the P_i-th person either entered the office if they were outside, or exited the office if they were inside. It is known that all people were outside the office at the beginning of the records, and they are outside now.\n\nYou need to answer Q queries in the following format:\n\nFor the i-th query, you are given a pair of integers (A_i, B_i). Find the total length of the periods during which both the A_i-th and B_i-th persons were inside the office since the records began.\n\n**Constraints:**\n- 2 \u2264 N \u2264 2 \u00d7 10^5\n- 2 \u2264 M \u2264 2 \u00d7 10^5\n- 1 \u2264 T_1 < T_2 < ... < T_M \u2264 10^9\n- 1 \u2264 P_i \u2264 N (1 \u2264 i \u2264 M)\n- For every 1 \u2264 p \u2264 N, the number of indices i such that P_i = p is even.\n- 1 \u2264 Q \u2264 2 \u00d7 10^5\n- 1 \u2264 A_i < B_i \u2264 N (1 \u2264 i \u2264 Q)\n- All inputs are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN M\nT_1 P_1\nT_2 P_2\n...\nT_M P_M\nQ\nA_1 B_1\nA_2 B_2\n...\nA_Q B_Q\n```\n\n**Output:**\nPrint Q lines. The i-th line should contain the answer to the i-th query.\n\n**Sample Input 1:**\n```\n3 8\n10 1\n20 2\n30 1\n40 3\n60 3\n70 1\n80 2\n90 1\n3\n1 2\n1 3\n2 3\n```\n\n**Sample Output 1:**\n```\n20\n0\n20\n```\n\nThe following diagram shows the time each of the three people spent inside the office. The answers to each query are as follows:\n- The 1st and 2nd persons were both inside the office from time 20 to 30 and from time 70 to 80. The lengths of these two periods are both 10, so print the total, which is 20.\n- The 1st and 3rd persons were never inside the office at the same time, so print 0.\n- The 2nd and 3rd persons were both inside the office from time 40 to 60. The length of this period is 20, so print 20.\n\n**Sample Input 2:**\n```\n10 20\n10257 9\n10490 4\n19335 1\n25893 5\n32538 9\n33433 3\n38522 9\n40629 9\n42896 5\n52106 1\n53024 3\n55610 5\n56721 9\n58286 9\n63128 3\n70513 3\n70977 4\n74936 5\n79883 9\n95116 9\n7\n1 3\n3 9\n1 9\n4 9\n1 5\n5 9\n3 5\n```\n\n**Sample Output 2:**\n```\n18673\n2107\n15310\n25720\n17003\n10317\n16848\n```\n\nSolution:\n\n```python\n# Editorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\n# Official Solution: G - AtCoder Office Editorial by en_translator\n\n# To solve the problem, we need to determine intervals where each person was in the office and apply different algorithms based on the size of these intervals \\(S _ i\\). A threshold \\(C\\) is set to choose the appropriate algorithm.\n\n# 1. **Small Sets:** If both \\(S _ A\\) and \\(S _ B\\) have sizes less than \\(C\\), process the intervals in ascending order of their left ends. This approach finds answers in \\(O(C)\\) time.\n\n# 2. **Large Sets:** If at least one of \\(S _ A\\) or \\(S _ B\\) is large (i.e., size \\(\\geq C\\)), precompute answers for these indices. This precomputation requires \\(O\\left(\\dfrac{MN}C\\right)\\) time with \\(O\\left(\\dfrac{N^2}C\\right)\\) memory and allows queries to be answered in \\(O(1)\\) time.\n\n# The overall time complexity is \\(O\\left(QC+\\dfrac{MN}C\\right)\\), and choosing \\(C=O\\left(\\sqrt{\\dfrac{MN}Q}\\right)\\) optimizes the complexity to \\(O(\\sqrt{QMN})\\).\n\n# Sample Code:\nfrom collections import defaultdict\nfrom itertools import accumulate\n\ndef main():\n    N, M = map(int, input().split())\n    records = [tuple(map(int, input().split())) for _ in range(M)]\n    records = [(T, P - 1) for T, P in records]\n    \n    inside_office = [[] for _ in range(N)]\n    in_ = [0] * N\n    for T, P in records:\n        if in_[P]:\n            inside_office[P].append((in_[P], T))\n            in_[P] = 0\n        else:\n            in_[P] = T\n    \n    large_limit = 1000\n    memo = defaultdict(int)\n    \n    for i, Si in enumerate(inside_office):\n        if len(Si) > large_limit:\n            sum_ = [0] * N\n            prev_i = 0\n            i_sum = 0\n            i_inside = False\n            for T, P in records:\n                if P == i:\n                    i_sum += i_inside * (T - prev_i)\n                    prev_i = T\n                    i_inside = not i_inside\n                sum_[P] = i_sum + i_inside * (T - prev_i) - sum_[P]\n            for j in range(N):\n                memo[min(i, j), max(i, j)] = sum_[j]\n    \n    def query(a, b):\n        if (a, b) in memo:\n            return memo[(a, b)]\n        Sa = inside_office[a]\n        Sb = inside_office[b]\n        if not Sa or not Sb:\n            memo[(a, b)] = 0\n            return 0\n        ans = 0\n        i = 0\n        for l, r in Sa:\n            while i < len(Sb) and Sb[i][1] <= l:\n                i += 1\n            if i < len(Sb):\n                aux = max(0, min(Sb[i][1], r) - max(Sb[i][0], l))\n                ans += aux if Sb[i][0] < r else 0\n            while i + 1 < len(Sb) and Sb[i + 1][0] <= r:\n                i += 1\n                ans += max(0, min(Sb[i][1], r) - Sb[i][0])\n        memo[(a, b)] = ans\n        return ans\n    \n    Q = int(input())\n    for _ in range(Q):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        print(query(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). Takahashi will perform the following operation exactly once:\n\n- Choose an integer \\( x \\) between 1 and \\( N \\), inclusive, and an arbitrary integer \\( y \\). Replace \\( A_x \\) with \\( y \\).\n\nFind the maximum possible length of a longest increasing subsequence (LIS) of \\( A \\) after performing the operation.\n\n**What is the longest increasing subsequence?**\n\nA subsequence of a sequence \\( A \\) is a sequence that can be derived from \\( A \\) by extracting some elements without changing the order.\n\nA longest increasing subsequence of a sequence \\( A \\) is a longest subsequence of \\( A \\) that is strictly increasing.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n\n```\n4\n3 2 2 4\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n*Explanation:*\n\nThe length of a LIS of the given sequence \\( A \\) is 2. For example, if you replace \\( A_1 \\) with 1, the length of a LIS of \\( A \\) becomes 3, which is the maximum.\n\n**Sample Input 2:**\n\n```\n5\n4 5 3 6 7\n```\n\n**Sample Output 2:**\n\n```\n4\n```\n\nSolution:\n\n```python\nimport sys\n\nclass RangeMaxSegmentTree:\n    def __init__(self, size, initial_value):\n        self.size = size\n        self.data = [initial_value] * (2 * size)\n        self.initial_value = initial_value\n\n    def update(self, index, value):\n        index += self.size\n        self.data[index] = value\n        while index > 1:\n            index //= 2\n            self.data[index] = max(self.data[2 * index], self.data[2 * index + 1])\n\n    def calc_max(self, left, right):\n        left += self.size\n        right += self.size\n        max_value = self.initial_value\n        while left < right:\n            if left % 2 == 1:\n                max_value = max(max_value, self.data[left])\n                left += 1\n            if right % 2 == 1:\n                right -= 1\n                max_value = max(max_value, self.data[right])\n            left //= 2\n            right //= 2\n        return max_value\n\ndef longest_increasing_subsequence(A):\n    N = len(A)\n    dp = [[-float('inf')] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, N + 1):\n        max_value = 0\n        for j in range(0, A[i-1]):\n            max_value = max(max_value, dp[i - 1][j])\n        dp[i][A[i-1]] = max_value + 1\n\n    max_lis_length = max(dp[N])\n    return max_lis_length\n\ndef longest_increasing_subsequence_with_segment_tree(A):\n    N = len(A)\n    dp = RangeMaxSegmentTree(N + 1, -float('inf'))\n    dp.update(0, 0)\n\n    for i in range(1, N + 1):\n        max_for_ai = dp.calc_max(0, A[i-1])\n        dp.update(A[i-1], max_for_ai + 1)\n\n    max_lis_length = max(dp.data[N + 1:])\n    return max_lis_length\n\n# Example array A for testing purposes\nA = [3, 10, 2, 1, 20]\nprint(\"LIS length using DP:\", longest_increasing_subsequence(A))\nprint(\"LIS length using segment tree:\", longest_increasing_subsequence_with_segment_tree(A))\n```\n\n \n\n", "problem_ids": ["arc184_a", "abc365_g", "abc360_g"]}, "abc307_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 350 points\n\nProblem Statement:\n\nThe coordinate plane is covered with 2\u00d71 tiles. The tiles are laid out according to the following rules:\n\n- For an integer pair (i, j), the square \\(A_{i,j} = \\{(x, y) \\mid i \\leq x \\leq i+1 \\wedge j \\leq y \\leq j+1\\}\\) is contained in one tile.\n- When i + j is even, \\(A_{i,j}\\) and \\(A_{i+1,j}\\) are contained in the same tile.\n\nTiles include their boundaries, and no two different tiles share a positive area.\n\nNear the origin, the tiles are laid out as follows:\n\n![Tile Layout Image](https://img.atcoder.jp/abc359/7ab121cd550fa78b43845d4ffd7f74b3.png)\n\nTakahashi starts at the point (S_x + 0.5, S_y + 0.5) on the coordinate plane. He can repeat the following move as many times as he likes:\n\n- Choose a direction (up, down, left, or right) and a positive integer n. Move n units in that direction.\n\nEach time he enters a tile, he pays a toll of 1.\n\nFind the minimum toll he must pay to reach the point (T_x + 0.5, T_y + 0.5).\n\nConstraints:\n- 0 \u2264 S_x \u2264 2 \u00d7 10^16\n- 0 \u2264 S_y \u2264 2 \u00d7 10^16\n- 0 \u2264 T_x \u2264 2 \u00d7 10^16\n- 0 \u2264 T_y \u2264 2 \u00d7 10^16\n- All input values are integers.\n\nInput:\n\nThe input is given from Standard Input in the following format:\n```\nS_x S_y\nT_x T_y\n```\n\nOutput:\n\nPrint the minimum toll Takahashi must pay.\n\nSample Input 1:\n```\n5 0\n2 5\n```\n\nSample Output 1:\n```\n5\n```\n\nFor example, Takahashi can pay a toll of 5 by moving as follows:\n\n![Movement Image](https://img.atcoder.jp/abc359/187d19c48a9a0fcedb2602063689ee77.png)\n\n- Move left by 1. Pay a toll of 0.\n- Move up by 1. Pay a toll of 1.\n- Move left by 1. Pay a toll of 0.\n- Move up by 3. Pay a toll of 3.\n- Move left by 1. Pay a toll of 0.\n- Move up by 1. Pay a toll of 1.\n\nIt is impossible to reduce the toll to 4 or less, so print 5.\n\nSample Input 2:\n```\n3 1\n4 1\n```\n\nSample Output 2:\n```\n0\n```\n\nThere are cases where no toll needs to be paid.\n\nSample Input 3:\n```\n2552608206527595 5411232866732612\n771856005518028 7206210729152763\n```\n\nSample Output 3:\n```\n1794977862420151\n```\n\nNote that the value to be output may exceed the range of a 32-bit integer.\n\nSolution:\n\n```\nHere is the cleaned-up version of the editorial:\n\n---\n\nFor simplicity, we may assume that the start and goal are in the left half of a tile. If \\(S_x + S_y\\) is odd, subtract \\(1\\) from \\(S_x\\). One can travel freely between the left and right halves, so traveling from the left half of one tile to another is a complete move. By paying a toll of \\(1\\), one can make either of these two moves:\n\n1. Move by \\(1\\) vertically and by \\(1\\) horizontally.\n2. Move by \\(2\\) horizontally.\n\nSuppose one could travel from \\((S_x, S_y)\\) to \\((T_x, T_y)\\) by making the first move \\(a\\) times and the second \\(b\\) times. The following conditions must hold:\n\n\\(\\lvert S_y - T_y \\rvert \\leq a\\)\n\n\\(\\lvert S_x - T_x \\rvert \\leq a + 2b\\)\n\n\\(a > 0\\) or \\(S_x - T_x \\equiv 2b \\pmod{4}\\)\n\nConversely, if a pair of non-negative integers \\((a, b)\\) satisfies these conditions, then one can make the specified moves to travel from \\((S_x, S_y)\\) to \\((T_x, T_y)\\).\n\nWe aim to minimize the toll \\(a + b\\) while respecting \\((0 \\leq a, 0 \\leq b)\\) and the above conditions. With \\(0 \\leq b\\) and \\(\\lvert S_y - T_y \\rvert \\leq a\\), it is necessary that \\(\\lvert S_y - T_y \\rvert \\leq a + b\\). \n\nAdditionally, \\(\\frac{\\lvert S_x - T_x \\rvert + \\lvert S_y - T_y \\rvert}{2} \\leq a + b\\).\n\nConversely, \\((a, b) = \\left( \\lvert S_y - T_y \\rvert, \\max\\left\\lbrace 0, \\frac{\\lvert S_x - T_x \\rvert - \\lvert S_y - T_y \\rvert}{2} \\right\\rbrace \\right)\\) always satisfies all the conditions, thus ensuring one or both equations hold as an equality.\n\nHence, the minimum toll is:\n\n\\[\\max\\left\\lbrace \\lvert S_y - T_y \\rvert, \\frac{\\lvert S_x - T_x \\rvert + \\lvert S_y - T_y \\rvert}{2} \\right\\rbrace = \\frac{\\lvert S_y - T_y \\rvert + \\max \\lbrace \\lvert S_x - T_x \\rvert, \\lvert S_y - T_y \\rvert \\rbrace}{2}\\].\n\nBelow is the sample code:\n\n```python\nSx, Sy = map(int, input().split())\nTx, Ty = map(int, input().split())\n\nif (Sx + Sy) % 2 == 1:\n    Sx -= 1\nif (Tx + Ty) % 2 == 1:\n    Tx -= 1\n\nDx = abs(Sx - Tx)\nDy = abs(Sy - Ty)\n\nprint((Dy + max(Dx, Dy)) // 2)\n```\n\n---\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi eats three plates for breakfast: rice, miso soup, and salad. His table is long and narrow, so he arranged the three plates in a row. The arrangement is given by a string \\( S \\), where the \\( i \\)-th plate from the left is rice if \\( S_i \\) is \\( R \\), miso soup if \\( S_i \\) is \\( M \\), and salad if \\( S_i \\) is \\( S \\).\n\nDetermine whether the plate of rice is to the left of the plate of miso soup.\n\n**Constraints**\n\n- \\(|S| = 3\\)\n- \\( S \\) contains one \\( R \\), one \\( M \\), and one \\( S \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n**Output**\n\nPrint `Yes` if the plate of rice is to the left of the plate of miso soup, and `No` otherwise.\n\n**Sample Input 1**\n\n```\nRSM\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nThe plate of rice is at the 1st position from the left, and the plate of miso soup is at the 3rd position from the left. Since the plate of rice is to the left, print `Yes`.\n\n**Sample Input 2**\n\n```\nSMR\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nThe plates are arranged as salad, miso soup, and rice from left to right.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 360\n\nA - A Healthy Breakfast Editorial by en_translator\n\nFor beginners: If you are new to learning programming, please try \"Welcome to AtCoder\" from the practice contest. There you can find a sample code for each language. If you are not familiar with programming contests, try some problems in \"AtCoder Beginners Selection.\" \"C++\u5165\u9580 AtCoder Programming Guide for beginners (APG4b)\" is a C++ tutorial for competitive programmers (in Japanese).\n\nSolution: Prepare a string variable s. Read input into s. Use a for loop to determine positions of R and M in s. Let pos_r and pos_m be those indices. Use an if statement to print 'Yes' if pos_r < pos_m, otherwise print 'No'. With only six possible strings for \\(S\\), you can manually determine the answer using a conditional branch. Sample code in C++ provided.\n```\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) sequences of length \\( M \\), where each element is either 0 or 1. The \\( i \\)-th sequence is \\( A_i = (A_{i, 1}, A_{i, 2}, \\dots, A_{i, M}) \\).\n\nFor integers \\( i, j \\) \\((1 \\leq i, j \\leq N)\\), define \\( f(i, j) \\) as follows: \\( f(i, j) \\) is the smallest non-negative integer \\( x \\) such that \\( A_i \\) and \\( A_j \\) become identical after performing the following operation \\( x \\) times, or \\( 0 \\) if such \\( x \\) does not exist.\n\nOperation: For all integers \\( k \\) \\((1 \\leq k \\leq M)\\) simultaneously, replace \\( A_{i, k} \\) with \\( \\left (\\sum_{l=1}^{k} A_{i, l} \\right ) \\bmod 2 \\).\n\nFind \\( \\sum_{i=1}^{N} \\sum_{j=i}^{N} f(i, j) \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\times M \\leq 10^6 \\)\n- \\( A_{i, j} \\in \\{0, 1\\} \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1, 1} A_{1, 2} \\cdots A_{1, M}\nA_{2, 1} A_{2, 2} \\cdots A_{2, M}\n\\vdots\nA_{N, 1} A_{N, 2} \\cdots A_{N, M}\n```\n\n**Output**\n\nPrint the answer in one line.\n\n**Sample Input 1**\n\n```\n4 3\n1 0 0\n1 1 0\n1 0 1\n0 1 1\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\nExplanation: \\( f(1, 1) = 0 \\), \\( f(1, 2) = 3 \\), \\( f(1, 3) = 2 \\), \\( f(1, 4) = 0 \\), \\( f(2, 2) = 0 \\), \\( f(2, 3) = 3 \\), \\( f(2, 4) = 0 \\), \\( f(3, 3) = 0 \\), \\( f(3, 4) = 0 \\), \\( f(4, 4) = 0 \\), summing to 8.\n\n**Sample Input 2**\n\n```\n7 6\n1 0 0 0 0 0\n1 1 1 0 0 0\n1 0 1 1 0 0\n1 0 0 0 1 1\n1 0 0 0 0 1\n1 0 0 0 0 0\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n\n```\n6\n```\n\nSolution:\n\n```plaintext\nEditorial - E - Accumulating Many Times\n\nFirst, treat sequences that differ in the position of their first \\(1\\) as separate problems, since operations do not change this position. Assume \\(A_{i, 1} = 1\\). Define the inverse operation for the problem's operation. The graph formed by length-\\(M\\) binary sequences starting with \\(1\\) has operations as edges and is a collection of cycles. \n\nEvery sequence can be transformed into a \u201cstandard form\u201d where all elements at positions \\((2^x + 1)\\) using non-negative integer \\(x\\) are \\(0\\). This is proven using Lucas\u2019s theorem. Cycle length is \\(2^m\\), where \\(m\\) is the smallest non-negative integer such that \\(2^m + 1 \\leq M\\).\n\nTo solve, first transform sequences to their standard forms and calculate the required operations. For each \\(i = 1, 2, \\dots, N\\), compute the standard form of sequence \\(A_i\\) and the cost to reach it. Transform \\(A_{i, 2^x + 1}\\) into \\(0\\) by performing the operation \\(2^x\\) times if \\(A_{i, 2^x + 1} = 1\\).\n\nNext, solve for each standard form: for integer sequence \\(B\\), compute \\(\\displaystyle \\sum_{i=1}^{m} \\sum_{j=i}^{m} \\left( (B_j - B_i) \\bmod 2^m \\right)\\) using Segment Tree or similar structures.\n\nThe computational bottleneck is computing the standard forms. Multiple operations using FFT help, but we may exceed the time limit if performed every time. Instead, keep track of operations count to determine value at a position in \\(O(M)\\) time. Overall complexity is \\(O(NM \\log NM)\\).\n```\n \n\n", "problem_ids": ["abc359_c", "abc360_a", "arc184_e"]}, "abc307_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), a non-negative integer \\( C \\), and an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nFind \\( \\displaystyle \\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace \\).\n\n**Constraints**\n\n- \\( 1 \\le N \\le 10^5 \\)\n- \\( 1 \\le M \\le 10^9 \\)\n- \\( 0 \\le C < M \\)\n- \\( 1 \\le K \\le 10^9 \\)\n- \\( 0 \\le A_i < M \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M C K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 5 3 3\n1 3\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nFor \\( k=0 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=3 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=1 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=2 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=2 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=2 \\).\n\nTherefore, the answer is \\( 1+1+2=4 \\). Hence, print 4.\n\n**Sample Input 2**\n\n```\n5 4 3 182\n0 3 2 1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Sample Input 3**\n\n```\n5 718 651 193855\n3 532 44 109 58\n```\n\n**Sample Output 3**\n\n```\n29484897\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 182\n\nE - Sum of Min of Mod of Linear Editorial\n\nAs a prerequisite, you need the floor_sum algorithm. This algorithm calculates \\(\\displaystyle f(n,m,a,b)=\\sum_{i=0}^{n-1}\\left\\lfloor\\frac{ai+b}m\\right\\rfloor\\) in \\(O(\\log m)\\) time.\n\nLet\u2019s assume that \\(A\\) has been sorted and duplicates removed so that \\(A_1 < A_2 < ... < A_N\\) holds. Fix \\(j\\), and let \\(S_j\\) be the set of \\(0\\le k < K\\) such that \\(\\displaystyle \\left\\{(Ck+A_j)\\ \\text{mod}\\ M\\right\\}=\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M\\right\\}\\). If \\(j\\geq 2\\), the condition for \\(k\\in S_j\\) can be rephrased as \\(\\left\\{(Ck+A_{j-1})\\ \\text{mod}\\ M \\right\\} > \\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\), and further as \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor=1\\). Since \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\) can only be \\(0\\) or \\(1\\), we have \\(\\displaystyle |S_j|=\\sum_{k=0}^{K-1}\\left(\\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\right)\\).\n\nTherefore,\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{k \\in S_j}\\left(\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\} - \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\right)\\\\\n&=\\sum_{k \\in S_j} (A_j-A_1-M)\\\\\n&=-(M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\nMeanwhile, for \\(j=1\\), we have\n\\[\n\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=0\n\\]\n\nThus, the answer is\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k\\in S_j}\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\} -\\sum_{j=2}^N(M+A_1-A_j)|S_j|\\\\\n&=\\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}-\\sum_{j=2}^N (M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\n\\(\\displaystyle \\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=\\sum_{k=0}^{K-1}\\left(Ck+A_1-M\\left\\lfloor\\frac{Ck+A_1}M \\right\\rfloor\\right)\\) and \\(|S_j|\\) can both be calculated quickly using the floor_sum algorithm.\n\nNow, the problem is solved. The complexity is \\(O(N(\\log N+\\log M))\\), with the bottlenecks being the sorting of \\(A\\) and the calculation of floor_sum. Be careful with overflow during implementation. You can avoid this issue by using multi-precision integers, 128-bit integers, or by using a modint with two different primes (e.g., \\(10^9+7\\) and \\(10^9+9\\)) and reconstructing the result using CRT. Alternatively, you can use a type like C++\u2019s unsigned long long, which guarantees that the correct value modulo \\(2^{64}\\) is returned even in case of overflow. The AtCoder Library\u2019s floor_sum uses unsigned long long and guarantees the correct answer modulo \\(2^{64}\\).\n\nSample Implementation (Python3):\n```python\nfrom atcoder.math import floor_sum\nn, m, c, k = map(int, input().split())\na = sorted(list(set(map(int, input().split()))))\nn = len(a)\nfl = [floor_sum(k, m, c, a[i]) for i in range(n)]\nans = c * k * (k - 1) // 2 + k * a[0] - m * fl[0]\nfor i in range(1, n):\n  ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\nprint(ans)\n```\n\nSample Implementation (Python3, translated from C++):\n```python\nfrom atcoder.math import floor_sum\n\ndef main():\n    n, m, c, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a = list(dict.fromkeys(a))\n    n = len(a)\n    fl = [floor_sum(k, m, c, a[i]) for i in range(n)]\n    ans = k * (k - 1) // 2 * c + k * a[0] - m * fl[0]\n    for i in range(1, n):\n        ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\n    print(ans)\n\nmain()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a stack of `N` cards, and the `i-th` card from the top has an integer `A_i` written on it. You take `K` cards from the bottom of the stack and place them on top of the stack, maintaining their order.\n\nPrint the integers written on the cards from top to bottom after the operation.\n\n**Constraints**\n\n- \\(1 \\leq K < N \\leq 100\\)\n- \\(1 \\leq A_i \\leq 100\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet `B_i` be the integer written on the `i-th` card from the top of the stack after the operation. Print `B_1, B_2, \\ldots, B_N` in this order, separated by spaces.\n\n**Sample Input 1**\n\n```\n5 3\n1 2 3 4 5\n```\n\n**Sample Output 1**\n\n```\n3 4 5 1 2\n```\n\nInitially, the integers written on the cards are `1, 2, 3, 4, 5` from top to bottom. After taking three cards from the bottom of the stack and placing them on top, the integers written on the cards become `3, 4, 5, 1, 2` from top to bottom.\n\n**Sample Input 2**\n\n```\n6 2\n1 2 1 2 1 2\n```\n\n**Sample Output 2**\n\n```\n1 2 1 2 1 2\n```\n\nThe integers written on the cards are not necessarily distinct.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Hitachi Vantara Programming Contest 2024 (AtCoder Beginner Contest 368)\n\nThe topmost card after an operation is the \\(K\\)-th card from the bottom in the original pile. The \\(K\\)-th bottommost card is the \\((N-K+1)\\) card from the top, so the cards after the operation have \\(A_{N-K+1},A_{N-K+2},\\ldots,A_{N},A_{1},A_{2},\\ldots\\), and \\(A_{N-K}\\) written on them from the top. You may print these values. In many programming languages, indices start from \\(0\\), so beware of indices.\n\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\nfor i in range(N-K,N): print(A[i])\nfor i in range(N-K): print(A[i])\n```\n\nIn languages like Python, one can easily achieve the operation of splitting a pile into two and move the lower part to the top, as follows:\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\ntop = A[:-K]  # upper\nbottom = A[-K:]  # lower\nB = bottom + top  # put the lower part to the top\nprint(*B)\n```\n\nIn Python, you can also achieve a similar operation using list slicing:\n```python\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA = A[-K:] + A[:-K]\nprint(*A)\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nA pair of binary strings \\( (S, T) \\) is called **good** if and only if the following conditions are satisfied:\n\n1. \\( S \\) and \\( T \\) contain the same number of \\( 0 \\)s.\n2. \\( S \\) and \\( T \\) contain the same number of \\( 1 \\)s.\n\nParticularly, for a good string pair \\( (S, T) \\), \\( S \\) and \\( T \\) have the same length.\n\nFor a good string pair \\( (S, T) \\), we define an undirected graph \\( G(S, T) \\) as follows:\n\n- Let \\( L \\) be the length of \\( S \\). Create a graph \\( g \\) with vertices \\( 1, 2, \\cdots, L \\).\n- Let \\( n \\) be the number of \\( 0 \\)s in \\( S \\). Let the indices of \\( 0 \\)s in \\( S \\) be \\( 1 \\leq a_1 < a_2 < \\cdots < a_n \\leq L \\). Let the indices of \\( 0 \\)s in \\( T \\) be \\( 1 \\leq b_1 < b_2 < \\cdots < b_n \\leq L \\). For each \\( 1 \\leq i \\leq n \\), add an edge between vertices \\( a_i \\) and \\( b_i \\) to \\( g \\).\n- Let \\( m \\) be the number of \\( 1 \\)s in \\( S \\). Let the indices of \\( 1 \\)s in \\( S \\) be \\( 1 \\leq c_1 < c_2 < \\cdots < c_m \\leq L \\). Let the indices of \\( 1 \\)s in \\( T \\) be \\( 1 \\leq d_1 < d_2 < \\cdots < d_m \\leq L \\). For each \\( 1 \\leq i \\leq m \\), add an edge between vertices \\( c_i \\) and \\( d_i \\) to \\( g \\).\n\nThe graph \\( g \\) obtained through the above steps is \\( G(S, T) \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\). Find one good string pair \\( (S, T) \\) satisfying all of the following conditions:\n\n- Let \\( L \\) be the length of \\( S \\). It satisfies \\( N \\leq L \\leq 10^5 \\).\n- For each pair \\( 1 \\leq i, j \\leq N \\), vertices \\( i \\) and \\( j \\) belong to the same connected component in \\( G(S, T) \\) if and only if \\( A_i = A_j \\).\n\nIt can be proved that a solution always exists under the constraints of this problem.\n\n### Constraints\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n### Output\nPrint a solution in the following format:\n```\nL\nS\nT\n```\nHere, \\( L \\) is the length of \\( S \\) and \\( T \\).\n\nIf multiple solutions exist, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n1 2 1\n```\n\n### Sample Output 1\n```\n4\n0011\n1100\n```\nFor the \\( S \\) and \\( T \\) in the sample output, we obtain \\( G(S, T) \\) as follows:\n- Prepare a graph \\( g \\) with 4 vertices.\n- The indices of \\( 0 \\)s in \\( S \\) are \\( (1, 2) \\), and the indices of \\( 0 \\)s in \\( T \\) are \\( (3, 4) \\). Add edges \\( (1, 3) \\) and \\( (2, 4) \\) to \\( g \\).\n- The indices of \\( 1 \\)s in \\( S \\) are \\( (3, 4) \\), and the indices of \\( 1 \\)s in \\( T \\) are \\( (1, 2) \\). Add edges \\( (3, 1) \\) and \\( (4, 2) \\) to \\( g \\).\n\n\\( G(S, T) \\) has a connected component with vertices \\( (1, 3) \\) and another with vertices \\( (2, 4) \\). This satisfies all the conditions, so this \\( (S, T) \\) is a valid output.\n\n### Sample Input 2\n```\n5\n1 2 3 4 5\n```\n\n### Sample Output 2\n```\n5\n01010\n01010\n```\n\n### Sample Input 3\n```\n6\n1 1 1 1 1 1\n```\n\n### Sample Output 3\n```\n6\n011111\n111110\n```\n\n### Sample Input 4\n```\n10\n1 2 3 2 4 3 4 4 5 6\n```\n\n### Sample Output 4\n```\n21\n000101010111100011011\n011010000010101111110\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere's the cleaned version of the solution:\n\nFirst, initialize \\(S = 0 \\times N\\) (a string of \\(N\\) 0s), and \\(T = 1 \\times N\\). To satisfy the conditions, perform these operations: \n\n1. Append 0 to the end of \\(S\\), and 0 to the end of \\(T\\).\n2. Append 1 to the end of \\(S\\), and 0 to the end of \\(T\\).\n\nTrack the connected components of unmatched 0s and 1s. Let \\(x_1, x_2, \\cdots, x_k\\) be the components of unmatched 0s in \\(S\\), and \\(y_1, y_2, \\cdots, y_k\\) be for 1s in \\(T\\). Adding 0 to both \\(S\\) and \\(T\\) cyclically shifts \\(x\\) one position left. Adding 1 to \\(S\\) and 0 to \\(T\\) removes \\(x_1\\) and \\(y_1\\) and connects \\(x_1\\) and \\(y_1\\).\n\nTo meet \\(A\\), prepare a permutation \\(P\\) aligning with \\(A\\)'s cycle decomposition and connect \\(x_1\\) and \\(y_1\\) when \\(x_1 = A_{y_1}\\). The operations number is \\(O(N^2)\\).\n[END TEXT]\n \n\n", "problem_ids": ["arc182_e", "abc368_a", "agc068_b"]}, "abc308_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nYou will perform the following operation exactly once:\n\n- Choose a non-empty subsequence of \\( A \\) (not necessarily contiguous) and replace it with its cumulative sums.\nMore precisely, first choose a sequence of indices \\( (i_1, i_2, \\ldots, i_k) \\) such that \\( 1 \\leq i_1 < i_2 < \\cdots < i_k \\leq N \\).\n  The length of the sequence \\( k \\) (\\( 1 \\leq k \\leq N \\)) can be chosen freely.\n  Then, for each \\( j \\) (\\( 1 \\leq j \\leq k \\)), replace the value of \\( A_{i_j} \\) with \\( \\sum_{1 \\leq x \\leq j} A_{i_x} \\).\n  This replacement is done simultaneously for all chosen indices.\n\nFind, modulo \\( 10^9 + 7 \\), the number of possible sequences \\( A \\) after the operation.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\(-10 \\leq A_i \\leq 10 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\[\nN \\\\\nA_1\\ A_2\\ \\cdots\\ A_N\n\\]\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n3\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nThe possible sequences \\( A \\) after the operation are as follows:\n- \\( A = (1, 1, 2) \\): This can be achieved with \\( k = 1 \\) and \\( (i_1) = (1) \\).\n- \\( A = (1, 2, 2) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 2) \\).\n- \\( A = (1, 1, 3) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 3) \\).\n- \\( A = (1, 2, 4) \\): This can be achieved with \\( k = 3 \\) and \\( (i_1, i_2, i_3) = (1, 2, 3) \\).\n\n**Sample Input 2**\n\n```\n4\n1 -1 1 -1\n```\n\n**Sample Output 2**\n\n```\n8\n```\n\n**Sample Input 3**\n\n```\n5\n0 0 0 0 0\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\n**Sample Input 4**\n\n```\n40\n2 -2 1 3 -3 -1 -2 -3 0 -1 -2 0 -3 0 0 2 0 -1 2 -2 -2 -1 3 -2 -2 -2 2 3 2 -3 0 -2 2 1 3 0 -1 0 -2 -3\n```\n\n**Sample Output 4**\n\n```\n420429545\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Regular Contest 180\n\nC - Subsequence and Prefix Sum Editorial by evima\n\nConsider the following DP: \\(dp[i][j]=\\) The number of ways to perform the operation on the first \\(i\\) terms so that \\(A_i\\) changes to \\(A_i+j\\) (\\(j \\neq 0\\)). Because \\(j \\neq 0\\), the operation counted in \\(dp[i][j]\\) always selects \\(A_i\\) for the operation. The next term will increase by \\(A_i+j\\). The transition for \\(A_i+j \\neq 0\\) is straightforward. For \\(A_i+j=0\\), let \\(A_k\\) be the next term to change. To change \\(A_k \\to A_k+v\\), select \\(v\\) from \\(A_{i+1},\\cdots,A_{k-1}\\). Implementing these covers all transitions. This problem can be solved in \\(O(N^3 \\max(|A_i|))\\) time.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a weighted undirected graph \\( G \\) with \\( N \\) vertices, numbered from 1 to \\( N \\). Initially, the graph \\( G \\) has no edges.\n\nYou will perform \\( M \\) operations to add edges to the graph \\( G \\). The \\( i \\)-th operation \\((1 \\leq i \\leq M)\\) is as follows:\n\n- You are given a subset of vertices \\( S_i = \\{ A_{i,1}, A_{i,2}, \\dots, A_{i,K_i} \\} \\) consisting of \\( K_i \\) vertices.\n- For every pair of vertices \\( u, v \\) such that \\( u, v \\in S_i \\) and \\( u < v \\), add an edge between vertices \\( u \\) and \\( v \\) with weight \\( C_i \\).\n\nAfter performing all \\( M \\) operations, determine whether the graph \\( G \\) is connected. If it is connected, find the total weight of the edges in a minimum spanning tree of \\( G \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq K_i \\leq N \\)\n- \\( \\sum_{i=1}^{M} K_i \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq A_{i,1} < A_{i,2} < \\dots < A_{i,K_i} \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nK_1 C_1\nA_{1,1} A_{1,2} \\dots A_{1,K_1}\nK_2 C_2\nA_{2,1} A_{2,2} \\dots A_{2,K_2}\n...\nK_M C_M\nA_{M,1} A_{M,2} \\dots A_{M,K_M}\n```\n\n**Output Format**\n\nIf the graph \\( G \\) is not connected after all \\( M \\) operations, print `-1`. If \\( G \\) is connected, print the total weight of the edges in a minimum spanning tree of \\( G \\).\n\nSolution:\n\n\n[BEGIN TEXT]\nOne of the algorithms to find the spanning tree is Kruskal\u2019s algorithm. Starting from a state where no edge is added to the graph, inspect the edges in ascending order of weight. If the edge currently being inspected between vertices \\(u\\) and \\(v\\) is not connected yet, add it to the graph. By managing the connectivity of the graph using a data structure like Disjoint Set Union (DSU), the algorithm runs in a total of \\(O(E\\log E)\\) time, where sorting is the bottleneck. (\\(E\\) is the number of edges.)\n\nIn this problem, there are at most \\(O((\\sum K)^2)\\) edges, making it infeasible to apply the algorithm directly within the time limit. Instead, we use the following property about the minimum spanning tree: if there is an edge \\(e=(u,v)\\) that satisfies the condition where there exists a path connecting vertex \\(u\\) and vertex \\(v\\) consisting of edges with weights not greater than that of edge \\(e\\), but not containing edge \\(e\\), removing edge \\(e\\) from the candidates does not change the total weight of the minimum spanning tree.\n\nThis is due to the behavior of Kruskal's algorithm. On edge \\(e\\)\u2019s turn, \\(u\\) and \\(v\\) are already connected, so edge \\(e\\) is never used. In this problem, the edges added are: an edge of weight \\(C_i\\) connecting vertices \\(u\\) and \\(v\\) for all pairs of different vertices contained in \\(\\lbrace A_{i,1},A_{i,2},\\dots,A_{i,K_i}\\rbrace\\).\n\nBy the property above, we find it sufficient to add only the following edges: an edge of weight \\(C_i\\) connecting vertices \\(A_{i,1}\\) and \\(A_{i,j}\\) for each \\(j=2,3,\\dots,K_i\\). This modification reduces the total number of edges to \\(O(\\sum K)\\), making it feasible to apply Kruskal\u2019s algorithm to solve the problem.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere are \\( N \\) types of items. The \\( i \\)-th type of item has a weight of \\( w_i \\) and a value of \\( v_i \\). Each type has \\( 10^{10} \\) items available.\n\nTakahashi is going to choose some items and put them into a bag with capacity \\( W \\). He wants to maximize the value of the selected items while avoiding choosing too many items of the same type. Hence, he defines the **happiness** of choosing \\( k_i \\) items of type \\( i \\) as \\( k_i v_i - k_i^2 \\). He wants to choose items to maximize the total happiness over all types while keeping the total weight at most \\( W \\). Calculate the maximum total happiness he can achieve.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 3000 \\)\n- \\( 1 \\leq W \\leq 3000 \\)\n- \\( 1 \\leq w_i \\leq W \\)\n- \\( 1 \\leq v_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN W\nw_1 v_1\nw_2 v_2\n\\vdots\nw_N v_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n2 10\n3 4\n3 2\n```\n\n**Sample Output 1:**\n```\n5\n```\n\nBy choosing 2 items of type 1 and 1 item of type 2, the total happiness can be 5, which is optimal. Here, the happiness for type 1 is \\( 2 \\times 4 - 2^2 = 4 \\), and the happiness for type 2 is \\( 1 \\times 2 - 1^2 = 1 \\). The total weight is 9, which is within the capacity 10.\n\n**Sample Input 2:**\n```\n3 6\n1 4\n2 3\n2 7\n```\n\n**Sample Output 2:**\n```\n14\n```\n\n**Sample Input 3:**\n```\n1 10\n1 7\n```\n\n**Sample Output 3:**\n```\n12\n```\n\nSolution:\n\n```python\n# Here is a streamlined version focusing on the core solution:\n\ndef dp_happiness(N, W, items):\n    # Initialize dp table\n    dp = [[0] * (W + 1) for _ in range(max_weight + 1)]\n    \n    for w in range(1, max_weight + 1):\n        values = [v for v_i, w_i in items if w_i == w]\n        m = len(values)\n        \n        def f_w(k):\n            happiness = 0\n            # Priority queue to maximize happiness delta\n            deltas = [v - 1 for v in values]\n            deltas.sort(reverse=True)\n            for i in range(k):\n                if deltas:\n                    happiness += deltas[0]\n                    deltas[0] -= 2\n                    deltas.sort(reverse=True)\n            return happiness\n        \n        for j in range(W + 1):\n            dp[w][j] = dp[w-1][j]\n            for k in range(0, j // w + 1):\n                dp[w][j] = max(dp[w][j], dp[w-1][j - k * w] + f_w(k))\n    \n    return dp[max_weight][W]\n\n# Example usage:\n# N: number of items\n# W: maximum weight\n# Items: list of tuples, each tuple is (value, weight)\nN = 5\nW = 10\nitems = [(3, 2), (2, 2), (4, 3), (5, 5)]\nmax_weight = max(item[1] for item in items)\n\nmax_happiness = dp_happiness(N, W, items)\nprint(f\"Maximum total happiness: {max_happiness}\")\n```\n\nThis Python code implements the Dynamic Programming approach described in the editorial, fully translated from the explanation provided. The function `dp_happiness` takes the number of items, maximum weight, and a list of items (each defined by a tuple of value and weight) and computes the maximum total happiness.\n \n\n", "problem_ids": ["arc180_c", "abc352_e", "abc373_f"]}, "abc308_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThis problem is interactive, and the judge is adaptive. See the notes for details. Also, the parameters in the problem statement are fixed at \\( N = 1000 \\), \\( M = 10 \\), \\( Q = 950 \\).\n\nThere are \\( N \\) coins numbered \\( 1, 2, \\dots, N \\). Exactly \\( M \\) of these coins are counterfeit. An appraiser can, in one appraisal, determine whether two coins are of the same type or different types. Specifically:\n- If the two coins are both genuine or both counterfeit, they are judged to be of the same type.\n- Otherwise, they are judged to be of different types.\n\nIdentify all the counterfeit coins using at most \\( Q \\) appraisals.\n\n**Constraints**\n- \\( N = 1000 \\)\n- \\( M = 10 \\)\n- \\( Q = 950 \\)\n\n**Interaction**\n\nThis is an interactive problem. Initially, receive \\( N \\), \\( M \\), and \\( Q \\) from Standard Input:\n\n```\nN M Q\n```\n\nNext, you can perform appraisals between 0 and \\( Q \\) times, inclusive, as follows.\n\nFirst, by outputting to Standard Output in the following format, you indicate that you are appraising coins \\( x \\) and \\( y \\). (Include a newline at the end.)\n\n```\n? x y\n```\n\nHere, \\( x \\) and \\( y \\) must be distinct integers between 1 and \\( N \\), inclusive.\n\nIn response, the judge system will reply with one of the following three responses.\n\n- `0`: If the response is `0`, it means that coins \\( x \\) and \\( y \\) are of the same type.\n- `1`: If the response is `1`, it means that coins \\( x \\) and \\( y \\) are of different types.\n- `-1`: If the response is `-1`, it means that the appraisal is invalid. Specifically, this response is given when at least one of the following conditions is met:\n  - The outputted \\( x \\) and \\( y \\) do not satisfy the constraints.\n  - The number of appraisals exceeds \\( Q \\).\n\nIf you receive this response, your program is considered incorrect. Terminate your program immediately.\n\nFinally, by outputting to Standard Output in the following format, you answer that coins \\( A_1, A_2, \\ldots, A_M \\) are counterfeit. (Include a newline at the end.)\n\n```\n! A_1 A_2 \\dots A_M\n```\n\nHere, \\( A_i \\) must be distinct integers between 1 and \\( N \\), inclusive. After this output, terminate your program immediately.\n\nIf any of your outputs do not meet the specified format, your program will be considered incorrect. The judge will then respond with `-1`, so in that case, terminate your program immediately.\n\n**Notes**\n- Every time you output, include a newline at the end and flush Standard Output. Failure to do so may result in a verdict of Time Limit Exceeded (TLE) or Wrong Answer (WA).\n- After outputting your answer (or receiving `-1`), terminate your program immediately. Otherwise, the verdict is indeterminate.\n- Beware that unnecessary newlines are considered malformed.\n- The judge for this problem is adaptive. That is, at any point, as long as consistency can be maintained, the judge may change which coins are counterfeit. See the sample interaction for details.\n\n**Sample Interaction**\n\nIn this interaction, \\( N = 5 \\), \\( M = 2 \\), \\( Q = 10 \\), and the judge initially considers coins 1 and 2 to be counterfeit.\n\n*Note*: This example does not meet the constraints and is not included in the judge.\n\n**Input**\n```\n5 2 10\n```\n**Output**\n```\n? 1 2\n```\n**Explanation**: You appraise coins 1 and 2.\n\n**Input**\n```\n0\n```\n**Explanation**: Coins 1 and 2 are judged to be of the same type.\n\n**Output**\n```\n? 1 3\n```\n**Explanation**: You appraise coins 1 and 3.\n\n**Input**\n```\n1\n```\n**Explanation**: Coins 1 and 3 are judged to be of different types.\n\n**Output**\n```\n? 1 4\n```\n**Explanation**: You appraise coins 1 and 4.\n\n**Input**\n```\n1\n```\n**Explanation**: Coins 1 and 4 are judged to be of different types.\n\n**Output**\n```\n! 1 2\n```\n**Explanation**: You answer that coins 1 and 2 are counterfeit.\n\nIndeed, coins 1 and 2 are considered counterfeit, but it is also possible to consider coins 3 and 4 as counterfeit while maintaining consistency. Therefore, the judge may change the counterfeit coins to 3 and 4. As a result, the judge may judge this answer as incorrect.\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 184\n\nA - Appraiser Editorial by evima\n\nThe key point of this problem is that there are more genuine coins than counterfeit coins. Since there are \\(10\\) counterfeit coins, any group of \\(11\\) or more coins of the same type must be genuine.\n\nConsider dividing the \\(1000\\) coins into groups of \\(11\\). There will be \\(90\\) groups of \\(11\\) coins and a remainder of \\(10\\) coins. Among these \\(90\\) groups, at most \\(10\\) groups may contain counterfeit coins, so we can obtain at least \\(80\\) groups of \\(11\\) coins that are all of the same type. Also, we need \\(10\\) inspections to divide a group of \\(11\\) coins into two types (without knowing which is genuine).\n\nFirst, use \\(900\\) inspections to divide all the \\(11\\)-coin groups into two types. Next, exclude the coins that have been identified as genuine (where all \\(11\\) coins are of the same type). Record one coin number \\(x\\) identified as genuine. We have up to \\(20\\) groups of coins whose type is undetermined, and the \\(10\\) leftover coins. Using up to an additional \\(30\\) inspections, determine whether each remaining coin is of the same type as \\(x\\) to identify all counterfeit coins. This solution can identify all counterfeit coins using a maximum of \\(930\\) inspections.\n\nSample Implementation (Python 3):\n```python\ndef ask(x, y):\n    print(f\"? {x} {y}\")\n    # Assume here that we get a response from the interaction\n    res = int(input().strip())\n    return res\n\ndef ans(a):\n    print(\"!\", \" \".join(map(str, a)))\n\ndef main():\n    n, m, q = map(int, input().split())  # dummy input\n    ok = None\n    unknown = []\n    for i in range(90):\n        up = i * 11 + 1\n        g1 = [up]\n        g2 = []\n        for j in range(i * 11 + 2, i * 11 + 12):\n            if ask(up, j) == 0:\n                g1.append(j)\n            else:\n                g2.append(j)\n        if not g2:\n            ok = up\n        else:\n            unknown.append(g1)\n            unknown.append(g2)\n    for i in range(991, 1001):\n        unknown.append([i])\n    res = []\n    for nx in unknown:\n        if ask(nx[0], ok) == 1:\n            res.extend(nx)\n    ans(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n## Problem Statement\n\nSnuke is planning to build a maze as a new attraction in AtCoder Land. The maze is represented as a grid with \\( N \\) rows and \\( M \\) columns, with the top edge of the top-right cell being the entrance and the bottom edge of the bottom-right cell being the exit. He will create the maze by appropriately placing walls between adjacent cells.\n\nHe loves simple mazes, so he wants the path from the entrance to the exit to pass through exactly \\( K \\) cells without any branches. Determine if it is possible to create such a maze, and if possible, construct one.\n\nFor example, in the following figure, \\( N = 3 \\) and \\( M = 3 \\), and walls are placed at the solid lines (walls are always placed around the outer perimeter except for the entrance and exit). In this case, the path from the entrance to the exit passes through exactly 7 cells without any branches.\n\n### Formal Statement\n\nThere is a grid with \\( N \\) rows and \\( M \\) columns. Let \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. For each pair of side-adjacent cells, you can decide whether to place a wall between them. Determine whether it is possible to place walls to satisfy the following condition, and if it is possible, construct one such placement.\n\n**Condition**: There exists a simple path with \\( K \\) vertices that connects the two vertices \\((1, M)\\) and \\((N, M)\\), and the connected component containing the vertices \\((1, M)\\) and \\((N, M)\\) consists only of this path.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 100 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 1 \\leq K \\leq NM \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\n```\n\n### Output\n\nIf there is no placement of walls that satisfies the condition, print `No`. Otherwise, print one such placement in the following format. If multiple valid placements exist, any of them can be printed.\n\n**See also the sample outputs below to better understand the complicated output format.**\n\n```\nYes\n+++++ \\dots +++S+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n\\vdots\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+++++ \\dots +++G+\n```\n\nHere, `S`, `G`, `+`, and `o` represent the entrance, exit, a wall, and a cell, respectively, and `?` between cells represents a position where a wall can be placed. Replace `?` between two horizontally adjacent cells with `|` if a wall is placed, and `.` otherwise. Replace `?` between two vertically adjacent cells with `-` if a wall is placed, and `.` otherwise.\n\n**Formal Instruction:**\n\n- The output should consist of \\( 2N+2 \\) lines.\n  - Line 1 should contain the string `Yes`.\n  - Lines 2 to \\( 2N+2 \\) should contain strings of length \\( 2M+1 \\) as described below:\n    - Line 2 should be a concatenation of `+` repeated \\( 2M-1 \\) times, `S`, and `+`, in this order.\n    - Line \\( 1+2i \\) (\\( 1 \\leq i \\leq N \\)) should be a concatenation of `+`, `o`, \\( c_{i,1} \\), `o`, \\( c_{i,2} \\), \\(\\dots\\), \\( c_{i,M-1} \\), `o`, `+`, in this order. Here, \\( c_{i,j} \\) is `|` if a wall is placed between cells \\((i,j)\\) and \\((i,j+1)\\), and `.` otherwise.\n    - Line \\( 2+2i \\) (\\( 1 \\leq i \\leq N-1 \\)) should be a concatenation of `+`, \\( r_{i,1} \\), `+`, \\( r_{i,2} \\), `+`, \\(\\dots\\), `+`, \\( r_{i,M} \\), `+`, in this order. Here, \\( r_{i,j} \\) is `-` if a wall is placed between cells \\((i,j)\\) and \\((i+1,j)\\), and `.` otherwise.\n    - Line \\( 2N+2 \\) should be a concatenation of `+` repeated \\( 2M-1 \\) times, `G`, and `+`, in this order.\n\n### Sample Input 1\n\n```\n3 3 7\n```\n\n### Sample Output 1\n\n```\nYes\n+++++S+\n+o.o.o+\n+.+-+-+\n+o.o.o+\n+-+-+.+\n+o.o|o+\n+++++G+\n```\n\nThis is the same placement of walls as in the figure in the problem statement.\n\n### Sample Input 2\n\n```\n3 3 2\n```\n\n### Sample Output 2\n\n```\nNo\n```\n\n### Sample Input 3\n\n```\n4 1 4\n```\n\n### Sample Output 3\n\n```\nYes\n+S+\n+o+\n+.+\n+o+\n+.+\n+o+\n+.+\n+o+\n+G+\n```\n\nSolution:\n\n```python\n        Editorial - AtCoder Beginner Contest 358\n\nF - Easiest Maze Editorial by en_translator\n\nFor what kind of \\(K\\) does the solution exist? Obviously, \\(K\\geq N\\) is required, considering the length of the shortest path between squares \\((1,M)\\) and \\((N,M)\\). Let's draw the grid in a checkered pattern:\n\nAny path visits red square \\(\\rightarrow\\) blue square \\(\\rightarrow\\) red square \\(\\rightarrow\\dots\\). The color parity of squares \\((1,M)\\) and \\((N,M)\\) depends on \\(N\\). Thus, \\(N\\) and \\(K\\) must have the same parity. If \\(N\\) is even, the path ends with an even number of vertices. If \\(K\\geq N\\) and parities are the same, a solution can always be constructed. Starting from the path of the shortest length \\(N\\), increase the length by \\(2\\) incrementally, as \\(N, N+2, N+4, \\dots\\).\n\nImplement carefully with some casework. Use casework and construction separately. The sample code outlines how to compute the sequence of squares, build walls, and remove those between adjacent squares.\n\nSample code (Python 3):\n```python\ndef main():\n    n, m, k = map(int, input().split())\n    if k < n or k % 2 != n % 2:\n        print(\"No\")\n        return\n    print(\"Yes\")\n    path = []\n    k -= n\n    i = 0\n    while i < n - 1:\n        if i != n - 3:\n            w = 1 + min(m - 1, k // 2)\n            k -= (w - 1) * 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n        elif k <= (m - 1) * 2:\n            w = 1 + k // 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n            path.append((i + 2, m - 1))\n        else:\n            for j in range(m):\n                path.append((i, m - 1 - j))\n            k -= (m - 1) * 2\n            j = 0\n            while j < m:\n                if k:\n                    path.append((i + 1, j))\n                    path.append((i + 2, j))\n                    path.append((i + 2, j + 1))\n                    path.append((i + 1, j + 1))\n                    j += 2\n                    k -= 2\n                else:\n                    path.append((i + 1, j))\n                    j += 1\n            path.append((i + 2, m - 1))\n        i += 2\n    \n    c = [['|' for _ in range(m - 1)] for _ in range(n)]\n    r = [['-' for _ in range(m)] for _ in range(n - 1)]\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i + 1]\n        if x1 == x2:\n            c[x1][min(y1, y2)] = '.'\n        else:\n            r[min(x1, x2)][y1] = '.'\n    \n    print('+' + 'S'.join([''] + ['-' * (2 * m - 1), '+']))\n    for i in range(n):\n        print('+', end='')\n        for j in range(m - 1):\n            print('o' + c[i][j], end='')\n        print(\"o+\")\n        if i < n - 1:\n            for j in range(m):\n                print('+' + r[i][j], end='')\n            print('+')\n    print('+' + 'G'.join([''] + ['-' * (2 * m - 1), '+']))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["arc184_a", "abc361_a", "abc358_f"]}, "abc308_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( L \\), and \\( R \\). For a sequence \\( A = (1, 2, \\dots, N) \\) of length \\( N \\), an operation of reversing the \\( L \\)-th through \\( R \\)-th elements was performed once. Print the sequence after this operation.\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\leq L \\leq R \\leq N \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN L R\n```\n\n**Output**\n\nLet \\( A' = (A'_1, A'_2, \\dots, A'_N) \\) be the sequence after the operation. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n5 2 3\n```\n\n**Sample Output 1**\n```\n1 3 2 4 5\n```\n\nExplanation: Initially, \\( A = (1, 2, 3, 4, 5) \\). After reversing the second through third elements, the sequence becomes \\( (1, 3, 2, 4, 5) \\), which should be printed.\n\n**Sample Input 2**\n```\n7 1 1\n```\n\n**Sample Output 2**\n```\n1 2 3 4 5 6 7\n```\n\nExplanation: It is possible that \\( L = R \\).\n\n**Sample Input 3**\n```\n10 1 10\n```\n\n**Sample Output 3**\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nExplanation: It is possible that \\( L = 1 \\) or \\( R = N \\).\n\nSolution:\n\nHere is the cleaned version of the editorial text:\n\nApproach 1: Actually construct an array and apply reversion. Solve the problem by constructing the sequence \\(A=(1,2,\\dots,N)\\) as an array, reverse the \\(L\\)-th through \\(R\\)-th elements, and print the result. First, let \\(l=L\\) and \\(r=R\\). While \\(l<r\\), swap the \\(l\\)-th and \\(r\\)-th element, add \\(1\\) to \\(l\\), and subtract \\(1\\) from \\(r\\). Note that the first element might be treated as the \\(0\\)-th one depending on array usage.\n\nSample code 1 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nwhile L < R:\n    A[L], A[R] = A[R], A[L]\n    L += 1\n    R -= 1\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nSample code 2 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nA[L:R + 1] = reversed(A[L:R + 1])\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nApproach 2: Directly construct the sought sequence. The structure is as follows: arrange \\(1,2,\\dots,L-1\\), then \\(R,R-1,\\dots,L\\), and finally \\(R+1,R+2,\\dots,N\\).\n\nSample code (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nres = []\n\nfor i in range(1, L):\n    res.append(i)\nfor i in range(R, L - 1, -1):\n    res.append(i)\nfor i in range(R + 1, N + 1):\n    res.append(i)\n\nfor i in range(N):\n    if i:\n        print(\" \", end=\"\")\n    print(res[i], end=\"\")\nprint()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) rest areas around a lake. The rest areas are numbered \\( 1, 2, \\ldots, N \\) in clockwise order. It takes \\( A_i \\) steps to walk clockwise from rest area \\( i \\) to rest area \\( i+1 \\) (where rest area \\( N+1 \\) refers to rest area \\( 1 \\)).\n\nThe minimum number of steps required to walk clockwise from rest area \\( s \\) to rest area \\( t \\) (\\( s \\neq t \\)) must be a multiple of \\( M \\).\n\nDetermine the number of possible pairs \\((s, t)\\).\n\n**Constraints**\n\n- All input values are integers\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 10^6 \\)\n\n**Input Format**\n\nThe input is given from the standard input in the following format:\n\n```\nN M\nA_1 A_2 \\ldots A_N\n```\n\n**Output Format**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n4 3\n2 1 4 3\n```\n\n**Sample Output 1**\n```\n4\n```\n\n**Explanation**\n\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 2 is 2, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 3 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 4 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 3 is 1, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 4 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 1 is 8, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 4 is 4, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 1 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 2 is 9, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 1 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 2 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 3 is 6, which is a multiple of 3.\n\nThus, there are four possible pairs \\( (s, t) \\).\n\n**Sample Input 2**\n```\n2 1000000\n1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n9 5\n9 9 8 2 4 4 3 5 3\n```\n\n**Sample Output 3**\n```\n11\n```\n\nSolution:\n\n```python\n# Here is the cleaned version of the editorial:\n\n# For convenience, reassign the index \\((k-1)\\) to rest area \\(k\\) to treat indices from \\(0\\) through \\((N-1)\\). Consider the following array. Let \\(R_i\\) be the number of steps, modulo \\(M\\), required to travel from rest area \\(0\\) to rest area \\(i \\% N\\) as the \\(i\\)-th rest area to encounter. Precalculate these values for \\(i\\) from \\(0\\) through \\(2N-1\\). For example, if \\(A=(1,2,3,4)\\) and \\(M=6\\)...ultiple of \\(M\\)?\n\n# If \\(s<t\\), it holds when \\(R_s = R_t\\). This is equivalent to \\(R_{N+s}=R_{N+t}\\). If \\(s>t\\), it holds when \\(R_s = R_{N+t}\\).\n\n# Therefore, it is sufficient to solve the following problem:\n\n# Find the sum of the following value for \\(i=N,N+1,\\dots,2N-1\\). How many elements among \\(R_{i-N+1},R_{i-N+2},\\dots,R_{i-1}\\) are equal to \\(R_i\\)?\n\n# Intuitively, we are summing up the number of rest areas \\(i \\% N\\) to which the minimum steps required is a multiple of \\(M\\), over \\(i=N,N+1,\\dots,2N-1\\). This problem can be solved as follows:\n\n# First, let \\(B=(B[0],B[1],\\dots,B[M-1])\\) be the array of occurrences of \\(k\\) between \\(0\\) and \\(M-1\\) in \\(R_0\\) through \\(R_{N-1}\\). For \\(i = N,N+1,\\dots,2N-1\\), repeat the following:\n\n# Decrease \\(B[R_{i-N}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i-1\\).\n\n# Add \\(B[R_{i}]\\) Increase \\(B[R_{i}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i\\).\n\n# Translated sample code (Python 3):\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    r = [0]\n    for i in range(2 * n):\n        r.append((r[-1] + a[i % n]) % m)\n    b = [0] * m\n    for i in range(n):\n        b[r[i]] += 1\n    res = 0\n    for i in range(n, 2 * n):\n        b[r[i - n]] -= 1\n        res += b[r[i]]\n        b[r[i]] += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( A \\). You will perform the following operations:\n\n1. Generate \\( N \\) real numbers uniformly at random between 0 and 1, inclusive. All generations are independent, and the random numbers are uniformly distributed.\n   \n2. Call the generated \\( N \\) real numbers \\( x_1, x_2, \\ldots, x_N \\) in ascending order. That is, \\( 0 \\leq x_1 \\leq x_2 \\leq \\ldots \\leq x_N \\leq 1 \\).\n\n3. Your score is given by the following formula:\n\n   \\[\n   \\prod_{i=1}^{N} \\left(1 + \\sum_{j=i+1}^N x_j^A \\right)\n   \\]\n\nCalculate the expected value, modulo \\( 10^9+7 \\), of the score.\n\n**Definition of expected value modulo \\( 10^9+7 \\)**\n\nIt can be proved that the sought expected value is always rational. Furthermore, under the constraints of this problem, it can be proved that if the expected value is expressed as an irreducible fraction \\(\\frac{P}{Q}\\), then \\( Q \\not\\equiv 0 \\pmod{10^9+7} \\). Therefore, there exists a unique integer \\( R \\) such that \\( R \\times Q \\equiv P \\pmod{10^9+7} \\) and \\( 0 \\leq R < 10^9+7 \\). Report this \\( R \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq A \\leq 5 \\times 10^4 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1\n```\n\n**Sample Output 1**\n\n```\n666666673\n```\n\nThe expected value of the score is \\( \\frac{5}{3} \\).\n\n**Sample Input 2**\n\n```\n1 1\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\n**Sample Input 3**\n\n```\n2 2\n```\n\n**Sample Output 3**\n\n```\n500000005\n```\n\n**Sample Input 4**\n\n```\n3 2\n```\n\n**Sample Output 4**\n\n```\n142857147\n```\n\n**Sample Input 5**\n\n```\n5 3\n```\n\n**Sample Output 5**\n\n```\n758371066\n```\n\n**Sample Input 6**\n\n```\n10000 12345\n```\n\n**Sample Output 6**\n\n```\n32201773\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Let \\(a_n(y)\\) be the expected value for a real number \\(y\\) (\\(0 \\leq y \\leq 1\\)) and a non-negative integer \\(n\\). Generate \\(n\\) real numbers within \\([0,1]\\) as \\(x_1, \\cdots, x_n\\). If \\(x_1 < \\cdots < x_n < y\\) is not satisfied, output \\(0\\). If they are in ascending order, output \\(\\prod_{1 \\leq i \\leq n} (y^A + \\sum_{i < j \\leq n} x_j^A)\\).\n\nDefine \\(f(y,x) = \\sum_{0 \\leq n} a_n(y)x^n\\). \\(a_n(y)\\) is a polynomial in \\(y\\), and \\(f\\) is a formal power series. We aim to find \\(N! [x^N]f(1,x)\\). Consider choosing one term from \\(y^A, x_{i+1}^A, \\cdots x_N^A\\) for each \\(i\\) and calculating their product, forming a tree. We draw arrows based on choices: from \\(i\\) to \\(j\\) for \\(x_j^A\\), and \\(i\\) to * for choosing \\(y^A\\). This setup reveals an equation for \\(f\\), decomposed into subproblems for each subtree. The weight of a subtree rooted at child \\(v\\) is \\(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt\\).\n\nIf * has \\(k\\) children, subtrees are ordered and multiplied by \\(1/k!\\). Thus, \\(f\\) satisfies: \\(f(y,x) = \\exp(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt)\\). \\(a_n(y)\\) is a polynomial and a constant multiple of \\(y^{(A+1)n}\\). Write \\(g(z) = f(x,y)\\) with \\(z = y^{A+1}x\\) using power series \\(g(z) = \\sum_{0 \\leq n} b_n z^n\\). Rewrite \\(f\\) for \\(g\\): \\(g(z) = \\exp(\\sum_{0 \\leq n} \\frac{b_n}{(A+1)n+1} z^{n+1})\\).\n\nLet \\(h(z)\\) be inside \\(\\exp\\). Knowing \\([z^n] g\\) allows calculation of \\([z^{n+1}] h(z)\\) and \\([z^{n+1}] g(z)\\). The coefficients of \\(g\\) can be determined in order. Calculate \\([z^{n+1}] g(z)\\) using \\(\\frac{d}{dz}g = \\frac{d}{dz}\\exp(h) = \\frac{d}{dz}h \\times g\\), achievable in \\(O(n)\\). Solve the problem in \\(O(N^2)\\) time overall.\n        [END TEXT]\n \n\n", "problem_ids": ["abc356_a", "abc367_d", "arc180_f"]}, "abc308_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThe problem statement is as follows:\n\n**Problem Statement:**\n\nThere is a rooted tree with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). The root is vertex \\( 1 \\), and the parent of vertex \\( i \\) (\\( 2 \\leq i \\leq N \\)) is vertex \\( P_i \\) (\\( P_i < i \\)).\n\nThere are also integer sequences of length \\( M \\): \\( A = (A_1, A_2, \\cdots, A_M) \\) and \\( B = (B_1, B_2, \\cdots, B_M) \\), consisting of integers between \\( 1 \\) and \\( N \\), inclusive.\n\nSequence \\( A \\) is said to be **good** if and only if for each \\( i \\), vertex \\( A_i \\) is an ancestor of vertex \\( B_i \\) or \\( A_i = B_i \\). Initially, \\( A \\) is good.\n\nConsider the following operation on \\( A \\):\n\n- Choose an integer \\( i \\) (\\( 1 \\leq i \\leq M-1 \\)) and swap the values of \\( A_i \\) and \\( A_{i+1} \\). Here, \\( A \\) must remain good after the operation.\n\nFind the number, modulo \\( 998244353 \\), of sequences that can result from performing this operation on \\( A \\) zero or more times.\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 250000 \\)\n- \\( 2 \\leq M \\leq 250000 \\)\n- \\( 1 \\leq P_i < i \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq N \\)\n- Vertex \\( A_i \\) is an ancestor of vertex \\( B_i \\) or \\( A_i = B_i \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nP_2 P_3 \\cdots P_N\nA_1 A_2 \\cdots A_M\nB_1 B_2 \\cdots B_M\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n```\n3 3\n1 2\n1 2 1\n1 2 3\n```\n\n**Sample Output 1:**\n```\n2\n```\n\nConsider choosing \\( i = 1 \\). The \\( A = (2, 1, 1) \\) after the operation is not good, so this operation is invalid. Consider choosing \\( i = 2 \\). The \\( A = (1, 1, 2) \\) after the operation is good, so this operation is valid. There are two sequences that can result from performing zero or more operations on \\( A \\): \\( A = (1, 2, 1) \\) and \\( (1, 1, 2) \\).\n\n**Sample Input 2:**\n```\n4 3\n1 1 1\n2 3 4\n2 3 4\n```\n\n**Sample Output 2:**\n```\n1\n```\n\n**Sample Input 3:**\n```\n8 13\n1 2 2 3 4 4 3\n5 3 2 5 4 6 2 8 2 6 7 4 7\n5 5 8 5 6 6 5 8 3 6 7 4 7\n```\n\n**Sample Output 3:**\n```\n8\n```\n\n**Sample Input 4:**\n```\n30 27\n1 2 1 1 5 1 7 1 5 10 1 12 12 13 15 16 12 18 19 18 21 21 23 13 18 18 27 27 13\n1 18 1 5 11 12 1 1 1 12 1 12 1 15 1 1 21 1 12 10 2 8 3 1 1 30 12\n14 27 30 5 11 17 1 18 24 27 29 27 19 15 28 5 21 21 29 11 2 8 3 4 10 30 22\n```\n\n**Sample Output 4:**\n```\n60\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere is the cleaned-up version focusing solely on the solution:\n\nFor each \\(i\\), consider the maximal interval \\([L_i, R_i]\\) that satisfies the conditions: \\(L_i \\leq i \\leq R_i\\), and for each \\(j \\in [L_i, R_i]\\), vertex \\(A_i\\) is an ancestor of vertex \\(B_j\\) (or \\(A_i = B_j\\)). The interval \\([L_i, R_i]\\) represents the range within which \\(A_i\\) can seemingly move. However, some positions within this range may be fixed, meaning \\(A_i\\) actually cannot move there. The set of intervals \\([L_i, R_i]\\) is laminar, forming a tree-like structure without partial overlaps.\n\nWe process in descending order of \\(A_i\\), which equates to ascending order of \\([L_i, R_i]\\) size. Within \\([L_i, R_i]\\), we calculate where \\(A_i\\) can actually move by excluding fixed positions. Suppose there are \\(k\\) intervals in the subtree of \\([L_i, R_i]\\): if \\(R_i - L_i + 1 = k\\), these intervals fill \\([L_i, R_i]\\), fixing those positions. Hence, \\(A_i\\) can move within \\([l, r]\\), excluding fixed positions.\n\nThe actual available positions depend on those not occupied by previously processed values. The count of such positions determines the candidates for placing the current \\(A_i\\). This must be done for all \\(A_i\\), considering duplicate values by dividing by an appropriate factor. \\(L_i\\) and \\(R_i\\) can be found using binary search and interval LCA queries on \\(B\\), processed in \\(O(\\log M + \\log N)\\) time. This leads to a time complexity of \\(O(N + M\\log M(\\log M + \\log N))\\), which can be optimized by handling interval min query and LCA query in \\(O(1)\\) time.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nA non-negative integer \\(X\\) is called a palindrome number if its decimal representation (without leading zeros) is a palindrome. For example, \\(363\\), \\(12344321\\), and \\(0\\) are all palindrome numbers. \n\nFind the \\(N\\)-th smallest palindrome number.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 10^{18}\\)\n- \\(N\\) is an integer.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\n```\n\n**Output**\n\nPrint the \\(N\\)-th smallest palindrome number.\n\n**Sample Input 1**\n\n```\n46\n```\n\n**Sample Output 1**\n\n```\n363\n```\n\nThe 46th smallest palindrome number is 363.\n\n**Sample Input 2**\n\n```\n1\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Sample Input 3**\n\n```\n1000000000000000000\n```\n\n**Sample Output 3**\n\n```\n90000000000000000000000000000000009\n```\n\nSolution:\n\n```python\ndef TEN(x):\n    return 1 if x == 0 else 10 ** x\n\ndef find_palindrome(N):\n    if N == 1:\n        print(0)\n        return\n    \n    N -= 1\n    d = 1\n    while True:\n        x = (d + 1) // 2\n        if N < 9 * TEN(x - 1):\n            S = str(TEN(x - 1) + N)\n            S = S.ljust(d, ' ')\n            for i in range(x, d):\n                S = S[:i] + S[d - 1 - i] + S[i + 1:]\n            print(S)\n            return\n        else:\n            N -= 9 * TEN(x - 1)\n        d += 1\n\n# Example usage:\n# N = int(input())\n# find_palindrome(N)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n### Problem Statement\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\).\n\nYour objective is to transform this permutation into the identity permutation \\( P_i = i \\) for all \\( i = 1, 2, \\ldots, N \\) by performing the following operation zero or more times:\n\n1. Choose an integer \\( k \\) such that \\( 1 \\leq k \\leq N \\).\n2. If \\( k \\geq 2 \\), sort the elements from the 1st to the \\((k-1)\\)-th position of \\( P \\) in ascending order.\n3. Then, if \\( k \\leq N - 1 \\), sort the elements from the \\((k+1)\\)-th to the \\( N \\)-th position of \\( P \\) in ascending order.\n\nIt can be proved that under the constraints of this problem, it is possible to transform any given permutation \\( P \\) into the identity permutation with a finite number of operations. Your task is to find the minimum number of operations required.\n\nYou have \\( T \\) test cases to solve.\n\n### Constraints\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 3 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( P \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n- The sum of \\( N \\) across the test cases in a single input is at most \\( 2 \\times 10^5 \\).\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\n...\ncase_T\n```\n\nEach case is presented as follows:\n\n```\nN\nP_1 P_2 ... P_N\n```\n\n### Output\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\n\n### Sample Input 1\n\n```\n3\n5\n2 1 3 5 4\n3\n1 2 3\n7\n3 2 1 7 5 6 4\n```\n\n### Sample Output 1\n\n```\n1\n0\n2\n```\n\n#### Explanation:\n\n- For the first test case, the operation with \\( k = 3 \\) yields \\( P \\) as \\( (1, 2, 3, 4, 5) \\), requiring 1 operation.\n- The second test case already satisfies \\( P_i = i \\), thus needing 0 operations.\n- For the third test case, perform the operations with \\( k = 4 \\) and then \\( k = 3 \\) successively to achieve the identity permutation \\( (1, 2, 3, 4, 5, 6, 7) \\), requiring 2 operations.\n\nSolution:\n\n---\n\nSince each operation sorts a significant portion of the array, it is expected that the entire array can be sorted with a few operations. In fact:\n\n1. Perform the operation with \\(k=1\\). This sorts the entire array if \\(P_1=1\\) in the initial state. Otherwise, we have \\(P_N \\neq 1\\) after the operation since \\(N \\geq 3\\).\n2. Next, perform the operation with \\(k=N\\). Since \\(P_N \\neq 1\\) before the operation, we have \\(P_1=1\\) after the operation.\n3. Perform the operation with \\(k=1\\). Since \\(P_1=1\\) before the operation, the entire array is certainly sorted after the operation.\n\nBy performing the above, any permutation can be sorted in at most three operations. Therefore, it is sufficient to quickly determine if the array can be sorted in zero, one, or two operations.\n\n- The determination for zero operations is trivial.\n- For one operation, if we fix \\(k\\), it is necessary and sufficient that the minimum and maximum values of \\((P_1, P_2, \\dots, P_{k-1})\\) are \\(1\\) and \\(k-1\\), respectively, and \\(P_k=k\\). This can be checked in \\(O(1)\\) time for each \\(k\\) by taking cumulative \\(\\min\\) and \\(\\max\\), so the overall determination can be done in \\(O(N)\\) time.\n- For two operations, if \\(P_N \\neq 1\\), starting from the second of the three operations, the array can be sorted in two operations. Similarly, if \\(P_1 \\neq N\\), it can be sorted in two operations. Conversely, if \\(P_1=N\\) and \\(P_N=1\\), the relative positions of \\(1\\) and \\(N\\) in \\(P\\) do not change with one operation, leaving them in the order \\(N, 1\\). Therefore, \\(P\\) can be sorted in two or fewer operations \\(\\iff\\) \\(P_1 \\neq N\\) or \\(P_N \\neq 1\\). This can be checked in \\(O(1)\\) time.\n\nFrom the above, the answer for each test case can be found in \\(O(N)\\) time.\n \n\n", "problem_ids": ["arc183_e", "abc363_d", "arc181_a"]}, "abc308_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer \\( K \\). For a set \\( S \\) that is initially empty, you need to process \\( Q \\) queries of the following two types in order:\n\n1. `1 x`: An integer \\( x \\) is given. If \\( x \\) is in \\( S \\), remove \\( x \\) from \\( S \\). Otherwise, add \\( x \\) to \\( S \\).\n2. `2 x`: An integer \\( x \\) that is in \\( S \\) is given. Consider a graph where the vertices are the numbers in \\( S \\), and there is an edge between two numbers if and only if the absolute difference between them is at most \\( K \\). Print the count of vertices in the connected component that contains \\( x \\).\n\n**Constraints:**\n\n- \\( 1 \\leq Q \\leq 200,000 \\)\n- \\( 0 \\leq K \\leq 10^{18} \\)\n- For each query, \\( 1 \\leq x \\leq 10^{18} \\).\n- For each query of the second type, the given \\( x \\) is in \\( S \\) at that point.\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nQ K\nquery_1\n...\nquery_Q\n```\nEach query is given in the following format:\n- For type 1 query: `1 x`\n- For type 2 query: `2 x`\n\n**Output:**\n\nProcess the queries and for each query of type 2, output the size of the connected component containing \\( x \\).\n\n**Sample Input 1:**\n```\n7 5\n1 3\n1 10\n2 3\n1 7\n2 3\n1 10\n2 3\n```\n\n**Sample Output 1:**\n```\n1\n3\n2\n```\n\n**Explanation:**\n\n- In the first query, \\( 3 \\) is added to \\( S \\), resulting in \\( S=\\{3\\} \\).\n- In the second query, \\( 10 \\) is added to \\( S \\), resulting in \\( S=\\{3, 10\\} \\).\n- In the third query, consider a graph with vertices \\( 3 \\) and \\( 10 \\) and no edges. The connected component containing \\( 3 \\) has a size of 1, so print 1.\n- In the fourth query, \\( 7 \\) is added to \\( S \\), resulting in \\( S=\\{3, 7, 10\\} \\).\n- In the fifth query, consider a graph with vertices \\( 3, 7, \\) and \\( 10 \\), with edges between \\( 3 \\) and \\( 7 \\), and \\( 7 \\) and \\( 10 \\). The connected component containing \\( 3 \\) has a size of 3, so print 3.\n- In the sixth query, \\( 10 \\) is removed from \\( S \\), resulting in \\( S=\\{3, 7\\} \\).\n- In the seventh query, consider a graph with vertices \\( 3 \\) and \\( 7 \\), with an edge between them. The connected component containing \\( 3 \\) has a size of 2, so print 2.\n\n**Sample Input 2:**\n```\n11 1000000000000000000\n1 1\n1 100\n1 10000\n1 1000000\n1 100000000\n1 10000000000\n1 1000000000000\n1 100000000000000\n1 10000000000000000\n1 1000000000000000000\n2 1\n```\n\n**Sample Output 2:**\n```\n10\n```\n\n**Sample Input 3:**\n```\n8 0\n1 1\n1 2\n2 1\n1 1\n1 2\n1 1\n1 2\n2 1\n```\n\n**Sample Output 3:**\n```\n1\n1\n```\n\nSolution:\n\n```python\nclass SegmentTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (2 * size)\n\n    def update(self, pos, value):\n        pos += self.size\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left, right):\n        result = 0\n        left += self.size\n        right += self.size\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef add_or_remove_edge(segments, A, x):\n    A[x] = 1 - A[x]\n    segments.update(x, A[x])\n\ndef find_connected_component_size(segments, start_x, size):\n    left = start_x\n    right = start_x\n\n    # Extend to the right\n    while right < size - 1 and segments.query(start_x, right + 1) == right + 1 - start_x:\n        right += 1\n\n    # Extend to the left\n    while left > 0 and segments.query(left - 1, start_x) == start_x - left + 1:\n        left -= 1\n\n    return right - left + 1\n\n# Assuming the segment size is known and is sufficient\nsize = 10000\nsegments = SegmentTree(size)\nA = [0] * size\n\n# Example usage\nadd_or_remove_edge(segments, A, 5)\ncomponent_size = find_connected_component_size(segments, 5, size)\nprint(\"Component size:\", component_size)\n```\n\nFor three numbers \\(a < b < c\\) and any \\(K\\), if \\(c-a \\leq K\\), then \\(b-a \\leq K\\) and \\(c-b \\leq K\\). Consequently, if there is an edge between \\(a\\) and \\(c\\), then there are also edges between \\(a\\) and \\(b\\), and \\(b\\) and \\(c\\). Thus, one can only add edges between adjacent elements in the sorted \\(S\\) without changing connectivity.\n\nFirst, consider a graph with \\(N\\) vertices and \\(0\\) edges. Two types of queries are:\n\n1. Given \\(x\\), add an edge between vertices \\(x\\) and \\(x+1\\) if absent, or remove it if present.\n2. Find the size of the connected component containing vertex \\(x\\).\n\nLet \\(A_i\\) be \\(1\\) if there is an edge between \\(i\\) and \\(i+1\\), and \\(0\\) otherwise. The two queries can be processed as follows:\n\n- Addition and deletion of an edge are done by updating \\(A_i\\).\n- To find how far the connected component containing \\(x\\) extends to the right, \\(y > x\\) is connected to \\(x\\) if and only if \\(A[x] + \\ldots + A[y-1] = y-x\\). The maximum such \\(y\\) can be quickly found with binary search by finding the segment sum of \\(A\\). The same applies to the left.\n\nThe altered question can be solved by managing the array \\(A\\) in a segment tree. The original problem asks to add or remove vertices by maintaining the following two arrays \\(A\\) and \\(B\\) as segment trees to manage the existence of vertices and edges:\n\n- \\(A_i = 1\\) if \\(x\\) is contained in \\(S\\), and \\(A_i = 0\\) otherwise.\n- \\(B_i = 1\\) if there is an edge between \\(x\\) and \u201cthe next vertex to the right,\u201d and \\(B_i = 0\\) otherwise.\n\nCoordinate compression or a dynamic segment tree can keep the number of nodes small, making the complexity \\(O(Q\\log Q)\\) or \\(O(Q\\log\\max x_i)\\).\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThe pattern of AtCoder's wallpaper can be represented on the xy-plane as follows:\n\n- The plane is divided by the following three types of lines:\n  - \\( x = n \\) (where \\( n \\) is an integer)\n  - \\( y = n \\) (where \\( n \\) is an even number)\n  - \\( x + y = n \\) (where \\( n \\) is an even number)\n\n- Each region is painted black or white. Any two regions adjacent along one of these lines are painted in different colors.\n- The region containing (0.5, 0.5) is painted black.\n\nYou are given integers \\( A, B, C, \\) and \\( D \\). Consider a rectangle whose sides are parallel to the x- and y-axes, with its bottom-left vertex at \\( (A, B) \\) and its top-right vertex at \\( (C, D) \\). Calculate the area of the regions painted black inside this rectangle, and print twice that area.\n\nIt can be proved that the output value will be an integer.\n\n**Constraints:**\n\n- \\( -10^9 \\leq A, B, C, D \\leq 10^9 \\)\n- \\( A < C \\) and \\( B < D \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nA B C D\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n\n```\n0 0 3 3\n```\n\n**Sample Output 1:**\n\n```\n10\n```\n\nThe area of the black-painted region inside the following square is 5, so print twice that value: 10.\n\n**Sample Input 2:**\n\n```\n-1 -2 1 3\n```\n\n**Sample Output 2:**\n\n```\n11\n```\n\nThe area is 5.5, but the output value is an integer.\n\n**Sample Input 3:**\n\n```\n-1000000000 -1000000000 1000000000 1000000000\n```\n\n**Sample Output 3:**\n\n```\n4000000000000000000\n```\n\nThis is the case with the largest rectangle, where the output still fits into a 64-bit signed integer.\n\nSolution:\n\n        Editorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nD - AtCoder Wallpaper Editorial by en_translator\n\nThe pattern of the wallpaper is an infinite repetition of this \\(4 \\times 2\\) rectangle. Thus, one can solve this problem by counting for each of the eight \\(1 \\times 1\\) squares how many instances of them are contained in the given rectangle. In order to count the number of squares at each position, it may be difficult to handle boundaries. As an example, we take the following approach in the sample code below.\n\nCount squares along \\(x\\) and \\(y\\) axes independently, and multiply it afterward. To count squares along the \\(x\\) axis, take a sufficiently large constant \\(P\\) that is a multiple of four (such as \\(1.1 \\times 10^9\\)), and compute \\((\\text{The number of squares between }x = -P\\text{ and }x = C) - (\\text{The number of squares between }x = -P\\text{ and }x = A)\\).\n\nWe pick such \\(P\\) to avoid issues on rounding-down division toward \\(0\\). Do the same thing for the \\(y\\) axis.\n\nAlso, when debugging this type of problem, it is effective to generate cases by yourself. In this problem, if it is a boundary issue that matters, it is a good idea to try many cases for \\(0 \\leq A, B, C, D \\leq 8\\).\n\nSample code (Python):\n```python\nmass = [[2, 1, 0, 1],\n        [1, 2, 1, 0]]\n# mass[i][j] : area of rectangle [[j, j + 1], [i, i + 1]] x 2\n\ninf = 4000000000\n\n# input\na, b, c, d = map(int, input().split())\n\n# calculation\nans = 0\nfor fy in range(2):\n    for fx in range(4):\n        x1 = (a - fx + 3 + inf) // 4\n        x2 = (c - fx + 3 + inf) // 4\n        count_x = x2 - x1  # count along x axis\n        y1 = (b - fy + 1 + inf) // 2\n        y2 = (d - fy + 1 + inf) // 2\n        count_y = y2 - y1  # count along y axis\n        ans += count_x * count_y * mass[fy][fx]\n\n# output\nprint(ans)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\) and a prime \\( P \\).\n\nCount the number, modulo \\( P \\), of undirected connected graphs \\( G \\) of \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) that satisfy the following conditions:\n\n1. There are no self-loops in \\( G \\). Note that multiple edges are allowed.\n2. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) remains connected. In other words, \\( G \\) is edge-biconnected.\n3. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) is no longer edge-biconnected.\n\nTwo graphs are considered different if and only if there exists a pair of distinct vertices \\( (u,v) \\) such that the numbers of edges connecting \\( u \\) and \\( v \\) in the two graphs are different.\n\n**Constraints**\n\n- \\( 2 \\le N \\le 50 \\)\n- \\( 10^9 < P < 1.01 \\times 10^9 \\)\n- \\( P \\) is prime.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**  \n```\n2 1005976817\n```\n\n**Sample Output 1**  \n```\n1\n```\n\n**Sample Input 2**  \n```\n5 1000837403\n```\n\n**Sample Output 2**  \n```\n372\n```\n\n**Sample Input 3**  \n```\n10 1001160547\n```\n\n**Sample Output 3**  \n```\n789846604\n```\n\n**Sample Input 4**  \n```\n20 1006779551\n```\n\n**Sample Output 4**  \n```\n888612770\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Grand Contest 067 - E: Biconnected Graph Editorial by Kubic\n\nIf an edge is deleted, the remaining graph will form a chain after shrinking biconnected components; it will become a cycle if the edge is added back. Solve the problem for each biconnected component and multiply the answers. In the subproblem, there's an additional edge connecting two vertices, allowing them to reach each other through the cycle. Repeat this method by taking an edge connected to vertex \\(1\\), leading to subproblems formatted as:\n\nCount good graphs of \\(n\\) vertices with the first \\(k\\) vertices able to reach each other externally.\n\nConsider the distribution of the first \\(k\\) vertices:\n\n\\(\\forall 1\\le u,v\\le k\\), \\(C(u),C(v)\\) are not adjacent in the cycle, where \\(C(u)\\) is the biconnected component containing \\(u\\).\n\nDP through the cycle without constraining the edge choice so every good graph is counted \\(\\deg(1)\\) times. Store \\(\\deg(1)\\) in the DP state and divide the final answer by it.\n\nTime complexity: \\(O(n^5)\\). Some \\(O(n^6)\\) solutions with small constants may pass.\n        [END TEXT]\n \n\n", "problem_ids": ["abc356_f", "abc354_d", "agc067_e"]}, "abc308_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence of \\(N\\) positive integers \\(A = (A_1, A_2, \\dots, A_N)\\). Takahashi repeats the following operation until \\(A\\) contains one or fewer positive elements:\n\n1. Sort \\(A\\) in descending order.\n2. Then, decrease both \\(A_1\\) and \\(A_2\\) by 1.\n\nFind the number of times he performs this operation.\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 100\\)\n- \\(1 \\leq A_i \\leq 100\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n4\n1 2 3 3\n```\n\n**Sample Output 1**\n```\n4\n```\n\n*Explanation:*\n\nThe process goes as follows:\n\n- After the 1st operation, \\(A\\) is \\((2, 2, 2, 1)\\).\n- After the 2nd operation, \\(A\\) is \\((1, 1, 2, 1)\\).\n- After the 3rd operation, \\(A\\) is \\((1, 0, 1, 1)\\).\n- After the 4th operation, \\(A\\) is \\((0, 0, 1, 0)\\). \\(A\\) no longer contains more than one positive element, so the process ends here.\n\n**Sample Input 2**\n```\n3\n1 1 100\n```\n\n**Sample Output 2**\n```\n2\n```\n\nSolution:\n\nCertainly! Here's the cleaned version of the editorial focused on the solution part:\n\n---\n\nThis problem can be solved with a simulation. Rearranging \\(A\\) in descending order can be done with the sort function in most programming languages. For more details, please refer to the following code.\n\n```python\ndef main():\n    # input\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    answer = 0\n    while True:\n        # sort\n        a.sort(reverse=True)\n        \n        # check condition\n        if a[0] == 0 or a[1] == 0:\n            break\n        \n        # apply\n        a[0] -= 1\n        a[1] -= 1\n        answer += 1\n    \n    # output\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\) and a sequence \\( B = (B_1, B_2, \\dots, B_M) \\) of length \\( M \\). Here, all elements of \\( A \\) and \\( B \\) are pairwise distinct. Determine whether the sequence \\( C = (C_1, C_2, \\dots, C_{N+M}) \\) formed by sorting all elements of \\( A \\) and \\( B \\) in ascending order contains two consecutive elements appearing in \\( A \\).\n\n**Constraints**\n\n- \\( 1 \\leq N, M \\leq 100 \\)\n- \\( 1 \\leq A_i, B_j \\leq 200 \\)\n- \\( A_1, A_2, \\dots, A_N, B_1, B_2, \\dots, B_M \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_1 A_2 \\dots A_N\nB_1 B_2 \\dots B_M\n```\n\n**Output**\n\nIf \\( C \\) contains two consecutive elements appearing in \\( A \\), print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n\n```\n3 2\n3 2 5\n4 1\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\n\\( C = (1, 2, 3, 4, 5) \\). Since \\( 2 \\) and \\( 3 \\) from \\( A \\) occur consecutively in \\( C \\), print `Yes`.\n\n**Sample Input 2**\n\n```\n3 2\n3 1 5\n4 2\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\n\\( C = (1, 2, 3, 4, 5) \\). Since no two elements from \\( A \\) occur consecutively in \\( C \\), print `No`.\n\n**Sample Input 3**\n\n```\n1 1\n1\n2\n```\n\n**Sample Output 3**\n\n```\nNo\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 355 (B - Piano 2)\n\nThis problem asks to rearrange elements in a sequence in a specific order, which is called sorting\u2014a standard feature in most languages. For example, Python and C++ both provide a function named sort. To solve the problem, concatenate lists \\(A\\) and \\(B\\) to define \\(C\\), sort \\(C\\), inspect the elements of \\(C\\), and check if adjacent elements are both contained in \\(A\\).\n\nIn Python, use the `in` operator, and in C++, use the set operator to check element containment.\n\nSample code (Python):\n\n```python\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = A + B\nC.sort()\nfor i in range(N + M - 1):\n    if C[i] in A and C[i + 1] in A:\n        print(\"Yes\")\n        exit()\nprint(\"No\")\n```\n\nSample code (C++):\n\n```python\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nC = A[:]\nC.extend(B)\nC.sort()\n\nst = set(A)\n\nfor i in range(N + M - 1):\n    if C[i] in st and C[i + 1] in st:\n        print(\"Yes\")\n        exit()\nprint(\"No\")\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi's cake has been eaten by someone. There are three suspects: person 1, person 2, and person 3.\n\nThere are two witnesses, Ringo and Snuke. Ringo remembers that person A is not the culprit, and Snuke remembers that person B is not the culprit.\n\nDetermine if the culprit can be uniquely identified based on the memories of the two witnesses. If the culprit can be identified, print the person's number.\n\n**Constraints**\n\n- 1 \u2264 A, B \u2264 3\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nA B\n```\n\n**Output**\n\nIf the culprit can be uniquely identified based on the memories of the two witnesses, print the person's number; otherwise, print `-1`.\n\n**Sample Input 1**\n\n```\n1 2\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\nFrom the memories of the two witnesses, it can be determined that person 3 is the culprit.\n\n**Sample Input 2**\n\n```\n1 1\n```\n\n**Sample Output 2**\n\n```\n-1\n```\n\nFrom the memories of the two witnesses, it cannot be determined whether person 2 or person 3 is the culprit. Therefore, print `-1`.\n\n**Sample Input 3**\n\n```\n3 1\n```\n\n**Sample Output 3**\n\n```\n2\n```\n\nSolution:\n\n        \n        [BEGIN TEXT]\n        Here is the cleaned version of the relevant solution: \n\nIf \\(A=B\\), the answer is -1. If \\(A\\neq B\\), print the one of \\(1,2,3\\) that is not \\(A\\) nor \\(B\\). There are six possible conditions when \\(A\\neq B\\):\n\n```python\nA, B = map(int, input().split())\nif A == B:\n    print(-1)\nelif A == 1 and B == 2 or A == 2 and B == 1:\n    print(3)\nelif A == 1 and B == 3 or A == 3 and B == 1:\n    print(2)\nelif A == 2 and B == 3 or A == 3 and B == 2:\n    print(1)\n```\n\nAlternatively, use properties of \\(A, B, C\\):\n\n\\(C=6-A-B\\)\n\n```python\nA, B = map(int, input().split())\nif A == B:\n    print(-1)\nelse:\n    print(6 - A - B)\n```\n\n\\(C=A\\oplus B\\) (\\(\\oplus\\) is XOR):\n\n```python\nA, B = map(int, input().split())\nif A == B:\n    print(-1)\nelse:\n    print(A ^ B)\n```\n\nOr use a set to reduce conditional branches:\n\n```python\nA, B = map(int, input().split())\nS = set([1, 2, 3])\nS.discard(A)\nS.discard(B)\n\nif len(S) == 1:\n    print(S.pop())\nelse:\n    print(-1)\n```\n        [END TEXT]\n        \n \n\n", "problem_ids": ["abc368_b", "abc355_b", "abc355_a"]}, "abc309_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere is a directed graph with \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) and \\( N \\) edges. The out-degree of every vertex is \\( 1 \\), and the edge from vertex \\( i \\) points to vertex \\( a_i \\). Count the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\).\n\nHere, vertex \\( v \\) is reachable from vertex \\( u \\) if there exists a sequence of vertices \\( w_0, w_1, \\ldots, w_K \\) of length \\( K+1 \\) that satisfies the following conditions. In particular, if \\( u = v \\), it is always reachable:\n- \\( w_0 = u \\).\n- \\( w_K = v \\).\n- For every \\( 0 \\leq i < K \\), there is an edge from vertex \\( w_i \\) to vertex \\( w_{i+1} \\).\n\n### Constraints\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n\n```\nN\na_1 a_2 \\ldots a_N\n```\n\n### Output\nPrint the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\).\n\n### Sample Input 1\n```\n4\n2 1 1 4\n```\n\n### Sample Output 1\n```\n8\n```\n\n**Explanation:**\n\n- The vertices reachable from vertex \\( 1 \\) are vertices \\( 1, 2 \\).\n- The vertices reachable from vertex \\( 2 \\) are vertices \\( 1, 2 \\).\n- The vertices reachable from vertex \\( 3 \\) are vertices \\( 1, 2, 3 \\).\n- The vertex reachable from vertex \\( 4 \\) is vertex \\( 4 \\).\n\nTherefore, the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\) is \\( 8 \\).\n\nNote that the edge from vertex \\( 4 \\) is a self-loop, that is, it points to vertex \\( 4 \\) itself.\n\n### Sample Input 2\n```\n5\n2 4 3 1 2\n```\n\n### Sample Output 2\n```\n14\n```\n\n### Sample Input 3\n```\n10\n6 10 4 1 5 9 8 6 5 1\n```\n\n### Sample Output 3\n```\n41\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial discusses a problem involving a functional graph, a common topic in competitive programming. A functional graph consists of connected components, each having exactly one cycle. The solution involves examining each connected component with a cycle and directed trees attached. For any vertex \\(u\\), all reachable vertices are either ancestors of \\(u\\) within its directed tree or part of the cycle that includes the root of this tree. To compute the reachable vertices, you should determine the depth of \\(u\\) in its directed tree and the number of vertices in the cycle using graph search algorithms like DFS. The algorithm's complexity is \\(\\mathrm{O}(N)\\), or alternatively, the SCC algorithm can be used.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\). Here, it is guaranteed that \\( 0 \\leq A_i < i \\) for each \\( i \\).\n\nThe **score** and **cost** of a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) are defined as follows:\n\n- The score of \\( P \\) is the length of the longest increasing subsequence of \\( P \\).\n- The cost of \\( P \\) is the number of integers \\( i \\) (\\( 1 \\leq i \\leq N \\)) that satisfy the following condition:\n  - There are fewer than \\( A_i \\) integers \\( j \\) such that \\( j < i \\) and \\( P_j > P_i \\).\n\nFor each \\( k = 1, 2, \\ldots, N \\), solve the following problem:\n\n- Find the minimum cost of a permutation \\( P \\) whose score is at least \\( k \\).\n\n### Constraints\n- \\( 1 \\leq N \\leq 250,000 \\)\n- \\( 0 \\leq A_i < i \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answers for \\( k = 1, 2, \\ldots, N \\) in this order.\n\n### Sample Input 1\n```\n4\n0 1 2 1\n```\n\n### Sample Output 1\n```\n0 0 1 3\n```\n\nFor each \\( k \\), a solution \\( P \\) is as follows:\n- \\( k=1 \\): If \\( P=(4, 2, 1, 3) \\), then \\( P \\) has the score of \\( 2 \\) and the cost of \\( 0 \\).\n- \\( k=2 \\): If \\( P=(4, 3, 1, 2) \\), then \\( P \\) has the score of \\( 2 \\) and the cost of \\( 0 \\).\n- \\( k=3 \\): If \\( P=(4, 1, 2, 3) \\), then \\( P \\) has the score of \\( 3 \\) and the cost of \\( 1 \\).\n- \\( k=4 \\): If \\( P=(1, 2, 3, 4) \\), then \\( P \\) has the score of \\( 4 \\) and the cost of \\( 3 \\).\n\n### Sample Input 2\n```\n3\n0 0 0\n```\n\n### Sample Output 2\n```\n0 0 0\n```\n\n### Sample Input 3\n```\n5\n0 1 2 3 4\n```\n\n### Sample Output 3\n```\n0 1 2 3 4\n```\n\n### Sample Input 4\n```\n11\n0 0 2 3 4 5 3 7 8 2 10\n```\n\n### Sample Output 4\n```\n0 0 0 1 2 3 4 5 7 8 9\n```\n\nSolution:\n\n```python\n# Consider the maximum score that can be achieved with a cost of 0.\n# Let's define the DP as:\n\n# dp[i][j] = when the order of P_1, ..., P_i is determined optimally,\n# the maximum length of an increasing subsequence ending with the j-th largest value among them.\n\n# Initialize N as the number of elements\nN = ...\n\n# Function to calculate maximum score with cost 0\ndef calculate_max_score(A):\n    dp = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    \n    # Initialize set S with elements from 1 to N\n    S = set(range(1, N + 1))\n    \n    for i in range(1, N + 1):\n        max_value_in_S = max(S)\n        \n        # Remove the maximum element from S not greater than A[i]\n        if max_value_in_S <= A[i - 1]:\n            S.remove(max_value_in_S)\n        \n        # Add i to S\n        S.add(i)\n        \n        # Calculate dp using set S\n        # The LIS length is the maximum value of dp[i]\n        dp[i] = sorted(list(S), reverse=True)\n\n    # Return the maximum LIS length\n    return len(S)\n\n# Assuming paying a cost of 1 allows setting one A_i to 0\n\ndef calculate_with_cost(A):\n    cost = N\n    result = []\n    \n    # Traverse A in descending order\n    for i in range(N, 0, -1):\n        A[i - 1] = 0\n        \n        # Calculate maximum score with new A\n        score = calculate_max_score(A)\n        result.append((cost, score))\n        \n        cost -= 1\n\n    # Return results in ascending order of cost\n    return sorted(result)\n\n# Example usage:\nA = [your_sequence_here]\nmax_score = calculate_max_score(A)\nprint('Maximum Score with cost 0:', max_score)\n\nscores_with_cost = calculate_with_cost(A)\nfor cost, score in scores_with_cost:\n    print(f'Cost: {cost}, Score: {score}')\n    \n# Time complexity is O(N log N)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nFor a positive integer \\( N \\), let \\( V_N \\) be the integer formed by concatenating \\( N \\) exactly \\( N \\) times. More precisely, consider \\( N \\) as a string, concatenate \\( N \\) copies of it, and treat the result as an integer to get \\( V_N \\). For example, \\( V_3 = 333 \\) and \\( V_{10} = 10101010101010101010 \\).\n\nFind the remainder when \\( V_N \\) is divided by \\( 998244353 \\).\n\n**Constraints**:\n- \\( 1 \\leq N \\leq 10^{18} \\)\n- \\( N \\) is an integer.\n\n**Input**:\nThe input is given from Standard Input in the following format:\n```\nN\n```\n\n**Output**:\nPrint the remainder when \\( V_N \\) is divided by \\( 998244353 \\).\n\n**Sample Input 1**:\n```\n5\n```\n\n**Sample Output 1**:\n```\n55555\n```\nThe remainder when \\( V_5 = 55555 \\) is divided by \\( 998244353 \\) is \\( 55555 \\).\n\n**Sample Input 2**:\n```\n9\n```\n\n**Sample Output 2**:\n```\n1755646\n```\nThe remainder when \\( V_9 = 999999999 \\) is divided by \\( 998244353 \\) is \\( 1755646 \\).\n\n**Sample Input 3**:\n```\n10000000000\n```\n\n**Sample Output 3**:\n```\n468086693\n```\nNote that the input may not fit into a 32-bit integer type.\n\nSolution:\n\n```python\nfrom sys import stdin\n\nmod = 998244353\n\ndef modinv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef main():\n    n = int(stdin.readline())\n    x = n\n    r = 1\n\n    while x:\n        x //= 10\n        r *= 10\n\n    r %= mod\n\n    r_pow_n = pow(r, n, mod)\n    inv_r_minus_1 = modinv(r - 1, mod)\n\n    ans = (n * (r_pow_n - 1) * inv_r_minus_1) % mod\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n \n\n", "problem_ids": ["abc357_e", "arc180_e", "abc357_d"]}, "abc309_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given positive integers \\( N \\) and \\( L \\), and a sequence of positive integers \\( A = (A_{1}, A_{2}, \\dots, A_{N}) \\) of length \\( N \\).\n\nFor each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nDetermine if there exists a sequence of \\( L \\) non-negative integers \\( B = (B_{1}, B_{2}, \\dots, B_{L}) \\) such that:\n\n\\[\n\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = A_{i}\n\\]\n\nIf it exists, find the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^{5} \\)\n- \\( 2 \\leq L \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq A_{i} \\leq 2 \\times 10^{5} \\)\n\nAll input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN L\nA_{1} A_{2} \\cdots A_{N}\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain \\(-1\\) if no sequence \\( B \\) satisfies the condition for \\( i = k \\); otherwise, it should contain the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Sample Input 1:**\n\n```\n2 4\n10 5\n```\n\n**Sample Output 1:**\n\n```\n3\n-1\n```\n\n*Explanation*:\n- For \\( A_{1} = 10 \\), if we take \\( B = (1, 0, 2, 3) \\), then \\(\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = 10\\), where \\( \\max(B) = 3 \\). No non-negative integer sequence \\( B \\) satisfies the condition with \\( \\max(B) < 3 \\), so print 3 in the first line.\n- For \\( A_{2} = 5 \\), there is no non-negative integer sequence \\( B \\) that satisfies the condition, so print -1 in the second line.\n\n**Sample Input 2:**\n\n```\n6 8\n167 924 167167 167924 116677 154308\n```\n\n**Sample Output 2:**\n\n```\n11\n58\n10448\n10496\n7293\n9645\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 178\n\nC - Sum of Abs 2 Editorial by evima\n\nIn this explanation, the \u201csum of abs\u201d refers to the following formula: \n\\[\\sum_{j=1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}|\\]\n\nWhen \\(B\\) exists, one \\(B\\) that minimizes \\(\\max(B)\\) satisfies the following two conditions:\n- \\(B\\) is sorted in ascending order.\n- \\(B_{1} = 0\\).\n\nThe sum of abs does not depend on the order of \\(B\\). If all elements of \\(B\\) are positive, subtracting \\(1\\) from all elements can reduce \\(\\max(B)\\) without changing the sum of abs. When \\(B\\) is sorted in ascending order, the sum of abs can be expressed as follows: \n\\[\\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}| = \\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} (B_{k} - B_{j}) =\\sum_{k = 1} ^ {L - 1} k(L - k)(B_{k + 1} - B_{k})\\]\n\nThis transformation is correct because \\(B_{a}-B_{b}=(B_{a}-B_{a-1}) + (B_{a-1}+B_{a-2}) + \\cdots +(B_{b+1}-B_{b})\\) for integers \\(a, b\\) satisfying \\(1\\leq b<a\\leq L\\), and the number of pairs \\((a, b)\\) satisfying \\(b\\leq k\\) and \\(k+1\\leq a\\) is \\(k(L-k)\\).\n\nIf we let \\(C_{k} = B_{k + 1} - B_{k}\\), then when \\(B\\) is sorted in ascending order and \\(B_{1} = 0\\), the following holds:\n- \\(0 \\leq C_{k}\\).\n- The sum of abs is equal to \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}\\).\n- \\(\\displaystyle\\max(B) = B_{L} = \\sum_{k = 1} ^ {L - 1} C_{k}\\).\n\nTherefore, we need to solve the following problem: Determine if there exists a sequence of non-negative integers \\(C\\) of length \\(L - 1\\) such that \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}  = A_{i}\\), and if it exists, find the minimum sum of such \\(C\\).\n\nThis can be solved using dynamic programming in the same manner as the knapsack problem, and it can be computed simultaneously for all \\(i\\). Since \\(C_{k} = 0\\) always holds for \\(k\\) satisfying \\(\\max(A)<k(L-k)\\), our solution has a space complexity of \\(O(\\max(A))\\) and a time complexity of \\(O(N + \\max(A)\\sqrt{\\max(A)})\\).\n\nPython implementation example:\n\n```python\nN, L = map(int, input().split())\nA = list(map(int, input().split()))\n\nM = 2 * 10 ** 5\nINF = 10 ** 9\ndp = [INF] * (M + 1)\ndp[0] = 0\nk = 1\n\nwhile k * (L - k) <= M and k * 2 <= L:\n    w = k * (L - k)\n    for i in range(w, M + 1):\n        dp[i] = min(dp[i], dp[i - w] + 1)\n    k += 1\n\nfor a in A:\n    print(-1 if dp[a] == INF else dp[a])\n``` \n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) people participating in an event, and the transportation cost for the \\( i \\)-th person is \\( A_i \\) yen. Takahashi, the organizer of the event, decided to set a maximum limit \\( x \\) for the transportation subsidy. The subsidy for person \\( i \\) will be \\( \\min(x, A_i) \\) yen. Here, \\( x \\) must be a non-negative integer.\n\nGiven that Takahashi's budget is \\( M \\) yen, and he wants the total transportation subsidy for all \\( N \\) people to be at most \\( M \\) yen, what is the maximum possible value of the subsidy limit \\( x \\)?\n\nIf the subsidy limit can be made infinitely large, report that instead.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^{14} \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_{N}\n```\n\n**Output:**\n\nPrint the maximum value of the subsidy limit \\( x \\) that satisfies the budget condition, as an integer.\n\nIf the subsidy limit can be made infinitely large, print `infinite` instead.\n\n**Sample Input 1:**\n```\n4 8\n1 3 2 4\n```\n\n**Sample Output 1:**\n```\n2\n```\n\n*Explanation:*\n\nIf the subsidy limit is set to 2 yen, the total transportation subsidy for all \\( N \\) people is \\( \\min(2,1) + \\min(2,3) + \\min(2,2) + \\min(2,4) = 7 \\) yen, which is within the budget of 8 yen.\n\nIf the subsidy limit is set to 3 yen, the total transportation subsidy for all \\( N \\) people is \\( \\min(3,1) + \\min(3,3) + \\min(3,2) + \\min(3,4) = 9 \\) yen, which exceeds the budget of 8 yen. Therefore, the maximum possible value of the subsidy limit is 2 yen.\n\n**Sample Input 2:**\n```\n3 20\n5 3 2\n```\n\n**Sample Output 2:**\n```\ninfinite\n```\n\n*Explanation:*\n\nThe subsidy limit can be made infinitely large.\n\n**Sample Input 3:**\n```\n10 23\n2 5 6 5 2 1 7 9 7 2\n```\n\n**Sample Output 3:**\n```\n2\n```\n\nSolution:\n\n```\nToyota Programming Contest 2024#8 (AtCoder Beginner Contest 365) Editorial\n\nC - Transportation Expenses Editorial\n\nFirst, we consider when the answer is infinite. It is infinite when the total sum of \\(A\\) is not greater than \\(M\\), as the total cost required is never greater than \\(M\\). Conversely, if the total sum is greater than \\(M\\), setting the upper bound to the maximum value of \\(A\\) leads to exceeding the budget, so a maximum value exists.\n\nAssuming the answer is not infinite, a technique called binary search is effective for finding the maximum value subject to some condition. Given an upper bound \\(x\\), it can be determined if the total cost exceeds the budget in \\(O(N)\\) time. The number of iterations in the binary search is \\(O(\\log{\\max{A}})\\) because the upper bound of the answer is \\(\\max{A}\\). Therefore, the problem can be solved in \\(O(N\\log{\\max{A}})\\) time.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two strings, \\( S \\) and \\( T \\), consisting of lowercase English letters. Determine if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the following condition is satisfied. Here, \\( |S| \\) denotes the length of the string \\( S \\). Note that \\( w \\) must be less than \\( |S| \\).\n\n- If \\( S \\) is split at every \\( w \\) characters from the beginning, the concatenation of the \\( c \\)-th characters of the substrings of length at least \\( c \\) in order equals \\( T \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters.\n- \\( 1 \\leq |T| \\leq |S| \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nPrint `Yes` if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the condition is satisfied, and `No` otherwise.\n\n**Sample Input 1**\n```\natcoder toe\n```\n\n**Sample Output 1**\n```\nYes\n```\n\nExplanation: If \\( S \\) is split at every two characters, it looks like this:\n```\nat\nco\nde\nr\n```\nThen, the concatenation of the 2nd characters of the substrings of length at least 2 is `toe`, which equals \\( T \\). Thus, print `Yes`.\n\n**Sample Input 2**\n```\nbeginner r\n```\n\n**Sample Output 2**\n```\nNo\n```\n\nExplanation: \\( w = |S| \\) is not allowed, and no pair of integers \\( 1 \\leq c \\leq w < |S| \\) satisfies the condition. Thus, print `No`.\n\n**Sample Input 3**\n```\nverticalreading agh\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        Below is a clean version of the text with only the relevant solution details:\n\nEnumerate all possible \\(c\\) and \\(w\\), and determine if a conforming pair \\(c,w\\) exists. One can construct a string for \\(c\\) and \\(w\\) using a for statement and concatenation of strings. For more details, please refer to the sample code.\n\nSample code (Python 3):\n\n```python\ndef main():\n    s = input().strip()\n    t = input().strip()\n    for w in range(1, len(s)):\n        for c in range(w):\n            now = \"\"\n            for i in range(c, len(s), w):\n                now += s[i]\n            if now == t:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["arc178_c", "abc365_c", "abc360_b"]}, "abc309_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nWe define an infinite sequence of positive integers \\( (a_1, a_2, \\ldots) \\) as \"good\" if and only if it satisfies both of the following conditions:\n1. There exists a finite constant \\( C \\) such that \\( a_n \\leq C \\cdot n \\) for all \\( 1 \\leq n \\).\n2. For all pairs of positive integers \\( (n, m) \\), \\( a_n \\mid a_m \\) if and only if \\( n \\mid m \\). Here, \\( x \\mid y \\) denotes that \\( x \\) divides \\( y \\).\n\nYou are given a positive integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\). Check if there exists a good infinite sequence starting with \\( (A_1, A_2, \\ldots, A_N) \\). You have \\( T \\) test cases to solve.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 5000 \\)\n- \\( 1 \\leq N \\leq 5000 \\)\n- \\( 1 \\leq A_i \\leq 10^{18} \\)\n- The sum of \\( N \\) across the test cases in a single input is at most 5000.\n- All input values are integers.\n\n**Input**\n\nThe input is given from standard input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nFor each test case, if there exists a good infinite sequence starting with \\( (A_1, A_2, \\ldots, A_N) \\), print `Yes`, and otherwise print `No`. In printing `Yes` or `No`, you can output each letter in any case (upper or lower).\n\n**Sample Input 1:**\n\n```\n5\n5\n1 2 3 4 5\n5\n1 4 9 16 25\n5\n1 4 6 8 10\n5\n1 2 4 4 5\n5\n1 2 3 5 4\n```\n\n**Sample Output 1:**\n\n```\nYes\nYes\nYes\nNo\nNo\n```\n\nFor the 1st test case, we can let \\( a_n = n \\) and that satisfies the condition.\n\nSolution:\n\n```\nAtCoder Grand Contest 067 - Editorial for Problem C: Divisibility Homomorphism\n\nClearly, all the \\(f(n)\\) are distinct. Let the primes be \\(p_1,p_2,\\cdots,p_k\\) in ascending order. We prove by induction on \\(k\\) that for all \\(u\\), \\(\\frac{f(p_ku)}{f(u)}\\) contains a prime factor at least \\(p_k\\), while \\(f(p_k^N)=C_k p_k^N\\) for sufficiently large \\(N\\).\n\nThe base is trivial for \\(k=0\\). For the induction step, consider an \\(X\\) with sufficient powers of \\(p_1,p_2,\\cdots,p_{k-1}\\). By \\(\\operatorname{LCM}(f(u),f(X))\\mid f(uX)\\) while \\(f(p_ku)\\nmid f(uX)\\), or \\(\\frac{f(p_ku)}{f(u)}\\nmid \\frac{f(uX)}{f(u)}\\), we know that the LHS contains a prime factor bigger than \\(p_{k-1}\\). We conclude \\(f(p_k^{N+1})\\ge p_kf(p_k^N)\\), and the strict inequality can occur at most \\(\\log_{p_{k+1}/p_k}C\\) times, proving the latter.\n\nAfter the induction, if \\(v_p(x)>v_p(y)\\), then \\(v_p (f(x)) > v_p (f(y))\\); otherwise, we can pick \\(Z\\) with sufficient prime powers of \\(f(x)\\) except \\(p\\), contradicting \\(f(x)|f(yZ)\\) and \\(x\\nmid yZ\\). This condition is sufficient as long as the given numbers don\u2019t contradict divisibility.\n\nFor \\(x\\nmid y\\), considering a prime \\(p\\) with \\(v_p(x)>v_p(y)\\), we conclude that \\(f(x)\\nmid f(y)\\). To make \\(f(x)\\mid f(y)\\) for all \\(x\\mid y\\), construct as follows: for each prime and each \u201clayer\u201d (meaning numbers \\(x\\) with \\(v_p(x)=\\text{Const}\\)), let the power of \\(p\\) be the maximum among its descendants (if the layer is empty, make the power all the same, at the minimal nonexisting integer).\n\nChecking all by brute force works in \\(O(n\\log (\\max a_i)+n \\pi (n))\\) time.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nGiven integers \\(N\\) and \\(M\\), compute the sum \\(\\sum_{k=0}^{N} \\text{popcount}(k \\& M)\\), modulo \\(998244353\\).\n\nHere, \\(\\&\\) represents the bitwise AND operation.\n\n**What is the bitwise AND operation?**\n\nThe result \\(x = a \\& b\\) of the bitwise AND operation between non-negative integers \\(a\\) and \\(b\\) is defined as follows:\n\n- \\(x\\) is the unique non-negative integer that satisfies the following conditions for all non-negative integers \\(k\\):\n  - If the \\(2^k\\) place in the binary representation of \\(a\\) and \\(b\\) are both \\(1\\), then the \\(2^k\\) place in the binary representation of \\(x\\) is \\(1\\).\n  - Otherwise, the \\(2^k\\) place in the binary representation of \\(x\\) is \\(0\\).\n\nFor example, \\(3=11_{(2)}\\) and \\(5=101_{(2)}\\), so \\(3 \\& 5 = 1\\).\n\n**What is popcount?**\n\n\\(\\text{popcount}(x)\\) represents the number of \\(1\\)s in the binary representation of \\(x\\).\n\nFor example, \\(13=1101_{(2)}\\), so \\(\\text{popcount}(13) = 3\\).\n\n**Constraints:**\n\n- \\(N\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n- \\(M\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\n```\n\n**Output:**\n\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 3\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n- \\(\\text{popcount}(0 \\& 3) = 0\\)\n- \\(\\text{popcount}(1 \\& 3) = 1\\)\n- \\(\\text{popcount}(2 \\& 3) = 1\\)\n- \\(\\text{popcount}(3 \\& 3) = 2\\)\n- \\(\\text{popcount}(4 \\& 3) = 0\\)\n\nThe sum of these values is \\(4\\).\n\n**Sample Input 2:**\n```\n0 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\nIt is possible that \\(N = 0\\) or \\(M = 0\\).\n\n**Sample Input 3:**\n```\n1152921504606846975 1152921504606846975\n```\n\n**Sample Output 3:**\n```\n499791890\n```\n\nRemember to compute the result modulo \\(998244353\\).\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial presents the solution to a problem from AtCoder Beginner Contest 356, specifically the \"D - Masked Popcount\" problem. The goal is to compute the sum of set bits in the result of bitwise AND operations between each integer from 0 to N and a given integer M with the following steps:\n\n1. Iterate over each bit position \\( j \\) from 0 to 59.\n2. If the \\( j \\)-th bit of \\( M \\) is set, for each \\( j \\), add to the result the count of integers between 0 and N whose \\( j \\)-th bit is set.\n3. The number of integers with the \\( j \\)-th bit set is calculated by examining ranges defined by powers of two.\n4. During computation, handle overflow by taking results modulo 998244353.\n\nThe solution involves efficiently counting set bits using bit operations and properties of numbers, ensuring accurate summing even under large values.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(N\\) where all elements are between \\(1\\) and \\(2^K - 1\\), inclusive, is called a **good sequence**.\n\nThe **score** of a good sequence \\(A = (A_1, A_2, \\ldots, A_N)\\) is defined as follows:\n- The number of distinct integers that can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) using an integer \\(i\\) between \\(1\\) and \\(N\\), inclusive, and a non-negative integer \\(k\\).\n\nFor example, for \\(A = (3, 5)\\), five integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3,\\) and \\(5\\), so the score is \\(5\\).\n\nFind one good sequence with the maximum score.\n\nFor each input file, you are given \\(T\\) test cases to solve.\n\n### Constraints\n- \\(1 \\leq T \\leq 10^5\\)\n- \\(1 \\leq N \\leq 10^5\\)\n- \\(1 \\leq K \\leq 30\\)\n- The sum of \\(N\\) across the test cases in a single input file is at most \\(2 \\times 10^5\\).\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format. Here, \\(\\text{case}_i\\) denotes the \\(i\\)-th test case.\n\n```\nT\n\\text{case}_1\n\\text{case}_2\n\\vdots\n\\text{case}_T\n```\n\nEach test case is given in the following format:\n```\nN K\n```\n\n### Output\nPrint \\(T\\) lines.\n\nThe \\(i\\)-th line should contain the answer for \\(\\text{case}_i\\).\n\nIf there are multiple good sequences with the maximum score, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n3 3\n7 2\n8 20\n```\n\n### Sample Output 1\n```\n5 6 7\n2 2 3 3 1 3 3\n662933 967505 876482 840117 1035841 651549 543175 781219\n```\n\n**Explanation for the first test case:**\nFor \\(A = (5, 6, 7)\\), seven integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3, 5, 6,\\) and \\(7\\), so its score is \\(7\\). Outputs such as \\(A = (7, 4, 5)\\) and \\(A = (6, 5, 4)\\) would also be accepted.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nB - |{floor(A_i/2^k)}| Editorial by evima\n\nIn this explanation, we assume that indices start from \\(0\\). First, it is unnecessary to include elements less than \\(2^{K-1}\\) in \\(A\\). This is because replacing elements less than \\(2^{K-1}\\) with their double will result in the same or a higher score. Therefore, we can limit the elements of \\(A\\) to be between \\(2^{K-1}\\) and \\(2^K-1\\).\n\n1. When \\(N \\geq 2^{K-1}\\): We can include all elements between \\(2^{K-1}\\) and \\(2^K-1\\) in \\(A\\) and set \\(A_i = \\max(1, 2^K - 1 - i)\\) \\((0 \\le i < N)\\).\n\n2. When \\(N < 2^{K-1}\\): Consider an upper bound of the score. For \\(0 \\le x < K\\), consider the number of elements that appear as \\(\\displaystyle \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) between \\(2^x\\) and \\(2^{x+1}-1\\). For each \\(A_i\\), there is at most one \\(k\\) that satisfies \\(\\displaystyle 2^x \\le \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor < 2^{x+1}\\), so the number of such elements is at most \\(N\\). On the other hand, there are only \\(2^x\\) integers between \\(2^x\\) and \\(2^{x+1}\\), so the number of elements that appear in this range is at most \\(\\min(N, 2^x)\\). Therefore, by summing over all \\(x\\), the score has an upper bound of \\(\\displaystyle 1 + \\sum_{x=0}^{K-1}\\min(N, 2^x)\\).\n\nThis upper bound can always be achieved. Specifically, construct \\(A\\) as follows: Set \\(A_i\\) to the sum of \\(2^{K-1}\\) and the bit-reversal of \\(i\\). \u201cThe bit-reversal of \\(i\\)\u201d means the value obtained by reversing the \\((K-1)\\)-bit binary representation of \\(i\\).\n\nBy implementing the above, we can solve this problem. The time complexity is \\(O(NK)\\) due to the bit-reversal calculation being the bottleneck.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n\n    def bit_reversal(x):\n        return int(bin(x)[2:].zfill(K - 1)[::-1], 2)\n\n    if N >= 2 ** (K - 1):\n        print(*[max(1, 2**K - i - 1) for i in range(N)])\n    else:\n        print(*[2 ** (K - 1) + bit_reversal(i) for i in range(N)])\n```\n\nAdditionally, you can also solve it by constructing from the highest bit downwards.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n    C = [1]\n    for _ in range(1, K):\n        D = [2 * c for c in C] + [2 * c + 1 for c in C]\n        C = D[:N]\n    while len(C) < N:\n        C.append(1)\n    print(*C)\n```\n```\n \n\n", "problem_ids": ["agc067_c", "abc356_d", "arc182_b"]}, "abc309_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi is growing a plant. The height of the plant at the time of germination is \\(0\\,\\mathrm{cm}\\). Each night from the day of germination, considered as day \\(0\\), the height of the plant increases by \\(2^i\\,\\mathrm{cm}\\) on day \\(i\\) (\\(0 \\le i\\)).\n\nTakahashi has a height of \\(H\\,\\mathrm{cm}\\).\n\nEvery morning, Takahashi measures his height against the plant. Find the first day such that the plant's height is strictly greater than Takahashi's height in the morning.\n\n### Constraints\n- \\(1 \\leq H \\leq 10^{9}\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nH\n```\n\n### Output\nPrint an integer representing the first day such that the plant's height is greater than Takahashi's height in the morning.\n\n### Sample Input 1\n```\n54\n```\n\n### Sample Output 1\n```\n6\n```\n**Explanation:** The plant's height in the mornings of days \\(1, 2, 3, 4, 5, 6\\) will be \\(1\\,\\mathrm{cm}, 3\\,\\mathrm{cm}, 7\\,\\mathrm{cm}, 15\\,\\mathrm{cm}, 31\\,\\mathrm{cm}, 63\\,\\mathrm{cm}\\), respectively. The plant becomes taller than Takahashi in the morning of day \\(6\\), so print \\(6\\).\n\n### Sample Input 2\n```\n7\n```\n\n### Sample Output 2\n```\n4\n```\n**Explanation:** The plant's height will be \\(7\\,\\mathrm{cm}\\) in the morning of day \\(3\\) and \\(15\\,\\mathrm{cm}\\) in the morning of day \\(4\\). The plant becomes taller than Takahashi in the morning of day \\(4\\), so print \\(4\\). Note that, in the morning of day \\(3\\), the plant is as tall as Takahashi, but not taller.\n\n### Sample Input 3\n```\n262144\n```\n\n### Sample Output 3\n```\n19\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\n## A - Exponential Plant Editorial\n\nUse a while statement to repeatedly add the delta to the height of the plant until it exceeds Takahashi\u2019s height. This simulation will allow you to solve this problem. Also, the height at day \\(30\\) is \\(1073741823\\, \\mathrm{cm}(> 10^{9}\\, \\mathrm{cm})\\), so just using a while statement to find the daily height is fast enough.\n\n**Sample code (Python):**\n```python\nh=int(input())\nnow=0\nans=0\nwhile now<=h:\n    now+=1<<ans\n    ans+=1\n\nprint(ans)\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree with \\( N \\) vertices. The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally. Additionally, you are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\).\n\nDefine \\( f(i, j) \\) as follows:\n\n- If \\( A_i = A_j \\), then \\( f(i, j) \\) is the minimum number of edges needed to traverse from vertex \\( i \\) to vertex \\( j \\).\n- If \\( A_i \\neq A_j \\), then \\( f(i, j) = 0 \\).\n\nCalculate the value of the following expression:\n\n\\[\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(i,j)\n\\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- The input graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nu_1 v_1\n...\nu_{N-1} v_{N-1}\nA_1 A_2 ... A_N\n```\n\n**Output**\n\nPrint the computed answer.\n\n**Sample Input 1**\n\n```\n4\n3 4\n4 2\n1 2\n2 1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nExplanation: \\( f(1,4)=2, f(2,3)=2 \\). For all other \\( i, j \\) \\((1 \\leq i < j \\leq N)\\), we have \\( f(i,j)=0 \\), so the answer is \\( 2+2=4 \\).\n\n**Sample Input 2**\n\n```\n8\n8 6\n3 8\n1 4\n7 8\n4 5\n3 4\n8 2\n1 2 2 2 3 1 1 3\n```\n\n**Sample Output 2**\n\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nApplying the centroid decomposition, it is sufficient to find the answer for paths passing through the root. We consider two cases depending on whether the endpoint of the path is the root or not. If it is root, one can naively perform BFS (Breadth-First Search). Otherwise, for each vertex \\(v\\), count how many times the path between vertex \\(v\\) and the root contributes to the answer. Let \\(c_1,\\ldots,c_k\\) be the children of the root, and suppose that vertex \\(v\\) is contained in the subtree \\(c_i\\). Then, the number of times the path between vertex \\(v\\) and the root contributes to the answer is found as (the number of vertices \\(u\\) contained in the current tree such that \\(A_v = A_u\\)) - (the number of vertices \\(u\\) in the subtree \\(c_i\\) such that \\(A_v = A_u\\)). The values required can all be found using a DFS (Depth-First Search), so the problem has been solved.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere is a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i,j)\\) denote the cell at the \\(i\\)-th row from the top and \\(j\\)-th column from the left. There are \\(N\\) coins on this grid, and the \\(i\\)-th coin can be picked up by passing through the cell \\((R_i,C_i)\\).\n\nYour goal is to start from cell \\((1,1)\\), repeatedly move either down or right by one cell, and reach cell \\((H,W)\\) while picking up as many coins as possible.\n\nFind the maximum number of coins you can pick up and one of the paths that achieves this maximum.\n\nConstraints:\n- \\(2 \\leq H, W \\leq 2 \\times 10^5\\)\n- \\(1 \\leq N \\leq \\min(HW-2, 2 \\times 10^5)\\)\n- \\(1 \\leq R_i \\leq H\\)\n- \\(1 \\leq C_i \\leq W\\)\n- \\((R_i, C_i) \\neq (1,1)\\)\n- \\((R_i, C_i) \\neq (H,W)\\)\n- \\((R_i, C_i)\\) are pairwise distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format: \n```\nH W N\nR_1 C_1\nR_2 C_2\n\u22ee\nR_N C_N\n```\n\nOutput:\nPrint two lines.\n- The first line should contain the maximum number of coins you can pick up.\n- The second line should contain one of the paths that achieves this maximum as a string of length \\(H+W-2\\). The \\(i\\)-th character of this string should be `D` if the \\(i\\)-th move is downward, and `R` if it is rightward.\n\nIf there are multiple paths that maximize the number of coins picked up, you may print any of them.\n\nSample Input 1:\n```\n3 4 4\n3 3\n2 1\n2 3\n1 4\n```\n\nSample Output 1:\n```\n3\nDRRDR\n```\nAs shown in the figure above, by moving \\((1,1)\\rightarrow (2,1)\\rightarrow (2,2)\\rightarrow (2,3)\\rightarrow (3,3)\\rightarrow (3,4)\\), you can pick up three coins at \\((2,1),(2,3),(3,3)\\).\n\nSample Input 2:\n```\n2 2 2\n2 1\n1 2\n```\n\nSample Output 2:\n```\n1\nDR\n```\nThe path `RD` is also acceptable.\n\nSample Input 3:\n```\n10 15 8\n2 7\n2 9\n7 9\n10 3\n7 11\n8 12\n9 6\n8 1\n```\n\nSample Output 3:\n```\n5\nDRRRRRRRRDDDDDRRDRDDRRR\n```\n\nSolution:\n\n```\nHere is the cleaned editorial without excess content unrelated to the solution:\n\n---\n\nLet us call the coin that can be collected by passing through square \\((r,c)\\) simply coin \\((r,c)\\). Given \\(k\\) coins \\((r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)\\), one can determine if there is a path that can collect all the coins as follows:\n\nSort the coins in ascending order of \\((r,c)\\). Here, \\((r_i, c_i) < (r_j, c_j) \\Leftrightarrow (r_i < r_j) \\lor (r_i = r_j \\land c_i < c_j)\\). Let \\(((r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k))\\) be the resulting sequence. There exists a path that can collect all the given \\(k\\) coins if and only if \\(c'_1 \\leq c'_2 \\leq \\dots \\leq c'_k\\).\n\nProof: If two coins $i$ and $j$ with $(r_i, c_i) < (r_j, c_j)$ are to be collected, coin $i$ has to be collected first. Thus, the $k$ coins $(r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)$ can be all collected if and only if the $k$ coins $(r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k)$ can be collected **in this order**. Given $(r_i, c_i) < (r_j, c_j)$, we have $(r_i \\leq r_j \\land c_i \\leq c_j) \\Leftrightarrow c_i \\leq c_j$, so the claim above has been shown.\n\nSuppose that the given \\(N\\) coins are sorted in ascending order of \\((r,c)\\). Then, by the fact above, this problem is boiled down to finding a longest (weakly) increasing subsequence (LIS). Given positive integer sequence \\(c=(c_1,c_2,\\dots,c_N)\\), one can find the length of a LIS of \\(c\\) (not its length) by the following famous algorithm:\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\). The length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\).\n\nIntuitively, each \\(d_j\\) manages the smallest last element of a length-\\(j\\) (weakly) increasing subsequence of \\(c_1,c_2,\\dots,c_i\\) (or \\(\\infty\\) if there is no such subsequence). To find an example of LIS instead of its length only, let us modify the algorithm as follows.\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Prepare a length-\\(N\\) sequence \\(\\text{id}\\) and \\(\\text{pre}\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\), and replace \\(\\text{id}_j\\) with \\(i\\). If \\(j > 1\\), replace \\(\\text{pre}_i\\) with \\(\\text{id}_{j-1}\\) too.\n\nThe length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\). Let \\(l\\) be the length of a LIS of \\(c\\). Consider a length-\\(l\\) sequence obtained by applying \\((l-1)\\) times the action \\(i\\mapsto \\text{pre}_i\\) to \\(\\text{id}_l\\), namely \\((\\text{id}_l, \\text{pre}_{\\text{id}_l},\\text{pre}_{\\text{pre}_{\\text{id}_l}},\\dots)\\). The reversal of this sequence is an example of a LIS of \\(c\\).\n\nThe fact that an example of LIS can be indeed obtained using this algorithm can be proved inductively. The complexity of this algorithm is \\(O(N\\log N)\\), same as the original algorithm. (To find the minimum \\(j\\) in step \\(3\\), use binary search.) Thus, the problem has been solved.\n\nSample code (Python3):\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    h, w, n = map(int, sys.stdin.readline().strip().split())\n    coins = []\n    for _ in range(n):\n        r, c = map(int, sys.stdin.readline().strip().split())\n        coins.append((r, c))\n    coins.sort()\n    dp = [float('inf')] * n\n    id_list = [-1] * n\n    pre = [0] * n\n    for i in range(n):\n        it = bisect_right(dp, coins[i][1])\n        dp[it] = coins[i][1]\n        id_list[it] = i\n        pre[i] = id_list[it - 1] if it else -1\n    m = n - 1\n    while id_list[m] == -1:\n        m -= 1\n    path = [(h, w)]\n    now = id_list[m]\n    while now != -1:\n        path.append(coins[now])\n        now = pre[now]\n    path.append((1, 1))\n    path.reverse()\n    s = []\n    for i in range(len(path) - 1):\n        d = path[i + 1][0] - path[i][0]\n        r = path[i + 1][1] - path[i][1]\n        s.append('D' * d + 'R' * r)\n    print(m + 1)\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc354_a", "abc359_g", "abc369_f"]}, "abc309_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n---\n**Problem Statement**\n\nYou are given a directed graph with \\( N \\) vertices and \\( M \\) edges. The \\( j \\)-th directed edge goes from vertex \\( u_j \\) to vertex \\( v_j \\) and has a weight of \\( w_j \\).\n\nFind one way to assign an integer between \\(-10^{18}\\) and \\(10^{18}\\), inclusive, to each vertex such that the following condition is satisfied:\n\n- Let \\( x_i \\) be the value assigned to vertex \\( i \\). For all edges \\( j = 1, 2, \\dots, M \\), it holds that \\( x_{v_j} - x_{u_j} = w_j \\).\n\nIt is guaranteed that at least one such assignment exists for the given input.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq \\min\\{2 \\times 10^5, \\frac{N(N-1)}{2}\\} \\)\n- \\( 1 \\leq u_j, v_j \\leq N \\)\n- \\( u_j \\neq v_j \\)\n- If \\( i \\neq j \\), then \\( (u_i, v_i) \\neq (u_j, v_j) \\) and \\( (u_i, v_i) \\neq (v_j, u_j) \\)\n- \\( |w_j| \\leq 10^9 \\)\n- All input values are integers.\n- There exists at least one assignment satisfying the conditions.\n\n**Input**\n\nThe input is given in the following format:\n\n```\nN M\nu_1 v_1 w_1\nu_2 v_2 w_2\n\u22ee\nu_M v_M w_M\n```\n\n**Output**\n\nLet \\( x_i \\) be the integer written on vertex \\( i \\). Print \\( x_1, x_2, \\dots, x_N \\) in this order, separated by spaces, on a single line. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n\n```\n3 3\n1 2 2\n3 2 3\n1 3 -1\n```\n\n**Sample Output 1**\n\n```\n3 5 2\n```\n\nBy setting \\( x = (3, 5, 2) \\), we have \\( x_2 - x_1 = w_1 = 2 \\), \\( x_2 - x_3 = w_2 = 3 \\), \\( x_3 - x_1 = w_3 = -1 \\), satisfying the conditions. For example, \\( x = (-1, 1, -2) \\) is also a valid answer.\n\n**Sample Input 2**\n\n```\n4 2\n2 1 5\n3 4 -3\n```\n\n**Sample Output 2**\n\n```\n5 0 6 3\n```\n\nFor example, \\( x = (0, -5, 4, 1) \\) and \\( x = (5, 0, 4, 1) \\) are also valid answers.\n\n**Sample Input 3**\n\n```\n5 7\n2 1 18169343\n3 1 307110901\n4 1 130955934\n2 3 -288941558\n2 5 96267410\n5 3 -385208968\n4 3 -176154967\n```\n\n**Sample Output 3**\n\n```\n200401298 182231955 -106709603 69445364 278499365\n```\n\nSolution:\n\n```python\n        For each connected component of the graph, once the value to be written on any vertex in it is fixed, all the values to be written are uniquely determined. This is because, once you determine the value for a vertex, the value for adjacent vertices is also determined in a chain. Thus, the problem can be solved by inspecting vertices one by one, and if the current vertex does not have a value assigned, set an arbitrary value (like 0) to it and determine the values for all the other connected vertices. This kind of process can be implemented as a Depth-First Search (DFS) or Breadth-First Search (BFS). The time complexity is \\(O(N+M)\\).\n\n```python\n# Read the input\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, w))\n    G[v].append((u, -w))\n\nvisited = [False] * N  # Whether the values are determined\nans = [0] * N  # The values to write\nfor i in range(N):\n    # Skip if the value is already determined\n    if visited[i]:\n        continue\n    # Set the value for vertex i to 0, and start searching\n    st = [i]\n    visited[i] = True\n    while st:\n        # Currently at vertex u\n        u = st.pop()\n        # Inspect vertex v adjacent to vertex u\n        for v, w in G[u]:\n            if not visited[v]:\n                # If the value for vertex v is undetermined, determine the value so that it is consistent with that for vertex u\n                visited[v] = True\n                ans[v] = ans[u] + w\n                st.append(v)\nprint(*ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) types of elements numbered \\( 1, 2, \\ldots, N \\). Elements can be combined with each other. When elements \\( i \\) and \\( j \\) are combined, they transform into element \\( A_{i, j} \\) if \\( i \\geq j \\), and into element \\( A_{j, i} \\) if \\( i < j \\).\n\nStarting with element \\( 1 \\), combine it with elements \\( 1, 2, \\ldots, N \\) in this order. Find the final element obtained.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_{i, j} \\leq N \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_{1, 1}\nA_{2, 1} A_{2, 2}\n\\vdots\nA_{N, 1} A_{N, 2} \\ldots A_{N, N}\n```\n\n**Output:**\n\nPrint the number representing the final element obtained.\n\n**Sample Input 1:**\n\n```\n4\n3\n2 4\n3 1 2\n2 1 2 4\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- Combining element 1 with element 1 results in element 3.\n- Combining element 3 with element 2 results in element 1.\n- Combining element 1 with element 3 results in element 3.\n- Combining element 3 with element 4 results in element 2.\n\nTherefore, the value to be printed is 2.\n\n**Sample Input 2:**\n\n```\n5\n5\n5 5\n5 5 5\n5 5 5 5\n5 5 5 5 5\n```\n\n**Sample Output 2:**\n\n```\n5\n```\n\n**Sample Input 3:**\n\n```\n6\n2\n1 5\n1 6 3\n2 6 1 4\n2 1 1 1 6\n5 6 1 2 2 5\n```\n\n**Sample Output 3:**\n\n```\n5\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\n**B - Binary Alchemy Editorial**\n\nSimulate the process of successively synthesizing elements \\(1, 2, \\ldots, N\\) into element \\(1\\) while managing the current index of the element.\n\n```python\ndef main():\n    n = int(input())\n    a = [list(map(lambda x: int(x) - 1, input().split())) + [0] * (n - i - 1) for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if ans >= i:\n            ans = a[ans][i]\n        else:\n            ans = a[i][ans]\n    ans += 1\n    print(ans)\n\nmain()\n```\n\n---\n \n\n", "problem_ids": ["abc373_d", "abc368_c", "abc370_b"]}, "abc310_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a string \\( S \\) consisting of lowercase English letters. You are also given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- A string \\( T_i \\) consisting of lowercase English letters is given. Print the number of substrings of \\( S \\) that equal \\( T_i \\). Two substrings are distinguished if they are taken from different positions, even if they are equal as strings.\n\n**Constraints:**\n\n- \\( 1 \\leq |S| \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq |T_i| \\leq |S| \\)\n- \\( \\displaystyle \\sum_{i=1}^Q |T_i| \\leq 5 \\times 10^5 \\)\n- \\( S \\) and \\( T_i \\) are strings consisting of lowercase English letters.\n- \\( Q \\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nS\nQ\nT_1\nT_2\n...\nT_Q\n```\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n```\nmissisippi\n5\ni\ns\na\nis\nmissisippi\n```\n\n**Sample Output 1:**\n```\n4\n3\n0\n2\n1\n```\n\nLet \\( S[l:r] \\) denote the substring of \\( S \\) from the \\( l \\)-th character through the \\( r \\)-th character.\n\nFor the 1st query, four substrings of \\( S \\) equal `i`: \\( S[2:2], S[5:5], S[7:7], S[10:10] \\).\n\nFor the 2nd query, three substrings of \\( S \\) equal `s`: \\( S[3:3], S[4:4], S[6:6] \\).\n\nFor the 3rd query, no substrings of \\( S \\) match `a`.\n\nFor the 4th query, two substrings of \\( S \\) equal `is`: \\( S[2:3], S[5:6] \\).\n\nFor the 5th query, one substring of \\( S \\) equals `missisippi`: \\( S[1:10] \\).\n\n**Sample Input 2:**\n```\naaaaaa\n6\na\naa\naaa\naaaa\naaaaa\naaaaaa\n```\n\n**Sample Output 2:**\n```\n6\n5\n4\n3\n2\n1\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - Toyota Programming Contest 2024#7\uff08AtCoder Beginner Contest 362\uff09\n\nG - Count Substring Query Editorial\nby en_translator\n\nLet ~ be a character lexicographically larger than any lowercase English letter. The query asks the number of, among \\(S[1:],S[2:],\\ldots,S[N:]\\), the strings with a prefix \\(T\\). Denoting by \\(T'\\) the string \\(T\\) followed by ~, the count equals the number of \\(i\\) with \\(T\\leq S[i:]\\leq T'\\). By precalculating \\(S[1:],S[2:],\\ldots,S[N:]\\) sorted in lexicographical order (as known as the suffix array) and performing a binary search on this sequence, one can find the number of \\(i\\) with \\(T\\leq S[i:]\\leq T'\\) fast. The complexity for the construction of the suffix array and for each query is \\(O(|S|)\\) and \\(O(|T|\\log |S|)\\), respectively.\n\n```python\nfrom atcoder.string import suffix_array\n\nS = input()\nSA = suffix_array(S)\n\ndef binary_search(T):\n    ng, ok = -1, len(S)\n    while ok - ng > 1:\n        mid = (ng + ok) // 2\n        l = SA[mid]\n        if T <= S[l : l + len(T)]:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nQ = int(input())\nfor _ in range(Q):\n    T = input()\n    print(binary_search(T + \"~\") - binary_search(T))\n```\n\n(Bonus) A standard feature of a language may help implement it concisely.\n```python\nfrom atcoder.string import suffix_array\nimport bisect\n\nS = input()\nSA = suffix_array(S)\n\nQ = int(input())\nfor _ in range(Q):\n    T = input()\n    l = bisect.bisect_left(SA, T, key=lambda x: S[x : x + len(T)])\n    r = bisect.bisect(SA, T, key=lambda x: S[x : x + len(T)])\n    print(r - l)\n```\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere are \\( N \\) people, numbered from 1 to \\( N \\). A competition was held among these \\( N \\) people, and they were ranked accordingly. The following information is given about their ranks:\n\n1. Each person has a unique rank.\n2. For each \\( 1 \\leq i \\leq M \\), if person \\( A_i \\) is ranked \\( x \\)-th and person \\( B_i \\) is ranked \\( y \\)-th, then \\( x - y = C_i \\).\n\nThe given input guarantees that there is at least one possible ranking that does not contradict the given information.\n\nYou need to answer \\( N \\) queries. The answer to the \\( i \\)-th query is determined as follows:\n- If the rank of person \\( i \\) can be uniquely determined, return that rank.\n- Otherwise, return \\(-1\\).\n\n### Constraints\n- \\( 2 \\leq N \\leq 16 \\)\n- \\( 0 \\leq M \\leq \\frac{N(N - 1)}{2} \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq N - 1 \\)\n- \\( (A_i, B_i) \\neq (A_j, B_j) \\) if \\( i \\neq j \\)\n- All input values are integers\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n### Output\nPrint the answers to the \\( 1 \\)-st, \\( 2 \\)-nd, ..., \\( N \\)-th queries in this order, separated by spaces.\n\n### Sample Input 1\n```\n5 2\n2 3 3\n5 4 3\n```\n\n### Sample Output 1\n```\n3 -1 -1 -1 -1\n```\n\nExplanation: Let \\( X_i \\) be the rank of person \\( i \\). The possible rankings could be \\( (3, 4, 1, 2, 5) \\) or \\( (3, 5, 2, 1, 4) \\). Therefore, only the rank of person 1 is uniquely determined as 3.\n\n### Sample Input 2\n```\n3 0\n```\n\n### Sample Output 2\n```\n-1 -1 -1\n```\n\n### Sample Input 3\n```\n8 5\n6 7 3\n8 1 7\n4 5 1\n7 2 1\n6 2 4\n```\n\n### Sample Output 3\n```\n1 -1 -1 -1 -1 -1 -1 8\n```\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 352\n\nConsider a \\(N\\)-vertex \\(M\\)-edge graph whose \\(i\\)-th edge connects vertex \\(A_i\\) and vertex \\(B_i\\). By the constraints, we can take an integer sequence \\(D = (D_1, D_2, \\ldots, D_N)\\) such that \\(D_{A_i} - D_{B_i} = C_i\\) for each \\(i\\). This sequence can be obtained by appropriately performing DFS (Depth-First Search) or BFS (Breadth-First Search) on the graph defined above. The sequence of person \\(i\\)\u2019s rank \\(X_i\\), collectively written as \\(X = (X_1, X_2, \\ldots, X_N)\\), is limited to permutations of \\((1,2,\\ldots, N)\\) such that:\n\n\\(X_i = D_i + v\\), where \\(v\\) is an arbitrary integer taken for each connected component and \\(i\\) is any of the vertices in it.\n\nWe try to respond to the query per connected component. When finding the answer to the \\(i\\)-th query, we perform a bit DP (Dynamic Programming) that places connected components not containing vertex \\(i\\). Specifically, maintain boolean values \\(dp_{x,y}\\) that represent whether the vertices in the first \\(x\\) connected components may correspond to the set of ranks \\(y\\). Since there are \\(O(N)\\) pairs of possible tuples of rank for each connected component, the DP above costs \\(O(N^2 2^N)\\) time naively, or \\(O(N 2^N)\\) time if you use the property that the value of \\(x\\) uniquely determines the popcount of \\(y\\). Therefore, the problem has been solved in a total of \\(O(N^2 2^N)\\) time.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Kingdom of AtCoder has \\( N \\) towns numbered from 1 to \\( N \\). To move from town \\( i \\) to town \\( j \\), you must pay a toll of \\( C \\times |i-j| \\) yen. Takahashi, a merchant, is considering participating in zero or more of \\( M \\) upcoming markets. The \\( i \\)-th market (\\( 1 \\leq i \\leq M \\)) is described by the pair of integers \\((T_i, P_i)\\), where the market is held in town \\( T_i \\) and he will earn \\( P_i \\) yen if he participates.\n\nFor all \\( 1 \\leq i < M \\), the \\( i \\)-th market ends before the \\((i+1)\\)-th market begins. The time it takes for him to move is negligible. He starts with \\( 10^{10^{100}} \\) yen and is initially in town 1. \n\nDetermine the maximum profit he can make by optimally choosing which markets to participate in and how to move. Formally, let \\( 10^{10^{100}} + X \\) be his final amount of money if he maximizes the amount of money he has after the \\( M \\) markets. Find \\( X \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq T_i \\leq N \\) (for \\( 1 \\leq i \\leq M \\))\n- \\( 1 \\leq P_i \\leq 10^{13} \\) (for \\( 1 \\leq i \\leq M \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN C\nM\nT_1 P_1\nT_2 P_2\n...\nT_M P_M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n6 3\n4\n5 30\n2 10\n4 25\n2 15\n```\n\n**Sample Output 1**\n\n```\n49\n```\n\n**Explanation for Sample 1**\n\nFor example, Takahashi can increase his money by 49 yen by acting as follows:\n- Move to town 5. His money becomes \\( 10^{10^{100}} - 12 \\) yen.\n- Participate in the first market. His money becomes \\( 10^{10^{100}} + 18 \\) yen.\n- Move to town 4. His money becomes \\( 10^{10^{100}} + 15 \\) yen.\n- Participate in the third market. His money becomes \\( 10^{10^{100}} + 40 \\) yen.\n- Move to town 2. His money becomes \\( 10^{10^{100}} + 34 \\) yen.\n- Participate in the fourth market. His money becomes \\( 10^{10^{100}} + 49 \\) yen.\n\nIt is impossible to increase his money to \\( 10^{10^{100}} + 50 \\) yen or more, so print 49.\n\n**Sample Input 2**\n\n```\n6 1000000000\n4\n5 30\n2 10\n4 25\n2 15\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Explanation for Sample 2**\n\nThe toll fee is so high that it is optimal for him not to move from town 1.\n\n**Sample Input 3**\n\n```\n50 10\n15\n37 261\n28 404\n49 582\n19 573\n18 633\n3 332\n31 213\n30 377\n50 783\n17 798\n4 561\n41 871\n15 525\n16 444\n26 453\n```\n\n**Sample Output 3**\n\n```\n5000\n```\n\n**Sample Input 4**\n\n```\n50 1000000000\n15\n30 60541209756\n48 49238708511\n1 73787345006\n24 47221018887\n9 20218773368\n34 40025202486\n14 28286410866\n24 82115648680\n37 62913240066\n14 92020110916\n24 20965327730\n32 67598565422\n39 79828753874\n40 52778306283\n40 67894622518\n```\n\n**Sample Output 4**\n\n```\n606214471001\n```\n\nNote that the output value may exceed the range of a 32-bit integer.\n\nSolution:\n\n```python\n# Python translation of the given C++ code\n\nclass SegmentTree:\n    OP = max\n    ID = 0\n\n    def __init__(self, n):\n        self.n = n\n        self.data = [self.ID] * (2 * n)\n\n    def set(self, p, value):\n        p += self.n\n        self.data[p] = value\n        p //= 2\n        while p > 0:\n            self.data[p] = self.OP(self.data[2 * p], self.data[2 * p + 1])\n            p //= 2\n\n    def prod(self, l, r):\n        l += self.n\n        r += self.n\n        result = self.ID\n        while l < r:\n            if l & 1:\n                result = self.OP(result, self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                result = self.OP(result, self.data[r])\n            l //= 2\n            r //= 2\n        return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    C = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    prefix = SegmentTree(N)\n    suffix = SegmentTree(N)\n    \n    offset = 2000000000000000000\n    \n    prefix.set(0, offset)\n    suffix.set(0, offset)\n    \n    ans = offset\n    \n    for _ in range(M):\n        T = int(data[idx]) - 1\n        idx += 1\n        P = int(data[idx])\n        idx += 1\n        \n        best = max(prefix.prod(0, T + 1) - C * T, suffix.prod(T, N) + C * T) + P\n        \n        ans = max(ans, best)\n        \n        prefix.set(T, best + C * T)\n        suffix.set(T, best - C * T)\n    \n    print(ans - offset)\n\n# The following is necessary since we are translating a full program.\n# In an actual competitive programming setting, you'd want to call main directly.\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc362_g", "abc352_f", "abc353_g"]}, "abc310_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere are \\(N+2\\) cells arranged in a row. Let cell \\(i\\) denote the \\(i\\)-th cell from the left.\n\nThere is one stone placed in each of the cells from cell \\(1\\) to cell \\(N\\).\n\nFor each \\(1 \\leq i \\leq N\\), the stone in cell \\(i\\) is white if \\(S_i\\) is 'W', and black if \\(S_i\\) is 'B'.\n\nCells \\(N+1\\) and \\(N+2\\) are empty.\n\nYou can perform the following operation any number of times (possibly zero):\n\n- Choose a pair of adjacent cells that both contain stones, and move these two stones to the empty two cells while preserving their order.\n\n  More precisely, choose an integer \\(x\\) such that \\(1 \\leq x \\leq N+1\\) and both cells \\(x\\) and \\(x+1\\) contain stones. Let \\(k\\) and \\(k+1\\) be the empty two cells. Move the stones from cells \\(x\\) and \\(x+1\\) to cells \\(k\\) and \\(k+1\\), respectively.\n\nDetermine if it is possible to achieve the following state, and if so, find the minimum number of operations required:\n\n- Each of the cells from cell \\(1\\) to cell \\(N\\) contains one stone, and for each \\(1 \\leq i \\leq N\\), the stone in cell \\(i\\) is white if \\(T_i\\) is 'W', and black if \\(T_i\\) is 'B'.\n\n**Constraints:**\n- \\(2 \\leq N \\leq 14\\)\n- \\(N\\) is an integer.\n- Each of \\(S\\) and \\(T\\) is a string of length \\(N\\) consisting of 'B' and 'W'.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\nT\n```\n\n**Output:**\n\nIf it is possible to achieve the desired state, print the minimum number of operations required. If it is impossible, print `-1`.\n\n**Sample Input 1:**\n```\n6\nBWBWBW\nWWWBBB\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n**Explanation:**\n\nUsing `.` to represent an empty cell, the desired state can be achieved in four operations as follows, which is the minimum:\n- `BWBWBW..`\n- `BW..BWBW`\n- `BWWBB..W`\n- `..WBBBWW`\n- `WWWBBB..`\n\n**Sample Input 2:**\n```\n6\nBBBBBB\nWWWWWW\n```\n\n**Sample Output 2:**\n```\n-1\n```\n\n**Sample Input 3:**\n```\n14\nBBBWBWWWBBWWBW\nWBWWBBWWWBWBBB\n```\n\n**Sample Output 3:**\n```\n7\n```\n\nSolution:\n\n[BEGIN TEXT]\nD - Go Stone Puzzle Editorial\n\nIf \\(S\\) and \\(T\\) have different numbers of W and B, then the answer is No. Assume they are equal. Let \\(W\\) be the number of W and \\(B\\) be the number of B. Since the empty squares are always adjacent, there are \\(\\frac{(N+1)!}{B!W!}=O(\\sqrt{N}2^N)\\) possible states of the cells. (The analysis is omitted here.) The maximum value \\(51480\\) occurs for \\(N=14\\) and \\(B=W=7\\). For each state, there are \\((N-1)\\) possible moves. Since the number of states and moves are small enough, use BFS to solve the problem. The total complexity is expected \\(O(N^{1.5}2^N)\\) using a hash map. Similar problem: 8 puzzle (AOJ).\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThis is an interactive problem where your program interacts with the judge via input and output.\n\nYou are given a positive integer \\(N\\) and integers \\(L\\) and \\(R\\) such that \\(0 \\leq L \\leq R < 2^N\\). The judge has a hidden sequence \\(A = (A_0, A_1, \\dots, A_{2^N-1})\\) consisting of integers between 0 and 99, inclusive.\n\nYour goal is to find the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100. However, you cannot directly know the values of the elements in the sequence \\(A\\). Instead, you can ask the judge the following question:\n\nChoose non-negative integers \\(i\\) and \\(j\\) such that \\(2^i(j+1) \\leq 2^N\\). Let \\(l = 2^i j\\) and \\(r = 2^i (j+1) - 1\\). Ask for the remainder when \\(A_l + A_{l+1} + \\dots + A_r\\) is divided by 100.\n\nLet \\(m\\) be the minimum number of questions required to determine the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100 for any sequence \\(A\\). You need to find this remainder within \\(m\\) questions.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 18\\)\n- \\(0 \\leq L \\leq R \\leq 2^N - 1\\)\n- All input values are integers.\n\n**Input and Output**\n\nThis is an interactive problem.\n\nFirst, read the integers \\(N\\), \\(L\\), and \\(R\\) from Standard Input:\n\n```\nN L R\n```\n\nThen, repeat asking questions until you can determine the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100. Each question should be printed in the following format:\n\n```\n? i j\n```\n\nHere, \\(i\\) and \\(j\\) must satisfy the following constraints:\n\n- \\(i\\) and \\(j\\) are non-negative integers.\n- \\(2^i(j+1) \\leq 2^N\\)\n\nThe response to the question will be given in the following format from Standard Input:\n\n```\nT\n```\n\nHere, \\(T\\) is the answer to the question, which is the remainder when \\(A_l + A_{l+1} + \\dots + A_r\\) is divided by 100, where \\(l = 2^i j\\) and \\(r = 2^i (j+1) - 1\\).\n\nIf \\(i\\) and \\(j\\) do not satisfy the constraints, or if the number of questions exceeds \\(m\\), then \\(T\\) will be -1.\n\nIf the judge returns -1, your program is already considered incorrect. In this case, terminate the program immediately.\n\nOnce you have determined the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100, print the remainder \\(S\\) in the following format and terminate the program immediately:\n\n```\n! S\n```\n\n**Notes**\n\n- At the end of each output, print a newline and flush Standard Output. Otherwise, the verdict may be Time Limit Exceeded (TLE).\n- If your output is malformed or your program exits prematurely, the verdict will be indeterminate.\n- After printing the answer, terminate the program immediately. Otherwise, the verdict will be indeterminate.\n\n**Example**\n\nHere is an example for \\(N=3\\), \\(L=1\\), \\(R=5\\), and \\(A=(31, 41, 59, 26, 53, 58, 97, 93)\\). In this case, \\(m=3\\), so you can ask up to three questions.\n\n**Input**\n```\n3 1 5\n```\n**Output**\n```\n? 0 1\n41\n? 1 1\n85\n? 1 2\n11\n! 37\n```\n\nSolution:\n\n```python\nfrom collections import deque\n\nN, L, R = map(int, input().split())\nn = 1 << N\nedge = [[] for i in range(n + 1)]\nfor i in range(N + 1):\n    for l in range(0, n, 1 << i):\n        r = l + (1 << i)\n        edge[l].append(r)\n        edge[r].append(l)\n\nparent = [None] * (n + 1)\nparent[R + 1] = -1\ndq = deque([R + 1])\nwhile dq:\n    v = dq.popleft()\n    for u in edge[v]:\n        if parent[u] == None:\n            parent[u] = v\n            dq.append(u)\n\nans = 0\nnow = L\nwhile parent[now] != -1:\n    p = parent[now]\n    sgn = 1\n    l, r = now, p\n    if l > r:\n        sgn = -1\n        l, r = r, l\n    i = (r - l).bit_length() - 1\n    j = l >> i\n    print(\"?\", i, j, flush=True)\n    T = int(input())\n    ans += sgn * T\n    now = p\n\nprint(\"!\", ans % 100)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n## Problem Statement\n\nAn election is being held with \\( N \\) candidates numbered \\( 1, 2, \\ldots, N \\). There are \\( K \\) votes, some of which have been counted so far. Up until now, candidate \\( i \\) has received \\( A_i \\) votes.\n\nAfter all ballots are counted, candidate \\( i \\) (\\( 1 \\leq i \\leq N \\)) will be elected if and only if the number of candidates who have received more votes than them is less than \\( M \\). There may be multiple candidates elected.\n\nFor each candidate, find the minimum number of additional votes they need from the remaining ballots to guarantee their victory regardless of how the other candidates receive votes. Formally, solve the following problem for each \\( i = 1,2,\\ldots,N \\).\n\nDetermine if there is a non-negative integer \\( X \\) not exceeding \\( K - \\displaystyle{\\sum_{i=1}^{N}} A_i \\) satisfying the following condition. If it exists, find the minimum possible such integer.\n\n- If candidate \\( i \\) receives \\( X \\) additional votes, then candidate \\( i \\) will always be elected.\n\n### Constraints\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq K \\leq 10^{12} \\)\n- \\( 0 \\leq A_i \\leq 10^{12} \\)\n- \\( \\displaystyle{\\sum_{i=1}^{N} A_i} \\leq K \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nLet \\( C_i \\) be the minimum number of additional votes candidate \\( i \\) needs from the remaining ballots to guarantee their victory regardless of how other candidates receive votes. Print \\( C_1, C_2, \\ldots, C_N \\) separated by spaces.\n\nIf candidate \\( i \\) has already secured their victory, then let \\( C_i = 0 \\). If candidate \\( i \\) cannot secure their victory under any circumstances, then let \\( C_i = -1 \\).\n\n### Sample Input 1\n\n```\n5 2 16\n3 1 4 1 5\n```\n\n### Sample Output 1\n\n```\n2 -1 1 -1 0\n```\n\n14 votes have been counted so far, and 2 votes are left. The \\( C \\) to output is \\((2, -1, 1, -1, 0)\\). For example:\n- Candidate 1 can secure their victory by obtaining 2 more votes, while not by obtaining 1 more vote. Thus, \\( C_1 = 2 \\).\n- Candidate 2 can never (even if they obtain 2 more votes) secure their victory, so \\( C_2 = -1 \\).\n\n### Sample Input 2\n\n```\n12 1 570\n81 62 17 5 5 86 15 7 79 26 6 28\n```\n\n### Sample Output 2\n\n```\n79 89 111 117 117 74 112 116 80 107 117 106\n```\n\nSolution:\n\n```python\nfrom itertools import accumulate\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    rem = k - sum(a)\n\n    if n == m:\n        print(' '.join(['0'] * n))\n        return\n\n    ord = list(range(n))\n    ord.sort(key=lambda i: a[i])\n    b = sorted(a)\n    sumb = [0] + list(accumulate(b))\n\n    ans = [-1] * n\n    for i in range(n):\n        l, r = -1, rem + 1\n        while r - l > 1:\n            mid = (l + r) // 2\n            rid = next((idx for idx, val in enumerate(b) if val >= b[i] + mid + 1), n)\n            lid = n - m - (1 if i >= n - m else 0)\n            cnt = 0\n            if rid > lid:\n                cnt += (rid - lid) * (b[i] + mid + 1) - (sumb[rid] - sumb[lid])\n            if lid <= i < rid:\n                cnt -= 1\n            else:\n                cnt += mid\n            if cnt > rem:\n                r = mid\n            else:\n                l = mid\n        ans[ord[i]] = -1 if l == rem else r\n\n    print(' '.join(map(str, ans)))\n\nmain()\n```\n \n\n", "problem_ids": ["abc361_d", "abc355_e", "abc373_e"]}, "abc310_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nIn the Kingdom of AtCoder, the eldest son is always given the name Taro. No one else is given the name Taro. The eldest son is the earliest born male child in each family.\n\nThere are \\(N\\) families in the Kingdom, and \\(M\\) babies were born. Before the \\(M\\) babies were born, none of the \\(N\\) families had had any babies.\n\nInformation about the babies is given in chronological order of their birth. The \\(i\\)-th baby born was born in family \\(A_i\\), and the baby is male if \\(B_i\\) is \\(M\\), and female if it is \\(F\\).\n\nDetermine for each of the \\(M\\) babies whether the name given is Taro.\n\nConstraints:\n- \\(1 \\leq N, M \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- \\(B_i\\) is \\(M\\) or \\(F\\).\n- All numbers in the input are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\nOutput:\nPrint \\(M\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq M)\\) should contain `Yes` if the name given to the \\(i\\)-th baby is Taro, and `No` otherwise.\n\nSample Input 1:\n```\n2 4\n1 M\n1 M\n2 F\n2 M\n```\n\nSample Output 1:\n```\nYes\nNo\nNo\nYes\n```\n\nExplanation of Sample Output 1:\n- The first baby is the earliest born boy in family 1, so he is named Taro.\n- The second baby is not the earliest born boy in family 1, so he is not named Taro.\n- The third baby is a girl, so she is not named Taro.\n- The fourth baby is the earliest born **boy** in family 2, so he is named Taro. Note that the third baby is also born in family 2, but it is the earliest born boy who is named Taro.\n\nSample Input 2:\n```\n4 7\n2 M\n3 M\n1 F\n4 F\n4 F\n1 F\n2 M\n```\n\nSample Output 2:\n```\nYes\nYes\nNo\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Beginner Contest 371\n\nB - Taro Editorial by en_translator\n\nMaintain a flag to manage whether each family had had Taro already. The flags are initialized with False. Inspect the babies in order. If the baby is a girl, print No, and nothing more is required. If the baby is a boy, check the flag of his family. If the flag is False, print Yes, and set the flag to True. If the flag is already True, print No. The operations so far can be implemented with for statements, if statements, and arrays.\n\nSample code (Python):\n```python\nn, m = map(int, input().split())\ntaro_exist = [False for i in range(n)]\nfor i in range(m):\n    a, b = input().split()\n    a = int(a) - 1\n    if b == 'F' or taro_exist[a]:\n        print('No')\n    else:\n        taro_exist[a] = True\n        print('Yes')\n```\n\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). For each \\( t = 1, 2, \\dots, N \\), determine whether \\( A_t \\) is included in a longest increasing subsequence of \\( A \\).\n\nHere, \\( A_t \\) is included in a longest increasing subsequence of \\( A \\) if and only if the following holds:\n- Let \\( L \\) be the length of a longest increasing subsequence of \\( A \\). There exists a strictly increasing integer sequence \\( i = (i_1, i_2, \\dots, i_L) \\ (i_1 < i_2 < \\dots < i_L) \\), where each element is between \\( 1 \\) and \\( N \\), inclusive, that satisfies all of the following conditions:\n  - \\( A_{i_1} < A_{i_2} < \\dots < A_{i_L} \\).\n  - \\( i_k = t \\) for some \\( k \\ (1 \\leq k \\leq L) \\).\n\nYou are given \\( T \\) test cases; solve each of them.\n\n**What is a longest increasing subsequence?**\n- A subsequence of a sequence \\( A \\) is a sequence that can be derived by extracting some elements from \\( A \\) without changing the order.\n- A longest increasing subsequence of a sequence \\( A \\) is a subsequence of \\( A \\) that is strictly increasing with the greatest possible length.\n\n**Constraints**\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) across all test cases is at most \\( 2 \\times 10^5 \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\nHere, \\(\\mathrm{case}_i\\) represents the input for the \\(i\\)-th case. Each case is given in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\nPrint the answers in the following format:\n```\n\\mathrm{answer}_1\n\\mathrm{answer}_2\n\\vdots\n\\mathrm{answer}_T\n```\nHere, \\(\\mathrm{answer}_i\\) represents the output for the \\(i\\)-th case. For each case, let there be \\( m \\) indices \\( t \\) such that \\( A_t \\) is included in a longest increasing subsequence of \\( A \\), which are \\( i_1, i_2, \\dots, i_m \\) in ascending order. Print these in the following format:\n```\nm\ni_1 i_2 \\cdots i_m\n```\n\n**Sample Input 1**\n```\n1\n5\n2 1 4 5 3\n```\n\n**Sample Output 1**\n```\n4\n1 2 3 4\n```\nOne of the longest increasing subsequences is \\( (2, 4, 5) \\), with a length of 3. Another longest increasing subsequence is \\( (1, 4, 5) \\). However, no longest increasing subsequence includes \\( A_5 \\). Therefore, print \\( 1, 2, 3, 4 \\).\n\n**Sample Input 2**\n```\n2\n6\n2 5 3 4 3 4\n5\n10000 1000 100 1 10\n```\n\n**Sample Output 2**\n```\n5\n1 3 4 5 6\n2\n4 5\n```\n\nSolution:\n\n```\nEditorial - Useless for LIS\n\nGiven a sequence \\( A \\), its Longest Increasing Sequence (LIS) can be found as follows: Apply coordinate compression to assume \\( 1 \\leq A_i \\leq N \\). Use Dynamic Programming (DP) with `dp[i][j]` representing the length of a LIS chosen from the first \\( i \\) elements with the last element \\( j \\). Initialize `dp[0][0] = 0` and `dp[0][1] = dp[0][2] = ... = dp[0][N] = -float('inf')`. The transitions for \\( i = 1, 2, ..., N \\) are:\n\n1. `dp[i][j] = max(dp[i - 1][k] + 1 for k in range(j))` for `j = A[i]`.\n2. `dp[i][j] = dp[i - 1][j]` for `j != A[i]`.\n\nThe length of a LIS is `max(dp[N][k] for k in range(N + 1))`. It is possible to reconstruct a LIS. The complexity can be reduced to \\(O(N \\log N)\\) using a segment tree.\n\nThe DP can be efficiently implemented using pseudocode and a segment tree for segment-max retrieval, which allows LIS length to be obtained in \\(O(N \\log N)\\). Furthermore, by considering constrained LIS lengths `l_i` and `r_i`, and checking if `l_i + r_i - 1 = L`, where `L` is the LIS length, we can address this problem. `l` is found by memorizing DP results, and `r` by reversing the array and applying the same algorithm.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\nYou can perform the following two types of operations zero or more times in any order:\n\n1. Choose a (contiguous) substring \\( ABA \\) in \\( S \\) and replace it with \\( A \\).\n2. Choose a (contiguous) substring \\( BAB \\) in \\( S \\) and replace it with \\( B \\).\n\nFind, modulo \\( 10^9+7 \\), the number of possible strings \\( S \\) after performing the operations.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 250000 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n4\nABAB\n```\n\n**Sample Output 1**\n\n```\n2\n```\n\nThe two possible strings \\( S \\) after the operations are as follows:\n- \\( ABAB \\): This string can be obtained by performing zero operations.\n- \\( AB \\): The 1st to 3rd characters of \\( S=ABAB \\) are \\( ABA \\). Replacing them with \\( A \\) results in \\( S=AB \\).\n\nHere, the 2nd to 4th characters of \\( S=ABAB \\) are \\( BAB \\), so you can also replace them with \\( B \\). Note, however, that the resulting \\( AB \\) does not count multiple times.\n\n**Sample Input 2**\n\n```\n1\nA\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\nNo operations can be performed.\n\n**Sample Input 3**\n\n```\n17\nBBABABAABABAAAABA\n```\n\n**Sample Output 3**\n\n```\n18\n```\n\n**Sample Input 4**\n\n```\n100\nABAABAABABBABAABAABAABABBABBABBABBABBABBABBABBABBABBABBABBABBABAABABAABABBABBABABBABAABAABAABAABA\n```\n\n**Sample Output 4**\n\n```\n415919090\n```\n\nRemember to take the result modulo \\( 10^9+7 \\).\n\nSolution:\n\n```\nIn competitive programming, a well-known technique is using parity to perform inversions. Let\u2019s apply it to this problem. Specifically, let\u2019s invert the characters A and B only at even positions in the input string. Then, the two available operations become:\n\nAAA \u2192 A  \nBBB \u2192 B  \n\nWith this transformation, the solution becomes straightforward. For a contiguous segment of A or B, as long as its length does not become zero, we can reduce the length by 2 each time. For example, if there is a segment AAAAA, the possible final states are AAAAA, AAA, and A: there are three. Therefore, if the length of a segment of consecutive identical characters is L, the number of possible final states for that segment is floor((L+1)/2). For all segments of consecutive identical characters, the final states can be chosen independently. Thus, the product of the above values for all such segments is the answer to this problem.\n```\n \n\n", "problem_ids": ["abc371_b", "abc354_f", "arc180_a"]}, "abc310_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land sells tiles with English letters written on them. Takahashi is thinking of making a nameplate by arranging these tiles in a row.\n\nFind the number, modulo 998244353, of strings consisting of uppercase English letters with a length between 1 and K, inclusive, that satisfy the following conditions:\n\n- For every integer \\(i\\) satisfying \\(1 \\leq i \\leq 26\\), the following holds:\n  - Let \\(a_i\\) be the \\(i\\)-th uppercase English letter in lexicographical order. For example, \\(a_1 = A\\), \\(a_5 = E\\), \\(a_{26} = Z\\).\n  - The number of occurrences of \\(a_i\\) in the string is between 0 and \\(C_i\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq K \\leq 1000\\)\n- \\(0 \\leq C_i \\leq 1000\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nK\nC_1 C_2 \\ldots C_{26}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2\n2 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 1**\n\n```\n10\n```\n\nThe 10 strings that satisfy the conditions are: A, B, C, AA, AB, AC, BA, BC, CA, CB.\n\n**Sample Input 2**\n\n```\n358\n1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 2**\n\n```\n64\n```\n\n**Sample Input 3**\n\n```\n1000\n1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n```\n\n**Sample Output 3**\n\n```\n270274035\n```\n\nSolution:\n\nHere is a concise version of the editorial text:\n\nConsider counting conforming strings for each number of occurrences of z, finding the answer as their sum. Suppose a length-\\(s\\) string has \\(t\\) occurrences of z; there are \\(\\binom{s}{t}\\) ways to determine the positions of z. The other positions form a string of length \\((s-t)\\) without z, where \\(a_i\\) occurs between \\(0\\) and \\(C_i\\) times. Repeat this for letters down to x. Use DP with \\(dp_{i,j}\\) as the number of length-\\(j\\) strings from \\(a_1, a_2, \\ldots, a_i\\) where each \\(a_k\\) occurs between \\(0\\) and \\(C_k\\) times. The formula is \\(dp_{i + 1, j} = \\sum_{k = 0}^{\\min(j, C_{i+1})} dp_{i,j-k} \\binom{j}{k}\\). The answer is \\(\\sum_{j= 1}^{K}dp_{26, j}\\). Precompute binomial coefficients for an \\(O(\\sigma K^2)\\) solution, where \\(\\sigma = 26\\).\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n### Problem Statement\n\nThere is a keyboard with 26 keys arranged on a number line. The arrangement of this keyboard is represented by a string \\( S \\), which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character \\( S_x \\) is located at coordinate \\( x \\) \\((1 \\leq x \\leq 26)\\). Here, \\( S_x \\) denotes the \\( x \\)-th character of \\( S \\).\n\nYou will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key. Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.\n\n### Constraints\n\n- \\( S \\) is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n### Sample Output 1\n```\n25\n```\n\nFrom pressing the key for `A` to pressing the key for `Z`, you need to move your finger 1 unit at a time in the positive direction, resulting in a total traveled distance of 25. It is impossible to press all keys with a total traveled distance less than 25, so print 25.\n\n### Sample Input 2\n```\nMGJYIZDKSBHPVENFLQURTCWOAX\n```\n\n### Sample Output 2\n```\n223\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        For a character \\(c\\), let \\(X_c\\) be the coordinate of the key corresponding to the character \\(c\\). We need to find \\(|X_A-X_B|+|X_B-X_C|+\\ldots+|X_Y-X_Z|\\). If we can find \\(S\\) from \\(X\\), the sought value can be found using a for loop. An array can correspond the integer \\(0\\) to A, \\(1\\) to B, \\(\\ldots\\), and \\(25\\) to Z, so that \\(X\\) can be managed as an array. Alternatively, an associative array with its key as a character type can be used.\n\nSample code in Python3:\n\n```python\ns = input()\nx = [0] * 26\nfor i in range(26):\n    x[ord(s[i]) - ord(\"A\")] = i\nans = 0\nfor i in range(25):\n    ans += abs(x[i] - x[i + 1])\nprint(ans)\n```\n        [END TEXT]\n        \n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 650 points\n\nProblem Statement:\nThere is a special grid with \\( N \\) rows. (\\( N \\) is even.) The \\( i \\)-th row from the top has \\(\\left \\lceil \\frac{i}{2} \\right \\rceil \\times 2\\) cells from the left end. For example, when \\( N = 6 \\), the grid looks like the following:\n\nLet \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Each cell is either an empty cell or a wall cell. There are \\( M \\) wall cells, and the \\( i \\)-th wall cell is \\((a_i, b_i)\\). Here, \\((1, 1)\\) and \\((N, N)\\) are empty.\n\nStarting from \\((1, 1)\\), how many ways are there to reach \\((N, N)\\) by repeatedly moving right or down to an adjacent empty cell? Find the count modulo 998244353.\n\nConstraints:\n- \\( 2 \\leq N \\leq 2.5 \\times 10^5 \\)\n- \\( N \\) is even.\n- \\( 0 \\leq M \\leq 50 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- \\( 1 \\leq b_i \\leq \\left \\lceil \\frac{a_i}{2} \\right \\rceil \\times 2 \\)\n- \\((a_i, b_i) \\neq (1, 1)\\) and \\((a_i, b_i) \\neq (N, N)\\).\n- \\((a_i, b_i) \\neq (a_j, b_j)\\) if \\( i \\neq j \\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\na_1 b_1\na_2 b_2\n...\na_M b_M\n```\n\nOutput:\nPrint the number of ways to reach \\((N, N)\\) from \\((1, 1)\\) by repeatedly moving right or down to an adjacent empty cell, modulo 998244353.\n\nSample Input 1:\n```\n4 2\n2 1\n4 2\n```\nSample Output 1:\n```\n2\n```\nThere are two paths that satisfy the conditions of the problem:\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (3, 4) \\to (4, 4)\\)\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (4, 3) \\to (4, 4)\\)\n\nSample Input 2:\n```\n6 3\n2 1\n3 3\n4 2\n```\nSample Output 2:\n```\n0\n```\n\nSample Input 3:\n```\n100 10\n36 9\n38 5\n38 30\n45 1\n48 40\n71 52\n85 27\n86 52\n92 34\n98 37\n```\nSample Output 3:\n```\n619611437\n```\n\nSample Input 4:\n```\n100000 10\n552 24\n4817 255\n7800 954\n23347 9307\n28028 17652\n39207 11859\n48670 22013\n74678 53158\n75345 45891\n88455 4693\n```\nSample Output 4:\n```\n175892766\n```\n\nSolution:\n\nSure, here is the editorial with all code translated to Python3:\n\n```python\ndef g(a, b):\n    \"\"\"Calculate the number of shortest paths from a to b.\"\"\"\n    # This function implementation depends on the specific grid configuration\n    pass\n\ndef calculate_dp_and_x(wall_squares, grid_size):\n    \"\"\"Calculate dp values and the sought count X using the wall squares.\"\"\"\n    S = wall_squares\n    N, M = grid_size\n    \n    # Initialize dp with base values\n    w = [(1, 1)] + S + [(N, N)]\n    dp = [0] * (len(S) + 2)\n    dp[0] = 1\n    \n    # Fill dp array according to the derived relations\n    for i in range(1, len(S) + 2):\n        dp_i_sum = sum(g(w[j], w[i]) * dp[j] for j in range(i))\n        dp[i] = -dp_i_sum\n    \n    # Calculate the sought count X\n    X = -dp[len(S) + 1]\n    \n    return X\n\n# Example usage\noriginal_wall_squares = []  # Replace with actual coordinates of original wall squares\ncalculate_dp_and_x(original_wall_squares, (N, M))\n```\n\nNote: In the provided code, `g(a, b)` is a placeholder function that needs actual implementation based on the specific problem constraints. The function `calculate_dp_and_x` calculates the dp values and the sought count `X` using the dynamic programming approach described in the editorial.\n \n\n", "problem_ids": ["abc358_e", "abc373_b", "abc357_g"]}, "abc310_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nSnuke is planning to build a maze as a new attraction in AtCoder Land. The maze is represented as a grid with \\( N \\) rows and \\( M \\) columns, with the top edge of the top-right cell being the entrance and the bottom edge of the bottom-right cell being the exit. He will create the maze by appropriately placing walls between adjacent cells.\n\nHe loves simple mazes, so he wants the path from the entrance to the exit to pass through exactly \\( K \\) cells without any branches. Determine if it is possible to create such a maze, and if possible, construct one.\n\nFor example, in the following figure, \\( N = 3 \\) and \\( M = 3 \\), and walls are placed at the solid lines (walls are always placed around the outer perimeter except for the entrance and exit). In this case, the path from the entrance to the exit passes through exactly 7 cells without any branches.\n\n### Formal Statement\n\nThere is a grid with \\( N \\) rows and \\( M \\) columns. Let \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. For each pair of side-adjacent cells, you can decide whether to place a wall between them. Determine whether it is possible to place walls to satisfy the following condition, and if it is possible, construct one such placement.\n\n**Condition**: There exists a simple path with \\( K \\) vertices that connects the two vertices \\((1, M)\\) and \\((N, M)\\), and the connected component containing the vertices \\((1, M)\\) and \\((N, M)\\) consists only of this path.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 100 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 1 \\leq K \\leq NM \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\n```\n\n### Output\n\nIf there is no placement of walls that satisfies the condition, print `No`. Otherwise, print one such placement in the following format. If multiple valid placements exist, any of them can be printed.\n\n**See also the sample outputs below to better understand the complicated output format.**\n\n```\nYes\n+++++ \\dots +++S+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n\\vdots\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+++++ \\dots +++G+\n```\n\nHere, `S`, `G`, `+`, and `o` represent the entrance, exit, a wall, and a cell, respectively, and `?` between cells represents a position where a wall can be placed. Replace `?` between two horizontally adjacent cells with `|` if a wall is placed, and `.` otherwise. Replace `?` between two vertically adjacent cells with `-` if a wall is placed, and `.` otherwise.\n\n**Formal Instruction:**\n\n- The output should consist of \\( 2N+2 \\) lines.\n  - Line 1 should contain the string `Yes`.\n  - Lines 2 to \\( 2N+2 \\) should contain strings of length \\( 2M+1 \\) as described below:\n    - Line 2 should be a concatenation of `+` repeated \\( 2M-1 \\) times, `S`, and `+`, in this order.\n    - Line \\( 1+2i \\) (\\( 1 \\leq i \\leq N \\)) should be a concatenation of `+`, `o`, \\( c_{i,1} \\), `o`, \\( c_{i,2} \\), \\(\\dots\\), \\( c_{i,M-1} \\), `o`, `+`, in this order. Here, \\( c_{i,j} \\) is `|` if a wall is placed between cells \\((i,j)\\) and \\((i,j+1)\\), and `.` otherwise.\n    - Line \\( 2+2i \\) (\\( 1 \\leq i \\leq N-1 \\)) should be a concatenation of `+`, \\( r_{i,1} \\), `+`, \\( r_{i,2} \\), `+`, \\(\\dots\\), `+`, \\( r_{i,M} \\), `+`, in this order. Here, \\( r_{i,j} \\) is `-` if a wall is placed between cells \\((i,j)\\) and \\((i+1,j)\\), and `.` otherwise.\n    - Line \\( 2N+2 \\) should be a concatenation of `+` repeated \\( 2M-1 \\) times, `G`, and `+`, in this order.\n\n### Sample Input 1\n\n```\n3 3 7\n```\n\n### Sample Output 1\n\n```\nYes\n+++++S+\n+o.o.o+\n+.+-+-+\n+o.o.o+\n+-+-+.+\n+o.o|o+\n+++++G+\n```\n\nThis is the same placement of walls as in the figure in the problem statement.\n\n### Sample Input 2\n\n```\n3 3 2\n```\n\n### Sample Output 2\n\n```\nNo\n```\n\n### Sample Input 3\n\n```\n4 1 4\n```\n\n### Sample Output 3\n\n```\nYes\n+S+\n+o+\n+.+\n+o+\n+.+\n+o+\n+.+\n+o+\n+G+\n```\n\nSolution:\n\n```python\n        Editorial - AtCoder Beginner Contest 358\n\nF - Easiest Maze Editorial by en_translator\n\nFor what kind of \\(K\\) does the solution exist? Obviously, \\(K\\geq N\\) is required, considering the length of the shortest path between squares \\((1,M)\\) and \\((N,M)\\). Let's draw the grid in a checkered pattern:\n\nAny path visits red square \\(\\rightarrow\\) blue square \\(\\rightarrow\\) red square \\(\\rightarrow\\dots\\). The color parity of squares \\((1,M)\\) and \\((N,M)\\) depends on \\(N\\). Thus, \\(N\\) and \\(K\\) must have the same parity. If \\(N\\) is even, the path ends with an even number of vertices. If \\(K\\geq N\\) and parities are the same, a solution can always be constructed. Starting from the path of the shortest length \\(N\\), increase the length by \\(2\\) incrementally, as \\(N, N+2, N+4, \\dots\\).\n\nImplement carefully with some casework. Use casework and construction separately. The sample code outlines how to compute the sequence of squares, build walls, and remove those between adjacent squares.\n\nSample code (Python 3):\n```python\ndef main():\n    n, m, k = map(int, input().split())\n    if k < n or k % 2 != n % 2:\n        print(\"No\")\n        return\n    print(\"Yes\")\n    path = []\n    k -= n\n    i = 0\n    while i < n - 1:\n        if i != n - 3:\n            w = 1 + min(m - 1, k // 2)\n            k -= (w - 1) * 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n        elif k <= (m - 1) * 2:\n            w = 1 + k // 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n            path.append((i + 2, m - 1))\n        else:\n            for j in range(m):\n                path.append((i, m - 1 - j))\n            k -= (m - 1) * 2\n            j = 0\n            while j < m:\n                if k:\n                    path.append((i + 1, j))\n                    path.append((i + 2, j))\n                    path.append((i + 2, j + 1))\n                    path.append((i + 1, j + 1))\n                    j += 2\n                    k -= 2\n                else:\n                    path.append((i + 1, j))\n                    j += 1\n            path.append((i + 2, m - 1))\n        i += 2\n    \n    c = [['|' for _ in range(m - 1)] for _ in range(n)]\n    r = [['-' for _ in range(m)] for _ in range(n - 1)]\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i + 1]\n        if x1 == x2:\n            c[x1][min(y1, y2)] = '.'\n        else:\n            r[min(x1, x2)][y1] = '.'\n    \n    print('+' + 'S'.join([''] + ['-' * (2 * m - 1), '+']))\n    for i in range(n):\n        print('+', end='')\n        for j in range(m - 1):\n            print('o' + c[i][j], end='')\n        print(\"o+\")\n        if i < n - 1:\n            for j in range(m):\n                print('+' + r[i][j], end='')\n            print('+')\n    print('+' + 'G'.join([''] + ['-' * (2 * m - 1), '+']))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) boxes numbered from 1 to \\( N \\) and \\( N \\) items also numbered from 1 to \\( N \\). Item \\( i \\) (\\( 1 \\leq i \\leq N \\)) is located in box \\( A_i \\) and has a weight of \\( W_i \\).\n\nYou can repeatedly perform the operation of selecting an item and moving it to another box. The cost of moving an item with weight \\( w \\) is \\( w \\).\n\nFind the minimum total cost required to ensure that each box contains exactly one item.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\) (\\( 1 \\leq i \\leq N \\))\n- \\( 1 \\leq W_i \\leq 10^4 \\) (\\( 1 \\leq i \\leq N \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given in the following format from Standard Input:\n```\nN\nA_1 A_2 \\ldots A_N\nW_1 W_2 \\ldots W_N\n```\n\n**Output**\n\nPrint the minimum total cost required to make each box contain exactly one item.\n\n**Sample Input 1**\n```\n5\n2 2 3 3 5\n33 40 2 12 16\n```\n\n**Sample Output 1**\n```\n35\n```\n\n*Explanation*: With the following two moves, you can make each box contain exactly one item:\n1. Move item 1 from box 2 to box 1. The cost is 33.\n2. Move item 3 from box 3 to box 4. The cost is 2.\n\nThe total cost of these two moves is 35. It is impossible to make each box contain exactly one item with a cost less than 35, so print 35.\n\n**Sample Input 2**\n```\n12\n3 6 7 4 12 4 8 11 11 1 8 11\n3925 9785 9752 3587 4013 1117 3937 7045 6437 6208 3391 6309\n```\n\n**Sample Output 2**\n```\n17254\n```\n\n\nSolution:\n\n```python\n# Python3 translation of the given C++ code\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n\n    max_weight = [0] * n\n    for i in range(n):\n        a[i] -= 1\n        max_weight[a[i]] = max(max_weight[a[i]], w[i])\n\n    sum_w = sum(w)\n    sum_max = sum(max_weight)\n    print(sum_w - sum_max)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 800 points\n\nProblem Statement: For positive integers \\(h\\) and \\(w\\), let \\((h, w)\\) denote a rectangle with height \\(h\\) and width \\(w\\). In this problem, rectangles are not considered to be rotatable, thus the rectangles \\((h, w)\\) and \\((w, h)\\) are considered different if \\(h \\neq w\\).\n\nA sequence of rectangles \\(((h_1, w_1), (h_2, w_2), \\dots, (h_n, w_n))\\) is called a **rectangle generation sequence** if there is a method that successfully follows the steps below:\n\n1. Let the rectangle \\(X\\) be \\((h_1, w_1)\\). Hereafter, let \\(H\\) and \\(W\\) denote the height and width of the rectangle \\(X\\) at each step.\n2. For \\(i = 2, 3, \\dots, n\\), perform one of the following operations. If neither can be performed, the procedure terminates unsuccessfully:\n   - If the height of \\(X\\) is equal to \\(h_i\\), attach the rectangle \\((h_i, w_i)\\) horizontally to \\(X\\). Formally, if \\(H = h_i\\) at that time, replace \\(X\\) with the rectangle \\((H, W + w_i)\\).\n   - If the width of \\(X\\) is equal to \\(w_i\\), attach the rectangle \\((h_i, w_i)\\) vertically to \\(X\\). Formally, if \\(W = w_i\\) at that time, replace \\(X\\) with the rectangle \\((H + h_i, W)\\).\n3. If the above series of operations does not fail, the procedure terminates successfully.\n\nYou are given \\(N\\) rectangles. The \\(i\\)-th rectangle has a height of \\(H_i\\) and a width of \\(W_i\\).\n\nFind the number of pairs of positive integers \\((l, r)\\) that satisfy \\(1 \\le l \\le r \\le N\\) and the following condition:\n\n- The sequence of rectangles \\(((H_l, W_l), (H_{l+1}, W_{l+1}), \\dots, (H_r, W_r))\\) is a rectangle generation sequence.\n\nConstraints:\n- \\(1 \\leq N \\leq 3 \\times 10^5\\)\n- \\(1 \\leq H_i, W_i \\leq 10^6\\)\n- All input values are integers.\n\nInput: The input is given from Standard Input in the following format:\n```\nN\nH_1 W_1\nH_2 W_2\n...\nH_N W_N\n```\n\nOutput: Print the answer.\n\nSample Input 1:\n```\n4\n1 2\n1 3\n2 3\n3 1\n```\n\nSample Output 1:\n```\n7\n```\nThe pairs \\((l, r)\\) that satisfy the condition are \\((1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (4, 4)\\); there are seven. For example, for \\((l, r) = (2, 4)\\), the procedure succeeds if the first attachment is done vertically and the second is done horizontally.\n\nSample Input 2:\n```\n5\n2 1\n2 1\n1 2\n3 2\n1 4\n```\n\nSample Output 2:\n```\n10\n```\n\nSample Input 3:\n```\n1\n1000000 1000000\n```\n\nSample Output 3:\n```\n1\n```\n\nSample Input 4:\n```\n10\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\nSample Output 4:\n```\n55\n```\n\nSolution:\n\n[BEGIN TEXT]\nObservation of Combining Rectangles: Let\u2019s consider combining rectangles consecutively. Starting from \\((h_1, w_1)\\), we combine \\((h_2, w_2)\\), and then continue to combine \\((h_3, w_3)\\). The condition is that if \\((h_2, w_2)\\) can be combined vertically/horizontally, then \\((h_3, w_3)\\) can also be combined similarly. For example, when \\(h_2 = h_3\\), if \\((h_2, w_2)\\) can be combined horizontally, then \\((h_3, w_3)\\) can also be combined horizontally. Similarly, when \\(w_2 = w_3\\), if \\((h_2, w_2)\\) can be combined vertically, then \\((h_3, w_3)\\) can also be combined vertically. \n\nCorrespondence to Graph and Counting: Let\u2019s count the number of pairs \\((l, r)\\) that satisfy the condition. When \\(l\\) is fixed, whether \\((l, r)\\) satisfies the condition is monotonic with respect to \\(r\\). For the orientation of the combination of two consecutive rectangles, we can determine whether the latter can be combined if the former can be combined. Represent this information in a graph with \\(2 \\times N\\) vertices.\n\nFor \\(i = 1, 2, \\dots, N\\), let vertex \\(i\\) represent that \\((H_i, W_i)\\) can be combined vertically, and vertex \\(N + i\\) represent that \\((H_i, W_i)\\) can be combined horizontally. For \\(i = 2, 3, \\dots, N\\):\n\n- If \\((H_{i-1}, W_{i-1})\\) can be combined vertically, and \\((H_i, W_i)\\) can also be combined vertically, span an edge between vertices \\(i-1\\) and \\(i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined vertically, and \\((H_i, W_i)\\) can be combined horizontally, span an edge between vertices \\(i-1\\) and \\(N + i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined horizontally, and \\((H_i, W_i)\\) can be combined vertically, span an edge between vertices \\(N + i - 1\\) and \\(i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined horizontally, and \\((H_i, W_i)\\) can be combined horizontally, span an edge between vertices \\(N + i - 1\\) and \\(N + i\\).\n\nAssume that \\((H_l, W_l)\\) can be combined both horizontally and vertically. Then, \\((l, r)\\) satisfies the condition if and only if either vertex \\(l\\) or \\(N + l\\) is connected to either vertex \\(r\\) or \\(N + r\\). Edges corresponding to combinations with different orientations will be spanned for at most one \\(l\\). Edges corresponding to combinations with the same orientation will be spanned for any \\(l\\) if they are initially spanned.\n\nRepresent the edges of the graph as a \\(2 \\times 2\\) matrix and load it on a segment tree. By performing binary search on the segment tree to find the maximum \\(r\\) that satisfies the condition, and updating the graph with segment tree updates, we process all \\(l\\) in \\(\\mathrm{O}(N \\log N)\\) time complexity.\n[END TEXT]\n \n\n", "problem_ids": ["abc358_f", "abc360_c", "arc179_e"]}, "abc310_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given simple undirected graphs \\( G \\) and \\( H \\), each with \\( N \\) vertices: vertices \\( 1, 2, \\ldots, N \\). Graph \\( G \\) has \\( M_G \\) edges, and its \\( i \\)-th edge (\\( 1 \\leq i \\leq M_G \\)) connects vertices \\( u_i \\) and \\( v_i \\). Graph \\( H \\) has \\( M_H \\) edges, and its \\( i \\)-th edge (\\( 1 \\leq i \\leq M_H \\)) connects vertices \\( a_i \\) and \\( b_i \\).\n\nYou can perform the following operation on graph \\( H \\) any number of times, possibly zero:\n- Choose a pair of integers \\( (i, j) \\) satisfying \\( 1 \\leq i < j \\leq N \\). Pay \\( A_{i,j} \\) yen, and if there is no edge between vertices \\( i \\) and \\( j \\) in \\( H \\), add one; if there is, remove it.\n\nFind the minimum total cost required to make \\( G \\) and \\( H \\) isomorphic.\n\n**What is a simple undirected graph?**\nA **simple undirected graph** is a graph without self-loops or multi-edges, where edges have no direction.\n\n**What does it mean for graphs to be isomorphic?**\nTwo graphs \\( G \\) and \\( H \\) with \\( N \\) vertices are **isomorphic** if and only if there exists a permutation \\( (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) such that for all \\( 1 \\leq i < j \\leq N \\):\n- an edge exists between vertices \\( i \\) and \\( j \\) in \\( G \\) if and only if an edge exists between vertices \\( P_i \\) and \\( P_j \\) in \\( H \\).\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 8 \\)\n- \\( 0 \\leq M_G \\leq \\frac{N(N-1)}{2} \\)\n- \\( 0 \\leq M_H \\leq \\frac{N(N-1)}{2} \\)\n- \\( 1 \\leq u_i < v_i \\leq N \\) for \\( 1 \\leq i \\leq M_G \\)\n- \\( (u_i, v_i) \\neq (u_j, v_j) \\) for \\( 1 \\leq i < j \\leq M_G \\)\n- \\( 1 \\leq a_i < b_i \\leq N \\) for \\( 1 \\leq i \\leq M_H \\)\n- \\( (a_i, b_i) \\neq (a_j, b_j) \\) for \\( 1 \\leq i < j \\leq M_H \\)\n- \\( 1 \\leq A_{i,j} \\leq 10^6 \\) for \\( 1 \\leq i < j \\leq N \\)\n\nAll input values are integers.\n\n**Input Format:**\nThe input is given from Standard Input in the following format:\n```\nN\nM_G\nu_1 v_1\nu_2 v_2\n...\nu_{M_G} v_{M_G}\nM_H\na_1 b_1\na_2 b_2\n...\na_{M_H} b_{M_H}\nA_{1,2} A_{1,3} ... A_{1,N}\nA_{2,3} ... A_{2,N}\n...\nA_{N-1,N}\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n5\n4\n1 2\n2 3\n3 4\n4 5\n4\n1 2\n1 3\n1 4\n1 5\n3 1 4 1\n5 9 2\n6 5\n3\n```\n\n**Sample Output 1:**\n```\n9\n```\n\n*Explanation for Sample Input 1:*\nThe given graphs are as follows:\nFor example, you can perform the following four operations on \\( H \\) to make it isomorphic to \\( G \\) at a cost of 9 yen.\n1. Choose \\( (i, j) = (1, 3) \\). There is an edge between vertices 1 and 3 in \\( H \\), so pay 1 yen to remove it.\n2. Choose \\( (i, j) = (2, 5) \\). There is no edge between vertices 2 and 5 in \\( H \\), so pay 2 yen to add it.\n3. Choose \\( (i, j) = (1, 5) \\). There is an edge between vertices 1 and 5 in \\( H \\), so pay 1 yen to remove it.\n4. Choose \\( (i, j) = (3, 5) \\). There is no edge between vertices 3 and 5 in \\( H \\), so pay 5 yen to add it.\n\nAfter these operations, \\( H \\) becomes isomorphic to \\( G \\). You cannot make \\( G \\) and \\( H \\) isomorphic at a cost less than 9 yen, so print 9.\n\nSolution:\n\n```python\n# Python3 translation of the given C++ code\n\nimport itertools\n\ndef main():\n    # Read number of vertices\n    N = int(input().strip())\n\n    # Set of edges in graphs G and H\n    edges_G, edges_H = set(), set()\n\n    # Read edges of graph G\n    M_G = int(input().strip())\n    for _ in range(M_G):\n        u, v = map(int, input().strip().split())\n        edges_G.add((u - 1, v - 1))\n        edges_G.add((v - 1, u - 1))  # Add reverse edge also\n\n    # Read edges of graph H\n    M_H = int(input().strip())\n    for _ in range(M_H):\n        a, b = map(int, input().strip().split())\n        edges_H.add((a - 1, b - 1))\n        edges_H.add((b - 1, a - 1))  # Add reverse edge also\n\n    # Read cost matrix A\n    A = [list(map(int, input().strip().split())) for _ in range(N)]\n\n    # Cost matrix is symmetric\n    for i in range(N):\n        for j in range(i + 1, N):\n            A[j][i] = A[i][j]\n\n    # Permutation that associates vertices of H to those of G\n    P = list(range(N))\n    ans = 28000000  # Initial answer is a large number\n\n    # Enumerate all permutations using itertools.permutations\n    for perm in itertools.permutations(P):\n        sum_ = 0\n        for i in range(N):\n            for j in range(i):\n                # Check the edges and calculate the cost\n                if (edges_H.__contains__((i, j))) != (edges_G.__contains__((perm[i], perm[j]))):\n                    sum_ += A[i][j]\n        # Update the minimum value\n        ans = min(ans, sum_)\n\n    print(ans)\n\nmain()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi will encounter \\( N \\) monsters in order. The \\( i \\)-th monster \\((1 \\leq i \\leq N)\\) has a strength of \\( A_i \\).\n\nFor each monster, he can choose to either let it go or defeat it. Each action awards him experience points as follows:\n- If he lets a monster go, he gains 0 experience points.\n- If he defeats a monster with strength \\( X \\), he gains \\( X \\) experience points. If it is an even-numbered defeated monster (2nd, 4th, ...), he gains an additional \\( X \\) experience points.\n\nFind the maximum total experience points he can gain from the \\( N \\) monsters.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the maximum total experience points he can gain from the \\( N \\) monsters as an integer.\n\n**Sample Input 1:**\n```\n5\n1 5 3 2 7\n```\n\n**Sample Output 1:**\n```\n28\n```\n\n**Explanation:**\n\nIf Takahashi defeats the 1st, 2nd, 3rd, and 5th monsters, and lets the 4th monster go, he gains experience points as follows:\n- Defeats a monster with strength \\( A_1 = 1 \\). He gains 1 experience point.\n- Defeats a monster with strength \\( A_2 = 5 \\). He gains 5 experience points. As it is the 2nd defeated monster, he gains an additional 5 points.\n- Defeats a monster with strength \\( A_3 = 3 \\). He gains 3 experience points.\n- Lets the 4th monster go. Takahashi gains no experience points.\n- Defeats a monster with strength \\( A_5 = 7 \\). He gains 7 experience points. As it is the 4th defeated monster, he gains an additional 7 points.\n\nTherefore, in this case, he gains \\( 1+(5+5)+3+0+(7+7)=28 \\) experience points. Note that even if he encounters a monster, if he lets it go, it does not count as defeated. He can gain at most 28 experience points no matter how he acts, so print 28. As a side note, if he defeats all monsters in this case, he would gain \\( 1+(5+5)+3+(2+2)+7=25 \\) experience points.\n\n**Sample Input 2:**\n```\n2\n1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n3000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 369\n\nD - Bonus EXP Editorial\n\nThis problem can be solved with dynamic programming (DP). Let \\(dp_{even}[k]\\) be the maximum total experience point when defeating an even number of monsters out of the first \\(k\\) monsters encountered, and \\(dp_{odd}[k]\\) be that for an odd number of monsters (or \\(-\\infty\\) if it is impossible). Initially, \\(dp_{even}[0]=0\\) and \\(dp_{odd}[0]=-\\infty\\).\n\nFor \\(1\\leq i\\leq N\\), the experience point from the \\(i\\)-th monster depends on whether Takahashi chooses to defeat it or not, and whether the number of defeated monsters is even or odd. To encounter the first \\(i\\) monsters and defeat an even number, we have two cases:\n\n1. Defeat an even number of monsters from the first \\((i-1)\\) and let the \\(i\\)-th go.\n2. Defeat an odd number of monsters from the first \\((i-1)\\) and defeat the \\(i\\)-th.\n\nThus, we can find \\(dp_{even}[i]\\) as \n\\[\ndp_{even}[i]=\\max(dp_{even}[i-1],dp_{odd}[i-1]+2A_i).\n\\]\n\nSimilarly, \\(dp_{odd}[i]\\) is\n\\[\ndp_{odd}[i]=\\max(dp_{odd}[i-1],dp_{even}[i-1]+A_i).\n\\]\n\nThe final answer is \\(\\max(dp_{even}[N],dp_{odd}[N])\\), with a complexity of \\(O(N)\\).\n\nSample code in Python:\n```python\nINF = 10**18\n\ndef main():\n    n = int(input())\n    dp0, dp1 = 0, -INF\n    for _ in range(n):\n        x = int(input())\n        tmp = dp0\n        dp0 = max(dp1 + 2*x, dp0)\n        dp1 = max(tmp + x, dp1)\n    print(max(dp0, dp1))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 900 points\n\nProblem Statement:\nWe have a long, thin piece of paper whose thickness can be ignored. We perform the following operation 100 times: lift the right end and fold it so that it aligns with the left end using the center as a crease. After completing the 100 folds, we unfold the paper back to its original state. At this point, there are \\(2^{100} - 1\\) creases on the paper, which can be classified into two types: mountain folds and valley folds. The figure below represents the state after performing the operation twice, where red solid lines represent mountain folds and red dashed lines represent valley folds.\n\nAbout mountain and valley folds:\n- A crease is a mountain fold if it is folded so that the back sides of the paper come together at the crease.\n- A crease is a valley fold if it is folded so that the front sides of the paper come together at the crease.\n\nYou are given a sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of N non-negative integers where \\(0 = A_1 < A_2 < \\dots < A_N \\leq 10^{18}\\).\n\nFor each integer \\(i\\) from 1 through \\(2^{100} - A_N - 1\\), define \\(f(i)\\) as follows:\n- The number of \\(k = 1, 2, \\dots, N\\) such that the \\((i + A_k)\\)-th crease from the left is a mountain fold.\n\nFind the maximum value among \\(f(1), f(2), \\dots, f(2^{100} - A_N - 1)\\).\n\nConstraints:\n- \\(1 \\leq N \\leq 10^3\\)\n- \\(0 = A_1 < A_2 < \\dots < A_N \\leq 10^{18}\\)\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\nOutput:\nPrint the answer in one line.\n\nSample Input 1:\n```\n4\n0 1 2 3\n```\n\nSample Output 1:\n```\n3\n```\n\nExplanation:\nIf mountain and valley folds are represented by M and V, respectively, there is a contiguous subsequence of creases like MMVM. There is no contiguous subsequence like MMMM, so the answer is 3.\n\nSample Input 2:\n```\n6\n0 2 3 5 7 8\n```\n\nSample Output 2:\n```\n4\n```\n\nSolution:\n\n```\nAtCoder Regular Contest 184 - C: Mountain and Valley Folds Editorial\n\nFirst, observe the structure of the creases. If we extract only the odd-numbered creases, the mountain and valley folds continue as VMVM.... If we extract only the even-numbered creases, this structure recurs. When grouping the creases based on the least significant bit that is 1 in the binary representation of their indices, each group forms a sequence like VMVM.... This can be proved using mathematical induction, among other methods, and is utilized in the solution.\n\nLet \\(f(a, k)\\) be the answer to the problem when taking \\(i\\) satisfying \\(i \\bmod 4 = k\\) for the sequence \\(a = (a_1, a_2, \\dots ,a_m)\\). When \\(k = 0, 2\\), the contribution to the answer from the odd elements of \\(a\\) is uniquely determined. When \\(k = 1, 3\\), the contribution from the even elements of \\(a\\) is uniquely determined, because the type (mountain or valley) of the fold at position \\(a_x + i\\) depends only on \\(i \\bmod 4\\).\n\nFor elements whose contribution is not uniquely determined\u2014namely, the even elements when \\(k = 0, 2\\), and the odd elements when \\(k = 1, 3\\)\u2014extract and divide them by \\(2\\) (rounded down) to form a sequence \\(b = (b_1, b_2, \\dots ,b_l)\\). The contribution of these elements is counted recursively as \\(\\max \\left( f\\left( b, \\left\\lceil \\frac{k}{2} \\right\\rceil \\right),\\ f\\left( b, \\left\\lceil \\frac{k}{2} \\right\\rceil + 2 \\right) \\right)\\). This recursive structure of the creases and the fact that 100 operations is sufficiently many in regard to the constraints make the approach viable.\n\nElements derived from a particular element of \\(A\\) appear in \\(a\\) at most \\(\\log_2 \\max A\\) times during recursion, making this solution efficient. With appropriate implementation, the computational complexity is \\(O(N \\log \\max A)\\).\n```\n \n\n", "problem_ids": ["abc371_c", "abc369_d", "arc184_c"]}, "abc311_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi is heading to AtCoder Land. There is a signboard in front of him, and he wants to determine whether it says \"AtCoder Land.\"\n\nYou are given two strings \\( S \\) and \\( T \\) separated by a space. Determine whether \\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of uppercase and lowercase English letters, with lengths between 1 and 10, inclusive.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nIf \\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\), print \"Yes\"; otherwise, print \"No\".\n\n**Sample Input 1**\n```\nAtCoder Land\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n\\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\).\n\n**Sample Input 2**\n```\nCodeQUEEN Land\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n\\( S \\) is not \"AtCoder\".\n\n**Sample Input 3**\n```\naTcodeR lANd\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nUppercase and lowercase letters are distinguished.\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nIf you are new to learning programming, try Problem A \u201cWelcome to AtCoder\u201d from the practice contest, which provides sample code for each language. Also, explore the \u201cAtCoder Beginners Selection\u201d for more practice problems.\n\nReceive two strings as input, and implement a conditional branch to print the answer. In the conditional expression, compare strings and evaluate the logical sum of two conditions. Refer to the sample code below.\n\nSample code (Python):\n```python\ns, t = input().split()\nif s == \"AtCoder\" and t == \"Land\":\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Score:** 475 points\n\n**Problem Statement**\n\nIn the nation of Atcoder, there are \\( N \\) cities numbered from 1 to \\( N \\), and \\( M \\) trains numbered from 1 to \\( M \\). Train \\( i \\) departs from city \\( A_i \\) at time \\( S_i \\) and arrives at city \\( B_i \\) at time \\( T_i \\).\n\nGiven a positive integer \\( X_1 \\), find a way to determine non-negative integers \\( X_2, \\ldots, X_M \\) that satisfy the following condition while minimizing the value of \\( X_2 + \\ldots + X_M \\).\n\n**Condition:**\n\nFor all pairs \\( (i, j) \\) satisfying \\( 1 \\leq i, j \\leq M \\), if \\( B_i = A_j \\) and \\( T_i \\leq S_j \\), then \\( T_i + X_i \\leq S_j + X_j \\).\n\nIn other words, for any pair of trains that were originally possible to transfer between, it must still be possible to transfer even after delaying the departure and arrival times of each train \\( i \\) by \\( X_i \\).\n\nIt can be proved that there is a unique way to set \\( X_2, \\ldots, X_M \\) with the minimum possible value of \\( X_2 + \\ldots + X_M \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( A_i \\neq B_i \\)\n- \\( 0 \\leq S_i < T_i \\leq 10^9 \\)\n- \\( 1 \\leq X_1 \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M X_1\nA_1 B_1 S_1 T_1\n\u22ee\nA_M B_M S_M T_M\n```\n\n**Output**\n\nPrint \\( X_2, \\ldots, X_M \\) that satisfy the condition with the minimum possible sum, in that order, separated by spaces.\n\n**Sample Input 1**\n\n```\n3 6 15\n1 2 10 20\n1 2 20 30\n2 3 25 40\n2 3 35 50\n3 1 15 30\n3 1 45 60\n```\n\n**Sample Output 1**\n\n```\n0 10 0 0 5\n```\n\n**Explanation**\n\nThe arrival of train 1 from city 1 to 2 is delayed by 15 and becomes time 35. To allow transfer from train 1 to 3 in city 2, the departure of train 3 is delayed by 10, making it depart at time 35 and arrive at time 50. Further, to allow transfer from train 3 to 6 in city 3, the departure of train 6 is delayed by 5, making it depart at time 50. Other trains can operate without delay while still allowing transfers between originally transferable trains, so \\( (X_2, X_3, X_4, X_5, X_6) = (0, 10, 0, 0, 5) \\) satisfies the condition. Moreover, there is no solution with a smaller sum that satisfies the condition, so this is the answer.\n\n**Sample Input 2**\n\n```\n10 9 100\n1 10 0 1\n10 2 1 100\n10 3 1 100\n10 4 1 100\n10 5 1 100\n10 6 1 100\n10 7 1 100\n10 8 1 100\n10 9 1 100\n```\n\n**Sample Output 2**\n\n```\n100 100 100 100 100 100 100 100\n```\n\n**Sample Input 3**\n\n```\n4 4 10\n1 2 0 1\n1 2 0 10\n2 3 100 200\n2 4 100 200\n```\n\n**Sample Output 3**\n\n```\n0 0 0\n```\n\nSolution:\n\nHere's the trimmed version focusing on the solution:\n\n---\n\n**E - Train Delay Editorial**\n\nLet us call \\(S_i\\) and \\(T_i\\) the scheduled departure and arrival, respectively, and \\(S_i+X_i\\) and \\(T_i+X_i\\) the actual departure and arrival. If you let a train depart later, you cannot make another depart earlier, so assume every train departs as early as possible. Whether a train \\(i\\) can depart is affected by trains whose scheduled arrival is prior to the departure of train \\(i\\). Therefore, processing trains in order of their scheduled times is effective.\n\nSort the \\(2M\\) departure/arrival events in ascending order:\n\n- When train \\(i\\) departs, find \\(X_i\\) based on the actual arrivals to station \\(A_i\\) for trains processed so far.\n- When train \\(i\\) arrives, record the actual arrival to station \\(B_i\\) based on \\(X_i\\).\n\nThese steps can be done in \\(O(1)\\) time by managing for each station the latest actual arrival of the trains processed so far. If departure and arrival occur simultaneously, process arrivals first.\n\n```python\nN, M, X = map(int, input().split())\nA, B, S, T = zip(*[tuple(map(int, input().split())) for _ in range(M)])\n\nevent = sorted([(S[i], 1, i) for i in range(M)] + [(T[i], 0, i) for i in range(M)])\n\nans = [0] * M\nans[0] = X\n\nstation = [0] * (N + 1)\nfor t, f, i in event:\n  if f:\n    if i:\n      ans[i] = max(0, station[A[i]] - t)\n  else:\n    station[B[i]] = max(station[B[i]], t + ans[i])\n\nprint(*ans[1:])\n```\n\n---\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\(N\\) linear functions \\(f_1, f_2, \\ldots, f_N\\), where \\(f_i(x) = A_i x + B_i\\). Your task is to find the maximum possible value of \n\\[ \nf_{p_1}(f_{p_2}(\\ldots f_{p_K}(1) \\ldots )) \n\\]\nfor a sequence \\(p = (p_1, p_2, \\ldots, p_K)\\) composed of \\(K\\) distinct integers between \\(1\\) and \\(N\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq K \\leq \\text{min}(N,10)\\)\n- \\(1 \\leq A_i, B_i \\leq 50\\) for all \\(1 \\leq i \\leq N\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2\n2 3\n1 5\n4 2\n```\n\n**Sample Output 1**\n```\n26\n```\n\n**Explanation for Sample Input 1**\n\nHere are all possible \\(p\\) and the corresponding values of \\(f_{p_1}(f_{p_2}(1))\\):\n- \\(p= (1,2)\\): \\(f_1(f_2(1))=15\\)\n- \\(p= (1,3)\\): \\(f_1(f_3(1))=15\\)\n- \\(p= (2,1)\\): \\(f_2(f_1(1))=10\\)\n- \\(p= (2,3)\\): \\(f_2(f_3(1))=11\\)\n- \\(p= (3,1)\\): \\(f_3(f_1(1))=22\\)\n- \\(p= (3,2)\\): \\(f_3(f_2(1))=26\\)\n\nTherefore, the maximum value is \\(26\\), and you should print \\(26\\).\n\n**Sample Input 2**\n```\n10 3\n48 40\n34 22\n24 37\n45 40\n48 31\n49 44\n45 40\n44 6\n35 22\n39 28\n```\n\n**Sample Output 2**\n```\n216223\n```\n\nSolution:\n\n```python\nn, k = map(int, input().split())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nord_indices = list(range(n))\nord_indices.sort(key=lambda i: b[i] * (a[i] - 1), reverse=True)\n\ndp = [int(-1e9)] * (k + 1)\ndp[0] = 1\n\nfor i in ord_indices:\n    ndp = dp[:]\n    for j in range(k):\n        if dp[j] > int(-1e9):\n            ndp[j + 1] = max(ndp[j + 1], dp[j] * a[i] + b[i])\n    dp = ndp\n\nprint(dp[k])\n```\n \n\n", "problem_ids": ["abc358_a", "abc368_e", "abc366_f"]}, "abc311_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) giants, each identified by an integer from 1 to \\( N \\). For each giant \\( i \\), when they stand on the ground, their shoulder height is \\( A_i \\) and their head height is \\( B_i \\).\n\nYou can arrange all the giants in a permutation \\( (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) and stack them one on top of another according to the following rules:\n\n1. Place giant \\( P_1 \\) on the ground. The shoulder height of giant \\( P_1 \\) from the ground is \\( A_{P_1} \\), and the head height is \\( B_{P_1} \\).\n2. Following this, for \\( i = 1, 2, \\ldots, N - 1 \\), place giant \\( P_{i+1} \\) on the shoulders of giant \\( P_i \\). If the shoulder height of giant \\( P_i \\) from the ground is \\( t \\), then the shoulder height of giant \\( P_{i+1} \\) from the ground is \\( t + A_{P_{i+1}} \\), and the head height is \\( t + B_{P_{i+1}} \\).\n\nThe goal is to determine the maximum possible head height from the ground of the topmost giant \\( P_N \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 200,000 \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq 1,000,000,000 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output:**\n\nPrint the maximum possible height of the head of the topmost giant from the ground.\n\n**Sample Input 1:**\n```\n3\n4 10\n5 8\n2 9\n```\n\n**Sample Output 1:**\n```\n18\n```\n\n*Explanation:* If the permutation \\( (P_1, P_2, P_3) = (2, 1, 3) \\) is chosen, the heights measured from the ground would be as follows:\n\n- Giant 2 will have a shoulder height of 5 and a head height of 8.\n- Giant 1 will be on top, having a shoulder height of 9 and a head height of 15.\n- Giant 3 will be on top, having a shoulder height of 11 and a head height of 18.\n\nThe maximum head height achievable with any arrangement of the giants is 18, and thus, 18 is printed.\n\n**Sample Input 2:**\n```\n5\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\n**Sample Output 2:**\n```\n5\n```\n\n**Sample Input 3:**\n```\n10\n690830957 868532399\n741145463 930111470\n612846445 948344128\n540375785 925723427\n723092548 925021315\n928915367 973970164\n563314352 832796216\n562681294 868338948\n923012648 954764623\n691107436 891127278\n```\n\n**Sample Output 3:**\n```\n7362669937\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\nThe height of the topmost giant\u2019s head when \\(P_N\\), i.e., when giant \\(i\\) is the topmost giant, is \\(B_i + \\sum_{j \\neq i}A_j\\). This can be expressed as \\(B_i - A_i + \\sum_{j = 1}^{N} A_j\\), and the answer is the maximum of this value for \\(i = 1, 2, \\ldots, N\\). Since \\(\\sum_{j = 1}^{N} A_j\\) is independent of \\(i\\), it is sufficient to find \\(\\max (B_i - A_i)\\). This can be computed using a for loop in a total of \\(O(N)\\) time.\n\nSample code:\n```python\nn = int(input())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nm = 0\nfor i in range(n):\n    m = max(m, b[i] - a[i])\nans = m + sum(a)\nprint(ans)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) buildings aligned in a row. The \\( i \\)-th building from the left has a height of \\( H_i \\).\n\nDetermine if there is a building taller than the first one from the left. If such a building exists, find the position of the leftmost such building from the left.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nIf no building is taller than the first one from the left, print `-1`.\nIf such a building exists, print the position (index) of the leftmost such building from the left.\n\n**Sample Input 1**\n```\n4\n3 2 5 2\n```\n\n**Sample Output 1**\n```\n3\n```\n*Explanation*: The building taller than the first one from the left is the third one from the left.\n\n**Sample Input 2**\n```\n3\n4 3 2\n```\n\n**Sample Output 2**\n```\n-1\n```\n*Explanation*: No building is taller than the first one from the left.\n\n**Sample Input 3**\n```\n7\n10 5 10 2 10 13 15\n```\n\n**Sample Output 3**\n```\n6\n```\n*Explanation*: The buildings taller than the first one from the left are the sixth and seventh ones. Among them, the leftmost is the sixth one.\n\nSolution:\n\nHere is a cleaned version of the coding problem editorial:\n\n---\n\nUse a for statement to check for each \\(i=2,3,\\ldots,N\\) if \\(H_i > H_1\\). If such an \\(i\\) is found, print that \\(i\\) and terminate the program. Otherwise, print \\(-1\\). Note that most programming languages adopt \\(0\\)-based indexing.\n\nSample code (Python):\n```python\nn = int(input())\nh = list(map(int, input().split()))\nfor i in range(1, n):\n  if h[i] > h[0]:\n    print(i + 1)\n    exit()\nprint(-1)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a string \\( S \\) consisting of lowercase English letters and periods (`.`). Your task is to find the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Constraints**\n\n- \\( S \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters and periods (`.`).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\( S \\)\n\n**Output**\n\nPrint the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Sample Input 1**\n\n```\n.v.\n```\n\n**Sample Output 1**\n\n```\nv\n```\n\nRemoving all periods (`.`) from `.v.` yields `v`, so we print `v`.\n\n**Sample Input 2**\n\n```\nchokudai\n```\n\n**Sample Output 2**\n\n```\nchokudai\n```\n\nThere are cases where \\( S \\) does not contain periods (`.`).\n\n**Sample Input 3**\n\n```\n...\n```\n\n**Sample Output 3**\n\n```\n\n```\n\nThere are also cases where all characters in \\( S \\) are periods (`.`).\n\nSolution:\n\n```python\n# Python equivalent of C++ code\n\n# Standard implementation\n\nS = input()\nT = \"\"\nfor c in S:\n    if c != '.':\n        T += c\nprint(T)\n\n# Concise implementation\n\nS = input()\nS = S.replace('.', '')\nprint(S)\n```\n \n\n", "problem_ids": ["abc352_c", "abc353_a", "abc372_a"]}, "abc311_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\nYou are given a horizontally written text. Convert it to vertical writing, filling spaces with `*`.\n\nYou are given \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\) consisting of lowercase English letters. Let \\( M \\) be the maximum length of these strings.\n\nPrint \\( M \\) strings \\( T_1, T_2, \\dots, T_M \\) that satisfy the following conditions:\n\n1. Each \\( T_i \\) consists of lowercase English letters and `*`.\n2. Each \\( T_i \\) does not end with `*`.\n3. For each \\( 1 \\leq i \\leq N \\), the following holds:\n    - For each \\( 1 \\leq j \\leq |S_i| \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) exists, and the concatenation of the \\( (N-i+1) \\)-th characters of \\( T_1, T_2, \\dots, T_{|S_i|} \\) in this order equals \\( S_i \\).\n    - For each \\( |S_i| + 1 \\leq j \\leq M \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) either does not exist or is `*`.\n\nHere, \\( |S_i| \\) denotes the length of the string \\( S_i \\).\n\nConstraints:\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is a string of lowercase English letters with length between 1 and 100, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\nOutput:\nPrint the answer in the following format:\n```\nT_1\nT_2\n\u22ee\nT_M\n```\n\nSample Input 1:\n```\n3\nabc\nde\nfghi\n```\n\nSample Output 1:\n```\nfda\ngeb\nh*c\ni\n```\n\nSample Input 2:\n```\n3\natcoder\nbeginner\ncontest\n```\n\nSample Output 2:\n```\ncba\noet\nngc\ntio\nend\nsne\nter\n*r\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        First, ignore the condition that \\(T_i\\) does not end with *. Initialize \\(T_1,T_2,\\dots,T_M\\) with a length-\\(N\\) string of *. For each \\(i\\) and \\(j\\), assign the \\(j\\)-th character of \\(S_i\\) to the \\((N-i+1)\\)-th character of \\(T_j\\). To satisfy the second condition, for each \\(T_i\\), remove the last character while it ends with *. \n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(map(len, S))\nT = [[\"*\"] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i][-1] == \"*\":\n        T[i].pop()\n    print(\"\".join(T[i]))\n```\n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(len(s) for s in S)\nT = [['*'] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i] and T[i][-1] == '*':\n        T[i].pop()\n    print(''.join(T[i]))\n}\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi has a piano with 100 keys arranged in a row. The i-th key from the left is called key i.\n\nHe will play music by pressing N keys one by one. For the i-th press, he will press key \\( A_i \\), using his left hand if \\( S_i = L \\), and his right hand if \\( S_i = R \\).\n\nBefore starting to play, he can place both of his hands on any keys he likes, and his fatigue level at this point is 0. During the performance, if he moves one hand from key x to key y, the fatigue level increases by \\(|y-x|\\) (the fatigue level does not increase for any reason other than moving hands). To press a certain key with a hand, that hand must be placed on that key.\n\nFind the minimum possible fatigue level at the end of the performance.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq 100 \\)\n- \\( N \\) and \\( A_i \\) are integers.\n- \\( S_i \\) is 'L' or 'R'.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 S_1\nA_2 S_2\n...\nA_N S_N\n```\n\n**Output**\n\nPrint the minimum fatigue level at the end of the performance.\n\n**Sample Input 1**\n```\n4\n3 L\n6 R\n9 L\n1 R\n```\n\n**Sample Output 1**\n```\n11\n```\n\nFor example, the performance can be done as follows:\n- Initially, place the left hand on key 3 and the right hand on key 6.\n- Press key 3 with the left hand.\n- Press key 6 with the right hand.\n- Move the left hand from key 3 to key 9. The fatigue level increases by \\(|9-3| = 6\\).\n- Move the right hand from key 6 to key 1. The fatigue level increases by \\(|1-6| = 5\\).\n- Press key 9 with the left hand.\n- Press key 1 with the right hand.\n\nIn this case, the fatigue level at the end of the performance is \\(6 + 5 = 11\\), which is the minimum possible.\n\n**Sample Input 2**\n```\n3\n2 L\n2 L\n100 L\n```\n\n**Sample Output 2**\n```\n98\n```\n\n**Sample Input 3**\n```\n8\n22 L\n75 L\n26 R\n45 R\n72 R\n81 R\n47 L\n29 R\n```\n\n**Sample Output 3**\n```\n188\n```\n\nSolution:\n\n```\nEditorial - B - Piano 3\n\nManage the positions of left and right hands while inspecting the key to press for \\(1,2,\\dots,N\\)-th press, and add the fatigue level of each move required. In the sample code, an array \\(\\text{pos}\\) of length two is prepared, with \\(pos[0]\\) and \\(pos[1]\\) managing the current positions of left and right hands, respectively. Initial positions are set to \\(-1\\), and no fatigue is added when moving a hand from \\(-1\\) to another key. This simulates placing a hand at the first key to be pressed by that hand.\n\nSample code (Python):\n```python\nn = int(input())\npos = [-1, -1]   # 0: left, 1: right\nans = 0\nfor i in range(n):\n    a, s = input().split()\n    a = int(a)\n    hand = (0 if s == 'L' else 1)\n    if pos[hand] != -1:\n        ans += abs(pos[hand] - a)\n    pos[hand] = a\nprint(ans)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) sequences of length \\( M \\), where each element is either 0 or 1. The \\( i \\)-th sequence is \\( A_i = (A_{i, 1}, A_{i, 2}, \\dots, A_{i, M}) \\).\n\nFor integers \\( i, j \\) \\((1 \\leq i, j \\leq N)\\), define \\( f(i, j) \\) as follows: \\( f(i, j) \\) is the smallest non-negative integer \\( x \\) such that \\( A_i \\) and \\( A_j \\) become identical after performing the following operation \\( x \\) times, or \\( 0 \\) if such \\( x \\) does not exist.\n\nOperation: For all integers \\( k \\) \\((1 \\leq k \\leq M)\\) simultaneously, replace \\( A_{i, k} \\) with \\( \\left (\\sum_{l=1}^{k} A_{i, l} \\right ) \\bmod 2 \\).\n\nFind \\( \\sum_{i=1}^{N} \\sum_{j=i}^{N} f(i, j) \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\times M \\leq 10^6 \\)\n- \\( A_{i, j} \\in \\{0, 1\\} \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1, 1} A_{1, 2} \\cdots A_{1, M}\nA_{2, 1} A_{2, 2} \\cdots A_{2, M}\n\\vdots\nA_{N, 1} A_{N, 2} \\cdots A_{N, M}\n```\n\n**Output**\n\nPrint the answer in one line.\n\n**Sample Input 1**\n\n```\n4 3\n1 0 0\n1 1 0\n1 0 1\n0 1 1\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\nExplanation: \\( f(1, 1) = 0 \\), \\( f(1, 2) = 3 \\), \\( f(1, 3) = 2 \\), \\( f(1, 4) = 0 \\), \\( f(2, 2) = 0 \\), \\( f(2, 3) = 3 \\), \\( f(2, 4) = 0 \\), \\( f(3, 3) = 0 \\), \\( f(3, 4) = 0 \\), \\( f(4, 4) = 0 \\), summing to 8.\n\n**Sample Input 2**\n\n```\n7 6\n1 0 0 0 0 0\n1 1 1 0 0 0\n1 0 1 1 0 0\n1 0 0 0 1 1\n1 0 0 0 0 1\n1 0 0 0 0 0\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n\n```\n6\n```\n\nSolution:\n\n```plaintext\nEditorial - E - Accumulating Many Times\n\nFirst, treat sequences that differ in the position of their first \\(1\\) as separate problems, since operations do not change this position. Assume \\(A_{i, 1} = 1\\). Define the inverse operation for the problem's operation. The graph formed by length-\\(M\\) binary sequences starting with \\(1\\) has operations as edges and is a collection of cycles. \n\nEvery sequence can be transformed into a \u201cstandard form\u201d where all elements at positions \\((2^x + 1)\\) using non-negative integer \\(x\\) are \\(0\\). This is proven using Lucas\u2019s theorem. Cycle length is \\(2^m\\), where \\(m\\) is the smallest non-negative integer such that \\(2^m + 1 \\leq M\\).\n\nTo solve, first transform sequences to their standard forms and calculate the required operations. For each \\(i = 1, 2, \\dots, N\\), compute the standard form of sequence \\(A_i\\) and the cost to reach it. Transform \\(A_{i, 2^x + 1}\\) into \\(0\\) by performing the operation \\(2^x\\) times if \\(A_{i, 2^x + 1} = 1\\).\n\nNext, solve for each standard form: for integer sequence \\(B\\), compute \\(\\displaystyle \\sum_{i=1}^{m} \\sum_{j=i}^{m} \\left( (B_j - B_i) \\bmod 2^m \\right)\\) using Segment Tree or similar structures.\n\nThe computational bottleneck is computing the standard forms. Multiple operations using FFT help, but we may exceed the time limit if performed every time. Instead, keep track of operations count to determine value at a position in \\(O(M)\\) time. Overall complexity is \\(O(NM \\log NM)\\).\n```\n \n\n", "problem_ids": ["abc366_b", "abc369_b", "arc184_e"]}, "abc311_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) types of elements numbered \\( 1, 2, \\ldots, N \\). Elements can be combined with each other. When elements \\( i \\) and \\( j \\) are combined, they transform into element \\( A_{i, j} \\) if \\( i \\geq j \\), and into element \\( A_{j, i} \\) if \\( i < j \\).\n\nStarting with element \\( 1 \\), combine it with elements \\( 1, 2, \\ldots, N \\) in this order. Find the final element obtained.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_{i, j} \\leq N \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_{1, 1}\nA_{2, 1} A_{2, 2}\n\\vdots\nA_{N, 1} A_{N, 2} \\ldots A_{N, N}\n```\n\n**Output:**\n\nPrint the number representing the final element obtained.\n\n**Sample Input 1:**\n\n```\n4\n3\n2 4\n3 1 2\n2 1 2 4\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- Combining element 1 with element 1 results in element 3.\n- Combining element 3 with element 2 results in element 1.\n- Combining element 1 with element 3 results in element 3.\n- Combining element 3 with element 4 results in element 2.\n\nTherefore, the value to be printed is 2.\n\n**Sample Input 2:**\n\n```\n5\n5\n5 5\n5 5 5\n5 5 5 5\n5 5 5 5 5\n```\n\n**Sample Output 2:**\n\n```\n5\n```\n\n**Sample Input 3:**\n\n```\n6\n2\n1 5\n1 6 3\n2 6 1 4\n2 1 1 1 6\n5 6 1 2 2 5\n```\n\n**Sample Output 3:**\n\n```\n5\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\n**B - Binary Alchemy Editorial**\n\nSimulate the process of successively synthesizing elements \\(1, 2, \\ldots, N\\) into element \\(1\\) while managing the current index of the element.\n\n```python\ndef main():\n    n = int(input())\n    a = [list(map(lambda x: int(x) - 1, input().split())) + [0] * (n - i - 1) for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if ans >= i:\n            ans = a[ans][i]\n        else:\n            ans = a[i][ans]\n    ans += 1\n    print(ans)\n\nmain()\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 100 points\n\n**Problem Statement**\n\nTakahashi is planning to eat \\( N \\) dishes. \n- The \\( i \\)-th dish he plans to eat is sweet if \\( S_i = \\text{sweet} \\), and salty if \\( S_i = \\text{salty} \\). \n- If he eats two sweet dishes consecutively, he will feel sick and be unable to eat any more dishes. \n\nDetermine whether he can eat all the dishes.\n\n**Constraints**\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is either \\text{sweet} or \\text{salty}.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nS_1\nS_2\n...\nS_N\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can eat all the dishes, and `No` otherwise.\n\n**Sample Input 1**\n```\n5\nsalty\nsweet\nsalty\nsalty\nsweet\n```\n\n**Sample Output 1**\n```\nYes\n```\n*Takahashi will not eat two sweet dishes consecutively, so he can eat all the dishes without feeling sick.*\n\n**Sample Input 2**\n```\n4\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 2**\n```\nYes\n```\n*He will feel sick but can still eat all the dishes.*\n\n**Sample Input 3**\n```\n6\nsalty\nsweet\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 3**\n```\nNo\n```\n*He feels sick when eating the 3rd dish and cannot eat the 4th and subsequent dishes.*\n\nSolution:\n\n        [BEGIN TEXT]\n        Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nIf there exists an integer \\(i\\) between \\(1\\) and \\((N-2)\\) such that the \\(i\\)-th and \\((i+1)\\)-th dishes to eat are both sweet, he cannot eat the \\((i+2)\\)-th dish and cannot eat all of the dishes. Otherwise, he does not get sick until eating the last dish, so he can eat all the dishes. Note that indices start from \\(0\\) in the following sample code.\n\n```python\nn = int(input())\ns = [input().strip() for _ in range(n)]\nans = \"Yes\"\nfor i in range(n - 2):\n    if s[i] == \"sweet\" and s[i + 1] == \"sweet\":\n        ans = \"No\"\nprint(ans)\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\n", "problem_ids": ["abc370_b", "abc364_a", "abc368_c"]}, "abc311_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence of integers \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nDefine \\( f(l, r) \\) as the number of distinct values in the subsequence \\( (A_l, A_{l+1}, \\ldots, A_r) \\).\n\nEvaluate the following sum:\n\n\\[\n\\sum_{i=1}^{N}\\sum_{j=i}^N f(i,j)\n\\]\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\n\nThe input is given in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n3\n1 2 2\n```\n\n### Sample Output 1\n\n```\n8\n```\n\nConsider \\( f(1, 2) \\). The subsequence \\( (A_1, A_2) = (1, 2) \\) contains 2 distinct values, so \\( f(1,2) = 2 \\).\n\nConsider \\( f(2, 3) \\). The subsequence \\( (A_2, A_3) = (2, 2) \\) contains 1 distinct value, so \\( f(2,3) = 1 \\).\n\nThe sum of \\( f \\) is 8.\n\n### Sample Input 2\n\n```\n9\n5 4 2 2 3 2 4 4 1\n```\n\n### Sample Output 2\n\n```\n111\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 371\n\nE - I Hate Sigma Problems Editorial\n\nThe answer is the number of subarrays containing \\(1\\) \\(+\\) the number of subarrays containing \\(2\\) \\(+\\ldots+\\) the number of subarrays containing \\(N\\). We will explain how to count subarrays containing \\(i\\) in \\(\\mathrm{O}(C_i)\\) time (where \\(C_i\\) is the number of occurrences of \\(i\\) in \\(A\\)). Once this is possible, the problem can be solved in a total of \\(\\mathrm{O}(N)\\) time. A common technique of combinatorics is to consider complementary events. Let\u2019s count the number of subarrays not containing \\(i\\), subtracting the sum from the all. For simplicity, let us insert \\(i\\) to both ends of \\(A\\). Then, the indices \\(x\\) with \\(A_x = i\\) arranged in ascending order are represented as \\(x=(x_0=0,x_1,\\ldots,x_{C_i+1} = N+1)\\). The number of subarrays not containing \\(i\\) equals the number of subarrays whose left end is \\(x_0+1\\) or greater, and right end is \\(x_1-1\\) or less, plus subarrays whose left end is \\(x_1+1\\) or greater, and right end is \\(x_2-1\\) or less, and so on. This can be evaluated in \\(\\mathrm{O}(C_i)\\) time. Hence, the problem has been solved.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThe Republic of AtCoder consists of \\(L+1\\) islands aligned east-west, numbered \\(0\\) to \\(L\\) from west to east. The islands are connected by air routes, where for each \\(1 \\leq i \\leq L\\), there is a bidirectional air route between islands \\(i-1\\) and \\(i\\). Each air route is owned by company A or company J, and the route between islands \\(i-1\\) and \\(i\\) is owned by company \\(S_i\\).\n\nThe nation has \\(N\\) residents, numbered \\(1\\) to \\(N\\). Resident \\(i\\) is currently on island \\(X_i\\). Each resident has a coupon of one of the companies. Specifically, resident \\(i\\) has a coupon of company \\(C_i\\). With a coupon, a resident can take that company's routes for free any number of times, but taking a route of the other company costs 1 coin per trip.\n\nNow, there is a treasure chest on island 0. The residents want to cooperate to carry it to the capital, which is on island \\(L\\). Determine the minimum total number of coins required to achieve this goal. The residents can pass the treasure chest to each other, but not their coupons.\n\nConstraints:\n- \\(1 \\leq L \\leq 6 \\times 10^4\\)\n- \\(1 \\leq N \\leq 6 \\times 10^4\\)\n- \\(S_i \\ (1 \\leq i \\leq L)\\) is 'A' or 'J'.\n- \\(0 \\leq X_i \\leq L \\ (1 \\leq i \\leq N)\\)\n- \\(C_i \\ (1 \\leq i \\leq N)\\) is 'A' or 'J'.\n- \\(L, N, X_i\\) are integers.\n\nInput:\n- Input is given from Standard Input in the following format:\n  \\[\n  L \\, N \\\\\n  S_1 S_2 \\cdots S_L \\\\\n  X_1 \\, C_1 \\\\\n  X_2 \\, C_2 \\\\\n  \\vdots \\\\\n  X_N \\, C_N\n  \\]\n- Note that the second line is a string of length \\(L\\).\n\nOutput:\n- Print the answer.\n\nSample Input 1:\n```\n4 3\nAAJJ\n3 A\n1 J\n1 J\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation for Sample 1:\nTo carry the treasure chest to island 4 for a total of 2 coins, the following steps are taken:\n1. Resident 1 moves from island 3 to island 2, costing 1 coin as the route is not covered by the coupon.\n2. Resident 1 moves from island 2 to island 1, requiring no coins as the route is covered by the coupon.\n3. Resident 1 moves from island 1 to island 0, requiring no coins as the route is covered by the coupon.\n4. Resident 1 picks up the treasure chest.\n5. Resident 1 moves, carrying the treasure chest, from island 0 to island 1 without costing any coins as the route is covered by the coupon.\n6. Resident 1 passes the treasure chest to resident 2.\n7. Resident 2, with the treasure chest, moves from island 1 to island 2, costing 1 coin as the route is not covered by the coupon.\n8. Resident 2 moves with the treasure chest from island 2 to island 3, requiring no coins as the route is covered by the coupon.\n9. Resident 2 moves with the treasure chest from island 3 to island 4, requiring no coins as the route is covered by the coupon.\n\nSample Input 2:\n```\n8 3\nJJAAJJAJ\n2 A\n6 A\n8 J\n```\n\nSample Output 2:\n```\n6\n```\n\nSample Input 3:\n```\n8 6\nJJAAJJAJ\n2 A\n6 A\n8 J\n8 J\n8 J\n8 J\n```\n\nSample Output 3:\n```\n4\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 177 - F - Two Airlines Editorial\n\nStep 1:\nConsider the optimal movement strategy for residents with company A and J coupons, labeled Blue 1, 2, 3,..., and Red 1, 2, 3,... It is suboptimal for a resident to move luggage after a fellow resident of the same color. Utilize dynamic programming with states recording the current position, count of used Blue and Red residents, and current luggage holder. This yields  \\(\\mathrm{dp}[\\mathrm{pos}][b][r][\\mathrm{type}]\\) but results in an \\(O(N^3)\\) complexity, leading to time limit exceeded.\n\nStep 2:\nReduce state count by assuming residents more than two positions left don't touch luggage, resulting in \\(b \\geq b_{\\mathrm{left}}\\), \\(r \\geq r_{\\mathrm{left}}\\). Still results in \\(O(N^3)\\) complexity, leading to time exceedance.\n\nStep 3:\nFurther constrain by assuming residents over 20 positions to the right do not touch the luggage: \\(b \\leq b_{\\mathrm{left}} + 20\\), \\(r \\leq r_{\\mathrm{left}} + 20\\). The worst-case scenario involves 21 Blue at a single position, causing theoretical upper limit issues, but proven correct under \\(L \\leq 6 \\times 10^4\\).\n\nSample Implementation (C++):\nImplement the strategy noted above with an emphasis on memory and time management due to \\(O(N^3)\\) complexity states. The sample outlines initializing cumulative sums, initializing DP states, and processing state transitions to determine the minimum cost of operations involving agents and positions.\n\n[Code Example Not Included for Brevity]\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Score:** 475 points\n\n**Problem Statement**\n\nIn the nation of Atcoder, there are \\( N \\) cities numbered from 1 to \\( N \\), and \\( M \\) trains numbered from 1 to \\( M \\). Train \\( i \\) departs from city \\( A_i \\) at time \\( S_i \\) and arrives at city \\( B_i \\) at time \\( T_i \\).\n\nGiven a positive integer \\( X_1 \\), find a way to determine non-negative integers \\( X_2, \\ldots, X_M \\) that satisfy the following condition while minimizing the value of \\( X_2 + \\ldots + X_M \\).\n\n**Condition:**\n\nFor all pairs \\( (i, j) \\) satisfying \\( 1 \\leq i, j \\leq M \\), if \\( B_i = A_j \\) and \\( T_i \\leq S_j \\), then \\( T_i + X_i \\leq S_j + X_j \\).\n\nIn other words, for any pair of trains that were originally possible to transfer between, it must still be possible to transfer even after delaying the departure and arrival times of each train \\( i \\) by \\( X_i \\).\n\nIt can be proved that there is a unique way to set \\( X_2, \\ldots, X_M \\) with the minimum possible value of \\( X_2 + \\ldots + X_M \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( A_i \\neq B_i \\)\n- \\( 0 \\leq S_i < T_i \\leq 10^9 \\)\n- \\( 1 \\leq X_1 \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M X_1\nA_1 B_1 S_1 T_1\n\u22ee\nA_M B_M S_M T_M\n```\n\n**Output**\n\nPrint \\( X_2, \\ldots, X_M \\) that satisfy the condition with the minimum possible sum, in that order, separated by spaces.\n\n**Sample Input 1**\n\n```\n3 6 15\n1 2 10 20\n1 2 20 30\n2 3 25 40\n2 3 35 50\n3 1 15 30\n3 1 45 60\n```\n\n**Sample Output 1**\n\n```\n0 10 0 0 5\n```\n\n**Explanation**\n\nThe arrival of train 1 from city 1 to 2 is delayed by 15 and becomes time 35. To allow transfer from train 1 to 3 in city 2, the departure of train 3 is delayed by 10, making it depart at time 35 and arrive at time 50. Further, to allow transfer from train 3 to 6 in city 3, the departure of train 6 is delayed by 5, making it depart at time 50. Other trains can operate without delay while still allowing transfers between originally transferable trains, so \\( (X_2, X_3, X_4, X_5, X_6) = (0, 10, 0, 0, 5) \\) satisfies the condition. Moreover, there is no solution with a smaller sum that satisfies the condition, so this is the answer.\n\n**Sample Input 2**\n\n```\n10 9 100\n1 10 0 1\n10 2 1 100\n10 3 1 100\n10 4 1 100\n10 5 1 100\n10 6 1 100\n10 7 1 100\n10 8 1 100\n10 9 1 100\n```\n\n**Sample Output 2**\n\n```\n100 100 100 100 100 100 100 100\n```\n\n**Sample Input 3**\n\n```\n4 4 10\n1 2 0 1\n1 2 0 10\n2 3 100 200\n2 4 100 200\n```\n\n**Sample Output 3**\n\n```\n0 0 0\n```\n\nSolution:\n\nHere's the trimmed version focusing on the solution:\n\n---\n\n**E - Train Delay Editorial**\n\nLet us call \\(S_i\\) and \\(T_i\\) the scheduled departure and arrival, respectively, and \\(S_i+X_i\\) and \\(T_i+X_i\\) the actual departure and arrival. If you let a train depart later, you cannot make another depart earlier, so assume every train departs as early as possible. Whether a train \\(i\\) can depart is affected by trains whose scheduled arrival is prior to the departure of train \\(i\\). Therefore, processing trains in order of their scheduled times is effective.\n\nSort the \\(2M\\) departure/arrival events in ascending order:\n\n- When train \\(i\\) departs, find \\(X_i\\) based on the actual arrivals to station \\(A_i\\) for trains processed so far.\n- When train \\(i\\) arrives, record the actual arrival to station \\(B_i\\) based on \\(X_i\\).\n\nThese steps can be done in \\(O(1)\\) time by managing for each station the latest actual arrival of the trains processed so far. If departure and arrival occur simultaneously, process arrivals first.\n\n```python\nN, M, X = map(int, input().split())\nA, B, S, T = zip(*[tuple(map(int, input().split())) for _ in range(M)])\n\nevent = sorted([(S[i], 1, i) for i in range(M)] + [(T[i], 0, i) for i in range(M)])\n\nans = [0] * M\nans[0] = X\n\nstation = [0] * (N + 1)\nfor t, f, i in event:\n  if f:\n    if i:\n      ans[i] = max(0, station[A[i]] - t)\n  else:\n    station[B[i]] = max(station[B[i]], t + ans[i])\n\nprint(*ans[1:])\n```\n\n---\n \n\n", "problem_ids": ["abc371_e", "arc177_f", "abc368_e"]}, "abc312_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere are \\( N \\) people, numbered from 1 to \\( N \\). A competition was held among these \\( N \\) people, and they were ranked accordingly. The following information is given about their ranks:\n\n1. Each person has a unique rank.\n2. For each \\( 1 \\leq i \\leq M \\), if person \\( A_i \\) is ranked \\( x \\)-th and person \\( B_i \\) is ranked \\( y \\)-th, then \\( x - y = C_i \\).\n\nThe given input guarantees that there is at least one possible ranking that does not contradict the given information.\n\nYou need to answer \\( N \\) queries. The answer to the \\( i \\)-th query is determined as follows:\n- If the rank of person \\( i \\) can be uniquely determined, return that rank.\n- Otherwise, return \\(-1\\).\n\n### Constraints\n- \\( 2 \\leq N \\leq 16 \\)\n- \\( 0 \\leq M \\leq \\frac{N(N - 1)}{2} \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq N - 1 \\)\n- \\( (A_i, B_i) \\neq (A_j, B_j) \\) if \\( i \\neq j \\)\n- All input values are integers\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n### Output\nPrint the answers to the \\( 1 \\)-st, \\( 2 \\)-nd, ..., \\( N \\)-th queries in this order, separated by spaces.\n\n### Sample Input 1\n```\n5 2\n2 3 3\n5 4 3\n```\n\n### Sample Output 1\n```\n3 -1 -1 -1 -1\n```\n\nExplanation: Let \\( X_i \\) be the rank of person \\( i \\). The possible rankings could be \\( (3, 4, 1, 2, 5) \\) or \\( (3, 5, 2, 1, 4) \\). Therefore, only the rank of person 1 is uniquely determined as 3.\n\n### Sample Input 2\n```\n3 0\n```\n\n### Sample Output 2\n```\n-1 -1 -1\n```\n\n### Sample Input 3\n```\n8 5\n6 7 3\n8 1 7\n4 5 1\n7 2 1\n6 2 4\n```\n\n### Sample Output 3\n```\n1 -1 -1 -1 -1 -1 -1 8\n```\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 352\n\nConsider a \\(N\\)-vertex \\(M\\)-edge graph whose \\(i\\)-th edge connects vertex \\(A_i\\) and vertex \\(B_i\\). By the constraints, we can take an integer sequence \\(D = (D_1, D_2, \\ldots, D_N)\\) such that \\(D_{A_i} - D_{B_i} = C_i\\) for each \\(i\\). This sequence can be obtained by appropriately performing DFS (Depth-First Search) or BFS (Breadth-First Search) on the graph defined above. The sequence of person \\(i\\)\u2019s rank \\(X_i\\), collectively written as \\(X = (X_1, X_2, \\ldots, X_N)\\), is limited to permutations of \\((1,2,\\ldots, N)\\) such that:\n\n\\(X_i = D_i + v\\), where \\(v\\) is an arbitrary integer taken for each connected component and \\(i\\) is any of the vertices in it.\n\nWe try to respond to the query per connected component. When finding the answer to the \\(i\\)-th query, we perform a bit DP (Dynamic Programming) that places connected components not containing vertex \\(i\\). Specifically, maintain boolean values \\(dp_{x,y}\\) that represent whether the vertices in the first \\(x\\) connected components may correspond to the set of ranks \\(y\\). Since there are \\(O(N)\\) pairs of possible tuples of rank for each connected component, the DP above costs \\(O(N^2 2^N)\\) time naively, or \\(O(N 2^N)\\) time if you use the property that the value of \\(x\\) uniquely determines the popcount of \\(y\\). Therefore, the problem has been solved in a total of \\(O(N^2 2^N)\\) time.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 350 points\n\n**Problem Statement**\n\nYou are given a string \\( S \\) of length \\( N \\). You are also given \\( Q \\) queries, which you should process in order.\n\nThe \\( i \\)-th query is as follows:\n- Given an integer \\( X_i \\) and a character \\( C_i \\), replace the \\( X_i \\)-th character of \\( S \\) with \\( C_i \\). Then, print the number of times the string \"ABC\" appears as a substring in \\( S \\).\n\nHere, a **substring** of \\( S \\) is a string obtained by deleting zero or more characters from the beginning and zero or more characters from the end of \\( S \\). For example, \"ab\" is a substring of \"abc\", but \"ac\" is not a substring of \"abc\".\n\n**Constraints**\n\n- \\( 3 \\le N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le Q \\le 2 \\times 10^5 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of uppercase English letters.\n- \\( 1 \\le X_i \\le N \\)\n- \\( C_i \\) is an uppercase English letter.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN Q\nS\nX_1 C_1\nX_2 C_2\n\\vdots\nX_Q C_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (1 \u2264 \\( i \\) \u2264 \\( Q \\)) should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n```\n7 4\nABCDABC\n4 B\n3 A\n5 C\n4 G\n```\n\n**Sample Output 1**\n```\n2\n1\n1\n0\n```\n\nAfter processing each query, \\( S \\) becomes as follows:\n- After the first query: \\( S = \\) \"ABCBABC\". In this string, \"ABC\" appears twice as a substring.\n- After the second query: \\( S = \\) \"ABABABC\". In this string, \"ABC\" appears once as a substring.\n- After the third query: \\( S = \\) \"ABABCBC\". In this string, \"ABC\" appears once as a substring.\n- After the fourth query: \\( S = \\) \"ABAGCBC\". In this string, \"ABC\" appears zero times as a substring.\n\n**Sample Input 2**\n```\n3 3\nABC\n1 A\n2 B\n3 C\n```\n\n**Sample Output 2**\n```\n1\n1\n1\n```\n\nThere are cases where \\( S \\) does not change through processing a query.\n\n**Sample Input 3**\n```\n15 10\nBBCCBCACCBACACA\n9 C\n11 B\n5 B\n11 B\n4 A\n8 C\n8 B\n5 B\n7 B\n14 B\n```\n\n**Sample Output 3**\n```\n0\n0\n0\n0\n1\n1\n2\n2\n1\n1\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nC - Count ABC Again Editorial by en_translator\n\nIf you ignore the constraints, the following solution is valid:\n\nModify the \\(X_i\\)-th character of \\(S\\) to \\(C_i\\). Inspect the \\((N-2)\\) length-\\(3\\) substrings of \\(S\\), check if each coincides with ABC, and print the number of such substrings.\n\nHowever, \\(N\\) and \\(Q\\) can become as large as \\(2\\times 10^5\\), so this solution would result in TLE (Time Limit Exceeded). Now notice that modifying one character of \\(S\\) changes at most three length-\\(3\\) substrings of \\(S\\). For example, suppose that \\(S=\\) ABCDEFGHI has become \\(S=\\) ABCZEFGI. Before the modification, the length-\\(3\\) substrings of \\(S\\) were:\n\nABC, BCD, CDE, DEF, EFG, FGH, GHI.\n\nAfter the modification, it has become:\n\nABC, BCZ, CZE, ZEF, EFG, FGH, GHI.\n\nAmong them, only three substrings have changed. In general, at most three length-\\(3\\) substrings will change. Therefore, it is sufficient to inspect only three substrings that possibly changes, count the number of ABC before and after modifications, and find the answer after the modification based on the difference and the count before the modification. The complexity is \\(O(N+Q)\\).\n\nSample code (Python3)\n```python\nN, Q = map(int, input().split())\nS = list(input())\nans = 0\nfor i in range(N - 2):\n    if S[i] == \"A\" and S[i + 1] == \"B\" and S[i + 2] == \"C\":\n        ans += 1\nfor _ in range(Q):\n    t, c = input().split()\n    t = int(t) - 1\n    for k in range(3):\n        idx = t - k\n        if 0 <= idx and idx + 2 < N:\n            if S[idx] == \"A\" and S[idx + 1] == \"B\" and S[idx + 2] == \"C\":\n                ans -= 1\n    S[t] = c\n    for k in range(3):\n        idx = t - k\n        if 0 <= idx and idx + 2 < N:\n            if S[idx] == \"A\" and S[idx + 1] == \"B\" and S[idx + 2] == \"C\":\n                ans += 1\n    print(ans)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc361_a", "abc352_f", "abc372_c"]}, "abc312_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nMr. AtCoder has created a device consisting of \\(N\\) small light bulbs arranged in a row from left to right, and two switches A and B. Each light bulb can be in one of two states: 0 (OFF) and 1 (ON). Pressing each switch causes the following:\n\n- Pressing switch A turns the leftmost light bulb in the 0 state into 1.\n- Pressing switch B turns the leftmost light bulb in the 1 state into 0.\n\nIf there is no applicable light bulb, you cannot press the switch.\n\nInitially, all light bulbs are in the 0 state. He wants the states of the light bulbs to be \\(S_1, S_2, \\dots, S_N\\) from left to right. Determine the order and number of times the switches should be pressed to achieve this. It is not necessary to minimize the number of presses, but it should be at most \\(10^6\\) so that the operations can finish in a realistic time. It can be proved that a solution exists under the constraints of this problem.\n\n**Constraints:**\n\n- \\(1 \\leq N \\leq 30\\)\n- Each of \\(S_1, S_2, \\dots, S_N\\) is 0 or 1.\n- Not all of \\(S_1, S_2, \\dots, S_N\\) are 0.\n- \\(N\\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1 S_2 \\dots S_N\n```\n\nNote that the second line is given as a string of length \\(N\\).\n\n**Output:**\n\nIf your solution presses the switches \\(m\\) times \\((1 \\leq m \\leq 10^6)\\) in the order \\(t_1, t_2, \\dots, t_m\\) (each being A or B), print these in the following format:\n\n```\nm\nt_1 t_2 \\dots t_m\n```\n\nThe second line should be printed as a string of length \\(m\\).\n\n**Sample Input 1:**\n\n```\n5\n01100\n```\n\n**Sample Output 1:**\n\n```\n4\nAAAB\n```\n\nThis sample output presents a solution that presses the switches in the order A, A, A, B. This sets the light bulbs to the desired states, as shown in the figure below:\n\nAlternatively, pressing switches in the order A, A, B, A, A, B also sets the light bulbs to the desired states. The following output corresponding to this solution would also be accepted:\n\n```\n6\nAABAAB\n```\n\nSolution:\n\n```\n        Editorial - B - Puzzle of Lamps\n\nFinding hints for the solution by trial and error:\nIn competitive programming, experimenting with cases like sample inputs can lead to clues for the solution. \n\nFor example, to change the state from 00000 to 01010:\n\n1. First, turn the fourth character into 1. Press A four times and B three times in order to change from 00000 to 00010.\n\n2. Next, turn the second character into 1. Press A twice and then B, which changes 00010 to 01010.\n\nSolution Strategy:\nTo turn only the \\(k\\)-th character into 1 from 000...0, press switch A \\(k\\) times in a row, then press switch B \\(k-1\\) times in a row. For multiple characters:\n- For \\(x_k\\)-th character, press A \\(x_k\\) times and B \\(x_k-1\\) times.\n- Repeat onwards for each \\(x_2, x_1,\\) etc.\n\nSample Python Implementation:\n```python\n# Input\nn = int(input())\ns = input()\n\n# Find the solution\nans = ''\nfor i in range(n-1, -1, -1):\n    if s[i] == '1':\n        ans += 'A' * (i+1) + 'B' * i\n\n# Output\nprint(len(ans))\nprint(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 350 points\n\n**Problem Statement:**\n\nA souvenir shop at AtCoder Land sells \\(N\\) boxes. The boxes are numbered from 1 to \\(N\\), and box \\(i\\) has a price of \\(A_i\\) yen and contains \\(A_i\\) pieces of candy. Takahashi wants to buy \\(M\\) out of the \\(N\\) boxes and give one box each to \\(M\\) people named 1, 2, ..., \\(M\\).\n\nHe wants to select the boxes such that:\n- For each \\(i = 1, 2, \\ldots, M\\), person \\(i\\) is given a box containing at least \\(B_i\\) pieces of candy.\n\nIt is not allowed to give more than one box to a single person or to give the same box to multiple people.\n\nDetermine whether it is possible to buy \\(M\\) boxes that can satisfy the condition. If it is possible, compute the minimum total cost Takahashi needs to pay.\n\n**Constraints:**\n- \\(1 \\leq M \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq A_i, B_i \\leq 10^9\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_M\n```\n\n**Output:**\n\nIf it is possible to buy \\(M\\) boxes that can satisfy the condition, print the minimum total amount of money Takahashi needs to pay. Otherwise, print \\(-1\\).\n\n**Sample Input 1:**\n```\n4 2\n3 4 5 4\n1 4\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n*Takahashi can buy boxes 1 and 4, and give box 1 to person 1 and box 4 to person 2 to satisfy the condition. In this case, he needs to pay 7 yen in total, and it is impossible to satisfy the condition by paying less than 7 yen, so print 7.*\n\n**Sample Input 2:**\n```\n3 3\n1 1 1\n1000000000 1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n-1\n```\n\n**Sample Input 3:**\n```\n7 3\n2 6 8 9 5 1 11\n3 5 7\n```\n\n**Sample Output 3:**\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nConsider determining the box to give to people \\(1, 2, \\ldots, M\\) in this order. The following greedy strategy executed for each \\(i = 1, 2, \\ldots , M\\) in order is valid.\n\nTo person \\(i\\), give the undistributed box containing at least \\(B_i\\) candies with the smallest number of candies in it. (Let us call this strategy \\((\\bigstar)\\).)\n\nWe will assume that this solution is not optimal to deduce a contradiction. Take an optimal solution. In this optimal solution, there is an \\(i\\) that violates the strategy \\((\\bigstar)\\). Take the minimum such \\(i\\). Let box \\(X\\) be the box that you would give to person \\(i\\) if you obey the strategy \\((\\bigstar)\\) up to \\(1,2,\\ldots, i-1, i\\). In the taken optimal solution, if box \\(X\\) is not given to anyone, then giving person \\(i\\) box \\(X\\) improves the solution, which contradicts the optimality. Thus you will give it to a person \\(j\\). Consider swapping the boxes to give to person \\(i\\) and to person \\(j\\). This operation keeps optimality, but the minimum \\(i\\) that violates \\((\\bigstar)\\) strictly increases, so repeating this yields a contradiction. Hence, the greedy algorithm has been justified.\n\nTherefore, it is sufficient to simulate this greedy algorithm fast enough. This can be done by using a data structure like `sortedcontainers.SortedList` in Python, or using the sliding window trick by using the fact that \\(A\\) and \\(B\\) can be sorted without changing the answer.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement (Score: 650 points)**\n\nWe call a positive integer \\( n \\) a \"good integer\" if and only if the sum of its positive divisors is divisible by 3. You are given two positive integers \\( N \\) and \\( M \\). Find the number, modulo 998244353, of length-\\( M \\) sequences \\( A \\) of positive integers such that the product of the elements in \\( A \\) is a good integer not exceeding \\( N \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^{10} \\)\n- \\( 1 \\leq M \\leq 10^5 \\)\n- \\( N \\) and \\( M \\) are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n10 1\n```\n\n**Sample Output 1**\n\n```\n5\n```\n\nThere are five sequences that satisfy the conditions:\n\n- (2)\n- (5)\n- (6)\n- (8)\n- (10)\n\n**Sample Input 2**\n\n```\n4 2\n```\n\n**Sample Output 2**\n\n```\n2\n```\n\nThere are two sequences that satisfy the conditions:\n\n- (1, 2)\n- (2, 1)\n\n**Sample Input 3**\n\n```\n370 907\n```\n\n**Sample Output 3**\n\n```\n221764640\n```\n\n**Sample Input 4**\n\n```\n10000000000 100000\n```\n\n**Sample Output 4**\n\n```\n447456146\n```\n\nSolution:\n\n```python\n# Here is the rewritten editorial with Python code:\n\n# Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\n# G - Divisible by 3 Editorial\n\n# This problem can be solved by finding a prefix sum of a multiplicative function. \n# A function f(n) is multiplicative if f(ab) = f(a) f(b) for all positive integers gcd(a, b) = 1.\n\n# Given a multiplicative function f(n), evaluate:\n# sum(1 <= n <= N) f(n).\n\n# **Facts and Problem Rephrasing:**\n\n# 1. sigma(n), the sum of the divisors of n, is multiplicative as per the formula:\n#    sigma(n) = prod(i=1 to k) (1 + p_i + ... + p_i^e_i)\n\n# 2. g(n), the number of length-M sequences of positive integers such that their product is M, is multiplicative:\n#    g(n) = prod(i=1 to k) comb(e_i + M - 1, M - 1)\n\n# Original problem:\n# sum(1 <= n <= N, sigma(n) % 3 = 0) g(n)\n\n# Define:\n# h(n) = \n# if sigma(n) % 3 == 0:\n#     0\n# else:\n#     g(n)\n\n# Rephrased Problem:\n# sum(n=1 to N) (g(n) - h(n))\n\n# Final expression:\n# sum(n=1 to N) g(n) - sum(n=1 to N) h(n)\n\n# There are efficient algorithms to compute these prefix sums:\n\n# **Lucy DP:**\n# Define:\n# F(n) = sum(1 <= m <= n) f(m),\n# F_prime(n) = sum(1 <= p <= n, p: prime) f(p),\n\n# Evaluate F_prime(n) for all n in Q_N using a dynamic programming approach, Lucy DP.\n\n# **Black Algorithm and Min_25 sieve:**\n# Evaluate F(N) using F_prime(n) results.\n\n# Black Algorithm: Uses a tree structure to compute F(N) leveraging the multiplicativity of the function.\n\n# Min_25 Sieve: Offers a more efficient approach with complexity O(N^(2/3)).\n\n# By implementing Lucy DP and one of the other methods, the problem is solved efficiently with complexity O(N^(3/4)/log N) or O(N^(1 - epsilon)).\n\n# **Advanced Topics:**\n\n# More efficient algorithms, like those by zhoukangyang (O(sqrt(N))) and Zhenting Zhu (Theta (N^(2/3) / (log N)^(4/3))), exist.\n# Other algorithms like Dujiao sieve or PowerfulNumber sieve can be used under specific conditions.\n```\n\n \n\n", "problem_ids": ["arc177_b", "abc358_d", "abc370_g"]}, "abc312_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 450 points\n\n## Problem Statement\n\nThere are \\( N \\) islands and \\( M \\) bidirectional bridges connecting two islands. The islands and bridges are numbered \\( 1, 2, \\ldots, N \\) and \\( 1, 2, \\ldots, M \\), respectively. Bridge \\( i \\) connects islands \\( U_i \\) and \\( V_i \\), and the time it takes to cross it in either direction is \\( T_i \\). No bridge connects an island to itself, but it is possible for two islands to be directly connected by more than one bridge. One can travel between any two islands using some bridges.\n\nYou are given \\( Q \\) queries, so answer each of them. The \\( i \\)-th query is as follows:\n\n- You are given \\( K_i \\) distinct bridges: bridges \\( B_{i,1}, B_{i,2}, \\ldots, B_{i,K_i} \\).\n- Find the minimum time required to travel from island \\( 1 \\) to island \\( N \\) using each of these bridges at least once.\n- Only consider the time spent crossing bridges.\n- You can cross the given bridges in any order and in any direction.\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 400 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq T_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 3000 \\)\n- \\( 1 \\leq K_i \\leq 5 \\)\n- \\( 1 \\leq B_{i,1} < B_{i,2} < \\cdots < B_{i,K_i} \\leq M \\)\n- All input values are integers.\n- It is possible to travel between any two islands using some bridges.\n\n## Input\n\nThe input is given in the following format:\n```\nN M\nU_1 V_1 T_1\nU_2 V_2 T_2\n\u22ee\nU_M V_M T_M\nQ\nK_1\nB_{1,1} B_{1,2} \u22ef B_{1,{K_1}}\nK_2\nB_{2,1} B_{2,2} \u22ef B_{2,{K_2}}\n\u22ee\nK_Q\nB_{Q,1} B_{Q,2} \u22ef B_{Q,{K_Q}}\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq Q \\)) should contain the answer to the \\( i \\)-th query as an integer.\n\n## Sample Input 1\n\n```\n3 5\n1 2 10\n1 3 20\n1 3 30\n2 3 15\n2 3 25\n2\n1\n1\n2\n3 5\n```\n\n## Sample Output 1\n\n```\n25\n70\n```\n\nExplanation:\n- For the first query, the minimum time to travel from island 1 to island 3 using bridge 1 is achieved by using bridge 1 to move from island 1 to island 2, then bridge 4 to move from island 2 to island 3. The time taken is 10 + 15 = 25.\n- For the second query, the minimum time to travel from island 1 to island 3 using both bridges 3 and 5 is achieved by using bridge 3 to move from island 1 to island 3, then using bridge 5 to move to island 2, and finally bridge 4 to return to island 3. The time taken is 30 + 25 + 15 = 70.\n\n## Sample Input 2\n\n```\n6 6\n1 5 1\n2 5 1\n2 4 1\n3 4 1\n3 6 1\n1 6 1\n2\n5\n1 2 3 4 5\n1\n5\n```\n\n## Sample Output 2\n\n```\n5\n3\n```\n\nRemarks: You can cross the specified bridges in either direction.\n\n## Sample Input 3\n\n```\n5 5\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4 5 1000000000\n1 5 1000000000\n1\n1\n3\n```\n\n## Sample Output 3\n\n```\n4000000000\n```\n\nNote: The answer may not fit in a 32-bit integer.\n\nSolution:\n\n```python\nimport itertools\n\nN = 400\nM = int(2e5)\nINF = int(1e15)\n\nn = 0\nu = [0] * M\nv = [0] * M\nt = [0] * M\nd = [[0 if i == j else INF for j in range(N)] for i in range(N)]\nk = 0\na = []\n\ndef solve():\n    ans = INF\n    dp = [[0] * 2 for _ in range(5)]\n    b = list(range(k))\n    for perm in itertools.permutations(b):\n        dp[0][0] = d[0][v[a[perm[0]]]] + t[a[perm[0]]]\n        dp[0][1] = d[0][u[a[perm[0]]]] + t[a[perm[0]]]\n        for i in range(k - 1):\n            dp[i + 1][0] = min(dp[i][0] + d[u[a[perm[i]]]][v[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][v[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n            dp[i + 1][1] = min(dp[i][0] + d[u[a[perm[i]]]][u[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][u[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n        ans = min(ans, dp[k-1][0] + d[u[a[perm[k-1]]]][n-1])\n        ans = min(ans, dp[k-1][1] + d[v[a[perm[k-1]]]][n-1])\n    return ans\n\ndef main():\n    global n, k\n    m, q = map(int, input().split())\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d[i][j] = INF\n\n    for i in range(m):\n        u[i], v[i], t[i] = map(int, input().split())\n        u[i] -= 1\n        v[i] -= 1\n        d[u[i]][v[i]] = min(d[u[i]][v[i]], t[i])\n        d[v[i]][u[i]] = min(d[v[i]][u[i]], t[i])\n\n    for i1 in range(n):\n        for i0 in range(n):\n            for i2 in range(n):\n                d[i0][i2] = min(d[i0][i2], d[i0][i1] + d[i1][i2])\n    \n    for _ in range(q):\n        k = int(input())\n        a.clear()\n        for _ in range(k):\n            x = int(input())\n            a.append(x-1)\n        print(solve())\n\nif __name__ == '__main__':\n    main()\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n## Problem Statement\n\nAn election is being held with \\( N \\) candidates numbered \\( 1, 2, \\ldots, N \\). There are \\( K \\) votes, some of which have been counted so far. Up until now, candidate \\( i \\) has received \\( A_i \\) votes.\n\nAfter all ballots are counted, candidate \\( i \\) (\\( 1 \\leq i \\leq N \\)) will be elected if and only if the number of candidates who have received more votes than them is less than \\( M \\). There may be multiple candidates elected.\n\nFor each candidate, find the minimum number of additional votes they need from the remaining ballots to guarantee their victory regardless of how the other candidates receive votes. Formally, solve the following problem for each \\( i = 1,2,\\ldots,N \\).\n\nDetermine if there is a non-negative integer \\( X \\) not exceeding \\( K - \\displaystyle{\\sum_{i=1}^{N}} A_i \\) satisfying the following condition. If it exists, find the minimum possible such integer.\n\n- If candidate \\( i \\) receives \\( X \\) additional votes, then candidate \\( i \\) will always be elected.\n\n### Constraints\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq K \\leq 10^{12} \\)\n- \\( 0 \\leq A_i \\leq 10^{12} \\)\n- \\( \\displaystyle{\\sum_{i=1}^{N} A_i} \\leq K \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nLet \\( C_i \\) be the minimum number of additional votes candidate \\( i \\) needs from the remaining ballots to guarantee their victory regardless of how other candidates receive votes. Print \\( C_1, C_2, \\ldots, C_N \\) separated by spaces.\n\nIf candidate \\( i \\) has already secured their victory, then let \\( C_i = 0 \\). If candidate \\( i \\) cannot secure their victory under any circumstances, then let \\( C_i = -1 \\).\n\n### Sample Input 1\n\n```\n5 2 16\n3 1 4 1 5\n```\n\n### Sample Output 1\n\n```\n2 -1 1 -1 0\n```\n\n14 votes have been counted so far, and 2 votes are left. The \\( C \\) to output is \\((2, -1, 1, -1, 0)\\). For example:\n- Candidate 1 can secure their victory by obtaining 2 more votes, while not by obtaining 1 more vote. Thus, \\( C_1 = 2 \\).\n- Candidate 2 can never (even if they obtain 2 more votes) secure their victory, so \\( C_2 = -1 \\).\n\n### Sample Input 2\n\n```\n12 1 570\n81 62 17 5 5 86 15 7 79 26 6 28\n```\n\n### Sample Output 2\n\n```\n79 89 111 117 117 74 112 116 80 107 117 106\n```\n\nSolution:\n\n```python\nfrom itertools import accumulate\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    rem = k - sum(a)\n\n    if n == m:\n        print(' '.join(['0'] * n))\n        return\n\n    ord = list(range(n))\n    ord.sort(key=lambda i: a[i])\n    b = sorted(a)\n    sumb = [0] + list(accumulate(b))\n\n    ans = [-1] * n\n    for i in range(n):\n        l, r = -1, rem + 1\n        while r - l > 1:\n            mid = (l + r) // 2\n            rid = next((idx for idx, val in enumerate(b) if val >= b[i] + mid + 1), n)\n            lid = n - m - (1 if i >= n - m else 0)\n            cnt = 0\n            if rid > lid:\n                cnt += (rid - lid) * (b[i] + mid + 1) - (sumb[rid] - sumb[lid])\n            if lid <= i < rid:\n                cnt -= 1\n            else:\n                cnt += mid\n            if cnt > rem:\n                r = mid\n            else:\n                l = mid\n        ans[ord[i]] = -1 if l == rem else r\n\n    print(' '.join(map(str, ans)))\n\nmain()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nTakahashi and Aoki are playing a game using \\(N\\) cards. The front side of the \\(i\\)-th card has \\(A_i\\) written on it, and the back side has \\(B_i\\) written on it. Initially, the \\(N\\) cards are laid out on the table. With Takahashi going first, the two players take turns performing the following operation:\n\n- Choose a pair of cards from the table such that either the numbers on their front sides are the same or the numbers on their back sides are the same, and remove these two cards from the table. If no such pair of cards exists, the player cannot perform the operation.\n\nThe player who is first to be unable to perform the operation loses, and the other player wins. Determine who wins if both players play optimally.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 18\\)\n- \\(1 \\leq A_i, B_i \\leq 10^9\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\n```\n\n**Output:**\n\nPrint `Takahashi` if Takahashi wins when both players play optimally, and `Aoki` otherwise.\n\n**Sample Input 1:**\n```\n5\n1 9\n2 5\n4 9\n1 4\n2 5\n```\n\n**Sample Output 1:**\n```\nAoki\n```\n\nIf Takahashi first removes:\n- the first and third cards: Aoki can win by removing the second and fifth cards.\n- the first and fourth cards: Aoki can win by removing the second and fifth cards.\n- the second and fifth cards: Aoki can win by removing the first and third cards.\n\nThese are the only three pairs of cards Takahashi can remove in his first move, and Aoki can win in all cases. Therefore, the answer is Aoki.\n\n**Sample Input 2:**\n```\n9\n3 2\n1 7\n4 1\n1 8\n5 2\n9 8\n2 1\n6 8\n5 2\n```\n\n**Sample Output 2:**\n```\nTakahashi\n```\n\nSolution:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nE - Remove Pairs Editorial by en_translator\n\nThere are \\(2^{N}\\) possible sets of cards on the table. It is sufficient to determine for each of them whether the first or second player will win if these cards are on the table right before the first player makes a move. This can be solved with a technique called bit DP. Let \\(dp[S]\\) = true if the first player will win if the cards in \\(S\\) are on the table right before the first player makes a move, and false otherwise. The transitions are as follows:\n\nFor a set \\(S\\) of cards, if \\(dp[S \\setminus \\{i,j\\}]\\) is false for some pair \\(i,j \\in S\\) such that \\(A_i=A_j\\) or \\(B_i=B_j\\), then \\(dp[S]\\) is true; otherwise, it is false.\n\nThe final answer is Takahashi if \\(dp[S]\\) for \\(S=\\{1,2,\\ldots,N\\}\\) is true, and Aoki otherwise. The number of states is \\(O(2^{N})\\) and each transition costs \\(O(N^{2})\\) time, so the total complexity is \\(O(2^{N} N^{2})\\), which is fast enough.\n\nSample code (Python):\n```python\ndef main():\n    n = int(input())\n    a = [0] * n\n    b = [0] * n\n    for i in range(n):\n        a[i], b[i] = map(int, input().split())\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n    for i in range(1, 1 << n):\n        f = False\n        for j in range(n):\n            for k in range(j + 1, n):\n                if (i >> j) & 1 and (i >> k) & 1:\n                    if (a[j] == a[k] or b[j] == b[k]) and dp[i ^ (1 << j) ^ (1 << k)] == 0:\n                        f = True\n        dp[i] = f\n    print(\"Takahashi\" if dp[-1] else \"Aoki\")\n\nmain()\n```\n```\n \n\n", "problem_ids": ["abc369_e", "abc373_e", "abc354_e"]}, "abc312_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) giants, each identified by an integer from 1 to \\( N \\). For each giant \\( i \\), when they stand on the ground, their shoulder height is \\( A_i \\) and their head height is \\( B_i \\).\n\nYou can arrange all the giants in a permutation \\( (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) and stack them one on top of another according to the following rules:\n\n1. Place giant \\( P_1 \\) on the ground. The shoulder height of giant \\( P_1 \\) from the ground is \\( A_{P_1} \\), and the head height is \\( B_{P_1} \\).\n2. Following this, for \\( i = 1, 2, \\ldots, N - 1 \\), place giant \\( P_{i+1} \\) on the shoulders of giant \\( P_i \\). If the shoulder height of giant \\( P_i \\) from the ground is \\( t \\), then the shoulder height of giant \\( P_{i+1} \\) from the ground is \\( t + A_{P_{i+1}} \\), and the head height is \\( t + B_{P_{i+1}} \\).\n\nThe goal is to determine the maximum possible head height from the ground of the topmost giant \\( P_N \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 200,000 \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq 1,000,000,000 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output:**\n\nPrint the maximum possible height of the head of the topmost giant from the ground.\n\n**Sample Input 1:**\n```\n3\n4 10\n5 8\n2 9\n```\n\n**Sample Output 1:**\n```\n18\n```\n\n*Explanation:* If the permutation \\( (P_1, P_2, P_3) = (2, 1, 3) \\) is chosen, the heights measured from the ground would be as follows:\n\n- Giant 2 will have a shoulder height of 5 and a head height of 8.\n- Giant 1 will be on top, having a shoulder height of 9 and a head height of 15.\n- Giant 3 will be on top, having a shoulder height of 11 and a head height of 18.\n\nThe maximum head height achievable with any arrangement of the giants is 18, and thus, 18 is printed.\n\n**Sample Input 2:**\n```\n5\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\n**Sample Output 2:**\n```\n5\n```\n\n**Sample Input 3:**\n```\n10\n690830957 868532399\n741145463 930111470\n612846445 948344128\n540375785 925723427\n723092548 925021315\n928915367 973970164\n563314352 832796216\n562681294 868338948\n923012648 954764623\n691107436 891127278\n```\n\n**Sample Output 3:**\n```\n7362669937\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\nThe height of the topmost giant\u2019s head when \\(P_N\\), i.e., when giant \\(i\\) is the topmost giant, is \\(B_i + \\sum_{j \\neq i}A_j\\). This can be expressed as \\(B_i - A_i + \\sum_{j = 1}^{N} A_j\\), and the answer is the maximum of this value for \\(i = 1, 2, \\ldots, N\\). Since \\(\\sum_{j = 1}^{N} A_j\\) is independent of \\(i\\), it is sufficient to find \\(\\max (B_i - A_i)\\). This can be computed using a for loop in a total of \\(O(N)\\) time.\n\nSample code:\n```python\nn = int(input())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nm = 0\nfor i in range(n):\n    m = max(m, b[i] - a[i])\nans = m + sum(a)\nprint(ans)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). Takahashi will perform the following operation exactly once:\n\n- Choose an integer \\( x \\) between 1 and \\( N \\), inclusive, and an arbitrary integer \\( y \\). Replace \\( A_x \\) with \\( y \\).\n\nFind the maximum possible length of a longest increasing subsequence (LIS) of \\( A \\) after performing the operation.\n\n**What is the longest increasing subsequence?**\n\nA subsequence of a sequence \\( A \\) is a sequence that can be derived from \\( A \\) by extracting some elements without changing the order.\n\nA longest increasing subsequence of a sequence \\( A \\) is a longest subsequence of \\( A \\) that is strictly increasing.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n\n```\n4\n3 2 2 4\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n*Explanation:*\n\nThe length of a LIS of the given sequence \\( A \\) is 2. For example, if you replace \\( A_1 \\) with 1, the length of a LIS of \\( A \\) becomes 3, which is the maximum.\n\n**Sample Input 2:**\n\n```\n5\n4 5 3 6 7\n```\n\n**Sample Output 2:**\n\n```\n4\n```\n\nSolution:\n\n```python\nimport sys\n\nclass RangeMaxSegmentTree:\n    def __init__(self, size, initial_value):\n        self.size = size\n        self.data = [initial_value] * (2 * size)\n        self.initial_value = initial_value\n\n    def update(self, index, value):\n        index += self.size\n        self.data[index] = value\n        while index > 1:\n            index //= 2\n            self.data[index] = max(self.data[2 * index], self.data[2 * index + 1])\n\n    def calc_max(self, left, right):\n        left += self.size\n        right += self.size\n        max_value = self.initial_value\n        while left < right:\n            if left % 2 == 1:\n                max_value = max(max_value, self.data[left])\n                left += 1\n            if right % 2 == 1:\n                right -= 1\n                max_value = max(max_value, self.data[right])\n            left //= 2\n            right //= 2\n        return max_value\n\ndef longest_increasing_subsequence(A):\n    N = len(A)\n    dp = [[-float('inf')] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, N + 1):\n        max_value = 0\n        for j in range(0, A[i-1]):\n            max_value = max(max_value, dp[i - 1][j])\n        dp[i][A[i-1]] = max_value + 1\n\n    max_lis_length = max(dp[N])\n    return max_lis_length\n\ndef longest_increasing_subsequence_with_segment_tree(A):\n    N = len(A)\n    dp = RangeMaxSegmentTree(N + 1, -float('inf'))\n    dp.update(0, 0)\n\n    for i in range(1, N + 1):\n        max_for_ai = dp.calc_max(0, A[i-1])\n        dp.update(A[i-1], max_for_ai + 1)\n\n    max_lis_length = max(dp.data[N + 1:])\n    return max_lis_length\n\n# Example array A for testing purposes\nA = [3, 10, 2, 1, 20]\nprint(\"LIS length using DP:\", longest_increasing_subsequence(A))\nprint(\"LIS length using segment tree:\", longest_increasing_subsequence_with_segment_tree(A))\n```\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence \\( A \\) of length \\( N \\). Freely choose exactly \\( K \\) elements from \\( A \\) and remove them, then concatenate the remaining elements in their original order to form a new sequence \\( B \\). Find the minimum possible value of this: the maximum value of \\( B \\) minus the minimum value of \\( B \\).\n\n**Constraints**\n\n- All inputs are integers.\n- \\( 1 \\le K < N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le A_i \\le 10^9 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n5 2\n3 1 5 4 9\n```\n\n**Sample Output 1**\n```\n2\n```\n\n**Sample Input 2**\n```\n6 5\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n8 3\n31 43 26 6 18 36 22 13\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Editorial - Denso Create Programming Contest 2024 (AtCoder Beginner Contest 361)\n\nRemoving \\(K\\) elements of \\(A\\) is equivalent to retaining \\((N-K)\\) elements to form \\(B\\). To minimize (maximum value of \\(B\\)) - (minimum value of \\(B\\)), it is optimal to retain the \\((N-K)\\) smallest elements among the elements of \\(A\\) greater than or equal to \\(A_x\\), the fixed minimum of \\(B\\). In other words, it is optimal to choose \\((N-K)\\) consecutive elements in \\(A\\) sorted in ascending order.\n\nSolution: \n1. Sort \\(A\\) such that \\(A_1 \\le A_2 \\le \\dots \\le A_N\\).\n2. The answer is the minimum of \\(A_{l+(N-K)-1} - A_l\\) for \\(1 \\le l \\le K+1\\).\n3. Implement with sorting and a for loop, with a total time complexity of \\(O(N \\log N)\\).\n\nSample code (Python3):\n\n```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\nres = int(2e9)\nfor i in range(k + 1):\n    res = min(res, a[i + (n - k) - 1] - a[i])\n\nprint(res)\n```\n \n\n", "problem_ids": ["abc352_c", "abc360_g", "abc361_c"]}, "abc312_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:  \nIn the \\( xy \\)-plane, there are three points \\( A(x_A, y_A) \\), \\( B(x_B, y_B) \\), and \\( C(x_C, y_C) \\) that are not collinear. Determine whether the triangle \\( ABC \\) is a right triangle.\n\nConstraints:  \n- \\( -1000 \\leq x_A, y_A, x_B, y_B, x_C, y_C \\leq 1000 \\)\n- The three points \\( A \\), \\( B \\), and \\( C \\) are not collinear.\n- All input values are integers.\n\nInput:  \nThe input is given from Standard Input in the following format:\n\n```\nx_A y_A  \nx_B y_B  \nx_C y_C  \n```\n\nOutput:  \nPrint `Yes` if the triangle \\( ABC \\) is a right triangle, and `No` otherwise.\n\nSample Input 1:  \n```\n0 0  \n4 0  \n0 3  \n```\n\nSample Output 1:  \n```\nYes\n```\n\nThe triangle \\( ABC \\) is a right triangle.\n\nSample Input 2:  \n```\n-4 3  \n2 1  \n3 4  \n```\n\nSample Output 2:  \n```\nYes\n```\n\nThe triangle \\( ABC \\) is a right triangle.\n\nSample Input 3:  \n```\n2 4  \n-3 2  \n1 -2  \n```\n\nSample Output 3:  \n```\nNo\n```\n\nThe triangle \\( ABC \\) is not a right triangle.\n\nSolution:\n\n```python\nxA, yA = map(int, input().split())\nxB, yB = map(int, input().split())\nxC, yC = map(int, input().split())\n\nAB2 = (xA - xB) ** 2 + (yA - yB) ** 2\nBC2 = (xB - xC) ** 2 + (yB - yC) ** 2\nCA2 = (xC - xA) ** 2 + (yC - yA) ** 2\n\nif AB2 + BC2 == CA2 or BC2 + CA2 == AB2 or CA2 + AB2 == BC2:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 650 points\n\nProblem Statement:\nThere is a special grid with \\( N \\) rows. (\\( N \\) is even.) The \\( i \\)-th row from the top has \\(\\left \\lceil \\frac{i}{2} \\right \\rceil \\times 2\\) cells from the left end. For example, when \\( N = 6 \\), the grid looks like the following:\n\nLet \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Each cell is either an empty cell or a wall cell. There are \\( M \\) wall cells, and the \\( i \\)-th wall cell is \\((a_i, b_i)\\). Here, \\((1, 1)\\) and \\((N, N)\\) are empty.\n\nStarting from \\((1, 1)\\), how many ways are there to reach \\((N, N)\\) by repeatedly moving right or down to an adjacent empty cell? Find the count modulo 998244353.\n\nConstraints:\n- \\( 2 \\leq N \\leq 2.5 \\times 10^5 \\)\n- \\( N \\) is even.\n- \\( 0 \\leq M \\leq 50 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- \\( 1 \\leq b_i \\leq \\left \\lceil \\frac{a_i}{2} \\right \\rceil \\times 2 \\)\n- \\((a_i, b_i) \\neq (1, 1)\\) and \\((a_i, b_i) \\neq (N, N)\\).\n- \\((a_i, b_i) \\neq (a_j, b_j)\\) if \\( i \\neq j \\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\na_1 b_1\na_2 b_2\n...\na_M b_M\n```\n\nOutput:\nPrint the number of ways to reach \\((N, N)\\) from \\((1, 1)\\) by repeatedly moving right or down to an adjacent empty cell, modulo 998244353.\n\nSample Input 1:\n```\n4 2\n2 1\n4 2\n```\nSample Output 1:\n```\n2\n```\nThere are two paths that satisfy the conditions of the problem:\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (3, 4) \\to (4, 4)\\)\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (4, 3) \\to (4, 4)\\)\n\nSample Input 2:\n```\n6 3\n2 1\n3 3\n4 2\n```\nSample Output 2:\n```\n0\n```\n\nSample Input 3:\n```\n100 10\n36 9\n38 5\n38 30\n45 1\n48 40\n71 52\n85 27\n86 52\n92 34\n98 37\n```\nSample Output 3:\n```\n619611437\n```\n\nSample Input 4:\n```\n100000 10\n552 24\n4817 255\n7800 954\n23347 9307\n28028 17652\n39207 11859\n48670 22013\n74678 53158\n75345 45891\n88455 4693\n```\nSample Output 4:\n```\n175892766\n```\n\nSolution:\n\nSure, here is the editorial with all code translated to Python3:\n\n```python\ndef g(a, b):\n    \"\"\"Calculate the number of shortest paths from a to b.\"\"\"\n    # This function implementation depends on the specific grid configuration\n    pass\n\ndef calculate_dp_and_x(wall_squares, grid_size):\n    \"\"\"Calculate dp values and the sought count X using the wall squares.\"\"\"\n    S = wall_squares\n    N, M = grid_size\n    \n    # Initialize dp with base values\n    w = [(1, 1)] + S + [(N, N)]\n    dp = [0] * (len(S) + 2)\n    dp[0] = 1\n    \n    # Fill dp array according to the derived relations\n    for i in range(1, len(S) + 2):\n        dp_i_sum = sum(g(w[j], w[i]) * dp[j] for j in range(i))\n        dp[i] = -dp_i_sum\n    \n    # Calculate the sought count X\n    X = -dp[len(S) + 1]\n    \n    return X\n\n# Example usage\noriginal_wall_squares = []  # Replace with actual coordinates of original wall squares\ncalculate_dp_and_x(original_wall_squares, (N, M))\n```\n\nNote: In the provided code, `g(a, b)` is a placeholder function that needs actual implementation based on the specific problem constraints. The function `calculate_dp_and_x` calculates the dp values and the sought count `X` using the dynamic programming approach described in the editorial.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nIn the Kingdom of AtCoder, residents are required to shout their love for takoyaki at \\( A \\) o'clock every day.\n\nTakahashi, who lives in the Kingdom of AtCoder, goes to bed at \\( B \\) o'clock and wakes up at \\( C \\) o'clock every day (in the 24-hour clock). He can shout his love for takoyaki when he is awake, but cannot when he is asleep. Determine whether he can shout his love for takoyaki every day. Here, a day has 24 hours, and his sleeping time is less than 24 hours.\n\n**Constraints**\n- \\( 0 \\leq A, B, C < 24 \\)\n- \\( A \\), \\( B \\), and \\( C \\) are pairwise different.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can shout his love for takoyaki every day, and `No` otherwise.\n\n**Sample Input 1**\n```\n21 8 14\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Takahashi goes to bed at 8 o'clock and wakes up at 14 o'clock every day. He is awake at 21 o'clock, so he can shout his love for takoyaki every day. Therefore, print `Yes`.*\n\n**Sample Input 2**\n```\n0 21 7\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*Takahashi goes to bed at 21 o'clock and wakes up at 7 o'clock every day. He is not awake at 0 o'clock, so he cannot shout his love for takoyaki every day. Therefore, print `No`.*\n\n**Sample Input 3**\n```\n10 7 17\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 367 - Editorial\n\n**Problem Solution:**\n\nThe problem can be solved by employing casework based on whether the person is asleep at midnight. \n\n1. **If not asleep at midnight:**\n   - The person sleeps from \\(B\\) to \\(C\\) o\u2019clock. The answer is \"No\" if \\(A\\) o\u2019clock is between \\(B\\) and \\(C\\) (\\(B<A<C\\)). Otherwise, the answer is \"Yes\".\n\n2. **If asleep at midnight:**\n   - The person is awake from \\(C\\) to \\(B\\) o\u2019clock. The answer is \"Yes\" if \\(A\\) o\u2019clock is between \\(C\\) and \\(B\\) (\\(C<A<B\\)). Otherwise, the answer is \"No\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A and A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A and A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Alternative Approach:**\n\nTo avoid casework, use a while statement starting from \\(B\\) and increment hour by hour. If \\(A\\) is reached before \\(C\\), print \"No\". Otherwise, print \"Yes\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nnow = B\nwhile now != C:\n    if now == A:\n        print(\"No\")\n        exit()\n    now += 1\n    now %= 24\n\nprint(\"Yes\")\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc362_b", "abc357_g", "abc367_a"]}, "abc312_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) strings. Each \\( i \\)-th string \\( S_i \\) (\\(1 \\leq i \\leq N\\)) is either \"Takahashi\" or \"Aoki\". Determine how many times \\( S_i \\) is equal to \"Takahashi\".\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( N \\) is an integer.\n- Each \\( S_i \\) is \"Takahashi\" or \"Aoki\". (\\(1 \\leq i \\leq N\\))\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\n**Output**\n\nPrint the count of \\( i \\) such that \\( S_i \\) is equal to \"Takahashi\" as an integer in a single line.\n\n**Sample Input 1**\n```\n3\nAoki\nTakahashi\nTakahashi\n```\n\n**Sample Output 1**\n```\n2\n```\n*S_2* and *S_3* are equal to \"Takahashi\", while *S_1* is not. Therefore, print 2.\n\n**Sample Input 2**\n```\n2\nAoki\nAoki\n```\n\n**Sample Output 2**\n```\n0\n```\nIt is possible that no \\( S_i \\) is equal to \"Takahashi\".\n\n**Sample Input 3**\n```\n20\nAoki\nTakahashi\nTakahashi\nAoki\nAoki\nAoki\nAoki\nTakahashi\nAoki\nAoki\nAoki\nTakahashi\nTakahashi\nAoki\nTakahashi\nAoki\nAoki\nAoki\nAoki\nTakahashi\n```\n\n**Sample Output 3**\n```\n7\n```\n\nSolution:\n\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nA - Count Takahashi Editorial\n\n1. A naive solution  \nDefine an integer variable `ans` for the integer, initializing it with `0`.  \nReceive `N` from the standard input.  \nRepeat the following operation `N` times:  \n\n- Receive a string from the standard input.  \n- If the received string equals \"Takahashi\", add `1` to `ans`.  \n\nPrint the value `ans`.  \n\nSample code in Python:\n```python\nans = 0\nN = int(input())\nfor _ in range(N):\n    S = input()\n    if S == 'Takahashi':\n        ans += 1\nprint(ans)\n```\n\n2. A little tricky solution  \nThe answer to this problem equals the number of occurrences of 'T' in the input.  \n\nSample code in Python:\n```python\nprint(open(0).read().count('T'))\n```\n\nSample code in Python (translated from Haskell):\n```python\nprint(len(list(filter(lambda x: x == 'T', open(0).read()))))\n```\n\nSample code in Bash translated to Python:\n```python\nimport sys\nprint(sum(1 for line in sys.stdin if 'T' in line))\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou have \\( N \\) keys numbered \\( 1, 2, \\dots, N \\). Some of these are real keys, while the others are dummies. There is a door, Door X, into which you can insert any number of keys. Door X will open if and only if at least \\( K \\) real keys are inserted.\n\nYou have conducted \\( M \\) tests on these keys. The \\( i \\)-th test went as follows:\n- You inserted \\( C_i \\) keys \\( A_{i,1}, A_{i,2}, \\dots, A_{i,C_i} \\) into Door X.\n- The test result is represented by a single English letter \\( R_i \\).\n  - \\( R_i = \\text{o} \\) means that Door X opened in the \\( i \\)-th test.\n  - \\( R_i = \\text{x} \\) means that Door X did not open in the \\( i \\)-th test.\n\nThere are \\( 2^N \\) possible combinations of which keys are real and which are dummies. Among these, find the number of combinations that do not contradict any of the test results. It is possible that the given test results are incorrect and no combination satisfies the conditions. In such a case, report \\( 0 \\).\n\n**Constraints**\n- \\( N, M, K, C_i, \\text{ and } A_{i,j} \\) are integers.\n- \\( 1 \\le K \\le N \\le 15 \\)\n- \\( 1 \\le M \\le 100 \\)\n- \\( 1 \\le C_i \\le N \\)\n- \\( 1 \\le A_{i,j} \\le N \\)\n- \\( A_{i,j} \\neq A_{i,k} \\) if \\( j \\neq k \\).\n- \\( R_i \\) is \\( \\text{o} \\) or \\( \\text{x} \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M K\nC_1 A_{1,1} A_{1,2} \\dots A_{1,C_1} R_1\nC_2 A_{2,1} A_{2,2} \\dots A_{2,C_2} R_2\n\\vdots\nC_M A_{M,1} A_{M,2} \\dots A_{M,C_M} R_M\n```\n\n**Output**\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2 2\n3 1 2 3 o\n2 2 3 x\n```\n\n**Sample Output 1**\n```\n2\n```\n\nIn this input, there are three keys and two tests were conducted. Two correct keys are required to open Door X. In the first test, keys 1, 2, 3 were used, and Door X opened. In the second test, keys 2, 3 were used, and Door X did not open. There are two combinations of which keys are real and which are dummies that do not contradict any of the test results: Key 1 is real, key 2 is a dummy, and key 3 is real. Key 1 is real, key 2 is real, and key 3 is a dummy.\n\n**Sample Input 2**\n```\n4 5 3\n3 1 2 3 o\n3 2 3 4 o\n3 3 4 1 o\n3 4 1 2 o\n4 1 2 3 4 x\n```\n\n**Sample Output 2**\n```\n0\n```\n\nAs mentioned in the problem statement, the answer may be 0.\n\n**Sample Input 3**\n```\n11 4 9\n10 1 2 3 4 5 6 7 8 9 10 o\n11 1 2 3 4 5 6 7 8 9 10 11 o\n10 11 10 9 8 7 6 5 4 3 2 x\n10 11 9 1 4 3 7 5 6 2 10 x\n```\n\n**Sample Output 3**\n```\n8\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 356\n\n# C - Keys Editorial by en_translator:\n\n# By the constraints, the number of keys \\(N \\le 15\\), and the tests \\(M \\le 100\\). \n# There are \\(2^N\\) combinations of authenticities of the keys. We may perform the \\(M\\) tests \n# on all \\(2^N\\) combinations and count the number of proper combinations. \n# \\(2^N \\times M \\le 3.3 \\times 10^6\\) tests are required. \n# Even with \\(N\\) operations per test, the total number of operations is \\(5 \\times 10^7\\), which is fast enough. \n# We achieve this through bitwise enumeration by iterating over \\(i=0,1,\\dots,2^N-1\\). \n# The presence of bit \\(2^k\\) in \\(i\\) determines if the \\((k+1)\\)-th key is real or a dummy. \n# For more details, refer to relevant articles on bitwise enumeration.\n\n# Note that operations exceeding \\(N\\) per test might not meet the execution time limit. \n# Managing whether the \\(k\\)-th key was used limits operations per test to \\(N\\).\n\n# Sample code translated to Python:\nn, m, k = map(int, input().split())\nkey = [[0]*n for _ in range(m)]\nr = []\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c + 1):\n        a = data[j]\n        key[i][a-1] = 1\n    r.append(input().strip())\n\nres = 0\n\nfor i in range(1 << n):\n    tf = [0] * n\n    for j in range(n):\n        if i & (1 << j):\n            tf[j] = 1\n        else:\n            tf[j] = 0\n    jud = True\n    for j in range(m):\n        ck = 0\n        for p in range(n):\n            if key[j][p] == 1 and tf[p] == 1:\n                ck += 1\n        if ck >= k and r[j] == \"x\":\n            jud = False\n        if ck < k and r[j] == \"o\":\n            jud = False\n    if jud:\n        res += 1\n\nprint(res)\n\n# A faster approach using bitwise operations translated to Python:\nn, m, k = map(int, input().split())\nks = [0] * m\nr = [0] * m\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c+1):\n        a = data[j] - 1\n        ks[i] |= (1 << a)\n    s = input().strip()\n    if s == \"o\":\n        r[i] = 1\n    else:\n        r[i] = 0\n\nres = 0\n\nfor i in range(1 << n):\n    jud = True\n    for j in range(m):\n        ok = bin(i & ks[j]).count('1')\n        if ok >= k and r[j] == 0:\n            jud = False\n            break\n        if ok < k and r[j] == 1:\n            jud = False\n            break\n    if jud:\n        res += 1\n\nprint(res)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a permutation \\( P = (P_1, P_2, \\dots, P_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nA sequence of indices \\((i_1, i_2, \\dots, i_K)\\) of length \\( K \\) is called a **good index sequence** if it satisfies both of the following conditions:\n\n1. \\(1 \\leq i_1 < i_2 < \\dots < i_K \\leq N\\).\n2. The subsequence \\((P_{i_1}, P_{i_2}, \\dots, P_{i_K})\\) can be obtained by rearranging some consecutive \\( K \\) integers. Formally, there exists an integer \\( a \\) such that \\(\\{ P_{i_1}, P_{i_2}, \\dots, P_{i_K} \\} = \\{ a, a+1, \\dots, a+K-1 \\}\\).\n\nFind the minimum value of \\( i_K - i_1 \\) among all good index sequences. It can be shown that at least one good index sequence exists under the constraints of this problem.\n\n**Constraints**\n\n- \\(1 \\leq K \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq P_i \\leq N\\)\n- \\(P_i \\neq P_j\\) if \\(i \\neq j\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n**Output**\n\nPrint the minimum value of \\( i_K - i_1 \\) among all good index sequences.\n\n**Sample Input 1**\n\n```\n4 2\n2 3 1 4\n```\n\n**Sample Output 1**\n\n```\n1\n```\n\nThe good index sequences are \\((1, 2), (1, 3), (2, 4)\\). For example, \\((i_1, i_2) = (1, 3)\\) is a good index sequence because \\(1 \\leq i_1 < i_2 \\leq N\\) and \\((P_{i_1}, P_{i_2}) = (2, 1)\\) is a rearrangement of two consecutive integers 1, 2. Among these good index sequences, the smallest value of \\( i_K - i_1 \\) is for \\((1, 2)\\), which is \\(2-1=1\\).\n\n**Sample Input 2**\n\n```\n4 1\n2 3 1 4\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n\\(i_K - i_1 = i_1 - i_1 = 0\\) in all good index sequences.\n\n**Sample Input 3**\n\n```\n10 5\n10 1 6 8 7 2 5 9 3 4\n```\n\n**Sample Output 3**\n\n```\n5\n```\n\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 352\n\n# D - Permutation Subsequence Editorial, by en_translator\n\n# We will exhaustively enumerate the value \\(a\\) in the problem statement. For each \\(a=1,2,\\dots,N-K+1\\), \n# we will find the minimum \\(i_K-i_1\\) when choosing \\(i_1 < i_2 < \\dots < i_K\\) so that \n# \\(\\{P_{i_1},P_{i_2},\\dots,P_{i_K}\\}=\\{a,a+1,\\dots,a+K-1\\}\\).\n\n# Define \\(Q=(Q_1,Q_2,\\dots,Q_N)\\) by \\(Q_j=(\\) the value \\(i\\) such that \\(P_i=j)\\). \n# When \\(P\\) is a permutation of \\((1,2,\\dots,N)\\), so is \\(Q\\). \n# The objective can be rephrased as the difference between the maximum and minimum values among \\(Q_a,Q_{a+1},\\dots,Q_{a+K-1}\\).\n\n# Evaluate this value while iterating \\(a\\) in ascending order. The set \\(\\{Q_a,Q_{a+1},\\dots,Q_{a+K-1}\\}\\) changes by one element \n# as \\(a\\) increases by one. We need a data structure \\(D\\) that manages a set and supports:\n\n# - Insert one element into \\(D\\).\n# - Remove one element from \\(D\\).\n# - Retrieve the minimum and maximum element of \\(D\\).\n\n# A balanced binary search tree like `std::set` in C++ fulfills these requirements. For implementation using `std::set`,\n# see the sample code below. For other languages, refer to their documentation.\n\n# Sample code (Python3):\nfrom sortedcontainers import SortedSet\n\ndef main():\n    n, k = map(int, input().split())\n    q = [0] * n\n    for i in range(n):\n        p = int(input().strip())\n        p -= 1\n        q[p] = i\n    \n    st = SortedSet()\n    for i in range(k):\n        st.add(q[i])\n    \n    ans = st[-1] - st[0]\n    for i in range(k, n):\n        st.remove(q[i - k])\n        st.add(q[i])\n        ans = min(ans, st[-1] - st[0])\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc359_a", "abc356_c", "abc352_d"]}, "abc313_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given \\(N\\) strings \\(S_1, S_2, \\ldots, S_N\\) consisting of lowercase English letters and \\(N\\) positive integers \\(A_1, A_2, \\ldots, A_N\\).\n\nA subset \\(T\\) of \\(\\{1, 2, \\ldots, N\\}\\) is called a **good set** if there is no pair \\(i, j \\in T\\) (\\(i \\neq j\\)) such that \\(S_i\\) is a substring of \\(S_j\\).\n\nFind the maximum possible value of \\(\\sum_{i \\in T} A_i\\) for a good set \\(T\\).\n\n### What is a substring?\n\nA **substring** of a string \\(S\\) is a string obtained by deleting zero or more characters from the beginning and zero or more characters from the end of \\(S\\). For example, `ab` is a substring of `abc`, but `ac` is not a substring of `abc`.\n\n### Constraints\n\n- \\(1 \\leq N \\leq 100\\)\n- \\(S_i\\) is a string consisting of lowercase English letters.\n- \\(1 \\leq |S_i|\\)\n- \\(|S_1| + |S_2| + \\ldots + |S_N| \\leq 5000\\)\n- \\(1 \\leq A_i \\leq 10^9\\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1\nS_2\n.\n.\n.\nS_N\nA_1 A_2 ... A_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n4\natcoder\nat\ncoder\ncode\n5 2 3 4\n```\n\n### Sample Output 1\n\n```\n6\n```\n\nThe possible good sets \\(T\\) and their corresponding \\(\\sum_{i \\in T} A_i\\) are as follows:\n\n- \\(T = \\{1\\}\\): \\(\\sum_{i \\in T} A_i = 5\\)\n- \\(T = \\{2\\}\\): \\(\\sum_{i \\in T} A_i = 2\\)\n- \\(T = \\{3\\}\\): \\(\\sum_{i \\in T} A_i = 3\\)\n- \\(T = \\{4\\}\\): \\(\\sum_{i \\in T} A_i = 4\\)\n- \\(T = \\{2, 3\\}\\): \\(\\sum_{i \\in T} A_i = 5\\)\n- \\(T = \\{2, 4\\}\\): \\(\\sum_{i \\in T} A_i = 6\\)\n\nThe maximum among them is 6, so print 6.\n\n### Sample Input 2\n\n```\n10\nabcd\nabc\nab\na\nb\nc\nd\nab\nbc\ncd\n100 10 50 30 60 90 80 70 40 20\n```\n\n### Sample Output 2\n\n```\n260\n```\n\nSolution:\n\n        Editorial - Panasonic Programming Contest 2024 (AtCoder Beginner Contest 354)\n\nFor simplicity, assume \\(S_i \\neq S_j (i \\neq j)\\). Consider an \\(N\\)-vertex graph \\(G\\) with a directed edge from vertex \\(i\\) to vertex \\(j\\) if \\(S_i\\) is a substring of \\(S_j\\) for given \\(S_1, S_2, \\ldots, S_N\\). Then, \\(G\\) forms a DAG (Directed Acyclic Graph). Suppose each vertex has a weight of \\(A_1, A_2, \\ldots, A_n\\). The problem can be rephrased as follows: You are given a vertex-weighted \\(N\\)-vertex DAG \\(G\\). Choose some vertices without including a pair that has a path between them and find the maximum total weight of the chosen vertices.\n\nIgnoring weights, maximize the number of chosen vertices. If \\(G\\) has edges from vertex \\(i\\) \\(\\to\\) vertex \\(j\\) and vertex \\(j\\) \\(\\to\\) vertex \\(k\\), then it also has an edge from vertex \\(i\\) \\(\\to\\) vertex \\(k\\). Use Dilworth\u2019s theorem, which states that the size of a minimum path cover equals the size of a maximum independent set in such a DAG.\n\nFor an unweighted graph, find the size of a maximum independent set or a minimum path cover. The minimum path cover can be reduced to the maximum matching of a bipartite graph. Consider the \\(N\\)-vertex DAG \\(G\\) as a bipartite graph \\(H\\) with left vertices \\(1, 2, \\ldots, N\\) and right vertices \\(1', 2', \\ldots, N'\\). Then, \\(N - (\\text{maximum matching of }H) = (\\text{size of a minimum path cover of }G)\\). Thus, minimize the size of a path cover by maximizing the number of edges in it, corresponding to a maximum matching problem on the bipartite graph.\n\nFor the weighted problem, where we need the maximum total weight of the chosen vertices, set the maximum capacity of each edge \\(S \\to v\\) and \\(v' \\to T\\) to \\(A_v\\) and of \\(i \\to j'\\) to \\(\\infty\\). The solution is \\((\\sum A_i - (\\text{maximum flow of }S \\to T))\\). In implementation, handle edges between vertices \\(i\\) and \\(j\\) with identical strings by adding edges \\(i \\to j\\) if \\(S_i = S_j\\) and \\(i < j\\).\n\nTime complexity: Determine if \\(S_i\\) is a substring of \\(S_j\\) for all pairs \\(i, j\\) in \\(O(N^{2} + (\\sum |S_i|)^{2})\\), and find the maximum flow for a bipartite graph with \\(O(N)\\) vertices and \\(O(N^{2})\\) edges in \\(O(N^{4})\\), resulting in a total time complexity of \\(O(N^{4} + (\\sum |S_i|)^{2})\\).\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThe Republic of AtCoder consists of \\(L+1\\) islands aligned east-west, numbered \\(0\\) to \\(L\\) from west to east. The islands are connected by air routes, where for each \\(1 \\leq i \\leq L\\), there is a bidirectional air route between islands \\(i-1\\) and \\(i\\). Each air route is owned by company A or company J, and the route between islands \\(i-1\\) and \\(i\\) is owned by company \\(S_i\\).\n\nThe nation has \\(N\\) residents, numbered \\(1\\) to \\(N\\). Resident \\(i\\) is currently on island \\(X_i\\). Each resident has a coupon of one of the companies. Specifically, resident \\(i\\) has a coupon of company \\(C_i\\). With a coupon, a resident can take that company's routes for free any number of times, but taking a route of the other company costs 1 coin per trip.\n\nNow, there is a treasure chest on island 0. The residents want to cooperate to carry it to the capital, which is on island \\(L\\). Determine the minimum total number of coins required to achieve this goal. The residents can pass the treasure chest to each other, but not their coupons.\n\nConstraints:\n- \\(1 \\leq L \\leq 6 \\times 10^4\\)\n- \\(1 \\leq N \\leq 6 \\times 10^4\\)\n- \\(S_i \\ (1 \\leq i \\leq L)\\) is 'A' or 'J'.\n- \\(0 \\leq X_i \\leq L \\ (1 \\leq i \\leq N)\\)\n- \\(C_i \\ (1 \\leq i \\leq N)\\) is 'A' or 'J'.\n- \\(L, N, X_i\\) are integers.\n\nInput:\n- Input is given from Standard Input in the following format:\n  \\[\n  L \\, N \\\\\n  S_1 S_2 \\cdots S_L \\\\\n  X_1 \\, C_1 \\\\\n  X_2 \\, C_2 \\\\\n  \\vdots \\\\\n  X_N \\, C_N\n  \\]\n- Note that the second line is a string of length \\(L\\).\n\nOutput:\n- Print the answer.\n\nSample Input 1:\n```\n4 3\nAAJJ\n3 A\n1 J\n1 J\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation for Sample 1:\nTo carry the treasure chest to island 4 for a total of 2 coins, the following steps are taken:\n1. Resident 1 moves from island 3 to island 2, costing 1 coin as the route is not covered by the coupon.\n2. Resident 1 moves from island 2 to island 1, requiring no coins as the route is covered by the coupon.\n3. Resident 1 moves from island 1 to island 0, requiring no coins as the route is covered by the coupon.\n4. Resident 1 picks up the treasure chest.\n5. Resident 1 moves, carrying the treasure chest, from island 0 to island 1 without costing any coins as the route is covered by the coupon.\n6. Resident 1 passes the treasure chest to resident 2.\n7. Resident 2, with the treasure chest, moves from island 1 to island 2, costing 1 coin as the route is not covered by the coupon.\n8. Resident 2 moves with the treasure chest from island 2 to island 3, requiring no coins as the route is covered by the coupon.\n9. Resident 2 moves with the treasure chest from island 3 to island 4, requiring no coins as the route is covered by the coupon.\n\nSample Input 2:\n```\n8 3\nJJAAJJAJ\n2 A\n6 A\n8 J\n```\n\nSample Output 2:\n```\n6\n```\n\nSample Input 3:\n```\n8 6\nJJAAJJAJ\n2 A\n6 A\n8 J\n8 J\n8 J\n8 J\n```\n\nSample Output 3:\n```\n4\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 177 - F - Two Airlines Editorial\n\nStep 1:\nConsider the optimal movement strategy for residents with company A and J coupons, labeled Blue 1, 2, 3,..., and Red 1, 2, 3,... It is suboptimal for a resident to move luggage after a fellow resident of the same color. Utilize dynamic programming with states recording the current position, count of used Blue and Red residents, and current luggage holder. This yields  \\(\\mathrm{dp}[\\mathrm{pos}][b][r][\\mathrm{type}]\\) but results in an \\(O(N^3)\\) complexity, leading to time limit exceeded.\n\nStep 2:\nReduce state count by assuming residents more than two positions left don't touch luggage, resulting in \\(b \\geq b_{\\mathrm{left}}\\), \\(r \\geq r_{\\mathrm{left}}\\). Still results in \\(O(N^3)\\) complexity, leading to time exceedance.\n\nStep 3:\nFurther constrain by assuming residents over 20 positions to the right do not touch the luggage: \\(b \\leq b_{\\mathrm{left}} + 20\\), \\(r \\leq r_{\\mathrm{left}} + 20\\). The worst-case scenario involves 21 Blue at a single position, causing theoretical upper limit issues, but proven correct under \\(L \\leq 6 \\times 10^4\\).\n\nSample Implementation (C++):\nImplement the strategy noted above with an emphasis on memory and time management due to \\(O(N^3)\\) complexity states. The sample outlines initializing cumulative sums, initializing DP states, and processing state transitions to determine the minimum cost of operations involving agents and positions.\n\n[Code Example Not Included for Brevity]\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nIn the Kingdom of AtCoder, the eldest son is always given the name Taro. No one else is given the name Taro. The eldest son is the earliest born male child in each family.\n\nThere are \\(N\\) families in the Kingdom, and \\(M\\) babies were born. Before the \\(M\\) babies were born, none of the \\(N\\) families had had any babies.\n\nInformation about the babies is given in chronological order of their birth. The \\(i\\)-th baby born was born in family \\(A_i\\), and the baby is male if \\(B_i\\) is \\(M\\), and female if it is \\(F\\).\n\nDetermine for each of the \\(M\\) babies whether the name given is Taro.\n\nConstraints:\n- \\(1 \\leq N, M \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- \\(B_i\\) is \\(M\\) or \\(F\\).\n- All numbers in the input are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\nOutput:\nPrint \\(M\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq M)\\) should contain `Yes` if the name given to the \\(i\\)-th baby is Taro, and `No` otherwise.\n\nSample Input 1:\n```\n2 4\n1 M\n1 M\n2 F\n2 M\n```\n\nSample Output 1:\n```\nYes\nNo\nNo\nYes\n```\n\nExplanation of Sample Output 1:\n- The first baby is the earliest born boy in family 1, so he is named Taro.\n- The second baby is not the earliest born boy in family 1, so he is not named Taro.\n- The third baby is a girl, so she is not named Taro.\n- The fourth baby is the earliest born **boy** in family 2, so he is named Taro. Note that the third baby is also born in family 2, but it is the earliest born boy who is named Taro.\n\nSample Input 2:\n```\n4 7\n2 M\n3 M\n1 F\n4 F\n4 F\n1 F\n2 M\n```\n\nSample Output 2:\n```\nYes\nYes\nNo\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Beginner Contest 371\n\nB - Taro Editorial by en_translator\n\nMaintain a flag to manage whether each family had had Taro already. The flags are initialized with False. Inspect the babies in order. If the baby is a girl, print No, and nothing more is required. If the baby is a boy, check the flag of his family. If the flag is False, print Yes, and set the flag to True. If the flag is already True, print No. The operations so far can be implemented with for statements, if statements, and arrays.\n\nSample code (Python):\n```python\nn, m = map(int, input().split())\ntaro_exist = [False for i in range(n)]\nfor i in range(m):\n    a, b = input().split()\n    a = int(a) - 1\n    if b == 'F' or taro_exist[a]:\n        print('No')\n    else:\n        taro_exist[a] = True\n        print('Yes')\n```\n\n[END TEXT]\n \n\n", "problem_ids": ["abc354_g", "arc177_f", "abc371_b"]}, "abc313_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\(N\\) and a prime \\(P\\).\n\nWe call a sequence of \\(N\\) intervals \\(([L_1,R_1],[L_2,R_2], \\ldots, [L_N,R_N])\\) **good** if and only if both of the following conditions are satisfied:\n\n1. \\(1 \\leq L_i \\leq R_i \\leq N\\) holds for all \\(1 \\leq i \\leq N\\).\n2. There exists a **unique** permutation \\(x = (x_1, x_2, \\ldots, x_N)\\) of \\((1, 2, \\ldots, N)\\) such that \\(L_i \\leq x_i \\leq R_i\\) holds for all \\(1 \\leq i \\leq N\\).\n\nCount the number of **good** sequences of intervals, modulo \\(P\\).\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 5000\\)\n- \\(10^9 < P < 1.01 \\times 10^9\\)\n- \\(P\\) is a prime number.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1005488041\n```\n\n**Sample Output 1**\n\n```\n6\n```\n\nThe following 6 sequences are good:\n1. \\(([1,1],[2,2])\\)\n2. \\(([1,2],[2,2])\\)\n3. \\(([1,1],[1,2])\\)\n4. \\(([2,2],[1,1])\\)\n5. \\(([2,2],[1,2])\\)\n6. \\(([1,2],[1,1])\\)\n\n**Sample Input 2**\n\n```\n5 1005488041\n```\n\n**Sample Output 2**\n\n```\n102960\n```\n\n**Sample Input 3**\n\n```\n100 1005488041\n```\n\n**Sample Output 3**\n\n```\n47599495\n```\n\n**Sample Input 4**\n\n```\n1000 1005488041\n```\n\n**Sample Output 4**\n\n```\n632708165\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Grand Contest 067\n\nD - Unique Matching Editorial by Kubic\n\nObviously, the intervals \\([l_i,r_i]\\) are distinct. So we can just let \\(x_i=i\\) and finally multiply the answer by \\(n!\\). Consider the uniqueness of bipartite graph matching. Fix a perfect matching; it is equivalent to not existing augmenting cycles. We claim that \\(l,r\\) is good if and only if there isn\u2019t \\(i,j\\) such that \\(1\\le i<j\\le n,r_i\\ge j,l_j\\le i\\). It means there is no cycle of length \\(2\\). Moreover, it can be proven that there will be no cycle under this condition. View \\(l\\) as constraints on \\(r\\), \\(\\forall l_i\\le j<i\\), then \\(r_j<i\\) must hold. Let \\(a_i=\\min\\limits_{l_j\\le i<j}j\\) (if \\(j\\) doesn\u2019t exist, then \\(a_i=n+1\\)). We need to calculate the sum of \\(\\prod (a_i-i)\\) for all possible sequences of \\(l\\). Fixing \\(a\\), we consider the number of \\(l\\) that generates \\(a\\). The main idea is to consider all maximums of \\(a\\) and divide \\(a\\) into several independent parts. Let \\(f_{i,j}\\) denote the answer when only considering \\([i,j]\\), requiring all \\(a_i\\dots a_j\\le j+1\\), with \\(l_{j+1}\\) determined (\\(l_{j+1}<i\\)). Let \\(g_{i,j}\\) denote the answer when \\(l_{j+1}\\) is undetermined (\\(l_{j+1}\\ge i\\)). Particularly, \\(f_{i+1,i}=g_{i+1,i}=1\\). The final answer is \\(f_{1,n}\\). Find the smallest \\(k\\) such that \\(i\\le k\\le j\\) and \\(a_k=j+1\\) (obviously \\(a_j=j+1\\), then such \\(k\\) exists). Now, \\([i,k-1]\\) and \\([k+1,j]\\) are independent subproblems. Thus, we have:\n\n```python\ndef f_i_j(i, j):\n    return sum((j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n\ndef g_i_j(i, j):\n    return sum((k - i + 1) * (j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n```\n\nFurthermore, \\(f_{i,j}\\) is only related to \\(j-i+1\\), thus it can be rewritten as follows:\n\n```python\ndef f_i(i):\n    return sum((i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n\ndef g_i(i):\n    return sum(j * (i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n```\n\nBrute force runs in \\(O(n^2)\\) and is allowed to pass. DC & FFT solution runs in \\(O(n\\log^2 n)\\).\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( A \\), \\( B \\), \\( X \\), \\( Y \\), and \\( N \\). The following conditions are guaranteed:\n\n- \\( A < B \\)\n- \\(\\gcd(A, B) = 1\\)\n- \\( 1 \\leq N \\leq A+B-1 \\)\n\nFor an integer \\( n \\), define \\( f(n) \\) as follows: You start with an integer \\( x = 0 \\). \\( f(n) \\) is the minimum total cost to achieve \\( x = n \\) by repeatedly performing the following operations:\n\n- Replace the value of \\( x \\) with \\( x + A \\). The cost of this operation is \\( X \\).\n- Replace the value of \\( x \\) with \\( x - A \\). The cost of this operation is \\( X \\).\n- Replace the value of \\( x \\) with \\( x + B \\). The cost of this operation is \\( Y \\).\n- Replace the value of \\( x \\) with \\( x - B \\). The cost of this operation is \\( Y \\).\n\nIt can be proved from the constraints on \\( A \\) and \\( B \\) that \\( f(n) \\) is defined for any integer \\( n \\).\n\nFind the value of \\( \\sum_{1 \\leq n \\leq N} f(n) \\), modulo \\( 998244353 \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 1000 \\)\n- \\( 1 \\leq A < B \\leq 10^9 \\)\n- \\(\\gcd(A, B) = 1\\)\n- \\( 1 \\leq X, Y \\leq 10^9 \\)\n- \\( 1 \\leq N \\leq A + B - 1 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nA B X Y N\n```\n\n**Output**\n\nPrint the answer for each test case.\n\n**Sample Input**\n\n```\n4\n1 2 1 1 2\n3 5 2 4 6\n79 85 72 95 4\n80980429 110892168 22712439 520643153 66132787\n```\n\n**Sample Output**\n\n```\n2\n34\n18111\n785776602\n```\n\nIn the first test case, \\( f(1) = 1 \\) and \\( f(2) = 1 \\).\n\nIn the second test case, \\( f(1) = 8 \\), \\( f(2) = 6 \\), \\( f(3) = 2 \\), \\( f(4) = 10 \\), \\( f(5) = 4 \\), and \\( f(6) = 4 \\).\n\nSolution:\n\n        The solution discusses how to find the shortest path in an operation sequence defined by integers \\(A, B, C, N\\), and elements \\(AX, AY, BX, BY\\) of a monoid \\(M\\). The problem focuses on modifying an integer \\(x\\) initially set to 0 and updating elements \\(cur\\) and \\(ans\\) in \\(M\\) over \\(N\\) operations. The operations are performed based on whether \\(x\\) is less than \\(B\\) or not, adjusting \\(ans\\) with products involving \\(AX, AY, BX, BY\\). The approach leverages a cycle structure of moves to ensure optimal paths, achieved through combinations of operations that mimic mathematical floor functions. Solutions are designed to work efficiently, leveraging logarithmic complexity relative to \\(A + B\\).\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nTakahashi will encounter \\( N \\) monsters in order. The \\( i \\)-th monster \\((1 \\leq i \\leq N)\\) has a strength of \\( A_i \\).\n\nFor each monster, he can choose to either let it go or defeat it. Each action awards him experience points as follows:\n- If he lets a monster go, he gains 0 experience points.\n- If he defeats a monster with strength \\( X \\), he gains \\( X \\) experience points. If it is an even-numbered defeated monster (2nd, 4th, ...), he gains an additional \\( X \\) experience points.\n\nFind the maximum total experience points he can gain from the \\( N \\) monsters.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the maximum total experience points he can gain from the \\( N \\) monsters as an integer.\n\n**Sample Input 1:**\n```\n5\n1 5 3 2 7\n```\n\n**Sample Output 1:**\n```\n28\n```\n\n**Explanation:**\n\nIf Takahashi defeats the 1st, 2nd, 3rd, and 5th monsters, and lets the 4th monster go, he gains experience points as follows:\n- Defeats a monster with strength \\( A_1 = 1 \\). He gains 1 experience point.\n- Defeats a monster with strength \\( A_2 = 5 \\). He gains 5 experience points. As it is the 2nd defeated monster, he gains an additional 5 points.\n- Defeats a monster with strength \\( A_3 = 3 \\). He gains 3 experience points.\n- Lets the 4th monster go. Takahashi gains no experience points.\n- Defeats a monster with strength \\( A_5 = 7 \\). He gains 7 experience points. As it is the 4th defeated monster, he gains an additional 7 points.\n\nTherefore, in this case, he gains \\( 1+(5+5)+3+0+(7+7)=28 \\) experience points. Note that even if he encounters a monster, if he lets it go, it does not count as defeated. He can gain at most 28 experience points no matter how he acts, so print 28. As a side note, if he defeats all monsters in this case, he would gain \\( 1+(5+5)+3+(2+2)+7=25 \\) experience points.\n\n**Sample Input 2:**\n```\n2\n1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n3000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 369\n\nD - Bonus EXP Editorial\n\nThis problem can be solved with dynamic programming (DP). Let \\(dp_{even}[k]\\) be the maximum total experience point when defeating an even number of monsters out of the first \\(k\\) monsters encountered, and \\(dp_{odd}[k]\\) be that for an odd number of monsters (or \\(-\\infty\\) if it is impossible). Initially, \\(dp_{even}[0]=0\\) and \\(dp_{odd}[0]=-\\infty\\).\n\nFor \\(1\\leq i\\leq N\\), the experience point from the \\(i\\)-th monster depends on whether Takahashi chooses to defeat it or not, and whether the number of defeated monsters is even or odd. To encounter the first \\(i\\) monsters and defeat an even number, we have two cases:\n\n1. Defeat an even number of monsters from the first \\((i-1)\\) and let the \\(i\\)-th go.\n2. Defeat an odd number of monsters from the first \\((i-1)\\) and defeat the \\(i\\)-th.\n\nThus, we can find \\(dp_{even}[i]\\) as \n\\[\ndp_{even}[i]=\\max(dp_{even}[i-1],dp_{odd}[i-1]+2A_i).\n\\]\n\nSimilarly, \\(dp_{odd}[i]\\) is\n\\[\ndp_{odd}[i]=\\max(dp_{odd}[i-1],dp_{even}[i-1]+A_i).\n\\]\n\nThe final answer is \\(\\max(dp_{even}[N],dp_{odd}[N])\\), with a complexity of \\(O(N)\\).\n\nSample code in Python:\n```python\nINF = 10**18\n\ndef main():\n    n = int(input())\n    dp0, dp1 = 0, -INF\n    for _ in range(n):\n        x = int(input())\n        tmp = dp0\n        dp0 = max(dp1 + 2*x, dp0)\n        dp1 = max(tmp + x, dp1)\n    print(max(dp0, dp1))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["agc067_d", "arc183_f", "abc369_d"]}, "abc313_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( N \\) and a sequence of \\( M \\) positive integers \\( A = (A_1, A_2, \\ldots, A_M) \\). All elements of \\( A \\) are distinct integers between \\( 1 \\) and \\( N \\), inclusive.\n\nA permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) is called a *good permutation* if it satisfies the following condition for all integers \\( i \\) such that \\( 1 \\leq i \\leq M \\):\n\n- No contiguous subsequence of \\( P \\) is a permutation of \\( (1, 2, \\ldots, A_i) \\).\n\nDetermine whether a *good permutation* exists, and if it does, find the lexicographically smallest *good permutation*.\n\n**What is lexicographical order?**\n\nA sequence \\( S = (S_1, S_2, \\ldots, S_{|S|}) \\) is said to be *lexicographically smaller* than a sequence \\( T = (T_1, T_2, \\ldots, T_{|T|}) \\) if one of the following conditions holds:\n\n1. \\( |S| < |T| \\) and \\( (S_1, S_2, \\ldots, S_{|S|}) = (T_1, T_2, \\ldots, T_{|S|}) \\).\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|S|, |T|\\} \\) such that both of the following hold:\n   - \\( (S_1, S_2, \\ldots, S_{i-1}) = (T_1, T_2, \\ldots, T_{i-1}) \\).\n   - \\( S_i \\) is smaller than \\( T_i \\) (as a number).\n\n**Constraints**\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All elements of \\( A \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\cdots A_M\n```\n\n**Output**\n\nIf a *good permutation* does not exist, print `-1`.  \nIf it exists, print the lexicographically smallest *good permutation*, separated by spaces.\n\n**Sample Input 1**\n```\n4 1\n2\n```\n\n**Sample Output 1**\n```\n1 3 2 4\n```\n\nFor example, \\( (4, 2, 1, 3) \\) is not a *good permutation* because it contains \\( (2, 1) \\) as a contiguous subsequence. Other non-*good permutations* are \\( (1, 2, 3, 4) \\) and \\( (3, 4, 2, 1) \\). Some *good permutations* are \\( (4, 1, 3, 2) \\) and \\( (2, 3, 4, 1) \\). Among these, the lexicographically smallest one is \\( (1, 3, 2, 4) \\), so print it separated by spaces.\n\n**Sample Input 2**\n```\n5 3\n4 3 2\n```\n\n**Sample Output 2**\n```\n1 3 4 5 2\n```\n\nExamples of *good permutations* include \\( (3, 4, 1, 5, 2) \\), \\( (2, 4, 5, 3, 1) \\), and \\( (4, 1, 5, 2, 3) \\). Examples of non-*good permutations* include \\( (1, 2, 5, 3, 4) \\), \\( (2, 3, 4, 1, 5) \\), and \\( (5, 3, 1, 2, 4) \\).\n\n**Sample Input 3**\n```\n92 4\n16 7 1 67\n```\n\n**Sample Output 3**\n```\n-1\n```\n\nIf a *good permutation* does not exist, print `-1`.\n\n**Sample Input 4**\n```\n43 2\n43 2\n```\n\n**Sample Output 4**\n```\n-1\n```\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nA - Good Permutation 2 Editorial by evima\n\nIf \\(A\\) contains either \\(1\\) or \\(N\\), a good permutation does not exist. Conversely, if neither \\(1\\) nor \\(N\\) is included in \\(A\\), a good permutation does exist. Let\u2019s consider this case. For example, if we set \\(P = (1, N, N - 1, N - 2, \\dots, 3, 2)\\), the only contiguous subsequence of \\(P\\) that includes both \\(1\\) and \\(2\\) is \\(P\\) itself, making \\(P\\) a good permutation. \n\nSince a good permutation with \\(P_{1} = 1\\) exists, the lexicographically smallest good permutation will have \\(P_{1} = 1\\). For any integer \\(x\\), if there exists a contiguous subsequence of \\(P\\) that is a permutation of \\((1, 2, \\dots, x)\\), it must be \\((P_{1}, P_{2}, \\dots, P_{x})\\). We determine \\(P_{i}\\) for \\(i \\neq 1\\) in ascending order of \\(i\\). When deciding \\(P_{i}\\), assume that all of \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\) are at most \\(i\\). Let \\(a\\) be the number that is at most \\(i\\) and not included in \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\).\n\nWhen \\(i\\) is included in \\(A\\):\nTo make the permutation lexicographically smallest, set \\(P_{i} = i + 1\\). Since \\(P_{i}\\) is not greater than \\(i + 1\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) does not change.\n\nWhen \\(i\\) is not included in \\(A\\):\nSet \\(P_{i} = a\\). Since this number is not greater than \\(i\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) becomes \\(i + 1\\).\n\nThe time complexity is \\(O(N)\\).\n\n```python\n# input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nban = [0] * N\nfor a in A:\n    ban[a - 1] = 1\n\n# impossible\nif ban[0] or ban[N - 1]:\n    print(-1)\n    quit()\n\n# init\nP = [0] * N\nP[0] = 1\na = 2\n\n# calc\nfor i in range(1, N):\n    if ban[i] == 1:\n        P[i] = i + 2\n    else:\n        P[i] = a\n        a = i + 2\n\n# output\nprint(*P)\n```\n\nYou can also construct the permutation as follows: Initialize \\(P = (1, 2, \\dots, N)\\), and for \\(i = 2, 3, \\dots, N - 1\\), perform the following operation: If \\(i\\) is included in \\(A\\), do \\(\\text{swap}(P_{i}, P_{i + 1})\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 550 points\n\n## Problem Statement\n\nYou are given a weighted undirected connected graph \\( G \\) with \\( N \\) vertices and \\( N-1 \\) edges, where vertices are numbered from \\( 1 \\) to \\( N \\) and edges are numbered from \\( 1 \\) to \\( N-1 \\). Edge \\( i \\) connects vertices \\( a_i \\) and \\( b_i \\) with a weight of \\( c_i \\).\n\nYou are given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- You are given integers \\( u_i, v_i, w_i \\). Add an edge with weight \\( w_i \\) between vertices \\( u_i \\) and \\( v_i \\) in \\( G \\). Then, print the sum of the weights of the edges in a minimum spanning tree of \\( G \\).\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i < b_i \\leq N \\)\n- \\( 1 \\leq u_i < v_i \\leq N \\)\n- \\( 1 \\leq c_i, w_i \\leq 10 \\)\n- The graph is connected before processing the queries.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\na_1 b_1 c_1\n.\n.\n.\na_{N-1} b_{N-1} c_{N-1}\nu_1 v_1 w_1\n.\n.\n.\nu_Q v_Q w_Q\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n## Sample Input 1\n\n```\n4 4\n1 2 6\n2 3 5\n2 4 4\n1 3 3\n1 2 3\n1 4 10\n3 4 1\n```\n\n## Sample Output 1\n\n```\n12\n10\n10\n7\n```\n\nHere is the graph after adding the edge for each query. The edges included in the minimum spanning tree are colored red.\n\n## Sample Input 2\n\n```\n8 6\n1 8 8\n1 6 10\n1 5 8\n2 6 6\n6 7 6\n1 3 9\n2 4 7\n1 3 4\n1 6 7\n3 4 6\n1 5 1\n7 8 4\n3 5 3\n```\n\n## Sample Output 2\n\n```\n49\n46\n45\n38\n34\n33\n```\n\nSolution:\n\n```\nHere is the trimmed editorial:\n\n---\n\n**F - MST Query Editorial**\n\nLet \\(W=10\\) be the maximum edge weight. Let \\(G_k (0\\leq k\\leq W)\\) be the (unweighted) subgraph of \\(G\\) consisting of the edges of \\(G\\) with weights not more than \\(k\\). Let \\(H\\) be the number of connected components of a graph \\(H\\), then the sum of weights of edges in an MST of graph \\(G\\) equals \\(\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Proof) Approach 1:** Among the edges in an MST of \\(G\\), there are \\(N-c(G_k)\\) edges whose weight is not greater than \\(k\\). Therefore, there are \\(\\left(N-c(G_k)\\right)-\\left(N-c(G_{k-1})\\right)=c(G_{k-1})-c(G_k)\\) edges whose weight is exactly \\(k\\), so the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle \\sum_{k=1}^{W}k\\left(c(G_{k-1})-c(G_k)\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)\\right)-W\\cdot c(G_W)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Approach 2):** Among the edges in an MST of \\(G\\), there are \\(c(G_{k-1})-1\\) edges whose weight is not greater than \\(c(G_{k-1})-1\\). Thus, the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle\\sum_{k=1}^{W}\\left(c(G_{k-1})-1\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left(c(G_k)-1\\right)\\).\n\nFor each \\(k(0\\leq k\\lt W)\\), one can manage the number of connected components of \\(G_k\\) with a disjoint set union (DSU) to solve this problem in a total of \\(O(W(N+Q)\\alpha(N))\\). The complexity can be reduced to \\(O((WN+Q)\\alpha(N))\\).\n\n**Sample Code:**\n\n```python\nfrom atcoder.dsu import DSU\n\nN, Q = map(int, input().split())\nuf = [DSU(N + 1) for i in range(10)]\nans = 10 * N - 10\nfor i in range(N - 1 + Q):\n    a, b, c = map(int, input().split())\n    for j in range(c, 10):\n        if not uf[j].same(a, b):\n            ans -= 1\n            uf[j].merge(a, b)\n    if i >= N - 1:\n        print(ans)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 300 points\n\n### Problem Statement\n\nPrint all integer sequences of length \\( N \\) that satisfy the following conditions, in ascending lexicographical order:\n\n1. The \\( i \\)-th element is between 1 and \\( R_i \\), inclusive.\n2. The sum of all elements is a multiple of \\( K \\).\n\nWhat is lexicographical order for sequences?\n\nA sequence \\( A = (A_1, \\ldots, A_{|A|}) \\) is lexicographically smaller than \\( B = (B_1, \\ldots, B_{|B|}) \\) if either 1. or 2. below holds:\n\n1. \\( |A| < |B| \\) and \\( (A_{1}, \\ldots, A_{|A|}) = (B_1, \\ldots, B_{|A|}) \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|A|,|B|\\} \\) such that both of the following are true:\n   - \\( (A_{1}, \\ldots, A_{i-1}) = (B_1, \\ldots, B_{i-1}) \\)\n   - \\( A_i < B_i \\)\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 8 \\)\n- \\( 2 \\le K \\le 10 \\)\n- \\( 1 \\le R_i \\le 5 \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nR_1 R_2 \\dots R_N\n```\n\n### Output\n\nPrint the answer in the following format, where \\( X \\) is the number of sequences to print, the \\( i \\)-th of which is \\( A_i = (A_{i,1}, A_{i,2}, \\dots, A_{i,N}) \\):\n\n```\nA_{1,1} A_{1,2} \\dots A_{1,N}\nA_{2,1} A_{2,2} \\dots A_{2,N}\n\u22ee\nA_{X,1} A_{X,2} \\dots A_{X,N}\n```\n\n### Sample Input 1\n\n```\n3 2\n2 1 3\n```\n\n### Sample Output 1\n\n```\n1 1 2\n2 1 1\n2 1 3\n```\n\nThere are three sequences to be printed, which are (1, 1, 2), (2, 1, 1), (2, 1, 3) in lexicographical order.\n\n### Sample Input 2\n\n```\n1 2\n1\n```\n\n### Sample Output 2\n\n```\n```\n\nThere may be no sequences to print. In this case, the output can be empty.\n\n### Sample Input 3\n\n```\n5 5\n2 3 2 3 2\n```\n\n### Sample Output 3\n\n```\n1 1 1 1 1\n1 2 2 3 2\n1 3 1 3 2\n1 3 2 2 2\n1 3 2 3 1\n2 1 2 3 2\n2 2 1 3 2\n2 2 2 2 2\n2 2 2 3 1\n2 3 1 2 2\n2 3 1 3 1\n2 3 2 1 2\n2 3 2 2 1\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 367\n\nC - Enumerate Sequences Editorial\n\nThere are \\(5^8=390625\\) sequences of length \\(8\\) consisting of integers between \\(1\\) and \\(5\\). Since the number of sequences to print is always not more than this count, we do not have to worry about too much output.\n\n**Approach 1: Use recursion to enumerate**  \n1. Fix the first element in ascending order.  \n2. Once the first element is fixed, call the recursion to fix the second element in ascending order.  \n3. Once all the elements are ready, check if the total sum is a multiple of \\(K\\) and print it.  \n\nImplementing this recursion will be accepted.\n\nSample code (Python3):\n```python\ndef solve(lv, n, k, r, seq):\n    if lv == n:\n        s = sum(seq[:n])\n        if s % k == 0:\n            print(\" \".join(map(str, seq[:n])))\n        return\n    \n    for i in range(1, r[lv] + 1):\n        seq[lv] = i\n        solve(lv + 1, n, k, r, seq)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    r = list(map(int, data[2:2 + n]))\n    seq = [0] * 8\n    solve(0, n, k, r, seq)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Approach 2: Decode integers corresponding to sequences**  \nIgnoring the condition \u201cmultiple of \\(K\\),\u201d there are \\(P=R_1 \\times R_2 \\times \\dots \\times R_N\\) possible sequences. If you decode an integer between \\(0\\) and \\(P-1\\), the results are sorted in ascending order.\n\nLet \\(S\\) be the decode result. Prepare a variable \\(x \\leftarrow t\\). For \\(i = N\\) down to \\(1\\), do the following:\n1. Let \\(S_i \\leftarrow (x \\% R_i)+1\\). Then, replace \\(x\\) with \\(\\displaystyle \\frac{x}{R_i}\\) (rounded down).\n\nIntuitively, a sequence corresponds to a special \\(N\\)-ary representation.\n\nSample code (Python3):\n```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    k = int(data[1])\n    r = list(map(int, data[2:2 + n]))\n\n    tot = 1\n    for i in range(n):\n        tot *= r[i]\n\n    for t in range(tot):\n        x = t\n        s = 0\n        seq = [0] * n\n        for i in range(n - 1, -1, -1):\n            seq[i] = (x % r[i]) + 1\n            s += seq[i]\n            x //= r[i]\n        \n        if s % k == 0:\n            print(\" \".join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["arc178_a", "abc355_f", "abc367_c"]}, "abc314_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices. The vertices are numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge (\\( 1 \\leq i \\leq N-1 \\)) connects vertices \\( U_i \\) and \\( V_i \\), with a length of \\( L_i \\).\n\nFor each \\( K = 1, 2, \\ldots, N \\), solve the following problem.\n\nTakahashi and Aoki play a game. The game proceeds as follows:\n\n1. First, Aoki specifies \\( K \\) distinct vertices on the tree.\n2. Then, Takahashi constructs a walk that starts and ends at vertex 1, and passes through all the vertices specified by Aoki.\n\nThe score is defined as the length of the walk constructed by Takahashi. Takahashi wants to minimize the score, while Aoki wants to maximize it. Find the score when both players play optimally.\n\n**Definition of a walk:**\nA walk on an undirected graph (possibly a tree) is a sequence of \\( k \\) vertices and \\( k-1 \\) edges \\( v_1, e_1, v_2, \\ldots, v_{k-1}, e_{k-1}, v_k \\) (where \\( k \\) is a positive integer) such that edge \\( e_i \\) connects vertices \\( v_i \\) and \\( v_{i+1} \\). The same vertex or edge can appear multiple times in the sequence. A walk is said to pass through vertex \\( x \\) if there exists at least one \\( i \\) (\\( 1 \\leq i \\leq k \\)) such that \\( v_i = x \\). (There can be multiple such \\( i \\).) The walk is said to start and end at \\( v_1 \\) and \\( v_k \\), respectively, and the length of the walk is the sum of the lengths of \\( e_1, e_2, \\ldots, e_{k-1} \\).\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq L_i \\leq 10^9 \\)\n- All input values are integers.\n- The given graph is a tree.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nU_1 V_1 L_1\nU_2 V_2 L_2\n...\nU_{N-1} V_{N-1} L_{N-1}\n```\n\n**Output:**\nPrint \\( N \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq N \\)) should contain the answer to the problem for \\( K = i \\).\n\n**Sample Input 1:**\n```\n5\n1 2 3\n2 3 5\n2 4 2\n1 5 3\n```\n\n**Sample Output 1:**\n```\n16\n22\n26\n26\n26\n```\n\nFor \\( K=1 \\), Aoki's optimal move is to specify vertex 3, and Takahashi's optimal move is to construct a path vertex 1 \u2192 vertex 2 \u2192 vertex 3 \u2192 vertex 2 \u2192 vertex 1, resulting in a score of 16.\n\nFor \\( K=2 \\), Aoki's optimal move is to specify vertices 3 and 5, and Takahashi's optimal move is to construct a path such as vertex 1 \u2192 vertex 5 \u2192 vertex 1 \u2192 vertex 2 \u2192 vertex 3 \u2192 vertex 2 \u2192 vertex 1, resulting in a score of 22.\n\nFor \\( K \\geq 3 \\), the score when both players play optimally is 26.\n\n**Sample Input 2:**\n```\n3\n1 2 1000000000\n2 3 1000000000\n```\n\n**Sample Output 2:**\n```\n4000000000\n4000000000\n4000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n---\n\nWe will regard the given tree as a rooted tree rooted at \\(1\\). We first consider Takahashi\u2019s strategy. For any edge on the tree, when the tree is split into two parts by the edge, if Aoki has chosen at least one vertex in the part not containing vertex \\(1\\), then Takahashi has to construct a walk that passes through that edge at least twice (back and forth). Conversely, he can construct the shortest such walk, which passes through such edges exactly twice but not the others. It can be constructed as, for example, an Euler tour on the tree obtained by removing unnecessary edges. Based on this fact, we will try to solve the problem with tree DP (Dynamic Programming).\n\nFor each subtree \\(T_v\\) rooted at vertex \\(v\\), let us try to find \\((S_v(1), S_v(2), \\ldots, S_v(T_v))\\), defined as the minimum scores for \\(K=1,2,\\ldots,|T_v|\\) when they play optimally on \\(T_v\\). Here, \\(|T_v|\\) denotes the number of vertices in \\(T_v\\).\n\nIf \\(T_u\\) consist of a single vertex, then \\(|T_u|=1\\) and \\(S_u(1)=0\\). Suppose that vertex \\(u\\) has \\(v_1,v_2,\\ldots,v_c\\) as its direct children, with the lengths of the edge between \\(u\\) and them being \\(d_1,d_2,\\ldots,d_c\\), respectively, and the scores are already known for \\(T_{v_i}\\) \\((1\\leq i\\leq c)\\). Then, noticing it is useless to choose \\(u\\) if \\(K<|T_u|\\), the scores \\(S(u,K)\\) \\((1\\leq K < |T_u|)\\) satisfy:\n\n\\[\nS(u,K)=\\max_{x_1+x_2+x_c=K}\\sum_{i=1}^c\n\\begin{cases}\n0 & (x_i=0) \\\\\n2d_i+S(v_i,x_i) & (1\\leq x_i\\leq |T_i|),\n\\end{cases}\n\\]\n\nwhere each \\(x_i\\) ranges over \\(0\\leq x_i\\leq |T_i|\\). Finally, \\(S(u,|T_u|)=S(u,|T_u|-1)\\).\n\nSince \\(S(v,x)\\leq S(v,x+1)\\) for any \\(v\\), this can be interpreted as the maximum sum of a total of \\(K\\) elements chosen from the leading elements of \\(c\\) sequences \\((2d_i+S(v_i,1),S(v_i,2)-S(v_i,1),\\ldots, S(v_i,|T_i|)-S(v_i,|T_i|-1) )\\). Moreover, assume that they satisfy \\(S(v_i,1)\\geq S(v_i,2)-S(v_i,1)\\) and \\(S(v_i,x)-S(v_i,x-1)\\geq S(v_i,x+1)-S(v_i,x)\\).\n\nIf we define a multiset \\(\\mathcal{S}\\) as:\n\n\\[\n\\mathcal{S}_u= \\left[\\bigcup_{i=1}^c \\{2d_i+S(v_i,1),S(v_i,2)-S(v_i,1),\\ldots, S(v_i,|T_i|)-S(v_i,|T_i|-1) \\}\\right]\\cup\\{0\\},\n\\]\n\nthen the elements sorted in descending order, \\((z_1,z_2,\\ldots,z_{|T_u|})\\), coincide with \\((S(u,1),S(u,2)-S(u,1),\\ldots, S(u,|T_u|)-S(u,|T_u|-1))\\). Then, we have \\(S(u,1)\\geq S(u,2)-S(u,1)\\) and \\(S(u,x)-S(u,x-1)\\geq S(u,x+1)-S(u,x)\\) for \\(u\\) too. Since it automatically holds for \\(|T_u|=1\\), this property inductively holds always, and thus can be computed like this.\n\nBased on this fact, we can compute it as follows: When processing a non-leaf vertex, compute \\(2d_i+S(v_i,1)\\) \\((1\\leq i\\leq c)\\) and store the maximum among them to \\(S(u,1)\\), and store the other \\((c-1)\\) values and one \\(0\\) into a multiset \\(\\mathcal{S}\\). \\(S(1,1)\\) is the last value stored, and \\(S(1,K)\\) is \\(S(1,1)\\) plus the sum of the largest \\((K-1)\\) elements of \\(\\mathcal{S}\\). The complexity is \\(O(N)\\), which is fast enough. Thus, the problem has been solved.\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi has various colors of socks in his chest of drawers. The colors of the socks are represented by integers from 1 to N, and there are \\( A_i (\\geq 2) \\) socks of color \\( i \\).\n\nHe is about to choose which socks to wear today by performing the following operation:\n\n- Continue to randomly draw one sock at a time from the chest, with equal probability, until he can make a pair of socks of the same color from those he has already drawn. Once a sock is drawn, it will not be returned to the chest.\n\nFind the expected value, modulo 998244353, of the number of times he has to draw a sock from the chest.\n\nIt can be proved that the sought expected value is always rational. Furthermore, the constraints of this problem guarantee that if the expected value is expressed as an irreducible fraction \\( \\frac{y}{x} \\), then \\( x \\) is not divisible by 998244353. Here, there exists a unique integer \\( z \\) between 0 and 998244352, inclusive, such that \\( xz \\equiv y \\pmod{998244353} \\). Find this \\( z \\).\n\n**Constraints:**\n\n- \\(1 \\leq N \\leq 3 \\times 10^5\\)\n- \\(2 \\leq A_i \\leq 3000\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n```\n2\n2 2\n```\n\n**Sample Output 1:**\n```\n665496238\n```\n\nFor example, the operation could be performed as follows:\n1. Draw a sock of color 1 from the chest. There remains one sock of color 1 and two socks of color 2 in the chest.\n2. Draw a sock of color 2 from the chest. There remains one sock each of colors 1 and 2 in the chest.\n3. Draw a sock of color 1 from the chest. The socks drawn so far are two of color 1 and one of color 2, allowing a pair of color 1 socks to be made, thus ending the operation.\n\nIn this example, Takahashi draws a sock from the chest three times. The expected number of times Takahashi draws a sock from the chest is 3 with probability \\( \\frac{2}{3} \\) and 2 with probability \\( \\frac{1}{3} \\), so the expected value is \\( 3 \\times \\frac{2}{3} + 2 \\times \\frac{1}{3} = \\frac{8}{3} \\equiv 665496238 \\pmod{998244353} \\).\n\n**Sample Input 2:**\n```\n1\n352\n```\n\n**Sample Output 2:**\n```\n2\n```\n\n**Sample Input 3:**\n```\n6\n1796 905 2768 253 2713 1448\n```\n\n**Sample Output 3:**\n```\n887165507\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial content without extraneous information:\n\n---\n\nLet \\(S = A_1 + A_2 + \\dots + A_N\\). By the Pigeonhole Theorem, Takahashi draws a sock at most \\(N+1\\) times. Let \\(P_i\\) be the probability that he draws a sock at least \\(i\\) times. The expected value is \\(P_1 + P_2 + \\dots + P_{N+1}\\).\n\nLet \\(Q_i\\) be the probability that he draws a sock exactly \\(i\\) times. The expected value is \\(1 \\cdot Q_1 + 2 \\cdot Q_2 + \\dots + (N+1) \\cdot Q_{N+1}\\). Using \\(Q_i = P_i - P_{i+1}\\), this can be rewritten as \\(P_1 + P_2 + \\dots + P_{N+1}\\).\n\n\\(P_{i+1}\\) is equivalent to the probability that there is no duplicating color after drawing \\(i\\) socks. Denote \\(f_i\\) as the number of ways to choose \\(i\\) socks with different colors among the \\(S\\) socks: \\(P_{i+1} = \\frac{f_i}{\\binom{S}{i}}\\). Finding \\(\\binom{S}{0}, \\binom{S}{1}, \\dots, \\binom{S}{N}\\) is trivial, so the task is to find \\(f_i\\).\n\nDefine a polynomial \\(F = \\sum_{i=0}^{S} f_i x^i\\). Since \\(f_i = \\sum_{1 \\leq k_1 < k_2 < \\dots < k_i \\leq N} \\prod_{l=1}^{i} A_{k_l}\\), \\(F\\) is the total product of \\(F_1, F_2, \\dots, F_N\\), where \\(F_i = (1 + A_i x)\\). The problem reduces to:\n\nGiven \\(N\\) linear polynomials, find their product.\n\nThis can be solved with a divide-and-conquer algorithm in \\(O(N\\log^2 N)\\) time. Specifically, define \\(f(l,r)\\) as the product of \\(F_l, F_{l+1}, \\dots, F_{r-1}\\), and apply \\(f(l,r) = f(l,m) \\times f(m,r)\\ (m = \\lfloor\\frac{l+r}{2}\\rfloor)\\) to evaluate it recursively. Using the NTT (Number-Theoretic Transform), the complexity is \\(O(N\\log^2 N)\\).\n\nSample code (Python):\n\n```python\nfrom atcoder.convolution import convolution\nfrom atcoder.modint import ModInt998244353 as mint\n\ndef prod(a, l, r):\n    if r - l == 1:\n        return [mint(1), mint(a[l])]\n    m = (l + r) // 2\n    return convolution(prod(a, l, m), prod(a, m, r))\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a)\n    f = prod(a, 0, n)\n    ans = mint(0)\n    sCi = mint(1)\n    for i in range(n + 1):\n        ans += f[i] / sCi\n        sCi *= s - i\n        sCi /= i + 1\n    print(ans.val())\n\nmain()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) types of elements numbered \\( 1, 2, \\ldots, N \\). Elements can be combined with each other. When elements \\( i \\) and \\( j \\) are combined, they transform into element \\( A_{i, j} \\) if \\( i \\geq j \\), and into element \\( A_{j, i} \\) if \\( i < j \\).\n\nStarting with element \\( 1 \\), combine it with elements \\( 1, 2, \\ldots, N \\) in this order. Find the final element obtained.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_{i, j} \\leq N \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_{1, 1}\nA_{2, 1} A_{2, 2}\n\\vdots\nA_{N, 1} A_{N, 2} \\ldots A_{N, N}\n```\n\n**Output:**\n\nPrint the number representing the final element obtained.\n\n**Sample Input 1:**\n\n```\n4\n3\n2 4\n3 1 2\n2 1 2 4\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- Combining element 1 with element 1 results in element 3.\n- Combining element 3 with element 2 results in element 1.\n- Combining element 1 with element 3 results in element 3.\n- Combining element 3 with element 4 results in element 2.\n\nTherefore, the value to be printed is 2.\n\n**Sample Input 2:**\n\n```\n5\n5\n5 5\n5 5 5\n5 5 5 5\n5 5 5 5 5\n```\n\n**Sample Output 2:**\n\n```\n5\n```\n\n**Sample Input 3:**\n\n```\n6\n2\n1 5\n1 6 3\n2 6 1 4\n2 1 1 1 6\n5 6 1 2 2 5\n```\n\n**Sample Output 3:**\n\n```\n5\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\n**B - Binary Alchemy Editorial**\n\nSimulate the process of successively synthesizing elements \\(1, 2, \\ldots, N\\) into element \\(1\\) while managing the current index of the element.\n\n```python\ndef main():\n    n = int(input())\n    a = [list(map(lambda x: int(x) - 1, input().split())) + [0] * (n - i - 1) for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if ans >= i:\n            ans = a[ans][i]\n        else:\n            ans = a[i][ans]\n    ans += 1\n    print(ans)\n\nmain()\n```\n\n---\n \n\n", "problem_ids": ["abc369_g", "abc352_g", "abc370_b"]}, "abc314_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 1100 points\n\nProblem Statement:\nYou have an integer sequence \\(a=(a_1, a_2, \\ldots, a_N)\\) of length \\(N\\). Initially, all elements are 0. You are given an integer \\(C\\) and \\(M\\) intervals \\(([L_1, R_1], [L_2, R_2], \\ldots, [L_M, R_M])\\).\n\nYou will choose a permutation \\(p\\) of \\((1, 2, \\ldots, M)\\) and an integer sequence \\(w=(w_1, w_2, \\ldots, w_M)\\) of length \\(M\\) where \\(1 \\le w_i \\le C\\) must hold.\n\nThen, you will perform \\(M\\) modifications. The \\(i\\)-th modification involves:\n\n- Changing \\(a_{L_{p_i}}, \\ldots, a_{R_{p_i}}\\) to \\(w_i\\).\n\nIt is guaranteed that every position in \\(a\\) is covered by at least one interval. Determine the number of possible sequences \\(a\\) after all modifications. Print the answer modulo \\(998244353\\).\n\nConstraints:\n- \\(1 \\le N \\le 100\\)\n- \\(1 \\le M \\le \\frac{N(N+1)}{2}\\)\n- \\(1 \\le C < 998244353\\)\n- \\(1 \\le L_i \\le R_i \\le N\\)\n- \\((L_i, R_i) \\neq (L_j, R_j)\\) for \\(i \\neq j\\)\n- Every position in \\(a\\) is covered by at least one interval.\n- All input values are integers.\n\nInput:\nInput is given from Standard Input in the following format:\n```\nN M C\nL_1 R_1\nL_2 R_2\n\u22ee\nL_M R_M\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n5 5 2\n1 3\n2 2\n3 3\n1 5\n3 5\n```\n\nSample Output 1:\n```\n16\n```\nThere are 16 sequences that can be achieved. For example, you can achieve \\(a=(2, 1, 1, 1, 1)\\) in the following manner:\n- Choose \\(p=(4, 1, 2, 3, 5)\\) and \\(w=(1, 2, 1, 2, 1)\\).\n- The 1st operation changes \\(a\\) into \\((1, 1, 1, 1, 1)\\).\n- The 2nd operation changes \\(a\\) into \\((2, 2, 2, 1, 1)\\).\n- The 3rd operation changes \\(a\\) into \\((2, 1, 2, 1, 1)\\).\n- The 4th operation changes \\(a\\) into \\((2, 1, 2, 1, 1)\\).\n- The 5th operation changes \\(a\\) into \\((2, 1, 1, 1, 1)\\).\n\nSample Input 2:\n```\n20 30 20\n1 14\n1 7\n1 16\n3 13\n1 17\n4 8\n2 11\n4 12\n9 14\n3 15\n11 19\n1 13\n4 15\n8 19\n3 17\n15 18\n10 18\n1 18\n17 19\n16 20\n1 8\n8 15\n13 17\n1 19\n13 19\n1 20\n6 13\n10 12\n11 20\n17 18\n```\n\nSample Output 2:\n```\n258066445\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Grand Contest 067\n\nB - Modifications Editorial by Kubic\n\nWe consider how to judge whether \\(a\\) can be generated. We reverse the process so that each modification changes an interval to any value, which we denote as this modification \u201ccovers\u201d the interval. We can then build a greedy process: If all uncovered elements in \\([l_i,r_i]\\) have the same value, cover them. The process ends when no more intervals can be selected. Obviously, \\(a\\) can be generated if and only if all elements are covered.\n\nWe solve the problem by an interval DP. To transition, calculate the invalid ones. There will be some elements left uncovered. Find all maximal covered intervals \\([p_1,q_1]\\dots [p_k,q_k]\\), which form \\(k\\) independent subproblems. Ensure that \u201cno more intervals can be selected.\u201d In the DP state, maintain the rightmost uncovered element with a value different from the rightmost uncovered element in the interval. This suffices to judge validity. The time complexity is \\(O(n^4)\\). \\(O(n^5)\\) solutions with a small constant may pass.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou have \\( N \\) keys numbered \\( 1, 2, \\dots, N \\). Some of these are real keys, while the others are dummies. There is a door, Door X, into which you can insert any number of keys. Door X will open if and only if at least \\( K \\) real keys are inserted.\n\nYou have conducted \\( M \\) tests on these keys. The \\( i \\)-th test went as follows:\n- You inserted \\( C_i \\) keys \\( A_{i,1}, A_{i,2}, \\dots, A_{i,C_i} \\) into Door X.\n- The test result is represented by a single English letter \\( R_i \\).\n  - \\( R_i = \\text{o} \\) means that Door X opened in the \\( i \\)-th test.\n  - \\( R_i = \\text{x} \\) means that Door X did not open in the \\( i \\)-th test.\n\nThere are \\( 2^N \\) possible combinations of which keys are real and which are dummies. Among these, find the number of combinations that do not contradict any of the test results. It is possible that the given test results are incorrect and no combination satisfies the conditions. In such a case, report \\( 0 \\).\n\n**Constraints**\n- \\( N, M, K, C_i, \\text{ and } A_{i,j} \\) are integers.\n- \\( 1 \\le K \\le N \\le 15 \\)\n- \\( 1 \\le M \\le 100 \\)\n- \\( 1 \\le C_i \\le N \\)\n- \\( 1 \\le A_{i,j} \\le N \\)\n- \\( A_{i,j} \\neq A_{i,k} \\) if \\( j \\neq k \\).\n- \\( R_i \\) is \\( \\text{o} \\) or \\( \\text{x} \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M K\nC_1 A_{1,1} A_{1,2} \\dots A_{1,C_1} R_1\nC_2 A_{2,1} A_{2,2} \\dots A_{2,C_2} R_2\n\\vdots\nC_M A_{M,1} A_{M,2} \\dots A_{M,C_M} R_M\n```\n\n**Output**\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2 2\n3 1 2 3 o\n2 2 3 x\n```\n\n**Sample Output 1**\n```\n2\n```\n\nIn this input, there are three keys and two tests were conducted. Two correct keys are required to open Door X. In the first test, keys 1, 2, 3 were used, and Door X opened. In the second test, keys 2, 3 were used, and Door X did not open. There are two combinations of which keys are real and which are dummies that do not contradict any of the test results: Key 1 is real, key 2 is a dummy, and key 3 is real. Key 1 is real, key 2 is real, and key 3 is a dummy.\n\n**Sample Input 2**\n```\n4 5 3\n3 1 2 3 o\n3 2 3 4 o\n3 3 4 1 o\n3 4 1 2 o\n4 1 2 3 4 x\n```\n\n**Sample Output 2**\n```\n0\n```\n\nAs mentioned in the problem statement, the answer may be 0.\n\n**Sample Input 3**\n```\n11 4 9\n10 1 2 3 4 5 6 7 8 9 10 o\n11 1 2 3 4 5 6 7 8 9 10 11 o\n10 11 10 9 8 7 6 5 4 3 2 x\n10 11 9 1 4 3 7 5 6 2 10 x\n```\n\n**Sample Output 3**\n```\n8\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 356\n\n# C - Keys Editorial by en_translator:\n\n# By the constraints, the number of keys \\(N \\le 15\\), and the tests \\(M \\le 100\\). \n# There are \\(2^N\\) combinations of authenticities of the keys. We may perform the \\(M\\) tests \n# on all \\(2^N\\) combinations and count the number of proper combinations. \n# \\(2^N \\times M \\le 3.3 \\times 10^6\\) tests are required. \n# Even with \\(N\\) operations per test, the total number of operations is \\(5 \\times 10^7\\), which is fast enough. \n# We achieve this through bitwise enumeration by iterating over \\(i=0,1,\\dots,2^N-1\\). \n# The presence of bit \\(2^k\\) in \\(i\\) determines if the \\((k+1)\\)-th key is real or a dummy. \n# For more details, refer to relevant articles on bitwise enumeration.\n\n# Note that operations exceeding \\(N\\) per test might not meet the execution time limit. \n# Managing whether the \\(k\\)-th key was used limits operations per test to \\(N\\).\n\n# Sample code translated to Python:\nn, m, k = map(int, input().split())\nkey = [[0]*n for _ in range(m)]\nr = []\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c + 1):\n        a = data[j]\n        key[i][a-1] = 1\n    r.append(input().strip())\n\nres = 0\n\nfor i in range(1 << n):\n    tf = [0] * n\n    for j in range(n):\n        if i & (1 << j):\n            tf[j] = 1\n        else:\n            tf[j] = 0\n    jud = True\n    for j in range(m):\n        ck = 0\n        for p in range(n):\n            if key[j][p] == 1 and tf[p] == 1:\n                ck += 1\n        if ck >= k and r[j] == \"x\":\n            jud = False\n        if ck < k and r[j] == \"o\":\n            jud = False\n    if jud:\n        res += 1\n\nprint(res)\n\n# A faster approach using bitwise operations translated to Python:\nn, m, k = map(int, input().split())\nks = [0] * m\nr = [0] * m\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c+1):\n        a = data[j] - 1\n        ks[i] |= (1 << a)\n    s = input().strip()\n    if s == \"o\":\n        r[i] = 1\n    else:\n        r[i] = 0\n\nres = 0\n\nfor i in range(1 << n):\n    jud = True\n    for j in range(m):\n        ok = bin(i & ks[j]).count('1')\n        if ok >= k and r[j] == 0:\n            jud = False\n            break\n        if ok < k and r[j] == 1:\n            jud = False\n            break\n    if jud:\n        res += 1\n\nprint(res)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou have an empty bag. You are given \\( Q \\) queries, which must be processed in order. There are three types of queries:\n\n1. `1 x`: Put one ball with the integer \\( x \\) written on it into the bag.\n2. `2 x`: Remove one ball with the integer \\( x \\) written on it from the bag and discard it. It is guaranteed that the bag has a ball with the integer \\( x \\) written on it when this query is given.\n3. `3`: Print the number of different integers written on the balls in the bag.\n\n**Constraints**\n\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq x \\leq 10^{6} \\)\n- When a query of the second type is given, the bag has a ball with the integer \\( x \\) written on it.\n- There is at least one query of the third type.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nQ\nquery_1\nquery_2\n\u22ee\nquery_Q\n```\n\nThe \\( i \\)-th query \\( \\text{query}_i \\) is given in one of the following three formats:\n\n```\n1 x\n2 x\n3\n```\n\n**Output**\n\nIf there are \\( K \\) queries of the third type, print \\( K \\) lines. The \\( i \\)-th line \\((1 \\leq i \\leq K)\\) should contain the answer to the \\( i \\)-th query of the third type.\n\n**Sample Input 1**\n\n```\n8\n1 3\n1 1\n1 4\n3\n2 1\n3\n1 5\n3\n```\n\n**Sample Output 1**\n\n```\n3\n2\n3\n```\n\n**Explanation**\n\nInitially, the bag is empty.\n- For the first query `1 3`, a ball with the integer 3 written on it enters the bag.\n- For the second query `1 1`, a ball with the integer 1 written on it enters the bag.\n- For the third query `1 4`, a ball with the integer 4 written on it enters the bag.\n- For the fourth query `3`, the bag has balls with the integers 1, 3, 4, so print 3.\n- For the fifth query `2 1`, a ball with the integer 1 written on it is removed from the bag.\n- For the sixth query `3`, the bag has balls with the integers 3, 4, so print 2.\n- For the seventh query `1 5`, a ball with the integer 5 written on it enters the bag.\n- For the eighth query `3`, the bag has balls with the integers 3, 4, 5, so print 3.\n\n**Sample Input 2**\n\n```\n8\n1 2\n1 2\n3\n2 2\n1 4\n1 4\n2 2\n3\n```\n\n**Sample Output 2**\n\n```\n1\n1\n```\n\nSolution:\n\n[BEGIN TEXT]\nLet us consider the properties of each operation, particularly the first and second types. Both operations can increase or decrease the number of distinct numbers in the bag by one. Specifically, adding a ball increases the count by one or zero, and removing a ball decreases the count by one or zero. To determine if each operation affects the count, we need to check how many balls with a specific integer are in the bag. On insertion, if the bag already contains a ball with that number, the distinct count does not increase; otherwise, it increases by one. Similarly, on removal, the change in count depends on the number of balls with that specific integer. Thus, to process the queries, keep track of the current number of distinct integers with an integer and the number of balls with each integer in an array of length \\(10^6\\). For more details, please refer to the sample code.\n[END TEXT]\n \n\n", "problem_ids": ["agc067_b", "abc356_c", "abc366_c"]}, "abc314_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nTakahashi has \\( N \\) cards from the card game \"AtCoder Magics.\" Each card \\( i \\) has two parameters: strength \\( A_i \\) and cost \\( C_i \\).\n\nTakahashi does not like weak cards, so he will discard them. He will repeatedly perform the following operation until it can no longer be done:\n\n- Choose two cards \\( x \\) and \\( y \\) such that \\( A_x > A_y \\) and \\( C_x < C_y \\). Discard card \\( y \\).\n\nIt is assured that when these operations can no longer be performed, the set of remaining cards is uniquely determined. Find this set of cards.\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, C_i \\leq 10^9 \\)\n- All the \\( A_1, A_2, \\dots, A_N \\) are distinct.\n- All the \\( C_1, C_2, \\dots, C_N \\) are distinct.\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 C_1\nA_2 C_2\n...\nA_N C_N\n```\n\n**Output:**\n\nSuppose there are \\( m \\) remaining cards, denoted by their indices \\( i_1, i_2, \\dots, i_m \\), in ascending order. Print these indices in the following format:\n\n```\nm\ni_1 i_2 ... i_m\n```\n\n**Sample Input 1:**\n```\n3\n2 4\n1 1\n3 2\n```\n\n**Sample Output 1:**\n```\n2\n2 3\n```\n\n(Focusing on cards 1 and 3, we have \\( A_1 < A_3 \\) and \\( C_1 > C_3 \\), so card 1 can be discarded. No further operations can be performed. At this point, cards 2 and 3 remain, so print them.)\n\n**Sample Input 2:**\n```\n5\n1 1\n10 2\n100 3\n1000 4\n10000 5\n```\n\n**Sample Output 2:**\n```\n5\n1 2 3 4 5\n```\n\n(In this case, no cards can be discarded.)\n\n**Sample Input 3:**\n```\n6\n32 101\n65 78\n2 29\n46 55\n103 130\n52 40\n```\n\n**Sample Output 3:**\n```\n4\n2 3 5 6\n```\n\nSolution:\n\nBelow is the editorial with the C++ code translated to Python3:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nC - AtCoder Magics Editorial by en_translator \n\nYou can intuitively understand the problem by plotting the data on a two-dimensional plane. The following is a visualization of Sample Input/Output 1. For cards \\(x\\) and \\(y\\), we have \\(A_x > A_y\\) and \\(C_x < C_y\\) if and only if the point corresponding to card \\(x\\) is in the lower-right region of that for card \\(y\\). In Sample Input/Output 1, card \\(3\\) is in the lower-right region of card \\(1\\).\n\nConsider the condition of a card that is never discarded. By the discussion above, a card is never removed if there is no point on the lower-right region of the point for itself. Otherwise, the card is always removed. The set of cards that has no point on its lower-right region can be found as follows. Scan the cards in ascending order of their costs, i.e., from lower points to higher, and include those that update the maximum strength so far (the rightmost one) to the answer. (Not being able to update the maximum strength means there is a card with smaller cost and larger strength, i.e., there is a card on its lower-right region.)\n\nSort cards in ascending order of \\(C_i\\). First, let \\(v = 0\\), and let \\(S\\) be an empty set. For \\(i = 1, 2, \\cdots, N\\) in order, if \\(A_i > v\\), then insert the \\(i\\)-th card, and set \\(v\\) to \\(A_i\\). The resulting \\(S\\) is the answer.\n\nFor sample code 1, it runs as follows. The cards are sorted by \\(C_i\\) as cards \\(2, 3, 1\\).\n\n\\(A_2 (= 1) > v (= 0)\\), so insert card \\(2\\) to \\(S\\), and let \\(v = 1\\). \\(A_3 (= 3) > v (= 1)\\), so insert card \\(3\\) to \\(S\\), and let \\(v = 3\\). \\(A_1 (= 2) < v (= 3)\\), so card \\(1\\) is not inserted to \\(S\\).\n\nFinally, \\(S = \\{ 2, 3 \\}\\).\n\nFor example, it can be implemented in Python as follows. The complexity is \\(O(N \\log N)\\), where sorting is the bottleneck.\n\n```python\ndef atcoder_magics():\n    # Input\n    n = int(input())\n    cards = []\n    for i in range(n):\n        a, c = map(int, input().split())\n        cards.append((a, c, i))\n    \n    # Sort in ascending order of C[i]\n    cards.sort(key=lambda x: x[1])\n    \n    # Compute the answer\n    ans = []\n    v = 0\n    for a, c, index in cards:\n        if a > v:\n            v = a\n            ans.append(index)\n    \n    ans.sort()\n    \n    # Print\n    m = len(ans)\n    print(m)\n    print(' '.join(str(x + 1) for x in ans))\n\n# To invoke the function, simply call:\n# atcoder_magics()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) strings. Each \\( i \\)-th string \\( S_i \\) (\\(1 \\leq i \\leq N\\)) is either \"Takahashi\" or \"Aoki\". Determine how many times \\( S_i \\) is equal to \"Takahashi\".\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( N \\) is an integer.\n- Each \\( S_i \\) is \"Takahashi\" or \"Aoki\". (\\(1 \\leq i \\leq N\\))\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\n**Output**\n\nPrint the count of \\( i \\) such that \\( S_i \\) is equal to \"Takahashi\" as an integer in a single line.\n\n**Sample Input 1**\n```\n3\nAoki\nTakahashi\nTakahashi\n```\n\n**Sample Output 1**\n```\n2\n```\n*S_2* and *S_3* are equal to \"Takahashi\", while *S_1* is not. Therefore, print 2.\n\n**Sample Input 2**\n```\n2\nAoki\nAoki\n```\n\n**Sample Output 2**\n```\n0\n```\nIt is possible that no \\( S_i \\) is equal to \"Takahashi\".\n\n**Sample Input 3**\n```\n20\nAoki\nTakahashi\nTakahashi\nAoki\nAoki\nAoki\nAoki\nTakahashi\nAoki\nAoki\nAoki\nTakahashi\nTakahashi\nAoki\nTakahashi\nAoki\nAoki\nAoki\nAoki\nTakahashi\n```\n\n**Sample Output 3**\n```\n7\n```\n\nSolution:\n\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nA - Count Takahashi Editorial\n\n1. A naive solution  \nDefine an integer variable `ans` for the integer, initializing it with `0`.  \nReceive `N` from the standard input.  \nRepeat the following operation `N` times:  \n\n- Receive a string from the standard input.  \n- If the received string equals \"Takahashi\", add `1` to `ans`.  \n\nPrint the value `ans`.  \n\nSample code in Python:\n```python\nans = 0\nN = int(input())\nfor _ in range(N):\n    S = input()\n    if S == 'Takahashi':\n        ans += 1\nprint(ans)\n```\n\n2. A little tricky solution  \nThe answer to this problem equals the number of occurrences of 'T' in the input.  \n\nSample code in Python:\n```python\nprint(open(0).read().count('T'))\n```\n\nSample code in Python (translated from Haskell):\n```python\nprint(len(list(filter(lambda x: x == 'T', open(0).read()))))\n```\n\nSample code in Bash translated to Python:\n```python\nimport sys\nprint(sum(1 for line in sys.stdin if 'T' in line))\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Score:** 900 points\n\n**Problem Statement:**  \nThere is a circle with circumference \\( L \\), and \\( L \\) people are standing equally spaced along the circumference. They are labeled as person \\( 0, 1, \\cdots, L-1 \\) in clockwise order. Consider choosing \\( N \\) from these \\( L \\) people. The **cost** of a choice is defined as follows:\n\n- For every pair of persons among the \\( N \\) chosen people, find the minimum distance one person has to move along the circumference to reach the other person's position. The maximum value among these distances is the cost.\n\nFind the sum of costs over all possible choices, modulo \\( 998244353 \\).\n\n**Constraints:**\n- \\( 2 \\leq N \\leq L \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**  \nThe input is given from Standard Input in the following format:\n```\nL N\n```\n\n**Output:**  \nPrint the answer.\n\n**Sample Input 1:**  \n```\n4 2\n```\n\n**Sample Output 1:**  \n```\n8\n```\n\nExplanation for Sample Input 1:  \nThe choices of \\( N \\) people and their corresponding costs are as follows:\n- \\( (0,1) \\): cost \\( 1 \\)\n- \\( (0,2) \\): cost \\( 2 \\)\n- \\( (0,3) \\): cost \\( 1 \\)\n- \\( (1,2) \\): cost \\( 1 \\)\n- \\( (1,3) \\): cost \\( 2 \\)\n- \\( (2,3) \\): cost \\( 1 \\)\n\nThe sum of these costs, \\( 8 \\), is the answer.\n\n**Sample Input 2:**  \n```\n5 5\n```\n\n**Sample Output 2:**  \n```\n2\n```\n\nExplanation for Sample Input 2:  \nWe can only choose all of them. In this case, the cost is \\( 2 \\).\n\n**Sample Input 3:**  \n```\n13 5\n```\n\n**Sample Output 3:**  \n```\n7618\n```\n\n**Sample Input 4:**  \n```\n1000000 100000\n```\n\n**Sample Output 4:**  \n```\n664396470\n```\n\nSolution:\n\n```python\nIf we know the answer when person 0 is always chosen, we can multiply it by L / N to get the original answer. Let\u2019s assume that person 0 is always chosen. For each D = 1, 2, ..., it suffices to find the number of ways to choose people so that the cost is less than D. First, people D, ..., L - D cannot be chosen. Next, consider whom to choose among people 1, 2, ..., D - 1. They can be chosen freely without interfering with each other. Finally, consider whom to choose among people L - D + 1, ..., L - 1. The condition for choosing person i is that none of the people in [i - L + D, i - D] have been chosen so far. Here, this interval is basically included within [1, D - 1]. If 2 * D <= i, this interval extends beyond that range, but the exceeding part is included in [D, L - D], from which we already know we are not choosing anyone, so we don\u2019t need to consider it specially. Let W = L - 2 * D + 1. We can regard the operation of choosing people from L - D + 1, ..., L - 1 as the operation of choosing intervals of length W among people 1, ..., D - 1. Then, what we need to consider is selecting people and intervals from people 1, ..., D - 1 so that they do not overlap (it\u2019s acceptable for intervals themselves to overlap). We will call a person chosen in the people selection as a red person. Also, in the interval selection, we will call the starting person of the interval as a blue person. If we fix the number of times red and blue alternate, the total number of ways to choose can be expressed using binomial coefficients. Also, the number of alternations is at most N // W. Therefore, if we perform this calculation for all D, the total computational complexity is O(N + N // 2 + N // 3 + ...) = O(N log N), so it runs sufficiently fast.\n```\n \n\n", "problem_ids": ["abc354_c", "abc359_a", "agc068_a"]}, "abc314_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Country of AtCoder consists of \\( N \\) cities and \\( M \\) roads connecting them. One can travel between any two cities by traversing some roads. The cities are numbered from 1 to \\( N \\), and the roads are numbered from 1 to \\( M \\). Road \\( i \\) connects cities \\( A_i \\) and \\( B_i \\) bidirectionally.\n\nDue to increasing traffic in the country, there is a plan to expand some roads. Currently, no roads have been expanded, and the cost to expand road \\( i \\) is \\( C_i \\).\n\nSince it is difficult to expand all roads at once, the plan is to first designate \\( K \\) out of the \\( N \\) cities as **major cities** and perform the minimum necessary expansion work, so that one can travel between any two major cities using only expanded roads. It has already been decided that cities \\( 1, 2, \\ldots, K-1 \\) will be major cities, but the last major city has not yet been decided.\n\nFor each \\( i = K, K+1, \\ldots, N \\), answer the following question: If city \\( i \\) is designated as the last major city, what is the minimum total cost of the expansion work required to ensure that one can travel between any two major cities using only expanded roads?\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 4000 \\)\n- \\( N-1 \\leq M \\leq 8000 \\)\n- \\( 2 \\leq K \\leq \\min(N, 10) \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- One can travel between any two cities by traversing some roads.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n**Output**\n\nPrint \\( N-K+1 \\) lines. The \\( l \\)-th line \\( (1 \\leq l \\leq N-K+1) \\) should contain the answer to the question for \\( i = l+K-1 \\), as an integer.\n\n**Sample Input 1**\n```\n4 5 3\n1 4 3\n3 4 4\n1 2 4\n2 3 2\n1 3 1\n```\n\n**Sample Output 1**\n```\n3\n6\n```\n\nIn the above figure, circles with numbers represent cities with those numbers, and lines with numbers represent roads with the cost of expansion being that number. The left and right figures correspond to the cases \\( i=3 \\) and \\( i=4 \\), respectively. The colored circles represent the major cities, and the colored thick lines represent the roads that are expanded in an optimal solution. For \\( i=3 \\), expanding roads 4 and 5 results in a total cost of \\( 2+1=3 \\), which is the minimum. For \\( i=4 \\), expanding roads 1, 4, and 5 results in a total cost of \\( 3+2+1=6 \\), which is the minimum.\n\n**Sample Input 2**\n```\n4 3 2\n2 4 28\n1 4 56\n1 3 82\n```\n\n**Sample Output 2**\n```\n84\n82\n56\n```\n\n**Sample Input 3**\n```\n6 12 4\n2 6 68\n2 5 93\n4 6 28\n2 4 89\n3 6 31\n1 3 10\n1 2 53\n3 5 1\n3 5 74\n3 4 22\n4 5 80\n3 4 35\n```\n\n**Sample Output 3**\n```\n85\n64\n94\n```\n\nThere may be multiple roads connecting the same pair of cities.\n\nSolution:\n\nHere is the editorial with the C++ code translated to Python3:\n\n```\nJapan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nOfficial\n\nG - Last Major City Editorial\n\nThis problem is an extension of the minimum Steiner tree problem. We referred to an editorial slide by Yoichi Iwata. A city, road, and cost are simply a vertex, edge, and weight. In an optimal solution, the graph defined by the set of edges to be extended as well as their adjacent vertices forms a tree. For a subset of the vertex set \\(\\{1,2,\\dots,K-1\\}\\) and vertex \\(v\\), \\(f(S,v)\\) is the minimum total weight of the edges of a tree containing vertex \\(v\\) and all vertices in \\(S\\). We seek \\(f(\\{1,2,\\dots,K-1\\}, v)\\) for each \\(K\\leq v\\leq N\\).\n\nThe function \\(f(S,v)\\) can be calculated with Dynamic Programming (DP), using initial values \\(f(\\{i\\}, i)=0\\ (1 \\leq i \\leq K-1)\\). There are two transitions: \n\n1. \\(f(S,v) \\leftarrow \\min(f(S,v),f(S,u) + w)\\) if an edge of weight \\(w\\) connects vertices \\(u\\) and \\(v\\).\n2. \\(f(S,v) \\leftarrow \\min(f(S,v),f(T,v)+f(S\\setminus T,v))\\ (T\\subsetneq S, T\\neq \\emptyset)\\).\n\nThe transitions ensure efficient processing by filling the DP table in ascending order of the size of \\(S\\). The circular dependency in the former transition is managed by determining \\(f(S,v)\\) in ascending order of its value using Dijkstra\u2019s algorithm. The overall complexity is \\(O(3^KN+2^KM\\log M)\\).\n\nSample code (Python3):\n\n```python\nimport sys\nimport heapq\n\ndef chmin(a, b):\n    return b < a\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2]) - 1\n    \n    G = [[] for _ in range(n)]\n\n    index = 3\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        index += 3\n        G[a].append((b, c))\n        G[b].append((a, c))\n\n    dp = [[float('inf')] * n for _ in range(1 << k)]\n    for i in range(k):\n        dp[1 << i][i] = 0\n\n    for bit in range(1, 1 << k):\n        sub = bit\n        while sub > 0:\n            for i in range(n):\n                dp[bit][i] = min(dp[bit][i], dp[sub][i] + dp[bit - sub][i])\n            sub = (sub - 1) & bit\n\n        pq = [(dp[bit][i], i) for i in range(n)]\n        heapq.heapify(pq)\n\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dp[bit][u]:\n                continue\n            for v, l in G[u]:\n                if chmin(dp[bit][v], d + l):\n                    dp[bit][v] = d + l\n                    heapq.heappush(pq, (d + l, v))\n\n    for i in range(k, n):\n        print(dp[-1][i])\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence \\( A \\) of length \\( N \\). Freely choose exactly \\( K \\) elements from \\( A \\) and remove them, then concatenate the remaining elements in their original order to form a new sequence \\( B \\). Find the minimum possible value of this: the maximum value of \\( B \\) minus the minimum value of \\( B \\).\n\n**Constraints**\n\n- All inputs are integers.\n- \\( 1 \\le K < N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le A_i \\le 10^9 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n5 2\n3 1 5 4 9\n```\n\n**Sample Output 1**\n```\n2\n```\n\n**Sample Input 2**\n```\n6 5\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n8 3\n31 43 26 6 18 36 22 13\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Editorial - Denso Create Programming Contest 2024 (AtCoder Beginner Contest 361)\n\nRemoving \\(K\\) elements of \\(A\\) is equivalent to retaining \\((N-K)\\) elements to form \\(B\\). To minimize (maximum value of \\(B\\)) - (minimum value of \\(B\\)), it is optimal to retain the \\((N-K)\\) smallest elements among the elements of \\(A\\) greater than or equal to \\(A_x\\), the fixed minimum of \\(B\\). In other words, it is optimal to choose \\((N-K)\\) consecutive elements in \\(A\\) sorted in ascending order.\n\nSolution: \n1. Sort \\(A\\) such that \\(A_1 \\le A_2 \\le \\dots \\le A_N\\).\n2. The answer is the minimum of \\(A_{l+(N-K)-1} - A_l\\) for \\(1 \\le l \\le K+1\\).\n3. Implement with sorting and a for loop, with a total time complexity of \\(O(N \\log N)\\).\n\nSample code (Python3):\n\n```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\nres = int(2e9)\nfor i in range(k + 1):\n    res = min(res, a[i + (n - k) - 1] - a[i])\n\nprint(res)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\). Additionally, you are given an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n1. Choose integers \\( l \\) and \\( r \\) such that \\( 1 \\leq l < r \\leq N \\).\n   - The pair \\((l, r)\\) must satisfy the following conditions:\n     - \\( K \\leq r - l \\).\n     - \\( P_l > P_r \\) at the time of the operation.\n     - The pair \\((l, r)\\) has never been chosen before.\n\n2. Swap the values of \\( P_l \\) and \\( P_r \\).\n\nYour goal is to maximize the number of operations. Find one way to achieve this.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( 1 \\leq K \\leq N - 1 \\)\n- \\( (P_1, P_2, \\ldots, P_N) \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\ldots P_N\n```\n\n### Output\n\nPrint the answer in the following format:\n```\nm\nl_1 r_1\nl_2 r_2\n\\vdots\nl_m r_m\n```\n\nHere, \\( m \\) is the maximum number of operations, and \\( l_i \\) and \\( r_i \\) are the values of \\( l \\) and \\( r \\) chosen in the \\( i \\)-th operation, respectively. If multiple solutions exist, you can print any of them.\n\n### Sample Input 1\n```\n3 1\n3 2 1\n```\n\n### Sample Output 1\n```\n3\n2 3\n1 3\n1 2\n```\n\nIn this example, the maximum number of operations is \\( 3 \\). The operations in the sample output proceed as follows:\n\n1. Choose \\((l, r) = (2, 3)\\). We have \\( 1 \\leq 3 - 2 \\) and \\( P_2 > P_3 \\), and \\((2, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_2 \\) and \\( P_3 \\), resulting in \\( P = (3, 1, 2) \\).\n\n2. Choose \\((l, r) = (1, 3)\\). We have \\( 1 \\leq 3 - 1 \\) and \\( P_1 > P_3 \\), and \\((1, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_3 \\), resulting in \\( P = (2, 1, 3) \\).\n\n3. Choose \\((l, r) = (1, 2)\\). We have \\( 1 \\leq 2 - 1 \\) and \\( P_1 > P_2 \\), and \\((1, 2)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_2 \\), resulting in \\( P = (1, 2, 3) \\).\n\nSolution:\n\n[BEGIN TEXT]\nLet\u2019s consider the inverse permutation \\(Q\\) of \\(P\\). In other words, \\(Q_{P_i} = i\\). Rephrasing the operation with \\(Q\\) as the main focus, it becomes: Choose \\(i, j\\) such that \\(1 \\leq i < j \\leq N\\) and \\(Q_i - Q_j \\geq K\\). Here, the pair \\((Q_i, Q_j)\\) must not have been chosen before. Swap \\(Q_i\\) and \\(Q_j\\).\n\nWe define the pseudo-inversion count of \\(Q\\) as the number of integer pairs \\((i, j)\\) such that \\(i < j\\) and \\(Q_i - Q_j \\geq K\\). Performing the operation decreases the pseudo-inversion count by at least \\(1\\). It is possible to construct a sequence of operations that decreases the pseudo-inversion count by \\(1\\) each time. Specifically, proceed as follows: Iterate \\(x = 1, 2, \\cdots, N\\). Assume that, when processing a certain \\(x\\), the pseudo-inversion count of \\(Q_1, \\cdots, Q_{x-1}\\) is \\(0\\). Enumerate \\(Q_i\\) that satisfy \\(i < x\\) and \\(Q_i - Q_x \\geq K\\), and denote them as \\(i_1, i_2, \\cdots, i_s\\). Then, process \\((i_s, x), (i_{s-1}, i_s), \\cdots, (i_1, i_2)\\) in this order. This decreases the pseudo-inversion count by \\(1\\) with each operation. The same pair \\((Q_i, Q_j)\\) will not be operated on more than once. A straightforward implementation of these steps yields an \\(O(N^2)\\) time solution.\n[END TEXT]\n \n\n", "problem_ids": ["abc364_g", "abc361_c", "arc180_b"]}, "abc314_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). Each edge \\( i \\) in the tree connects two vertices \\( A_i \\) and \\( B_i \\).\n\nConsider a subtree that can be obtained by removing some (possibly zero) edges and vertices from this tree. Your task is to find the minimum number of vertices required in such a subtree that includes all of \\( K \\) specified vertices \\( V_1, V_2, \\ldots, V_K \\).\n\n**Constraints**\n- \\( 1 \\leq K \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq V_1 < V_2 < \\ldots < V_K \\leq N \\)\n- The given graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN K\nA_1 B_1\nA_2 B_2\n...\nA_{N-1} B_{N-1}\nV_1 V_2 ... V_K\n```\n\n**Output**\n\nPrint the minimum number of vertices in the subtree that includes the desired vertices.\n\n**Sample Input 1**\n```\n7 3\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n1 3 5\n```\n\n**Sample Output 1**\n```\n4\n```\n\nThe given tree is shown on the left below. The subtree with the minimum number of vertices that includes vertices \\( 1, 3, 5 \\) is shown on the right.\n\n**Sample Input 2**\n```\n4 4\n3 1\n1 4\n2 1\n1 2 3 4\n```\n\n**Sample Output 2**\n```\n4\n```\n\n**Sample Input 3**\n```\n5 1\n1 4\n2 3\n5 2\n1 2\n1\n```\n\n**Sample Output 3**\n```\n1\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Hitachi Vantara Programming Contest 2024 (AtCoder Beginner Contest 368)\n\nD - Minimum Steiner Tree Editorial by en_translator\n\nIf \\(K=1\\), the answer is obviously \\(1\\). For other cases, define a tree as applicable if it is obtained by removing zero or more edges and vertices from the original graph and contains all vertices \\(V_1, \\ldots, V_K\\). A vertex is bad if its degree is \\(1\\) and it is not one of \\(V_1,\\ldots,V_K\\). The sought tree is obtained by repeatedly removing a bad vertex and its adjacent edge from the original tree as many times as possible.\n\nProof:\n\n1. An applicable tree with the minimum number of vertices does not have a bad vertex. If it has a bad vertex, the tree remains applicable even after removing that vertex. Hence, a minimal applicable tree does not have a bad vertex.\n\n2. An applicable tree without a bad vertex is minimal. For any applicable tree \\(T\\) without a bad vertex, and any minimal tree \\(T'\\), consider their intersection as subgraphs. If it forms a tree or is empty, the tree \\(T''\\) obtained by contracting the vertices in \\(T \\cap T'\\) must be a single vertex, implying \\(T \\subseteq T'\\). By minimality of \\(T'\\), we conclude \\(T = T'\\).\n\nThis operation can be efficiently performed by managing the vertices directly connected by an edge for each vertex.\n\nWriter\u2019s solution (Python):\n```python\nN, K = map(int, input().split())\nedge = [set() for _ in range(N)]\n\nfor _ in range(N-1):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  edge[a].add(b)\n  edge[b].add(a)\n\nV = set(map(int, input().split()))\nV = {x - 1 for x in V}\n\ndeg = [len(s) for s in edge]\nq = [i for i, d in enumerate(deg) if d == 1]\n\nans = N\nfor v in q:\n  if v in V: continue\n  vv = edge[v].pop()\n  edge[vv].discard(v)\n  ans -= 1\n  if len(edge[vv]) == 1: q.append(vv)\n\nprint(ans)\n```\n\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is an integer sequence \\( S \\) of length \\( N \\). Initially, all elements of \\( S \\) are \\( 0 \\).\n\nYou are also given two integer sequences of length \\( Q \\): \\( P = (P_1, P_2, \\dots, P_Q) \\) and \\( V = (V_1, V_2, \\dots, V_Q) \\).\n\nSnuke wants to perform \\( Q \\) operations on the sequence \\( S \\) in order. The \\( i \\)-th operation is as follows:\n\n- Perform one of the following:\n  - Replace each of the elements \\( S_1, S_2, \\dots, S_{P_i} \\) with \\( V_i \\). However, before this operation, if there is an element among \\( S_1, S_2, \\dots, S_{P_i} \\) that is strictly greater than \\( V_i \\), Snuke will start crying.\n  - Replace each of the elements \\( S_{P_i}, S_{P_i+1}, \\dots, S_N \\) with \\( V_i \\). However, before this operation, if there is an element among \\( S_{P_i}, S_{P_i+1}, \\dots, S_N \\) that is strictly greater than \\( V_i \\), Snuke will start crying.\n\nFind the number of sequences of \\( Q \\) operations where Snuke can perform all operations without crying, modulo \\( 998244353 \\).\n\nTwo sequences of operations are distinguished if and only if there is \\( 1 \\leq i \\leq Q \\) such that the choice for the \\( i \\)-th operation is different.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 5000 \\)\n- \\( 1 \\leq Q \\leq 5000 \\)\n- \\( 1 \\leq P_i \\leq N \\)\n- \\( 1 \\leq V_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nP_1 V_1\nP_2 V_2\n\\vdots\nP_Q V_Q\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n\n```\n8 3\n1 8\n8 1\n2 1\n```\n\n**Sample Output 1**\n\n```\n1\n```\n\nSnuke can perform the three operations without crying as follows:\n1. Replace \\( S_1 \\) with \\( 8 \\).\n2. Replace \\( S_8 \\) with \\( 1 \\).\n3. Replace \\( S_2, S_3, \\dots, S_8 \\) with \\( 1 \\).\n\nNo other sequences of operations satisfy the conditions, so the answer is \\( 1 \\). For example, if he replaces \\( S_1, S_2, \\dots, S_8 \\) with \\( 8 \\) in the first operation, he will cry in the second operation regardless of the choice.\n\n**Sample Input 2**\n\n```\n8 3\n8 1\n1 8\n1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\nNo matter how he performs the first two operations, he will cry in the third operation.\n\n**Sample Input 3**\n\n```\n241 82\n190 3207371\n229 3639088\n61 4428925\n84 17258698\n34 42692503\n207 59753183\n180 67198566\n78 99285033\n60 102449991\n234 122146510\n111 126959145\n141 152331579\n78 159855439\n11 169658471\n22 189991287\n37 204602946\n73 209329065\n72 215363269\n152 236450854\n175 237822921\n22 261431608\n144 252550201\n54 268889550\n238 276997357\n69 313065279\n226 330144323\n6 335788783\n126 345410019\n220 348318997\n166 365778763\n142 382251905\n200 406191336\n234 392702679\n83 409660987\n183 410908761\n142 445707116\n205 470279207\n230 486436406\n156 494269002\n113 495687706\n200 500005738\n162 505246499\n201 548652987\n86 449551554\n62 459527873\n32 574001635\n230 601073337\n175 610244315\n174 613857555\n181 637452273\n158 637866397\n148 648101378\n172 646898076\n144 682578257\n239 703460335\n192 713255331\n28 727075136\n196 730768166\n111 751850547\n90 762445737\n204 762552166\n72 773170159\n240 803415865\n32 798873367\n195 814999380\n72 842641864\n125 851815348\n116 858041919\n200 869948671\n195 873324903\n5 877767414\n105 877710280\n150 877719360\n9 884707717\n230 880263190\n88 967344715\n49 977643789\n167 979463984\n70 981400941\n114 991068035\n94 991951735\n141 995762200\n```\n\n**Sample Output 3**\n\n```\n682155965\n```\n\nRemember to take the count modulo \\( 998244353 \\).\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nA - Chmax Rush! Editorial by evima\n\nSolution: Let\u2019s denote the \\(i\\)-th operation as operation \\(i\\). For each operation, we will refer to the former choice as the left operation and the latter choice as the right operation. Consider the relationship between operations \\(i\\) and \\(j\\) for all integer pairs \\((i, j)\\) such that \\(1 \\leq i < j \\leq Q\\).\n\n- When \\(V_i \\leq V_j\\): Any choice is fine.\n- When \\(V_i > V_j\\) and \\(P_i = P_j\\): No matter what, Snuke will cry during operation \\(j\\), so the answer is \\(0\\).\n- When \\(V_i > V_j\\) and \\(P_i < P_j\\): Operation \\(i\\) must be a left operation, and operation \\(j\\) must be a right operation.\n- When \\(V_i > V_j\\) and \\(P_i > P_j\\): Operation \\(i\\) must be a right operation, and operation \\(j\\) must be a left operation.\n\nAfter determining the direction of each operation in this way, if there is a contradiction, it is clear that the answer is \\(0\\). If there is no contradiction, the answer is at least \\(1\\). This is because, for any operation, the direction is set so that it can be performed after the previous operations. For those operations whose direction is not set, either choice is fine, so let \\(x\\) be the number of such operations, and the answer is \\(2^x\\) modulo \\(998244353\\). Therefore, by implementing this directly, we can find the answer in \\(O(Q^2)\\) time. This is fast enough to solve this problem.\n\nJudge\u2019s Solution (PyPy3):\n```python\ndef change(p,k):\n    global kind\n    if kind[p]==0:\n        kind[p]=k\n    elif kind[p]!=k:\n        print(0)\n        exit()\n\nN,Q=map(int,input().split())\nope=[tuple(map(int,input().split())) for i in range(Q)]\nkind=[0]*Q\nfor i in range(Q):\n    for j in range(i+1,Q):\n        if ope[i][1]<=ope[j][1]:\n            continue\n        if ope[i][0]==ope[j][0]:\n            print(0)\n            exit()\n        elif ope[i][0]<ope[j][0]:\n            change(i,-1)\n            change(j,1)\n        else:\n            change(i,1)\n            change(j,-1)\nprint(pow(2,kind.count(0),998244353))\n```\n\nBonus: Consider how to solve this problem quickly even when \\(N, Q \\leq 2 \\times 10^5\\).\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nTakahashi is growing a plant. The height of the plant at the time of germination is \\(0\\,\\mathrm{cm}\\). Each night from the day of germination, considered as day \\(0\\), the height of the plant increases by \\(2^i\\,\\mathrm{cm}\\) on day \\(i\\) (\\(0 \\le i\\)).\n\nTakahashi has a height of \\(H\\,\\mathrm{cm}\\).\n\nEvery morning, Takahashi measures his height against the plant. Find the first day such that the plant's height is strictly greater than Takahashi's height in the morning.\n\n### Constraints\n- \\(1 \\leq H \\leq 10^{9}\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nH\n```\n\n### Output\nPrint an integer representing the first day such that the plant's height is greater than Takahashi's height in the morning.\n\n### Sample Input 1\n```\n54\n```\n\n### Sample Output 1\n```\n6\n```\n**Explanation:** The plant's height in the mornings of days \\(1, 2, 3, 4, 5, 6\\) will be \\(1\\,\\mathrm{cm}, 3\\,\\mathrm{cm}, 7\\,\\mathrm{cm}, 15\\,\\mathrm{cm}, 31\\,\\mathrm{cm}, 63\\,\\mathrm{cm}\\), respectively. The plant becomes taller than Takahashi in the morning of day \\(6\\), so print \\(6\\).\n\n### Sample Input 2\n```\n7\n```\n\n### Sample Output 2\n```\n4\n```\n**Explanation:** The plant's height will be \\(7\\,\\mathrm{cm}\\) in the morning of day \\(3\\) and \\(15\\,\\mathrm{cm}\\) in the morning of day \\(4\\). The plant becomes taller than Takahashi in the morning of day \\(4\\), so print \\(4\\). Note that, in the morning of day \\(3\\), the plant is as tall as Takahashi, but not taller.\n\n### Sample Input 3\n```\n262144\n```\n\n### Sample Output 3\n```\n19\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\n## A - Exponential Plant Editorial\n\nUse a while statement to repeatedly add the delta to the height of the plant until it exceeds Takahashi\u2019s height. This simulation will allow you to solve this problem. Also, the height at day \\(30\\) is \\(1073741823\\, \\mathrm{cm}(> 10^{9}\\, \\mathrm{cm})\\), so just using a while statement to find the daily height is fast enough.\n\n**Sample code (Python):**\n```python\nh=int(input())\nnow=0\nans=0\nwhile now<=h:\n    now+=1<<ans\n    ans+=1\n\nprint(ans)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc368_d", "arc182_a", "abc354_a"]}, "abc314_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 300 points\n\nProblem Statement:\n\nIn AtCoder Land, there are \\( N \\) popcorn stands numbered from 1 to \\( N \\). They have \\( M \\) different flavors of popcorn, labeled from 1 to \\( M \\). However, not every stand sells all flavors of popcorn.\n\nTakahashi has obtained information about which flavors of popcorn are sold at each stand. This information is represented by \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\), each of length \\( M \\). If the \\( j \\)-th character of \\( S_i \\) is 'o', it means that stand \\( i \\) sells flavor \\( j \\) of popcorn. If it is 'x', it means that stand \\( i \\) does not sell flavor \\( j \\). Each stand sells at least one flavor of popcorn, and each flavor of popcorn is sold at least at one stand.\n\nTakahashi wants to try all the flavors of popcorn but does not want to move around too much. Determine the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn.\n\nConstraints:\n\n- \\( N \\) and \\( M \\) are integers.\n- \\( 1 \\leq N, M \\leq 10 \\)\n- Each \\( S_i \\) is a string of length \\( M \\) consisting of 'o' and 'x'.\n- For every \\( i \\) (1 \u2264 \\( i \\) \u2264 \\( N \\)), there is at least one 'o' in \\( S_i \\).\n- For every \\( j \\) (1 \u2264 \\( j \\) \u2264 \\( M \\)), there is at least one \\( i \\) such that the \\( j \\)-th character of \\( S_i \\) is 'o'.\n\nInput:\n\nThe input is given from Standard Input in the following format:\n```\nN M\nS_1\nS_2\n...\nS_N\n```\n\nOutput:\n\nPrint the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn.\n\nSample Input 1:\n```\n3 5\noooxx\nxooox\nxxooo\n```\n\nSample Output 1:\n```\n2\n```\n\nBy visiting the 1st and 3rd stands, you can buy all the flavors of popcorn. It is impossible to buy all the flavors from a single stand, so the answer is 2.\n\nSample Input 2:\n```\n3 2\noo\nox\nxo\n```\n\nSample Output 2:\n```\n1\n```\n\nSample Input 3:\n```\n8 6\nxxoxxo\nxxoxxx\nxoxxxx\nxxxoxx\nxxoooo\nxxxxox\nxoxxox\noxoxxo\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n```python\ndef main():\n    n, m = map(int, input().split())\n    s = [input().strip() for _ in range(n)]\n    ans = n\n    for bit in range(1 << n):\n        exist = [False] * m\n        cnt = 0\n        for i in range(n):\n            if (bit >> i) & 1:\n                cnt += 1\n                for j in range(m):\n                    if s[i][j] == 'o':\n                        exist[j] = True\n        all_exist = all(exist[j] for j in range(m))\n        if all_exist:\n            ans = min(ans, cnt)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given two strings \\( S \\) and \\( T \\) consisting of lowercase English letters. Here, \\( S \\) and \\( T \\) have equal lengths.\n\nLet \\( X \\) be an empty array, and repeat the following operation until \\( S \\) equals \\( T \\):\n\n- Change one character in \\( S \\), and append \\( S \\) to the end of \\( X \\).\n\nFind the array of strings \\( X \\) with the minimum number of elements obtained in this way. If there are multiple such arrays with the minimum number of elements, find the lexicographically smallest one among them.\n\n**Lexicographical order on arrays of strings:**\n\nA string \\( S = S_1 S_2 \\ldots S_N \\) of length \\( N \\) is lexicographically smaller than a string \\( T = T_1 T_2 \\ldots T_N \\) of length \\( N \\) if there exists an integer \\( 1 \\leq i \\leq N \\) such that both of the following are satisfied:\n\n1. \\( S_1 S_2 \\ldots S_{i-1} = T_1 T_2 \\ldots T_{i-1} \\)\n2. \\( S_i \\) comes earlier than \\( T_i \\) in alphabetical order.\n\nAn array of strings \\( X = (X_1, X_2, \\ldots, X_M) \\) with \\( M \\) elements is lexicographically smaller than an array of strings \\( Y = (Y_1, Y_2, \\ldots, Y_M) \\) with \\( M \\) elements if there exists an integer \\( 1 \\leq j \\leq M \\) such that both of the following are satisfied:\n\n1. \\( (X_1, X_2, \\ldots, X_{j-1}) = (Y_1, Y_2, \\ldots, Y_{j-1}) \\)\n2. \\( X_j \\) is lexicographically smaller than \\( Y_j \\).\n\n**Constraints:**\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters with lengths between 1 and 100, inclusive.\n- The lengths of \\( S \\) and \\( T \\) are equal.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n- Line 1: String \\( S \\)\n- Line 2: String \\( T \\)\n\n**Output:**\nLet \\( M \\) be the number of elements in the desired array. Print \\( M + 1 \\) lines:\n- The first line should contain the value of \\( M \\).\n- The \\( i + 1 \\)-th line (for \\( 1 \\leq i \\leq M \\)) should contain the \\( i \\)-th element of the array.\n\n**Sample Input 1:**\n```\nadbe\nbcbc\n```\n\n**Sample Output 1:**\n```\n3\nacbe\nacbc\nbcbc\n```\n\n**Explanation:**\nInitially, \\( S = \\) `adbe`. We can obtain \\( X = ( \\) `acbe`, `acbc`, `bcbc` \\( ) \\) by performing the following operations:\n1. Change \\( S \\) to `acbe` and append `acbe` to the end of \\( X \\).\n2. Change \\( S \\) to `acbc` and append `acbc` to the end of \\( X \\).\n3. Change \\( S \\) to `bcbc` and append `bcbc` to the end of \\( X \\).\n\n**Sample Input 2:**\n```\nabcde\nabcde\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\nafwgebrw\noarbrenq\n```\n\n**Sample Output 3:**\n```\n8\naawgebrw\naargebrw\naarbebrw\naarbebnw\naarbebnq\naarbeenq\naarbrenq\noarbrenq\n```\n\nSolution:\n\n        Here is a cleaned-up version of the text:\n\n---\n\nLet \\(N\\) be the length of the string, and \\(x\\) be the number of \\(i\\) with \\(S_i \\neq T_i\\). The minimum possible number of operations is \\(x\\), and each operation replaces \\(S_i\\) with \\(T_i\\) for some \\(i\\) where \\(S_i \\neq T_i\\).\n\nThe order of these operations can vary, and to achieve a lexicographically minimum string, we can consider doing the operation that results in the minimal string. This brute-force approach can be accomplished in \\(O(N^3)\\) time. It can be further optimized: when \\(S_i\\) is replaced with \\(T_i\\), the string becomes larger if \\(S_i < T_i\\) and smaller if \\(S_i > T_i\\). Therefore, it's optimal to apply operations on the minimum \\(i\\) with \\(S_i > T_i\\). If there\u2019s no such \\(i\\), apply the operation against the maximum \\(i\\) with \\(S_i < T_i\\). This approach runs in \\(O(N^2)\\) time.\n\nSample code (\\(O(N^3)\\)):\n\n```python\ndef main():\n    s = input()\n    t = input()\n    ans = []\n    n = len(s)\n    while s != t:\n        nxt = 'z' * n\n        for i in range(n):\n            if s[i] != t[i]:\n                tmp = list(s)\n                tmp[i] = t[i]\n                s_tmp = ''.join(tmp)\n                nxt = min(nxt, s_tmp)\n        ans.append(nxt)\n        s = nxt\n    sz = len(ans)\n    print(sz)\n    for e in ans:\n        print(e)\n\nmain()\n```\n\nSample code (\\(O(N^2)\\)):\n\n```python\ndef main():\n    s = input()\n    t = input()\n    ans = []\n    v = []\n    n = len(s)\n    for i in range(n):\n        if s[i] > t[i]:\n            v.append(i)\n    for i in range(n - 1, -1, -1):\n        if s[i] < t[i]:\n            v.append(i)\n    sz = len(v)\n    for i in range(sz):\n        s = list(s)\n        s[v[i]] = t[v[i]]\n        ans.append(''.join(s))\n        s = ''.join(s)\n    print(sz)\n    for e in ans:\n        print(e)\n\nmain()\n```\n\n---\n \n\n", "problem_ids": ["abc355_g", "abc358_c", "abc370_c"]}, "abc315_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) people participating in an event, and the transportation cost for the \\( i \\)-th person is \\( A_i \\) yen. Takahashi, the organizer of the event, decided to set a maximum limit \\( x \\) for the transportation subsidy. The subsidy for person \\( i \\) will be \\( \\min(x, A_i) \\) yen. Here, \\( x \\) must be a non-negative integer.\n\nGiven that Takahashi's budget is \\( M \\) yen, and he wants the total transportation subsidy for all \\( N \\) people to be at most \\( M \\) yen, what is the maximum possible value of the subsidy limit \\( x \\)?\n\nIf the subsidy limit can be made infinitely large, report that instead.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^{14} \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_{N}\n```\n\n**Output:**\n\nPrint the maximum value of the subsidy limit \\( x \\) that satisfies the budget condition, as an integer.\n\nIf the subsidy limit can be made infinitely large, print `infinite` instead.\n\n**Sample Input 1:**\n```\n4 8\n1 3 2 4\n```\n\n**Sample Output 1:**\n```\n2\n```\n\n*Explanation:*\n\nIf the subsidy limit is set to 2 yen, the total transportation subsidy for all \\( N \\) people is \\( \\min(2,1) + \\min(2,3) + \\min(2,2) + \\min(2,4) = 7 \\) yen, which is within the budget of 8 yen.\n\nIf the subsidy limit is set to 3 yen, the total transportation subsidy for all \\( N \\) people is \\( \\min(3,1) + \\min(3,3) + \\min(3,2) + \\min(3,4) = 9 \\) yen, which exceeds the budget of 8 yen. Therefore, the maximum possible value of the subsidy limit is 2 yen.\n\n**Sample Input 2:**\n```\n3 20\n5 3 2\n```\n\n**Sample Output 2:**\n```\ninfinite\n```\n\n*Explanation:*\n\nThe subsidy limit can be made infinitely large.\n\n**Sample Input 3:**\n```\n10 23\n2 5 6 5 2 1 7 9 7 2\n```\n\n**Sample Output 3:**\n```\n2\n```\n\nSolution:\n\n```\nToyota Programming Contest 2024#8 (AtCoder Beginner Contest 365) Editorial\n\nC - Transportation Expenses Editorial\n\nFirst, we consider when the answer is infinite. It is infinite when the total sum of \\(A\\) is not greater than \\(M\\), as the total cost required is never greater than \\(M\\). Conversely, if the total sum is greater than \\(M\\), setting the upper bound to the maximum value of \\(A\\) leads to exceeding the budget, so a maximum value exists.\n\nAssuming the answer is not infinite, a technique called binary search is effective for finding the maximum value subject to some condition. Given an upper bound \\(x\\), it can be determined if the total cost exceeds the budget in \\(O(N)\\) time. The number of iterations in the binary search is \\(O(\\log{\\max{A}})\\) because the upper bound of the answer is \\(\\max{A}\\). Therefore, the problem can be solved in \\(O(N\\log{\\max{A}})\\) time.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nA pair of binary strings \\( (S, T) \\) is called **good** if and only if the following conditions are satisfied:\n\n1. \\( S \\) and \\( T \\) contain the same number of \\( 0 \\)s.\n2. \\( S \\) and \\( T \\) contain the same number of \\( 1 \\)s.\n\nParticularly, for a good string pair \\( (S, T) \\), \\( S \\) and \\( T \\) have the same length.\n\nFor a good string pair \\( (S, T) \\), we define an undirected graph \\( G(S, T) \\) as follows:\n\n- Let \\( L \\) be the length of \\( S \\). Create a graph \\( g \\) with vertices \\( 1, 2, \\cdots, L \\).\n- Let \\( n \\) be the number of \\( 0 \\)s in \\( S \\). Let the indices of \\( 0 \\)s in \\( S \\) be \\( 1 \\leq a_1 < a_2 < \\cdots < a_n \\leq L \\). Let the indices of \\( 0 \\)s in \\( T \\) be \\( 1 \\leq b_1 < b_2 < \\cdots < b_n \\leq L \\). For each \\( 1 \\leq i \\leq n \\), add an edge between vertices \\( a_i \\) and \\( b_i \\) to \\( g \\).\n- Let \\( m \\) be the number of \\( 1 \\)s in \\( S \\). Let the indices of \\( 1 \\)s in \\( S \\) be \\( 1 \\leq c_1 < c_2 < \\cdots < c_m \\leq L \\). Let the indices of \\( 1 \\)s in \\( T \\) be \\( 1 \\leq d_1 < d_2 < \\cdots < d_m \\leq L \\). For each \\( 1 \\leq i \\leq m \\), add an edge between vertices \\( c_i \\) and \\( d_i \\) to \\( g \\).\n\nThe graph \\( g \\) obtained through the above steps is \\( G(S, T) \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\). Find one good string pair \\( (S, T) \\) satisfying all of the following conditions:\n\n- Let \\( L \\) be the length of \\( S \\). It satisfies \\( N \\leq L \\leq 10^5 \\).\n- For each pair \\( 1 \\leq i, j \\leq N \\), vertices \\( i \\) and \\( j \\) belong to the same connected component in \\( G(S, T) \\) if and only if \\( A_i = A_j \\).\n\nIt can be proved that a solution always exists under the constraints of this problem.\n\n### Constraints\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n### Output\nPrint a solution in the following format:\n```\nL\nS\nT\n```\nHere, \\( L \\) is the length of \\( S \\) and \\( T \\).\n\nIf multiple solutions exist, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n1 2 1\n```\n\n### Sample Output 1\n```\n4\n0011\n1100\n```\nFor the \\( S \\) and \\( T \\) in the sample output, we obtain \\( G(S, T) \\) as follows:\n- Prepare a graph \\( g \\) with 4 vertices.\n- The indices of \\( 0 \\)s in \\( S \\) are \\( (1, 2) \\), and the indices of \\( 0 \\)s in \\( T \\) are \\( (3, 4) \\). Add edges \\( (1, 3) \\) and \\( (2, 4) \\) to \\( g \\).\n- The indices of \\( 1 \\)s in \\( S \\) are \\( (3, 4) \\), and the indices of \\( 1 \\)s in \\( T \\) are \\( (1, 2) \\). Add edges \\( (3, 1) \\) and \\( (4, 2) \\) to \\( g \\).\n\n\\( G(S, T) \\) has a connected component with vertices \\( (1, 3) \\) and another with vertices \\( (2, 4) \\). This satisfies all the conditions, so this \\( (S, T) \\) is a valid output.\n\n### Sample Input 2\n```\n5\n1 2 3 4 5\n```\n\n### Sample Output 2\n```\n5\n01010\n01010\n```\n\n### Sample Input 3\n```\n6\n1 1 1 1 1 1\n```\n\n### Sample Output 3\n```\n6\n011111\n111110\n```\n\n### Sample Input 4\n```\n10\n1 2 3 2 4 3 4 4 5 6\n```\n\n### Sample Output 4\n```\n21\n000101010111100011011\n011010000010101111110\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere's the cleaned version of the solution:\n\nFirst, initialize \\(S = 0 \\times N\\) (a string of \\(N\\) 0s), and \\(T = 1 \\times N\\). To satisfy the conditions, perform these operations: \n\n1. Append 0 to the end of \\(S\\), and 0 to the end of \\(T\\).\n2. Append 1 to the end of \\(S\\), and 0 to the end of \\(T\\).\n\nTrack the connected components of unmatched 0s and 1s. Let \\(x_1, x_2, \\cdots, x_k\\) be the components of unmatched 0s in \\(S\\), and \\(y_1, y_2, \\cdots, y_k\\) be for 1s in \\(T\\). Adding 0 to both \\(S\\) and \\(T\\) cyclically shifts \\(x\\) one position left. Adding 1 to \\(S\\) and 0 to \\(T\\) removes \\(x_1\\) and \\(y_1\\) and connects \\(x_1\\) and \\(y_1\\).\n\nTo meet \\(A\\), prepare a permutation \\(P\\) aligning with \\(A\\)'s cycle decomposition and connect \\(x_1\\) and \\(y_1\\) when \\(x_1 = A_{y_1}\\). The operations number is \\(O(N^2)\\).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). Takahashi will perform the following operation exactly once:\n\n- Choose an integer \\( x \\) between 1 and \\( N \\), inclusive, and an arbitrary integer \\( y \\). Replace \\( A_x \\) with \\( y \\).\n\nFind the maximum possible length of a longest increasing subsequence (LIS) of \\( A \\) after performing the operation.\n\n**What is the longest increasing subsequence?**\n\nA subsequence of a sequence \\( A \\) is a sequence that can be derived from \\( A \\) by extracting some elements without changing the order.\n\nA longest increasing subsequence of a sequence \\( A \\) is a longest subsequence of \\( A \\) that is strictly increasing.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n\n```\n4\n3 2 2 4\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n*Explanation:*\n\nThe length of a LIS of the given sequence \\( A \\) is 2. For example, if you replace \\( A_1 \\) with 1, the length of a LIS of \\( A \\) becomes 3, which is the maximum.\n\n**Sample Input 2:**\n\n```\n5\n4 5 3 6 7\n```\n\n**Sample Output 2:**\n\n```\n4\n```\n\nSolution:\n\n```python\nimport sys\n\nclass RangeMaxSegmentTree:\n    def __init__(self, size, initial_value):\n        self.size = size\n        self.data = [initial_value] * (2 * size)\n        self.initial_value = initial_value\n\n    def update(self, index, value):\n        index += self.size\n        self.data[index] = value\n        while index > 1:\n            index //= 2\n            self.data[index] = max(self.data[2 * index], self.data[2 * index + 1])\n\n    def calc_max(self, left, right):\n        left += self.size\n        right += self.size\n        max_value = self.initial_value\n        while left < right:\n            if left % 2 == 1:\n                max_value = max(max_value, self.data[left])\n                left += 1\n            if right % 2 == 1:\n                right -= 1\n                max_value = max(max_value, self.data[right])\n            left //= 2\n            right //= 2\n        return max_value\n\ndef longest_increasing_subsequence(A):\n    N = len(A)\n    dp = [[-float('inf')] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, N + 1):\n        max_value = 0\n        for j in range(0, A[i-1]):\n            max_value = max(max_value, dp[i - 1][j])\n        dp[i][A[i-1]] = max_value + 1\n\n    max_lis_length = max(dp[N])\n    return max_lis_length\n\ndef longest_increasing_subsequence_with_segment_tree(A):\n    N = len(A)\n    dp = RangeMaxSegmentTree(N + 1, -float('inf'))\n    dp.update(0, 0)\n\n    for i in range(1, N + 1):\n        max_for_ai = dp.calc_max(0, A[i-1])\n        dp.update(A[i-1], max_for_ai + 1)\n\n    max_lis_length = max(dp.data[N + 1:])\n    return max_lis_length\n\n# Example array A for testing purposes\nA = [3, 10, 2, 1, 20]\nprint(\"LIS length using DP:\", longest_increasing_subsequence(A))\nprint(\"LIS length using segment tree:\", longest_increasing_subsequence_with_segment_tree(A))\n```\n\n \n\n", "problem_ids": ["abc365_c", "agc068_b", "abc360_g"]}, "abc315_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\). You are also given \\(Q\\) queries to process in order. There are three types of queries:\n\n1. `1 l r x`: Add \\(x\\) to each of \\(A_l, A_{l+1}, \\ldots, A_r\\).\n2. `2 l r x`: Add \\(x\\) to each of \\(B_l, B_{l+1}, \\ldots, B_r\\).\n3. `3 l r`: Print the remainder of \\(\\sum_{i=l}^r (A_i \\times B_i)\\) when divided by 998244353.\n\n**Constraints:**\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(0 \\leq A_i, B_i \\leq 10^9\\)\n- \\(1 \\leq l \\leq r \\leq N\\)\n- \\(1 \\leq x \\leq 10^9\\)\n- All input values are integers.\n- There is at least one query of the third type.\n\n**Input:**\n\nThe input is given from Standard Input in the following format. Here, \\(\\text{query}_i (1 \\leq i \\leq Q)\\) is the \\(i\\)-th query to be processed.\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n\\text{query}_1\n\\text{query}_2\n\\vdots\n\\text{query}_Q\n```\n\nEach query is given in one of the following formats:\n\n```\n1 l r x\n```\n\n```\n2 l r x\n```\n\n```\n3 l r\n```\n\n**Output:**\n\nIf there are \\(K\\) queries of the third type, print \\(K\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq K)\\) should contain the output for the \\(i\\)-th query of the third type.\n\n**Sample Input 1:**\n\n```\n5 6\n1 3 5 6 8\n3 1 2 1 2\n3 1 3\n1 2 5 3\n3 1 3\n1 1 3 1\n2 5 5 2\n3 1 5\n```\n\n**Sample Output 1:**\n\n```\n16\n25\n84\n```\n\nInitially, \\(A = (1, 3, 5, 6, 8)\\) and \\(B = (3, 1, 2, 1, 2)\\). The queries are processed in the following order:\n\n1. For the first query, print \\((1 \\times 3) + (3 \\times 1) + (5 \\times 2) = 16\\) modulo 998244353, which is 16.\n2. For the second query, add 3 to \\(A_2, A_3, A_4, A_5\\). Now \\(A = (1, 6, 8, 9, 11)\\).\n3. For the third query, print \\((1 \\times 3) + (6 \\times 1) + (8 \\times 2) = 25\\) modulo 998244353, which is 25.\n4. For the fourth query, add 1 to \\(A_1, A_2, A_3\\). Now \\(A = (2, 7, 9, 9, 11)\\).\n5. For the fifth query, add 2 to \\(B_5\\). Now \\(B = (3, 1, 2, 1, 4)\\).\n6. For the sixth query, print \\((2 \\times 3) + (7 \\times 1) + (9 \\times 2) + (9 \\times 1) + (11 \\times 4) = 84\\) modulo 998244353, which is 84.\n\nThus, the first, second, and third lines should contain 16, 25, and 84, respectively.\n\n**Sample Input 2:**\n\n```\n2 3\n1000000000 1000000000\n1000000000 1000000000\n3 1 1\n1 2 2 1000000000\n3 1 2\n```\n\n**Sample Output 2:**\n\n```\n2716070898\n151723988\n```\n\nMake sure to print the sum modulo 998244353 for the third type of query.\n\nSolution:\n\n[BEGIN TEXT]\nConsider solving this problem using a lazy segment tree. For details on lazy segment trees, please refer to other editorials and the AtCoder Library explanation. Specifically, for each segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) for integers \\(a,k\\geq 0\\) and \\(2^k(a+1)\\leq N\\), we want to manage the sum of \\(A_i\\times B_i\\) within the segment, and apply addition to \\(A_i\\) and \\(B_i\\) fast enough (in \\(O(1)\\) time). The set of actions consists of \u201cadding \\(x\\) to each element of \\(A\\) and \\(y\\) to that of \\(B\\) (within the segment)\u201d for all integers \\(x\\) and \\(y\\). \n\nFor a segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) (where \\(L=a\\cdot2^k+1\\) and \\(R=(a+1)2^k\\)), it is insufficient to store the values \\(\\sum_{i=L}^R (A_i\\times B_i)\\) for each segment. Instead, manage the length \\((R-L+1)\\), and three kinds of sum: \\(\\sum_{i=L}^R A_i\\), \\(\\sum_{i=L}^R B_i\\), and \\(\\sum_{i=L}^R (A_i\\times B_i)\\), for each segment. Then, one can update the value \\(\\sum_{i=L}^R (A_i\\times B_i)\\) in \\(O(1)\\) time. \n\nThe key updates are:\n\\[\n\\sum_{i=L}^R ((A_i+x)\\times (B_i+y)) = \\sum_{i=L}^R (A_i\\times B_i) + y\\sum_{i=L}^R A_i + x\\sum_{i=L}^R B_i + (R-L+1)xy\n\\]\n\\[\n\\sum_{i=L}^R (A_i+x) = \\sum_{i=L}^R A_i+(R-L+1)x, \n\\]\n\\[\n\\sum_{i=L}^R (B_i+y) = \\sum_{i=L}^R B_i+(R-L+1)y\n\\]\n\nTherefore, the lazy segment tree can find the answer with a complexity of \\(O(Q\\log N)\\), which is efficient. The answer should be printed modulo \\(998244353\\).\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi and Aoki played rock-paper-scissors \\(N\\) times. [Note: In this game, Rock beats Scissors, Scissors beats Paper, and Paper beats Rock.]\n\nAoki's moves are represented by a string \\(S\\) of length \\(N\\) consisting of the characters \\(R\\), \\(P\\), and \\(S\\). The \\(i\\)-th character of \\(S\\) indicates Aoki's move in the \\(i\\)-th game: \\(R\\) for Rock, \\(P\\) for Paper, and \\(S\\) for Scissors.\n\nTakahashi's moves satisfy the following conditions:\n1. Takahashi never lost to Aoki.\n2. For \\(i = 1, 2, \\ldots, N-1\\), Takahashi's move in the \\(i\\)-th game is different from his move in the \\((i+1)\\)-th game.\n\nDetermine the maximum number of games Takahashi could have won.\n\nIt is guaranteed that there exists a sequence of moves for Takahashi that satisfies these conditions.\n\n**Constraints**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(S\\) is a string of length \\(N\\) consisting of \\(R\\), \\(P\\), and \\(S\\).\n- \\(N\\) is an integer.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN\nS\n```\n\n**Output**\nPrint the maximum number of games Takahashi could have won.\n\n**Sample Input 1**\n```\n6\nPRSSRS\n```\n\n**Sample Output 1**\n```\n5\n```\n\n*Explanation:* In the six games of rock-paper-scissors, Aoki played Paper, Rock, Scissors, Scissors, Rock, and Scissors. Takahashi can play Scissors, Paper, Rock, Scissors, Paper, and Rock to win the 1st, 2nd, 3rd, 5th, and 6th games. There is no sequence of moves for Takahashi that satisfies the conditions and wins all six games, so print 5.\n\n**Sample Input 2**\n```\n10\nSSSSSSSSSS\n```\n\n**Sample Output 2**\n```\n5\n```\n\n**Sample Input 3**\n```\n24\nSPRPSRRRRRPPRPRPSSRSPRSS\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Here is the trimmed content containing only the solution to the coding problem:\n\n---\n\nDefine \\(\\operatorname{dp} _ i[H]\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) by:\n\n\\(\\operatorname{dp} _ i[H]\\coloneqq\\) the maximum number of Takahashi\u2019s wins during conforming first \\(i\\) hands of Takahashi such that his \\(i\\)-th hand is \\(H\\).\n\nHere, we define \\(\\operatorname{dp} _ 0[H]=0\\) for convenience. (DP stands for Dynamic Programming.)\n\nTakahashi\u2019s \\(i\\)-th move is solely dependent on Aoki\u2019s \\(i\\)-th hand and Takahashi\u2019s \\(i\\)-th hand. Therefore, \\(\\operatorname{dp} _ i[H]\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) can be found based on \\(\\operatorname{dp} _ {i-1}\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) (and the value \\(S _ i\\)). Specifically, let \\(\\operatorname{rps}(a,b)\\) be \\(1\\) if \\(a\\) wins \\(b\\), \\(-1\\) if it loses, and \\(0\\) if they are draw (here rps stands for rock-scissors-paper), then\n\n\\[\\operatorname{dp} _ i[H]=\\begin{cases}\\displaystyle\\max _ {H^\\prime\\neq H}\\operatorname{dp} _ {i-1}[H^\\prime]&\\ &(\\operatorname{janken}(H,S _ i)=0)\\\\1+\\displaystyle\\max _ {H^\\prime\\neq H}\\operatorname{dp} _ {i-1}[H^\\prime]&&(\\operatorname{janken}(H,S _ i)=1)\\\\0&&(\\operatorname{janken}(H,S _ i)=-1).\\end{cases}\\]\n\nWhile we may set \\(-\\infty\\) to the value of the DP table when losing, one can prove that setting \\(0\\) still yields a correct value.\n\nThe following is sample code.\n\n```python\ndef main():\n    N = int(input().strip())\n    S = input().strip()\n\n    dp = [0, 0, 0]\n    rock, scissors, paper = dp\n\n    for c in S:\n        dp = [max(scissors, paper), max(rock, paper), max(rock, scissors)]\n\n        if c == 'R':\n            scissors = 0\n            paper += 1\n        elif c == 'S':\n            paper = 0\n            rock += 1\n        elif c == 'P':\n            rock = 0\n            scissors += 1\n\n    print(max(dp))\n\nmain()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere are \\( N \\) types of items. The \\( i \\)-th type of item has a weight of \\( w_i \\) and a value of \\( v_i \\). Each type has \\( 10^{10} \\) items available.\n\nTakahashi is going to choose some items and put them into a bag with capacity \\( W \\). He wants to maximize the value of the selected items while avoiding choosing too many items of the same type. Hence, he defines the **happiness** of choosing \\( k_i \\) items of type \\( i \\) as \\( k_i v_i - k_i^2 \\). He wants to choose items to maximize the total happiness over all types while keeping the total weight at most \\( W \\). Calculate the maximum total happiness he can achieve.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 3000 \\)\n- \\( 1 \\leq W \\leq 3000 \\)\n- \\( 1 \\leq w_i \\leq W \\)\n- \\( 1 \\leq v_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN W\nw_1 v_1\nw_2 v_2\n\\vdots\nw_N v_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n2 10\n3 4\n3 2\n```\n\n**Sample Output 1:**\n```\n5\n```\n\nBy choosing 2 items of type 1 and 1 item of type 2, the total happiness can be 5, which is optimal. Here, the happiness for type 1 is \\( 2 \\times 4 - 2^2 = 4 \\), and the happiness for type 2 is \\( 1 \\times 2 - 1^2 = 1 \\). The total weight is 9, which is within the capacity 10.\n\n**Sample Input 2:**\n```\n3 6\n1 4\n2 3\n2 7\n```\n\n**Sample Output 2:**\n```\n14\n```\n\n**Sample Input 3:**\n```\n1 10\n1 7\n```\n\n**Sample Output 3:**\n```\n12\n```\n\nSolution:\n\n```python\n# Here is a streamlined version focusing on the core solution:\n\ndef dp_happiness(N, W, items):\n    # Initialize dp table\n    dp = [[0] * (W + 1) for _ in range(max_weight + 1)]\n    \n    for w in range(1, max_weight + 1):\n        values = [v for v_i, w_i in items if w_i == w]\n        m = len(values)\n        \n        def f_w(k):\n            happiness = 0\n            # Priority queue to maximize happiness delta\n            deltas = [v - 1 for v in values]\n            deltas.sort(reverse=True)\n            for i in range(k):\n                if deltas:\n                    happiness += deltas[0]\n                    deltas[0] -= 2\n                    deltas.sort(reverse=True)\n            return happiness\n        \n        for j in range(W + 1):\n            dp[w][j] = dp[w-1][j]\n            for k in range(0, j // w + 1):\n                dp[w][j] = max(dp[w][j], dp[w-1][j - k * w] + f_w(k))\n    \n    return dp[max_weight][W]\n\n# Example usage:\n# N: number of items\n# W: maximum weight\n# Items: list of tuples, each tuple is (value, weight)\nN = 5\nW = 10\nitems = [(3, 2), (2, 2), (4, 3), (5, 5)]\nmax_weight = max(item[1] for item in items)\n\nmax_happiness = dp_happiness(N, W, items)\nprint(f\"Maximum total happiness: {max_happiness}\")\n```\n\nThis Python code implements the Dynamic Programming approach described in the editorial, fully translated from the explanation provided. The function `dp_happiness` takes the number of items, maximum weight, and a list of items (each defined by a tuple of value and weight) and computes the maximum total happiness.\n \n\n", "problem_ids": ["abc357_f", "abc365_d", "abc373_f"]}, "abc315_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n---\n**Problem Statement**\n\nYou are given a directed graph with \\( N \\) vertices and \\( M \\) edges. The \\( j \\)-th directed edge goes from vertex \\( u_j \\) to vertex \\( v_j \\) and has a weight of \\( w_j \\).\n\nFind one way to assign an integer between \\(-10^{18}\\) and \\(10^{18}\\), inclusive, to each vertex such that the following condition is satisfied:\n\n- Let \\( x_i \\) be the value assigned to vertex \\( i \\). For all edges \\( j = 1, 2, \\dots, M \\), it holds that \\( x_{v_j} - x_{u_j} = w_j \\).\n\nIt is guaranteed that at least one such assignment exists for the given input.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq \\min\\{2 \\times 10^5, \\frac{N(N-1)}{2}\\} \\)\n- \\( 1 \\leq u_j, v_j \\leq N \\)\n- \\( u_j \\neq v_j \\)\n- If \\( i \\neq j \\), then \\( (u_i, v_i) \\neq (u_j, v_j) \\) and \\( (u_i, v_i) \\neq (v_j, u_j) \\)\n- \\( |w_j| \\leq 10^9 \\)\n- All input values are integers.\n- There exists at least one assignment satisfying the conditions.\n\n**Input**\n\nThe input is given in the following format:\n\n```\nN M\nu_1 v_1 w_1\nu_2 v_2 w_2\n\u22ee\nu_M v_M w_M\n```\n\n**Output**\n\nLet \\( x_i \\) be the integer written on vertex \\( i \\). Print \\( x_1, x_2, \\dots, x_N \\) in this order, separated by spaces, on a single line. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n\n```\n3 3\n1 2 2\n3 2 3\n1 3 -1\n```\n\n**Sample Output 1**\n\n```\n3 5 2\n```\n\nBy setting \\( x = (3, 5, 2) \\), we have \\( x_2 - x_1 = w_1 = 2 \\), \\( x_2 - x_3 = w_2 = 3 \\), \\( x_3 - x_1 = w_3 = -1 \\), satisfying the conditions. For example, \\( x = (-1, 1, -2) \\) is also a valid answer.\n\n**Sample Input 2**\n\n```\n4 2\n2 1 5\n3 4 -3\n```\n\n**Sample Output 2**\n\n```\n5 0 6 3\n```\n\nFor example, \\( x = (0, -5, 4, 1) \\) and \\( x = (5, 0, 4, 1) \\) are also valid answers.\n\n**Sample Input 3**\n\n```\n5 7\n2 1 18169343\n3 1 307110901\n4 1 130955934\n2 3 -288941558\n2 5 96267410\n5 3 -385208968\n4 3 -176154967\n```\n\n**Sample Output 3**\n\n```\n200401298 182231955 -106709603 69445364 278499365\n```\n\nSolution:\n\n```python\n        For each connected component of the graph, once the value to be written on any vertex in it is fixed, all the values to be written are uniquely determined. This is because, once you determine the value for a vertex, the value for adjacent vertices is also determined in a chain. Thus, the problem can be solved by inspecting vertices one by one, and if the current vertex does not have a value assigned, set an arbitrary value (like 0) to it and determine the values for all the other connected vertices. This kind of process can be implemented as a Depth-First Search (DFS) or Breadth-First Search (BFS). The time complexity is \\(O(N+M)\\).\n\n```python\n# Read the input\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, w))\n    G[v].append((u, -w))\n\nvisited = [False] * N  # Whether the values are determined\nans = [0] * N  # The values to write\nfor i in range(N):\n    # Skip if the value is already determined\n    if visited[i]:\n        continue\n    # Set the value for vertex i to 0, and start searching\n    st = [i]\n    visited[i] = True\n    while st:\n        # Currently at vertex u\n        u = st.pop()\n        # Inspect vertex v adjacent to vertex u\n        for v, w in G[u]:\n            if not visited[v]:\n                # If the value for vertex v is undetermined, determine the value so that it is consistent with that for vertex u\n                visited[v] = True\n                ans[v] = ans[u] + w\n                st.append(v)\nprint(*ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 550 points\n\n## Problem Statement\n\nYou are given a weighted undirected connected graph \\( G \\) with \\( N \\) vertices and \\( N-1 \\) edges, where vertices are numbered from \\( 1 \\) to \\( N \\) and edges are numbered from \\( 1 \\) to \\( N-1 \\). Edge \\( i \\) connects vertices \\( a_i \\) and \\( b_i \\) with a weight of \\( c_i \\).\n\nYou are given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- You are given integers \\( u_i, v_i, w_i \\). Add an edge with weight \\( w_i \\) between vertices \\( u_i \\) and \\( v_i \\) in \\( G \\). Then, print the sum of the weights of the edges in a minimum spanning tree of \\( G \\).\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i < b_i \\leq N \\)\n- \\( 1 \\leq u_i < v_i \\leq N \\)\n- \\( 1 \\leq c_i, w_i \\leq 10 \\)\n- The graph is connected before processing the queries.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\na_1 b_1 c_1\n.\n.\n.\na_{N-1} b_{N-1} c_{N-1}\nu_1 v_1 w_1\n.\n.\n.\nu_Q v_Q w_Q\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n## Sample Input 1\n\n```\n4 4\n1 2 6\n2 3 5\n2 4 4\n1 3 3\n1 2 3\n1 4 10\n3 4 1\n```\n\n## Sample Output 1\n\n```\n12\n10\n10\n7\n```\n\nHere is the graph after adding the edge for each query. The edges included in the minimum spanning tree are colored red.\n\n## Sample Input 2\n\n```\n8 6\n1 8 8\n1 6 10\n1 5 8\n2 6 6\n6 7 6\n1 3 9\n2 4 7\n1 3 4\n1 6 7\n3 4 6\n1 5 1\n7 8 4\n3 5 3\n```\n\n## Sample Output 2\n\n```\n49\n46\n45\n38\n34\n33\n```\n\nSolution:\n\n```\nHere is the trimmed editorial:\n\n---\n\n**F - MST Query Editorial**\n\nLet \\(W=10\\) be the maximum edge weight. Let \\(G_k (0\\leq k\\leq W)\\) be the (unweighted) subgraph of \\(G\\) consisting of the edges of \\(G\\) with weights not more than \\(k\\). Let \\(H\\) be the number of connected components of a graph \\(H\\), then the sum of weights of edges in an MST of graph \\(G\\) equals \\(\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Proof) Approach 1:** Among the edges in an MST of \\(G\\), there are \\(N-c(G_k)\\) edges whose weight is not greater than \\(k\\). Therefore, there are \\(\\left(N-c(G_k)\\right)-\\left(N-c(G_{k-1})\\right)=c(G_{k-1})-c(G_k)\\) edges whose weight is exactly \\(k\\), so the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle \\sum_{k=1}^{W}k\\left(c(G_{k-1})-c(G_k)\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)\\right)-W\\cdot c(G_W)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Approach 2):** Among the edges in an MST of \\(G\\), there are \\(c(G_{k-1})-1\\) edges whose weight is not greater than \\(c(G_{k-1})-1\\). Thus, the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle\\sum_{k=1}^{W}\\left(c(G_{k-1})-1\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left(c(G_k)-1\\right)\\).\n\nFor each \\(k(0\\leq k\\lt W)\\), one can manage the number of connected components of \\(G_k\\) with a disjoint set union (DSU) to solve this problem in a total of \\(O(W(N+Q)\\alpha(N))\\). The complexity can be reduced to \\(O((WN+Q)\\alpha(N))\\).\n\n**Sample Code:**\n\n```python\nfrom atcoder.dsu import DSU\n\nN, Q = map(int, input().split())\nuf = [DSU(N + 1) for i in range(10)]\nans = 10 * N - 10\nfor i in range(N - 1 + Q):\n    a, b, c = map(int, input().split())\n    for j in range(c, 10):\n        if not uf[j].same(a, b):\n            ans -= 1\n            uf[j].merge(a, b)\n    if i >= N - 1:\n        print(ans)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two strings, \\( S \\) and \\( T \\), consisting of lowercase English letters. Determine if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the following condition is satisfied. Here, \\( |S| \\) denotes the length of the string \\( S \\). Note that \\( w \\) must be less than \\( |S| \\).\n\n- If \\( S \\) is split at every \\( w \\) characters from the beginning, the concatenation of the \\( c \\)-th characters of the substrings of length at least \\( c \\) in order equals \\( T \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters.\n- \\( 1 \\leq |T| \\leq |S| \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nPrint `Yes` if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the condition is satisfied, and `No` otherwise.\n\n**Sample Input 1**\n```\natcoder toe\n```\n\n**Sample Output 1**\n```\nYes\n```\n\nExplanation: If \\( S \\) is split at every two characters, it looks like this:\n```\nat\nco\nde\nr\n```\nThen, the concatenation of the 2nd characters of the substrings of length at least 2 is `toe`, which equals \\( T \\). Thus, print `Yes`.\n\n**Sample Input 2**\n```\nbeginner r\n```\n\n**Sample Output 2**\n```\nNo\n```\n\nExplanation: \\( w = |S| \\) is not allowed, and no pair of integers \\( 1 \\leq c \\leq w < |S| \\) satisfies the condition. Thus, print `No`.\n\n**Sample Input 3**\n```\nverticalreading agh\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        Below is a clean version of the text with only the relevant solution details:\n\nEnumerate all possible \\(c\\) and \\(w\\), and determine if a conforming pair \\(c,w\\) exists. One can construct a string for \\(c\\) and \\(w\\) using a for statement and concatenation of strings. For more details, please refer to the sample code.\n\nSample code (Python 3):\n\n```python\ndef main():\n    s = input().strip()\n    t = input().strip()\n    for w in range(1, len(s)):\n        for c in range(w):\n            now = \"\"\n            for i in range(c, len(s), w):\n                now += s[i]\n            if now == t:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc373_d", "abc355_f", "abc360_b"]}, "abc315_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nA real number \\( X \\) is given to the third decimal place. Print the real number \\( X \\) under the following conditions:\n\n- The decimal part must not have trailing zeros.\n- There must not be an unnecessary trailing decimal point.\n\n**Constraints**\n\n- \\( 0 \\le X < 100 \\)\n- \\( X \\) is given to the third decimal place.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nX\n```\n\n**Output**\n\nOutput the answer.\n\n**Sample Input 1**\n```\n1.012\n```\n\n**Sample Output 1**\n```\n1.012\n```\n\nExplanation: `1.012` can be printed as it is.\n\n**Sample Input 2**\n```\n12.340\n```\n\n**Sample Output 2**\n```\n12.34\n```\n\nExplanation: Printing `12.340` without the trailing zero results in `12.34`.\n\n**Sample Input 3**\n```\n99.900\n```\n\n**Sample Output 3**\n```\n99.9\n```\n\nExplanation: Printing `99.900` without the trailing zeros results in `99.9`.\n\n**Sample Input 4**\n```\n0.000\n```\n\n**Sample Output 4**\n```\n0\n```\n\nExplanation: Printing `0.000` without trailing zeros or an unnecessary decimal point results in `0`.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 367\n\nB - Cut .0 Editorial\n\nSolution 1: In C++, receive \\(X\\) as a double and print it. This avoids trailing zeros without specifying a format. Other languages might share this feature.\n\nSample code (Python3):\n```python\nx = float(input())\nprint(x)\n```\n\nSolution 2: Treat as a string problem. Receive \\(X\\) as a string, remove trailing zeros, and then remove a trailing '.' if present. The input ensures a decimal point, so trailing zeros are in the decimal part.\n\nSample code (Python3):\n```python\nx = input()\nwhile x[-1] == '0':\n    x = x[:-1]\nif x[-1] == '.':\n    x = x[:-1]\nprint(x)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given two permutations \\( P = (P_1, P_2, \\dots, P_N) \\) and \\( Q = (Q_1, Q_2, \\dots, Q_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nWrite one of the characters '0' and '1' in each cell of an \\( N \\)-by-\\( N \\) grid so that all of the following conditions are satisfied:\n\n1. Let \\( S_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th row from the 1st to the \\( N \\)-th column. Then, \\( S_{P_1} < S_{P_2} < \\dots < S_{P_N} \\) in lexicographical order.\n\n2. Let \\( T_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th column from the 1st to the \\( N \\)-th row. Then, \\( T_{Q_1} < T_{Q_2} < \\dots < T_{Q_N} \\) in lexicographical order.\n\nIt can be proved that for any \\( P \\) and \\( Q \\), there is at least one way to write the characters that satisfies all the conditions.\n\n**Lexicographical Order Explanation:**\n\nFor strings \\( X = X_1 X_2 \\dots X_{|X|} \\) and \\( Y = Y_1 Y_2 \\dots Y_{|Y|} \\), \" \\( X < Y \\) in lexicographical order\" means that condition 1 or 2 below holds:\n\n1. \\( |X| < |Y| \\) and \\( X_1 X_2 \\ldots X_{|X|} = Y_1 Y_2 \\ldots Y_{|X|} \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\lbrace |X|, |Y| \\rbrace \\) such that both of the following are true:\n   - \\( X_1 X_2 \\ldots X_{i-1} = Y_1 Y_2 \\ldots Y_{i-1} \\)\n   - \\( X_i \\) is less than \\( Y_i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( P \\) and \\( Q \\) are permutations of \\( (1, 2, \\dots, N) \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n\n```\nN\nP_1 P_2 \\dots P_N\nQ_1 Q_2 \\dots Q_N\n```\n\n**Output:**\n\nPrint a way to fill the grid that satisfies the conditions in the following format, where \\( A_{ij} \\) is the character written at the \\( i \\)-th row and \\( j \\)-th column:\n\n```\nA_{11} A_{12} \\dots A_{1N}\n...\nA_{N1} A_{N2} \\dots A_{NN}\n```\n\nIf there are multiple ways to satisfy the conditions, any of them will be accepted.\n\n**Sample Input 1:**\n\n```\n3\n1 2 3\n2 1 3\n```\n\n**Sample Output 1:**\n\n```\n001\n101\n110\n```\n\nIn this sample, \\( S_1 = \\) \"001\", \\( S_2 = \\) \"101\", \\( S_3 = \\) \"110\", and \\( T_1 = \\) \"011\", \\( T_2 = \\) \"001\", \\( T_3 = \\) \"110\". Therefore, \\( S_1 < S_2 < S_3 \\) and \\( T_2 < T_1 < T_3 \\) hold, satisfying the conditions.\n\n**Sample Input 2:**\n\n```\n15\n8 15 10 2 4 3 1 13 5 12 9 6 14 11 7\n4 1 5 14 3 12 13 7 11 8 6 2 9 15 10\n```\n\n**Sample Output 2:**\n\n```\n010001111110101\n001000000101001\n010001001100010\n010000011110010\n010011101101101\n100101110100000\n111100011001000\n000001001100000\n100011011000101\n000111101011110\n101010101010101\n011010101011110\n010011000010011\n100110010110101\n000101101100100\n```\n\nSolution:\n\n```python\ndef fill_grid(N, P, Q):\n    grid = [[None] * N for _ in range(N)]\n\n    # Step 1: Write 0 in all cells of row P_1\n    for j in range(N):\n        grid[P[0]][j] = 0\n\n    # Step 2: Write 1 in all cells of column Q_N that are still empty\n    for i in range(N):\n        if grid[i][Q[N-1]] is None:\n            grid[i][Q[N-1]] = 1\n\n    # Recursive filling for remaining (N-1) x (N-1) cells\n    def fill_recursive(start, end, P, Q):\n        if start >= end:\n            return\n        # Write in row P[start]\n        for j in range(N):\n            if grid[P[start]][j] is None:\n                grid[P[start]][j] = 0\n        # Write in column Q[end]\n        for i in range(N):\n            if grid[i][Q[end]] is None:\n                grid[i][Q[end]] = 1\n        # Recurse on remaining subproblem\n        fill_recursive(start + 1, end - 1, P, Q)\n\n    fill_recursive(1, N-1, P, Q)\n\n    return grid\n\n# Example usage\nN = 3\nP = [0, 1, 2]  # Row order\nQ = [2, 1, 0]  # Column order\ngrid = fill_grid(N, P, Q)\nfor row in grid:\n    print(row)\n```\n\n**C - Row and Column Order Editorial by evima**\n\n**Solution**\n\n1. Write 0 in all cells of row \\(P_1\\).\n2. Write 1 in all cells of column \\(Q_N\\) that are still empty.\n3. For the remaining \\((N-1) \\times (N-1)\\) cells, let \\(S'_i\\) be the string obtained by concatenating row \\(i\\) excluding column \\(Q_N\\), and \\(T'_j\\) be the string obtained by concatenating column \\(j\\) excluding row \\(P_1\\). Then, recursively write in the same way so that \\(S'_{P_2} < S'_{P_3} < \\dots < S'_{P_N}\\) and \\(T'_{Q_2} < T'_{Q_3} < \\dots < T'_{Q_N}\\) hold.\n\nThe grid filled by this algorithm will satisfy the problem's conditions. Additionally, each column will contain at least one cell with 0, as 0 is always written in row \\(P_1\\). The lexicographical order of \\(S_{P_i}\\) and \\(T_{Q_i}\\) is maintained through recursive writing. The order of writing is \\(i=1,2,\\dots,N\\): first, write 0 in row \\(P_i\\) cells not yet written, then write 1 in column \\(Q_{N+1-i}\\) cells still empty.\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Country of AtCoder consists of \\( N \\) cities and \\( M \\) roads connecting them. One can travel between any two cities by traversing some roads. The cities are numbered from 1 to \\( N \\), and the roads are numbered from 1 to \\( M \\). Road \\( i \\) connects cities \\( A_i \\) and \\( B_i \\) bidirectionally.\n\nDue to increasing traffic in the country, there is a plan to expand some roads. Currently, no roads have been expanded, and the cost to expand road \\( i \\) is \\( C_i \\).\n\nSince it is difficult to expand all roads at once, the plan is to first designate \\( K \\) out of the \\( N \\) cities as **major cities** and perform the minimum necessary expansion work, so that one can travel between any two major cities using only expanded roads. It has already been decided that cities \\( 1, 2, \\ldots, K-1 \\) will be major cities, but the last major city has not yet been decided.\n\nFor each \\( i = K, K+1, \\ldots, N \\), answer the following question: If city \\( i \\) is designated as the last major city, what is the minimum total cost of the expansion work required to ensure that one can travel between any two major cities using only expanded roads?\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 4000 \\)\n- \\( N-1 \\leq M \\leq 8000 \\)\n- \\( 2 \\leq K \\leq \\min(N, 10) \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- One can travel between any two cities by traversing some roads.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n**Output**\n\nPrint \\( N-K+1 \\) lines. The \\( l \\)-th line \\( (1 \\leq l \\leq N-K+1) \\) should contain the answer to the question for \\( i = l+K-1 \\), as an integer.\n\n**Sample Input 1**\n```\n4 5 3\n1 4 3\n3 4 4\n1 2 4\n2 3 2\n1 3 1\n```\n\n**Sample Output 1**\n```\n3\n6\n```\n\nIn the above figure, circles with numbers represent cities with those numbers, and lines with numbers represent roads with the cost of expansion being that number. The left and right figures correspond to the cases \\( i=3 \\) and \\( i=4 \\), respectively. The colored circles represent the major cities, and the colored thick lines represent the roads that are expanded in an optimal solution. For \\( i=3 \\), expanding roads 4 and 5 results in a total cost of \\( 2+1=3 \\), which is the minimum. For \\( i=4 \\), expanding roads 1, 4, and 5 results in a total cost of \\( 3+2+1=6 \\), which is the minimum.\n\n**Sample Input 2**\n```\n4 3 2\n2 4 28\n1 4 56\n1 3 82\n```\n\n**Sample Output 2**\n```\n84\n82\n56\n```\n\n**Sample Input 3**\n```\n6 12 4\n2 6 68\n2 5 93\n4 6 28\n2 4 89\n3 6 31\n1 3 10\n1 2 53\n3 5 1\n3 5 74\n3 4 22\n4 5 80\n3 4 35\n```\n\n**Sample Output 3**\n```\n85\n64\n94\n```\n\nThere may be multiple roads connecting the same pair of cities.\n\nSolution:\n\nHere is the editorial with the C++ code translated to Python3:\n\n```\nJapan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nOfficial\n\nG - Last Major City Editorial\n\nThis problem is an extension of the minimum Steiner tree problem. We referred to an editorial slide by Yoichi Iwata. A city, road, and cost are simply a vertex, edge, and weight. In an optimal solution, the graph defined by the set of edges to be extended as well as their adjacent vertices forms a tree. For a subset of the vertex set \\(\\{1,2,\\dots,K-1\\}\\) and vertex \\(v\\), \\(f(S,v)\\) is the minimum total weight of the edges of a tree containing vertex \\(v\\) and all vertices in \\(S\\). We seek \\(f(\\{1,2,\\dots,K-1\\}, v)\\) for each \\(K\\leq v\\leq N\\).\n\nThe function \\(f(S,v)\\) can be calculated with Dynamic Programming (DP), using initial values \\(f(\\{i\\}, i)=0\\ (1 \\leq i \\leq K-1)\\). There are two transitions: \n\n1. \\(f(S,v) \\leftarrow \\min(f(S,v),f(S,u) + w)\\) if an edge of weight \\(w\\) connects vertices \\(u\\) and \\(v\\).\n2. \\(f(S,v) \\leftarrow \\min(f(S,v),f(T,v)+f(S\\setminus T,v))\\ (T\\subsetneq S, T\\neq \\emptyset)\\).\n\nThe transitions ensure efficient processing by filling the DP table in ascending order of the size of \\(S\\). The circular dependency in the former transition is managed by determining \\(f(S,v)\\) in ascending order of its value using Dijkstra\u2019s algorithm. The overall complexity is \\(O(3^KN+2^KM\\log M)\\).\n\nSample code (Python3):\n\n```python\nimport sys\nimport heapq\n\ndef chmin(a, b):\n    return b < a\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2]) - 1\n    \n    G = [[] for _ in range(n)]\n\n    index = 3\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        index += 3\n        G[a].append((b, c))\n        G[b].append((a, c))\n\n    dp = [[float('inf')] * n for _ in range(1 << k)]\n    for i in range(k):\n        dp[1 << i][i] = 0\n\n    for bit in range(1, 1 << k):\n        sub = bit\n        while sub > 0:\n            for i in range(n):\n                dp[bit][i] = min(dp[bit][i], dp[sub][i] + dp[bit - sub][i])\n            sub = (sub - 1) & bit\n\n        pq = [(dp[bit][i], i) for i in range(n)]\n        heapq.heapify(pq)\n\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dp[bit][u]:\n                continue\n            for v, l in G[u]:\n                if chmin(dp[bit][v], d + l):\n                    dp[bit][v] = d + l\n                    heapq.heappush(pq, (d + l, v))\n\n    for i in range(k, n):\n        print(dp[-1][i])\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc367_b", "arc181_c", "abc364_g"]}, "abc315_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThe problem statement is as follows:\n\n**Problem Statement:**\n\nThere is a rooted tree with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). The root is vertex \\( 1 \\), and the parent of vertex \\( i \\) (\\( 2 \\leq i \\leq N \\)) is vertex \\( P_i \\) (\\( P_i < i \\)).\n\nThere are also integer sequences of length \\( M \\): \\( A = (A_1, A_2, \\cdots, A_M) \\) and \\( B = (B_1, B_2, \\cdots, B_M) \\), consisting of integers between \\( 1 \\) and \\( N \\), inclusive.\n\nSequence \\( A \\) is said to be **good** if and only if for each \\( i \\), vertex \\( A_i \\) is an ancestor of vertex \\( B_i \\) or \\( A_i = B_i \\). Initially, \\( A \\) is good.\n\nConsider the following operation on \\( A \\):\n\n- Choose an integer \\( i \\) (\\( 1 \\leq i \\leq M-1 \\)) and swap the values of \\( A_i \\) and \\( A_{i+1} \\). Here, \\( A \\) must remain good after the operation.\n\nFind the number, modulo \\( 998244353 \\), of sequences that can result from performing this operation on \\( A \\) zero or more times.\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 250000 \\)\n- \\( 2 \\leq M \\leq 250000 \\)\n- \\( 1 \\leq P_i < i \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq N \\)\n- Vertex \\( A_i \\) is an ancestor of vertex \\( B_i \\) or \\( A_i = B_i \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nP_2 P_3 \\cdots P_N\nA_1 A_2 \\cdots A_M\nB_1 B_2 \\cdots B_M\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n```\n3 3\n1 2\n1 2 1\n1 2 3\n```\n\n**Sample Output 1:**\n```\n2\n```\n\nConsider choosing \\( i = 1 \\). The \\( A = (2, 1, 1) \\) after the operation is not good, so this operation is invalid. Consider choosing \\( i = 2 \\). The \\( A = (1, 1, 2) \\) after the operation is good, so this operation is valid. There are two sequences that can result from performing zero or more operations on \\( A \\): \\( A = (1, 2, 1) \\) and \\( (1, 1, 2) \\).\n\n**Sample Input 2:**\n```\n4 3\n1 1 1\n2 3 4\n2 3 4\n```\n\n**Sample Output 2:**\n```\n1\n```\n\n**Sample Input 3:**\n```\n8 13\n1 2 2 3 4 4 3\n5 3 2 5 4 6 2 8 2 6 7 4 7\n5 5 8 5 6 6 5 8 3 6 7 4 7\n```\n\n**Sample Output 3:**\n```\n8\n```\n\n**Sample Input 4:**\n```\n30 27\n1 2 1 1 5 1 7 1 5 10 1 12 12 13 15 16 12 18 19 18 21 21 23 13 18 18 27 27 13\n1 18 1 5 11 12 1 1 1 12 1 12 1 15 1 1 21 1 12 10 2 8 3 1 1 30 12\n14 27 30 5 11 17 1 18 24 27 29 27 19 15 28 5 21 21 29 11 2 8 3 4 10 30 22\n```\n\n**Sample Output 4:**\n```\n60\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere is the cleaned-up version focusing solely on the solution:\n\nFor each \\(i\\), consider the maximal interval \\([L_i, R_i]\\) that satisfies the conditions: \\(L_i \\leq i \\leq R_i\\), and for each \\(j \\in [L_i, R_i]\\), vertex \\(A_i\\) is an ancestor of vertex \\(B_j\\) (or \\(A_i = B_j\\)). The interval \\([L_i, R_i]\\) represents the range within which \\(A_i\\) can seemingly move. However, some positions within this range may be fixed, meaning \\(A_i\\) actually cannot move there. The set of intervals \\([L_i, R_i]\\) is laminar, forming a tree-like structure without partial overlaps.\n\nWe process in descending order of \\(A_i\\), which equates to ascending order of \\([L_i, R_i]\\) size. Within \\([L_i, R_i]\\), we calculate where \\(A_i\\) can actually move by excluding fixed positions. Suppose there are \\(k\\) intervals in the subtree of \\([L_i, R_i]\\): if \\(R_i - L_i + 1 = k\\), these intervals fill \\([L_i, R_i]\\), fixing those positions. Hence, \\(A_i\\) can move within \\([l, r]\\), excluding fixed positions.\n\nThe actual available positions depend on those not occupied by previously processed values. The count of such positions determines the candidates for placing the current \\(A_i\\). This must be done for all \\(A_i\\), considering duplicate values by dividing by an appropriate factor. \\(L_i\\) and \\(R_i\\) can be found using binary search and interval LCA queries on \\(B\\), processed in \\(O(\\log M + \\log N)\\) time. This leads to a time complexity of \\(O(N + M\\log M(\\log M + \\log N))\\), which can be optimized by handling interval min query and LCA query in \\(O(1)\\) time.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi is health-conscious and concerned about whether he is getting enough of \\( M \\) types of nutrients from his diet. For the \\( i \\)-th nutrient, his goal is to take at least \\( A_i \\) units per day. Today, he ate \\( N \\) foods, and from the \\( i \\)-th food, he took \\( X_{i,j} \\) units of nutrient \\( j \\). Determine whether he has met the goal for all \\( M \\) types of nutrients.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 0 \\leq A_i, X_{i,j} \\leq 10^7 \\)\n- All input values are integers.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_M\nX_{1,1} X_{1,2} \\ldots X_{1,M}\n\\vdots\nX_{N,1} X_{N,2} \\ldots X_{N,M}\n```\n\n**Output**\nPrint `Yes` if the goal is met for all \\( M \\) types of nutrients, and `No` otherwise.\n\n**Sample Input 1**\n```\n2 3\n10 20 30\n20 0 10\n0 100 100\n```\n\n**Sample Output 1**\n```\nYes\n```\nFor nutrient 1, Takahashi took 20 units from the 1st food and 0 units from the 2nd food, totaling 20 units, thus meeting the goal of taking at least 10 units. Similarly, he meets the goal for nutrients 2 and 3.\n\n**Sample Input 2**\n```\n2 4\n10 20 30 40\n20 0 10 30\n0 100 100 0\n```\n\n**Sample Output 2**\n```\nNo\n```\nThe goal is not met for nutrient 4.\n\nSolution:\n\n        Here is a clean version of the editorial:\n\n---\n\nThis problem can be solved by appropriate operations on two-dimensional arrays. Find the total amount of each nutrition and check if all of them exceed the goal. Beware of indices handling.\n\n**Sample code (Python):**\n\n```python\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nX = [list(map(int, input().split())) for _ in range(N)]\n\nfor j in range(M):\n    s = 0\n    for i in range(N):\n        s += X[i][j]\n    if s < A[j]:\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")\n```\n\n---\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n Problem Statement:  \nYou are given integers \\( N \\) and \\( Q \\), and two integer sequences of length \\( Q \\): \\( A = (A_1, A_2, \\ldots, A_Q) \\) and \\( B = (B_1, B_2, \\ldots, B_Q) \\). For each \\( k = 1, 2, \\ldots, Q \\), solve the following problem:  \n\nThere is an undirected graph with \\( N \\) vertices numbered from \\( 0 \\) to \\( N-1 \\) and \\( N \\) edges. The \\( i \\)-th edge \\( (0 \\leq i < N) \\) connects vertices \\( i \\) and \\( (A_k \\times i + B_k) \\mod N \\) bidirectionally. Find the number of connected components in this undirected graph.  \n\nConstraints:  \n- \\( 1 \\leq N \\leq 10^6 \\)  \n- \\( 1 \\leq Q \\leq 10^5 \\)  \n- \\( 0 \\leq A_k < N \\)  \n- \\( 0 \\leq B_k < N \\)  \n- All input values are integers.  \n\nInput:  \nThe input is given from Standard Input in the following format:  \n```\nN Q  \nA_1 B_1  \nA_2 B_2  \n\\vdots  \nA_Q B_Q  \n```  \n\nOutput:  \nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer for \\( k = i \\).  \n\nSample Input 1:  \n```\n6 3  \n2 1  \n0 1  \n1 0  \n```  \n\nSample Output 1:  \n```\n2  \n1  \n6  \n```  \n\nExplanation for \\( k = 1 \\):  \nThe graph has the following two connected components:  \n- A connected component with vertices \\( 0, 1, 3, 4 \\).  \n- A connected component with vertices \\( 2, 5 \\).  \n\nThus, the answer for \\( k = 1 \\) is \\( 2 \\).  \n\nSample Input 2:  \n```\n11 3  \n9 1  \n5 3  \n8 0  \n```  \n\nSample Output 2:  \n```\n3  \n3  \n2  \n```  \n\nExplanation for \\( k = 1 \\):  \nThe graph has the following three connected components:  \n- A connected component with vertices \\( 0, 1, 3, 6, 10 \\).  \n- A connected component with vertices \\( 2, 5, 7, 8, 9 \\).  \n- A connected component with vertex \\( 4 \\).  \n\nThus, the answer for \\( k = 1 \\) is \\( 3 \\).  \n\nSample Input 3:  \n```\n182 3  \n61 2  \n77 88  \n180 55  \n```  \n\nSample Output 3:  \n```\n36  \n14  \n9  \n```\n\nSolution:\n\n[BEGIN TEXT]\nBelow is a cleaner version of the editorial:\n\n---\n\n**Editorial - AtCoder Regular Contest 182**\n\n**Official Problem F - Graph of Mod of Linear**\n\nWe will analyze the problem in terms of directed graphs. The number of connected components in the undirected graph corresponds to the number of cycles in the directed graph, so we will focus on the latter.\n\n1. **When \\(\\gcd(N, A) \\neq 1\\):**\n\n   Let \\(f^N(x)\\) represent the vertex reached after \\(N\\) moves starting from vertex \\(x\\). We have \\(\\displaystyle f^N(x)\\equiv A^N x + B\\frac{A^N-1}{A-1}\\ \\text{mod}\\ N\\). Here, let \\(d = \\gcd(N, A^N)\\). Since \\(\\displaystyle f^N(x+1)-f^N(x)\\equiv A^N\\equiv 0\\ \\text{mod}\\ d\\), the vertices forming a cycle all match \\(f^N(0)\\) modulo \\(d\\). Considering only these vertices, the problem can be reduced to the case where \\(\\displaystyle(N, A, B) \\leftarrow \\left(\\frac{N}{d}, A \\mod \\frac{N}{d}, \\frac{A^N}{d}B \\mod \\frac{N}{d}\\right)\\). By performing this substitution, the problem can be reduced to the case where \\(\\gcd(N, A) = 1\\).\n\n2. **When \\(\\gcd(N, A) = 1\\):**\n\n   If \\(\\gcd(N, A) = 1\\), all vertices form some cycle. Therefore, the answer is the sum of the reciprocals of the lengths of the cycles formed by each vertex. If vertex \\(x\\) returns to its original position after \\(K\\) moves, then \\(\\displaystyle A^K x + B\\frac{A^K-1}{A-1}\\equiv x\\ \\text{mod}\\ N\\), which implies \\(\\displaystyle A^K\\equiv 1\\ \\text{mod}\\ \\frac{N(A-1)}{\\gcd(N(A-1), (A-1)x+B)}\\). Letting \\(G = \\gcd(A-1, B)\\), \\(A'=\\frac{A-1}{G}\\), \\(B'=\\frac{B}{G}\\), and \\(N'=\\frac{N}{\\gcd(A'^N, N)}\\), we have \\(\\displaystyle \\gcd(N(A-1), (A-1)x+B)=G\\gcd(N', A'x+B')\\). Since \\(A'\\) and \\(N'\\) are coprime, for each \\(0\\le y<N'\\), there exist exactly \\(\\displaystyle \\frac{N}{N'}\\) values \\(0\\le x<N\\) such that \\(y\\equiv A'x+B'\\ \\text{mod}\\ N'\\). Therefore, if we let \\(C_y\\) be the smallest positive integer \\(K\\) such that \\(\\displaystyle A^K\\equiv 1\\ \\text{mod}\\ \\frac{NA'}{\\gcd(y, N')}\\) for each \\(0\\le y<N'\\), the desired answer is \\(\\displaystyle \\frac{N}{N'}\\sum_{y=0}^{N'-1}\\frac{1}{C_y}\\). Values of \\(y\\) with the same \\(\\gcd(y, N')\\) have the same \\(C_y\\). Therefore, for each divisor \\(n\\) of \\(N'\\), we need to find the answer for \\(n = \\gcd(y, N')\\), and sum them up. The number of values \\(0\\le y<N'\\) such that \\(n = \\gcd(y, N')\\) is \\(\\displaystyle \\phi\\left(\\frac{N'}{n}\\right)\\), so the answer can be expressed as \\(\\displaystyle \\frac{N}{N'}\\sum_{n| N'}\\frac{1}{C_n}\\phi\\left(\\frac{N'}{n}\\right)\\). Here, \\(\\phi\\) is the Euler\u2019s totient function.\n\nTo compute \\(C_n\\) for each \\(n\\), we can use the following facts:\n\n- By Euler\u2019s theorem, the candidates for \\(C_1\\) are divisors of \\(\\phi(NA')\\).\n- Let \\(n_1\\) and \\(n_2\\) be divisors of \\(N'\\). If \\(n_1\\) divides \\(n_2\\), then \\(C_{n_2}\\) divides \\(C_{n_1}\\).\n\nThis approach can be implemented using a DFS-like method. The value of \\(\\phi(NA')\\) and its prime factorization can be computed quickly by precomputing the prime factorizations of all positive integers up to \\(N\\).\n\n---\n\nThis concise editorial provides a clear breakdown of the problem-solving approach without unnecessary content.\n[END TEXT]\n \n\n", "problem_ids": ["arc183_e", "abc356_b", "arc182_f"]}, "abc315_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nN AtCoder users have gathered to play AtCoder RPS 2. The i-th user's name is \\( S_i \\) and their rating is \\( C_i \\).\n\nAtCoder RPS 2 is played as follows:\n1. Assign the numbers \\( 0, 1, \\dots, N - 1 \\) to the users in lexicographical order of their usernames.\n2. Let \\( T \\) be the sum of the ratings of the N users. The user assigned the number \\( T \\mod N \\) is the winner.\n\nPrint the winner's username.\n\n**What is lexicographical order?**\n\nLexicographical order, simply put, means \"the order in which words appear in a dictionary.\" More precisely, the algorithm to determine the order of two distinct strings \\( S \\) and \\( T \\) consisting of lowercase English letters is as follows:\n\n- If \\( S \\) is lexicographically smaller than \\( T \\), we write \\( S < T \\), and if \\( S \\) is larger, we write \\( S > T \\).\n1. Let \\( L \\) be the length of the shorter string among \\( S \\) and \\( T \\). Check if \\( S_i \\) and \\( T_i \\) match for \\( i = 1, 2, \\dots, L \\).\n2. If there exists an \\( i \\) such that \\( S_i \\neq T_i \\), let \\( j \\) be the smallest such \\( i \\). Compare \\( S_j \\) and \\( T_j \\). If \\( S_j \\) is alphabetically smaller than \\( T_j \\), then \\( S < T \\). Otherwise, \\( S > T \\). The algorithm ends here.\n3. If there is no \\( i \\) such that \\( S_i \\neq T_i \\), compare the lengths of \\( S \\) and \\( T \\). If \\( S \\) is shorter than \\( T \\), then \\( S < T \\). If \\( S \\) is longer, then \\( S > T \\). The algorithm ends here.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( S_i \\) is a string consisting of lowercase English letters with length between 3 and 16, inclusive.\n- \\( S_1, S_2, \\dots, S_N \\) are all distinct.\n- \\( 1 \\leq C_i \\leq 4229 \\)\n- \\( C_i \\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN\nS_1 C_1\nS_2 C_2\n\\vdots\nS_N C_N\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n```\n3\ntakahashi 2\naoki 6\nsnuke 5\n```\n\n**Sample Output 1:**\n```\nsnuke\n```\n\n*Explanation:*\nThe sum of the ratings of the three users is 13. Sorting their names in lexicographical order yields aoki, snuke, takahashi, so aoki is assigned number 0, snuke is 1, and takahashi is 2. Since \\( 13 \\mod 3 = 1 \\), print snuke, who is assigned number 1.\n\n**Sample Input 2:**\n```\n3\ntakahashi 2813\ntakahashixx 1086\ntakahashix 4229\n```\n\n**Sample Output 2:**\n```\ntakahashix\n```\n\nSolution:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nSolution:\nMost mainstream programming languages provide lexicographical comparison of strings as a function in the standard library or a language feature. With this feature, implementation will be simple. For example in Python, the < operator compares strings in lexicographical order. The total rating \\(T\\) of the users can be found using a for loop. Then one can find \\(T \\bmod N\\) to find the index of the winner. Also, one has to find the number assigned to each user. This can be done by sorting the user\u2019s name in lexicographical order. Most languages provide a sorting function, which enables us concise implementation.\n\nThe complexity of sorting strings:\nLet \\(\\displaystyle M = \\sum_{i=1}^{N} |S_i| \\). With merge sort, the complexity is \\(O(M \\log N)\\). This is due to the fact that lexicographical comparison of two strings \\(a\\) and \\(b\\) can be done in \\(O(\\min(|a|, |b|))\\) time. In Python, the sorted function uses Timsort, which runs in \\(O(n \\log n)\\) time, where n is the number of elements which are being sorted; it performs well for string comparison. It can also be solved in \\(O(M)\\) time using SA-IS for example.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou have an empty bag. You are given \\( Q \\) queries, which must be processed in order. There are three types of queries:\n\n1. `1 x`: Put one ball with the integer \\( x \\) written on it into the bag.\n2. `2 x`: Remove one ball with the integer \\( x \\) written on it from the bag and discard it. It is guaranteed that the bag has a ball with the integer \\( x \\) written on it when this query is given.\n3. `3`: Print the number of different integers written on the balls in the bag.\n\n**Constraints**\n\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq x \\leq 10^{6} \\)\n- When a query of the second type is given, the bag has a ball with the integer \\( x \\) written on it.\n- There is at least one query of the third type.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nQ\nquery_1\nquery_2\n\u22ee\nquery_Q\n```\n\nThe \\( i \\)-th query \\( \\text{query}_i \\) is given in one of the following three formats:\n\n```\n1 x\n2 x\n3\n```\n\n**Output**\n\nIf there are \\( K \\) queries of the third type, print \\( K \\) lines. The \\( i \\)-th line \\((1 \\leq i \\leq K)\\) should contain the answer to the \\( i \\)-th query of the third type.\n\n**Sample Input 1**\n\n```\n8\n1 3\n1 1\n1 4\n3\n2 1\n3\n1 5\n3\n```\n\n**Sample Output 1**\n\n```\n3\n2\n3\n```\n\n**Explanation**\n\nInitially, the bag is empty.\n- For the first query `1 3`, a ball with the integer 3 written on it enters the bag.\n- For the second query `1 1`, a ball with the integer 1 written on it enters the bag.\n- For the third query `1 4`, a ball with the integer 4 written on it enters the bag.\n- For the fourth query `3`, the bag has balls with the integers 1, 3, 4, so print 3.\n- For the fifth query `2 1`, a ball with the integer 1 written on it is removed from the bag.\n- For the sixth query `3`, the bag has balls with the integers 3, 4, so print 2.\n- For the seventh query `1 5`, a ball with the integer 5 written on it enters the bag.\n- For the eighth query `3`, the bag has balls with the integers 3, 4, 5, so print 3.\n\n**Sample Input 2**\n\n```\n8\n1 2\n1 2\n3\n2 2\n1 4\n1 4\n2 2\n3\n```\n\n**Sample Output 2**\n\n```\n1\n1\n```\n\nSolution:\n\n[BEGIN TEXT]\nLet us consider the properties of each operation, particularly the first and second types. Both operations can increase or decrease the number of distinct numbers in the bag by one. Specifically, adding a ball increases the count by one or zero, and removing a ball decreases the count by one or zero. To determine if each operation affects the count, we need to check how many balls with a specific integer are in the bag. On insertion, if the bag already contains a ball with that number, the distinct count does not increase; otherwise, it increases by one. Similarly, on removal, the change in count depends on the number of balls with that specific integer. Thus, to process the queries, keep track of the current number of distinct integers with an integer and the number of balls with each integer in an array of length \\(10^6\\). For more details, please refer to the sample code.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\).\n\nYou can perform the following operation any number of times, possibly zero: Choose an integer pair \\((i, j)\\) satisfying \\(1 \\leq i < j \\leq N\\), and replace \\(A_i\\) with \\(A_i + 1\\) and \\(A_j\\) with \\(A_j - 1\\).\n\nDetermine whether it is possible to make \\( A \\) a non-decreasing sequence through the operations.\n\nYou are given \\( T \\) test cases. Solve each of them.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format. Here, \\( \\mathrm{case}_i \\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\nFor each test case, if it is possible to make \\( A \\) a non-decreasing sequence through the operations, print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n\n```\n3\n3\n1 7 5\n2\n9 0\n10\n607 495 419 894 610 636 465 331 925 724\n```\n\n**Sample Output 1**\n\n```\nYes\nNo\nYes\n```\n\nIn the first test case, you can make \\( A \\) into a non-decreasing sequence by performing the following operations:\n1. Choose \\((i, j) = (1, 2)\\). After the operation, \\( A \\) is \\( (2, 6, 5) \\).\n2. Choose \\((i, j) = (1, 2)\\). After the operation, \\( A \\) is \\( (3, 5, 5) \\).\n\nIn the second test case, you cannot make \\( A \\) into a non-decreasing sequence no matter how you perform the operations.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - AtCoder Regular Contest 185\n\nB - +1 and -1 Editorial by evima\n\nIt is possible to turn \\(A\\) into a non-decreasing sequence if and only if the following condition is satisfied: A non-decreasing sequence where the difference between the maximum and minimum values is at most \\(1\\) is called a good sequence. It is possible to turn \\(A\\) into a good sequence through operations.\n\nProof: If we can make \\(A\\) into a good sequence, then \\(A\\) can be made into a non-decreasing sequence. Suppose we transform \\(A\\) into a non-decreasing sequence. After that, we can perform operations to transform \\(A\\) into a good sequence:\n\nInvariant: Initially, the sequence \\((A_1)\\) is a good sequence, and \\(A\\) is non-decreasing. For \\(i = 2, 3, \\dots, N\\), do the following:\n\nInvariant: \\((A_1, A_2, \\dots, A_{i-1})\\) is a good sequence. While \\((A_1, A_2, \\dots, A_i)\\) is not a good sequence, find exactly one position \\(j\\) \\((1 \\leq j \\leq i-1)\\) where adding \\(1\\) to \\(A_j\\) maintains \\((A_1, A_2, \\dots, A_{i-1})\\) as a good sequence. Perform the operation on \\((j, i)\\).\n\nRepeat the operation until \\((A_1, A_2, \\dots, A_i)\\) becomes a good sequence. \\((A_1, A_2, \\dots, A_i)\\) becomes a good sequence if \\(A_{i-1}\\) and \\(A_i\\) coincide, reducing the difference by \\(1\\) or \\(2\\). If it is not obtained, choosing \\(j = i - 1\\) when the difference is \\(1\\) results in \\((A_1, A_2, \\dots, A_{i-1}, A_i) = (x, x, \\dots, x, x+1)\\), which is a good sequence, so no operation is performed.\n\nAfter the operation, \\((A_1, A_2, \\dots, A_i)\\) is a good sequence, and \\(A_i \\leq A_{i+1}\\), so \\(A\\) remains non-decreasing.\n\nThus, the two propositions are equivalent. We can determine if \\(A\\) can become a good sequence in \\(\\mathrm{O}(N)\\) time using cumulative sums, solving this problem in \\(\\mathrm{O}(N)\\) per test case.\n        [END TEXT]\n \n\n", "problem_ids": ["abc354_b", "abc366_c", "arc185_b"]}, "abc318_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi will encounter \\( N \\) monsters in order. The \\( i \\)-th monster \\((1 \\leq i \\leq N)\\) has a strength of \\( A_i \\).\n\nFor each monster, he can choose to either let it go or defeat it. Each action awards him experience points as follows:\n- If he lets a monster go, he gains 0 experience points.\n- If he defeats a monster with strength \\( X \\), he gains \\( X \\) experience points. If it is an even-numbered defeated monster (2nd, 4th, ...), he gains an additional \\( X \\) experience points.\n\nFind the maximum total experience points he can gain from the \\( N \\) monsters.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the maximum total experience points he can gain from the \\( N \\) monsters as an integer.\n\n**Sample Input 1:**\n```\n5\n1 5 3 2 7\n```\n\n**Sample Output 1:**\n```\n28\n```\n\n**Explanation:**\n\nIf Takahashi defeats the 1st, 2nd, 3rd, and 5th monsters, and lets the 4th monster go, he gains experience points as follows:\n- Defeats a monster with strength \\( A_1 = 1 \\). He gains 1 experience point.\n- Defeats a monster with strength \\( A_2 = 5 \\). He gains 5 experience points. As it is the 2nd defeated monster, he gains an additional 5 points.\n- Defeats a monster with strength \\( A_3 = 3 \\). He gains 3 experience points.\n- Lets the 4th monster go. Takahashi gains no experience points.\n- Defeats a monster with strength \\( A_5 = 7 \\). He gains 7 experience points. As it is the 4th defeated monster, he gains an additional 7 points.\n\nTherefore, in this case, he gains \\( 1+(5+5)+3+0+(7+7)=28 \\) experience points. Note that even if he encounters a monster, if he lets it go, it does not count as defeated. He can gain at most 28 experience points no matter how he acts, so print 28. As a side note, if he defeats all monsters in this case, he would gain \\( 1+(5+5)+3+(2+2)+7=25 \\) experience points.\n\n**Sample Input 2:**\n```\n2\n1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n3000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 369\n\nD - Bonus EXP Editorial\n\nThis problem can be solved with dynamic programming (DP). Let \\(dp_{even}[k]\\) be the maximum total experience point when defeating an even number of monsters out of the first \\(k\\) monsters encountered, and \\(dp_{odd}[k]\\) be that for an odd number of monsters (or \\(-\\infty\\) if it is impossible). Initially, \\(dp_{even}[0]=0\\) and \\(dp_{odd}[0]=-\\infty\\).\n\nFor \\(1\\leq i\\leq N\\), the experience point from the \\(i\\)-th monster depends on whether Takahashi chooses to defeat it or not, and whether the number of defeated monsters is even or odd. To encounter the first \\(i\\) monsters and defeat an even number, we have two cases:\n\n1. Defeat an even number of monsters from the first \\((i-1)\\) and let the \\(i\\)-th go.\n2. Defeat an odd number of monsters from the first \\((i-1)\\) and defeat the \\(i\\)-th.\n\nThus, we can find \\(dp_{even}[i]\\) as \n\\[\ndp_{even}[i]=\\max(dp_{even}[i-1],dp_{odd}[i-1]+2A_i).\n\\]\n\nSimilarly, \\(dp_{odd}[i]\\) is\n\\[\ndp_{odd}[i]=\\max(dp_{odd}[i-1],dp_{even}[i-1]+A_i).\n\\]\n\nThe final answer is \\(\\max(dp_{even}[N],dp_{odd}[N])\\), with a complexity of \\(O(N)\\).\n\nSample code in Python:\n```python\nINF = 10**18\n\ndef main():\n    n = int(input())\n    dp0, dp1 = 0, -INF\n    for _ in range(n):\n        x = int(input())\n        tmp = dp0\n        dp0 = max(dp1 + 2*x, dp0)\n        dp1 = max(tmp + x, dp1)\n    print(max(dp0, dp1))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( K \\).\n\nThe **cumulative sums** of an integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is defined as a sequence \\( Y = (Y_0, Y_1, \\dots, Y_N) \\) of length \\( N+1 \\) as follows:\n\n- \\( Y_0 = 0 \\)\n- \\( Y_i = \\sum_{j=1}^{i} X_j \\) for \\( i = 1, 2, \\dots, N \\)\n\nAn integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is called a **good sequence** if and only if it satisfies the following condition:\n\n- Any value in the cumulative sums of \\( X \\) that is less than \\( K \\) appears before any value that is not less than \\( K \\).\n  \n  Formally, for the cumulative sums \\( Y \\) of \\( X \\), for any pair of integers \\( (i, j) \\) such that \\( 0 \\le i, j \\le N \\), if \\( (Y_i < K \\) and \\( Y_j \\ge K) \\), then \\( i < j \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). Determine whether the elements of \\( A \\) can be rearranged to form a good sequence. If so, print one such rearrangement.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq K \\leq 10^9 \\)\n- \\( -10^9 \\leq A_i \\leq 10^9 \\)\n\nAll input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nIf the elements of \\( A \\) can be rearranged to a good sequence, print the rearranged sequence \\( (A'_1, A'_2, \\dots, A'_N) \\) in the following format:\n\n```\nYes\nA'_1 A'_2 \\cdots A'_N\n```\n\nIf there are multiple valid rearrangements, any of them is considered correct.\n\nIf a good sequence cannot be obtained, print `No`.\n\n**Sample Input 1**\n```\n4 1\n-1 2 -3 4\n```\n\n**Sample Output 1**\n```\nYes\n-3 -1 2 4\n```\n\nIf you rearrange \\( A \\) to \\((-3, -1, 2, 4)\\), the cumulative sums \\( Y \\) will be \\( (0, -3, -4, -2, 2) \\). In this \\( Y \\), any value less than 1 appears before any value not less than 1.\n\n**Sample Input 2**\n```\n4 -1\n1 -2 3 -4\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n10 1000000000\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\nYes\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 179 - A - Partition Editorial by evima\n\nIf \\(K \\geq 1\\):\nBy sorting \\(A\\) in ascending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in ascending order. Let \\(B\\) be the cumulative sums of \\(A\\). Values in \\(A\\) that are less than \\(0\\) appear before values that are \\(0\\) or greater. Therefore, \\(B\\) can be represented as a concatenation of a strictly decreasing sequence and a non-decreasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 < K\\) and decreasing for a while, it begins to increase from a value less than \\(K\\). Once it becomes \\(K\\) or greater, it remains so thereafter. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i \\geq K\\):\nBy sorting \\(A\\) in descending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in descending order. Let \\(B\\) be the cumulative sum of \\(A\\). Values in \\(A\\) that are \\(0\\) or greater appear before values that are less than \\(0\\). Therefore, \\(B\\) can be represented as a concatenation of a strictly increasing sequence and a non-increasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 \\geq K\\) and increasing for a while, it begins to decrease from a value not less than \\(K\\). Since \\(B_0 \\geq K\\), it is \\(K\\) or greater from the start, and since \\(B_N = \\sum_{i=1}^{N}A_i \\geq K\\), it remains \\(K\\) or greater until the end. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i < K\\):\nNo matter how \\(A\\) is rearranged, it cannot be made into a good sequence. No matter how \\(A\\) is rearranged, the initial and final terms of the cumulative sum \\(B\\) of \\(A\\) are fixed. Since \\(B_0 = 0 \\geq K\\) and \\(B_N = \\sum_{i=1}^{N}A_i < K\\), it does not satisfy the conditions for a good sequence.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 500 points\n\n### Problem Statement\n\nHow many integers \\( x \\) between 1 and \\( N \\), inclusive, can be expressed as \\( x = a^b \\) using some positive integer \\( a \\) and a positive integer \\( b \\) not less than 2?\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 10^{18} \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\n```\n\n### Output\n\nPrint the answer as an integer.\n\n### Sample Input 1\n\n```\n99\n```\n\n### Sample Output 1\n\n```\n12\n```\n\nThe integers that satisfy the conditions in the problem statement are: 1, 4, 8, 9, 16, 25, 27, 32, 36, 49, 64, 81. There are 12 of these.\n\n### Sample Input 2\n\n```\n1000000000000000000\n```\n\n### Sample Output 2\n\n```\n1001003332\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Denso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09 Editorial - Problem F: x = a^b\n\nWe introduce a rather brute-force solution. As evident from Sample 2, a total of 1001003332 integers can satisfy the condition. Since \\((10^9)^2 = 10^{18}\\), \\(10^9\\) integers among them can be represented as \\(a^2\\). Therefore, there are only \\(10^6\\) integers that cannot be represented as \\(a^2\\). One can enumerate all of them and then add the number of those represented as \\(a^2\\). This enumeration can be done for \\(b=3,4,\\dots,59\\) and then stopped once \\(a^b > N\\) is satisfied; one can determine if an integer \\(x\\) can be represented as \\(a^2\\) by checking if \\((\\lfloor \\sqrt{x} \\rfloor )^2=x\\).\n\nSample code (Python):\n```python\nimport math\n\ndef safe_pow(a, b):\n    res = 1\n    for _ in range(b):\n        dres = res\n        dres *= a\n        if dres > 2e18:\n            return 2e18\n        res *= a\n    return res\n\ndef sqrt_floor(x):\n    l, r = 0, int(2e9)\n    while l <= r:\n        t = (l + r) // 2\n        if t * t > x:\n            r = t - 1\n        else:\n            l = t + 1\n    return r\n\ndef main():\n    n = int(input().strip())\n    st = set()\n    for b in range(3, 60):\n        a = 2\n        while True:\n            x = safe_pow(a, b)\n            if x > n:\n                break\n            s = sqrt_floor(x)\n            if s * s != x:\n                st.add(x)\n            a += 1\n    res = len(st)\n    res += sqrt_floor(n)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc369_d", "arc179_a", "abc361_f"]}, "abc318_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given two permutations \\( P = (P_1, P_2, \\dots, P_N) \\) and \\( Q = (Q_1, Q_2, \\dots, Q_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nWrite one of the characters '0' and '1' in each cell of an \\( N \\)-by-\\( N \\) grid so that all of the following conditions are satisfied:\n\n1. Let \\( S_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th row from the 1st to the \\( N \\)-th column. Then, \\( S_{P_1} < S_{P_2} < \\dots < S_{P_N} \\) in lexicographical order.\n\n2. Let \\( T_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th column from the 1st to the \\( N \\)-th row. Then, \\( T_{Q_1} < T_{Q_2} < \\dots < T_{Q_N} \\) in lexicographical order.\n\nIt can be proved that for any \\( P \\) and \\( Q \\), there is at least one way to write the characters that satisfies all the conditions.\n\n**Lexicographical Order Explanation:**\n\nFor strings \\( X = X_1 X_2 \\dots X_{|X|} \\) and \\( Y = Y_1 Y_2 \\dots Y_{|Y|} \\), \" \\( X < Y \\) in lexicographical order\" means that condition 1 or 2 below holds:\n\n1. \\( |X| < |Y| \\) and \\( X_1 X_2 \\ldots X_{|X|} = Y_1 Y_2 \\ldots Y_{|X|} \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\lbrace |X|, |Y| \\rbrace \\) such that both of the following are true:\n   - \\( X_1 X_2 \\ldots X_{i-1} = Y_1 Y_2 \\ldots Y_{i-1} \\)\n   - \\( X_i \\) is less than \\( Y_i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( P \\) and \\( Q \\) are permutations of \\( (1, 2, \\dots, N) \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n\n```\nN\nP_1 P_2 \\dots P_N\nQ_1 Q_2 \\dots Q_N\n```\n\n**Output:**\n\nPrint a way to fill the grid that satisfies the conditions in the following format, where \\( A_{ij} \\) is the character written at the \\( i \\)-th row and \\( j \\)-th column:\n\n```\nA_{11} A_{12} \\dots A_{1N}\n...\nA_{N1} A_{N2} \\dots A_{NN}\n```\n\nIf there are multiple ways to satisfy the conditions, any of them will be accepted.\n\n**Sample Input 1:**\n\n```\n3\n1 2 3\n2 1 3\n```\n\n**Sample Output 1:**\n\n```\n001\n101\n110\n```\n\nIn this sample, \\( S_1 = \\) \"001\", \\( S_2 = \\) \"101\", \\( S_3 = \\) \"110\", and \\( T_1 = \\) \"011\", \\( T_2 = \\) \"001\", \\( T_3 = \\) \"110\". Therefore, \\( S_1 < S_2 < S_3 \\) and \\( T_2 < T_1 < T_3 \\) hold, satisfying the conditions.\n\n**Sample Input 2:**\n\n```\n15\n8 15 10 2 4 3 1 13 5 12 9 6 14 11 7\n4 1 5 14 3 12 13 7 11 8 6 2 9 15 10\n```\n\n**Sample Output 2:**\n\n```\n010001111110101\n001000000101001\n010001001100010\n010000011110010\n010011101101101\n100101110100000\n111100011001000\n000001001100000\n100011011000101\n000111101011110\n101010101010101\n011010101011110\n010011000010011\n100110010110101\n000101101100100\n```\n\nSolution:\n\n```python\ndef fill_grid(N, P, Q):\n    grid = [[None] * N for _ in range(N)]\n\n    # Step 1: Write 0 in all cells of row P_1\n    for j in range(N):\n        grid[P[0]][j] = 0\n\n    # Step 2: Write 1 in all cells of column Q_N that are still empty\n    for i in range(N):\n        if grid[i][Q[N-1]] is None:\n            grid[i][Q[N-1]] = 1\n\n    # Recursive filling for remaining (N-1) x (N-1) cells\n    def fill_recursive(start, end, P, Q):\n        if start >= end:\n            return\n        # Write in row P[start]\n        for j in range(N):\n            if grid[P[start]][j] is None:\n                grid[P[start]][j] = 0\n        # Write in column Q[end]\n        for i in range(N):\n            if grid[i][Q[end]] is None:\n                grid[i][Q[end]] = 1\n        # Recurse on remaining subproblem\n        fill_recursive(start + 1, end - 1, P, Q)\n\n    fill_recursive(1, N-1, P, Q)\n\n    return grid\n\n# Example usage\nN = 3\nP = [0, 1, 2]  # Row order\nQ = [2, 1, 0]  # Column order\ngrid = fill_grid(N, P, Q)\nfor row in grid:\n    print(row)\n```\n\n**C - Row and Column Order Editorial by evima**\n\n**Solution**\n\n1. Write 0 in all cells of row \\(P_1\\).\n2. Write 1 in all cells of column \\(Q_N\\) that are still empty.\n3. For the remaining \\((N-1) \\times (N-1)\\) cells, let \\(S'_i\\) be the string obtained by concatenating row \\(i\\) excluding column \\(Q_N\\), and \\(T'_j\\) be the string obtained by concatenating column \\(j\\) excluding row \\(P_1\\). Then, recursively write in the same way so that \\(S'_{P_2} < S'_{P_3} < \\dots < S'_{P_N}\\) and \\(T'_{Q_2} < T'_{Q_3} < \\dots < T'_{Q_N}\\) hold.\n\nThe grid filled by this algorithm will satisfy the problem's conditions. Additionally, each column will contain at least one cell with 0, as 0 is always written in row \\(P_1\\). The lexicographical order of \\(S_{P_i}\\) and \\(T_{Q_i}\\) is maintained through recursive writing. The order of writing is \\(i=1,2,\\dots,N\\): first, write 0 in row \\(P_i\\) cells not yet written, then write 1 in column \\(Q_{N+1-i}\\) cells still empty.\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land is represented by a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i, j)\\) denote the cell at the \\(i\\)-th row and \\(j\\)-th column.\n\nTakahashi starts at cell \\((S_i, S_j)\\) and repeats the following action \\(K\\) times:\n- He either stays in the current cell or moves to an adjacent cell. After this action, if he is in cell \\((i, j)\\), he gains a fun value of \\(A_{i, j}\\).\n\nFind the maximum total fun value he can gain.\n\nHere, a cell \\((x', y')\\) is considered adjacent to cell \\((x, y)\\) if and only if \\(|x - x'| + |y - y'| = 1\\).\n\n**Constraints**\n\n- \\(1 \\leq H, W \\leq 50\\)\n- \\(1 \\leq K \\leq 10^9\\)\n- \\(1 \\leq S_i \\leq H\\)\n- \\(1 \\leq S_j \\leq W\\)\n- \\(1 \\leq A_{i, j} \\leq 10^9\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nH W K\nS_i S_j\nA_{1, 1} A_{1, 2} \\ldots A_{1, W}\nA_{2, 1} A_{2, 2} \\ldots A_{2, W}\n\\vdots\nA_{H, 1} A_{H, 2} \\ldots A_{H, W}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 3 3\n1 2\n2 1 2\n3 4 5\n```\n\n**Sample Output 1**\n\n```\n14\n```\n\nTakahashi can gain a total fun value of 14 by acting as follows:\n- Initially, he is at \\((1, 2)\\).\n- He moves to cell \\((2, 2)\\). Then, he gains a fun value of \\(A_{2, 2} = 4\\).\n- He moves to cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n- He stays in cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n\nHe cannot gain a total fun value greater than 14, so print 14.\n\n**Sample Input 2**\n\n```\n2 2 1000000000\n2 1\n100 100\n100 99\n```\n\n**Sample Output 2**\n\n```\n100000000000\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        In an optimal solution, one can assume that Takahashi stays at a cell with the maximum \\(A_{i,j}\\) among those he passes through. This means he can keep staying there indefinitely. Let \\((G_i, G_j)\\) be the final cell. We assume he travels from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) and then stays there zero or more times. In the travel, he never passes through the same cell twice because if he does, he can improve the score by staying more times at \\((G_i, G_j)\\). Paths from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) have a length not greater than \\(HW\\), allowing for a straightforward DP (Dynamic Programming) approach. Specifically, evaluate \\(dp_{i,j,k}\\) as the maximum total fun value after making \\(i\\) moves to end up at \\((j,k)\\). The answer is \\(\\max ((K - i) A_{j,k} + dp_{i,j,k})\\). The DP runs in \\(O((HW)^2)\\) time. Consider cases where \\(K \\leq HW\\).\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 450 points\n\n**Problem Statement**\n\nThere is an island of size \\(H \\times W\\), surrounded by the sea. The island is divided into \\(H\\) rows and \\(W\\) columns of \\(1 \\times 1\\) sections, and the elevation of the section at the \\(i\\)-th row from the top and the \\(j\\)-th column from the left (relative to the current sea level) is \\(A_{i,j}\\). Starting from now, the sea level rises by 1 each year. A section that is vertically or horizontally adjacent to the sea or a section sunk into the sea and has an elevation not greater than the sea level will sink into the sea. When a section newly sinks into the sea, any vertically or horizontally adjacent section with an elevation not greater than the sea level will also sink into the sea simultaneously, and this process repeats for the newly sunk sections.\n\nFor each \\(i=1, 2, \\ldots, Y\\), find the area of the island that remains above sea level \\(i\\) years from now.\n\n**Constraints**\n\n- \\(1 \\leq H, W \\leq 1000\\)\n- \\(1 \\leq Y \\leq 10^5\\)\n- \\(1 \\leq A_{i,j} \\leq 10^5\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nH W Y\nA_{1,1} A_{1,2} \\ldots A_{1,W}\nA_{2,1} A_{2,2} \\ldots A_{2,W}\n\\vdots\nA_{H,1} A_{H,2} \\ldots A_{H,W}\n```\n\n**Output**\n\nPrint \\(Y\\) lines. The \\(i\\)-th line (\\(1 \\leq i \\leq Y\\)) should contain the area of the island that remains above sea level \\(i\\) years from now.\n\n**Sample Input 1**\n```\n3 3 5\n10 2 10\n3 1 4\n10 5 10\n```\n\n**Sample Output 1**\n```\n9\n7\n6\n5\n4\n```\n\nLet \\((i,j)\\) denote the section at the \\(i\\)-th row from the top and the \\(j\\)-th column from the left. Then, the following happens:\n\n- After 1 year, the sea level is higher than now by 1, but there are no sections with an elevation of 1 that are adjacent to the sea, so no sections sink. Thus, the first line should contain 9.\n- After 2 years, the sea level is higher than now by 2, and \\((1,2)\\) sinks into the sea. This makes \\((2,2)\\) adjacent to a sunken section, and its elevation is not greater than 2, so it also sinks. No other sections sink at this point. Thus, two sections sink, and the second line should contain \\(9-2=7\\).\n- After 3 years, the sea level is higher than now by 3, and \\((2,1)\\) sinks into the sea. No other sections sink. Thus, the third line should contain 6.\n- After 4 years, the sea level is higher than now by 4, and \\((2,3)\\) sinks into the sea. No other sections sink. Thus, the fourth line should contain 5.\n- After 5 years, the sea level is higher than now by 5, and \\((3,2)\\) sinks into the sea. No other sections sink. Thus, the fifth line should contain 4.\n\nTherefore, print 9, 7, 6, 5, 4 in this order, each on a new line.\n\n**Sample Input 2**\n```\n3 5 3\n2 2 3 3 3\n2 1 2 1 3\n2 2 3 3 3\n```\n\n**Sample Output 2**\n```\n15\n7\n0\n```\n\nSolution:\n\n```python\n# Let's implement a Python function based on the problem description\n\ndef sink_sections(A, Y, H, W):\n    # Initialize sequences Q for each year\n    Q = [[] for _ in range(Y + 1)]\n    \n    # Initialize the positions adjacent to the sea in year 0\n    for i in range(H):\n        for j in range(W):\n            # Check if the initial circumference\n            if is_adjacent_to_sea(i, j):\n                if A[i][j] <= Y:\n                    Q[A[i][j]].append((i, j))\n    \n    # Iterate over years\n    for k in range(1, Y + 1):\n        for (i, j) in Q[k]:\n            # Check adjacent sections\n            for (i_prime, j_prime) in get_adjacent(i, j, H, W):\n                if not is_already_submerged(i_prime, j_prime):\n                    # Check if it becomes adjacent for the first time\n                    if becomes_adjacent(i_prime, j_prime, k):\n                        if A[i_prime][j_prime] <= k:\n                            Q[k].append((i_prime, j_prime))\n                        elif k + 1 <= A[i_prime][j_prime] <= Y:\n                            Q[A[i_prime][j_prime]].append((i_prime, j_prime))\n    \n    # The complexity is O(HW), which is efficient\n    return Q\n\ndef is_adjacent_to_sea(i, j):\n    # Define your logic to check if position (i, j) is adjacent to the sea initially\n    pass\n\ndef get_adjacent(i, j, H, W):\n    # Return a list of (i', j') positions adjacent to (i, j) within bounds\n    adjacent_positions = []\n    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        ni, nj = i + di, j + dj\n        if 0 <= ni < H and 0 <= nj < W:\n            adjacent_positions.append((ni, nj))\n    return adjacent_positions\n\ndef is_already_submerged(i, j):\n    # Check if the section (i, j) is already considered submerged\n    pass\n\ndef becomes_adjacent(i, j, year):\n    # Define logic to check if the section (i, j) becomes adjacent in the given year\n    pass\n```\n\nThis Python code provides a framework for solving the problem described in the editorial with a specific focus on simulating the sinking process over years. You'll need to fill in the details for how to check adjacency and other conditions based on the particular rules of the scenario.\n \n\n", "problem_ids": ["arc181_c", "abc358_g", "abc363_e"]}, "abc318_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) sequences of length \\( M \\), where each element is either 0 or 1. The \\( i \\)-th sequence is \\( A_i = (A_{i, 1}, A_{i, 2}, \\dots, A_{i, M}) \\).\n\nFor integers \\( i, j \\) \\((1 \\leq i, j \\leq N)\\), define \\( f(i, j) \\) as follows: \\( f(i, j) \\) is the smallest non-negative integer \\( x \\) such that \\( A_i \\) and \\( A_j \\) become identical after performing the following operation \\( x \\) times, or \\( 0 \\) if such \\( x \\) does not exist.\n\nOperation: For all integers \\( k \\) \\((1 \\leq k \\leq M)\\) simultaneously, replace \\( A_{i, k} \\) with \\( \\left (\\sum_{l=1}^{k} A_{i, l} \\right ) \\bmod 2 \\).\n\nFind \\( \\sum_{i=1}^{N} \\sum_{j=i}^{N} f(i, j) \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\times M \\leq 10^6 \\)\n- \\( A_{i, j} \\in \\{0, 1\\} \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1, 1} A_{1, 2} \\cdots A_{1, M}\nA_{2, 1} A_{2, 2} \\cdots A_{2, M}\n\\vdots\nA_{N, 1} A_{N, 2} \\cdots A_{N, M}\n```\n\n**Output**\n\nPrint the answer in one line.\n\n**Sample Input 1**\n\n```\n4 3\n1 0 0\n1 1 0\n1 0 1\n0 1 1\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\nExplanation: \\( f(1, 1) = 0 \\), \\( f(1, 2) = 3 \\), \\( f(1, 3) = 2 \\), \\( f(1, 4) = 0 \\), \\( f(2, 2) = 0 \\), \\( f(2, 3) = 3 \\), \\( f(2, 4) = 0 \\), \\( f(3, 3) = 0 \\), \\( f(3, 4) = 0 \\), \\( f(4, 4) = 0 \\), summing to 8.\n\n**Sample Input 2**\n\n```\n7 6\n1 0 0 0 0 0\n1 1 1 0 0 0\n1 0 1 1 0 0\n1 0 0 0 1 1\n1 0 0 0 0 1\n1 0 0 0 0 0\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n\n```\n6\n```\n\nSolution:\n\n```plaintext\nEditorial - E - Accumulating Many Times\n\nFirst, treat sequences that differ in the position of their first \\(1\\) as separate problems, since operations do not change this position. Assume \\(A_{i, 1} = 1\\). Define the inverse operation for the problem's operation. The graph formed by length-\\(M\\) binary sequences starting with \\(1\\) has operations as edges and is a collection of cycles. \n\nEvery sequence can be transformed into a \u201cstandard form\u201d where all elements at positions \\((2^x + 1)\\) using non-negative integer \\(x\\) are \\(0\\). This is proven using Lucas\u2019s theorem. Cycle length is \\(2^m\\), where \\(m\\) is the smallest non-negative integer such that \\(2^m + 1 \\leq M\\).\n\nTo solve, first transform sequences to their standard forms and calculate the required operations. For each \\(i = 1, 2, \\dots, N\\), compute the standard form of sequence \\(A_i\\) and the cost to reach it. Transform \\(A_{i, 2^x + 1}\\) into \\(0\\) by performing the operation \\(2^x\\) times if \\(A_{i, 2^x + 1} = 1\\).\n\nNext, solve for each standard form: for integer sequence \\(B\\), compute \\(\\displaystyle \\sum_{i=1}^{m} \\sum_{j=i}^{m} \\left( (B_j - B_i) \\bmod 2^m \\right)\\) using Segment Tree or similar structures.\n\nThe computational bottleneck is computing the standard forms. Multiple operations using FFT help, but we may exceed the time limit if performed every time. Instead, keep track of operations count to determine value at a position in \\(O(M)\\) time. Overall complexity is \\(O(NM \\log NM)\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 350 points\n\n**Problem Statement:**\n\nA souvenir shop at AtCoder Land sells \\(N\\) boxes. The boxes are numbered from 1 to \\(N\\), and box \\(i\\) has a price of \\(A_i\\) yen and contains \\(A_i\\) pieces of candy. Takahashi wants to buy \\(M\\) out of the \\(N\\) boxes and give one box each to \\(M\\) people named 1, 2, ..., \\(M\\).\n\nHe wants to select the boxes such that:\n- For each \\(i = 1, 2, \\ldots, M\\), person \\(i\\) is given a box containing at least \\(B_i\\) pieces of candy.\n\nIt is not allowed to give more than one box to a single person or to give the same box to multiple people.\n\nDetermine whether it is possible to buy \\(M\\) boxes that can satisfy the condition. If it is possible, compute the minimum total cost Takahashi needs to pay.\n\n**Constraints:**\n- \\(1 \\leq M \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq A_i, B_i \\leq 10^9\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_M\n```\n\n**Output:**\n\nIf it is possible to buy \\(M\\) boxes that can satisfy the condition, print the minimum total amount of money Takahashi needs to pay. Otherwise, print \\(-1\\).\n\n**Sample Input 1:**\n```\n4 2\n3 4 5 4\n1 4\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n*Takahashi can buy boxes 1 and 4, and give box 1 to person 1 and box 4 to person 2 to satisfy the condition. In this case, he needs to pay 7 yen in total, and it is impossible to satisfy the condition by paying less than 7 yen, so print 7.*\n\n**Sample Input 2:**\n```\n3 3\n1 1 1\n1000000000 1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n-1\n```\n\n**Sample Input 3:**\n```\n7 3\n2 6 8 9 5 1 11\n3 5 7\n```\n\n**Sample Output 3:**\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nConsider determining the box to give to people \\(1, 2, \\ldots, M\\) in this order. The following greedy strategy executed for each \\(i = 1, 2, \\ldots , M\\) in order is valid.\n\nTo person \\(i\\), give the undistributed box containing at least \\(B_i\\) candies with the smallest number of candies in it. (Let us call this strategy \\((\\bigstar)\\).)\n\nWe will assume that this solution is not optimal to deduce a contradiction. Take an optimal solution. In this optimal solution, there is an \\(i\\) that violates the strategy \\((\\bigstar)\\). Take the minimum such \\(i\\). Let box \\(X\\) be the box that you would give to person \\(i\\) if you obey the strategy \\((\\bigstar)\\) up to \\(1,2,\\ldots, i-1, i\\). In the taken optimal solution, if box \\(X\\) is not given to anyone, then giving person \\(i\\) box \\(X\\) improves the solution, which contradicts the optimality. Thus you will give it to a person \\(j\\). Consider swapping the boxes to give to person \\(i\\) and to person \\(j\\). This operation keeps optimality, but the minimum \\(i\\) that violates \\((\\bigstar)\\) strictly increases, so repeating this yields a contradiction. Hence, the greedy algorithm has been justified.\n\nTherefore, it is sufficient to simulate this greedy algorithm fast enough. This can be done by using a data structure like `sortedcontainers.SortedList` in Python, or using the sliding window trick by using the fact that \\(A\\) and \\(B\\) can be sorted without changing the answer.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\).\nAnswer the following \\( Q \\) queries.\n\nFor the \\( i \\)-th query, you are given integers \\( L_i \\) and \\( R_i \\).\nSolve the following problem for \\( B = (A_{L_i}, A_{L_{i}+1}, \\cdots, A_{R_i}) \\).\n\nDivide \\( B \\) into three non-empty contiguous subsequences. For each contiguous subsequence, find the maximum value of its elements. The task is to find the minimum possible sum of these maximum values.\n\nIt is guaranteed that the length of \\( B \\) is at least 3, so there is always at least one way to divide it into three non-empty contiguous subsequences.\n\n### Constraints\n\n- \\( 3 \\leq N \\leq 250000 \\)\n- \\( 1 \\leq Q \\leq 250000 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- \\( 1 \\leq L_i \\leq R_i \\leq N \\)\n- \\( R_i - L_i \\geq 2 \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from standard input in the following format:\n```\nN Q\nA_1 A_2 \\ldots A_N\nL_1 R_1\nL_2 R_2\n\u22ee\nL_Q R_Q\n```\n\n### Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n### Sample Input 1\n```\n7 5\n4 3 1 1 4 5 2\n1 7\n2 4\n3 5\n1 5\n4 7\n```\n\n### Sample Output 1\n```\n10\n5\n6\n9\n8\n```\n\nExplanation for the first query: We have \\( B = (4, 3, 1, 1, 4, 5, 2) \\). If you divide it into \\( (4, 3), (1, 1), (4, 5, 2) \\), the maximum values of the contiguous subsequences are 4, 1, and 5 respectively, and their sum is 10. There is no way to make this sum smaller, so the answer to this query is 10.\n\n### Sample Input 2\n```\n10 15\n8 3 8 10 1 5 3 1 6 4\n4 6\n2 5\n6 9\n8 10\n2 9\n4 10\n1 5\n1 8\n1 3\n4 8\n1 10\n2 10\n6 10\n2 6\n2 6\n```\n\n### Sample Output 2\n```\n16\n14\n12\n11\n17\n17\n19\n14\n19\n14\n17\n17\n12\n16\n16\n```\n\n\nSolution:\n\n        [BEGIN TEXT]\n        First, consider the case with one query. Suppose the input is \\(B=(B_1,\\cdots,B_N)\\). Let \\(B_m=\\max(B)\\). When decomposing \\(B\\) into \\(XYZ\\), consider the scenarios based on where \\(B_m\\) is included among \\(X, Y, Z\\). If \\(B_m\\) is in \\(Y\\), \\(\\max(Y)\\) is \\(B_m\\), so make \\(Y\\) larger: \\(X=(B_1), Y=(B_2,\\cdots,B_{N-1}), Z=(B_N)\\). If \\(B_m\\) is in \\(X\\), assume \\(Y\\) has one element. Try all possible positions for \\(Y\\) to calculate the answer. If \\(B_m\\) is in \\(Z\\), reverse the sequence to solve it similarly. For multiple queries, if \\(B_m\\) is in \\(Y\\), handle it with a simple RMQ. When \\(B_m\\) is in \\(X\\), use two main approaches: manage \\(\\max(Z)\\) for each \\(Y\\) by processing queries in ascending order of \\(R_i\\) with a segment tree for range addition and range minimum query or manage \\(Y\\) for each \\(\\max(Z)\\) with a stack and a segment tree for range minimum query. Using either approach, the time complexity is \\(O((N+Q) \\log N)\\).\n        [END TEXT]\n \n\n", "problem_ids": ["arc184_e", "abc358_d", "arc180_d"]}, "abc318_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence of integers \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nDefine \\( f(l, r) \\) as the number of distinct values in the subsequence \\( (A_l, A_{l+1}, \\ldots, A_r) \\).\n\nEvaluate the following sum:\n\n\\[\n\\sum_{i=1}^{N}\\sum_{j=i}^N f(i,j)\n\\]\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\n\nThe input is given in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n3\n1 2 2\n```\n\n### Sample Output 1\n\n```\n8\n```\n\nConsider \\( f(1, 2) \\). The subsequence \\( (A_1, A_2) = (1, 2) \\) contains 2 distinct values, so \\( f(1,2) = 2 \\).\n\nConsider \\( f(2, 3) \\). The subsequence \\( (A_2, A_3) = (2, 2) \\) contains 1 distinct value, so \\( f(2,3) = 1 \\).\n\nThe sum of \\( f \\) is 8.\n\n### Sample Input 2\n\n```\n9\n5 4 2 2 3 2 4 4 1\n```\n\n### Sample Output 2\n\n```\n111\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 371\n\nE - I Hate Sigma Problems Editorial\n\nThe answer is the number of subarrays containing \\(1\\) \\(+\\) the number of subarrays containing \\(2\\) \\(+\\ldots+\\) the number of subarrays containing \\(N\\). We will explain how to count subarrays containing \\(i\\) in \\(\\mathrm{O}(C_i)\\) time (where \\(C_i\\) is the number of occurrences of \\(i\\) in \\(A\\)). Once this is possible, the problem can be solved in a total of \\(\\mathrm{O}(N)\\) time. A common technique of combinatorics is to consider complementary events. Let\u2019s count the number of subarrays not containing \\(i\\), subtracting the sum from the all. For simplicity, let us insert \\(i\\) to both ends of \\(A\\). Then, the indices \\(x\\) with \\(A_x = i\\) arranged in ascending order are represented as \\(x=(x_0=0,x_1,\\ldots,x_{C_i+1} = N+1)\\). The number of subarrays not containing \\(i\\) equals the number of subarrays whose left end is \\(x_0+1\\) or greater, and right end is \\(x_1-1\\) or less, plus subarrays whose left end is \\(x_1+1\\) or greater, and right end is \\(x_2-1\\) or less, and so on. This can be evaluated in \\(\\mathrm{O}(C_i)\\) time. Hence, the problem has been solved.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n---\n**Problem Statement**\n\nYou are given a directed graph with \\( N \\) vertices and \\( M \\) edges. The \\( j \\)-th directed edge goes from vertex \\( u_j \\) to vertex \\( v_j \\) and has a weight of \\( w_j \\).\n\nFind one way to assign an integer between \\(-10^{18}\\) and \\(10^{18}\\), inclusive, to each vertex such that the following condition is satisfied:\n\n- Let \\( x_i \\) be the value assigned to vertex \\( i \\). For all edges \\( j = 1, 2, \\dots, M \\), it holds that \\( x_{v_j} - x_{u_j} = w_j \\).\n\nIt is guaranteed that at least one such assignment exists for the given input.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq \\min\\{2 \\times 10^5, \\frac{N(N-1)}{2}\\} \\)\n- \\( 1 \\leq u_j, v_j \\leq N \\)\n- \\( u_j \\neq v_j \\)\n- If \\( i \\neq j \\), then \\( (u_i, v_i) \\neq (u_j, v_j) \\) and \\( (u_i, v_i) \\neq (v_j, u_j) \\)\n- \\( |w_j| \\leq 10^9 \\)\n- All input values are integers.\n- There exists at least one assignment satisfying the conditions.\n\n**Input**\n\nThe input is given in the following format:\n\n```\nN M\nu_1 v_1 w_1\nu_2 v_2 w_2\n\u22ee\nu_M v_M w_M\n```\n\n**Output**\n\nLet \\( x_i \\) be the integer written on vertex \\( i \\). Print \\( x_1, x_2, \\dots, x_N \\) in this order, separated by spaces, on a single line. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n\n```\n3 3\n1 2 2\n3 2 3\n1 3 -1\n```\n\n**Sample Output 1**\n\n```\n3 5 2\n```\n\nBy setting \\( x = (3, 5, 2) \\), we have \\( x_2 - x_1 = w_1 = 2 \\), \\( x_2 - x_3 = w_2 = 3 \\), \\( x_3 - x_1 = w_3 = -1 \\), satisfying the conditions. For example, \\( x = (-1, 1, -2) \\) is also a valid answer.\n\n**Sample Input 2**\n\n```\n4 2\n2 1 5\n3 4 -3\n```\n\n**Sample Output 2**\n\n```\n5 0 6 3\n```\n\nFor example, \\( x = (0, -5, 4, 1) \\) and \\( x = (5, 0, 4, 1) \\) are also valid answers.\n\n**Sample Input 3**\n\n```\n5 7\n2 1 18169343\n3 1 307110901\n4 1 130955934\n2 3 -288941558\n2 5 96267410\n5 3 -385208968\n4 3 -176154967\n```\n\n**Sample Output 3**\n\n```\n200401298 182231955 -106709603 69445364 278499365\n```\n\nSolution:\n\n```python\n        For each connected component of the graph, once the value to be written on any vertex in it is fixed, all the values to be written are uniquely determined. This is because, once you determine the value for a vertex, the value for adjacent vertices is also determined in a chain. Thus, the problem can be solved by inspecting vertices one by one, and if the current vertex does not have a value assigned, set an arbitrary value (like 0) to it and determine the values for all the other connected vertices. This kind of process can be implemented as a Depth-First Search (DFS) or Breadth-First Search (BFS). The time complexity is \\(O(N+M)\\).\n\n```python\n# Read the input\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, w))\n    G[v].append((u, -w))\n\nvisited = [False] * N  # Whether the values are determined\nans = [0] * N  # The values to write\nfor i in range(N):\n    # Skip if the value is already determined\n    if visited[i]:\n        continue\n    # Set the value for vertex i to 0, and start searching\n    st = [i]\n    visited[i] = True\n    while st:\n        # Currently at vertex u\n        u = st.pop()\n        # Inspect vertex v adjacent to vertex u\n        for v, w in G[u]:\n            if not visited[v]:\n                # If the value for vertex v is undetermined, determine the value so that it is consistent with that for vertex u\n                visited[v] = True\n                ans[v] = ans[u] + w\n                st.append(v)\nprint(*ans)\n```\n```\n \n\n", "problem_ids": ["abc371_e", "abc366_e", "abc373_d"]}, "abc318_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nA real number \\( X \\) is given to the third decimal place. Print the real number \\( X \\) under the following conditions:\n\n- The decimal part must not have trailing zeros.\n- There must not be an unnecessary trailing decimal point.\n\n**Constraints**\n\n- \\( 0 \\le X < 100 \\)\n- \\( X \\) is given to the third decimal place.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nX\n```\n\n**Output**\n\nOutput the answer.\n\n**Sample Input 1**\n```\n1.012\n```\n\n**Sample Output 1**\n```\n1.012\n```\n\nExplanation: `1.012` can be printed as it is.\n\n**Sample Input 2**\n```\n12.340\n```\n\n**Sample Output 2**\n```\n12.34\n```\n\nExplanation: Printing `12.340` without the trailing zero results in `12.34`.\n\n**Sample Input 3**\n```\n99.900\n```\n\n**Sample Output 3**\n```\n99.9\n```\n\nExplanation: Printing `99.900` without the trailing zeros results in `99.9`.\n\n**Sample Input 4**\n```\n0.000\n```\n\n**Sample Output 4**\n```\n0\n```\n\nExplanation: Printing `0.000` without trailing zeros or an unnecessary decimal point results in `0`.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 367\n\nB - Cut .0 Editorial\n\nSolution 1: In C++, receive \\(X\\) as a double and print it. This avoids trailing zeros without specifying a format. Other languages might share this feature.\n\nSample code (Python3):\n```python\nx = float(input())\nprint(x)\n```\n\nSolution 2: Treat as a string problem. Receive \\(X\\) as a string, remove trailing zeros, and then remove a trailing '.' if present. The input ensures a decimal point, so trailing zeros are in the decimal part.\n\nSample code (Python3):\n```python\nx = input()\nwhile x[-1] == '0':\n    x = x[:-1]\nif x[-1] == '.':\n    x = x[:-1]\nprint(x)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nTakahashi and Aoki are playing a game using \\(N\\) cards. The front side of the \\(i\\)-th card has \\(A_i\\) written on it, and the back side has \\(B_i\\) written on it. Initially, the \\(N\\) cards are laid out on the table. With Takahashi going first, the two players take turns performing the following operation:\n\n- Choose a pair of cards from the table such that either the numbers on their front sides are the same or the numbers on their back sides are the same, and remove these two cards from the table. If no such pair of cards exists, the player cannot perform the operation.\n\nThe player who is first to be unable to perform the operation loses, and the other player wins. Determine who wins if both players play optimally.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 18\\)\n- \\(1 \\leq A_i, B_i \\leq 10^9\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\n```\n\n**Output:**\n\nPrint `Takahashi` if Takahashi wins when both players play optimally, and `Aoki` otherwise.\n\n**Sample Input 1:**\n```\n5\n1 9\n2 5\n4 9\n1 4\n2 5\n```\n\n**Sample Output 1:**\n```\nAoki\n```\n\nIf Takahashi first removes:\n- the first and third cards: Aoki can win by removing the second and fifth cards.\n- the first and fourth cards: Aoki can win by removing the second and fifth cards.\n- the second and fifth cards: Aoki can win by removing the first and third cards.\n\nThese are the only three pairs of cards Takahashi can remove in his first move, and Aoki can win in all cases. Therefore, the answer is Aoki.\n\n**Sample Input 2:**\n```\n9\n3 2\n1 7\n4 1\n1 8\n5 2\n9 8\n2 1\n6 8\n5 2\n```\n\n**Sample Output 2:**\n```\nTakahashi\n```\n\nSolution:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nE - Remove Pairs Editorial by en_translator\n\nThere are \\(2^{N}\\) possible sets of cards on the table. It is sufficient to determine for each of them whether the first or second player will win if these cards are on the table right before the first player makes a move. This can be solved with a technique called bit DP. Let \\(dp[S]\\) = true if the first player will win if the cards in \\(S\\) are on the table right before the first player makes a move, and false otherwise. The transitions are as follows:\n\nFor a set \\(S\\) of cards, if \\(dp[S \\setminus \\{i,j\\}]\\) is false for some pair \\(i,j \\in S\\) such that \\(A_i=A_j\\) or \\(B_i=B_j\\), then \\(dp[S]\\) is true; otherwise, it is false.\n\nThe final answer is Takahashi if \\(dp[S]\\) for \\(S=\\{1,2,\\ldots,N\\}\\) is true, and Aoki otherwise. The number of states is \\(O(2^{N})\\) and each transition costs \\(O(N^{2})\\) time, so the total complexity is \\(O(2^{N} N^{2})\\), which is fast enough.\n\nSample code (Python):\n```python\ndef main():\n    n = int(input())\n    a = [0] * n\n    b = [0] * n\n    for i in range(n):\n        a[i], b[i] = map(int, input().split())\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n    for i in range(1, 1 << n):\n        f = False\n        for j in range(n):\n            for k in range(j + 1, n):\n                if (i >> j) & 1 and (i >> k) & 1:\n                    if (a[j] == a[k] or b[j] == b[k]) and dp[i ^ (1 << j) ^ (1 << k)] == 0:\n                        f = True\n        dp[i] = f\n    print(\"Takahashi\" if dp[-1] else \"Aoki\")\n\nmain()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 600 points\n\nProblem Statement:\nThere are \\(N\\) stones placed on a 2-dimensional plane. The \\(i\\)-th stone is located at coordinates \\((X_i, Y_i)\\). All stones are located at lattice points in the first quadrant (including the axes).\n\nCount the number of lattice points \\((x, y)\\) where no stone is placed and it is **impossible** to reach \\((-1, -1)\\) from \\((x, y)\\) by repeatedly moving up, down, left, or right by 1 without passing through coordinates where a stone is placed.\n\nMore precisely, count the number of lattice points \\((x, y)\\) where no stone is placed, and there does **not** exist a finite sequence of integer pairs \\((x_0, y_0), \\ldots, (x_k, y_k)\\) that satisfies all of the following four conditions:\n1. \\((x_0, y_0) = (x, y)\\).\n2. \\((x_k, y_k) = (-1, -1)\\).\n3. \\(|x_i - x_{i+1}| + |y_i - y_{i+1}| = 1\\) for all \\(0 \\leq i < k\\).\n4. There is no stone at \\((x_i, y_i)\\) for all \\(0 \\leq i \\leq k\\).\n\nConstraints:\n- \\(0 \\leq N \\leq 2 \\times 10^5\\)\n- \\(0 \\leq X_i, Y_i \\leq 2 \\times 10^5\\)\n- The pairs \\((X_i, Y_i)\\) are distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nX_1 Y_1\n\\vdots\nX_N Y_N\n```\n\nOutput:\nPrint the number of lattice points that satisfy the conditions.\n\nSample Input 1:\n```\n5\n1 0\n0 1\n2 3\n1 2\n2 1\n```\n\nSample Output 1:\n```\n1\n```\nIt is impossible to reach \\((-1, -1)\\) from \\((1, 1)\\).\n\nSample Input 2:\n```\n0\n```\n\nSample Output 2:\n```\n0\n```\nThere may be cases where no stones are placed.\n\nSample Input 3:\n```\n22\n0 1\n0 2\n0 3\n1 0\n1 4\n2 0\n2 2\n2 4\n3 0\n3 1\n3 2\n3 4\n5 1\n5 2\n5 3\n6 0\n6 4\n7 0\n7 4\n8 1\n8 2\n8 3\n```\n\nSample Output 3:\n```\n6\n```\nThere are six such points: \\((6, 1), (6, 2), (6, 3), (7, 1), (7, 2), (7, 3)\\).\n\nSolution:\n\n```python\n'''\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nG - Go Territory Editorial by en_translator\n\nWe will consider a grid instead of a coordinate plane. We call those cells reachable to (-1,-1) \u201cinside,\u201d \nand unreachable \u201coutside.\u201d We first consider the case where the stones are connected in eight directions. \nBy enumerating eight cells around each cell beforehand, one can easily determine if these cells are inside or \noutside easily with BFS (Breadth First Search). The top-left cell is always outside; by performing BFS from this cell \nin four directions, one can reach all cells outside.\n\nExample: black cells represent lattice points with stones. Then, inspect each row. If there is a segment with \n\u201coutside stone inside \u2026 inside stone outside,\u201d then that segment can be counted as \u201cinside\u201d to count \u201cinside\u201d points. \nBeware of cases with consecutive stones, or stones between inside cells.\n\nNow we consider disconnected cases. It may seem we can consider each connected component independently, \nbut note that there may be a nested structure. After performing BFS for each connected component and determining whether \neach cell is outside or inside, when scanning the entire row, there may be parts like \n\u201coutside stone inside \u2026\u2026 outside stone inside \u2026\u2026 inside stone outside \u2026\u2026 inside stone outside,\u201d where some cells \ninside are labeled outside.\n\nEvery time you encounter \u201coutside, one or more stones, inside,\u201d the nest increases by one; for \n\u201cinside, one or more stones, outside,\u201d it decreases by one. By using this method to manage how many times the current \nposition is surrounded, one can handle this issue. Also, if there are different connected components sufficiently close \nto each other, the label (outside/inside) might be overwritten. This can be avoided by defining that stones are connected \nif the Chebyshev distance is two or less, instead of being eight-adjacent.\n'''\n```\n\n \n\n", "problem_ids": ["abc367_b", "abc354_e", "abc361_g"]}, "abc319_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAn undirected graph with numbered vertices is called a **good graph** if it has a spanning tree \\( T \\) that satisfies the following condition: For every edge \\( (u, v) \\) (\\( u < v \\)) in the graph, the minimum and maximum vertex numbers on the unique simple path connecting vertices \\( u \\) and \\( v \\) in \\( T \\) are \\( u \\) and \\( v \\), respectively.\n\nYou are given a simple connected undirected graph \\( G \\) with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). The graph \\( G \\) has \\( M \\) edges, and the \\( i \\)-th edge connects vertices \\( A_i \\) and \\( B_i \\) (\\( A_i < B_i \\)).\n\nFor each \\( i = 1, 2, \\dots, M \\), determine whether the graph obtained by removing the \\( i \\)-th edge from \\( G \\) is a **good graph**.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- All input values are integers.\n- The given graph is a simple connected undirected graph.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\n**Output**\n\nPrint \\( M \\) lines. The \\( i \\)-th line should contain `Yes` if the graph obtained by removing the \\( i \\)-th edge from \\( G \\) is a **good graph**, and `No` otherwise.\n\n**Sample Input 1**\n\n```\n6 9\n1 3\n1 5\n2 5\n2 6\n3 4\n3 5\n3 6\n4 6\n5 6\n```\n\n**Sample Output 1**\n\n```\nNo\nNo\nNo\nNo\nYes\nNo\nNo\nYes\nYes\n```\n\nConsider the case where edge \\( (4, 6) \\) is removed. A spanning tree formed by edges \\( (1, 3), (2, 5), (3, 4), (3, 5), (5, 6) \\) satisfies the condition. For example, for edge \\( (3, 6) \\), the simple path connecting vertices \\( 3 \\) and \\( 6 \\) traverses vertices \\( 3, 5, 6 \\) in this order, and the minimum and maximum vertex numbers on the path are \\( 3 \\) and \\( 6 \\), respectively, thus satisfying the condition. By verifying the other edges similarly, it can be seen that this spanning tree satisfies the condition, so the answer is `Yes`.\n\nOn the other hand, consider the case where edge \\( (1, 5) \\) is removed. The same spanning tree does not satisfy the condition. For edge \\( (4, 6) \\), the simple path connecting vertices \\( 4 \\) and \\( 6 \\) traverses vertices \\( 4, 3, 5, 6 \\) in this order, and the minimum and maximum vertex numbers on the path are \\( 3 \\) and \\( 6 \\), respectively, thus not satisfying the condition. It can also be shown that no other spanning tree satisfies the condition, so the answer is `No`.\n\n**Sample Input 2**\n\n```\n5 4\n1 2\n2 3\n3 4\n4 5\n```\n\n**Sample Output 2**\n\n```\nNo\nNo\nNo\nNo\n```\n\nRemoving an edge may disconnect the graph.\n\n**Sample Input 3**\n\n```\n15 20\n12 13\n7 8\n5 7\n8 10\n9 12\n4 5\n11 12\n2 4\n6 8\n4 14\n1 2\n14 15\n2 9\n3 8\n2 15\n10 11\n13 14\n8 9\n7 14\n5 13\n```\n\n**Sample Output 3**\n\n```\nNo\nNo\nNo\nYes\nYes\nNo\nYes\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nYes\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 181\n\nE - Min and Max at the edge Editorial by evima\n\nThe spanning tree that possesses the properties described in the conditions for a good graph will be referred to as a \u201cgood spanning tree.\u201d First, let\u2019s consider how to determine the existence of a good spanning tree for a fixed graph. If a good spanning tree exists, when we define the cost of an edge \\( (u,v) \\) as \\(|X_u - X_v|\\) using a strictly increasing sequence \\(X\\), the good spanning tree will be one of the minimum spanning trees. This follows from Kruskal's algorithm and the fact that for an edge \\( (u,v) \\) not included in the good spanning tree, the cost of the edges on the simple path connecting \\(u\\) and \\(v\\) will be less than \\(|X_u - X_v|\\). Specifically, if we consider setting \\(X_u = 10^u\\) or \\(-10^{N-u}\\), the costs of each edge will be distinct, so the minimum spanning tree will be uniquely determined. The good spanning tree will be equal to both of the following:\n\n1. The minimum spanning tree \\(T_1\\) when the cost of edge \\((u,v)\\) is \\((N+1)v - u\\)\n2. The minimum spanning tree \\(T_2\\) when the cost of edge \\((u,v)\\) is \\((N+1)(N+1-u) - (N+1-v)\\)\n\nTherefore, for a good spanning tree to exist, it is necessary that \\(T_1 = T_2\\). Conversely, in \\(T_1\\), for an edge \\((u,v)\\), the maximum vertex number on the simple path connecting \\(u\\) and \\(v\\) must be \\(v\\). In \\(T_2\\), for an edge \\((u,v)\\), the minimum vertex number on the simple path connecting \\(u\\) and \\(v\\) must be \\(u\\). Thus, the above conditions are also sufficient. From the above, the existence of a good spanning tree can be determined by finding \\(T_1\\) and \\(T_2\\) and checking if they are identical. Then, to determine the existence of a good spanning tree when each edge is removed, we can find the changes in the minimum spanning tree when the edge is removed and check for identicalness.\n\nFor the minimum spanning tree \\(T\\) of graph \\(G\\), the minimum spanning tree \\(T_{u,v}\\) of the graph obtained by removing edge \\((u,v)\\) can be obtained by the following steps:\n- If \\((u,v)\\) is not included in \\(T\\), then \\(T_{u,v} = T\\).\n- Otherwise, remove \\((u,v)\\) from \\(T\\). As a result, \\(T\\) will be divided into two connected components. Among the edges that span the two connected components, add the one with the minimum cost to \\(T\\) to obtain the tree \\(T_{u,v}\\).\n\nTherefore, we need to solve the following problem:\n\n1. For each edge \\(e\\) in the minimum spanning tree \\(T\\) of graph \\(G\\), initialize a variable \\(X_e\\) to \\(\\infty\\).\n2. For each edge \\((u,v)\\) in graph \\(G\\) that is not included in \\(T\\), update \\(X_e \\leftarrow \\min(X_e, C_{u,v})\\) (where \\(C_{u,v}\\) is the cost of edge \\((u,v)\\)) for each edge \\(e\\) included in the simple path connecting \\(u\\) and \\(v\\) in \\(T\\), and find the final values of \\(X_e\\).\n\nThis can be processed in \\(O(M \\log N)\\) time by handling range chmin queries with a segment tree while performing a DFS. Alternatively, by decomposing the tree into heavy and light paths and arranging the heavy paths, it can be converted into \\(O(\\log N)\\) range chmin queries, allowing it to be processed in \\(O(M \\log^2 N)\\) time, which is also sufficient.\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of the characters 'A' and 'B'. For a string \\( X \\) of length \\( N \\) consisting of the characters '1', '2', and '3', the score is determined by the following procedure:\n\n1. Initialize the variables \\( h_1, h_2, h_3, P \\) to 0.\n\n2. For \\( i = 1, 2, \\dots, N \\) in this order, perform the following operations:\n   - If the \\( i \\)-th character of \\( S \\) is 'A', perform operation A; if it is 'B', perform operation B. Let \\( d \\) be the number represented by the \\( i \\)-th character of \\( X \\).\n   - **Operation A:** Add 2 to \\( h_d \\).\n   - **Operation B:** If \\( d = 2 \\) or \\( h_d \\neq h_2 \\), set \\( P \\) to \\(-10^{100}\\). Otherwise, add 1 to both \\( h_d \\) and \\( h_2 \\).\n\n3. If \\( h_1 = h_2 = h_3 \\), add 1 to \\( P \\).\n\nThe final value of \\( P \\) is the score.\n\nPrint one string \\( X \\) that maximizes the score. You have \\( T \\) test cases to solve.\n\n**Constraints:**\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N \\leq 10^6 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of 'A' and 'B'.\n- \\( T \\) and \\( N \\) are integers.\n- The sum of \\( N \\) across all test cases is at most \\( 10^6 \\).\n\n**Input:**\nThe input is given from Standard Input in the following format. Here, \\(\\mathrm{test}_i\\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{test}_1\n\\mathrm{test}_2\n\\vdots\n\\mathrm{test}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nS\n```\n\n**Output:**\nPrint \\( T \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq T \\)) should contain a string \\( X \\) that maximizes the score for the \\( i \\)-th test case. If multiple strings \\( X \\) maximize the score, any of them is considered correct.\n\n**Sample Input 1:**\n```\n5\n4\nABBA\n5\nAAAAA\n6\nBBBBBB\n7\nABABABA\n20\nAAABBBBBBBBAAABBBABA\n```\n\n**Sample Output 1:**\n```\n1333\n12321\n333333\n1313212\n33311111133121111311\n```\n\nLet us describe the changes in \\((h_1, h_2, h_3, P)\\) as we proceed with \\( i = 1, 2, \\dots, N \\).\n\n- For the first test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,1,1,0) \\rightarrow (2,2,2,1) \\rightarrow (2,2,4,1)\\). The maximum score is 1.\n- For the second test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,2,0,0) \\rightarrow (2,2,2,1) \\rightarrow (2,4,2,1) \\rightarrow (4,4,2,1)\\). The maximum score is 1.\n\nFor the third, fourth, and fifth test cases, the maximum scores are 0, 0, and 2, respectively. There may be multiple strings \\( X \\) that maximize the score, but you only need to print one of them.\n\nSolution:\n\n[BEGIN TEXT]\nHere is a concise version of the provided text:\n\n---\n\n**F - All the Same Editorial by evima**\n\n**Observations on the Problem:**  \nThe problem can be visualized as a Tetris game with dominoes on a field width of 3, where dominoes cannot be rotated and there must be no gaps below horizontally placed dominoes. The score increases when all pieces are cleared. Flattening occurs when \\( h_1 = h_2 = h_3 \\).\n\n**Characteristics of \\( S \\):**  \nFor \\( i=0,1,\\ldots,N \\), let \\( a_i \\) be the number of As and \\( b_i \\) the number of Bs. The sequence can be flattened under the following conditions:\n- \\( a_i + b_i \\equiv 0 \\mod 3 \\)\n- \\( b_i \\equiv 0 \\mod 2 \\)\n- \\( b_i \\le 2a_i \\)\n\nDefining \\( V_i = 2a_i - b_i \\) gives:\n\\[ V_i \\ge 0, \\ V_i \\equiv 0 \\mod 6 \\]\nThese conditions are both necessary and sufficient for flattening.\n\n**Maximizing the Score:**  \nFind the longest non-decreasing subsequence \\( (V_{i_0}, V_{i_1}, \\ldots, V_{i_k}) \\) with:\n- \\( i_0 = 0 \\)\n- \\( V_{i_j} \\equiv 0 \\mod 6 \\)\n- \\( V_{i_j} \\le V_{i_{j+1}} \\)\n\nThis can be solved in \\( O(N \\log N) \\) time. \n\n**Constructing the Operation Sequence:**  \nDefine \\( T_j \\) as the substring of \\( S \\) from \\( (V_{i_j}+1) \\)-th to \\( V_{i_{j+1}} \\)-th character. Construct an operation sequence \\( X \\) for \\( S \\):\n- \\( A \\to 1 \\) (vertical domino)\n- \\( B \\to 3 \\) (horizontal domino)\n\nAdjust for \\( V_N \\ge 6 \\) by aligning extra vertical dominoes. Execute the basic idea when \\( V_N = 0 \\). Handle \\( V_i \\) conditions to reduce \\( V_N \\).\n\n**Summary:**  \n1. Compute \\( V \\) and solve the longest non-decreasing subsequence problem.\n2. For divided substrings, use the basic idea and reductions.\n\nThe solution operates in \\( O(|S|\\log |S|) \\) time per test case.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 100 points\n\n**Problem Statement**\n\nTakahashi is planning to eat \\( N \\) dishes. \n- The \\( i \\)-th dish he plans to eat is sweet if \\( S_i = \\text{sweet} \\), and salty if \\( S_i = \\text{salty} \\). \n- If he eats two sweet dishes consecutively, he will feel sick and be unable to eat any more dishes. \n\nDetermine whether he can eat all the dishes.\n\n**Constraints**\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is either \\text{sweet} or \\text{salty}.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nS_1\nS_2\n...\nS_N\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can eat all the dishes, and `No` otherwise.\n\n**Sample Input 1**\n```\n5\nsalty\nsweet\nsalty\nsalty\nsweet\n```\n\n**Sample Output 1**\n```\nYes\n```\n*Takahashi will not eat two sweet dishes consecutively, so he can eat all the dishes without feeling sick.*\n\n**Sample Input 2**\n```\n4\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 2**\n```\nYes\n```\n*He will feel sick but can still eat all the dishes.*\n\n**Sample Input 3**\n```\n6\nsalty\nsweet\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 3**\n```\nNo\n```\n*He feels sick when eating the 3rd dish and cannot eat the 4th and subsequent dishes.*\n\nSolution:\n\n        [BEGIN TEXT]\n        Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nIf there exists an integer \\(i\\) between \\(1\\) and \\((N-2)\\) such that the \\(i\\)-th and \\((i+1)\\)-th dishes to eat are both sweet, he cannot eat the \\((i+2)\\)-th dish and cannot eat all of the dishes. Otherwise, he does not get sick until eating the last dish, so he can eat all the dishes. Note that indices start from \\(0\\) in the following sample code.\n\n```python\nn = int(input())\ns = [input().strip() for _ in range(n)]\nans = \"Yes\"\nfor i in range(n - 2):\n    if s[i] == \"sweet\" and s[i + 1] == \"sweet\":\n        ans = \"No\"\nprint(ans)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["arc181_e", "arc179_f", "abc364_a"]}, "abc319_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally.\n\nInitially, all vertices are painted white.\n\nTo efficiently visit all vertices of this tree, Alice has invented a magical gate. She uses one piece and one gate to travel according to the following procedure.\n\nFirst, she chooses a vertex and places both the piece and the gate on that vertex. Then, she repeatedly performs the following operations until all vertices are painted black.\n\nChoose one of the following actions:\n\n1. Paint the vertex where the piece is placed black.\n2. Choose a vertex adjacent to the vertex where the piece is placed and move the piece to that vertex. The cost of this action is 1.\n3. Move the piece to the vertex where the gate is placed.\n4. Move the gate to the vertex where the piece is placed.\n\nNote that only the second action incurs a cost.\n\nIt can be proved that it is possible to paint all vertices black in a finite number of operations. Find the minimum total cost required.\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- The given graph is a tree.\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nu_1 v_1\n\\vdots\nu_{N-1} v_{N-1}\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n4\n1 2\n1 3\n1 4\n```\n\n**Sample Output 1:**\n```\n3\n```\n\nHere is an example of Alice's procedure. Let \\((u, v)\\) denote the state where the piece is at vertex \\( u \\) and the gate is at vertex \\( v \\).\n\n- Place the piece and the gate at vertex 4.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 1.\n  - Vertex 4 is painted black.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 2 and move the piece to vertex 1.\n  - This costs 1.\n  - The state is now \\((1, 4)\\).\n\n- Perform action 1.\n  - Vertex 1 is painted black.\n\n- Perform action 4.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 2.\n  - This costs 1.\n  - The state is now \\((2, 1)\\).\n\n- Perform action 1.\n  - Vertex 2 is painted black.\n\n- Perform action 3.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 3.\n  - This costs 1.\n  - The state is now \\((3, 1)\\).\n\n- Perform action 1.\n  - Vertex 3 is painted black.\n  - All vertices are now painted black, so the procedure ends.\n\nThe total cost of performing action 2 is 3, and there is no procedure with a smaller cost.\n\n**Sample Input 2:**\n```\n10\n1 7\n7 10\n10 8\n8 3\n8 4\n10 9\n9 6\n9 5\n7 2\n```\n\n**Sample Output 2:**\n```\n10\n```\n\nSolution:\n\n```\nHere is the cleaned version:\n\nEditorial - AtCoder Regular Contest 179\n\nD - Portable Gate Editorial by evima\n\nWhen moving the gate, it can be considered to move simultaneously with the piece. We will perform operation 1 as needed and consider the following operations:\n\nOperation A: When the piece and the gate are on the same vertex, move both the piece and the gate to an adjacent vertex. Operation B: Move the piece to an adjacent vertex. Operation C: Move the piece to the vertex where the gate is located.\n\nOperations A and B each incur a cost of 1. Once operation B is performed, the gate remains in its position until operation C is performed. It's inefficient to move the piece to the gate using operation B, so we will not consider this.\n\nLet \\(v\\) be the initial position of the piece and gate. By performing operation C at the end, the process ends when the piece and the gate are on the same vertex. Label the vertices and edges the gate moves to with A, and the rest with B. The vertices and edges labeled A form a connected subgraph, or subtree A. Vertex \\(v\\) is included in subtree A. Edges labeled B with one endpoint as A are boundary edges.\n\nVertices and edges labeled B not connected to boundary edges form connected components. Each component is a tree connected to a vertex in subtree A by a boundary edge \\(e_i\\). Let them form subtree \\(B_i\\), connected to vertex \\(l_i\\) in A.\n\nKey points:\n\n1. In optimal operations, assume edges labeled A are not traversed by operation B. By rearranging operations, the cost does not increase:\n\n   - The piece and gate start from \\(v\\), visit all vertices in A using operation A, and return to \\(v\\). This is the journey in A.\n   - If \\(l_i\\) is visited during A's journey, it's interrupted. The piece starts from \\(l_i\\), visits all vertices in \\(B_i\\) using operation B, and returns to \\(l_i\\). This is the journey in \\(B_i\\). The gate stays at \\(l_i\\).\n\n2. Assume moving along boundary edge \\(e_i\\) occurs only once in B's journey. If done more than once, moving with the gate using operation A during the first move and returning does not increase the cost. In \\(B_i\\)'s journey, operation C is done once at the end.\n\n3. In the journeys of A and \\(B_i\\), the farthest vertex is visited last. If the distance from start to the farthest vertex is \\(d\\) and the number of edges is \\(m\\), the cost is \\(2m - d\\).\n\nThe total number of edges in subtrees is \\(N-1\\). Minimize cost by maximizing \\(d\\)'s total sum. Calculate for fixed \\(v\\) using tree DP. Maintain:\n\n- Maximum distance to vertex where \\(B_i\\)'s journey ends, assuming \\(u = l_i\\).\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex in \\(u\\)'s subtree.\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex not in \\(u\\)'s subtree.\n\nExtend to rerooting DP to examine all possible starting vertices. Time complexity \\(\\mathrm{O}(N)\\).\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). For each \\( t = 1, 2, \\dots, N \\), determine whether \\( A_t \\) is included in a longest increasing subsequence of \\( A \\).\n\nHere, \\( A_t \\) is included in a longest increasing subsequence of \\( A \\) if and only if the following holds:\n- Let \\( L \\) be the length of a longest increasing subsequence of \\( A \\). There exists a strictly increasing integer sequence \\( i = (i_1, i_2, \\dots, i_L) \\ (i_1 < i_2 < \\dots < i_L) \\), where each element is between \\( 1 \\) and \\( N \\), inclusive, that satisfies all of the following conditions:\n  - \\( A_{i_1} < A_{i_2} < \\dots < A_{i_L} \\).\n  - \\( i_k = t \\) for some \\( k \\ (1 \\leq k \\leq L) \\).\n\nYou are given \\( T \\) test cases; solve each of them.\n\n**What is a longest increasing subsequence?**\n- A subsequence of a sequence \\( A \\) is a sequence that can be derived by extracting some elements from \\( A \\) without changing the order.\n- A longest increasing subsequence of a sequence \\( A \\) is a subsequence of \\( A \\) that is strictly increasing with the greatest possible length.\n\n**Constraints**\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) across all test cases is at most \\( 2 \\times 10^5 \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\nHere, \\(\\mathrm{case}_i\\) represents the input for the \\(i\\)-th case. Each case is given in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\nPrint the answers in the following format:\n```\n\\mathrm{answer}_1\n\\mathrm{answer}_2\n\\vdots\n\\mathrm{answer}_T\n```\nHere, \\(\\mathrm{answer}_i\\) represents the output for the \\(i\\)-th case. For each case, let there be \\( m \\) indices \\( t \\) such that \\( A_t \\) is included in a longest increasing subsequence of \\( A \\), which are \\( i_1, i_2, \\dots, i_m \\) in ascending order. Print these in the following format:\n```\nm\ni_1 i_2 \\cdots i_m\n```\n\n**Sample Input 1**\n```\n1\n5\n2 1 4 5 3\n```\n\n**Sample Output 1**\n```\n4\n1 2 3 4\n```\nOne of the longest increasing subsequences is \\( (2, 4, 5) \\), with a length of 3. Another longest increasing subsequence is \\( (1, 4, 5) \\). However, no longest increasing subsequence includes \\( A_5 \\). Therefore, print \\( 1, 2, 3, 4 \\).\n\n**Sample Input 2**\n```\n2\n6\n2 5 3 4 3 4\n5\n10000 1000 100 1 10\n```\n\n**Sample Output 2**\n```\n5\n1 3 4 5 6\n2\n4 5\n```\n\nSolution:\n\n```\nEditorial - Useless for LIS\n\nGiven a sequence \\( A \\), its Longest Increasing Sequence (LIS) can be found as follows: Apply coordinate compression to assume \\( 1 \\leq A_i \\leq N \\). Use Dynamic Programming (DP) with `dp[i][j]` representing the length of a LIS chosen from the first \\( i \\) elements with the last element \\( j \\). Initialize `dp[0][0] = 0` and `dp[0][1] = dp[0][2] = ... = dp[0][N] = -float('inf')`. The transitions for \\( i = 1, 2, ..., N \\) are:\n\n1. `dp[i][j] = max(dp[i - 1][k] + 1 for k in range(j))` for `j = A[i]`.\n2. `dp[i][j] = dp[i - 1][j]` for `j != A[i]`.\n\nThe length of a LIS is `max(dp[N][k] for k in range(N + 1))`. It is possible to reconstruct a LIS. The complexity can be reduced to \\(O(N \\log N)\\) using a segment tree.\n\nThe DP can be efficiently implemented using pseudocode and a segment tree for segment-max retrieval, which allows LIS length to be obtained in \\(O(N \\log N)\\). Furthermore, by considering constrained LIS lengths `l_i` and `r_i`, and checking if `l_i + r_i - 1 = L`, where `L` is the LIS length, we can address this problem. `l` is found by memorizing DP results, and `r` by reversing the array and applying the same algorithm.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two strings, \\( S \\) and \\( T \\), consisting of lowercase English letters. Determine if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the following condition is satisfied. Here, \\( |S| \\) denotes the length of the string \\( S \\). Note that \\( w \\) must be less than \\( |S| \\).\n\n- If \\( S \\) is split at every \\( w \\) characters from the beginning, the concatenation of the \\( c \\)-th characters of the substrings of length at least \\( c \\) in order equals \\( T \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters.\n- \\( 1 \\leq |T| \\leq |S| \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nPrint `Yes` if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the condition is satisfied, and `No` otherwise.\n\n**Sample Input 1**\n```\natcoder toe\n```\n\n**Sample Output 1**\n```\nYes\n```\n\nExplanation: If \\( S \\) is split at every two characters, it looks like this:\n```\nat\nco\nde\nr\n```\nThen, the concatenation of the 2nd characters of the substrings of length at least 2 is `toe`, which equals \\( T \\). Thus, print `Yes`.\n\n**Sample Input 2**\n```\nbeginner r\n```\n\n**Sample Output 2**\n```\nNo\n```\n\nExplanation: \\( w = |S| \\) is not allowed, and no pair of integers \\( 1 \\leq c \\leq w < |S| \\) satisfies the condition. Thus, print `No`.\n\n**Sample Input 3**\n```\nverticalreading agh\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        Below is a clean version of the text with only the relevant solution details:\n\nEnumerate all possible \\(c\\) and \\(w\\), and determine if a conforming pair \\(c,w\\) exists. One can construct a string for \\(c\\) and \\(w\\) using a for statement and concatenation of strings. For more details, please refer to the sample code.\n\nSample code (Python 3):\n\n```python\ndef main():\n    s = input().strip()\n    t = input().strip()\n    for w in range(1, len(s)):\n        for c in range(w):\n            now = \"\"\n            for i in range(c, len(s), w):\n                now += s[i]\n            if now == t:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["arc179_d", "abc354_f", "abc360_b"]}, "abc319_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou have an empty bag. You are given \\( Q \\) queries, which must be processed in order. There are three types of queries:\n\n1. `1 x`: Put one ball with the integer \\( x \\) written on it into the bag.\n2. `2 x`: Remove one ball with the integer \\( x \\) written on it from the bag and discard it. It is guaranteed that the bag has a ball with the integer \\( x \\) written on it when this query is given.\n3. `3`: Print the number of different integers written on the balls in the bag.\n\n**Constraints**\n\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq x \\leq 10^{6} \\)\n- When a query of the second type is given, the bag has a ball with the integer \\( x \\) written on it.\n- There is at least one query of the third type.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nQ\nquery_1\nquery_2\n\u22ee\nquery_Q\n```\n\nThe \\( i \\)-th query \\( \\text{query}_i \\) is given in one of the following three formats:\n\n```\n1 x\n2 x\n3\n```\n\n**Output**\n\nIf there are \\( K \\) queries of the third type, print \\( K \\) lines. The \\( i \\)-th line \\((1 \\leq i \\leq K)\\) should contain the answer to the \\( i \\)-th query of the third type.\n\n**Sample Input 1**\n\n```\n8\n1 3\n1 1\n1 4\n3\n2 1\n3\n1 5\n3\n```\n\n**Sample Output 1**\n\n```\n3\n2\n3\n```\n\n**Explanation**\n\nInitially, the bag is empty.\n- For the first query `1 3`, a ball with the integer 3 written on it enters the bag.\n- For the second query `1 1`, a ball with the integer 1 written on it enters the bag.\n- For the third query `1 4`, a ball with the integer 4 written on it enters the bag.\n- For the fourth query `3`, the bag has balls with the integers 1, 3, 4, so print 3.\n- For the fifth query `2 1`, a ball with the integer 1 written on it is removed from the bag.\n- For the sixth query `3`, the bag has balls with the integers 3, 4, so print 2.\n- For the seventh query `1 5`, a ball with the integer 5 written on it enters the bag.\n- For the eighth query `3`, the bag has balls with the integers 3, 4, 5, so print 3.\n\n**Sample Input 2**\n\n```\n8\n1 2\n1 2\n3\n2 2\n1 4\n1 4\n2 2\n3\n```\n\n**Sample Output 2**\n\n```\n1\n1\n```\n\nSolution:\n\n[BEGIN TEXT]\nLet us consider the properties of each operation, particularly the first and second types. Both operations can increase or decrease the number of distinct numbers in the bag by one. Specifically, adding a ball increases the count by one or zero, and removing a ball decreases the count by one or zero. To determine if each operation affects the count, we need to check how many balls with a specific integer are in the bag. On insertion, if the bag already contains a ball with that number, the distinct count does not increase; otherwise, it increases by one. Similarly, on removal, the change in count depends on the number of balls with that specific integer. Thus, to process the queries, keep track of the current number of distinct integers with an integer and the number of balls with each integer in an array of length \\(10^6\\). For more details, please refer to the sample code.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi eats three plates for breakfast: rice, miso soup, and salad. His table is long and narrow, so he arranged the three plates in a row. The arrangement is given by a string \\( S \\), where the \\( i \\)-th plate from the left is rice if \\( S_i \\) is \\( R \\), miso soup if \\( S_i \\) is \\( M \\), and salad if \\( S_i \\) is \\( S \\).\n\nDetermine whether the plate of rice is to the left of the plate of miso soup.\n\n**Constraints**\n\n- \\(|S| = 3\\)\n- \\( S \\) contains one \\( R \\), one \\( M \\), and one \\( S \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n**Output**\n\nPrint `Yes` if the plate of rice is to the left of the plate of miso soup, and `No` otherwise.\n\n**Sample Input 1**\n\n```\nRSM\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nThe plate of rice is at the 1st position from the left, and the plate of miso soup is at the 3rd position from the left. Since the plate of rice is to the left, print `Yes`.\n\n**Sample Input 2**\n\n```\nSMR\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nThe plates are arranged as salad, miso soup, and rice from left to right.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 360\n\nA - A Healthy Breakfast Editorial by en_translator\n\nFor beginners: If you are new to learning programming, please try \"Welcome to AtCoder\" from the practice contest. There you can find a sample code for each language. If you are not familiar with programming contests, try some problems in \"AtCoder Beginners Selection.\" \"C++\u5165\u9580 AtCoder Programming Guide for beginners (APG4b)\" is a C++ tutorial for competitive programmers (in Japanese).\n\nSolution: Prepare a string variable s. Read input into s. Use a for loop to determine positions of R and M in s. Let pos_r and pos_m be those indices. Use an if statement to print 'Yes' if pos_r < pos_m, otherwise print 'No'. With only six possible strings for \\(S\\), you can manually determine the answer using a conditional branch. Sample code in C++ provided.\n```\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n## Problem Statement\n\nThere is a grid with \\( N \\) rows and \\( N \\) columns. Let \\( (i, j) \\) \\((1 \\leq i \\leq N, 1 \\leq j \\leq N)\\) denote the cell at the \\( i \\)-th row from the top and the \\( j \\)-th column from the left. Each cell is initially painted red or blue, with cell \\( (i, j) \\) being red if \\( c_{i,j} = R \\) and blue if \\( c_{i,j} = B \\). You want to change the colors of some cells to purple so that the following two conditions are simultaneously satisfied:\n\n- **Condition 1:** You can move from cell \\( (1, 1) \\) to cell \\( (N, N) \\) by only passing through cells that are red or purple.\n- **Condition 2:** You can move from cell \\( (1, N) \\) to cell \\( (N, 1) \\) by only passing through cells that are blue or purple.\n\nHere, \"You can move\" means that you can reach the destination from the starting point by repeatedly moving to a horizontally or vertically adjacent cell of the relevant colors.\n\nWhat is the minimum number of cells that must be changed to purple to satisfy these conditions?\n\n## Constraints\n\n- \\( 3 \\leq N \\leq 500 \\)\n- Each \\( c_{i,j} \\) is \\( R \\) or \\( B \\).\n- \\( c_{1,1} \\) and \\( c_{N,N} \\) are \\( R \\).\n- \\( c_{1,N} \\) and \\( c_{N,1} \\) are \\( B \\).\n- \\( N \\) is an integer.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nc_{1,1}c_{1,2}\\cdots c_{1,N}\nc_{2,1}c_{2,2}\\cdots c_{2,N}\n\u22ee\nc_{N,1}c_{N,2}\\cdots c_{N,N}\n```\n\n## Output\n\nPrint the answer.\n\n## Sample Input 1\n\n```\n5\nRBRBB\nRBRRR\nRRRBR\nRBBRB\nBBRBR\n```\n\n## Sample Output 1\n\n```\n3\n```\n\nAs shown in the figure below, changing cells \\( (1, 3) \\), \\( (3, 2) \\), \\( (4, 5) \\) to purple satisfies the conditions.\n\n## Sample Input 2\n\n```\n5\nRBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBR\n```\n\n## Sample Output 2\n\n```\n7\n```\n\nAs shown in the figure below, changing cells \\( (1, 2) \\), \\( (2, 2) \\), \\( (2, 3) \\), \\( (3, 3) \\), \\( (3, 4) \\), \\( (4, 4) \\), \\( (4, 5) \\) to purple satisfies the conditions.\n\n## Sample Input 3\n\n```\n10\nRRBBBBBBBB\nBRRBBBBBBB\nBBRRBBBBBB\nBBBRRBBBBB\nBBBBRRBBBB\nBBBBBRRBBB\nBBBBBBRRBB\nBBBBBBBRRB\nBBBBBBBBRR\nBBBBBBBBBR\n```\n\n## Sample Output 3\n\n```\n2\n```\n\n## Sample Input 4\n\n```\n17\nRBBRRBRRRRRBBBBBB\nBBRBRBRRBRRBRRBBR\nBRBRBBBRBBRBBRBBB\nRBRRBBBBBBRRBRRRR\nRRRRRBRBRRRBBRBBR\nRRRRRBRRBRBBRRRBB\nBBBRRRBRBRBBRRRBB\nBBRRRBRBBBRBRRRBR\nRRBBBBBBBBBBBRBRR\nRRRBRRBRBRBRBRBBB\nRRBRRRRBRBRRBRBBR\nRRRBBRBRBBBRBBRBR\nBBRBBRRBRRRBBRBBB\nBBBRBRRRRRRRBBRBB\nRRRRRBRBRBBRRBRRR\nBRRRRBBBRRRBRRBBB\nBBRRBBRRRBBBRBBBR\n```\n\n## Sample Output 4\n\n```\n8\n```\n\nSolution:\n\n```python\n[BEGIN TEXT]\n**Editorial - AtCoder Regular Contest 177**\n\n**C - Routing Editorial by evima**\n\n**Step 1:** Consider solving the Sample Input 1 manually:  \nGrid:  \n5  \nRBRBB  \nRBRRR  \nRRRBR  \nRBBRB  \nBBRBR  \n\nThe problem involves these conditions:  \n1. Move from top-left to bottom-right only through red or purple cells.  \n2. Move from top-right to bottom-left only through blue or purple cells.  \n\nDivide the grid; red cells represent only the left side painted, and blue cells represent only the right side painted. Purple cells are where both sides are painted.\n\n**Operations:**  \n- Blue \u2192 Purple: Paint an unpainted cell in the left grid.  \n- Red \u2192 Purple: Paint an unpainted cell in the right grid.\n\n**Satisfying Conditions:**  \n- Condition 1 requires one \"Blue \u2192 Purple\" operation.  \n- Condition 2 requires two \"Red \u2192 Purple\" operations.  \n\nThe answer is \\(1+2=3\\).\n\n**Step 2:** For the general case, divide the grid and consider red and blue independently. Solve for red, then add results.  \n\n**Properties:**  \n- Minimum cells to repaint red = minimum white cells passed from top-left to bottom-right.  \nLet \\(a\\) be cells repainted red, and \\(b\\) be white cells passed.  \n- \\(b \\geq a\\): A path through \\(b\\) white cells can be repainted to move.  \n- \\(b \\leq a\\): A method with \\(a\\) repaintings moves without more than \\(a\\) white cells.  \nThus, \\(a = b\\).\n\n**Find Minimum White Cells Passed:**  \nReduce to shortest path problem:  \n- Each cell is a vertex; cost is 1 for white and 0 otherwise.  \n- Use Dijkstra\u2019s algorithm (\\(O(N^2 \\log N)\\) time). Constraint \\(N \\leq 500\\).\n\n**Sample Implementation (Python 3):**\n```python\nimport heapq\n\nN = int(input())\nC = [input().strip() for _ in range(N)]\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ndef solve(sx, sy, gx, gy, target):\n    dist = [[float('inf')] * N for _ in range(N)]\n    dist[sx][sy] = 0\n    used = [[False] * N for _ in range(N)]\n    queue = [(0, sx, sy)]\n\n    while queue:\n        cost, ax, ay = heapq.heappop(queue)\n        if used[ax][ay]:\n            continue\n        used[ax][ay] = True\n        for i in range(4):\n            bx = ax + dx[i]\n            by = ay + dy[i]\n            if 0 <= bx < N and 0 <= by < N:\n                new_cost = cost + (0 if C[bx][by] == target else 1)\n                if dist[bx][by] > new_cost:\n                    dist[bx][by] = new_cost\n                    heapq.heappush(queue, (new_cost, bx, by))\n\n    return dist[gx][gy]\n\ndist1 = solve(0, 0, N-1, N-1, 'R')\ndist2 = solve(0, N-1, N-1, 0, 'B')\nprint(dist1 + dist2)\n```\n[END TEXT]\n```\n \n\n", "problem_ids": ["abc366_c", "abc360_a", "arc177_c"]}, "abc319_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) intervals of real numbers. The \\( i \\)-th (\\( 1 \\leq i \\leq N \\)) interval is \\([l_i, r_i]\\). Find the number of pairs \\((i, j)\\) (\\( 1 \\leq i < j \\leq N \\)) such that the \\( i \\)-th and \\( j \\)-th intervals intersect.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 5 \\times 10^5 \\)\n- \\( 0 \\leq l_i < r_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nl_1 r_1\nl_2 r_2\n\u22ee\nl_N r_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n1 5\n7 8\n3 7\n```\n\n**Sample Output 1**\n```\n2\n```\n*Explanation*: The given intervals are \\([1,5], [7,8], [3,7]\\). Among these, the 1st and 3rd intervals intersect, as well as the 2nd and 3rd intervals, so the answer is 2.\n\n**Sample Input 2**\n```\n3\n3 4\n2 5\n1 6\n```\n\n**Sample Output 2**\n```\n3\n```\n\n**Sample Input 3**\n```\n2\n1 2\n3 4\n```\n\n**Sample Output 3**\n```\n0\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Inspecting all pairs of segments to check if they intersect has a time complexity of \\(O(N^2)\\), which exceeds the execution time limit. Instead, we find the number of disjoint segments \\(x\\) and subtract it from \\(N(N-1)/2\\). For each segment \\(i\\), count \\(j\\) such that \\(r_j < l_i\\) using a sliding window technique. Sort the sequences \\(L\\) and \\(R\\) obtained from \\(l_i\\) and \\(r_i\\) respectively. For each \\(i\\), find the number \\(c_i\\) of \\(j\\) such that \\(R_j < L_i\\) by leveraging the property \\(c_i\\leq c_{i+1}\\). This optimization results in a time complexity of \\(O(N)\\), allowing the algorithm to run efficiently.\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nGiven integers \\(N\\) and \\(M\\), compute the sum \\(\\sum_{k=0}^{N} \\text{popcount}(k \\& M)\\), modulo \\(998244353\\).\n\nHere, \\(\\&\\) represents the bitwise AND operation.\n\n**What is the bitwise AND operation?**\n\nThe result \\(x = a \\& b\\) of the bitwise AND operation between non-negative integers \\(a\\) and \\(b\\) is defined as follows:\n\n- \\(x\\) is the unique non-negative integer that satisfies the following conditions for all non-negative integers \\(k\\):\n  - If the \\(2^k\\) place in the binary representation of \\(a\\) and \\(b\\) are both \\(1\\), then the \\(2^k\\) place in the binary representation of \\(x\\) is \\(1\\).\n  - Otherwise, the \\(2^k\\) place in the binary representation of \\(x\\) is \\(0\\).\n\nFor example, \\(3=11_{(2)}\\) and \\(5=101_{(2)}\\), so \\(3 \\& 5 = 1\\).\n\n**What is popcount?**\n\n\\(\\text{popcount}(x)\\) represents the number of \\(1\\)s in the binary representation of \\(x\\).\n\nFor example, \\(13=1101_{(2)}\\), so \\(\\text{popcount}(13) = 3\\).\n\n**Constraints:**\n\n- \\(N\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n- \\(M\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\n```\n\n**Output:**\n\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 3\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n- \\(\\text{popcount}(0 \\& 3) = 0\\)\n- \\(\\text{popcount}(1 \\& 3) = 1\\)\n- \\(\\text{popcount}(2 \\& 3) = 1\\)\n- \\(\\text{popcount}(3 \\& 3) = 2\\)\n- \\(\\text{popcount}(4 \\& 3) = 0\\)\n\nThe sum of these values is \\(4\\).\n\n**Sample Input 2:**\n```\n0 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\nIt is possible that \\(N = 0\\) or \\(M = 0\\).\n\n**Sample Input 3:**\n```\n1152921504606846975 1152921504606846975\n```\n\n**Sample Output 3:**\n```\n499791890\n```\n\nRemember to compute the result modulo \\(998244353\\).\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial presents the solution to a problem from AtCoder Beginner Contest 356, specifically the \"D - Masked Popcount\" problem. The goal is to compute the sum of set bits in the result of bitwise AND operations between each integer from 0 to N and a given integer M with the following steps:\n\n1. Iterate over each bit position \\( j \\) from 0 to 59.\n2. If the \\( j \\)-th bit of \\( M \\) is set, for each \\( j \\), add to the result the count of integers between 0 and N whose \\( j \\)-th bit is set.\n3. The number of integers with the \\( j \\)-th bit set is calculated by examining ranges defined by powers of two.\n4. During computation, handle overflow by taking results modulo 998244353.\n\nThe solution involves efficiently counting set bits using bit operations and properties of numbers, ensuring accurate summing even under large values.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThe Republic of AtCoder consists of \\(L+1\\) islands aligned east-west, numbered \\(0\\) to \\(L\\) from west to east. The islands are connected by air routes, where for each \\(1 \\leq i \\leq L\\), there is a bidirectional air route between islands \\(i-1\\) and \\(i\\). Each air route is owned by company A or company J, and the route between islands \\(i-1\\) and \\(i\\) is owned by company \\(S_i\\).\n\nThe nation has \\(N\\) residents, numbered \\(1\\) to \\(N\\). Resident \\(i\\) is currently on island \\(X_i\\). Each resident has a coupon of one of the companies. Specifically, resident \\(i\\) has a coupon of company \\(C_i\\). With a coupon, a resident can take that company's routes for free any number of times, but taking a route of the other company costs 1 coin per trip.\n\nNow, there is a treasure chest on island 0. The residents want to cooperate to carry it to the capital, which is on island \\(L\\). Determine the minimum total number of coins required to achieve this goal. The residents can pass the treasure chest to each other, but not their coupons.\n\nConstraints:\n- \\(1 \\leq L \\leq 6 \\times 10^4\\)\n- \\(1 \\leq N \\leq 6 \\times 10^4\\)\n- \\(S_i \\ (1 \\leq i \\leq L)\\) is 'A' or 'J'.\n- \\(0 \\leq X_i \\leq L \\ (1 \\leq i \\leq N)\\)\n- \\(C_i \\ (1 \\leq i \\leq N)\\) is 'A' or 'J'.\n- \\(L, N, X_i\\) are integers.\n\nInput:\n- Input is given from Standard Input in the following format:\n  \\[\n  L \\, N \\\\\n  S_1 S_2 \\cdots S_L \\\\\n  X_1 \\, C_1 \\\\\n  X_2 \\, C_2 \\\\\n  \\vdots \\\\\n  X_N \\, C_N\n  \\]\n- Note that the second line is a string of length \\(L\\).\n\nOutput:\n- Print the answer.\n\nSample Input 1:\n```\n4 3\nAAJJ\n3 A\n1 J\n1 J\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation for Sample 1:\nTo carry the treasure chest to island 4 for a total of 2 coins, the following steps are taken:\n1. Resident 1 moves from island 3 to island 2, costing 1 coin as the route is not covered by the coupon.\n2. Resident 1 moves from island 2 to island 1, requiring no coins as the route is covered by the coupon.\n3. Resident 1 moves from island 1 to island 0, requiring no coins as the route is covered by the coupon.\n4. Resident 1 picks up the treasure chest.\n5. Resident 1 moves, carrying the treasure chest, from island 0 to island 1 without costing any coins as the route is covered by the coupon.\n6. Resident 1 passes the treasure chest to resident 2.\n7. Resident 2, with the treasure chest, moves from island 1 to island 2, costing 1 coin as the route is not covered by the coupon.\n8. Resident 2 moves with the treasure chest from island 2 to island 3, requiring no coins as the route is covered by the coupon.\n9. Resident 2 moves with the treasure chest from island 3 to island 4, requiring no coins as the route is covered by the coupon.\n\nSample Input 2:\n```\n8 3\nJJAAJJAJ\n2 A\n6 A\n8 J\n```\n\nSample Output 2:\n```\n6\n```\n\nSample Input 3:\n```\n8 6\nJJAAJJAJ\n2 A\n6 A\n8 J\n8 J\n8 J\n8 J\n```\n\nSample Output 3:\n```\n4\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 177 - F - Two Airlines Editorial\n\nStep 1:\nConsider the optimal movement strategy for residents with company A and J coupons, labeled Blue 1, 2, 3,..., and Red 1, 2, 3,... It is suboptimal for a resident to move luggage after a fellow resident of the same color. Utilize dynamic programming with states recording the current position, count of used Blue and Red residents, and current luggage holder. This yields  \\(\\mathrm{dp}[\\mathrm{pos}][b][r][\\mathrm{type}]\\) but results in an \\(O(N^3)\\) complexity, leading to time limit exceeded.\n\nStep 2:\nReduce state count by assuming residents more than two positions left don't touch luggage, resulting in \\(b \\geq b_{\\mathrm{left}}\\), \\(r \\geq r_{\\mathrm{left}}\\). Still results in \\(O(N^3)\\) complexity, leading to time exceedance.\n\nStep 3:\nFurther constrain by assuming residents over 20 positions to the right do not touch the luggage: \\(b \\leq b_{\\mathrm{left}} + 20\\), \\(r \\leq r_{\\mathrm{left}} + 20\\). The worst-case scenario involves 21 Blue at a single position, causing theoretical upper limit issues, but proven correct under \\(L \\leq 6 \\times 10^4\\).\n\nSample Implementation (C++):\nImplement the strategy noted above with an emphasis on memory and time management due to \\(O(N^3)\\) complexity states. The sample outlines initializing cumulative sums, initializing DP states, and processing state transitions to determine the minimum cost of operations involving agents and positions.\n\n[Code Example Not Included for Brevity]\n[END TEXT]\n \n\n", "problem_ids": ["abc355_d", "abc356_d", "arc177_f"]}, "abc320_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nIn the Kingdom of AtCoder, residents are required to shout their love for takoyaki at \\( A \\) o'clock every day.\n\nTakahashi, who lives in the Kingdom of AtCoder, goes to bed at \\( B \\) o'clock and wakes up at \\( C \\) o'clock every day (in the 24-hour clock). He can shout his love for takoyaki when he is awake, but cannot when he is asleep. Determine whether he can shout his love for takoyaki every day. Here, a day has 24 hours, and his sleeping time is less than 24 hours.\n\n**Constraints**\n- \\( 0 \\leq A, B, C < 24 \\)\n- \\( A \\), \\( B \\), and \\( C \\) are pairwise different.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can shout his love for takoyaki every day, and `No` otherwise.\n\n**Sample Input 1**\n```\n21 8 14\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Takahashi goes to bed at 8 o'clock and wakes up at 14 o'clock every day. He is awake at 21 o'clock, so he can shout his love for takoyaki every day. Therefore, print `Yes`.*\n\n**Sample Input 2**\n```\n0 21 7\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*Takahashi goes to bed at 21 o'clock and wakes up at 7 o'clock every day. He is not awake at 0 o'clock, so he cannot shout his love for takoyaki every day. Therefore, print `No`.*\n\n**Sample Input 3**\n```\n10 7 17\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 367 - Editorial\n\n**Problem Solution:**\n\nThe problem can be solved by employing casework based on whether the person is asleep at midnight. \n\n1. **If not asleep at midnight:**\n   - The person sleeps from \\(B\\) to \\(C\\) o\u2019clock. The answer is \"No\" if \\(A\\) o\u2019clock is between \\(B\\) and \\(C\\) (\\(B<A<C\\)). Otherwise, the answer is \"Yes\".\n\n2. **If asleep at midnight:**\n   - The person is awake from \\(C\\) to \\(B\\) o\u2019clock. The answer is \"Yes\" if \\(A\\) o\u2019clock is between \\(C\\) and \\(B\\) (\\(C<A<B\\)). Otherwise, the answer is \"No\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A and A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A and A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Alternative Approach:**\n\nTo avoid casework, use a while statement starting from \\(B\\) and increment hour by hour. If \\(A\\) is reached before \\(C\\), print \"No\". Otherwise, print \"Yes\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nnow = B\nwhile now != C:\n    if now == A:\n        print(\"No\")\n        exit()\n    now += 1\n    now %= 24\n\nprint(\"Yes\")\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two integer sequences, \\( A \\) and \\( B \\), each of length \\( N \\). Choose integers \\( i, j \\) (such that \\( 1 \\leq i, j \\leq N \\)) to maximize the value of \\( A_i + B_j \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 5 \\times 10^5 \\)\n- \\( |A_i| \\leq 10^9 \\) for \\( i = 1, 2, \\ldots, N \\)\n- \\( |B_j| \\leq 10^9 \\) for \\( j = 1, 2, \\ldots, N \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\nB_1 B_2 \\dots B_N\n```\n\n**Output**\n\nPrint the maximum possible value of \\( A_i + B_j \\).\n\n**Sample Input 1**\n\n```\n2\n-1 5\n3 -7\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\n_For \\( (i, j) = (1,1), (1,2), (2,1), (2,2) \\), the values of \\( A_i + B_j \\) are \\( 2, -8, 8, -2 \\) respectively, and \\( (i, j) = (2,1) \\) achieves the maximum value 8._\n\n**Sample Input 2**\n\n```\n6\n15 12 3 -13 -1 -19\n7 17 -13 -10 18 4\n```\n\n**Sample Output 2**\n\n```\n33\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 373 - C - Max Ai+Bj Editorial\n\nThere are \\(N^2\\) combinations of \\((i,j)\\), so evaluating \\(A_i+B_j\\) for all pairs \\((i,j)\\) does not finish within the execution time limit. Notice that \\(\\max_{1 \\leq i,j \\leq N} (A_i + B_j) = \\max_{1 \\leq i \\leq N} A_i + \\max_{1 \\leq j \\leq N} B_j\\). One can find \\(\\max_{1 \\leq i \\leq N} A_i\\) by scanning the elements of \\(A\\) in \\(O(N)\\) time, and the same applies to \\(\\max_{1 \\leq j \\leq N} B_j\\). Therefore, the problem is solved in \\(O(N)\\) time.\n\nSample code (Python):\n```python\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nprint(max(A) + max(B))\n```\n\nSample code (Python, translated from C++):\n```python\nN = int(input())\na = -1e9\nb = -1e9\nfor _ in range(N):\n    x = int(input())\n    a = max(a, x)\nfor _ in range(N):\n    x = int(input())\n    b = max(b, x)\nprint(a + b)\n```\n        [END TEXT]\n        \n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) giants, each identified by an integer from 1 to \\( N \\). For each giant \\( i \\), when they stand on the ground, their shoulder height is \\( A_i \\) and their head height is \\( B_i \\).\n\nYou can arrange all the giants in a permutation \\( (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) and stack them one on top of another according to the following rules:\n\n1. Place giant \\( P_1 \\) on the ground. The shoulder height of giant \\( P_1 \\) from the ground is \\( A_{P_1} \\), and the head height is \\( B_{P_1} \\).\n2. Following this, for \\( i = 1, 2, \\ldots, N - 1 \\), place giant \\( P_{i+1} \\) on the shoulders of giant \\( P_i \\). If the shoulder height of giant \\( P_i \\) from the ground is \\( t \\), then the shoulder height of giant \\( P_{i+1} \\) from the ground is \\( t + A_{P_{i+1}} \\), and the head height is \\( t + B_{P_{i+1}} \\).\n\nThe goal is to determine the maximum possible head height from the ground of the topmost giant \\( P_N \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 200,000 \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq 1,000,000,000 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output:**\n\nPrint the maximum possible height of the head of the topmost giant from the ground.\n\n**Sample Input 1:**\n```\n3\n4 10\n5 8\n2 9\n```\n\n**Sample Output 1:**\n```\n18\n```\n\n*Explanation:* If the permutation \\( (P_1, P_2, P_3) = (2, 1, 3) \\) is chosen, the heights measured from the ground would be as follows:\n\n- Giant 2 will have a shoulder height of 5 and a head height of 8.\n- Giant 1 will be on top, having a shoulder height of 9 and a head height of 15.\n- Giant 3 will be on top, having a shoulder height of 11 and a head height of 18.\n\nThe maximum head height achievable with any arrangement of the giants is 18, and thus, 18 is printed.\n\n**Sample Input 2:**\n```\n5\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\n**Sample Output 2:**\n```\n5\n```\n\n**Sample Input 3:**\n```\n10\n690830957 868532399\n741145463 930111470\n612846445 948344128\n540375785 925723427\n723092548 925021315\n928915367 973970164\n563314352 832796216\n562681294 868338948\n923012648 954764623\n691107436 891127278\n```\n\n**Sample Output 3:**\n```\n7362669937\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\nThe height of the topmost giant\u2019s head when \\(P_N\\), i.e., when giant \\(i\\) is the topmost giant, is \\(B_i + \\sum_{j \\neq i}A_j\\). This can be expressed as \\(B_i - A_i + \\sum_{j = 1}^{N} A_j\\), and the answer is the maximum of this value for \\(i = 1, 2, \\ldots, N\\). Since \\(\\sum_{j = 1}^{N} A_j\\) is independent of \\(i\\), it is sufficient to find \\(\\max (B_i - A_i)\\). This can be computed using a for loop in a total of \\(O(N)\\) time.\n\nSample code:\n```python\nn = int(input())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nm = 0\nfor i in range(n):\n    m = max(m, b[i] - a[i])\nans = m + sum(a)\nprint(ans)\n```\n \n\n", "problem_ids": ["abc367_a", "abc373_c", "abc352_c"]}, "abc320_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( A \\), \\( B \\), \\( X \\), \\( Y \\), and \\( N \\). The following conditions are guaranteed:\n\n- \\( A < B \\)\n- \\(\\gcd(A, B) = 1\\)\n- \\( 1 \\leq N \\leq A+B-1 \\)\n\nFor an integer \\( n \\), define \\( f(n) \\) as follows: You start with an integer \\( x = 0 \\). \\( f(n) \\) is the minimum total cost to achieve \\( x = n \\) by repeatedly performing the following operations:\n\n- Replace the value of \\( x \\) with \\( x + A \\). The cost of this operation is \\( X \\).\n- Replace the value of \\( x \\) with \\( x - A \\). The cost of this operation is \\( X \\).\n- Replace the value of \\( x \\) with \\( x + B \\). The cost of this operation is \\( Y \\).\n- Replace the value of \\( x \\) with \\( x - B \\). The cost of this operation is \\( Y \\).\n\nIt can be proved from the constraints on \\( A \\) and \\( B \\) that \\( f(n) \\) is defined for any integer \\( n \\).\n\nFind the value of \\( \\sum_{1 \\leq n \\leq N} f(n) \\), modulo \\( 998244353 \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 1000 \\)\n- \\( 1 \\leq A < B \\leq 10^9 \\)\n- \\(\\gcd(A, B) = 1\\)\n- \\( 1 \\leq X, Y \\leq 10^9 \\)\n- \\( 1 \\leq N \\leq A + B - 1 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nA B X Y N\n```\n\n**Output**\n\nPrint the answer for each test case.\n\n**Sample Input**\n\n```\n4\n1 2 1 1 2\n3 5 2 4 6\n79 85 72 95 4\n80980429 110892168 22712439 520643153 66132787\n```\n\n**Sample Output**\n\n```\n2\n34\n18111\n785776602\n```\n\nIn the first test case, \\( f(1) = 1 \\) and \\( f(2) = 1 \\).\n\nIn the second test case, \\( f(1) = 8 \\), \\( f(2) = 6 \\), \\( f(3) = 2 \\), \\( f(4) = 10 \\), \\( f(5) = 4 \\), and \\( f(6) = 4 \\).\n\nSolution:\n\n        The solution discusses how to find the shortest path in an operation sequence defined by integers \\(A, B, C, N\\), and elements \\(AX, AY, BX, BY\\) of a monoid \\(M\\). The problem focuses on modifying an integer \\(x\\) initially set to 0 and updating elements \\(cur\\) and \\(ans\\) in \\(M\\) over \\(N\\) operations. The operations are performed based on whether \\(x\\) is less than \\(B\\) or not, adjusting \\(ans\\) with products involving \\(AX, AY, BX, BY\\). The approach leverages a cycle structure of moves to ensure optimal paths, achieved through combinations of operations that mimic mathematical floor functions. Solutions are designed to work efficiently, leveraging logarithmic complexity relative to \\(A + B\\).\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a positive integer \\( N \\), and an integer \\( A_{x,y,z} \\) for each triple of integers \\( (x, y, z) \\) such that \\( 1 \\leq x, y, z \\leq N \\).\n\nYou will be given \\( Q \\) queries in the following format, which must be processed in order.\n\nFor the \\( i \\)-th query \\( (1 \\leq i \\leq Q) \\), you are given a tuple of integers \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\) such that \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\), \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\), and \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\). Find:\n\n\\[\n\\displaystyle{\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}}\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 0 \\leq A_{x,y,z} \\leq 999 \\) where \\( 1 \\leq x, y, z \\leq N \\)\n- \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n- The integer \\( N \\)\n- An \\( N \\times N \\times N \\) array \\( A \\) of integers, given in the order \\( A_{1,1,1}, A_{1,1,2}, \\ldots \\), i.e., iterating through \\( x \\), then \\( y \\), then \\( z \\).\n- The integer \\( Q \\)\n- \\( Q \\) lines, each containing six integers representing \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\)\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n\n```\n2\n1 2\n3 4\n5 6\n7 8\n2\n1 2 2 2 1 1\n2 2 1 2 1 2\n```\n\n**Sample Output 1:**\n\n```\n10\n26\n```\n\n**Explanation:**\n\nFor the 1st query, the sought value is \\( A_{1,2,1} + A_{2,2,1} = 3 + 7 = 10 \\). Thus, print 10.\n\nFor the 2nd query, the sought value is \\( A_{2,1,1} + A_{2,1,2} + A_{2,2,1} + A_{2,2,2} = 5 + 6 + 7 + 8 = 26 \\). Thus, print 26.\n\n**Sample Input 2:**\n\n```\n3\n733 857 714\n956 208 257\n123 719 648\n840 881 245\n245 112 746\n306 942 694\n58 870 849\n13 208 789\n687 906 783\n8\n3 3 3 3 1 1\n1 3 2 3 3 3\n2 2 2 3 1 1\n1 3 1 1 1 1\n2 3 2 3 2 3\n1 2 1 1 1 2\n3 3 2 2 1 3\n1 2 2 3 2 3\n```\n\n**Sample Output 2:**\n\n```\n687\n3917\n551\n1631\n5180\n3311\n1010\n4326\n```\n\nSolution:\n\n```plaintext\nD - Cuboid Sum Query Editorial\n\nThis problem is an exercise of cumulative sums. We assume the knowledge of cumulative sums for a sequence (one-dimensional cumulative sums).\n\nGiven a length-\\(N\\) sequence \\(A\\), process \\(Q\\) queries. In the \\(i\\)-th query, given an integer pair \\((L_i,R_i)\\) satisfying \\(1 \\leq L_i \\leq R_i \\leq N\\), find \\(\\sum_{k=L_i}^{R_i}A_k\\).\n\nA solution to this problem is as follows: Define a length-\\((N+1)\\) sequence \\(S=(S_0,S_1,\\ldots S_N)\\) by \\(S_0=0,S_i=\\sum_{k=1}^{i-1}A_k\\), and use \\(\\sum_{k=L_i}^{R_i}A_k=S_{R_i+1}-S_{L_i}\\) to answer the query fast. The sequence \\(S\\) is called the cumulative sums of \\(A\\).\n\nThe original problem is an extension of this one-dimensional cumulative sum problem into three dimensions.\n\nConsider \\(S\\) such that \\(S_{i,j,k}=\\sum_{x=1}^{i-1} \\sum_{y=1}^{j-1}\\sum_{z=1}^{k-1}A_{x,y,z}\\) for \\(1 \\leq i,j,k \\leq N+1\\). If \\(i\\), \\(j\\), or \\(k\\) is \\(0\\), define \\(S_{i,j,k}=0\\).\n\nIt holds that \\(\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}=S_{Rx_i+1,Ry_i+1,Rz_i+1}-S_{Lx_i,Rx_i+1,Rz_i+1}-S_{Rx_i+1,Ly_i,Rz_i+1}-S_{Rx_i+1,Ry_i+1,Lz_i}+S_{Lx_i,Ly_i,Rz_i+1}+S_{Lx_i,Ry_i+1,Lz_i}+S_{Rx_i+1,Ly_i,Lz_i}-S_{Lx_i,Ly_i,Lz_i}\\).\n\nTherefore, if one can compute \\(S\\) fast, then each query can be answered in constant time.\n\n\\(S\\) can be found by the property that \\(S_{i,j,k}=S_{i-1,j,k}+S_{i,j-1,k}+S_{i,j,k-1}-S_{i-1,j-1,k}-S_{i-1,j,k-1}-S_{i,j-1,k-1}+S_{i-1,j-1,k-1}+A_{i-1,j-1,k-1}\\). The time complexity is \\(O(N^3+Q)\\).\n\nSample code (Python):\n```python\nn = int(input())\n\na = [[[0] * n for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        a[i][j]=list(map(int,input().split()))\n\nsum = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            sum[i + 1][j + 1][k + 1] = (sum[i][j+1][k+1]\n                                        + sum[i+1][j][k+1]\n                                        + sum[i+1][j+1][k]\n                                        - sum[i][j][k+1]\n                                        - sum[i][j+1][k]\n                                        - sum[i+1][j][k]\n                                        + sum[i][j][k]\n                                        + a[i][j][k])\n\nq = int(input())\nfor _ in range(q):\n    lx, rx, ly, ry, lz, rz = map(int, input().split())\n    lx -= 1\n    ly -= 1\n    lz -= 1\n\n    result = (sum[rx][ry][rz]\n                - sum[lx][ry][rz]\n                - sum[rx][ly][rz]\n                - sum[rx][ry][lz]\n                + sum[lx][ly][rz]\n                + sum[lx][ry][lz]\n                + sum[rx][ly][lz]\n                - sum[lx][ly][lz])\n    print(result)\n```\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere are \\( N \\) types of items. The \\( i \\)-th type of item has a weight of \\( w_i \\) and a value of \\( v_i \\). Each type has \\( 10^{10} \\) items available.\n\nTakahashi is going to choose some items and put them into a bag with capacity \\( W \\). He wants to maximize the value of the selected items while avoiding choosing too many items of the same type. Hence, he defines the **happiness** of choosing \\( k_i \\) items of type \\( i \\) as \\( k_i v_i - k_i^2 \\). He wants to choose items to maximize the total happiness over all types while keeping the total weight at most \\( W \\). Calculate the maximum total happiness he can achieve.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 3000 \\)\n- \\( 1 \\leq W \\leq 3000 \\)\n- \\( 1 \\leq w_i \\leq W \\)\n- \\( 1 \\leq v_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN W\nw_1 v_1\nw_2 v_2\n\\vdots\nw_N v_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n2 10\n3 4\n3 2\n```\n\n**Sample Output 1:**\n```\n5\n```\n\nBy choosing 2 items of type 1 and 1 item of type 2, the total happiness can be 5, which is optimal. Here, the happiness for type 1 is \\( 2 \\times 4 - 2^2 = 4 \\), and the happiness for type 2 is \\( 1 \\times 2 - 1^2 = 1 \\). The total weight is 9, which is within the capacity 10.\n\n**Sample Input 2:**\n```\n3 6\n1 4\n2 3\n2 7\n```\n\n**Sample Output 2:**\n```\n14\n```\n\n**Sample Input 3:**\n```\n1 10\n1 7\n```\n\n**Sample Output 3:**\n```\n12\n```\n\nSolution:\n\n```python\n# Here is a streamlined version focusing on the core solution:\n\ndef dp_happiness(N, W, items):\n    # Initialize dp table\n    dp = [[0] * (W + 1) for _ in range(max_weight + 1)]\n    \n    for w in range(1, max_weight + 1):\n        values = [v for v_i, w_i in items if w_i == w]\n        m = len(values)\n        \n        def f_w(k):\n            happiness = 0\n            # Priority queue to maximize happiness delta\n            deltas = [v - 1 for v in values]\n            deltas.sort(reverse=True)\n            for i in range(k):\n                if deltas:\n                    happiness += deltas[0]\n                    deltas[0] -= 2\n                    deltas.sort(reverse=True)\n            return happiness\n        \n        for j in range(W + 1):\n            dp[w][j] = dp[w-1][j]\n            for k in range(0, j // w + 1):\n                dp[w][j] = max(dp[w][j], dp[w-1][j - k * w] + f_w(k))\n    \n    return dp[max_weight][W]\n\n# Example usage:\n# N: number of items\n# W: maximum weight\n# Items: list of tuples, each tuple is (value, weight)\nN = 5\nW = 10\nitems = [(3, 2), (2, 2), (4, 3), (5, 5)]\nmax_weight = max(item[1] for item in items)\n\nmax_happiness = dp_happiness(N, W, items)\nprint(f\"Maximum total happiness: {max_happiness}\")\n```\n\nThis Python code implements the Dynamic Programming approach described in the editorial, fully translated from the explanation provided. The function `dp_happiness` takes the number of items, maximum weight, and a list of items (each defined by a tuple of value and weight) and computes the maximum total happiness.\n \n\n", "problem_ids": ["arc183_f", "abc366_d", "abc373_f"]}, "abc320_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) people participating in an event, and the transportation cost for the \\( i \\)-th person is \\( A_i \\) yen. Takahashi, the organizer of the event, decided to set a maximum limit \\( x \\) for the transportation subsidy. The subsidy for person \\( i \\) will be \\( \\min(x, A_i) \\) yen. Here, \\( x \\) must be a non-negative integer.\n\nGiven that Takahashi's budget is \\( M \\) yen, and he wants the total transportation subsidy for all \\( N \\) people to be at most \\( M \\) yen, what is the maximum possible value of the subsidy limit \\( x \\)?\n\nIf the subsidy limit can be made infinitely large, report that instead.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^{14} \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_{N}\n```\n\n**Output:**\n\nPrint the maximum value of the subsidy limit \\( x \\) that satisfies the budget condition, as an integer.\n\nIf the subsidy limit can be made infinitely large, print `infinite` instead.\n\n**Sample Input 1:**\n```\n4 8\n1 3 2 4\n```\n\n**Sample Output 1:**\n```\n2\n```\n\n*Explanation:*\n\nIf the subsidy limit is set to 2 yen, the total transportation subsidy for all \\( N \\) people is \\( \\min(2,1) + \\min(2,3) + \\min(2,2) + \\min(2,4) = 7 \\) yen, which is within the budget of 8 yen.\n\nIf the subsidy limit is set to 3 yen, the total transportation subsidy for all \\( N \\) people is \\( \\min(3,1) + \\min(3,3) + \\min(3,2) + \\min(3,4) = 9 \\) yen, which exceeds the budget of 8 yen. Therefore, the maximum possible value of the subsidy limit is 2 yen.\n\n**Sample Input 2:**\n```\n3 20\n5 3 2\n```\n\n**Sample Output 2:**\n```\ninfinite\n```\n\n*Explanation:*\n\nThe subsidy limit can be made infinitely large.\n\n**Sample Input 3:**\n```\n10 23\n2 5 6 5 2 1 7 9 7 2\n```\n\n**Sample Output 3:**\n```\n2\n```\n\nSolution:\n\n```\nToyota Programming Contest 2024#8 (AtCoder Beginner Contest 365) Editorial\n\nC - Transportation Expenses Editorial\n\nFirst, we consider when the answer is infinite. It is infinite when the total sum of \\(A\\) is not greater than \\(M\\), as the total cost required is never greater than \\(M\\). Conversely, if the total sum is greater than \\(M\\), setting the upper bound to the maximum value of \\(A\\) leads to exceeding the budget, so a maximum value exists.\n\nAssuming the answer is not infinite, a technique called binary search is effective for finding the maximum value subject to some condition. Given an upper bound \\(x\\), it can be determined if the total cost exceeds the budget in \\(O(N)\\) time. The number of iterations in the binary search is \\(O(\\log{\\max{A}})\\) because the upper bound of the answer is \\(\\max{A}\\). Therefore, the problem can be solved in \\(O(N\\log{\\max{A}})\\) time.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(N\\) where all elements are between \\(1\\) and \\(2^K - 1\\), inclusive, is called a **good sequence**.\n\nThe **score** of a good sequence \\(A = (A_1, A_2, \\ldots, A_N)\\) is defined as follows:\n- The number of distinct integers that can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) using an integer \\(i\\) between \\(1\\) and \\(N\\), inclusive, and a non-negative integer \\(k\\).\n\nFor example, for \\(A = (3, 5)\\), five integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3,\\) and \\(5\\), so the score is \\(5\\).\n\nFind one good sequence with the maximum score.\n\nFor each input file, you are given \\(T\\) test cases to solve.\n\n### Constraints\n- \\(1 \\leq T \\leq 10^5\\)\n- \\(1 \\leq N \\leq 10^5\\)\n- \\(1 \\leq K \\leq 30\\)\n- The sum of \\(N\\) across the test cases in a single input file is at most \\(2 \\times 10^5\\).\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format. Here, \\(\\text{case}_i\\) denotes the \\(i\\)-th test case.\n\n```\nT\n\\text{case}_1\n\\text{case}_2\n\\vdots\n\\text{case}_T\n```\n\nEach test case is given in the following format:\n```\nN K\n```\n\n### Output\nPrint \\(T\\) lines.\n\nThe \\(i\\)-th line should contain the answer for \\(\\text{case}_i\\).\n\nIf there are multiple good sequences with the maximum score, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n3 3\n7 2\n8 20\n```\n\n### Sample Output 1\n```\n5 6 7\n2 2 3 3 1 3 3\n662933 967505 876482 840117 1035841 651549 543175 781219\n```\n\n**Explanation for the first test case:**\nFor \\(A = (5, 6, 7)\\), seven integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3, 5, 6,\\) and \\(7\\), so its score is \\(7\\). Outputs such as \\(A = (7, 4, 5)\\) and \\(A = (6, 5, 4)\\) would also be accepted.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nB - |{floor(A_i/2^k)}| Editorial by evima\n\nIn this explanation, we assume that indices start from \\(0\\). First, it is unnecessary to include elements less than \\(2^{K-1}\\) in \\(A\\). This is because replacing elements less than \\(2^{K-1}\\) with their double will result in the same or a higher score. Therefore, we can limit the elements of \\(A\\) to be between \\(2^{K-1}\\) and \\(2^K-1\\).\n\n1. When \\(N \\geq 2^{K-1}\\): We can include all elements between \\(2^{K-1}\\) and \\(2^K-1\\) in \\(A\\) and set \\(A_i = \\max(1, 2^K - 1 - i)\\) \\((0 \\le i < N)\\).\n\n2. When \\(N < 2^{K-1}\\): Consider an upper bound of the score. For \\(0 \\le x < K\\), consider the number of elements that appear as \\(\\displaystyle \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) between \\(2^x\\) and \\(2^{x+1}-1\\). For each \\(A_i\\), there is at most one \\(k\\) that satisfies \\(\\displaystyle 2^x \\le \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor < 2^{x+1}\\), so the number of such elements is at most \\(N\\). On the other hand, there are only \\(2^x\\) integers between \\(2^x\\) and \\(2^{x+1}\\), so the number of elements that appear in this range is at most \\(\\min(N, 2^x)\\). Therefore, by summing over all \\(x\\), the score has an upper bound of \\(\\displaystyle 1 + \\sum_{x=0}^{K-1}\\min(N, 2^x)\\).\n\nThis upper bound can always be achieved. Specifically, construct \\(A\\) as follows: Set \\(A_i\\) to the sum of \\(2^{K-1}\\) and the bit-reversal of \\(i\\). \u201cThe bit-reversal of \\(i\\)\u201d means the value obtained by reversing the \\((K-1)\\)-bit binary representation of \\(i\\).\n\nBy implementing the above, we can solve this problem. The time complexity is \\(O(NK)\\) due to the bit-reversal calculation being the bottleneck.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n\n    def bit_reversal(x):\n        return int(bin(x)[2:].zfill(K - 1)[::-1], 2)\n\n    if N >= 2 ** (K - 1):\n        print(*[max(1, 2**K - i - 1) for i in range(N)])\n    else:\n        print(*[2 ** (K - 1) + bit_reversal(i) for i in range(N)])\n```\n\nAdditionally, you can also solve it by constructing from the highest bit downwards.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n    C = [1]\n    for _ in range(1, K):\n        D = [2 * c for c in C] + [2 * c + 1 for c in C]\n        C = D[:N]\n    while len(C) < N:\n        C.append(1)\n    print(*C)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Your task is to find the value of:\n\n\\[\n\\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} \\left\\lfloor \\frac{\\max(A_i, A_j)}{\\min(A_i, A_j)} \\right\\rfloor\n\\]\n\nHere, \\(\\lfloor x \\rfloor\\) represents the greatest integer not greater than \\( x \\). For example, \\(\\lfloor 3.14 \\rfloor = 3\\) and \\(\\lfloor 2 \\rfloor = 2\\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n3 1 4\n```\n\n**Sample Output 1:**\n\n```\n8\n```\n\n*Explanation:* The sought value is:\n\n\\[\n\\left\\lfloor \\frac{\\max(3, 1)}{\\min(3, 1)} \\right\\rfloor + \\left\\lfloor \\frac{\\max(3, 4)}{\\min(3, 4)} \\right\\rfloor + \\left\\lfloor \\frac{\\max(1, 4)}{\\min(1, 4)} \\right\\rfloor = \\left\\lfloor \\frac{3}{1} \\right\\rfloor + \\left\\lfloor \\frac{4}{3} \\right\\rfloor + \\left\\lfloor \\frac{4}{1} \\right\\rfloor = 3 + 1 + 4 = 8\n\\]\n\n**Sample Input 2:**\n\n```\n6\n2 7 1 8 2 8\n```\n\n**Sample Output 2:**\n\n```\n53\n```\n\n**Sample Input 3:**\n\n```\n12\n3 31 314 3141 31415 314159 2 27 271 2718 27182 271828\n```\n\n**Sample Output 3:**\n\n```\n592622\n```\n\nSolution:\n\n```python\ndef calculate_max_min_sum(N, M, A):\n    # A should be sorted in ascending order\n    A.sort()\n    \n    # Pre-calculate the cumulative sum of C\n    C = [0] * (M + 1)\n    \n    # Count frequency of each element in A\n    for a in A:\n        C[a] += 1\n    \n    # Convert frequency to cumulative\n    for i in range(1, M + 1):\n        C[i] += C[i - 1]\n    \n    # Calculate the sum\n    max_min_sum = 0\n    for i in range(N - 1):\n        for n in range(1, M // A[i] + 1):\n            # Get count of j where floor(A_j/A[i]) = n\n            j_count = C[min(M, n * A[i])] - C[n * A[i] - 1]\n            max_min_sum += n * j_count\n    \n    return max_min_sum\n```\n \n\n", "problem_ids": ["abc365_c", "arc182_b", "abc356_e"]}, "abc320_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi eats three plates for breakfast: rice, miso soup, and salad. His table is long and narrow, so he arranged the three plates in a row. The arrangement is given by a string \\( S \\), where the \\( i \\)-th plate from the left is rice if \\( S_i \\) is \\( R \\), miso soup if \\( S_i \\) is \\( M \\), and salad if \\( S_i \\) is \\( S \\).\n\nDetermine whether the plate of rice is to the left of the plate of miso soup.\n\n**Constraints**\n\n- \\(|S| = 3\\)\n- \\( S \\) contains one \\( R \\), one \\( M \\), and one \\( S \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n**Output**\n\nPrint `Yes` if the plate of rice is to the left of the plate of miso soup, and `No` otherwise.\n\n**Sample Input 1**\n\n```\nRSM\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nThe plate of rice is at the 1st position from the left, and the plate of miso soup is at the 3rd position from the left. Since the plate of rice is to the left, print `Yes`.\n\n**Sample Input 2**\n\n```\nSMR\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nThe plates are arranged as salad, miso soup, and rice from left to right.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 360\n\nA - A Healthy Breakfast Editorial by en_translator\n\nFor beginners: If you are new to learning programming, please try \"Welcome to AtCoder\" from the practice contest. There you can find a sample code for each language. If you are not familiar with programming contests, try some problems in \"AtCoder Beginners Selection.\" \"C++\u5165\u9580 AtCoder Programming Guide for beginners (APG4b)\" is a C++ tutorial for competitive programmers (in Japanese).\n\nSolution: Prepare a string variable s. Read input into s. Use a for loop to determine positions of R and M in s. Let pos_r and pos_m be those indices. Use an if statement to print 'Yes' if pos_r < pos_m, otherwise print 'No'. With only six possible strings for \\(S\\), you can manually determine the answer using a conditional branch. Sample code in C++ provided.\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) villages on a number line. The \\( i \\)-th village is located at coordinate \\( X_i \\), and has \\( P_i \\) villagers.\n\nYou need to answer \\( Q \\) queries. Each query provides two integers, \\( L_i \\) and \\( R_i \\), and asks for the total number of villagers living in villages located between coordinates \\( L_i \\) and \\( R_i \\), inclusive.\n\n**Constraints**\n\n- \\( 1 \\leq N, Q \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq X_1 < X_2 < \\ldots < X_N \\leq 10^9 \\)\n- \\( 1 \\leq P_i \\leq 10^9 \\)\n- \\( -10^9 \\leq L_i \\leq R_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nX_1 X_2 ... X_N\nP_1 P_2 ... P_N\nQ\nL_1 R_1\nL_2 R_2\n...\nL_Q R_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line \\( (1 \\leq i \\leq Q) \\) should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n```\n4\n1 3 5 7\n1 2 3 4\n4\n1 1\n2 6\n0 10\n2 2\n```\n\n**Sample Output 1**\n```\n1\n5\n10\n0\n```\n\n*Consider the first query. The villages between coordinates 1 and 1 are the village at coordinate 1, with 1 villager. Hence, the answer is 1.*\n\n*Consider the second query. The villages between coordinates 2 and 6 are the villages at coordinates 3 and 5, with 2 and 3 villagers, respectively. Hence, the answer is \\( 2 + 3 = 5 \\).*\n\n**Sample Input 2**\n```\n7\n-10 -5 -3 -1 0 1 4\n2 5 6 5 2 1 7\n8\n-7 7\n-1 5\n-10 -4\n-8 10\n-5 0\n-10 5\n-8 7\n-8 -3\n```\n\n**Sample Output 2**\n```\n26\n15\n7\n26\n18\n28\n26\n11\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 371 - D Problem Editorial\n\nIf we can count the number of villagers with coordinates less than or equal to \\(D\\), the problem can be solved because the answer for a query can be found as \\(f(R_i) - f(L_i-1)\\), where \\(f(D)\\) corresponds to that subproblem. \n\nAssume \\(x\\) and \\(D\\) are between \\(0\\) and \\(N\\). We can precalculate the cumulative sums to find the answer in \\(\\mathrm{O}(1)\\) time. The original difficulty lies in large \\(x\\) and \\(D\\). To handle this, we use binary search. The rightmost village with coordinate \\(D\\) or less can be found with binary search. Along with the cumulative sums, \\(f(D)\\) can be found in \\(\\mathrm{O}(\\log N)\\) time, which is efficient.\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nFind the number of permutations \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) that satisfy all of the following \\( M \\) conditions, modulo \\( 998244353 \\).\n\nThe \\( i \\)-th condition: The maximum among \\( P_{L_i}, P_{L_i+1}, \\ldots, P_{R_i} \\) is **not** \\( P_{X_i} \\). Here, \\( L_i \\), \\( R_i \\), and \\( X_i \\) are integers given in the input.\n\n**Constraints:**\n\n1. \\( 1 \\leq N \\leq 500 \\)\n2. \\( 1 \\leq M \\leq 10^5 \\)\n3. \\( 1 \\leq L_i \\leq X_i \\leq R_i \\leq N \\)\n4. All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nL_1 R_1 X_1\nL_2 R_2 X_2\n\\vdots\nL_M R_M X_M\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n```\n3 2\n1 3 2\n1 2 1\n```\n\n**Sample Output 1:**\n```\n1\n```\nOnly one permutation, \\( P = (1, 2, 3) \\), satisfies the conditions.\n\n**Sample Input 2:**\n```\n5 1\n1 1 1\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n10 5\n3 8 4\n3 10 4\n1 7 2\n1 8 3\n3 8 7\n```\n\n**Sample Output 3:**\n```\n1598400\n```\n\n**Sample Input 4:**\n```\n15 17\n2 11 9\n2 15 13\n1 14 2\n5 11 5\n3 15 11\n1 6 2\n4 15 12\n3 11 6\n9 13 10\n2 14 6\n10 15 11\n1 8 6\n6 14 8\n2 10 2\n6 12 6\n3 14 12\n2 6 2\n```\n\n**Sample Output 4:**\n```\n921467228\n```\n\nSolution:\n\n        Here's a cleaned-up version of the editorial without excess content:\n\n---\n\n**C - Not Argmax Editorial by evima**\n\nDP is applied here. Let \\(dp[l][r]\\) denote the answer when considering only the interval \\([l,r]\\). We assume that when considering the interval \\([l,r]\\), only the intervals \\([L_i,R_i]\\) that satisfy \\(l \\leq L_i \\leq R_i \\leq r\\) are given as conditions. Without loss of generality, we can assume that the values of \\(P_l,\\cdots,P_r\\) range from \\(1\\) to \\(r-l+1\\). Let\u2019s consider how to calculate \\(dp[l][r]\\).\n\nWe will do a case-by-case analysis based on the position \\(m\\) of the maximum value of \\(P_l,\\cdots,P_r\\). If there is a condition with \\(X_i=m\\), then that \\(m\\) is invalid. Consider the case without one. First, the conditions that satisfy \\(L_i \\leq m \\leq R_i\\) can be ignored from this point onward. This reduces the problem to calculating \\(dp[l][m-1]\\) and \\(dp[m+1][r]\\). Thus, we obtain the transition for \\(dp\\).\n\nNote that, since there is flexibility in the allocation of value sets to the left and right sides, it is necessary to multiply by the binomial coefficient corresponding to this. This gives us an \\(O(N^3)\\) DP solution.\n\nHere, it is necessary to enumerate the prohibited \\(m\\) for each \\([l,r]\\), but checking the \\(M\\) conditions each time would take \\(O(N^2 M)\\) time, which is too slow. By fixing \\(l\\) and managing the positions of prohibited \\(m\\) while increasing \\(r\\), it takes \\(O(NM)\\) time in total, which is fast enough. The overall time complexity is \\(O(N^3+NM)\\).\n \n\n", "problem_ids": ["abc360_a", "abc371_d", "arc183_c"]}, "abc320_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of length \\(N\\). On this sequence, the following operation can be performed:\n\nChoose \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Replace each of \\(A_{l+1}, A_{l+2}, \\dots, A_{r-1}\\) with \\(A_l\\). The cost of this operation is \\(r-l-1\\).\n\nYou will repeat this operation until there is no \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Find the minimum total cost of such a series of operations.\n\n**Constraints:**\n- \\(3 \\leq N \\leq 5 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq N\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n7\n1 2 3 2 3 2 1\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n_For example, if you perform the operation with \\((l, r) = (3, 5), (2, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,3,3,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\), after which there is no \\(l\\) and \\(r\\) with the said property. The total cost of this series of operations is \\(1+3+5=9\\)._\n\n_On the other hand, if you perform the operation with \\((l, r) = (2, 4), (4, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,2,2,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\). The total cost of this series of operations is \\(1+1+5=7\\)._\n\n**Sample Input 2:**\n```\n5\n1 2 3 4 5\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n40\n1 2 3 4 5 6 7 8 7 6 5 6 7 8 7 6 5 4 3 2 2 1 2 3 4 5 4 5 6 7 8 7 7 6 5 6 6 7 8 8\n```\n\n**Sample Output 3:**\n```\n44\n```\n\nSolution:\n\n```\nHere's a cleaned-up version of the solution:\n\nStarting from a vertex with color \\(A_i\\) and a piece placed on it, create a tree with colored vertices by performing the following steps for \\(i=2,3,\\dots,N\\): Let \\(pos\\) be the current position. If the color of the vertex at \\(pos\\) is \\(A_i\\), do nothing. If there is an adjacent vertex to \\(pos\\) with color \\(A_i\\), move the piece there. If no such vertex exists, create a new adjacent vertex with color \\(A_i\\) and move the piece there. The colors of adjacent vertices are always distinct. \n\nThe state of the sequence corresponds to a walk on this tree, where operations change a walk \\(u\\rightarrow v\\rightarrow v\\rightarrow \\dots \\rightarrow v\\rightarrow u\\) to \\(u\\rightarrow u\\rightarrow u\\rightarrow \\dots \\rightarrow u\\rightarrow u\\). Let \\(start\\) and \\(goal\\) be the start and end points of the walk. The problem is finding the minimum cost to change the walk into a simple path connecting \\(start\\) and \\(goal\\). \n\nCalculate the minimum cost. Consider parts of the walk off the path connecting \\(start\\) and \\(goal\\), like \\(\\dots \\rightarrow a \\rightarrow b \\rightarrow \\dots \\rightarrow b \\rightarrow a \\rightarrow \\dots\\). Convert \\(b \\rightarrow \\dots \\rightarrow b\\) to stay at \\(a\\), with the cost equivalent to the sum of distances to \\(a\\). The problem becomes: \n\nGiven \\(V=(v_1,v_2,\\dots,v_n)\\) with:\n\n\\(v_1=1, v_n=\\max_{1\\leq i \\leq n} v_i\\)\n\\(|v_i-v_{i+1}| \\in \\{0,1\\}\\),\n\nFind the minimum \\(\\sum |v_i-v'_i|\\) for \\(V'=(v'_1,v'_2,\\dots,v'_n)\\) where:\n\n\\(v'_1=v_1, v'_n=v_n\\)\n\\(v'_i \\leq v'_{i+1}\\)\nIf \\(v'_i \\neq v'_{i+1}\\), then \\(v_i=v'_i\\) and \\(v_{i+1}=v'_{i+1}\\).\n\nSolve this using dynamic programming in \\(O(N)\\): \n\nUse \\(dp[k]=\\) the minimum value of \\(\\sum_{k \\leq i} |v_i-v'_i|\\) when \\(v'_k=v_k\\). If \\(v_{k+1}=v_k+1\\), update \\(dp[k] \\leftarrow \\min(dp[k],dp[k+1])\\). Let \\(k'\\) be the smallest \\(i\\ (k < i)\\) such that \\(v_{i}=v_k\\), then update \\(dp[k] \\leftarrow \\min(dp[k],dp[k']+\\sum_{i=k+1}^{k'}|v_k-v_i|)\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 900 points\n\nProblem Statement:\nWe have a long, thin piece of paper whose thickness can be ignored. We perform the following operation 100 times: lift the right end and fold it so that it aligns with the left end using the center as a crease. After completing the 100 folds, we unfold the paper back to its original state. At this point, there are \\(2^{100} - 1\\) creases on the paper, which can be classified into two types: mountain folds and valley folds. The figure below represents the state after performing the operation twice, where red solid lines represent mountain folds and red dashed lines represent valley folds.\n\nAbout mountain and valley folds:\n- A crease is a mountain fold if it is folded so that the back sides of the paper come together at the crease.\n- A crease is a valley fold if it is folded so that the front sides of the paper come together at the crease.\n\nYou are given a sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of N non-negative integers where \\(0 = A_1 < A_2 < \\dots < A_N \\leq 10^{18}\\).\n\nFor each integer \\(i\\) from 1 through \\(2^{100} - A_N - 1\\), define \\(f(i)\\) as follows:\n- The number of \\(k = 1, 2, \\dots, N\\) such that the \\((i + A_k)\\)-th crease from the left is a mountain fold.\n\nFind the maximum value among \\(f(1), f(2), \\dots, f(2^{100} - A_N - 1)\\).\n\nConstraints:\n- \\(1 \\leq N \\leq 10^3\\)\n- \\(0 = A_1 < A_2 < \\dots < A_N \\leq 10^{18}\\)\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\nOutput:\nPrint the answer in one line.\n\nSample Input 1:\n```\n4\n0 1 2 3\n```\n\nSample Output 1:\n```\n3\n```\n\nExplanation:\nIf mountain and valley folds are represented by M and V, respectively, there is a contiguous subsequence of creases like MMVM. There is no contiguous subsequence like MMMM, so the answer is 3.\n\nSample Input 2:\n```\n6\n0 2 3 5 7 8\n```\n\nSample Output 2:\n```\n4\n```\n\nSolution:\n\n```\nAtCoder Regular Contest 184 - C: Mountain and Valley Folds Editorial\n\nFirst, observe the structure of the creases. If we extract only the odd-numbered creases, the mountain and valley folds continue as VMVM.... If we extract only the even-numbered creases, this structure recurs. When grouping the creases based on the least significant bit that is 1 in the binary representation of their indices, each group forms a sequence like VMVM.... This can be proved using mathematical induction, among other methods, and is utilized in the solution.\n\nLet \\(f(a, k)\\) be the answer to the problem when taking \\(i\\) satisfying \\(i \\bmod 4 = k\\) for the sequence \\(a = (a_1, a_2, \\dots ,a_m)\\). When \\(k = 0, 2\\), the contribution to the answer from the odd elements of \\(a\\) is uniquely determined. When \\(k = 1, 3\\), the contribution from the even elements of \\(a\\) is uniquely determined, because the type (mountain or valley) of the fold at position \\(a_x + i\\) depends only on \\(i \\bmod 4\\).\n\nFor elements whose contribution is not uniquely determined\u2014namely, the even elements when \\(k = 0, 2\\), and the odd elements when \\(k = 1, 3\\)\u2014extract and divide them by \\(2\\) (rounded down) to form a sequence \\(b = (b_1, b_2, \\dots ,b_l)\\). The contribution of these elements is counted recursively as \\(\\max \\left( f\\left( b, \\left\\lceil \\frac{k}{2} \\right\\rceil \\right),\\ f\\left( b, \\left\\lceil \\frac{k}{2} \\right\\rceil + 2 \\right) \\right)\\). This recursive structure of the creases and the fact that 100 operations is sufficiently many in regard to the constraints make the approach viable.\n\nElements derived from a particular element of \\(A\\) appear in \\(a\\) at most \\(\\log_2 \\max A\\) times during recursion, making this solution efficient. With appropriate implementation, the computational complexity is \\(O(N \\log \\max A)\\).\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere is a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i,j)\\) denote the cell at the \\(i\\)-th row from the top and \\(j\\)-th column from the left. There are \\(N\\) coins on this grid, and the \\(i\\)-th coin can be picked up by passing through the cell \\((R_i,C_i)\\).\n\nYour goal is to start from cell \\((1,1)\\), repeatedly move either down or right by one cell, and reach cell \\((H,W)\\) while picking up as many coins as possible.\n\nFind the maximum number of coins you can pick up and one of the paths that achieves this maximum.\n\nConstraints:\n- \\(2 \\leq H, W \\leq 2 \\times 10^5\\)\n- \\(1 \\leq N \\leq \\min(HW-2, 2 \\times 10^5)\\)\n- \\(1 \\leq R_i \\leq H\\)\n- \\(1 \\leq C_i \\leq W\\)\n- \\((R_i, C_i) \\neq (1,1)\\)\n- \\((R_i, C_i) \\neq (H,W)\\)\n- \\((R_i, C_i)\\) are pairwise distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format: \n```\nH W N\nR_1 C_1\nR_2 C_2\n\u22ee\nR_N C_N\n```\n\nOutput:\nPrint two lines.\n- The first line should contain the maximum number of coins you can pick up.\n- The second line should contain one of the paths that achieves this maximum as a string of length \\(H+W-2\\). The \\(i\\)-th character of this string should be `D` if the \\(i\\)-th move is downward, and `R` if it is rightward.\n\nIf there are multiple paths that maximize the number of coins picked up, you may print any of them.\n\nSample Input 1:\n```\n3 4 4\n3 3\n2 1\n2 3\n1 4\n```\n\nSample Output 1:\n```\n3\nDRRDR\n```\nAs shown in the figure above, by moving \\((1,1)\\rightarrow (2,1)\\rightarrow (2,2)\\rightarrow (2,3)\\rightarrow (3,3)\\rightarrow (3,4)\\), you can pick up three coins at \\((2,1),(2,3),(3,3)\\).\n\nSample Input 2:\n```\n2 2 2\n2 1\n1 2\n```\n\nSample Output 2:\n```\n1\nDR\n```\nThe path `RD` is also acceptable.\n\nSample Input 3:\n```\n10 15 8\n2 7\n2 9\n7 9\n10 3\n7 11\n8 12\n9 6\n8 1\n```\n\nSample Output 3:\n```\n5\nDRRRRRRRRDDDDDRRDRDDRRR\n```\n\nSolution:\n\n```\nHere is the cleaned editorial without excess content unrelated to the solution:\n\n---\n\nLet us call the coin that can be collected by passing through square \\((r,c)\\) simply coin \\((r,c)\\). Given \\(k\\) coins \\((r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)\\), one can determine if there is a path that can collect all the coins as follows:\n\nSort the coins in ascending order of \\((r,c)\\). Here, \\((r_i, c_i) < (r_j, c_j) \\Leftrightarrow (r_i < r_j) \\lor (r_i = r_j \\land c_i < c_j)\\). Let \\(((r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k))\\) be the resulting sequence. There exists a path that can collect all the given \\(k\\) coins if and only if \\(c'_1 \\leq c'_2 \\leq \\dots \\leq c'_k\\).\n\nProof: If two coins $i$ and $j$ with $(r_i, c_i) < (r_j, c_j)$ are to be collected, coin $i$ has to be collected first. Thus, the $k$ coins $(r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)$ can be all collected if and only if the $k$ coins $(r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k)$ can be collected **in this order**. Given $(r_i, c_i) < (r_j, c_j)$, we have $(r_i \\leq r_j \\land c_i \\leq c_j) \\Leftrightarrow c_i \\leq c_j$, so the claim above has been shown.\n\nSuppose that the given \\(N\\) coins are sorted in ascending order of \\((r,c)\\). Then, by the fact above, this problem is boiled down to finding a longest (weakly) increasing subsequence (LIS). Given positive integer sequence \\(c=(c_1,c_2,\\dots,c_N)\\), one can find the length of a LIS of \\(c\\) (not its length) by the following famous algorithm:\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\). The length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\).\n\nIntuitively, each \\(d_j\\) manages the smallest last element of a length-\\(j\\) (weakly) increasing subsequence of \\(c_1,c_2,\\dots,c_i\\) (or \\(\\infty\\) if there is no such subsequence). To find an example of LIS instead of its length only, let us modify the algorithm as follows.\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Prepare a length-\\(N\\) sequence \\(\\text{id}\\) and \\(\\text{pre}\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\), and replace \\(\\text{id}_j\\) with \\(i\\). If \\(j > 1\\), replace \\(\\text{pre}_i\\) with \\(\\text{id}_{j-1}\\) too.\n\nThe length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\). Let \\(l\\) be the length of a LIS of \\(c\\). Consider a length-\\(l\\) sequence obtained by applying \\((l-1)\\) times the action \\(i\\mapsto \\text{pre}_i\\) to \\(\\text{id}_l\\), namely \\((\\text{id}_l, \\text{pre}_{\\text{id}_l},\\text{pre}_{\\text{pre}_{\\text{id}_l}},\\dots)\\). The reversal of this sequence is an example of a LIS of \\(c\\).\n\nThe fact that an example of LIS can be indeed obtained using this algorithm can be proved inductively. The complexity of this algorithm is \\(O(N\\log N)\\), same as the original algorithm. (To find the minimum \\(j\\) in step \\(3\\), use binary search.) Thus, the problem has been solved.\n\nSample code (Python3):\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    h, w, n = map(int, sys.stdin.readline().strip().split())\n    coins = []\n    for _ in range(n):\n        r, c = map(int, sys.stdin.readline().strip().split())\n        coins.append((r, c))\n    coins.sort()\n    dp = [float('inf')] * n\n    id_list = [-1] * n\n    pre = [0] * n\n    for i in range(n):\n        it = bisect_right(dp, coins[i][1])\n        dp[it] = coins[i][1]\n        id_list[it] = i\n        pre[i] = id_list[it - 1] if it else -1\n    m = n - 1\n    while id_list[m] == -1:\n        m -= 1\n    path = [(h, w)]\n    now = id_list[m]\n    while now != -1:\n        path.append(coins[now])\n        now = pre[now]\n    path.append((1, 1))\n    path.reverse()\n    s = []\n    for i in range(len(path) - 1):\n        d = path[i + 1][0] - path[i][0]\n        r = path[i + 1][1] - path[i][1]\n        s.append('D' * d + 'R' * r)\n    print(m + 1)\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["arc181_f", "arc184_c", "abc369_f"]}, "abc321_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\nYou are given a horizontally written text. Convert it to vertical writing, filling spaces with `*`.\n\nYou are given \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\) consisting of lowercase English letters. Let \\( M \\) be the maximum length of these strings.\n\nPrint \\( M \\) strings \\( T_1, T_2, \\dots, T_M \\) that satisfy the following conditions:\n\n1. Each \\( T_i \\) consists of lowercase English letters and `*`.\n2. Each \\( T_i \\) does not end with `*`.\n3. For each \\( 1 \\leq i \\leq N \\), the following holds:\n    - For each \\( 1 \\leq j \\leq |S_i| \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) exists, and the concatenation of the \\( (N-i+1) \\)-th characters of \\( T_1, T_2, \\dots, T_{|S_i|} \\) in this order equals \\( S_i \\).\n    - For each \\( |S_i| + 1 \\leq j \\leq M \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) either does not exist or is `*`.\n\nHere, \\( |S_i| \\) denotes the length of the string \\( S_i \\).\n\nConstraints:\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is a string of lowercase English letters with length between 1 and 100, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\nOutput:\nPrint the answer in the following format:\n```\nT_1\nT_2\n\u22ee\nT_M\n```\n\nSample Input 1:\n```\n3\nabc\nde\nfghi\n```\n\nSample Output 1:\n```\nfda\ngeb\nh*c\ni\n```\n\nSample Input 2:\n```\n3\natcoder\nbeginner\ncontest\n```\n\nSample Output 2:\n```\ncba\noet\nngc\ntio\nend\nsne\nter\n*r\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        First, ignore the condition that \\(T_i\\) does not end with *. Initialize \\(T_1,T_2,\\dots,T_M\\) with a length-\\(N\\) string of *. For each \\(i\\) and \\(j\\), assign the \\(j\\)-th character of \\(S_i\\) to the \\((N-i+1)\\)-th character of \\(T_j\\). To satisfy the second condition, for each \\(T_i\\), remove the last character while it ends with *. \n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(map(len, S))\nT = [[\"*\"] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i][-1] == \"*\":\n        T[i].pop()\n    print(\"\".join(T[i]))\n```\n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(len(s) for s in S)\nT = [['*'] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i] and T[i][-1] == '*':\n        T[i].pop()\n    print(''.join(T[i]))\n}\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a bottle of disinfectant that can disinfect exactly \\( M \\) hands. \\( N \\) aliens come one by one to disinfect their hands. The \\( i \\)-th alien (\\( 1 \\leq i \\leq N \\)) has \\( H_i \\) hands and wants to disinfect all of their hands once. Determine how many aliens can disinfect all of their hands. Here, even if there is not enough disinfectant left for an alien to disinfect all of their hands when they start, they will use up the remaining disinfectant.\n\n**Constraints**\n\n- \\( 1 \\leq N, M \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the number of aliens who can disinfect all of their hands.\n\n**Sample Input 1**\n\n```\n5 10\n2 3 2 5 3\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\n*Explanation:*\n\n1. The first alien disinfects their two hands. The remaining disinfectant can disinfect \\( 10-2=8 \\) hands.\n2. The second alien disinfects their three hands. The remaining disinfectant can disinfect \\( 8-3=5 \\) hands.\n3. The third alien disinfects their two hands. The remaining disinfectant can disinfect \\( 5-2=3 \\) hands.\n4. The fourth alien has five hands, but there is only enough disinfectant for three hands, so they use up the disinfectant without disinfecting all of their hands.\n\nThus, the first three aliens can disinfect all of their hands, so print 3.\n\n**Sample Input 2**\n\n```\n5 10\n2 3 2 3 5\n```\n\n**Sample Output 2**\n\n```\n4\n```\n\n**Sample Input 3**\n\n```\n1 5\n1\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\nAll aliens can disinfect their hands.\n\nSolution:\n\n[BEGIN TEXT]\nHere is the simplified version of the editorial:\n\nThe problem can be solved by simulating the remaining amount of disinfectant. Start from \\(M\\) and subtract \\(H_1, H_2, \\ldots, H_N\\) from it in order. If it never goes below \\(0\\), all aliens can disinfect their hands, and the answer is \\(N\\). If it becomes less than \\(0\\) for the first time when subtracting \\(H_i\\), the answer is \\(i-1\\). Ensure to use an appropriate conditional inequality to handle the case when the disinfectant is used up completely.\n\nSample code in Python:\n\n```python\nn, m = map(int, input().split())\nh = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n    m -= h[i]\n    if m >= 0:\n        ans += 1\nprint(ans)\n```\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nGiven integers \\(N\\) and \\(M\\), compute the sum \\(\\sum_{k=0}^{N} \\text{popcount}(k \\& M)\\), modulo \\(998244353\\).\n\nHere, \\(\\&\\) represents the bitwise AND operation.\n\n**What is the bitwise AND operation?**\n\nThe result \\(x = a \\& b\\) of the bitwise AND operation between non-negative integers \\(a\\) and \\(b\\) is defined as follows:\n\n- \\(x\\) is the unique non-negative integer that satisfies the following conditions for all non-negative integers \\(k\\):\n  - If the \\(2^k\\) place in the binary representation of \\(a\\) and \\(b\\) are both \\(1\\), then the \\(2^k\\) place in the binary representation of \\(x\\) is \\(1\\).\n  - Otherwise, the \\(2^k\\) place in the binary representation of \\(x\\) is \\(0\\).\n\nFor example, \\(3=11_{(2)}\\) and \\(5=101_{(2)}\\), so \\(3 \\& 5 = 1\\).\n\n**What is popcount?**\n\n\\(\\text{popcount}(x)\\) represents the number of \\(1\\)s in the binary representation of \\(x\\).\n\nFor example, \\(13=1101_{(2)}\\), so \\(\\text{popcount}(13) = 3\\).\n\n**Constraints:**\n\n- \\(N\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n- \\(M\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\n```\n\n**Output:**\n\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 3\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n- \\(\\text{popcount}(0 \\& 3) = 0\\)\n- \\(\\text{popcount}(1 \\& 3) = 1\\)\n- \\(\\text{popcount}(2 \\& 3) = 1\\)\n- \\(\\text{popcount}(3 \\& 3) = 2\\)\n- \\(\\text{popcount}(4 \\& 3) = 0\\)\n\nThe sum of these values is \\(4\\).\n\n**Sample Input 2:**\n```\n0 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\nIt is possible that \\(N = 0\\) or \\(M = 0\\).\n\n**Sample Input 3:**\n```\n1152921504606846975 1152921504606846975\n```\n\n**Sample Output 3:**\n```\n499791890\n```\n\nRemember to compute the result modulo \\(998244353\\).\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial presents the solution to a problem from AtCoder Beginner Contest 356, specifically the \"D - Masked Popcount\" problem. The goal is to compute the sum of set bits in the result of bitwise AND operations between each integer from 0 to N and a given integer M with the following steps:\n\n1. Iterate over each bit position \\( j \\) from 0 to 59.\n2. If the \\( j \\)-th bit of \\( M \\) is set, for each \\( j \\), add to the result the count of integers between 0 and N whose \\( j \\)-th bit is set.\n3. The number of integers with the \\( j \\)-th bit set is calculated by examining ranges defined by powers of two.\n4. During computation, handle overflow by taking results modulo 998244353.\n\nThe solution involves efficiently counting set bits using bit operations and properties of numbers, ensuring accurate summing even under large values.\n[END TEXT]\n \n\n", "problem_ids": ["abc366_b", "abc357_a", "abc356_d"]}, "abc321_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally.\n\nInitially, all vertices are painted white.\n\nTo efficiently visit all vertices of this tree, Alice has invented a magical gate. She uses one piece and one gate to travel according to the following procedure.\n\nFirst, she chooses a vertex and places both the piece and the gate on that vertex. Then, she repeatedly performs the following operations until all vertices are painted black.\n\nChoose one of the following actions:\n\n1. Paint the vertex where the piece is placed black.\n2. Choose a vertex adjacent to the vertex where the piece is placed and move the piece to that vertex. The cost of this action is 1.\n3. Move the piece to the vertex where the gate is placed.\n4. Move the gate to the vertex where the piece is placed.\n\nNote that only the second action incurs a cost.\n\nIt can be proved that it is possible to paint all vertices black in a finite number of operations. Find the minimum total cost required.\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- The given graph is a tree.\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nu_1 v_1\n\\vdots\nu_{N-1} v_{N-1}\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n4\n1 2\n1 3\n1 4\n```\n\n**Sample Output 1:**\n```\n3\n```\n\nHere is an example of Alice's procedure. Let \\((u, v)\\) denote the state where the piece is at vertex \\( u \\) and the gate is at vertex \\( v \\).\n\n- Place the piece and the gate at vertex 4.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 1.\n  - Vertex 4 is painted black.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 2 and move the piece to vertex 1.\n  - This costs 1.\n  - The state is now \\((1, 4)\\).\n\n- Perform action 1.\n  - Vertex 1 is painted black.\n\n- Perform action 4.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 2.\n  - This costs 1.\n  - The state is now \\((2, 1)\\).\n\n- Perform action 1.\n  - Vertex 2 is painted black.\n\n- Perform action 3.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 3.\n  - This costs 1.\n  - The state is now \\((3, 1)\\).\n\n- Perform action 1.\n  - Vertex 3 is painted black.\n  - All vertices are now painted black, so the procedure ends.\n\nThe total cost of performing action 2 is 3, and there is no procedure with a smaller cost.\n\n**Sample Input 2:**\n```\n10\n1 7\n7 10\n10 8\n8 3\n8 4\n10 9\n9 6\n9 5\n7 2\n```\n\n**Sample Output 2:**\n```\n10\n```\n\nSolution:\n\n```\nHere is the cleaned version:\n\nEditorial - AtCoder Regular Contest 179\n\nD - Portable Gate Editorial by evima\n\nWhen moving the gate, it can be considered to move simultaneously with the piece. We will perform operation 1 as needed and consider the following operations:\n\nOperation A: When the piece and the gate are on the same vertex, move both the piece and the gate to an adjacent vertex. Operation B: Move the piece to an adjacent vertex. Operation C: Move the piece to the vertex where the gate is located.\n\nOperations A and B each incur a cost of 1. Once operation B is performed, the gate remains in its position until operation C is performed. It's inefficient to move the piece to the gate using operation B, so we will not consider this.\n\nLet \\(v\\) be the initial position of the piece and gate. By performing operation C at the end, the process ends when the piece and the gate are on the same vertex. Label the vertices and edges the gate moves to with A, and the rest with B. The vertices and edges labeled A form a connected subgraph, or subtree A. Vertex \\(v\\) is included in subtree A. Edges labeled B with one endpoint as A are boundary edges.\n\nVertices and edges labeled B not connected to boundary edges form connected components. Each component is a tree connected to a vertex in subtree A by a boundary edge \\(e_i\\). Let them form subtree \\(B_i\\), connected to vertex \\(l_i\\) in A.\n\nKey points:\n\n1. In optimal operations, assume edges labeled A are not traversed by operation B. By rearranging operations, the cost does not increase:\n\n   - The piece and gate start from \\(v\\), visit all vertices in A using operation A, and return to \\(v\\). This is the journey in A.\n   - If \\(l_i\\) is visited during A's journey, it's interrupted. The piece starts from \\(l_i\\), visits all vertices in \\(B_i\\) using operation B, and returns to \\(l_i\\). This is the journey in \\(B_i\\). The gate stays at \\(l_i\\).\n\n2. Assume moving along boundary edge \\(e_i\\) occurs only once in B's journey. If done more than once, moving with the gate using operation A during the first move and returning does not increase the cost. In \\(B_i\\)'s journey, operation C is done once at the end.\n\n3. In the journeys of A and \\(B_i\\), the farthest vertex is visited last. If the distance from start to the farthest vertex is \\(d\\) and the number of edges is \\(m\\), the cost is \\(2m - d\\).\n\nThe total number of edges in subtrees is \\(N-1\\). Minimize cost by maximizing \\(d\\)'s total sum. Calculate for fixed \\(v\\) using tree DP. Maintain:\n\n- Maximum distance to vertex where \\(B_i\\)'s journey ends, assuming \\(u = l_i\\).\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex in \\(u\\)'s subtree.\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex not in \\(u\\)'s subtree.\n\nExtend to rerooting DP to examine all possible starting vertices. Time complexity \\(\\mathrm{O}(N)\\).\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi attempted to type a string \\( S \\) consisting of lowercase English letters using a keyboard. He typed while looking only at the keyboard, not the screen. Whenever he mistakenly typed a different lowercase English letter, he immediately pressed the backspace key. However, since the backspace key was broken, the mistakenly typed letter was not deleted, resulting in the actual string \\( T \\). He did not mistakenly press any keys other than those for lowercase English letters. The characters in \\( T \\) that were not mistakenly typed are called correctly typed characters.\n\nYour task is to determine the positions in \\( T \\) of the correctly typed characters.\n\n**Constraints:**\n\n- \\( S \\) and \\( T \\) are strings of lowercase English letters with lengths between 1 and \\( 2 \\times 10^5 \\), inclusive.\n- \\( T \\) is a string obtained by the procedure described.\n\n**Input:**\n\nThe input is given in the following format:\n\n\\( S \\)  \n\\( T \\)\n\n**Output:**\n\nLet \\(|S|\\) be the length of \\( S \\). If the correctly typed characters are the \\( A_1 \\)-th, \\( A_2 \\)-th, \\(\\ldots\\), \\( A_{|S|} \\)-th characters of \\( T \\), print the values of \\( A_1, A_2, \\ldots, A_{|S|} \\) in this order, separated by spaces. Ensure that the output is in ascending order, i.e., \\( A_i < A_{i + 1} \\) should hold for each \\( 1 \\leq i \\leq |S| - 1 \\).\n\n**Sample Input 1:**\n\n```\nabc\naxbxyc\n```\n\n**Sample Output 1:**\n\n```\n1 3 6\n```\n\n**Sample Input 2:**\n\n```\naaaa\nbbbbaaaa\n```\n\n**Sample Output 2:**\n\n```\n5 6 7 8\n```\n\n**Sample Input 3:**\n\n```\natcoder\natcoder\n```\n\n**Sample Output 3:**\n\n```\n1 2 3 4 5 6 7\n```\nIn Sample 1, the sequence of Takahashi's typing is as follows:\n\n1. Type `a`.\n2. Try to type `b` but mistakenly type `x`.\n3. Press the backspace key, but the character is not deleted.\n4. Type `b`.\n5. Try to type `c` but mistakenly type `x`.\n6. Press the backspace key, but the character is not deleted.\n7. Try to type `c` but mistakenly type `y`.\n8. Press the backspace key, but the character is not deleted.\n9. Type `c`.\n\nThe correctly typed characters are the first, third, and sixth characters.\n\nSolution:\n\n        [BEGIN TEXT]\n        Maintain a variable to manage how many first characters of \\(S\\) have been typed while scanning the characters of \\(T\\).\n\n```python\nn, m = 0, 0\ns, t = input(), input()\nn = len(s)\nm = len(t)\na = [0] * n\nj = 0\nfor i in range(m):\n    if s[j] == t[i]:\n        a[j] = i + 1\n        j += 1\nfor i in range(n):\n    print(a[i], end=\" \\n\" if i == n - 1 else \" \")\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\n", "problem_ids": ["arc179_d", "abc352_b", "abc355_g"]}, "abc321_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} (A_i \\oplus A_{i+1} \\oplus \\ldots \\oplus A_j) \\]\n\n**Notes on Bitwise XOR:**\n\nThe bitwise XOR of non-negative integers \\( A \\) and \\( B \\), denoted as \\( A \\oplus B \\), is defined as follows:\n\n- In the binary representation of \\( A \\oplus B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) position is 1 if and only if exactly one of the digits at the \\( 2^k \\) position in the binary representations of \\( A \\) and \\( B \\) is 1; otherwise, it is 0.\n\nFor example, \\( 3 \\oplus 5 = 6 \\) (in binary: \\( 011 \\oplus 101 = 110 \\)).\n\nIn general, the bitwise XOR of \\( k \\) integers \\( p_1, \\dots, p_k \\) is defined as \\( (\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k) \\). It can be proved that this is independent of the order of \\( p_1, \\dots, p_k \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n1 3 2\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n**Explanation:**\n\n\\( A_1 \\oplus A_2 = 2 \\), \\( A_1 \\oplus A_2 \\oplus A_3 = 0 \\), and \\( A_2 \\oplus A_3 = 1 \\), so the answer is \\( 2 + 0 + 1 = 3 \\).\n\n**Sample Input 2:**\n\n```\n7\n2 5 6 5 2 1 7\n```\n\n**Sample Output 2:**\n\n```\n83\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\nE - Xor Sigma Problem Editorial by en_translator\n\nIt is often effective to consider bitwise independently for a problem regarding XOR (exclusive logical sum). For each \\(j=0,1,\\ldots,27\\), define a sequence \\(B\\) of length \\(N\\) such that \\(B_i=1\\) if the \\(j\\)-th bit of \\(A_i\\) is \\(1\\) and \\(B_i=0\\) if it is \\(0\\). Solve the problem against \\(B\\) for each \\(j\\), and the total sum of the answers multiplied by \\(2^j\\) is the solution to the original problem. This simplifies the problem as \\(B\\) takes only zero or one, as opposed to \\(A\\) taking variable values.\n\nNext, the expression \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j)\\) requires the total XOR of a segment. This can be computed fast using cumulative XORs, similar to cumulative sums when computing the total sum on a segment. Define the array of cumulative XORs \\(C\\) by \\(C_0=0\\) and \\(C_i =B_1\\oplus \\ldots \\oplus B_i\\). Then \\(B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j = C_{i-1} \\oplus C_j\\).\n\nThe expression can be rewritten as follows:\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (C_{i-1} \\oplus C_j)  = \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j). \\]\n\nAdjusting the index \\(j\\) to start from \\(i+1\\):\n\\[ \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=0}^{N-1} (C_i\\oplus C_{i+1}) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=1}^{N} B_i. \\]\n\nNow \\(\\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j)\\) is the number of pairs of elements in \\(C\\) with different values, which equals the product of the number of occurrences of \\(0\\) and \\(1\\) in \\(C\\). Thus, the sought value can be evaluated with the total sum of \\(B\\) and the number of occurrences of \\(0\\) and \\(1\\) in the cumulative XORs. The problem is solved in \\(\\mathrm{O}(N \\log {\\mathrm{MAX_A}})\\) time.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers of length \\( N \\): \\( A = (A_1, A_2, \\ldots, A_N) \\) and \\( B = (B_1, B_2, \\ldots, B_N) \\).\n\nYou are given \\( Q \\) queries to process in order. The \\( i \\)-th query is explained below:\n\n- You are given positive integers \\( l_i, r_i, L_i, R_i \\). Print \"Yes\" if it is possible to rearrange the subsequence \\( (A_{l_i}, A_{l_i+1}, \\ldots, A_{r_i}) \\) to match the subsequence \\( (B_{L_i}, B_{L_i+1}, \\ldots, B_{R_i}) \\), and \"No\" otherwise.\n\n**Constraints**\n\n- \\( 1 \\leq N, Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq l_i \\leq r_i \\leq N \\)\n- \\( 1 \\leq L_i \\leq R_i \\leq N \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nl_1 r_1 L_1 R_1\nl_2 r_2 L_2 R_2\n\\vdots\nl_Q r_Q L_Q R_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n\n```\n5 4\n1 2 3 2 4\n2 3 1 4 2\n1 3 1 3\n1 2 3 5\n1 4 2 5\n1 5 1 5\n```\n\n**Sample Output 1**\n\n```\nYes\nNo\nNo\nYes\n```\n\n**Explanation**\n\n- For the 1st query, it is possible to rearrange \\( (1, 2, 3) \\) to match \\( (2, 3, 1) \\). Hence, we print \"Yes\".\n- For the 2nd query, it is impossible to rearrange \\( (1, 2) \\) in any way to match \\( (1, 4, 2) \\). Hence, we print \"No\".\n- For the 3rd query, it is impossible to rearrange \\( (1, 2, 3, 2) \\) in any way to match \\( (3, 1, 4, 2) \\). Hence, we print \"No\".\n- For the 4th query, it is possible to rearrange \\( (1, 2, 3, 2, 4) \\) to match \\( (2, 3, 1, 4, 2) \\). Hence, we print \"Yes\".\n\n**Sample Input 2**\n\n```\n4 4\n4 4 4 4\n4 4 4 4\n1 2 2 3\n3 3 1 1\n1 3 1 4\n1 4 2 3\n```\n\n**Sample Output 2**\n\n```\nYes\nYes\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe problem requires processing queries to check if \\(\\{A_l,A_{l+1},\\ldots,A_r\\}\\) coincides with \\(\\{B_L,B_{L+1},\\ldots,B_R\\}\\) as a multiset. A method for this involves using Zobrist Hashing to determine set equivalence. The hash function \\(H\\) should meet these requirements: \n\n1. Compute \\(H(S)\\) of a multiset quickly.\n2. If two multisets \\(S\\) and \\(T\\) are equal, then \\(H(S)=H(T)\\).\n3. If \\(S\\) and \\(T\\) are not equal, then \\(H(S)\\neq H(T)\\) with high probability.\n\nTo implement this, assign a hash value to each integer between \\(1\\) and \\(N\\), and define the hash function of \\(S\\) as the sum of its element hash values, modulo \\(P\\) (a large prime). Precalculate cumulative sums of hash values to compute the hash of subsequences in \\(O(1)\\) time. Hence, the total time complexity is \\(O(N+Q)\\).\n\n```python\nimport random\nmod = (1 << 61) - 1\n\nN, Q = map(int, input().split())\nA = list(map(lambda x: int(x) - 1, input().split()))\nB = list(map(lambda x: int(x) - 1, input().split()))\n\nhash = [random.randint(1, mod - 1) for i in range(N)]\ncumA = [0] * (N + 1)\ncumB = [0] * (N + 1)\nfor i in range(N):\n    cumA[i + 1] = (cumA[i] + hash[A[i]]) % mod\n    cumB[i + 1] = (cumB[i] + hash[B[i]]) % mod\n\nfor i in range(Q):\n    l, r, L, R = map(int, input().split())\n    if (cumA[r] - cumA[l - 1]) % mod == (cumB[R] - cumB[L - 1]) % mod:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n[END TEXT]\n \n\n", "problem_ids": ["abc355_g", "abc365_e", "abc367_f"]}, "abc321_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 450 points\n\n## Problem Statement\n\nThere are \\( N \\) islands and \\( M \\) bidirectional bridges connecting two islands. The islands and bridges are numbered \\( 1, 2, \\ldots, N \\) and \\( 1, 2, \\ldots, M \\), respectively. Bridge \\( i \\) connects islands \\( U_i \\) and \\( V_i \\), and the time it takes to cross it in either direction is \\( T_i \\). No bridge connects an island to itself, but it is possible for two islands to be directly connected by more than one bridge. One can travel between any two islands using some bridges.\n\nYou are given \\( Q \\) queries, so answer each of them. The \\( i \\)-th query is as follows:\n\n- You are given \\( K_i \\) distinct bridges: bridges \\( B_{i,1}, B_{i,2}, \\ldots, B_{i,K_i} \\).\n- Find the minimum time required to travel from island \\( 1 \\) to island \\( N \\) using each of these bridges at least once.\n- Only consider the time spent crossing bridges.\n- You can cross the given bridges in any order and in any direction.\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 400 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq T_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 3000 \\)\n- \\( 1 \\leq K_i \\leq 5 \\)\n- \\( 1 \\leq B_{i,1} < B_{i,2} < \\cdots < B_{i,K_i} \\leq M \\)\n- All input values are integers.\n- It is possible to travel between any two islands using some bridges.\n\n## Input\n\nThe input is given in the following format:\n```\nN M\nU_1 V_1 T_1\nU_2 V_2 T_2\n\u22ee\nU_M V_M T_M\nQ\nK_1\nB_{1,1} B_{1,2} \u22ef B_{1,{K_1}}\nK_2\nB_{2,1} B_{2,2} \u22ef B_{2,{K_2}}\n\u22ee\nK_Q\nB_{Q,1} B_{Q,2} \u22ef B_{Q,{K_Q}}\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq Q \\)) should contain the answer to the \\( i \\)-th query as an integer.\n\n## Sample Input 1\n\n```\n3 5\n1 2 10\n1 3 20\n1 3 30\n2 3 15\n2 3 25\n2\n1\n1\n2\n3 5\n```\n\n## Sample Output 1\n\n```\n25\n70\n```\n\nExplanation:\n- For the first query, the minimum time to travel from island 1 to island 3 using bridge 1 is achieved by using bridge 1 to move from island 1 to island 2, then bridge 4 to move from island 2 to island 3. The time taken is 10 + 15 = 25.\n- For the second query, the minimum time to travel from island 1 to island 3 using both bridges 3 and 5 is achieved by using bridge 3 to move from island 1 to island 3, then using bridge 5 to move to island 2, and finally bridge 4 to return to island 3. The time taken is 30 + 25 + 15 = 70.\n\n## Sample Input 2\n\n```\n6 6\n1 5 1\n2 5 1\n2 4 1\n3 4 1\n3 6 1\n1 6 1\n2\n5\n1 2 3 4 5\n1\n5\n```\n\n## Sample Output 2\n\n```\n5\n3\n```\n\nRemarks: You can cross the specified bridges in either direction.\n\n## Sample Input 3\n\n```\n5 5\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4 5 1000000000\n1 5 1000000000\n1\n1\n3\n```\n\n## Sample Output 3\n\n```\n4000000000\n```\n\nNote: The answer may not fit in a 32-bit integer.\n\nSolution:\n\n```python\nimport itertools\n\nN = 400\nM = int(2e5)\nINF = int(1e15)\n\nn = 0\nu = [0] * M\nv = [0] * M\nt = [0] * M\nd = [[0 if i == j else INF for j in range(N)] for i in range(N)]\nk = 0\na = []\n\ndef solve():\n    ans = INF\n    dp = [[0] * 2 for _ in range(5)]\n    b = list(range(k))\n    for perm in itertools.permutations(b):\n        dp[0][0] = d[0][v[a[perm[0]]]] + t[a[perm[0]]]\n        dp[0][1] = d[0][u[a[perm[0]]]] + t[a[perm[0]]]\n        for i in range(k - 1):\n            dp[i + 1][0] = min(dp[i][0] + d[u[a[perm[i]]]][v[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][v[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n            dp[i + 1][1] = min(dp[i][0] + d[u[a[perm[i]]]][u[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][u[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n        ans = min(ans, dp[k-1][0] + d[u[a[perm[k-1]]]][n-1])\n        ans = min(ans, dp[k-1][1] + d[v[a[perm[k-1]]]][n-1])\n    return ans\n\ndef main():\n    global n, k\n    m, q = map(int, input().split())\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d[i][j] = INF\n\n    for i in range(m):\n        u[i], v[i], t[i] = map(int, input().split())\n        u[i] -= 1\n        v[i] -= 1\n        d[u[i]][v[i]] = min(d[u[i]][v[i]], t[i])\n        d[v[i]][u[i]] = min(d[v[i]][u[i]], t[i])\n\n    for i1 in range(n):\n        for i0 in range(n):\n            for i2 in range(n):\n                d[i0][i2] = min(d[i0][i2], d[i0][i1] + d[i1][i2])\n    \n    for _ in range(q):\n        k = int(input())\n        a.clear()\n        for _ in range(k):\n            x = int(input())\n            a.append(x-1)\n        print(solve())\n\nif __name__ == '__main__':\n    main()\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( A \\), \\( B \\), \\( X \\), \\( Y \\), and \\( N \\). The following conditions are guaranteed:\n\n- \\( A < B \\)\n- \\(\\gcd(A, B) = 1\\)\n- \\( 1 \\leq N \\leq A+B-1 \\)\n\nFor an integer \\( n \\), define \\( f(n) \\) as follows: You start with an integer \\( x = 0 \\). \\( f(n) \\) is the minimum total cost to achieve \\( x = n \\) by repeatedly performing the following operations:\n\n- Replace the value of \\( x \\) with \\( x + A \\). The cost of this operation is \\( X \\).\n- Replace the value of \\( x \\) with \\( x - A \\). The cost of this operation is \\( X \\).\n- Replace the value of \\( x \\) with \\( x + B \\). The cost of this operation is \\( Y \\).\n- Replace the value of \\( x \\) with \\( x - B \\). The cost of this operation is \\( Y \\).\n\nIt can be proved from the constraints on \\( A \\) and \\( B \\) that \\( f(n) \\) is defined for any integer \\( n \\).\n\nFind the value of \\( \\sum_{1 \\leq n \\leq N} f(n) \\), modulo \\( 998244353 \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 1000 \\)\n- \\( 1 \\leq A < B \\leq 10^9 \\)\n- \\(\\gcd(A, B) = 1\\)\n- \\( 1 \\leq X, Y \\leq 10^9 \\)\n- \\( 1 \\leq N \\leq A + B - 1 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nA B X Y N\n```\n\n**Output**\n\nPrint the answer for each test case.\n\n**Sample Input**\n\n```\n4\n1 2 1 1 2\n3 5 2 4 6\n79 85 72 95 4\n80980429 110892168 22712439 520643153 66132787\n```\n\n**Sample Output**\n\n```\n2\n34\n18111\n785776602\n```\n\nIn the first test case, \\( f(1) = 1 \\) and \\( f(2) = 1 \\).\n\nIn the second test case, \\( f(1) = 8 \\), \\( f(2) = 6 \\), \\( f(3) = 2 \\), \\( f(4) = 10 \\), \\( f(5) = 4 \\), and \\( f(6) = 4 \\).\n\nSolution:\n\n        The solution discusses how to find the shortest path in an operation sequence defined by integers \\(A, B, C, N\\), and elements \\(AX, AY, BX, BY\\) of a monoid \\(M\\). The problem focuses on modifying an integer \\(x\\) initially set to 0 and updating elements \\(cur\\) and \\(ans\\) in \\(M\\) over \\(N\\) operations. The operations are performed based on whether \\(x\\) is less than \\(B\\) or not, adjusting \\(ans\\) with products involving \\(AX, AY, BX, BY\\). The approach leverages a cycle structure of moves to ensure optimal paths, achieved through combinations of operations that mimic mathematical floor functions. Solutions are designed to work efficiently, leveraging logarithmic complexity relative to \\(A + B\\).\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a string \\( S \\) consisting of lowercase English letters. You are also given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- A string \\( T_i \\) consisting of lowercase English letters is given. Print the number of substrings of \\( S \\) that equal \\( T_i \\). Two substrings are distinguished if they are taken from different positions, even if they are equal as strings.\n\n**Constraints:**\n\n- \\( 1 \\leq |S| \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq |T_i| \\leq |S| \\)\n- \\( \\displaystyle \\sum_{i=1}^Q |T_i| \\leq 5 \\times 10^5 \\)\n- \\( S \\) and \\( T_i \\) are strings consisting of lowercase English letters.\n- \\( Q \\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nS\nQ\nT_1\nT_2\n...\nT_Q\n```\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n```\nmissisippi\n5\ni\ns\na\nis\nmissisippi\n```\n\n**Sample Output 1:**\n```\n4\n3\n0\n2\n1\n```\n\nLet \\( S[l:r] \\) denote the substring of \\( S \\) from the \\( l \\)-th character through the \\( r \\)-th character.\n\nFor the 1st query, four substrings of \\( S \\) equal `i`: \\( S[2:2], S[5:5], S[7:7], S[10:10] \\).\n\nFor the 2nd query, three substrings of \\( S \\) equal `s`: \\( S[3:3], S[4:4], S[6:6] \\).\n\nFor the 3rd query, no substrings of \\( S \\) match `a`.\n\nFor the 4th query, two substrings of \\( S \\) equal `is`: \\( S[2:3], S[5:6] \\).\n\nFor the 5th query, one substring of \\( S \\) equals `missisippi`: \\( S[1:10] \\).\n\n**Sample Input 2:**\n```\naaaaaa\n6\na\naa\naaa\naaaa\naaaaa\naaaaaa\n```\n\n**Sample Output 2:**\n```\n6\n5\n4\n3\n2\n1\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - Toyota Programming Contest 2024#7\uff08AtCoder Beginner Contest 362\uff09\n\nG - Count Substring Query Editorial\nby en_translator\n\nLet ~ be a character lexicographically larger than any lowercase English letter. The query asks the number of, among \\(S[1:],S[2:],\\ldots,S[N:]\\), the strings with a prefix \\(T\\). Denoting by \\(T'\\) the string \\(T\\) followed by ~, the count equals the number of \\(i\\) with \\(T\\leq S[i:]\\leq T'\\). By precalculating \\(S[1:],S[2:],\\ldots,S[N:]\\) sorted in lexicographical order (as known as the suffix array) and performing a binary search on this sequence, one can find the number of \\(i\\) with \\(T\\leq S[i:]\\leq T'\\) fast. The complexity for the construction of the suffix array and for each query is \\(O(|S|)\\) and \\(O(|T|\\log |S|)\\), respectively.\n\n```python\nfrom atcoder.string import suffix_array\n\nS = input()\nSA = suffix_array(S)\n\ndef binary_search(T):\n    ng, ok = -1, len(S)\n    while ok - ng > 1:\n        mid = (ng + ok) // 2\n        l = SA[mid]\n        if T <= S[l : l + len(T)]:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nQ = int(input())\nfor _ in range(Q):\n    T = input()\n    print(binary_search(T + \"~\") - binary_search(T))\n```\n\n(Bonus) A standard feature of a language may help implement it concisely.\n```python\nfrom atcoder.string import suffix_array\nimport bisect\n\nS = input()\nSA = suffix_array(S)\n\nQ = int(input())\nfor _ in range(Q):\n    T = input()\n    l = bisect.bisect_left(SA, T, key=lambda x: S[x : x + len(T)])\n    r = bisect.bisect(SA, T, key=lambda x: S[x : x + len(T)])\n    print(r - l)\n```\n[END TEXT]\n \n\n", "problem_ids": ["abc369_e", "arc183_f", "abc362_g"]}, "abc321_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 650 points\n\nProblem Statement:\nThere is a special grid with \\( N \\) rows. (\\( N \\) is even.) The \\( i \\)-th row from the top has \\(\\left \\lceil \\frac{i}{2} \\right \\rceil \\times 2\\) cells from the left end. For example, when \\( N = 6 \\), the grid looks like the following:\n\nLet \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Each cell is either an empty cell or a wall cell. There are \\( M \\) wall cells, and the \\( i \\)-th wall cell is \\((a_i, b_i)\\). Here, \\((1, 1)\\) and \\((N, N)\\) are empty.\n\nStarting from \\((1, 1)\\), how many ways are there to reach \\((N, N)\\) by repeatedly moving right or down to an adjacent empty cell? Find the count modulo 998244353.\n\nConstraints:\n- \\( 2 \\leq N \\leq 2.5 \\times 10^5 \\)\n- \\( N \\) is even.\n- \\( 0 \\leq M \\leq 50 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- \\( 1 \\leq b_i \\leq \\left \\lceil \\frac{a_i}{2} \\right \\rceil \\times 2 \\)\n- \\((a_i, b_i) \\neq (1, 1)\\) and \\((a_i, b_i) \\neq (N, N)\\).\n- \\((a_i, b_i) \\neq (a_j, b_j)\\) if \\( i \\neq j \\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\na_1 b_1\na_2 b_2\n...\na_M b_M\n```\n\nOutput:\nPrint the number of ways to reach \\((N, N)\\) from \\((1, 1)\\) by repeatedly moving right or down to an adjacent empty cell, modulo 998244353.\n\nSample Input 1:\n```\n4 2\n2 1\n4 2\n```\nSample Output 1:\n```\n2\n```\nThere are two paths that satisfy the conditions of the problem:\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (3, 4) \\to (4, 4)\\)\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (4, 3) \\to (4, 4)\\)\n\nSample Input 2:\n```\n6 3\n2 1\n3 3\n4 2\n```\nSample Output 2:\n```\n0\n```\n\nSample Input 3:\n```\n100 10\n36 9\n38 5\n38 30\n45 1\n48 40\n71 52\n85 27\n86 52\n92 34\n98 37\n```\nSample Output 3:\n```\n619611437\n```\n\nSample Input 4:\n```\n100000 10\n552 24\n4817 255\n7800 954\n23347 9307\n28028 17652\n39207 11859\n48670 22013\n74678 53158\n75345 45891\n88455 4693\n```\nSample Output 4:\n```\n175892766\n```\n\nSolution:\n\nSure, here is the editorial with all code translated to Python3:\n\n```python\ndef g(a, b):\n    \"\"\"Calculate the number of shortest paths from a to b.\"\"\"\n    # This function implementation depends on the specific grid configuration\n    pass\n\ndef calculate_dp_and_x(wall_squares, grid_size):\n    \"\"\"Calculate dp values and the sought count X using the wall squares.\"\"\"\n    S = wall_squares\n    N, M = grid_size\n    \n    # Initialize dp with base values\n    w = [(1, 1)] + S + [(N, N)]\n    dp = [0] * (len(S) + 2)\n    dp[0] = 1\n    \n    # Fill dp array according to the derived relations\n    for i in range(1, len(S) + 2):\n        dp_i_sum = sum(g(w[j], w[i]) * dp[j] for j in range(i))\n        dp[i] = -dp_i_sum\n    \n    # Calculate the sought count X\n    X = -dp[len(S) + 1]\n    \n    return X\n\n# Example usage\noriginal_wall_squares = []  # Replace with actual coordinates of original wall squares\ncalculate_dp_and_x(original_wall_squares, (N, M))\n```\n\nNote: In the provided code, `g(a, b)` is a placeholder function that needs actual implementation based on the specific problem constraints. The function `calculate_dp_and_x` calculates the dp values and the sought count `X` using the dynamic programming approach described in the editorial.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nIn the Kingdom of AtCoder, the eldest son is always given the name Taro. No one else is given the name Taro. The eldest son is the earliest born male child in each family.\n\nThere are \\(N\\) families in the Kingdom, and \\(M\\) babies were born. Before the \\(M\\) babies were born, none of the \\(N\\) families had had any babies.\n\nInformation about the babies is given in chronological order of their birth. The \\(i\\)-th baby born was born in family \\(A_i\\), and the baby is male if \\(B_i\\) is \\(M\\), and female if it is \\(F\\).\n\nDetermine for each of the \\(M\\) babies whether the name given is Taro.\n\nConstraints:\n- \\(1 \\leq N, M \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- \\(B_i\\) is \\(M\\) or \\(F\\).\n- All numbers in the input are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\nOutput:\nPrint \\(M\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq M)\\) should contain `Yes` if the name given to the \\(i\\)-th baby is Taro, and `No` otherwise.\n\nSample Input 1:\n```\n2 4\n1 M\n1 M\n2 F\n2 M\n```\n\nSample Output 1:\n```\nYes\nNo\nNo\nYes\n```\n\nExplanation of Sample Output 1:\n- The first baby is the earliest born boy in family 1, so he is named Taro.\n- The second baby is not the earliest born boy in family 1, so he is not named Taro.\n- The third baby is a girl, so she is not named Taro.\n- The fourth baby is the earliest born **boy** in family 2, so he is named Taro. Note that the third baby is also born in family 2, but it is the earliest born boy who is named Taro.\n\nSample Input 2:\n```\n4 7\n2 M\n3 M\n1 F\n4 F\n4 F\n1 F\n2 M\n```\n\nSample Output 2:\n```\nYes\nYes\nNo\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Beginner Contest 371\n\nB - Taro Editorial by en_translator\n\nMaintain a flag to manage whether each family had had Taro already. The flags are initialized with False. Inspect the babies in order. If the baby is a girl, print No, and nothing more is required. If the baby is a boy, check the flag of his family. If the flag is False, print Yes, and set the flag to True. If the flag is already True, print No. The operations so far can be implemented with for statements, if statements, and arrays.\n\nSample code (Python):\n```python\nn, m = map(int, input().split())\ntaro_exist = [False for i in range(n)]\nfor i in range(m):\n    a, b = input().split()\n    a = int(a) - 1\n    if b == 'F' or taro_exist[a]:\n        print('No')\n    else:\n        taro_exist[a] = True\n        print('Yes')\n```\n\n[END TEXT]\n \n\n", "problem_ids": ["abc366_e", "abc357_g", "abc371_b"]}, "abc322_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a bottle of disinfectant that can disinfect exactly \\( M \\) hands. \\( N \\) aliens come one by one to disinfect their hands. The \\( i \\)-th alien (\\( 1 \\leq i \\leq N \\)) has \\( H_i \\) hands and wants to disinfect all of their hands once. Determine how many aliens can disinfect all of their hands. Here, even if there is not enough disinfectant left for an alien to disinfect all of their hands when they start, they will use up the remaining disinfectant.\n\n**Constraints**\n\n- \\( 1 \\leq N, M \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the number of aliens who can disinfect all of their hands.\n\n**Sample Input 1**\n\n```\n5 10\n2 3 2 5 3\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\n*Explanation:*\n\n1. The first alien disinfects their two hands. The remaining disinfectant can disinfect \\( 10-2=8 \\) hands.\n2. The second alien disinfects their three hands. The remaining disinfectant can disinfect \\( 8-3=5 \\) hands.\n3. The third alien disinfects their two hands. The remaining disinfectant can disinfect \\( 5-2=3 \\) hands.\n4. The fourth alien has five hands, but there is only enough disinfectant for three hands, so they use up the disinfectant without disinfecting all of their hands.\n\nThus, the first three aliens can disinfect all of their hands, so print 3.\n\n**Sample Input 2**\n\n```\n5 10\n2 3 2 3 5\n```\n\n**Sample Output 2**\n\n```\n4\n```\n\n**Sample Input 3**\n\n```\n1 5\n1\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\nAll aliens can disinfect their hands.\n\nSolution:\n\n[BEGIN TEXT]\nHere is the simplified version of the editorial:\n\nThe problem can be solved by simulating the remaining amount of disinfectant. Start from \\(M\\) and subtract \\(H_1, H_2, \\ldots, H_N\\) from it in order. If it never goes below \\(0\\), all aliens can disinfect their hands, and the answer is \\(N\\). If it becomes less than \\(0\\) for the first time when subtracting \\(H_i\\), the answer is \\(i-1\\). Ensure to use an appropriate conditional inequality to handle the case when the disinfectant is used up completely.\n\nSample code in Python:\n\n```python\nn, m = map(int, input().split())\nh = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n    m -= h[i]\n    if m >= 0:\n        ans += 1\nprint(ans)\n```\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), a non-negative integer \\( C \\), and an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nFind \\( \\displaystyle \\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace \\).\n\n**Constraints**\n\n- \\( 1 \\le N \\le 10^5 \\)\n- \\( 1 \\le M \\le 10^9 \\)\n- \\( 0 \\le C < M \\)\n- \\( 1 \\le K \\le 10^9 \\)\n- \\( 0 \\le A_i < M \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M C K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 5 3 3\n1 3\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nFor \\( k=0 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=3 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=1 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=2 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=2 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=2 \\).\n\nTherefore, the answer is \\( 1+1+2=4 \\). Hence, print 4.\n\n**Sample Input 2**\n\n```\n5 4 3 182\n0 3 2 1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Sample Input 3**\n\n```\n5 718 651 193855\n3 532 44 109 58\n```\n\n**Sample Output 3**\n\n```\n29484897\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 182\n\nE - Sum of Min of Mod of Linear Editorial\n\nAs a prerequisite, you need the floor_sum algorithm. This algorithm calculates \\(\\displaystyle f(n,m,a,b)=\\sum_{i=0}^{n-1}\\left\\lfloor\\frac{ai+b}m\\right\\rfloor\\) in \\(O(\\log m)\\) time.\n\nLet\u2019s assume that \\(A\\) has been sorted and duplicates removed so that \\(A_1 < A_2 < ... < A_N\\) holds. Fix \\(j\\), and let \\(S_j\\) be the set of \\(0\\le k < K\\) such that \\(\\displaystyle \\left\\{(Ck+A_j)\\ \\text{mod}\\ M\\right\\}=\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M\\right\\}\\). If \\(j\\geq 2\\), the condition for \\(k\\in S_j\\) can be rephrased as \\(\\left\\{(Ck+A_{j-1})\\ \\text{mod}\\ M \\right\\} > \\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\), and further as \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor=1\\). Since \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\) can only be \\(0\\) or \\(1\\), we have \\(\\displaystyle |S_j|=\\sum_{k=0}^{K-1}\\left(\\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\right)\\).\n\nTherefore,\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{k \\in S_j}\\left(\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\} - \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\right)\\\\\n&=\\sum_{k \\in S_j} (A_j-A_1-M)\\\\\n&=-(M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\nMeanwhile, for \\(j=1\\), we have\n\\[\n\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=0\n\\]\n\nThus, the answer is\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k\\in S_j}\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\} -\\sum_{j=2}^N(M+A_1-A_j)|S_j|\\\\\n&=\\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}-\\sum_{j=2}^N (M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\n\\(\\displaystyle \\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=\\sum_{k=0}^{K-1}\\left(Ck+A_1-M\\left\\lfloor\\frac{Ck+A_1}M \\right\\rfloor\\right)\\) and \\(|S_j|\\) can both be calculated quickly using the floor_sum algorithm.\n\nNow, the problem is solved. The complexity is \\(O(N(\\log N+\\log M))\\), with the bottlenecks being the sorting of \\(A\\) and the calculation of floor_sum. Be careful with overflow during implementation. You can avoid this issue by using multi-precision integers, 128-bit integers, or by using a modint with two different primes (e.g., \\(10^9+7\\) and \\(10^9+9\\)) and reconstructing the result using CRT. Alternatively, you can use a type like C++\u2019s unsigned long long, which guarantees that the correct value modulo \\(2^{64}\\) is returned even in case of overflow. The AtCoder Library\u2019s floor_sum uses unsigned long long and guarantees the correct answer modulo \\(2^{64}\\).\n\nSample Implementation (Python3):\n```python\nfrom atcoder.math import floor_sum\nn, m, c, k = map(int, input().split())\na = sorted(list(set(map(int, input().split()))))\nn = len(a)\nfl = [floor_sum(k, m, c, a[i]) for i in range(n)]\nans = c * k * (k - 1) // 2 + k * a[0] - m * fl[0]\nfor i in range(1, n):\n  ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\nprint(ans)\n```\n\nSample Implementation (Python3, translated from C++):\n```python\nfrom atcoder.math import floor_sum\n\ndef main():\n    n, m, c, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a = list(dict.fromkeys(a))\n    n = len(a)\n    fl = [floor_sum(k, m, c, a[i]) for i in range(n)]\n    ans = k * (k - 1) // 2 * c + k * a[0] - m * fl[0]\n    for i in range(1, n):\n        ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\n    print(ans)\n\nmain()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nN people work at the AtCoder office. The office keeps records of entries and exits, and there have been M such entries and exits since the records began. \n\nEach record is represented by a pair of integers (T_i, P_i), indicating that at time T_i, the P_i-th person either entered the office if they were outside, or exited the office if they were inside. It is known that all people were outside the office at the beginning of the records, and they are outside now.\n\nYou need to answer Q queries in the following format:\n\nFor the i-th query, you are given a pair of integers (A_i, B_i). Find the total length of the periods during which both the A_i-th and B_i-th persons were inside the office since the records began.\n\n**Constraints:**\n- 2 \u2264 N \u2264 2 \u00d7 10^5\n- 2 \u2264 M \u2264 2 \u00d7 10^5\n- 1 \u2264 T_1 < T_2 < ... < T_M \u2264 10^9\n- 1 \u2264 P_i \u2264 N (1 \u2264 i \u2264 M)\n- For every 1 \u2264 p \u2264 N, the number of indices i such that P_i = p is even.\n- 1 \u2264 Q \u2264 2 \u00d7 10^5\n- 1 \u2264 A_i < B_i \u2264 N (1 \u2264 i \u2264 Q)\n- All inputs are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN M\nT_1 P_1\nT_2 P_2\n...\nT_M P_M\nQ\nA_1 B_1\nA_2 B_2\n...\nA_Q B_Q\n```\n\n**Output:**\nPrint Q lines. The i-th line should contain the answer to the i-th query.\n\n**Sample Input 1:**\n```\n3 8\n10 1\n20 2\n30 1\n40 3\n60 3\n70 1\n80 2\n90 1\n3\n1 2\n1 3\n2 3\n```\n\n**Sample Output 1:**\n```\n20\n0\n20\n```\n\nThe following diagram shows the time each of the three people spent inside the office. The answers to each query are as follows:\n- The 1st and 2nd persons were both inside the office from time 20 to 30 and from time 70 to 80. The lengths of these two periods are both 10, so print the total, which is 20.\n- The 1st and 3rd persons were never inside the office at the same time, so print 0.\n- The 2nd and 3rd persons were both inside the office from time 40 to 60. The length of this period is 20, so print 20.\n\n**Sample Input 2:**\n```\n10 20\n10257 9\n10490 4\n19335 1\n25893 5\n32538 9\n33433 3\n38522 9\n40629 9\n42896 5\n52106 1\n53024 3\n55610 5\n56721 9\n58286 9\n63128 3\n70513 3\n70977 4\n74936 5\n79883 9\n95116 9\n7\n1 3\n3 9\n1 9\n4 9\n1 5\n5 9\n3 5\n```\n\n**Sample Output 2:**\n```\n18673\n2107\n15310\n25720\n17003\n10317\n16848\n```\n\nSolution:\n\n```python\n# Editorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\n# Official Solution: G - AtCoder Office Editorial by en_translator\n\n# To solve the problem, we need to determine intervals where each person was in the office and apply different algorithms based on the size of these intervals \\(S _ i\\). A threshold \\(C\\) is set to choose the appropriate algorithm.\n\n# 1. **Small Sets:** If both \\(S _ A\\) and \\(S _ B\\) have sizes less than \\(C\\), process the intervals in ascending order of their left ends. This approach finds answers in \\(O(C)\\) time.\n\n# 2. **Large Sets:** If at least one of \\(S _ A\\) or \\(S _ B\\) is large (i.e., size \\(\\geq C\\)), precompute answers for these indices. This precomputation requires \\(O\\left(\\dfrac{MN}C\\right)\\) time with \\(O\\left(\\dfrac{N^2}C\\right)\\) memory and allows queries to be answered in \\(O(1)\\) time.\n\n# The overall time complexity is \\(O\\left(QC+\\dfrac{MN}C\\right)\\), and choosing \\(C=O\\left(\\sqrt{\\dfrac{MN}Q}\\right)\\) optimizes the complexity to \\(O(\\sqrt{QMN})\\).\n\n# Sample Code:\nfrom collections import defaultdict\nfrom itertools import accumulate\n\ndef main():\n    N, M = map(int, input().split())\n    records = [tuple(map(int, input().split())) for _ in range(M)]\n    records = [(T, P - 1) for T, P in records]\n    \n    inside_office = [[] for _ in range(N)]\n    in_ = [0] * N\n    for T, P in records:\n        if in_[P]:\n            inside_office[P].append((in_[P], T))\n            in_[P] = 0\n        else:\n            in_[P] = T\n    \n    large_limit = 1000\n    memo = defaultdict(int)\n    \n    for i, Si in enumerate(inside_office):\n        if len(Si) > large_limit:\n            sum_ = [0] * N\n            prev_i = 0\n            i_sum = 0\n            i_inside = False\n            for T, P in records:\n                if P == i:\n                    i_sum += i_inside * (T - prev_i)\n                    prev_i = T\n                    i_inside = not i_inside\n                sum_[P] = i_sum + i_inside * (T - prev_i) - sum_[P]\n            for j in range(N):\n                memo[min(i, j), max(i, j)] = sum_[j]\n    \n    def query(a, b):\n        if (a, b) in memo:\n            return memo[(a, b)]\n        Sa = inside_office[a]\n        Sb = inside_office[b]\n        if not Sa or not Sb:\n            memo[(a, b)] = 0\n            return 0\n        ans = 0\n        i = 0\n        for l, r in Sa:\n            while i < len(Sb) and Sb[i][1] <= l:\n                i += 1\n            if i < len(Sb):\n                aux = max(0, min(Sb[i][1], r) - max(Sb[i][0], l))\n                ans += aux if Sb[i][0] < r else 0\n            while i + 1 < len(Sb) and Sb[i + 1][0] <= r:\n                i += 1\n                ans += max(0, min(Sb[i][1], r) - Sb[i][0])\n        memo[(a, b)] = ans\n        return ans\n    \n    Q = int(input())\n    for _ in range(Q):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        print(query(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc357_a", "arc182_e", "abc365_g"]}, "abc322_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) intervals of real numbers. The \\( i \\)-th (\\( 1 \\leq i \\leq N \\)) interval is \\([l_i, r_i]\\). Find the number of pairs \\((i, j)\\) (\\( 1 \\leq i < j \\leq N \\)) such that the \\( i \\)-th and \\( j \\)-th intervals intersect.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 5 \\times 10^5 \\)\n- \\( 0 \\leq l_i < r_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nl_1 r_1\nl_2 r_2\n\u22ee\nl_N r_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n1 5\n7 8\n3 7\n```\n\n**Sample Output 1**\n```\n2\n```\n*Explanation*: The given intervals are \\([1,5], [7,8], [3,7]\\). Among these, the 1st and 3rd intervals intersect, as well as the 2nd and 3rd intervals, so the answer is 2.\n\n**Sample Input 2**\n```\n3\n3 4\n2 5\n1 6\n```\n\n**Sample Output 2**\n```\n3\n```\n\n**Sample Input 3**\n```\n2\n1 2\n3 4\n```\n\n**Sample Output 3**\n```\n0\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Inspecting all pairs of segments to check if they intersect has a time complexity of \\(O(N^2)\\), which exceeds the execution time limit. Instead, we find the number of disjoint segments \\(x\\) and subtract it from \\(N(N-1)/2\\). For each segment \\(i\\), count \\(j\\) such that \\(r_j < l_i\\) using a sliding window technique. Sort the sequences \\(L\\) and \\(R\\) obtained from \\(l_i\\) and \\(r_i\\) respectively. For each \\(i\\), find the number \\(c_i\\) of \\(j\\) such that \\(R_j < L_i\\) by leveraging the property \\(c_i\\leq c_{i+1}\\). This optimization results in a time complexity of \\(O(N)\\), allowing the algorithm to run efficiently.\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere are three brothers named A, B, and C. The age relationships among them are specified by three characters: \\( S_{\\mathrm{AB}} \\), \\( S_{\\mathrm{AC}} \\), and \\( S_{\\mathrm{BC}} \\). The meanings of these characters are as follows:\n\n- If \\( S_{\\mathrm{AB}} \\) is '<', then A is younger than B; if it is '>', then A is older than B.\n- If \\( S_{\\mathrm{AC}} \\) is '<', then A is younger than C; if it is '>', then A is older than C.\n- If \\( S_{\\mathrm{BC}} \\) is '<', then B is younger than C; if it is '>', then B is older than C.\n\nYou need to determine who the middle brother is, meaning the one who is the second oldest among the three.\n\n**Constraints:**\n\n- Each of \\( S_{\\mathrm{AB}}, S_{\\mathrm{AC}}, S_{\\mathrm{BC}} \\) is either '<' or '>'.\n- The input contains no contradictions, which means there will always be a valid age relationship that satisfies all provided inequalities.\n\n**Input**\n\nThe input is provided from standard input in the following format:\n\n```\nS_{\\mathrm{AB}} S_{\\mathrm{AC}} S_{\\mathrm{BC}}\n```\n\n**Output**\n\nPrint the name of the middle brother, who is the second oldest among the three.\n\n**Sample Input 1**\n```\n< < <\n```\n\n**Sample Output 1**\n```\nB\n```\n\nExplanation: Since A is younger than B, and B is younger than C, we conclude that C is the oldest, B is the middle, and A is the youngest. Hence, the answer is B.\n\n**Sample Input 2**\n```\n< < >\n```\n\n**Sample Output 2**\n```\nC\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial:\n\n---\n\nFor beginners:\n\nIf you are new to programming and do not know where to start, please try Problem A \"Welcome to AtCoder\" from the practice contest. There you can find sample code for each language. If you are not familiar with problems in programming contests, we recommend you try some problems in \"AtCoder Beginners Selection\". There are C++ and Python tutorials for competitive programmers in Japanese.\n\nProblem A Solution:\n\nThis problem has various solutions. One solution is to implement a conditional branch for all the eight possible inputs (among which six are consistent and can actually be the input). This can be done with an if statement, but it\u2019s a bit cumbersome. Here is a bit cleverer solution:\n\nIf \\(S_\\mathrm{AB}\\neq S_\\mathrm{AC}\\): A is the middle son.  \nOtherwise, if \\(S_\\mathrm{AB}= S_\\mathrm{BC}\\): B is the middle son.  \nOtherwise: C is the middle son.\n\nThe following sample code implements the simple casework in Python:\n\n```python\na, b, c = input().strip()\n\nif a != b:\n    print(\"A\")\nelif a == c:\n    print(\"B\")\nelse:\n    print(\"C\")\n```\n\n \n\n", "problem_ids": ["abc355_d", "abc355_g", "abc371_a"]}, "abc322_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 350 points\n\nProblem Statement:\n\nThe coordinate plane is covered with 2\u00d71 tiles. The tiles are laid out according to the following rules:\n\n- For an integer pair (i, j), the square \\(A_{i,j} = \\{(x, y) \\mid i \\leq x \\leq i+1 \\wedge j \\leq y \\leq j+1\\}\\) is contained in one tile.\n- When i + j is even, \\(A_{i,j}\\) and \\(A_{i+1,j}\\) are contained in the same tile.\n\nTiles include their boundaries, and no two different tiles share a positive area.\n\nNear the origin, the tiles are laid out as follows:\n\n![Tile Layout Image](https://img.atcoder.jp/abc359/7ab121cd550fa78b43845d4ffd7f74b3.png)\n\nTakahashi starts at the point (S_x + 0.5, S_y + 0.5) on the coordinate plane. He can repeat the following move as many times as he likes:\n\n- Choose a direction (up, down, left, or right) and a positive integer n. Move n units in that direction.\n\nEach time he enters a tile, he pays a toll of 1.\n\nFind the minimum toll he must pay to reach the point (T_x + 0.5, T_y + 0.5).\n\nConstraints:\n- 0 \u2264 S_x \u2264 2 \u00d7 10^16\n- 0 \u2264 S_y \u2264 2 \u00d7 10^16\n- 0 \u2264 T_x \u2264 2 \u00d7 10^16\n- 0 \u2264 T_y \u2264 2 \u00d7 10^16\n- All input values are integers.\n\nInput:\n\nThe input is given from Standard Input in the following format:\n```\nS_x S_y\nT_x T_y\n```\n\nOutput:\n\nPrint the minimum toll Takahashi must pay.\n\nSample Input 1:\n```\n5 0\n2 5\n```\n\nSample Output 1:\n```\n5\n```\n\nFor example, Takahashi can pay a toll of 5 by moving as follows:\n\n![Movement Image](https://img.atcoder.jp/abc359/187d19c48a9a0fcedb2602063689ee77.png)\n\n- Move left by 1. Pay a toll of 0.\n- Move up by 1. Pay a toll of 1.\n- Move left by 1. Pay a toll of 0.\n- Move up by 3. Pay a toll of 3.\n- Move left by 1. Pay a toll of 0.\n- Move up by 1. Pay a toll of 1.\n\nIt is impossible to reduce the toll to 4 or less, so print 5.\n\nSample Input 2:\n```\n3 1\n4 1\n```\n\nSample Output 2:\n```\n0\n```\n\nThere are cases where no toll needs to be paid.\n\nSample Input 3:\n```\n2552608206527595 5411232866732612\n771856005518028 7206210729152763\n```\n\nSample Output 3:\n```\n1794977862420151\n```\n\nNote that the value to be output may exceed the range of a 32-bit integer.\n\nSolution:\n\n```\nHere is the cleaned-up version of the editorial:\n\n---\n\nFor simplicity, we may assume that the start and goal are in the left half of a tile. If \\(S_x + S_y\\) is odd, subtract \\(1\\) from \\(S_x\\). One can travel freely between the left and right halves, so traveling from the left half of one tile to another is a complete move. By paying a toll of \\(1\\), one can make either of these two moves:\n\n1. Move by \\(1\\) vertically and by \\(1\\) horizontally.\n2. Move by \\(2\\) horizontally.\n\nSuppose one could travel from \\((S_x, S_y)\\) to \\((T_x, T_y)\\) by making the first move \\(a\\) times and the second \\(b\\) times. The following conditions must hold:\n\n\\(\\lvert S_y - T_y \\rvert \\leq a\\)\n\n\\(\\lvert S_x - T_x \\rvert \\leq a + 2b\\)\n\n\\(a > 0\\) or \\(S_x - T_x \\equiv 2b \\pmod{4}\\)\n\nConversely, if a pair of non-negative integers \\((a, b)\\) satisfies these conditions, then one can make the specified moves to travel from \\((S_x, S_y)\\) to \\((T_x, T_y)\\).\n\nWe aim to minimize the toll \\(a + b\\) while respecting \\((0 \\leq a, 0 \\leq b)\\) and the above conditions. With \\(0 \\leq b\\) and \\(\\lvert S_y - T_y \\rvert \\leq a\\), it is necessary that \\(\\lvert S_y - T_y \\rvert \\leq a + b\\). \n\nAdditionally, \\(\\frac{\\lvert S_x - T_x \\rvert + \\lvert S_y - T_y \\rvert}{2} \\leq a + b\\).\n\nConversely, \\((a, b) = \\left( \\lvert S_y - T_y \\rvert, \\max\\left\\lbrace 0, \\frac{\\lvert S_x - T_x \\rvert - \\lvert S_y - T_y \\rvert}{2} \\right\\rbrace \\right)\\) always satisfies all the conditions, thus ensuring one or both equations hold as an equality.\n\nHence, the minimum toll is:\n\n\\[\\max\\left\\lbrace \\lvert S_y - T_y \\rvert, \\frac{\\lvert S_x - T_x \\rvert + \\lvert S_y - T_y \\rvert}{2} \\right\\rbrace = \\frac{\\lvert S_y - T_y \\rvert + \\max \\lbrace \\lvert S_x - T_x \\rvert, \\lvert S_y - T_y \\rvert \\rbrace}{2}\\].\n\nBelow is the sample code:\n\n```python\nSx, Sy = map(int, input().split())\nTx, Ty = map(int, input().split())\n\nif (Sx + Sy) % 2 == 1:\n    Sx -= 1\nif (Tx + Ty) % 2 == 1:\n    Tx -= 1\n\nDx = abs(Sx - Tx)\nDy = abs(Sy - Ty)\n\nprint((Dy + max(Dx, Dy)) // 2)\n```\n\n---\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nN AtCoder users have gathered to play AtCoder RPS 2. The i-th user's name is \\( S_i \\) and their rating is \\( C_i \\).\n\nAtCoder RPS 2 is played as follows:\n1. Assign the numbers \\( 0, 1, \\dots, N - 1 \\) to the users in lexicographical order of their usernames.\n2. Let \\( T \\) be the sum of the ratings of the N users. The user assigned the number \\( T \\mod N \\) is the winner.\n\nPrint the winner's username.\n\n**What is lexicographical order?**\n\nLexicographical order, simply put, means \"the order in which words appear in a dictionary.\" More precisely, the algorithm to determine the order of two distinct strings \\( S \\) and \\( T \\) consisting of lowercase English letters is as follows:\n\n- If \\( S \\) is lexicographically smaller than \\( T \\), we write \\( S < T \\), and if \\( S \\) is larger, we write \\( S > T \\).\n1. Let \\( L \\) be the length of the shorter string among \\( S \\) and \\( T \\). Check if \\( S_i \\) and \\( T_i \\) match for \\( i = 1, 2, \\dots, L \\).\n2. If there exists an \\( i \\) such that \\( S_i \\neq T_i \\), let \\( j \\) be the smallest such \\( i \\). Compare \\( S_j \\) and \\( T_j \\). If \\( S_j \\) is alphabetically smaller than \\( T_j \\), then \\( S < T \\). Otherwise, \\( S > T \\). The algorithm ends here.\n3. If there is no \\( i \\) such that \\( S_i \\neq T_i \\), compare the lengths of \\( S \\) and \\( T \\). If \\( S \\) is shorter than \\( T \\), then \\( S < T \\). If \\( S \\) is longer, then \\( S > T \\). The algorithm ends here.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( S_i \\) is a string consisting of lowercase English letters with length between 3 and 16, inclusive.\n- \\( S_1, S_2, \\dots, S_N \\) are all distinct.\n- \\( 1 \\leq C_i \\leq 4229 \\)\n- \\( C_i \\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN\nS_1 C_1\nS_2 C_2\n\\vdots\nS_N C_N\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n```\n3\ntakahashi 2\naoki 6\nsnuke 5\n```\n\n**Sample Output 1:**\n```\nsnuke\n```\n\n*Explanation:*\nThe sum of the ratings of the three users is 13. Sorting their names in lexicographical order yields aoki, snuke, takahashi, so aoki is assigned number 0, snuke is 1, and takahashi is 2. Since \\( 13 \\mod 3 = 1 \\), print snuke, who is assigned number 1.\n\n**Sample Input 2:**\n```\n3\ntakahashi 2813\ntakahashixx 1086\ntakahashix 4229\n```\n\n**Sample Output 2:**\n```\ntakahashix\n```\n\nSolution:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nSolution:\nMost mainstream programming languages provide lexicographical comparison of strings as a function in the standard library or a language feature. With this feature, implementation will be simple. For example in Python, the < operator compares strings in lexicographical order. The total rating \\(T\\) of the users can be found using a for loop. Then one can find \\(T \\bmod N\\) to find the index of the winner. Also, one has to find the number assigned to each user. This can be done by sorting the user\u2019s name in lexicographical order. Most languages provide a sorting function, which enables us concise implementation.\n\nThe complexity of sorting strings:\nLet \\(\\displaystyle M = \\sum_{i=1}^{N} |S_i| \\). With merge sort, the complexity is \\(O(M \\log N)\\). This is due to the fact that lexicographical comparison of two strings \\(a\\) and \\(b\\) can be done in \\(O(\\min(|a|, |b|))\\) time. In Python, the sorted function uses Timsort, which runs in \\(O(n \\log n)\\) time, where n is the number of elements which are being sorted; it performs well for string comparison. It can also be solved in \\(O(M)\\) time using SA-IS for example.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\(N\\) and a prime \\(P\\).\n\nWe call a sequence of \\(N\\) intervals \\(([L_1,R_1],[L_2,R_2], \\ldots, [L_N,R_N])\\) **good** if and only if both of the following conditions are satisfied:\n\n1. \\(1 \\leq L_i \\leq R_i \\leq N\\) holds for all \\(1 \\leq i \\leq N\\).\n2. There exists a **unique** permutation \\(x = (x_1, x_2, \\ldots, x_N)\\) of \\((1, 2, \\ldots, N)\\) such that \\(L_i \\leq x_i \\leq R_i\\) holds for all \\(1 \\leq i \\leq N\\).\n\nCount the number of **good** sequences of intervals, modulo \\(P\\).\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 5000\\)\n- \\(10^9 < P < 1.01 \\times 10^9\\)\n- \\(P\\) is a prime number.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1005488041\n```\n\n**Sample Output 1**\n\n```\n6\n```\n\nThe following 6 sequences are good:\n1. \\(([1,1],[2,2])\\)\n2. \\(([1,2],[2,2])\\)\n3. \\(([1,1],[1,2])\\)\n4. \\(([2,2],[1,1])\\)\n5. \\(([2,2],[1,2])\\)\n6. \\(([1,2],[1,1])\\)\n\n**Sample Input 2**\n\n```\n5 1005488041\n```\n\n**Sample Output 2**\n\n```\n102960\n```\n\n**Sample Input 3**\n\n```\n100 1005488041\n```\n\n**Sample Output 3**\n\n```\n47599495\n```\n\n**Sample Input 4**\n\n```\n1000 1005488041\n```\n\n**Sample Output 4**\n\n```\n632708165\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Grand Contest 067\n\nD - Unique Matching Editorial by Kubic\n\nObviously, the intervals \\([l_i,r_i]\\) are distinct. So we can just let \\(x_i=i\\) and finally multiply the answer by \\(n!\\). Consider the uniqueness of bipartite graph matching. Fix a perfect matching; it is equivalent to not existing augmenting cycles. We claim that \\(l,r\\) is good if and only if there isn\u2019t \\(i,j\\) such that \\(1\\le i<j\\le n,r_i\\ge j,l_j\\le i\\). It means there is no cycle of length \\(2\\). Moreover, it can be proven that there will be no cycle under this condition. View \\(l\\) as constraints on \\(r\\), \\(\\forall l_i\\le j<i\\), then \\(r_j<i\\) must hold. Let \\(a_i=\\min\\limits_{l_j\\le i<j}j\\) (if \\(j\\) doesn\u2019t exist, then \\(a_i=n+1\\)). We need to calculate the sum of \\(\\prod (a_i-i)\\) for all possible sequences of \\(l\\). Fixing \\(a\\), we consider the number of \\(l\\) that generates \\(a\\). The main idea is to consider all maximums of \\(a\\) and divide \\(a\\) into several independent parts. Let \\(f_{i,j}\\) denote the answer when only considering \\([i,j]\\), requiring all \\(a_i\\dots a_j\\le j+1\\), with \\(l_{j+1}\\) determined (\\(l_{j+1}<i\\)). Let \\(g_{i,j}\\) denote the answer when \\(l_{j+1}\\) is undetermined (\\(l_{j+1}\\ge i\\)). Particularly, \\(f_{i+1,i}=g_{i+1,i}=1\\). The final answer is \\(f_{1,n}\\). Find the smallest \\(k\\) such that \\(i\\le k\\le j\\) and \\(a_k=j+1\\) (obviously \\(a_j=j+1\\), then such \\(k\\) exists). Now, \\([i,k-1]\\) and \\([k+1,j]\\) are independent subproblems. Thus, we have:\n\n```python\ndef f_i_j(i, j):\n    return sum((j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n\ndef g_i_j(i, j):\n    return sum((k - i + 1) * (j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n```\n\nFurthermore, \\(f_{i,j}\\) is only related to \\(j-i+1\\), thus it can be rewritten as follows:\n\n```python\ndef f_i(i):\n    return sum((i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n\ndef g_i(i):\n    return sum(j * (i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n```\n\nBrute force runs in \\(O(n^2)\\) and is allowed to pass. DC & FFT solution runs in \\(O(n\\log^2 n)\\).\n[END TEXT]\n \n\n", "problem_ids": ["abc359_c", "abc354_b", "agc067_d"]}, "abc322_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\). You are also given \\(Q\\) queries to process in order. There are three types of queries:\n\n1. `1 l r x`: Add \\(x\\) to each of \\(A_l, A_{l+1}, \\ldots, A_r\\).\n2. `2 l r x`: Add \\(x\\) to each of \\(B_l, B_{l+1}, \\ldots, B_r\\).\n3. `3 l r`: Print the remainder of \\(\\sum_{i=l}^r (A_i \\times B_i)\\) when divided by 998244353.\n\n**Constraints:**\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(0 \\leq A_i, B_i \\leq 10^9\\)\n- \\(1 \\leq l \\leq r \\leq N\\)\n- \\(1 \\leq x \\leq 10^9\\)\n- All input values are integers.\n- There is at least one query of the third type.\n\n**Input:**\n\nThe input is given from Standard Input in the following format. Here, \\(\\text{query}_i (1 \\leq i \\leq Q)\\) is the \\(i\\)-th query to be processed.\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n\\text{query}_1\n\\text{query}_2\n\\vdots\n\\text{query}_Q\n```\n\nEach query is given in one of the following formats:\n\n```\n1 l r x\n```\n\n```\n2 l r x\n```\n\n```\n3 l r\n```\n\n**Output:**\n\nIf there are \\(K\\) queries of the third type, print \\(K\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq K)\\) should contain the output for the \\(i\\)-th query of the third type.\n\n**Sample Input 1:**\n\n```\n5 6\n1 3 5 6 8\n3 1 2 1 2\n3 1 3\n1 2 5 3\n3 1 3\n1 1 3 1\n2 5 5 2\n3 1 5\n```\n\n**Sample Output 1:**\n\n```\n16\n25\n84\n```\n\nInitially, \\(A = (1, 3, 5, 6, 8)\\) and \\(B = (3, 1, 2, 1, 2)\\). The queries are processed in the following order:\n\n1. For the first query, print \\((1 \\times 3) + (3 \\times 1) + (5 \\times 2) = 16\\) modulo 998244353, which is 16.\n2. For the second query, add 3 to \\(A_2, A_3, A_4, A_5\\). Now \\(A = (1, 6, 8, 9, 11)\\).\n3. For the third query, print \\((1 \\times 3) + (6 \\times 1) + (8 \\times 2) = 25\\) modulo 998244353, which is 25.\n4. For the fourth query, add 1 to \\(A_1, A_2, A_3\\). Now \\(A = (2, 7, 9, 9, 11)\\).\n5. For the fifth query, add 2 to \\(B_5\\). Now \\(B = (3, 1, 2, 1, 4)\\).\n6. For the sixth query, print \\((2 \\times 3) + (7 \\times 1) + (9 \\times 2) + (9 \\times 1) + (11 \\times 4) = 84\\) modulo 998244353, which is 84.\n\nThus, the first, second, and third lines should contain 16, 25, and 84, respectively.\n\n**Sample Input 2:**\n\n```\n2 3\n1000000000 1000000000\n1000000000 1000000000\n3 1 1\n1 2 2 1000000000\n3 1 2\n```\n\n**Sample Output 2:**\n\n```\n2716070898\n151723988\n```\n\nMake sure to print the sum modulo 998244353 for the third type of query.\n\nSolution:\n\n[BEGIN TEXT]\nConsider solving this problem using a lazy segment tree. For details on lazy segment trees, please refer to other editorials and the AtCoder Library explanation. Specifically, for each segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) for integers \\(a,k\\geq 0\\) and \\(2^k(a+1)\\leq N\\), we want to manage the sum of \\(A_i\\times B_i\\) within the segment, and apply addition to \\(A_i\\) and \\(B_i\\) fast enough (in \\(O(1)\\) time). The set of actions consists of \u201cadding \\(x\\) to each element of \\(A\\) and \\(y\\) to that of \\(B\\) (within the segment)\u201d for all integers \\(x\\) and \\(y\\). \n\nFor a segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) (where \\(L=a\\cdot2^k+1\\) and \\(R=(a+1)2^k\\)), it is insufficient to store the values \\(\\sum_{i=L}^R (A_i\\times B_i)\\) for each segment. Instead, manage the length \\((R-L+1)\\), and three kinds of sum: \\(\\sum_{i=L}^R A_i\\), \\(\\sum_{i=L}^R B_i\\), and \\(\\sum_{i=L}^R (A_i\\times B_i)\\), for each segment. Then, one can update the value \\(\\sum_{i=L}^R (A_i\\times B_i)\\) in \\(O(1)\\) time. \n\nThe key updates are:\n\\[\n\\sum_{i=L}^R ((A_i+x)\\times (B_i+y)) = \\sum_{i=L}^R (A_i\\times B_i) + y\\sum_{i=L}^R A_i + x\\sum_{i=L}^R B_i + (R-L+1)xy\n\\]\n\\[\n\\sum_{i=L}^R (A_i+x) = \\sum_{i=L}^R A_i+(R-L+1)x, \n\\]\n\\[\n\\sum_{i=L}^R (B_i+y) = \\sum_{i=L}^R B_i+(R-L+1)y\n\\]\n\nTherefore, the lazy segment tree can find the answer with a complexity of \\(O(Q\\log N)\\), which is efficient. The answer should be printed modulo \\(998244353\\).\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\n", "problem_ids": ["abc357_f", "abc366_e", "abc355_g"]}, "abc322_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou have \\( N \\) keys numbered \\( 1, 2, \\dots, N \\). Some of these are real keys, while the others are dummies. There is a door, Door X, into which you can insert any number of keys. Door X will open if and only if at least \\( K \\) real keys are inserted.\n\nYou have conducted \\( M \\) tests on these keys. The \\( i \\)-th test went as follows:\n- You inserted \\( C_i \\) keys \\( A_{i,1}, A_{i,2}, \\dots, A_{i,C_i} \\) into Door X.\n- The test result is represented by a single English letter \\( R_i \\).\n  - \\( R_i = \\text{o} \\) means that Door X opened in the \\( i \\)-th test.\n  - \\( R_i = \\text{x} \\) means that Door X did not open in the \\( i \\)-th test.\n\nThere are \\( 2^N \\) possible combinations of which keys are real and which are dummies. Among these, find the number of combinations that do not contradict any of the test results. It is possible that the given test results are incorrect and no combination satisfies the conditions. In such a case, report \\( 0 \\).\n\n**Constraints**\n- \\( N, M, K, C_i, \\text{ and } A_{i,j} \\) are integers.\n- \\( 1 \\le K \\le N \\le 15 \\)\n- \\( 1 \\le M \\le 100 \\)\n- \\( 1 \\le C_i \\le N \\)\n- \\( 1 \\le A_{i,j} \\le N \\)\n- \\( A_{i,j} \\neq A_{i,k} \\) if \\( j \\neq k \\).\n- \\( R_i \\) is \\( \\text{o} \\) or \\( \\text{x} \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M K\nC_1 A_{1,1} A_{1,2} \\dots A_{1,C_1} R_1\nC_2 A_{2,1} A_{2,2} \\dots A_{2,C_2} R_2\n\\vdots\nC_M A_{M,1} A_{M,2} \\dots A_{M,C_M} R_M\n```\n\n**Output**\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2 2\n3 1 2 3 o\n2 2 3 x\n```\n\n**Sample Output 1**\n```\n2\n```\n\nIn this input, there are three keys and two tests were conducted. Two correct keys are required to open Door X. In the first test, keys 1, 2, 3 were used, and Door X opened. In the second test, keys 2, 3 were used, and Door X did not open. There are two combinations of which keys are real and which are dummies that do not contradict any of the test results: Key 1 is real, key 2 is a dummy, and key 3 is real. Key 1 is real, key 2 is real, and key 3 is a dummy.\n\n**Sample Input 2**\n```\n4 5 3\n3 1 2 3 o\n3 2 3 4 o\n3 3 4 1 o\n3 4 1 2 o\n4 1 2 3 4 x\n```\n\n**Sample Output 2**\n```\n0\n```\n\nAs mentioned in the problem statement, the answer may be 0.\n\n**Sample Input 3**\n```\n11 4 9\n10 1 2 3 4 5 6 7 8 9 10 o\n11 1 2 3 4 5 6 7 8 9 10 11 o\n10 11 10 9 8 7 6 5 4 3 2 x\n10 11 9 1 4 3 7 5 6 2 10 x\n```\n\n**Sample Output 3**\n```\n8\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 356\n\n# C - Keys Editorial by en_translator:\n\n# By the constraints, the number of keys \\(N \\le 15\\), and the tests \\(M \\le 100\\). \n# There are \\(2^N\\) combinations of authenticities of the keys. We may perform the \\(M\\) tests \n# on all \\(2^N\\) combinations and count the number of proper combinations. \n# \\(2^N \\times M \\le 3.3 \\times 10^6\\) tests are required. \n# Even with \\(N\\) operations per test, the total number of operations is \\(5 \\times 10^7\\), which is fast enough. \n# We achieve this through bitwise enumeration by iterating over \\(i=0,1,\\dots,2^N-1\\). \n# The presence of bit \\(2^k\\) in \\(i\\) determines if the \\((k+1)\\)-th key is real or a dummy. \n# For more details, refer to relevant articles on bitwise enumeration.\n\n# Note that operations exceeding \\(N\\) per test might not meet the execution time limit. \n# Managing whether the \\(k\\)-th key was used limits operations per test to \\(N\\).\n\n# Sample code translated to Python:\nn, m, k = map(int, input().split())\nkey = [[0]*n for _ in range(m)]\nr = []\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c + 1):\n        a = data[j]\n        key[i][a-1] = 1\n    r.append(input().strip())\n\nres = 0\n\nfor i in range(1 << n):\n    tf = [0] * n\n    for j in range(n):\n        if i & (1 << j):\n            tf[j] = 1\n        else:\n            tf[j] = 0\n    jud = True\n    for j in range(m):\n        ck = 0\n        for p in range(n):\n            if key[j][p] == 1 and tf[p] == 1:\n                ck += 1\n        if ck >= k and r[j] == \"x\":\n            jud = False\n        if ck < k and r[j] == \"o\":\n            jud = False\n    if jud:\n        res += 1\n\nprint(res)\n\n# A faster approach using bitwise operations translated to Python:\nn, m, k = map(int, input().split())\nks = [0] * m\nr = [0] * m\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c+1):\n        a = data[j] - 1\n        ks[i] |= (1 << a)\n    s = input().strip()\n    if s == \"o\":\n        r[i] = 1\n    else:\n        r[i] = 0\n\nres = 0\n\nfor i in range(1 << n):\n    jud = True\n    for j in range(m):\n        ok = bin(i & ks[j]).count('1')\n        if ok >= k and r[j] == 0:\n            jud = False\n            break\n        if ok < k and r[j] == 1:\n            jud = False\n            break\n    if jud:\n        res += 1\n\nprint(res)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThis is an interactive problem where your program interacts with the judge via input and output.\n\nYou are given a positive integer \\(N\\) and integers \\(L\\) and \\(R\\) such that \\(0 \\leq L \\leq R < 2^N\\). The judge has a hidden sequence \\(A = (A_0, A_1, \\dots, A_{2^N-1})\\) consisting of integers between 0 and 99, inclusive.\n\nYour goal is to find the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100. However, you cannot directly know the values of the elements in the sequence \\(A\\). Instead, you can ask the judge the following question:\n\nChoose non-negative integers \\(i\\) and \\(j\\) such that \\(2^i(j+1) \\leq 2^N\\). Let \\(l = 2^i j\\) and \\(r = 2^i (j+1) - 1\\). Ask for the remainder when \\(A_l + A_{l+1} + \\dots + A_r\\) is divided by 100.\n\nLet \\(m\\) be the minimum number of questions required to determine the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100 for any sequence \\(A\\). You need to find this remainder within \\(m\\) questions.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 18\\)\n- \\(0 \\leq L \\leq R \\leq 2^N - 1\\)\n- All input values are integers.\n\n**Input and Output**\n\nThis is an interactive problem.\n\nFirst, read the integers \\(N\\), \\(L\\), and \\(R\\) from Standard Input:\n\n```\nN L R\n```\n\nThen, repeat asking questions until you can determine the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100. Each question should be printed in the following format:\n\n```\n? i j\n```\n\nHere, \\(i\\) and \\(j\\) must satisfy the following constraints:\n\n- \\(i\\) and \\(j\\) are non-negative integers.\n- \\(2^i(j+1) \\leq 2^N\\)\n\nThe response to the question will be given in the following format from Standard Input:\n\n```\nT\n```\n\nHere, \\(T\\) is the answer to the question, which is the remainder when \\(A_l + A_{l+1} + \\dots + A_r\\) is divided by 100, where \\(l = 2^i j\\) and \\(r = 2^i (j+1) - 1\\).\n\nIf \\(i\\) and \\(j\\) do not satisfy the constraints, or if the number of questions exceeds \\(m\\), then \\(T\\) will be -1.\n\nIf the judge returns -1, your program is already considered incorrect. In this case, terminate the program immediately.\n\nOnce you have determined the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100, print the remainder \\(S\\) in the following format and terminate the program immediately:\n\n```\n! S\n```\n\n**Notes**\n\n- At the end of each output, print a newline and flush Standard Output. Otherwise, the verdict may be Time Limit Exceeded (TLE).\n- If your output is malformed or your program exits prematurely, the verdict will be indeterminate.\n- After printing the answer, terminate the program immediately. Otherwise, the verdict will be indeterminate.\n\n**Example**\n\nHere is an example for \\(N=3\\), \\(L=1\\), \\(R=5\\), and \\(A=(31, 41, 59, 26, 53, 58, 97, 93)\\). In this case, \\(m=3\\), so you can ask up to three questions.\n\n**Input**\n```\n3 1 5\n```\n**Output**\n```\n? 0 1\n41\n? 1 1\n85\n? 1 2\n11\n! 37\n```\n\nSolution:\n\n```python\nfrom collections import deque\n\nN, L, R = map(int, input().split())\nn = 1 << N\nedge = [[] for i in range(n + 1)]\nfor i in range(N + 1):\n    for l in range(0, n, 1 << i):\n        r = l + (1 << i)\n        edge[l].append(r)\n        edge[r].append(l)\n\nparent = [None] * (n + 1)\nparent[R + 1] = -1\ndq = deque([R + 1])\nwhile dq:\n    v = dq.popleft()\n    for u in edge[v]:\n        if parent[u] == None:\n            parent[u] = v\n            dq.append(u)\n\nans = 0\nnow = L\nwhile parent[now] != -1:\n    p = parent[now]\n    sgn = 1\n    l, r = now, p\n    if l > r:\n        sgn = -1\n        l, r = r, l\n    i = (r - l).bit_length() - 1\n    j = l >> i\n    print(\"?\", i, j, flush=True)\n    T = int(input())\n    ans += sgn * T\n    now = p\n\nprint(\"!\", ans % 100)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of the characters 'A' and 'B'. For a string \\( X \\) of length \\( N \\) consisting of the characters '1', '2', and '3', the score is determined by the following procedure:\n\n1. Initialize the variables \\( h_1, h_2, h_3, P \\) to 0.\n\n2. For \\( i = 1, 2, \\dots, N \\) in this order, perform the following operations:\n   - If the \\( i \\)-th character of \\( S \\) is 'A', perform operation A; if it is 'B', perform operation B. Let \\( d \\) be the number represented by the \\( i \\)-th character of \\( X \\).\n   - **Operation A:** Add 2 to \\( h_d \\).\n   - **Operation B:** If \\( d = 2 \\) or \\( h_d \\neq h_2 \\), set \\( P \\) to \\(-10^{100}\\). Otherwise, add 1 to both \\( h_d \\) and \\( h_2 \\).\n\n3. If \\( h_1 = h_2 = h_3 \\), add 1 to \\( P \\).\n\nThe final value of \\( P \\) is the score.\n\nPrint one string \\( X \\) that maximizes the score. You have \\( T \\) test cases to solve.\n\n**Constraints:**\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N \\leq 10^6 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of 'A' and 'B'.\n- \\( T \\) and \\( N \\) are integers.\n- The sum of \\( N \\) across all test cases is at most \\( 10^6 \\).\n\n**Input:**\nThe input is given from Standard Input in the following format. Here, \\(\\mathrm{test}_i\\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{test}_1\n\\mathrm{test}_2\n\\vdots\n\\mathrm{test}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nS\n```\n\n**Output:**\nPrint \\( T \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq T \\)) should contain a string \\( X \\) that maximizes the score for the \\( i \\)-th test case. If multiple strings \\( X \\) maximize the score, any of them is considered correct.\n\n**Sample Input 1:**\n```\n5\n4\nABBA\n5\nAAAAA\n6\nBBBBBB\n7\nABABABA\n20\nAAABBBBBBBBAAABBBABA\n```\n\n**Sample Output 1:**\n```\n1333\n12321\n333333\n1313212\n33311111133121111311\n```\n\nLet us describe the changes in \\((h_1, h_2, h_3, P)\\) as we proceed with \\( i = 1, 2, \\dots, N \\).\n\n- For the first test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,1,1,0) \\rightarrow (2,2,2,1) \\rightarrow (2,2,4,1)\\). The maximum score is 1.\n- For the second test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,2,0,0) \\rightarrow (2,2,2,1) \\rightarrow (2,4,2,1) \\rightarrow (4,4,2,1)\\). The maximum score is 1.\n\nFor the third, fourth, and fifth test cases, the maximum scores are 0, 0, and 2, respectively. There may be multiple strings \\( X \\) that maximize the score, but you only need to print one of them.\n\nSolution:\n\n[BEGIN TEXT]\nHere is a concise version of the provided text:\n\n---\n\n**F - All the Same Editorial by evima**\n\n**Observations on the Problem:**  \nThe problem can be visualized as a Tetris game with dominoes on a field width of 3, where dominoes cannot be rotated and there must be no gaps below horizontally placed dominoes. The score increases when all pieces are cleared. Flattening occurs when \\( h_1 = h_2 = h_3 \\).\n\n**Characteristics of \\( S \\):**  \nFor \\( i=0,1,\\ldots,N \\), let \\( a_i \\) be the number of As and \\( b_i \\) the number of Bs. The sequence can be flattened under the following conditions:\n- \\( a_i + b_i \\equiv 0 \\mod 3 \\)\n- \\( b_i \\equiv 0 \\mod 2 \\)\n- \\( b_i \\le 2a_i \\)\n\nDefining \\( V_i = 2a_i - b_i \\) gives:\n\\[ V_i \\ge 0, \\ V_i \\equiv 0 \\mod 6 \\]\nThese conditions are both necessary and sufficient for flattening.\n\n**Maximizing the Score:**  \nFind the longest non-decreasing subsequence \\( (V_{i_0}, V_{i_1}, \\ldots, V_{i_k}) \\) with:\n- \\( i_0 = 0 \\)\n- \\( V_{i_j} \\equiv 0 \\mod 6 \\)\n- \\( V_{i_j} \\le V_{i_{j+1}} \\)\n\nThis can be solved in \\( O(N \\log N) \\) time. \n\n**Constructing the Operation Sequence:**  \nDefine \\( T_j \\) as the substring of \\( S \\) from \\( (V_{i_j}+1) \\)-th to \\( V_{i_{j+1}} \\)-th character. Construct an operation sequence \\( X \\) for \\( S \\):\n- \\( A \\to 1 \\) (vertical domino)\n- \\( B \\to 3 \\) (horizontal domino)\n\nAdjust for \\( V_N \\ge 6 \\) by aligning extra vertical dominoes. Execute the basic idea when \\( V_N = 0 \\). Handle \\( V_i \\) conditions to reduce \\( V_N \\).\n\n**Summary:**  \n1. Compute \\( V \\) and solve the longest non-decreasing subsequence problem.\n2. For divided substrings, use the basic idea and reductions.\n\nThe solution operates in \\( O(|S|\\log |S|) \\) time per test case.\n[END TEXT]\n \n\n", "problem_ids": ["abc356_c", "abc355_e", "arc179_f"]}, "abc323_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nDefine the **score** of a sequence of positive integers \\( B = (B_1, B_2, \\dots, B_k) \\) as:\n\n\\[\n\\sum_{i=1}^{k-1} \\gcd(B_i, B_{i+1})\n\\]\n\nGiven a sequence of positive integers \\( A = (A_1, A_2, \\dots, A_N) \\), solve the following problem for \\( m = 1, 2, \\dots, N \\):\n\n- Find the sum of the scores of all non-empty subsequences of the sequence \\( (A_1, A_2, \\dots, A_m) \\), modulo 998244353. There are \\( 2^m - 1 \\) such subsequences. Two subsequences are distinguished if they are taken from different positions in the sequence, even if they coincide as sequences.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^5 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the answer for \\( m = i \\).\n\n**Sample Input 1**\n\n```\n3\n9 6 4\n```\n\n**Sample Output 1**\n\n```\n0\n3\n11\n```\n\n*Explanation*: \n\nConsider the case \\( m = 3 \\). Here are the non-empty subsequences of \\( (A_1, A_2, A_3) = (9, 6, 4) \\) and their scores:\n\n- \\( (9) \\): Score is 0.\n- \\( (6) \\): Score is 0.\n- \\( (4) \\): Score is 0.\n- \\( (9, 6) \\): Score is \\( \\gcd(9, 6) = 3 \\).\n- \\( (9, 4) \\): Score is \\( \\gcd(9, 4) = 1 \\).\n- \\( (6, 4) \\): Score is \\( \\gcd(6, 4) = 2 \\).\n- \\( (9, 6, 4) \\): Score is \\( \\gcd(9, 6) + \\gcd(6, 4) = 3 + 2 = 5 \\).\n\nTherefore, the answer for \\( m = 3 \\) is \\( 0 + 0 + 0 + 3 + 1 + 2 + 5 = 11 \\).\n\n**Sample Input 2**\n\n```\n5\n3 8 12 6 9\n```\n\n**Sample Output 2**\n\n```\n0\n1\n13\n57\n155\n```\n\n**Sample Input 3**\n\n```\n10\n47718 21994 74148 76721 98917 73766 29598 59035 69293 29127\n```\n\n**Sample Output 3**\n\n```\n0\n2\n14\n35\n97\n372\n866\n1859\n4273\n43287\n```\n\nSolution:\n\nHere is the translated editorial with all non-Python code converted to Python3:\n\n```python\ndef gcd(n, m):\n    while m:\n        n, m = m, n % m\n    return n\n\ndef euler_totient_function(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef compute_R(A):\n    max_A = max(A)\n    N = len(A)\n    \n    # Precompute divisors and Euler's totient function values\n    phi = [euler_totient_function(i) for i in range(max_A + 1)]\n    \n    s = [0] * (max_A + 1)\n    R = [0] * (N + 1)  # R_0 is already 0\n    \n    for i in range(1, N + 1):\n        a_i = A[i - 1]\n        # Computing R_i\n        R[i] = 2 * R[i - 1]\n        d = 1\n        while d * d <= a_i:\n            if a_i % d == 0:\n                # For divisor d\n                R[i] += phi[d] * s[d]\n                if d != a_i // d:\n                    # For divisor a_i // d\n                    R[i] += phi[a_i // d] * s[a_i // d]\n            d += 1\n\n        # Update s values for current a_i\n        d = 1\n        while d * d <= a_i:\n            if a_i % d == 0:\n                s[d] += 2 ** i\n                if d != a_i // d:\n                    s[a_i // d] += 2 ** i\n            d += 1\n\n    return R[1:]  # Return R_1 to R_N\n\n# Example usage with an array A\nA = [your_array_values_here]\nR_values = compute_R(A)\nprint(R_values)\n```\n\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a long water tank with boards of different heights placed at equal intervals. Takahashi wants to know the time at which water reaches each section separated by the boards when water is poured from one end of the tank.\n\nYou are given a sequence of positive integers of length \\( N \\): \\( H = (H_1, H_2, \\dotsc, H_N) \\).\n\nThere is a sequence of non-negative integers of length \\( N+1 \\): \\( A = (A_0, A_1, \\dotsc, A_N) \\). Initially, \\( A_0 = A_1 = \\dotsb = A_N = 0 \\).\n\nPerform the following operations repeatedly on \\( A \\):\n1. Increase the value of \\( A_0 \\) by 1.\n2. For \\( i = 1, 2, \\ldots, N \\) in this order, perform the following operation:\n   - If \\( A_{i-1} > A_i \\) and \\( A_{i-1} > H_i \\), decrease the value of \\( A_{i-1} \\) by 1 and increase the value of \\( A_i \\) by 1.\n\nFor each \\( i = 1, 2, \\ldots, N \\), find the number of operations before \\( A_i > 0 \\) holds for the first time.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\) for \\( 1 \\leq i \\leq N \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\dotsc H_N\n```\n\n**Output:**\n\nPrint the answers for \\( i = 1, 2, \\ldots, N \\) in a single line, separated by spaces.\n\n**Sample Input 1:**\n\n```\n5\n3 1 4 1 5\n```\n\n**Sample Output 1:**\n\n```\n4 5 13 14 26\n```\n\nFrom this, \\( A_1 > 0 \\) holds for the first time after the 4th operation, and \\( A_2 > 0 \\) holds for the first time after the 5th operation. Similarly, the answers for \\( A_3, A_4, A_5 \\) are 13, 14, 26, respectively.\n\n**Sample Input 2:**\n\n```\n6\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 2:**\n\n```\n1000000001 2000000001 3000000001 4000000001 5000000001 6000000001\n```\n\nNote that the values to be output may not fit within a 32-bit integer.\n\n**Sample Input 3:**\n\n```\n15\n748 169 586 329 972 529 432 519 408 587 138 249 656 114 632\n```\n\n**Sample Output 3:**\n\n```\n749 918 1921 2250 4861 5390 5822 6428 6836 7796 7934 8294 10109 10223 11373\n```\n\nSolution:\n\nHere is the cleaned-up content of the solution for the problem:\n\nConsider how the sequence \\(A_i\\) changes right before \\(A_n\\) becomes positive for the first time. The operation and properties involve maintaining \\(P(i)\\), defined as \\(A_{i-1} \\leq \\max\\{H_i, A_i\\}\\). \n\n1. When performing operations, increment \\(A_{i-1}\\) for the minimum \\(i\\) where \\(A_{i-1} < \\max\\{H_i, A_i\\}\\). \n\n2. Initially, all \\(A_i = 0\\). Prove through induction that if any \\(A_{i-1}\\) is incremented following the conditions, the property \\(P(i)\\) remains valid.\n\nDetermining \\(A_{i} = \\max_{i<j\\leq n} H_j\\) right before \\(A_n\\) becomes positive allows calculation of \\(\\sum A_i\\).\n\nThe solution can be optimized using data structures such as a stack, lazy segment tree, or segment tree beats to manage operations efficiently, with complexities varying based on the approach used.\n\nBelow is sample code implementing the stack approach to solve the problem:\n\n```python\nN = int(input().strip())\nrectangles = []\nans = 1\n\nfor i in range(N):\n    H = int(input().strip())\n    count = 1\n\n    while rectangles and rectangles[-1][0] <= H:\n        h, c = rectangles.pop()\n        ans -= h * c\n        count += c\n\n    ans += H * count\n    rectangles.append((H, count))\n    print(ans, end=\" \")\nprint()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere is a directed graph with \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) and \\( N \\) edges. The out-degree of every vertex is \\( 1 \\), and the edge from vertex \\( i \\) points to vertex \\( a_i \\). Count the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\).\n\nHere, vertex \\( v \\) is reachable from vertex \\( u \\) if there exists a sequence of vertices \\( w_0, w_1, \\ldots, w_K \\) of length \\( K+1 \\) that satisfies the following conditions. In particular, if \\( u = v \\), it is always reachable:\n- \\( w_0 = u \\).\n- \\( w_K = v \\).\n- For every \\( 0 \\leq i < K \\), there is an edge from vertex \\( w_i \\) to vertex \\( w_{i+1} \\).\n\n### Constraints\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n\n```\nN\na_1 a_2 \\ldots a_N\n```\n\n### Output\nPrint the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\).\n\n### Sample Input 1\n```\n4\n2 1 1 4\n```\n\n### Sample Output 1\n```\n8\n```\n\n**Explanation:**\n\n- The vertices reachable from vertex \\( 1 \\) are vertices \\( 1, 2 \\).\n- The vertices reachable from vertex \\( 2 \\) are vertices \\( 1, 2 \\).\n- The vertices reachable from vertex \\( 3 \\) are vertices \\( 1, 2, 3 \\).\n- The vertex reachable from vertex \\( 4 \\) is vertex \\( 4 \\).\n\nTherefore, the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\) is \\( 8 \\).\n\nNote that the edge from vertex \\( 4 \\) is a self-loop, that is, it points to vertex \\( 4 \\) itself.\n\n### Sample Input 2\n```\n5\n2 4 3 1 2\n```\n\n### Sample Output 2\n```\n14\n```\n\n### Sample Input 3\n```\n10\n6 10 4 1 5 9 8 6 5 1\n```\n\n### Sample Output 3\n```\n41\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial discusses a problem involving a functional graph, a common topic in competitive programming. A functional graph consists of connected components, each having exactly one cycle. The solution involves examining each connected component with a cycle and directed trees attached. For any vertex \\(u\\), all reachable vertices are either ancestors of \\(u\\) within its directed tree or part of the cycle that includes the root of this tree. To compute the reachable vertices, you should determine the depth of \\(u\\) in its directed tree and the number of vertices in the cycle using graph search algorithms like DFS. The algorithm's complexity is \\(\\mathrm{O}(N)\\), or alternatively, the SCC algorithm can be used.\n[END TEXT]\n \n\n", "problem_ids": ["arc185_e", "abc359_e", "abc357_e"]}, "abc323_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere are \\( N \\) people, and the current hair length of the \\( i \\)-th person \\( (1 \\leq i \\leq N) \\) is \\( L_i \\).\nEach person's hair grows by 1 per day.\n\nPrint the number of days after which the number of people whose hair length is at least \\( T \\) becomes \\( P \\) or more for the first time.\nIf there are already \\( P \\) or more people whose hair length is at least \\( T \\) now, print 0.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq L_i \\leq 100 \\)\n- \\( 1 \\leq T \\leq 100 \\)\n- \\( 1 \\leq P \\leq N \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN T P\nL_1 L_2 \\ldots L_N\n```\n\n**Output:**\nPrint the number of days after which the number of people whose hair length is at least \\( T \\) becomes \\( P \\) or more for the first time. \nIf this condition is already satisfied now, print 0.\n\n**Sample Input 1:**\n```\n5 10 3\n3 11 1 6 2\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n*Explanation:*\nThere are five people, and their current hair lengths are 3, 11, 1, 6, and 2, so there is one person whose hair length is at least 10.\nAfter seven days, the hair lengths of the people will be 10, 18, 8, 13, and 9, respectively, and there will be three people whose hair length is at least 10.\nAfter six days, there are only two people whose hair length is at least 10, not satisfying the condition, so print 7.\n\n**Sample Input 2:**\n```\n2 5 2\n10 10\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n*Explanation:*\nSince there are already two people whose hair length is at least 5 now, satisfying the condition, print 0.\n\n**Sample Input 3:**\n```\n3 10 1\n1 2 3\n```\n\n**Sample Output 3:**\n```\n7\n```\n\nSolution:\n\n        Editorial - B - Japanese Cursed Doll\n\n\\((T-1)\\) days later, everyone has hair of length \\(T\\) or greater. Together with \\(P\\leq N\\), the condition is always satisfied. One can find the answer by checking if the conditions are satisfied on day \\(i\\) for each \\(i=0,1,\\ldots,(T-1)\\) in order. The complexity is \\(O(NT)\\), which is fast enough for the constraints. The problem can also be solved in \\(O(N\\log N)\\) time by recording how many days are required for each person to have hair of length \\(T\\) or greater, sorting the counts of days, and finding the \\(P\\)-th smallest one among them.\n\nSample code in C++:\n```python\nn, t, p = map(int, input().split())\nl = list(map(int, input().split()))\n\nfor i in range(t):\n    cnt = 0\n    for j in range(n):\n        if l[j] + i >= t:\n            cnt += 1\n    if cnt >= p:\n        print(i)\n        break\n```\n\nSample code in Python:\n```python\nn,t,p=map(int, input().split())\nl=list(map(int, input().split()))\n\nfor i in range(t):\n    cnt=0\n    for j in range(n):\n        if l[j]+i>=t:\n            cnt+=1\n    if cnt>=p:\n        print(i)\n        break\n```\n\nSample code in C++ (another solution):\n```python\nn, t, p = map(int, input().split())\nl = []\n\nfor i in range(n):\n    x = int(input())\n    l.append(max(0, t - x))\n\nl.sort()\nprint(l[p - 1])\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Kingdom of AtCoder has \\( N \\) towns numbered from 1 to \\( N \\). To move from town \\( i \\) to town \\( j \\), you must pay a toll of \\( C \\times |i-j| \\) yen. Takahashi, a merchant, is considering participating in zero or more of \\( M \\) upcoming markets. The \\( i \\)-th market (\\( 1 \\leq i \\leq M \\)) is described by the pair of integers \\((T_i, P_i)\\), where the market is held in town \\( T_i \\) and he will earn \\( P_i \\) yen if he participates.\n\nFor all \\( 1 \\leq i < M \\), the \\( i \\)-th market ends before the \\((i+1)\\)-th market begins. The time it takes for him to move is negligible. He starts with \\( 10^{10^{100}} \\) yen and is initially in town 1. \n\nDetermine the maximum profit he can make by optimally choosing which markets to participate in and how to move. Formally, let \\( 10^{10^{100}} + X \\) be his final amount of money if he maximizes the amount of money he has after the \\( M \\) markets. Find \\( X \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq T_i \\leq N \\) (for \\( 1 \\leq i \\leq M \\))\n- \\( 1 \\leq P_i \\leq 10^{13} \\) (for \\( 1 \\leq i \\leq M \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN C\nM\nT_1 P_1\nT_2 P_2\n...\nT_M P_M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n6 3\n4\n5 30\n2 10\n4 25\n2 15\n```\n\n**Sample Output 1**\n\n```\n49\n```\n\n**Explanation for Sample 1**\n\nFor example, Takahashi can increase his money by 49 yen by acting as follows:\n- Move to town 5. His money becomes \\( 10^{10^{100}} - 12 \\) yen.\n- Participate in the first market. His money becomes \\( 10^{10^{100}} + 18 \\) yen.\n- Move to town 4. His money becomes \\( 10^{10^{100}} + 15 \\) yen.\n- Participate in the third market. His money becomes \\( 10^{10^{100}} + 40 \\) yen.\n- Move to town 2. His money becomes \\( 10^{10^{100}} + 34 \\) yen.\n- Participate in the fourth market. His money becomes \\( 10^{10^{100}} + 49 \\) yen.\n\nIt is impossible to increase his money to \\( 10^{10^{100}} + 50 \\) yen or more, so print 49.\n\n**Sample Input 2**\n\n```\n6 1000000000\n4\n5 30\n2 10\n4 25\n2 15\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Explanation for Sample 2**\n\nThe toll fee is so high that it is optimal for him not to move from town 1.\n\n**Sample Input 3**\n\n```\n50 10\n15\n37 261\n28 404\n49 582\n19 573\n18 633\n3 332\n31 213\n30 377\n50 783\n17 798\n4 561\n41 871\n15 525\n16 444\n26 453\n```\n\n**Sample Output 3**\n\n```\n5000\n```\n\n**Sample Input 4**\n\n```\n50 1000000000\n15\n30 60541209756\n48 49238708511\n1 73787345006\n24 47221018887\n9 20218773368\n34 40025202486\n14 28286410866\n24 82115648680\n37 62913240066\n14 92020110916\n24 20965327730\n32 67598565422\n39 79828753874\n40 52778306283\n40 67894622518\n```\n\n**Sample Output 4**\n\n```\n606214471001\n```\n\nNote that the output value may exceed the range of a 32-bit integer.\n\nSolution:\n\n```python\n# Python translation of the given C++ code\n\nclass SegmentTree:\n    OP = max\n    ID = 0\n\n    def __init__(self, n):\n        self.n = n\n        self.data = [self.ID] * (2 * n)\n\n    def set(self, p, value):\n        p += self.n\n        self.data[p] = value\n        p //= 2\n        while p > 0:\n            self.data[p] = self.OP(self.data[2 * p], self.data[2 * p + 1])\n            p //= 2\n\n    def prod(self, l, r):\n        l += self.n\n        r += self.n\n        result = self.ID\n        while l < r:\n            if l & 1:\n                result = self.OP(result, self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                result = self.OP(result, self.data[r])\n            l //= 2\n            r //= 2\n        return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    C = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    prefix = SegmentTree(N)\n    suffix = SegmentTree(N)\n    \n    offset = 2000000000000000000\n    \n    prefix.set(0, offset)\n    suffix.set(0, offset)\n    \n    ans = offset\n    \n    for _ in range(M):\n        T = int(data[idx]) - 1\n        idx += 1\n        P = int(data[idx])\n        idx += 1\n        \n        best = max(prefix.prod(0, T + 1) - C * T, suffix.prod(T, N) + C * T) + P\n        \n        ans = max(ans, best)\n        \n        prefix.set(T, best + C * T)\n        suffix.set(T, best - C * T)\n    \n    print(ans - offset)\n\n# The following is necessary since we are translating a full program.\n# In an actual competitive programming setting, you'd want to call main directly.\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( K \\).\n\nThe **cumulative sums** of an integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is defined as a sequence \\( Y = (Y_0, Y_1, \\dots, Y_N) \\) of length \\( N+1 \\) as follows:\n\n- \\( Y_0 = 0 \\)\n- \\( Y_i = \\sum_{j=1}^{i} X_j \\) for \\( i = 1, 2, \\dots, N \\)\n\nAn integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is called a **good sequence** if and only if it satisfies the following condition:\n\n- Any value in the cumulative sums of \\( X \\) that is less than \\( K \\) appears before any value that is not less than \\( K \\).\n  \n  Formally, for the cumulative sums \\( Y \\) of \\( X \\), for any pair of integers \\( (i, j) \\) such that \\( 0 \\le i, j \\le N \\), if \\( (Y_i < K \\) and \\( Y_j \\ge K) \\), then \\( i < j \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). Determine whether the elements of \\( A \\) can be rearranged to form a good sequence. If so, print one such rearrangement.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq K \\leq 10^9 \\)\n- \\( -10^9 \\leq A_i \\leq 10^9 \\)\n\nAll input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nIf the elements of \\( A \\) can be rearranged to a good sequence, print the rearranged sequence \\( (A'_1, A'_2, \\dots, A'_N) \\) in the following format:\n\n```\nYes\nA'_1 A'_2 \\cdots A'_N\n```\n\nIf there are multiple valid rearrangements, any of them is considered correct.\n\nIf a good sequence cannot be obtained, print `No`.\n\n**Sample Input 1**\n```\n4 1\n-1 2 -3 4\n```\n\n**Sample Output 1**\n```\nYes\n-3 -1 2 4\n```\n\nIf you rearrange \\( A \\) to \\((-3, -1, 2, 4)\\), the cumulative sums \\( Y \\) will be \\( (0, -3, -4, -2, 2) \\). In this \\( Y \\), any value less than 1 appears before any value not less than 1.\n\n**Sample Input 2**\n```\n4 -1\n1 -2 3 -4\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n10 1000000000\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\nYes\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 179 - A - Partition Editorial by evima\n\nIf \\(K \\geq 1\\):\nBy sorting \\(A\\) in ascending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in ascending order. Let \\(B\\) be the cumulative sums of \\(A\\). Values in \\(A\\) that are less than \\(0\\) appear before values that are \\(0\\) or greater. Therefore, \\(B\\) can be represented as a concatenation of a strictly decreasing sequence and a non-decreasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 < K\\) and decreasing for a while, it begins to increase from a value less than \\(K\\). Once it becomes \\(K\\) or greater, it remains so thereafter. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i \\geq K\\):\nBy sorting \\(A\\) in descending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in descending order. Let \\(B\\) be the cumulative sum of \\(A\\). Values in \\(A\\) that are \\(0\\) or greater appear before values that are less than \\(0\\). Therefore, \\(B\\) can be represented as a concatenation of a strictly increasing sequence and a non-increasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 \\geq K\\) and increasing for a while, it begins to decrease from a value not less than \\(K\\). Since \\(B_0 \\geq K\\), it is \\(K\\) or greater from the start, and since \\(B_N = \\sum_{i=1}^{N}A_i \\geq K\\), it remains \\(K\\) or greater until the end. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i < K\\):\nNo matter how \\(A\\) is rearranged, it cannot be made into a good sequence. No matter how \\(A\\) is rearranged, the initial and final terms of the cumulative sum \\(B\\) of \\(A\\) are fixed. Since \\(B_0 = 0 \\geq K\\) and \\(B_N = \\sum_{i=1}^{N}A_i < K\\), it does not satisfy the conditions for a good sequence.\n[END TEXT]\n \n\n", "problem_ids": ["abc363_b", "abc353_g", "arc179_a"]}, "abc323_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) types of elements numbered \\( 1, 2, \\ldots, N \\). Elements can be combined with each other. When elements \\( i \\) and \\( j \\) are combined, they transform into element \\( A_{i, j} \\) if \\( i \\geq j \\), and into element \\( A_{j, i} \\) if \\( i < j \\).\n\nStarting with element \\( 1 \\), combine it with elements \\( 1, 2, \\ldots, N \\) in this order. Find the final element obtained.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_{i, j} \\leq N \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_{1, 1}\nA_{2, 1} A_{2, 2}\n\\vdots\nA_{N, 1} A_{N, 2} \\ldots A_{N, N}\n```\n\n**Output:**\n\nPrint the number representing the final element obtained.\n\n**Sample Input 1:**\n\n```\n4\n3\n2 4\n3 1 2\n2 1 2 4\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- Combining element 1 with element 1 results in element 3.\n- Combining element 3 with element 2 results in element 1.\n- Combining element 1 with element 3 results in element 3.\n- Combining element 3 with element 4 results in element 2.\n\nTherefore, the value to be printed is 2.\n\n**Sample Input 2:**\n\n```\n5\n5\n5 5\n5 5 5\n5 5 5 5\n5 5 5 5 5\n```\n\n**Sample Output 2:**\n\n```\n5\n```\n\n**Sample Input 3:**\n\n```\n6\n2\n1 5\n1 6 3\n2 6 1 4\n2 1 1 1 6\n5 6 1 2 2 5\n```\n\n**Sample Output 3:**\n\n```\n5\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\n**B - Binary Alchemy Editorial**\n\nSimulate the process of successively synthesizing elements \\(1, 2, \\ldots, N\\) into element \\(1\\) while managing the current index of the element.\n\n```python\ndef main():\n    n = int(input())\n    a = [list(map(lambda x: int(x) - 1, input().split())) + [0] * (n - i - 1) for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if ans >= i:\n            ans = a[ans][i]\n        else:\n            ans = a[i][ans]\n    ans += 1\n    print(ans)\n\nmain()\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a string \\( S \\) of length \\( N \\) consisting only of lowercase English letters. Find the number of strings obtained by permuting the characters of \\( S \\) (including the string \\( S \\) itself) that **do not contain** a palindrome of length \\( K \\) as a substring.\n\nHere, a string \\( T \\) of length \\( N \\) is said to \"contain a palindrome of length \\( K \\) as a substring\" if and only if there exists a non-negative integer \\( i \\) not greater than \\( (N-K) \\) such that \\( T_{i+j} = T_{i+K+1-j} \\) for every integer \\( j \\) with \\( 1 \\leq j \\leq K \\). Here, \\( T_k \\) denotes the \\( k \\)-th character of the string \\( T \\).\n\n**Constraints:**\n\n- \\( 2 \\leq K \\leq N \\leq 10 \\)\n- \\( N \\) and \\( K \\) are integers.\n- \\( S \\) is a string of length \\( N \\) consisting only of lowercase English letters.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nS\n```\n\n**Output:**\n\nPrint the number of strings obtained by permuting \\( S \\) that do not contain a palindrome of length \\( K \\) as a substring.\n\n**Sample Input 1:**\n```\n3 2\naab\n```\n\n**Sample Output 1:**\n```\n1\n```\n\nExplanation: The strings obtained by permuting `aab` are `aab`, `aba`, and `baa`. Among these, `aab` and `baa` contain the palindrome `aa` of length 2 as a substring. Thus, the only string that satisfies the condition is `aba`, so print 1.\n\n**Sample Input 2:**\n```\n5 3\nzzyyx\n```\n\n**Sample Output 2:**\n```\n16\n```\n\nExplanation: There are 30 strings obtained by permuting `zzyyx`, 16 of which do not contain a palindrome of length 3. Thus, print 16.\n\n**Sample Input 3:**\n```\n10 5\nabcwxyzyxw\n```\n\n**Sample Output 3:**\n```\n440640\n```\n\nSolution:\n\n```python\nfrom itertools import permutations\n\ndef avoid_k_palindrome(n, k, s):\n    a = [ord(char) - ord('a') for char in s]\n    a.sort()\n    ans = 0\n    \n    perms = set(permutations(a))\n    \n    for perm in perms:\n        ok = True\n        for i in range(n - k + 1):\n            flag = True\n            for j in range(k):\n                if perm[i + j] != perm[i + k - 1 - j]:\n                    flag = False\n                    break\n            if flag:\n                ok = False\n                break\n        if ok:\n            ans += 1\n\n    return ans\n\n# Example usage\nn, k = map(int, input().split())\ns = input()\nprint(avoid_k_palindrome(n, k, s))\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer \\( K \\). For a set \\( S \\) that is initially empty, you need to process \\( Q \\) queries of the following two types in order:\n\n1. `1 x`: An integer \\( x \\) is given. If \\( x \\) is in \\( S \\), remove \\( x \\) from \\( S \\). Otherwise, add \\( x \\) to \\( S \\).\n2. `2 x`: An integer \\( x \\) that is in \\( S \\) is given. Consider a graph where the vertices are the numbers in \\( S \\), and there is an edge between two numbers if and only if the absolute difference between them is at most \\( K \\). Print the count of vertices in the connected component that contains \\( x \\).\n\n**Constraints:**\n\n- \\( 1 \\leq Q \\leq 200,000 \\)\n- \\( 0 \\leq K \\leq 10^{18} \\)\n- For each query, \\( 1 \\leq x \\leq 10^{18} \\).\n- For each query of the second type, the given \\( x \\) is in \\( S \\) at that point.\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nQ K\nquery_1\n...\nquery_Q\n```\nEach query is given in the following format:\n- For type 1 query: `1 x`\n- For type 2 query: `2 x`\n\n**Output:**\n\nProcess the queries and for each query of type 2, output the size of the connected component containing \\( x \\).\n\n**Sample Input 1:**\n```\n7 5\n1 3\n1 10\n2 3\n1 7\n2 3\n1 10\n2 3\n```\n\n**Sample Output 1:**\n```\n1\n3\n2\n```\n\n**Explanation:**\n\n- In the first query, \\( 3 \\) is added to \\( S \\), resulting in \\( S=\\{3\\} \\).\n- In the second query, \\( 10 \\) is added to \\( S \\), resulting in \\( S=\\{3, 10\\} \\).\n- In the third query, consider a graph with vertices \\( 3 \\) and \\( 10 \\) and no edges. The connected component containing \\( 3 \\) has a size of 1, so print 1.\n- In the fourth query, \\( 7 \\) is added to \\( S \\), resulting in \\( S=\\{3, 7, 10\\} \\).\n- In the fifth query, consider a graph with vertices \\( 3, 7, \\) and \\( 10 \\), with edges between \\( 3 \\) and \\( 7 \\), and \\( 7 \\) and \\( 10 \\). The connected component containing \\( 3 \\) has a size of 3, so print 3.\n- In the sixth query, \\( 10 \\) is removed from \\( S \\), resulting in \\( S=\\{3, 7\\} \\).\n- In the seventh query, consider a graph with vertices \\( 3 \\) and \\( 7 \\), with an edge between them. The connected component containing \\( 3 \\) has a size of 2, so print 2.\n\n**Sample Input 2:**\n```\n11 1000000000000000000\n1 1\n1 100\n1 10000\n1 1000000\n1 100000000\n1 10000000000\n1 1000000000000\n1 100000000000000\n1 10000000000000000\n1 1000000000000000000\n2 1\n```\n\n**Sample Output 2:**\n```\n10\n```\n\n**Sample Input 3:**\n```\n8 0\n1 1\n1 2\n2 1\n1 1\n1 2\n1 1\n1 2\n2 1\n```\n\n**Sample Output 3:**\n```\n1\n1\n```\n\nSolution:\n\n```python\nclass SegmentTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (2 * size)\n\n    def update(self, pos, value):\n        pos += self.size\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left, right):\n        result = 0\n        left += self.size\n        right += self.size\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef add_or_remove_edge(segments, A, x):\n    A[x] = 1 - A[x]\n    segments.update(x, A[x])\n\ndef find_connected_component_size(segments, start_x, size):\n    left = start_x\n    right = start_x\n\n    # Extend to the right\n    while right < size - 1 and segments.query(start_x, right + 1) == right + 1 - start_x:\n        right += 1\n\n    # Extend to the left\n    while left > 0 and segments.query(left - 1, start_x) == start_x - left + 1:\n        left -= 1\n\n    return right - left + 1\n\n# Assuming the segment size is known and is sufficient\nsize = 10000\nsegments = SegmentTree(size)\nA = [0] * size\n\n# Example usage\nadd_or_remove_edge(segments, A, 5)\ncomponent_size = find_connected_component_size(segments, 5, size)\nprint(\"Component size:\", component_size)\n```\n\nFor three numbers \\(a < b < c\\) and any \\(K\\), if \\(c-a \\leq K\\), then \\(b-a \\leq K\\) and \\(c-b \\leq K\\). Consequently, if there is an edge between \\(a\\) and \\(c\\), then there are also edges between \\(a\\) and \\(b\\), and \\(b\\) and \\(c\\). Thus, one can only add edges between adjacent elements in the sorted \\(S\\) without changing connectivity.\n\nFirst, consider a graph with \\(N\\) vertices and \\(0\\) edges. Two types of queries are:\n\n1. Given \\(x\\), add an edge between vertices \\(x\\) and \\(x+1\\) if absent, or remove it if present.\n2. Find the size of the connected component containing vertex \\(x\\).\n\nLet \\(A_i\\) be \\(1\\) if there is an edge between \\(i\\) and \\(i+1\\), and \\(0\\) otherwise. The two queries can be processed as follows:\n\n- Addition and deletion of an edge are done by updating \\(A_i\\).\n- To find how far the connected component containing \\(x\\) extends to the right, \\(y > x\\) is connected to \\(x\\) if and only if \\(A[x] + \\ldots + A[y-1] = y-x\\). The maximum such \\(y\\) can be quickly found with binary search by finding the segment sum of \\(A\\). The same applies to the left.\n\nThe altered question can be solved by managing the array \\(A\\) in a segment tree. The original problem asks to add or remove vertices by maintaining the following two arrays \\(A\\) and \\(B\\) as segment trees to manage the existence of vertices and edges:\n\n- \\(A_i = 1\\) if \\(x\\) is contained in \\(S\\), and \\(A_i = 0\\) otherwise.\n- \\(B_i = 1\\) if there is an edge between \\(x\\) and \u201cthe next vertex to the right,\u201d and \\(B_i = 0\\) otherwise.\n\nCoordinate compression or a dynamic segment tree can keep the number of nodes small, making the complexity \\(O(Q\\log Q)\\) or \\(O(Q\\log\\max x_i)\\).\n \n\n", "problem_ids": ["abc370_b", "abc363_c", "abc356_f"]}, "abc323_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of length \\(N\\). On this sequence, the following operation can be performed:\n\nChoose \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Replace each of \\(A_{l+1}, A_{l+2}, \\dots, A_{r-1}\\) with \\(A_l\\). The cost of this operation is \\(r-l-1\\).\n\nYou will repeat this operation until there is no \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Find the minimum total cost of such a series of operations.\n\n**Constraints:**\n- \\(3 \\leq N \\leq 5 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq N\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n7\n1 2 3 2 3 2 1\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n_For example, if you perform the operation with \\((l, r) = (3, 5), (2, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,3,3,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\), after which there is no \\(l\\) and \\(r\\) with the said property. The total cost of this series of operations is \\(1+3+5=9\\)._\n\n_On the other hand, if you perform the operation with \\((l, r) = (2, 4), (4, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,2,2,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\). The total cost of this series of operations is \\(1+1+5=7\\)._\n\n**Sample Input 2:**\n```\n5\n1 2 3 4 5\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n40\n1 2 3 4 5 6 7 8 7 6 5 6 7 8 7 6 5 4 3 2 2 1 2 3 4 5 4 5 6 7 8 7 7 6 5 6 6 7 8 8\n```\n\n**Sample Output 3:**\n```\n44\n```\n\nSolution:\n\n```\nHere's a cleaned-up version of the solution:\n\nStarting from a vertex with color \\(A_i\\) and a piece placed on it, create a tree with colored vertices by performing the following steps for \\(i=2,3,\\dots,N\\): Let \\(pos\\) be the current position. If the color of the vertex at \\(pos\\) is \\(A_i\\), do nothing. If there is an adjacent vertex to \\(pos\\) with color \\(A_i\\), move the piece there. If no such vertex exists, create a new adjacent vertex with color \\(A_i\\) and move the piece there. The colors of adjacent vertices are always distinct. \n\nThe state of the sequence corresponds to a walk on this tree, where operations change a walk \\(u\\rightarrow v\\rightarrow v\\rightarrow \\dots \\rightarrow v\\rightarrow u\\) to \\(u\\rightarrow u\\rightarrow u\\rightarrow \\dots \\rightarrow u\\rightarrow u\\). Let \\(start\\) and \\(goal\\) be the start and end points of the walk. The problem is finding the minimum cost to change the walk into a simple path connecting \\(start\\) and \\(goal\\). \n\nCalculate the minimum cost. Consider parts of the walk off the path connecting \\(start\\) and \\(goal\\), like \\(\\dots \\rightarrow a \\rightarrow b \\rightarrow \\dots \\rightarrow b \\rightarrow a \\rightarrow \\dots\\). Convert \\(b \\rightarrow \\dots \\rightarrow b\\) to stay at \\(a\\), with the cost equivalent to the sum of distances to \\(a\\). The problem becomes: \n\nGiven \\(V=(v_1,v_2,\\dots,v_n)\\) with:\n\n\\(v_1=1, v_n=\\max_{1\\leq i \\leq n} v_i\\)\n\\(|v_i-v_{i+1}| \\in \\{0,1\\}\\),\n\nFind the minimum \\(\\sum |v_i-v'_i|\\) for \\(V'=(v'_1,v'_2,\\dots,v'_n)\\) where:\n\n\\(v'_1=v_1, v'_n=v_n\\)\n\\(v'_i \\leq v'_{i+1}\\)\nIf \\(v'_i \\neq v'_{i+1}\\), then \\(v_i=v'_i\\) and \\(v_{i+1}=v'_{i+1}\\).\n\nSolve this using dynamic programming in \\(O(N)\\): \n\nUse \\(dp[k]=\\) the minimum value of \\(\\sum_{k \\leq i} |v_i-v'_i|\\) when \\(v'_k=v_k\\). If \\(v_{k+1}=v_k+1\\), update \\(dp[k] \\leftarrow \\min(dp[k],dp[k+1])\\). Let \\(k'\\) be the smallest \\(i\\ (k < i)\\) such that \\(v_{i}=v_k\\), then update \\(dp[k] \\leftarrow \\min(dp[k],dp[k']+\\sum_{i=k+1}^{k'}|v_k-v_i|)\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere is a directed graph with \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) and \\( N \\) edges. The out-degree of every vertex is \\( 1 \\), and the edge from vertex \\( i \\) points to vertex \\( a_i \\). Count the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\).\n\nHere, vertex \\( v \\) is reachable from vertex \\( u \\) if there exists a sequence of vertices \\( w_0, w_1, \\ldots, w_K \\) of length \\( K+1 \\) that satisfies the following conditions. In particular, if \\( u = v \\), it is always reachable:\n- \\( w_0 = u \\).\n- \\( w_K = v \\).\n- For every \\( 0 \\leq i < K \\), there is an edge from vertex \\( w_i \\) to vertex \\( w_{i+1} \\).\n\n### Constraints\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n\n```\nN\na_1 a_2 \\ldots a_N\n```\n\n### Output\nPrint the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\).\n\n### Sample Input 1\n```\n4\n2 1 1 4\n```\n\n### Sample Output 1\n```\n8\n```\n\n**Explanation:**\n\n- The vertices reachable from vertex \\( 1 \\) are vertices \\( 1, 2 \\).\n- The vertices reachable from vertex \\( 2 \\) are vertices \\( 1, 2 \\).\n- The vertices reachable from vertex \\( 3 \\) are vertices \\( 1, 2, 3 \\).\n- The vertex reachable from vertex \\( 4 \\) is vertex \\( 4 \\).\n\nTherefore, the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\) is \\( 8 \\).\n\nNote that the edge from vertex \\( 4 \\) is a self-loop, that is, it points to vertex \\( 4 \\) itself.\n\n### Sample Input 2\n```\n5\n2 4 3 1 2\n```\n\n### Sample Output 2\n```\n14\n```\n\n### Sample Input 3\n```\n10\n6 10 4 1 5 9 8 6 5 1\n```\n\n### Sample Output 3\n```\n41\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial discusses a problem involving a functional graph, a common topic in competitive programming. A functional graph consists of connected components, each having exactly one cycle. The solution involves examining each connected component with a cycle and directed trees attached. For any vertex \\(u\\), all reachable vertices are either ancestors of \\(u\\) within its directed tree or part of the cycle that includes the root of this tree. To compute the reachable vertices, you should determine the depth of \\(u\\) in its directed tree and the number of vertices in the cycle using graph search algorithms like DFS. The algorithm's complexity is \\(\\mathrm{O}(N)\\), or alternatively, the SCC algorithm can be used.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n### Problem Statement\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\).\n\nYour objective is to transform this permutation into the identity permutation \\( P_i = i \\) for all \\( i = 1, 2, \\ldots, N \\) by performing the following operation zero or more times:\n\n1. Choose an integer \\( k \\) such that \\( 1 \\leq k \\leq N \\).\n2. If \\( k \\geq 2 \\), sort the elements from the 1st to the \\((k-1)\\)-th position of \\( P \\) in ascending order.\n3. Then, if \\( k \\leq N - 1 \\), sort the elements from the \\((k+1)\\)-th to the \\( N \\)-th position of \\( P \\) in ascending order.\n\nIt can be proved that under the constraints of this problem, it is possible to transform any given permutation \\( P \\) into the identity permutation with a finite number of operations. Your task is to find the minimum number of operations required.\n\nYou have \\( T \\) test cases to solve.\n\n### Constraints\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 3 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( P \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n- The sum of \\( N \\) across the test cases in a single input is at most \\( 2 \\times 10^5 \\).\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\n...\ncase_T\n```\n\nEach case is presented as follows:\n\n```\nN\nP_1 P_2 ... P_N\n```\n\n### Output\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\n\n### Sample Input 1\n\n```\n3\n5\n2 1 3 5 4\n3\n1 2 3\n7\n3 2 1 7 5 6 4\n```\n\n### Sample Output 1\n\n```\n1\n0\n2\n```\n\n#### Explanation:\n\n- For the first test case, the operation with \\( k = 3 \\) yields \\( P \\) as \\( (1, 2, 3, 4, 5) \\), requiring 1 operation.\n- The second test case already satisfies \\( P_i = i \\), thus needing 0 operations.\n- For the third test case, perform the operations with \\( k = 4 \\) and then \\( k = 3 \\) successively to achieve the identity permutation \\( (1, 2, 3, 4, 5, 6, 7) \\), requiring 2 operations.\n\nSolution:\n\n---\n\nSince each operation sorts a significant portion of the array, it is expected that the entire array can be sorted with a few operations. In fact:\n\n1. Perform the operation with \\(k=1\\). This sorts the entire array if \\(P_1=1\\) in the initial state. Otherwise, we have \\(P_N \\neq 1\\) after the operation since \\(N \\geq 3\\).\n2. Next, perform the operation with \\(k=N\\). Since \\(P_N \\neq 1\\) before the operation, we have \\(P_1=1\\) after the operation.\n3. Perform the operation with \\(k=1\\). Since \\(P_1=1\\) before the operation, the entire array is certainly sorted after the operation.\n\nBy performing the above, any permutation can be sorted in at most three operations. Therefore, it is sufficient to quickly determine if the array can be sorted in zero, one, or two operations.\n\n- The determination for zero operations is trivial.\n- For one operation, if we fix \\(k\\), it is necessary and sufficient that the minimum and maximum values of \\((P_1, P_2, \\dots, P_{k-1})\\) are \\(1\\) and \\(k-1\\), respectively, and \\(P_k=k\\). This can be checked in \\(O(1)\\) time for each \\(k\\) by taking cumulative \\(\\min\\) and \\(\\max\\), so the overall determination can be done in \\(O(N)\\) time.\n- For two operations, if \\(P_N \\neq 1\\), starting from the second of the three operations, the array can be sorted in two operations. Similarly, if \\(P_1 \\neq N\\), it can be sorted in two operations. Conversely, if \\(P_1=N\\) and \\(P_N=1\\), the relative positions of \\(1\\) and \\(N\\) in \\(P\\) do not change with one operation, leaving them in the order \\(N, 1\\). Therefore, \\(P\\) can be sorted in two or fewer operations \\(\\iff\\) \\(P_1 \\neq N\\) or \\(P_N \\neq 1\\). This can be checked in \\(O(1)\\) time.\n\nFrom the above, the answer for each test case can be found in \\(O(N)\\) time.\n \n\n", "problem_ids": ["arc181_f", "abc357_e", "arc181_a"]}, "abc323_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Score:** 475 points\n\n**Problem Statement**\n\nIn the nation of Atcoder, there are \\( N \\) cities numbered from 1 to \\( N \\), and \\( M \\) trains numbered from 1 to \\( M \\). Train \\( i \\) departs from city \\( A_i \\) at time \\( S_i \\) and arrives at city \\( B_i \\) at time \\( T_i \\).\n\nGiven a positive integer \\( X_1 \\), find a way to determine non-negative integers \\( X_2, \\ldots, X_M \\) that satisfy the following condition while minimizing the value of \\( X_2 + \\ldots + X_M \\).\n\n**Condition:**\n\nFor all pairs \\( (i, j) \\) satisfying \\( 1 \\leq i, j \\leq M \\), if \\( B_i = A_j \\) and \\( T_i \\leq S_j \\), then \\( T_i + X_i \\leq S_j + X_j \\).\n\nIn other words, for any pair of trains that were originally possible to transfer between, it must still be possible to transfer even after delaying the departure and arrival times of each train \\( i \\) by \\( X_i \\).\n\nIt can be proved that there is a unique way to set \\( X_2, \\ldots, X_M \\) with the minimum possible value of \\( X_2 + \\ldots + X_M \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( A_i \\neq B_i \\)\n- \\( 0 \\leq S_i < T_i \\leq 10^9 \\)\n- \\( 1 \\leq X_1 \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M X_1\nA_1 B_1 S_1 T_1\n\u22ee\nA_M B_M S_M T_M\n```\n\n**Output**\n\nPrint \\( X_2, \\ldots, X_M \\) that satisfy the condition with the minimum possible sum, in that order, separated by spaces.\n\n**Sample Input 1**\n\n```\n3 6 15\n1 2 10 20\n1 2 20 30\n2 3 25 40\n2 3 35 50\n3 1 15 30\n3 1 45 60\n```\n\n**Sample Output 1**\n\n```\n0 10 0 0 5\n```\n\n**Explanation**\n\nThe arrival of train 1 from city 1 to 2 is delayed by 15 and becomes time 35. To allow transfer from train 1 to 3 in city 2, the departure of train 3 is delayed by 10, making it depart at time 35 and arrive at time 50. Further, to allow transfer from train 3 to 6 in city 3, the departure of train 6 is delayed by 5, making it depart at time 50. Other trains can operate without delay while still allowing transfers between originally transferable trains, so \\( (X_2, X_3, X_4, X_5, X_6) = (0, 10, 0, 0, 5) \\) satisfies the condition. Moreover, there is no solution with a smaller sum that satisfies the condition, so this is the answer.\n\n**Sample Input 2**\n\n```\n10 9 100\n1 10 0 1\n10 2 1 100\n10 3 1 100\n10 4 1 100\n10 5 1 100\n10 6 1 100\n10 7 1 100\n10 8 1 100\n10 9 1 100\n```\n\n**Sample Output 2**\n\n```\n100 100 100 100 100 100 100 100\n```\n\n**Sample Input 3**\n\n```\n4 4 10\n1 2 0 1\n1 2 0 10\n2 3 100 200\n2 4 100 200\n```\n\n**Sample Output 3**\n\n```\n0 0 0\n```\n\nSolution:\n\nHere's the trimmed version focusing on the solution:\n\n---\n\n**E - Train Delay Editorial**\n\nLet us call \\(S_i\\) and \\(T_i\\) the scheduled departure and arrival, respectively, and \\(S_i+X_i\\) and \\(T_i+X_i\\) the actual departure and arrival. If you let a train depart later, you cannot make another depart earlier, so assume every train departs as early as possible. Whether a train \\(i\\) can depart is affected by trains whose scheduled arrival is prior to the departure of train \\(i\\). Therefore, processing trains in order of their scheduled times is effective.\n\nSort the \\(2M\\) departure/arrival events in ascending order:\n\n- When train \\(i\\) departs, find \\(X_i\\) based on the actual arrivals to station \\(A_i\\) for trains processed so far.\n- When train \\(i\\) arrives, record the actual arrival to station \\(B_i\\) based on \\(X_i\\).\n\nThese steps can be done in \\(O(1)\\) time by managing for each station the latest actual arrival of the trains processed so far. If departure and arrival occur simultaneously, process arrivals first.\n\n```python\nN, M, X = map(int, input().split())\nA, B, S, T = zip(*[tuple(map(int, input().split())) for _ in range(M)])\n\nevent = sorted([(S[i], 1, i) for i in range(M)] + [(T[i], 0, i) for i in range(M)])\n\nans = [0] * M\nans[0] = X\n\nstation = [0] * (N + 1)\nfor t, f, i in event:\n  if f:\n    if i:\n      ans[i] = max(0, station[A[i]] - t)\n  else:\n    station[B[i]] = max(station[B[i]], t + ans[i])\n\nprint(*ans[1:])\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence of \\( N \\) positive integers \\( A = (A_1, A_2, \\dots, A_N) \\), where each element is at least \\( 2 \\). Anna and Bruno play a game using these integers. They take turns, with Anna going first, performing the following operation:\n\n- Choose an integer \\( i \\) \\((1 \\leq i \\leq N)\\) freely. Then, freely choose a positive divisor \\( x \\) of \\( A_i \\) that is not \\( A_i \\) itself, and replace \\( A_i \\) with \\( x \\).\n\nThe player who cannot perform the operation loses, and the other player wins. Determine who wins assuming both players play optimally for victory.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 2 \\leq A_i \\leq 10^5 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nPrint `Anna` if Anna wins the game, and `Bruno` if Bruno wins.\n\n**Sample Input 1**\n```\n3\n2 3 4\n```\n\n**Sample Output 1**\n```\nAnna\n```\n\nFor example, the game might proceed as follows. Note that this example may not necessarily represent optimal play by both players:\n- Anna changes \\( A_3 \\) to \\( 2 \\).\n- Bruno changes \\( A_1 \\) to \\( 1 \\).\n- Anna changes \\( A_2 \\) to \\( 1 \\).\n- Bruno changes \\( A_3 \\) to \\( 1 \\).\n\nAnna cannot operate on her turn, so Bruno wins. Actually, for this sample, Anna always wins if she plays optimally.\n\n**Sample Input 2**\n```\n4\n2 3 4 6\n```\n\n**Sample Output 2**\n```\nBruno\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere is the cleaned version of the editorial text:\n\nThis algorithm requires the knowledge of the Grundy number. If you are unfamiliar with it, refer to the editorial for ABC255-G or online articles. To find the Grundy number for each \\(i\\), observe the operation where \\(A_i\\) is replaced with a positive divisor other than itself, reducing one or more prime factors including duplicates. Let \\(x_i\\) represent the number of prime factors of \\(A_i\\), counting duplicates. The game in this problem involves \\(x_i\\) stones in the \\(i\\)-th pile, where players take turns removing stones until one cannot make a move and loses. This is equivalent to Nim, where the Grundy number of \\(A_i\\) is \\(x_i\\). Using the Sieve of Eratosthenes provides an algorithm that runs in \\(O(N + T \\log \\log T)\\) time, with \\(T\\) as the maximum value of \\(A\\). The \\(O(N \\sqrt T)\\) algorithm for naive prime factorization is also sufficiently fast.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere is a simple directed graph \\(G\\) with \\(N\\) vertices and \\(N+M\\) edges. The vertices are numbered \\(1\\) to \\(N\\), and the edges are numbered \\(1\\) to \\(N+M\\).\n\n- Edge \\(i\\) \\((1 \\leq i \\leq N)\\) goes from vertex \\(i\\) to vertex \\(i+1\\). Here, vertex \\(N+1\\) is considered as vertex \\(1\\).\n- Edge \\(N+i\\) \\((1 \\leq i \\leq M)\\) goes from vertex \\(X_i\\) to vertex \\(Y_i\\).\n\nTakahashi is at vertex \\(1\\). At each vertex, he can move to any vertex to which there is an outgoing edge from the current vertex.\n\nCompute the number of ways he can move exactly \\(K\\) times.\n\nThat is, find the number of integer sequences \\((v_0, v_1, \\dots, v_K)\\) of length \\(K+1\\) satisfying all of the following three conditions:\n- \\(1 \\leq v_i \\leq N\\) for \\(i = 0, 1, \\dots, K\\).\n- \\(v_0 = 1\\).\n- There is a directed edge from vertex \\(v_{i-1}\\) to vertex \\(v_i\\) for \\(i = 1, 2, \\ldots, K\\).\n\nSince this number can be very large, print it modulo \\(998244353\\).\n\n**Constraints**:\n- \\(2 \\leq N \\leq 2 \\times 10^5\\)\n- \\(0 \\leq M \\leq 50\\)\n- \\(1 \\leq K \\leq 2 \\times 10^5\\)\n- \\(1 \\leq X_i, Y_i \\leq N\\), \\(X_i \\neq Y_i\\)\n- All of the \\(N+M\\) directed edges are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M K\nX_1 Y_1\nX_2 Y_2\n\u22ee\nX_M Y_M\n```\n\n**Output**\n\nPrint the count modulo \\(998244353\\).\n\n**Sample Input 1**\n```\n6 2 5\n1 4\n2 5\n```\n\n**Sample Output 1**\n```\n5\n```\n\nThe above figure represents the graph \\(G\\). There are five ways for Takahashi to move:\n- Vertex \\(1 \\to\\) Vertex \\(2 \\to\\) Vertex \\(3 \\to\\) Vertex \\(4 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6\\)\n- Vertex \\(1 \\to\\) Vertex \\(2 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6 \\to\\) Vertex \\(1 \\to\\) Vertex \\(2\\)\n- Vertex \\(1 \\to\\) Vertex \\(2 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6 \\to\\) Vertex \\(1 \\to\\) Vertex \\(4\\)\n- Vertex \\(1 \\to\\) Vertex \\(4 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6 \\to\\) Vertex \\(1 \\to\\) Vertex \\(2\\)\n- Vertex \\(1 \\to\\) Vertex \\(4 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6 \\to\\) Vertex \\(1 \\to\\) Vertex \\(4\\)\n\n**Sample Input 2**\n```\n10 0 200000\n```\n\n**Sample Output 2**\n```\n1\n```\n\n**Sample Input 3**\n```\n199 10 1326\n122 39\n142 49\n164 119\n197 127\n188 145\n69 80\n6 120\n24 160\n18 154\n185 27\n```\n\n**Sample Output 3**\n```\n451022766\n```\n\nSolution:\n\n```python\nn, m, k = map(int, input().split())\nif m == 0:\n    print(1)\n    exit()\nedges = []\ns = set([0])\nfor i in range(m):\n    x, y = map(lambda x: int(x) - 1, input().split())\n    s.add(x)\n    s.add(y)\n    edges.append((x, y))\n\ns = sorted(list(s))\nd = {}\nsz = len(s)\nfor i in range(sz):\n    d[s[i]] = i\nedge = [[] for i in range(sz)]\nfor i in range(sz):\n    edge[i].append(((i + 1) % sz, (s[(i + 1) % sz] - s[i]) % n))\nfor x, y in edges:\n    edge[d[x]].append((d[y], 1))\n\nmod = 998244353\ndp = [[0] * sz for i in range(k)]\ndp[0][0] = 1\nans = 0\nfor i in range(k):\n    for v in range(sz):\n        for to, w in edge[v]:\n            if i + w >= k:\n                ans += dp[i][v]\n                ans %= mod\n            else:\n                dp[i + w][to] += dp[i][v]\n                dp[i + w][to] %= mod\n\nprint(ans)\n```\n \n\n", "problem_ids": ["abc368_e", "abc368_f", "abc372_f"]}, "abc324_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\).\n\nYou can perform the following operation any number of times, possibly zero: Choose an integer pair \\((i, j)\\) satisfying \\(1 \\leq i < j \\leq N\\), and replace \\(A_i\\) with \\(A_i + 1\\) and \\(A_j\\) with \\(A_j - 1\\).\n\nDetermine whether it is possible to make \\( A \\) a non-decreasing sequence through the operations.\n\nYou are given \\( T \\) test cases. Solve each of them.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format. Here, \\( \\mathrm{case}_i \\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\nFor each test case, if it is possible to make \\( A \\) a non-decreasing sequence through the operations, print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n\n```\n3\n3\n1 7 5\n2\n9 0\n10\n607 495 419 894 610 636 465 331 925 724\n```\n\n**Sample Output 1**\n\n```\nYes\nNo\nYes\n```\n\nIn the first test case, you can make \\( A \\) into a non-decreasing sequence by performing the following operations:\n1. Choose \\((i, j) = (1, 2)\\). After the operation, \\( A \\) is \\( (2, 6, 5) \\).\n2. Choose \\((i, j) = (1, 2)\\). After the operation, \\( A \\) is \\( (3, 5, 5) \\).\n\nIn the second test case, you cannot make \\( A \\) into a non-decreasing sequence no matter how you perform the operations.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - AtCoder Regular Contest 185\n\nB - +1 and -1 Editorial by evima\n\nIt is possible to turn \\(A\\) into a non-decreasing sequence if and only if the following condition is satisfied: A non-decreasing sequence where the difference between the maximum and minimum values is at most \\(1\\) is called a good sequence. It is possible to turn \\(A\\) into a good sequence through operations.\n\nProof: If we can make \\(A\\) into a good sequence, then \\(A\\) can be made into a non-decreasing sequence. Suppose we transform \\(A\\) into a non-decreasing sequence. After that, we can perform operations to transform \\(A\\) into a good sequence:\n\nInvariant: Initially, the sequence \\((A_1)\\) is a good sequence, and \\(A\\) is non-decreasing. For \\(i = 2, 3, \\dots, N\\), do the following:\n\nInvariant: \\((A_1, A_2, \\dots, A_{i-1})\\) is a good sequence. While \\((A_1, A_2, \\dots, A_i)\\) is not a good sequence, find exactly one position \\(j\\) \\((1 \\leq j \\leq i-1)\\) where adding \\(1\\) to \\(A_j\\) maintains \\((A_1, A_2, \\dots, A_{i-1})\\) as a good sequence. Perform the operation on \\((j, i)\\).\n\nRepeat the operation until \\((A_1, A_2, \\dots, A_i)\\) becomes a good sequence. \\((A_1, A_2, \\dots, A_i)\\) becomes a good sequence if \\(A_{i-1}\\) and \\(A_i\\) coincide, reducing the difference by \\(1\\) or \\(2\\). If it is not obtained, choosing \\(j = i - 1\\) when the difference is \\(1\\) results in \\((A_1, A_2, \\dots, A_{i-1}, A_i) = (x, x, \\dots, x, x+1)\\), which is a good sequence, so no operation is performed.\n\nAfter the operation, \\((A_1, A_2, \\dots, A_i)\\) is a good sequence, and \\(A_i \\leq A_{i+1}\\), so \\(A\\) remains non-decreasing.\n\nThus, the two propositions are equivalent. We can determine if \\(A\\) can become a good sequence in \\(\\mathrm{O}(N)\\) time using cumulative sums, solving this problem in \\(\\mathrm{O}(N)\\) per test case.\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land sells tiles with English letters written on them. Takahashi is thinking of making a nameplate by arranging these tiles in a row.\n\nFind the number, modulo 998244353, of strings consisting of uppercase English letters with a length between 1 and K, inclusive, that satisfy the following conditions:\n\n- For every integer \\(i\\) satisfying \\(1 \\leq i \\leq 26\\), the following holds:\n  - Let \\(a_i\\) be the \\(i\\)-th uppercase English letter in lexicographical order. For example, \\(a_1 = A\\), \\(a_5 = E\\), \\(a_{26} = Z\\).\n  - The number of occurrences of \\(a_i\\) in the string is between 0 and \\(C_i\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq K \\leq 1000\\)\n- \\(0 \\leq C_i \\leq 1000\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nK\nC_1 C_2 \\ldots C_{26}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2\n2 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 1**\n\n```\n10\n```\n\nThe 10 strings that satisfy the conditions are: A, B, C, AA, AB, AC, BA, BC, CA, CB.\n\n**Sample Input 2**\n\n```\n358\n1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 2**\n\n```\n64\n```\n\n**Sample Input 3**\n\n```\n1000\n1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n```\n\n**Sample Output 3**\n\n```\n270274035\n```\n\nSolution:\n\nHere is a concise version of the editorial text:\n\nConsider counting conforming strings for each number of occurrences of z, finding the answer as their sum. Suppose a length-\\(s\\) string has \\(t\\) occurrences of z; there are \\(\\binom{s}{t}\\) ways to determine the positions of z. The other positions form a string of length \\((s-t)\\) without z, where \\(a_i\\) occurs between \\(0\\) and \\(C_i\\) times. Repeat this for letters down to x. Use DP with \\(dp_{i,j}\\) as the number of length-\\(j\\) strings from \\(a_1, a_2, \\ldots, a_i\\) where each \\(a_k\\) occurs between \\(0\\) and \\(C_k\\) times. The formula is \\(dp_{i + 1, j} = \\sum_{k = 0}^{\\min(j, C_{i+1})} dp_{i,j-k} \\binom{j}{k}\\). The answer is \\(\\sum_{j= 1}^{K}dp_{26, j}\\). Precompute binomial coefficients for an \\(O(\\sigma K^2)\\) solution, where \\(\\sigma = 26\\).\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nTakahashi decided to make takoyaki (octopus balls) and serve it to Snuke. Takahashi instructed Snuke to raise only his left hand if he wants to eat takoyaki, and only his right hand otherwise.\n\nYou are given the information about which hand Snuke is raising as two integers L and R. He is raising his left hand if and only if L = 1, and raising his right hand if and only if R = 1. He might not follow the instructions and could raise both hands or not raise any hand at all.\n\n- If Snuke is raising only one hand, print \"Yes\" if he wants to eat takoyaki, and \"No\" if he does not.\n- If he is raising both hands or not raising any hand, print \"Invalid\".\n\nAssume that if Snuke is raising only one hand, he is always following the instructions.\n\n**Constraints:**\n- Each of L and R is 0 or 1.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nL R\n```\n\n**Output:**\nPrint \"Yes\", \"No\", or \"Invalid\" according to the instructions in the problem statement.\n\n**Sample Input 1:**\n```\n1 0\n```\n\n**Sample Output 1:**\n```\nYes\n```\nSnuke wants to eat takoyaki, so he is raising only his left hand.\n\n**Sample Input 2:**\n```\n1 1\n```\n\n**Sample Output 2:**\n```\nInvalid\n```\nSnuke is raising both hands.\n\nSolution:\n\n        [BEGIN TEXT]\n        Toyota Programming Contest 2024#9\uff08AtCoder Beginner Contest 370\uff09\n\nDivide into cases based on the values \\(L\\) and \\(R\\). If \\(L = 0\\) and \\(R = 0\\), print Invalid; if \\(L = 0\\) and \\(R = 1\\), print No; if \\(L = 1\\) and \\(R = 0\\), print Yes; and if \\(L = 1\\) and \\(R = 1\\), print Invalid.\n\nSample code:\n```python\nl, r = map(int, input().split())\nif l == 0 and r == 0:\n    print(\"Invalid\")\nelif l == 0 and r == 1:\n    print(\"No\")\nelif l == 1 and r == 0:\n    print(\"Yes\")\nelse:\n    print(\"Invalid\")\n```\n        [END TEXT]\n \n\n", "problem_ids": ["arc185_b", "abc358_e", "abc370_a"]}, "abc324_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 150 points\n\nProblem Statement:\nThere are \\(2N\\) people standing in a row, and the person at the \\(i\\)-th position from the left is wearing clothes of color \\(A_i\\). The clothes have \\(N\\) colors from \\(1\\) to \\(N\\), and exactly two people are wearing clothes of each color.\n\nFind how many of the integers \\(i=1,2,\\ldots,N\\) satisfy the following condition:\n- There is exactly one person between the two people wearing clothes of color \\(i\\).\n\nConstraints:\n- \\(2 \\leq N \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- Each integer from \\(1\\) through \\(N\\) appears exactly twice in \\(A\\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{2N}\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n3\n1 2 1 3 2 3\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation:\nThere are two values of \\(i\\) that satisfy the condition: \\(1\\) and \\(3\\).\nIn fact, the people wearing clothes of color \\(1\\) are at the 1st and 3rd positions from the left, with exactly one person in between.\n\nSample Input 2:\n```\n2\n1 1 2 2\n```\n\nSample Output 2:\n```\n0\n```\n\nExplanation:\nThere may be no \\(i\\) that satisfies the condition.\n\nSample Input 3:\n```\n4\n4 3 2 3 2 1 4 1\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nB - Couples Editorial by en_translator\n\nBy mathematically interpreting the problem statement, it turns out that it is asking to count \\(i\\) such that \\(A_i=A_{i+2}\\). Use for and if statements to check if each \\(i\\) satisfies the condition. Sample code (Python3):\n\n```python\nn = int(input())\na = [int(input()) for _ in range(n * 2)]\nres = 0\nfor i in range(n * 2 - 2):\n    if a[i] == a[i + 2]:\n        res += 1\nprint(res)\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( K \\).\n\nThe **cumulative sums** of an integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is defined as a sequence \\( Y = (Y_0, Y_1, \\dots, Y_N) \\) of length \\( N+1 \\) as follows:\n\n- \\( Y_0 = 0 \\)\n- \\( Y_i = \\sum_{j=1}^{i} X_j \\) for \\( i = 1, 2, \\dots, N \\)\n\nAn integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is called a **good sequence** if and only if it satisfies the following condition:\n\n- Any value in the cumulative sums of \\( X \\) that is less than \\( K \\) appears before any value that is not less than \\( K \\).\n  \n  Formally, for the cumulative sums \\( Y \\) of \\( X \\), for any pair of integers \\( (i, j) \\) such that \\( 0 \\le i, j \\le N \\), if \\( (Y_i < K \\) and \\( Y_j \\ge K) \\), then \\( i < j \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). Determine whether the elements of \\( A \\) can be rearranged to form a good sequence. If so, print one such rearrangement.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq K \\leq 10^9 \\)\n- \\( -10^9 \\leq A_i \\leq 10^9 \\)\n\nAll input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nIf the elements of \\( A \\) can be rearranged to a good sequence, print the rearranged sequence \\( (A'_1, A'_2, \\dots, A'_N) \\) in the following format:\n\n```\nYes\nA'_1 A'_2 \\cdots A'_N\n```\n\nIf there are multiple valid rearrangements, any of them is considered correct.\n\nIf a good sequence cannot be obtained, print `No`.\n\n**Sample Input 1**\n```\n4 1\n-1 2 -3 4\n```\n\n**Sample Output 1**\n```\nYes\n-3 -1 2 4\n```\n\nIf you rearrange \\( A \\) to \\((-3, -1, 2, 4)\\), the cumulative sums \\( Y \\) will be \\( (0, -3, -4, -2, 2) \\). In this \\( Y \\), any value less than 1 appears before any value not less than 1.\n\n**Sample Input 2**\n```\n4 -1\n1 -2 3 -4\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n10 1000000000\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\nYes\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 179 - A - Partition Editorial by evima\n\nIf \\(K \\geq 1\\):\nBy sorting \\(A\\) in ascending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in ascending order. Let \\(B\\) be the cumulative sums of \\(A\\). Values in \\(A\\) that are less than \\(0\\) appear before values that are \\(0\\) or greater. Therefore, \\(B\\) can be represented as a concatenation of a strictly decreasing sequence and a non-decreasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 < K\\) and decreasing for a while, it begins to increase from a value less than \\(K\\). Once it becomes \\(K\\) or greater, it remains so thereafter. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i \\geq K\\):\nBy sorting \\(A\\) in descending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in descending order. Let \\(B\\) be the cumulative sum of \\(A\\). Values in \\(A\\) that are \\(0\\) or greater appear before values that are less than \\(0\\). Therefore, \\(B\\) can be represented as a concatenation of a strictly increasing sequence and a non-increasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 \\geq K\\) and increasing for a while, it begins to decrease from a value not less than \\(K\\). Since \\(B_0 \\geq K\\), it is \\(K\\) or greater from the start, and since \\(B_N = \\sum_{i=1}^{N}A_i \\geq K\\), it remains \\(K\\) or greater until the end. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i < K\\):\nNo matter how \\(A\\) is rearranged, it cannot be made into a good sequence. No matter how \\(A\\) is rearranged, the initial and final terms of the cumulative sum \\(B\\) of \\(A\\) are fixed. Since \\(B_0 = 0 \\geq K\\) and \\(B_N = \\sum_{i=1}^{N}A_i < K\\), it does not satisfy the conditions for a good sequence.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 800 points\n\nProblem Statement: For positive integers \\(h\\) and \\(w\\), let \\((h, w)\\) denote a rectangle with height \\(h\\) and width \\(w\\). In this problem, rectangles are not considered to be rotatable, thus the rectangles \\((h, w)\\) and \\((w, h)\\) are considered different if \\(h \\neq w\\).\n\nA sequence of rectangles \\(((h_1, w_1), (h_2, w_2), \\dots, (h_n, w_n))\\) is called a **rectangle generation sequence** if there is a method that successfully follows the steps below:\n\n1. Let the rectangle \\(X\\) be \\((h_1, w_1)\\). Hereafter, let \\(H\\) and \\(W\\) denote the height and width of the rectangle \\(X\\) at each step.\n2. For \\(i = 2, 3, \\dots, n\\), perform one of the following operations. If neither can be performed, the procedure terminates unsuccessfully:\n   - If the height of \\(X\\) is equal to \\(h_i\\), attach the rectangle \\((h_i, w_i)\\) horizontally to \\(X\\). Formally, if \\(H = h_i\\) at that time, replace \\(X\\) with the rectangle \\((H, W + w_i)\\).\n   - If the width of \\(X\\) is equal to \\(w_i\\), attach the rectangle \\((h_i, w_i)\\) vertically to \\(X\\). Formally, if \\(W = w_i\\) at that time, replace \\(X\\) with the rectangle \\((H + h_i, W)\\).\n3. If the above series of operations does not fail, the procedure terminates successfully.\n\nYou are given \\(N\\) rectangles. The \\(i\\)-th rectangle has a height of \\(H_i\\) and a width of \\(W_i\\).\n\nFind the number of pairs of positive integers \\((l, r)\\) that satisfy \\(1 \\le l \\le r \\le N\\) and the following condition:\n\n- The sequence of rectangles \\(((H_l, W_l), (H_{l+1}, W_{l+1}), \\dots, (H_r, W_r))\\) is a rectangle generation sequence.\n\nConstraints:\n- \\(1 \\leq N \\leq 3 \\times 10^5\\)\n- \\(1 \\leq H_i, W_i \\leq 10^6\\)\n- All input values are integers.\n\nInput: The input is given from Standard Input in the following format:\n```\nN\nH_1 W_1\nH_2 W_2\n...\nH_N W_N\n```\n\nOutput: Print the answer.\n\nSample Input 1:\n```\n4\n1 2\n1 3\n2 3\n3 1\n```\n\nSample Output 1:\n```\n7\n```\nThe pairs \\((l, r)\\) that satisfy the condition are \\((1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (4, 4)\\); there are seven. For example, for \\((l, r) = (2, 4)\\), the procedure succeeds if the first attachment is done vertically and the second is done horizontally.\n\nSample Input 2:\n```\n5\n2 1\n2 1\n1 2\n3 2\n1 4\n```\n\nSample Output 2:\n```\n10\n```\n\nSample Input 3:\n```\n1\n1000000 1000000\n```\n\nSample Output 3:\n```\n1\n```\n\nSample Input 4:\n```\n10\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\nSample Output 4:\n```\n55\n```\n\nSolution:\n\n[BEGIN TEXT]\nObservation of Combining Rectangles: Let\u2019s consider combining rectangles consecutively. Starting from \\((h_1, w_1)\\), we combine \\((h_2, w_2)\\), and then continue to combine \\((h_3, w_3)\\). The condition is that if \\((h_2, w_2)\\) can be combined vertically/horizontally, then \\((h_3, w_3)\\) can also be combined similarly. For example, when \\(h_2 = h_3\\), if \\((h_2, w_2)\\) can be combined horizontally, then \\((h_3, w_3)\\) can also be combined horizontally. Similarly, when \\(w_2 = w_3\\), if \\((h_2, w_2)\\) can be combined vertically, then \\((h_3, w_3)\\) can also be combined vertically. \n\nCorrespondence to Graph and Counting: Let\u2019s count the number of pairs \\((l, r)\\) that satisfy the condition. When \\(l\\) is fixed, whether \\((l, r)\\) satisfies the condition is monotonic with respect to \\(r\\). For the orientation of the combination of two consecutive rectangles, we can determine whether the latter can be combined if the former can be combined. Represent this information in a graph with \\(2 \\times N\\) vertices.\n\nFor \\(i = 1, 2, \\dots, N\\), let vertex \\(i\\) represent that \\((H_i, W_i)\\) can be combined vertically, and vertex \\(N + i\\) represent that \\((H_i, W_i)\\) can be combined horizontally. For \\(i = 2, 3, \\dots, N\\):\n\n- If \\((H_{i-1}, W_{i-1})\\) can be combined vertically, and \\((H_i, W_i)\\) can also be combined vertically, span an edge between vertices \\(i-1\\) and \\(i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined vertically, and \\((H_i, W_i)\\) can be combined horizontally, span an edge between vertices \\(i-1\\) and \\(N + i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined horizontally, and \\((H_i, W_i)\\) can be combined vertically, span an edge between vertices \\(N + i - 1\\) and \\(i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined horizontally, and \\((H_i, W_i)\\) can be combined horizontally, span an edge between vertices \\(N + i - 1\\) and \\(N + i\\).\n\nAssume that \\((H_l, W_l)\\) can be combined both horizontally and vertically. Then, \\((l, r)\\) satisfies the condition if and only if either vertex \\(l\\) or \\(N + l\\) is connected to either vertex \\(r\\) or \\(N + r\\). Edges corresponding to combinations with different orientations will be spanned for at most one \\(l\\). Edges corresponding to combinations with the same orientation will be spanned for any \\(l\\) if they are initially spanned.\n\nRepresent the edges of the graph as a \\(2 \\times 2\\) matrix and load it on a segment tree. By performing binary search on the segment tree to find the maximum \\(r\\) that satisfies the condition, and updating the graph with segment tree updates, we process all \\(l\\) in \\(\\mathrm{O}(N \\log N)\\) time complexity.\n[END TEXT]\n \n\n", "problem_ids": ["abc359_b", "arc179_a", "arc179_e"]}, "abc324_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n Problem Statement:  \nYou are given integers \\( N \\) and \\( Q \\), and two integer sequences of length \\( Q \\): \\( A = (A_1, A_2, \\ldots, A_Q) \\) and \\( B = (B_1, B_2, \\ldots, B_Q) \\). For each \\( k = 1, 2, \\ldots, Q \\), solve the following problem:  \n\nThere is an undirected graph with \\( N \\) vertices numbered from \\( 0 \\) to \\( N-1 \\) and \\( N \\) edges. The \\( i \\)-th edge \\( (0 \\leq i < N) \\) connects vertices \\( i \\) and \\( (A_k \\times i + B_k) \\mod N \\) bidirectionally. Find the number of connected components in this undirected graph.  \n\nConstraints:  \n- \\( 1 \\leq N \\leq 10^6 \\)  \n- \\( 1 \\leq Q \\leq 10^5 \\)  \n- \\( 0 \\leq A_k < N \\)  \n- \\( 0 \\leq B_k < N \\)  \n- All input values are integers.  \n\nInput:  \nThe input is given from Standard Input in the following format:  \n```\nN Q  \nA_1 B_1  \nA_2 B_2  \n\\vdots  \nA_Q B_Q  \n```  \n\nOutput:  \nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer for \\( k = i \\).  \n\nSample Input 1:  \n```\n6 3  \n2 1  \n0 1  \n1 0  \n```  \n\nSample Output 1:  \n```\n2  \n1  \n6  \n```  \n\nExplanation for \\( k = 1 \\):  \nThe graph has the following two connected components:  \n- A connected component with vertices \\( 0, 1, 3, 4 \\).  \n- A connected component with vertices \\( 2, 5 \\).  \n\nThus, the answer for \\( k = 1 \\) is \\( 2 \\).  \n\nSample Input 2:  \n```\n11 3  \n9 1  \n5 3  \n8 0  \n```  \n\nSample Output 2:  \n```\n3  \n3  \n2  \n```  \n\nExplanation for \\( k = 1 \\):  \nThe graph has the following three connected components:  \n- A connected component with vertices \\( 0, 1, 3, 6, 10 \\).  \n- A connected component with vertices \\( 2, 5, 7, 8, 9 \\).  \n- A connected component with vertex \\( 4 \\).  \n\nThus, the answer for \\( k = 1 \\) is \\( 3 \\).  \n\nSample Input 3:  \n```\n182 3  \n61 2  \n77 88  \n180 55  \n```  \n\nSample Output 3:  \n```\n36  \n14  \n9  \n```\n\nSolution:\n\n[BEGIN TEXT]\nBelow is a cleaner version of the editorial:\n\n---\n\n**Editorial - AtCoder Regular Contest 182**\n\n**Official Problem F - Graph of Mod of Linear**\n\nWe will analyze the problem in terms of directed graphs. The number of connected components in the undirected graph corresponds to the number of cycles in the directed graph, so we will focus on the latter.\n\n1. **When \\(\\gcd(N, A) \\neq 1\\):**\n\n   Let \\(f^N(x)\\) represent the vertex reached after \\(N\\) moves starting from vertex \\(x\\). We have \\(\\displaystyle f^N(x)\\equiv A^N x + B\\frac{A^N-1}{A-1}\\ \\text{mod}\\ N\\). Here, let \\(d = \\gcd(N, A^N)\\). Since \\(\\displaystyle f^N(x+1)-f^N(x)\\equiv A^N\\equiv 0\\ \\text{mod}\\ d\\), the vertices forming a cycle all match \\(f^N(0)\\) modulo \\(d\\). Considering only these vertices, the problem can be reduced to the case where \\(\\displaystyle(N, A, B) \\leftarrow \\left(\\frac{N}{d}, A \\mod \\frac{N}{d}, \\frac{A^N}{d}B \\mod \\frac{N}{d}\\right)\\). By performing this substitution, the problem can be reduced to the case where \\(\\gcd(N, A) = 1\\).\n\n2. **When \\(\\gcd(N, A) = 1\\):**\n\n   If \\(\\gcd(N, A) = 1\\), all vertices form some cycle. Therefore, the answer is the sum of the reciprocals of the lengths of the cycles formed by each vertex. If vertex \\(x\\) returns to its original position after \\(K\\) moves, then \\(\\displaystyle A^K x + B\\frac{A^K-1}{A-1}\\equiv x\\ \\text{mod}\\ N\\), which implies \\(\\displaystyle A^K\\equiv 1\\ \\text{mod}\\ \\frac{N(A-1)}{\\gcd(N(A-1), (A-1)x+B)}\\). Letting \\(G = \\gcd(A-1, B)\\), \\(A'=\\frac{A-1}{G}\\), \\(B'=\\frac{B}{G}\\), and \\(N'=\\frac{N}{\\gcd(A'^N, N)}\\), we have \\(\\displaystyle \\gcd(N(A-1), (A-1)x+B)=G\\gcd(N', A'x+B')\\). Since \\(A'\\) and \\(N'\\) are coprime, for each \\(0\\le y<N'\\), there exist exactly \\(\\displaystyle \\frac{N}{N'}\\) values \\(0\\le x<N\\) such that \\(y\\equiv A'x+B'\\ \\text{mod}\\ N'\\). Therefore, if we let \\(C_y\\) be the smallest positive integer \\(K\\) such that \\(\\displaystyle A^K\\equiv 1\\ \\text{mod}\\ \\frac{NA'}{\\gcd(y, N')}\\) for each \\(0\\le y<N'\\), the desired answer is \\(\\displaystyle \\frac{N}{N'}\\sum_{y=0}^{N'-1}\\frac{1}{C_y}\\). Values of \\(y\\) with the same \\(\\gcd(y, N')\\) have the same \\(C_y\\). Therefore, for each divisor \\(n\\) of \\(N'\\), we need to find the answer for \\(n = \\gcd(y, N')\\), and sum them up. The number of values \\(0\\le y<N'\\) such that \\(n = \\gcd(y, N')\\) is \\(\\displaystyle \\phi\\left(\\frac{N'}{n}\\right)\\), so the answer can be expressed as \\(\\displaystyle \\frac{N}{N'}\\sum_{n| N'}\\frac{1}{C_n}\\phi\\left(\\frac{N'}{n}\\right)\\). Here, \\(\\phi\\) is the Euler\u2019s totient function.\n\nTo compute \\(C_n\\) for each \\(n\\), we can use the following facts:\n\n- By Euler\u2019s theorem, the candidates for \\(C_1\\) are divisors of \\(\\phi(NA')\\).\n- Let \\(n_1\\) and \\(n_2\\) be divisors of \\(N'\\). If \\(n_1\\) divides \\(n_2\\), then \\(C_{n_2}\\) divides \\(C_{n_1}\\).\n\nThis approach can be implemented using a DFS-like method. The value of \\(\\phi(NA')\\) and its prime factorization can be computed quickly by precomputing the prime factorizations of all positive integers up to \\(N\\).\n\n---\n\nThis concise editorial provides a clear breakdown of the problem-solving approach without unnecessary content.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} (A_i \\oplus A_{i+1} \\oplus \\ldots \\oplus A_j) \\]\n\n**Notes on Bitwise XOR:**\n\nThe bitwise XOR of non-negative integers \\( A \\) and \\( B \\), denoted as \\( A \\oplus B \\), is defined as follows:\n\n- In the binary representation of \\( A \\oplus B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) position is 1 if and only if exactly one of the digits at the \\( 2^k \\) position in the binary representations of \\( A \\) and \\( B \\) is 1; otherwise, it is 0.\n\nFor example, \\( 3 \\oplus 5 = 6 \\) (in binary: \\( 011 \\oplus 101 = 110 \\)).\n\nIn general, the bitwise XOR of \\( k \\) integers \\( p_1, \\dots, p_k \\) is defined as \\( (\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k) \\). It can be proved that this is independent of the order of \\( p_1, \\dots, p_k \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n1 3 2\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n**Explanation:**\n\n\\( A_1 \\oplus A_2 = 2 \\), \\( A_1 \\oplus A_2 \\oplus A_3 = 0 \\), and \\( A_2 \\oplus A_3 = 1 \\), so the answer is \\( 2 + 0 + 1 = 3 \\).\n\n**Sample Input 2:**\n\n```\n7\n2 5 6 5 2 1 7\n```\n\n**Sample Output 2:**\n\n```\n83\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\nE - Xor Sigma Problem Editorial by en_translator\n\nIt is often effective to consider bitwise independently for a problem regarding XOR (exclusive logical sum). For each \\(j=0,1,\\ldots,27\\), define a sequence \\(B\\) of length \\(N\\) such that \\(B_i=1\\) if the \\(j\\)-th bit of \\(A_i\\) is \\(1\\) and \\(B_i=0\\) if it is \\(0\\). Solve the problem against \\(B\\) for each \\(j\\), and the total sum of the answers multiplied by \\(2^j\\) is the solution to the original problem. This simplifies the problem as \\(B\\) takes only zero or one, as opposed to \\(A\\) taking variable values.\n\nNext, the expression \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j)\\) requires the total XOR of a segment. This can be computed fast using cumulative XORs, similar to cumulative sums when computing the total sum on a segment. Define the array of cumulative XORs \\(C\\) by \\(C_0=0\\) and \\(C_i =B_1\\oplus \\ldots \\oplus B_i\\). Then \\(B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j = C_{i-1} \\oplus C_j\\).\n\nThe expression can be rewritten as follows:\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (C_{i-1} \\oplus C_j)  = \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j). \\]\n\nAdjusting the index \\(j\\) to start from \\(i+1\\):\n\\[ \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=0}^{N-1} (C_i\\oplus C_{i+1}) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=1}^{N} B_i. \\]\n\nNow \\(\\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j)\\) is the number of pairs of elements in \\(C\\) with different values, which equals the product of the number of occurrences of \\(0\\) and \\(1\\) in \\(C\\). Thus, the sought value can be evaluated with the total sum of \\(B\\) and the number of occurrences of \\(0\\) and \\(1\\) in the cumulative XORs. The problem is solved in \\(\\mathrm{O}(N \\log {\\mathrm{MAX_A}})\\) time.\n```\n \n\n", "problem_ids": ["arc182_f", "abc355_g", "abc365_e"]}, "abc324_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), and a sequence of non-negative integers: \\( A = (A_1,A_2,\\ldots,A_N) \\).\n\nFor a non-empty non-negative integer sequence \\( B = (B_1,B_2,\\ldots,B_{|B|}) \\), we define its **score** as follows:\n- If the length of \\( B \\) is a multiple of \\( M \\): \\( (B_1 \\oplus B_2 \\oplus \\dots \\oplus B_{|B|})^K \\)\n- Otherwise: \\( 0 \\)\n\nHere, \\( \\oplus \\) represents the bitwise XOR.\n\nFind the sum, modulo \\( 998244353 \\), of the scores of the \\( 2^N-1 \\) non-empty subsequences of \\( A \\).\n\n### Constraints\n- \\( 1 \\leq N, K \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 0 \\leq A_i < 2^{20} \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n3 2 2\n1 2 3\n```\n\n### Sample Output 1\n```\n14\n```\n\nHere are the scores of the \\( 2^3-1=7 \\) non-empty subsequences of \\( A \\).\n- \\( (1) \\): \\( 0 \\)\n- \\( (2) \\): \\( 0 \\)\n- \\( (3) \\): \\( 0 \\)\n- \\( (1,2) \\): \\( (1 \\oplus 2)^2 = 9 \\)\n- \\( (1,3) \\): \\( (1 \\oplus 3)^2 = 4 \\)\n- \\( (2,3) \\): \\( (2 \\oplus 3)^2 = 1 \\)\n- \\( (1,2,3) \\): \\( 0 \\)\n\nTherefore, the sought sum is \\( 0 + 0 + 0 + 9 + 4 + 1 + 0 = 14 \\).\n\n### Sample Input 2\n```\n10 5 3\n100 100 100 100 100 100 100 100 100 100\n```\n\n### Sample Output 2\n```\n252000000\n```\n\n### Sample Input 3\n```\n16 4 100\n7053 3876 3178 8422 7802 5998 2334 6757 6889 6637 7365 9495 7848 9026 7312 6558\n```\n\n### Sample Output 3\n```\n432440016\n```\n\n\nSolution:\n\nThe problem requires knowledge of XOR convolution and Hadamard transform. Define \\(C_i\\) as the number of subsequences of \\(A\\) with length as a multiple of \\(M\\) and total XOR equals \\(i\\). We need to find \\(C_0, C_1, \\ldots, C_{2^L-1}\\) such that \\(\\sum_{i=0}^{2^L-1} C_i \\cdot i^K\\) is calculated, where \\(L=20\\).\n\nDefine sequences \\(v_i\\) such that each sequence term is a polynomial, with the 0-th term being 1, the \\(A_i\\)-th term as \\(x\\), and others 0. If \\(A_i=0\\), the 0-th term is \\(1+x\\). For two sequences \\(a, b\\), define the XOR convolution as \\((a \\ast b)_k = \\sum_{i \\oplus j = k} a_i \\times b_j\\). \n\nCompute the XOR convolution \\(V = v_1 \\ast v_2 \\ast \\cdots \\ast v_N\\). The coefficient of \\(x^j\\) of the \\(i\\)-th term (\\([x^j]V_i\\)) equals the number of length-\\(j\\) subsequences of \\(A\\) with a total XOR of \\(i\\), resulting in \\(C_i = [x^0]V_i + [x^M]V_i + \\cdots = [x^0]V_i \\, (\\text{mod } 1-x^M)\\).\n\nUtilize Hadamard conversion \\(H\\), where \\(H(a \\ast b)_i = H(a)_i \\times H(b)_i\\). Therefore, \\(H(V)_i = H(v_1)_i \\times \\cdots \\times H(v_N)_i\\). Compute \\(H(V)\\) using Hadamard conversion on sequences \\(v_1, v_2, \\ldots\\).\n\nGiven sequences that have 1 at the 0-th term and \\(x\\) at the \\(A_i\\)-th term, \\(H(v_i)\\) becomes \\((1+x)\\) or \\((1-x)\\). Thus, \\(H(V)_i\\) can be represented as \\((1+x)^{B_i}(1-x)^{N-B_i}\\). Calculate \\(B_i\\) efficiently using a combination of Hadamard conversion and population count divide-and-conquer strategy, allowing \\(O(L2^L)\\) calculation time. Alternatively, use \\(B_i = \\frac{H(\\text{cnt})_i + N}{2}\\).\n\nFind \\([x^0](1+x)^{B_i}(1-x)^{N-B_i} \\, (\\text{mod } 1-x^M)\\) in \\(O(NM)\\) using precalculated sequences for \\((1+x)^n\\) and \\((1-x)^n \\, (\\text{mod } 1-x^M)\\). Thus, the overall problem can be solved in \\(O(NM + 2^L (L + \\log K))\\) time.\n\nHere's the implementation:\n\n```python\nmod = 998244353\n\ndef hadamard(a, m):\n    for k in range(m):\n        i = 1 << k\n        for j in range(1 << m):\n            if not i & j:\n                a[j], a[i | j] = (a[j] + a[i | j]), (a[j] - a[i | j])\n\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nL = 20\ncnt = [0] * (1 << L)\nfor i in range(N):\n    cnt[A[i]] += 1\n\nF = [[0] * M for i in range(N + 1)]\nG = [[0] * M for i in range(N + 1)]\n\nF[0][0], G[0][0] = 1, 1\n\nfor i in range(N):\n    for j in range(M):\n        F[i + 1][j] = (F[i][j] + F[i][j - 1]) % mod\n        G[i + 1][j] = (G[i][j] - G[i][j - 1]) % mod\n\nres = [0] * (N + 1)\nfor i in range(N + 1):\n    for j in range(M):\n        res[i] += F[i][j] * G[N - i][-j]\n        res[i] %= mod\n\nhadamard(cnt, L)\nB = [(cnt[i] + N) // 2 for i in range(1 << L)]\nC = [res[B[i]] for i in range(1 << L)]\nhadamard(C, L)\n\ninv = pow(1 << L, mod - 2, mod)\nans = 0\nfor i in range(1 << L):\n    C[i] = C[i] % mod * inv % mod\n    ans += C[i] * pow(i, K, mod)\n    ans %= mod\n\nprint(ans)\n```\n\nCalculate \\(B\\) using divide-and-conquer:\n\n```python\ndef calc(off, k):\n    if k == 0:\n        return ([cnt[off]], cnt[off])\n    H0, c0 = calc(off, k - 1)\n    H1, c1 = calc(off | (1 << (k - 1)), k - 1)\n    H = [0] * (1 << k)\n    for i in range(1 << (k - 1)):\n        H[i] = H0[i] + H1[i]\n        H[i | (1 << (k - 1))] = H0[i] + c1 - H1[i]\n    return (H, c0 + c1)\n\nB = calc(0, L)[0]\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally.\n\nInitially, all vertices are painted white.\n\nTo efficiently visit all vertices of this tree, Alice has invented a magical gate. She uses one piece and one gate to travel according to the following procedure.\n\nFirst, she chooses a vertex and places both the piece and the gate on that vertex. Then, she repeatedly performs the following operations until all vertices are painted black.\n\nChoose one of the following actions:\n\n1. Paint the vertex where the piece is placed black.\n2. Choose a vertex adjacent to the vertex where the piece is placed and move the piece to that vertex. The cost of this action is 1.\n3. Move the piece to the vertex where the gate is placed.\n4. Move the gate to the vertex where the piece is placed.\n\nNote that only the second action incurs a cost.\n\nIt can be proved that it is possible to paint all vertices black in a finite number of operations. Find the minimum total cost required.\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- The given graph is a tree.\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nu_1 v_1\n\\vdots\nu_{N-1} v_{N-1}\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n4\n1 2\n1 3\n1 4\n```\n\n**Sample Output 1:**\n```\n3\n```\n\nHere is an example of Alice's procedure. Let \\((u, v)\\) denote the state where the piece is at vertex \\( u \\) and the gate is at vertex \\( v \\).\n\n- Place the piece and the gate at vertex 4.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 1.\n  - Vertex 4 is painted black.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 2 and move the piece to vertex 1.\n  - This costs 1.\n  - The state is now \\((1, 4)\\).\n\n- Perform action 1.\n  - Vertex 1 is painted black.\n\n- Perform action 4.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 2.\n  - This costs 1.\n  - The state is now \\((2, 1)\\).\n\n- Perform action 1.\n  - Vertex 2 is painted black.\n\n- Perform action 3.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 3.\n  - This costs 1.\n  - The state is now \\((3, 1)\\).\n\n- Perform action 1.\n  - Vertex 3 is painted black.\n  - All vertices are now painted black, so the procedure ends.\n\nThe total cost of performing action 2 is 3, and there is no procedure with a smaller cost.\n\n**Sample Input 2:**\n```\n10\n1 7\n7 10\n10 8\n8 3\n8 4\n10 9\n9 6\n9 5\n7 2\n```\n\n**Sample Output 2:**\n```\n10\n```\n\nSolution:\n\n```\nHere is the cleaned version:\n\nEditorial - AtCoder Regular Contest 179\n\nD - Portable Gate Editorial by evima\n\nWhen moving the gate, it can be considered to move simultaneously with the piece. We will perform operation 1 as needed and consider the following operations:\n\nOperation A: When the piece and the gate are on the same vertex, move both the piece and the gate to an adjacent vertex. Operation B: Move the piece to an adjacent vertex. Operation C: Move the piece to the vertex where the gate is located.\n\nOperations A and B each incur a cost of 1. Once operation B is performed, the gate remains in its position until operation C is performed. It's inefficient to move the piece to the gate using operation B, so we will not consider this.\n\nLet \\(v\\) be the initial position of the piece and gate. By performing operation C at the end, the process ends when the piece and the gate are on the same vertex. Label the vertices and edges the gate moves to with A, and the rest with B. The vertices and edges labeled A form a connected subgraph, or subtree A. Vertex \\(v\\) is included in subtree A. Edges labeled B with one endpoint as A are boundary edges.\n\nVertices and edges labeled B not connected to boundary edges form connected components. Each component is a tree connected to a vertex in subtree A by a boundary edge \\(e_i\\). Let them form subtree \\(B_i\\), connected to vertex \\(l_i\\) in A.\n\nKey points:\n\n1. In optimal operations, assume edges labeled A are not traversed by operation B. By rearranging operations, the cost does not increase:\n\n   - The piece and gate start from \\(v\\), visit all vertices in A using operation A, and return to \\(v\\). This is the journey in A.\n   - If \\(l_i\\) is visited during A's journey, it's interrupted. The piece starts from \\(l_i\\), visits all vertices in \\(B_i\\) using operation B, and returns to \\(l_i\\). This is the journey in \\(B_i\\). The gate stays at \\(l_i\\).\n\n2. Assume moving along boundary edge \\(e_i\\) occurs only once in B's journey. If done more than once, moving with the gate using operation A during the first move and returning does not increase the cost. In \\(B_i\\)'s journey, operation C is done once at the end.\n\n3. In the journeys of A and \\(B_i\\), the farthest vertex is visited last. If the distance from start to the farthest vertex is \\(d\\) and the number of edges is \\(m\\), the cost is \\(2m - d\\).\n\nThe total number of edges in subtrees is \\(N-1\\). Minimize cost by maximizing \\(d\\)'s total sum. Calculate for fixed \\(v\\) using tree DP. Maintain:\n\n- Maximum distance to vertex where \\(B_i\\)'s journey ends, assuming \\(u = l_i\\).\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex in \\(u\\)'s subtree.\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex not in \\(u\\)'s subtree.\n\nExtend to rerooting DP to examine all possible starting vertices. Time complexity \\(\\mathrm{O}(N)\\).\n```\n\n \n\n", "problem_ids": ["abc367_g", "abc368_c", "arc179_d"]}, "abc324_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi is growing a plant. The height of the plant at the time of germination is \\(0\\,\\mathrm{cm}\\). Each night from the day of germination, considered as day \\(0\\), the height of the plant increases by \\(2^i\\,\\mathrm{cm}\\) on day \\(i\\) (\\(0 \\le i\\)).\n\nTakahashi has a height of \\(H\\,\\mathrm{cm}\\).\n\nEvery morning, Takahashi measures his height against the plant. Find the first day such that the plant's height is strictly greater than Takahashi's height in the morning.\n\n### Constraints\n- \\(1 \\leq H \\leq 10^{9}\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nH\n```\n\n### Output\nPrint an integer representing the first day such that the plant's height is greater than Takahashi's height in the morning.\n\n### Sample Input 1\n```\n54\n```\n\n### Sample Output 1\n```\n6\n```\n**Explanation:** The plant's height in the mornings of days \\(1, 2, 3, 4, 5, 6\\) will be \\(1\\,\\mathrm{cm}, 3\\,\\mathrm{cm}, 7\\,\\mathrm{cm}, 15\\,\\mathrm{cm}, 31\\,\\mathrm{cm}, 63\\,\\mathrm{cm}\\), respectively. The plant becomes taller than Takahashi in the morning of day \\(6\\), so print \\(6\\).\n\n### Sample Input 2\n```\n7\n```\n\n### Sample Output 2\n```\n4\n```\n**Explanation:** The plant's height will be \\(7\\,\\mathrm{cm}\\) in the morning of day \\(3\\) and \\(15\\,\\mathrm{cm}\\) in the morning of day \\(4\\). The plant becomes taller than Takahashi in the morning of day \\(4\\), so print \\(4\\). Note that, in the morning of day \\(3\\), the plant is as tall as Takahashi, but not taller.\n\n### Sample Input 3\n```\n262144\n```\n\n### Sample Output 3\n```\n19\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\n## A - Exponential Plant Editorial\n\nUse a while statement to repeatedly add the delta to the height of the plant until it exceeds Takahashi\u2019s height. This simulation will allow you to solve this problem. Also, the height at day \\(30\\) is \\(1073741823\\, \\mathrm{cm}(> 10^{9}\\, \\mathrm{cm})\\), so just using a while statement to find the daily height is fast enough.\n\n**Sample code (Python):**\n```python\nh=int(input())\nnow=0\nans=0\nwhile now<=h:\n    now+=1<<ans\n    ans+=1\n\nprint(ans)\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} (A_i \\oplus A_{i+1} \\oplus \\ldots \\oplus A_j) \\]\n\n**Notes on Bitwise XOR:**\n\nThe bitwise XOR of non-negative integers \\( A \\) and \\( B \\), denoted as \\( A \\oplus B \\), is defined as follows:\n\n- In the binary representation of \\( A \\oplus B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) position is 1 if and only if exactly one of the digits at the \\( 2^k \\) position in the binary representations of \\( A \\) and \\( B \\) is 1; otherwise, it is 0.\n\nFor example, \\( 3 \\oplus 5 = 6 \\) (in binary: \\( 011 \\oplus 101 = 110 \\)).\n\nIn general, the bitwise XOR of \\( k \\) integers \\( p_1, \\dots, p_k \\) is defined as \\( (\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k) \\). It can be proved that this is independent of the order of \\( p_1, \\dots, p_k \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n1 3 2\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n**Explanation:**\n\n\\( A_1 \\oplus A_2 = 2 \\), \\( A_1 \\oplus A_2 \\oplus A_3 = 0 \\), and \\( A_2 \\oplus A_3 = 1 \\), so the answer is \\( 2 + 0 + 1 = 3 \\).\n\n**Sample Input 2:**\n\n```\n7\n2 5 6 5 2 1 7\n```\n\n**Sample Output 2:**\n\n```\n83\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\nE - Xor Sigma Problem Editorial by en_translator\n\nIt is often effective to consider bitwise independently for a problem regarding XOR (exclusive logical sum). For each \\(j=0,1,\\ldots,27\\), define a sequence \\(B\\) of length \\(N\\) such that \\(B_i=1\\) if the \\(j\\)-th bit of \\(A_i\\) is \\(1\\) and \\(B_i=0\\) if it is \\(0\\). Solve the problem against \\(B\\) for each \\(j\\), and the total sum of the answers multiplied by \\(2^j\\) is the solution to the original problem. This simplifies the problem as \\(B\\) takes only zero or one, as opposed to \\(A\\) taking variable values.\n\nNext, the expression \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j)\\) requires the total XOR of a segment. This can be computed fast using cumulative XORs, similar to cumulative sums when computing the total sum on a segment. Define the array of cumulative XORs \\(C\\) by \\(C_0=0\\) and \\(C_i =B_1\\oplus \\ldots \\oplus B_i\\). Then \\(B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j = C_{i-1} \\oplus C_j\\).\n\nThe expression can be rewritten as follows:\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (C_{i-1} \\oplus C_j)  = \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j). \\]\n\nAdjusting the index \\(j\\) to start from \\(i+1\\):\n\\[ \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=0}^{N-1} (C_i\\oplus C_{i+1}) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=1}^{N} B_i. \\]\n\nNow \\(\\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j)\\) is the number of pairs of elements in \\(C\\) with different values, which equals the product of the number of occurrences of \\(0\\) and \\(1\\) in \\(C\\). Thus, the sought value can be evaluated with the total sum of \\(B\\) and the number of occurrences of \\(0\\) and \\(1\\) in the cumulative XORs. The problem is solved in \\(\\mathrm{O}(N \\log {\\mathrm{MAX_A}})\\) time.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\) and a prime \\( P \\).\n\nCount the number, modulo \\( P \\), of undirected connected graphs \\( G \\) of \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) that satisfy the following conditions:\n\n1. There are no self-loops in \\( G \\). Note that multiple edges are allowed.\n2. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) remains connected. In other words, \\( G \\) is edge-biconnected.\n3. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) is no longer edge-biconnected.\n\nTwo graphs are considered different if and only if there exists a pair of distinct vertices \\( (u,v) \\) such that the numbers of edges connecting \\( u \\) and \\( v \\) in the two graphs are different.\n\n**Constraints**\n\n- \\( 2 \\le N \\le 50 \\)\n- \\( 10^9 < P < 1.01 \\times 10^9 \\)\n- \\( P \\) is prime.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**  \n```\n2 1005976817\n```\n\n**Sample Output 1**  \n```\n1\n```\n\n**Sample Input 2**  \n```\n5 1000837403\n```\n\n**Sample Output 2**  \n```\n372\n```\n\n**Sample Input 3**  \n```\n10 1001160547\n```\n\n**Sample Output 3**  \n```\n789846604\n```\n\n**Sample Input 4**  \n```\n20 1006779551\n```\n\n**Sample Output 4**  \n```\n888612770\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Grand Contest 067 - E: Biconnected Graph Editorial by Kubic\n\nIf an edge is deleted, the remaining graph will form a chain after shrinking biconnected components; it will become a cycle if the edge is added back. Solve the problem for each biconnected component and multiply the answers. In the subproblem, there's an additional edge connecting two vertices, allowing them to reach each other through the cycle. Repeat this method by taking an edge connected to vertex \\(1\\), leading to subproblems formatted as:\n\nCount good graphs of \\(n\\) vertices with the first \\(k\\) vertices able to reach each other externally.\n\nConsider the distribution of the first \\(k\\) vertices:\n\n\\(\\forall 1\\le u,v\\le k\\), \\(C(u),C(v)\\) are not adjacent in the cycle, where \\(C(u)\\) is the biconnected component containing \\(u\\).\n\nDP through the cycle without constraining the edge choice so every good graph is counted \\(\\deg(1)\\) times. Store \\(\\deg(1)\\) in the DP state and divide the final answer by it.\n\nTime complexity: \\(O(n^5)\\). Some \\(O(n^6)\\) solutions with small constants may pass.\n        [END TEXT]\n \n\n", "problem_ids": ["abc354_a", "abc365_e", "agc067_e"]}, "abc324_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nSnuke is planning to build a maze as a new attraction in AtCoder Land. The maze is represented as a grid with \\( N \\) rows and \\( M \\) columns, with the top edge of the top-right cell being the entrance and the bottom edge of the bottom-right cell being the exit. He will create the maze by appropriately placing walls between adjacent cells.\n\nHe loves simple mazes, so he wants the path from the entrance to the exit to pass through exactly \\( K \\) cells without any branches. Determine if it is possible to create such a maze, and if possible, construct one.\n\nFor example, in the following figure, \\( N = 3 \\) and \\( M = 3 \\), and walls are placed at the solid lines (walls are always placed around the outer perimeter except for the entrance and exit). In this case, the path from the entrance to the exit passes through exactly 7 cells without any branches.\n\n### Formal Statement\n\nThere is a grid with \\( N \\) rows and \\( M \\) columns. Let \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. For each pair of side-adjacent cells, you can decide whether to place a wall between them. Determine whether it is possible to place walls to satisfy the following condition, and if it is possible, construct one such placement.\n\n**Condition**: There exists a simple path with \\( K \\) vertices that connects the two vertices \\((1, M)\\) and \\((N, M)\\), and the connected component containing the vertices \\((1, M)\\) and \\((N, M)\\) consists only of this path.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 100 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 1 \\leq K \\leq NM \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\n```\n\n### Output\n\nIf there is no placement of walls that satisfies the condition, print `No`. Otherwise, print one such placement in the following format. If multiple valid placements exist, any of them can be printed.\n\n**See also the sample outputs below to better understand the complicated output format.**\n\n```\nYes\n+++++ \\dots +++S+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n\\vdots\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+++++ \\dots +++G+\n```\n\nHere, `S`, `G`, `+`, and `o` represent the entrance, exit, a wall, and a cell, respectively, and `?` between cells represents a position where a wall can be placed. Replace `?` between two horizontally adjacent cells with `|` if a wall is placed, and `.` otherwise. Replace `?` between two vertically adjacent cells with `-` if a wall is placed, and `.` otherwise.\n\n**Formal Instruction:**\n\n- The output should consist of \\( 2N+2 \\) lines.\n  - Line 1 should contain the string `Yes`.\n  - Lines 2 to \\( 2N+2 \\) should contain strings of length \\( 2M+1 \\) as described below:\n    - Line 2 should be a concatenation of `+` repeated \\( 2M-1 \\) times, `S`, and `+`, in this order.\n    - Line \\( 1+2i \\) (\\( 1 \\leq i \\leq N \\)) should be a concatenation of `+`, `o`, \\( c_{i,1} \\), `o`, \\( c_{i,2} \\), \\(\\dots\\), \\( c_{i,M-1} \\), `o`, `+`, in this order. Here, \\( c_{i,j} \\) is `|` if a wall is placed between cells \\((i,j)\\) and \\((i,j+1)\\), and `.` otherwise.\n    - Line \\( 2+2i \\) (\\( 1 \\leq i \\leq N-1 \\)) should be a concatenation of `+`, \\( r_{i,1} \\), `+`, \\( r_{i,2} \\), `+`, \\(\\dots\\), `+`, \\( r_{i,M} \\), `+`, in this order. Here, \\( r_{i,j} \\) is `-` if a wall is placed between cells \\((i,j)\\) and \\((i+1,j)\\), and `.` otherwise.\n    - Line \\( 2N+2 \\) should be a concatenation of `+` repeated \\( 2M-1 \\) times, `G`, and `+`, in this order.\n\n### Sample Input 1\n\n```\n3 3 7\n```\n\n### Sample Output 1\n\n```\nYes\n+++++S+\n+o.o.o+\n+.+-+-+\n+o.o.o+\n+-+-+.+\n+o.o|o+\n+++++G+\n```\n\nThis is the same placement of walls as in the figure in the problem statement.\n\n### Sample Input 2\n\n```\n3 3 2\n```\n\n### Sample Output 2\n\n```\nNo\n```\n\n### Sample Input 3\n\n```\n4 1 4\n```\n\n### Sample Output 3\n\n```\nYes\n+S+\n+o+\n+.+\n+o+\n+.+\n+o+\n+.+\n+o+\n+G+\n```\n\nSolution:\n\n```python\n        Editorial - AtCoder Beginner Contest 358\n\nF - Easiest Maze Editorial by en_translator\n\nFor what kind of \\(K\\) does the solution exist? Obviously, \\(K\\geq N\\) is required, considering the length of the shortest path between squares \\((1,M)\\) and \\((N,M)\\). Let's draw the grid in a checkered pattern:\n\nAny path visits red square \\(\\rightarrow\\) blue square \\(\\rightarrow\\) red square \\(\\rightarrow\\dots\\). The color parity of squares \\((1,M)\\) and \\((N,M)\\) depends on \\(N\\). Thus, \\(N\\) and \\(K\\) must have the same parity. If \\(N\\) is even, the path ends with an even number of vertices. If \\(K\\geq N\\) and parities are the same, a solution can always be constructed. Starting from the path of the shortest length \\(N\\), increase the length by \\(2\\) incrementally, as \\(N, N+2, N+4, \\dots\\).\n\nImplement carefully with some casework. Use casework and construction separately. The sample code outlines how to compute the sequence of squares, build walls, and remove those between adjacent squares.\n\nSample code (Python 3):\n```python\ndef main():\n    n, m, k = map(int, input().split())\n    if k < n or k % 2 != n % 2:\n        print(\"No\")\n        return\n    print(\"Yes\")\n    path = []\n    k -= n\n    i = 0\n    while i < n - 1:\n        if i != n - 3:\n            w = 1 + min(m - 1, k // 2)\n            k -= (w - 1) * 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n        elif k <= (m - 1) * 2:\n            w = 1 + k // 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n            path.append((i + 2, m - 1))\n        else:\n            for j in range(m):\n                path.append((i, m - 1 - j))\n            k -= (m - 1) * 2\n            j = 0\n            while j < m:\n                if k:\n                    path.append((i + 1, j))\n                    path.append((i + 2, j))\n                    path.append((i + 2, j + 1))\n                    path.append((i + 1, j + 1))\n                    j += 2\n                    k -= 2\n                else:\n                    path.append((i + 1, j))\n                    j += 1\n            path.append((i + 2, m - 1))\n        i += 2\n    \n    c = [['|' for _ in range(m - 1)] for _ in range(n)]\n    r = [['-' for _ in range(m)] for _ in range(n - 1)]\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i + 1]\n        if x1 == x2:\n            c[x1][min(y1, y2)] = '.'\n        else:\n            r[min(x1, x2)][y1] = '.'\n    \n    print('+' + 'S'.join([''] + ['-' * (2 * m - 1), '+']))\n    for i in range(n):\n        print('+', end='')\n        for j in range(m - 1):\n            print('o' + c[i][j], end='')\n        print(\"o+\")\n        if i < n - 1:\n            for j in range(m):\n                print('+' + r[i][j], end='')\n            print('+')\n    print('+' + 'G'.join([''] + ['-' * (2 * m - 1), '+']))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Score:** 475 points\n\n**Problem Statement**\n\nIn the nation of Atcoder, there are \\( N \\) cities numbered from 1 to \\( N \\), and \\( M \\) trains numbered from 1 to \\( M \\). Train \\( i \\) departs from city \\( A_i \\) at time \\( S_i \\) and arrives at city \\( B_i \\) at time \\( T_i \\).\n\nGiven a positive integer \\( X_1 \\), find a way to determine non-negative integers \\( X_2, \\ldots, X_M \\) that satisfy the following condition while minimizing the value of \\( X_2 + \\ldots + X_M \\).\n\n**Condition:**\n\nFor all pairs \\( (i, j) \\) satisfying \\( 1 \\leq i, j \\leq M \\), if \\( B_i = A_j \\) and \\( T_i \\leq S_j \\), then \\( T_i + X_i \\leq S_j + X_j \\).\n\nIn other words, for any pair of trains that were originally possible to transfer between, it must still be possible to transfer even after delaying the departure and arrival times of each train \\( i \\) by \\( X_i \\).\n\nIt can be proved that there is a unique way to set \\( X_2, \\ldots, X_M \\) with the minimum possible value of \\( X_2 + \\ldots + X_M \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( A_i \\neq B_i \\)\n- \\( 0 \\leq S_i < T_i \\leq 10^9 \\)\n- \\( 1 \\leq X_1 \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M X_1\nA_1 B_1 S_1 T_1\n\u22ee\nA_M B_M S_M T_M\n```\n\n**Output**\n\nPrint \\( X_2, \\ldots, X_M \\) that satisfy the condition with the minimum possible sum, in that order, separated by spaces.\n\n**Sample Input 1**\n\n```\n3 6 15\n1 2 10 20\n1 2 20 30\n2 3 25 40\n2 3 35 50\n3 1 15 30\n3 1 45 60\n```\n\n**Sample Output 1**\n\n```\n0 10 0 0 5\n```\n\n**Explanation**\n\nThe arrival of train 1 from city 1 to 2 is delayed by 15 and becomes time 35. To allow transfer from train 1 to 3 in city 2, the departure of train 3 is delayed by 10, making it depart at time 35 and arrive at time 50. Further, to allow transfer from train 3 to 6 in city 3, the departure of train 6 is delayed by 5, making it depart at time 50. Other trains can operate without delay while still allowing transfers between originally transferable trains, so \\( (X_2, X_3, X_4, X_5, X_6) = (0, 10, 0, 0, 5) \\) satisfies the condition. Moreover, there is no solution with a smaller sum that satisfies the condition, so this is the answer.\n\n**Sample Input 2**\n\n```\n10 9 100\n1 10 0 1\n10 2 1 100\n10 3 1 100\n10 4 1 100\n10 5 1 100\n10 6 1 100\n10 7 1 100\n10 8 1 100\n10 9 1 100\n```\n\n**Sample Output 2**\n\n```\n100 100 100 100 100 100 100 100\n```\n\n**Sample Input 3**\n\n```\n4 4 10\n1 2 0 1\n1 2 0 10\n2 3 100 200\n2 4 100 200\n```\n\n**Sample Output 3**\n\n```\n0 0 0\n```\n\nSolution:\n\nHere's the trimmed version focusing on the solution:\n\n---\n\n**E - Train Delay Editorial**\n\nLet us call \\(S_i\\) and \\(T_i\\) the scheduled departure and arrival, respectively, and \\(S_i+X_i\\) and \\(T_i+X_i\\) the actual departure and arrival. If you let a train depart later, you cannot make another depart earlier, so assume every train departs as early as possible. Whether a train \\(i\\) can depart is affected by trains whose scheduled arrival is prior to the departure of train \\(i\\). Therefore, processing trains in order of their scheduled times is effective.\n\nSort the \\(2M\\) departure/arrival events in ascending order:\n\n- When train \\(i\\) departs, find \\(X_i\\) based on the actual arrivals to station \\(A_i\\) for trains processed so far.\n- When train \\(i\\) arrives, record the actual arrival to station \\(B_i\\) based on \\(X_i\\).\n\nThese steps can be done in \\(O(1)\\) time by managing for each station the latest actual arrival of the trains processed so far. If departure and arrival occur simultaneously, process arrivals first.\n\n```python\nN, M, X = map(int, input().split())\nA, B, S, T = zip(*[tuple(map(int, input().split())) for _ in range(M)])\n\nevent = sorted([(S[i], 1, i) for i in range(M)] + [(T[i], 0, i) for i in range(M)])\n\nans = [0] * M\nans[0] = X\n\nstation = [0] * (N + 1)\nfor t, f, i in event:\n  if f:\n    if i:\n      ans[i] = max(0, station[A[i]] - t)\n  else:\n    station[B[i]] = max(station[B[i]], t + ans[i])\n\nprint(*ans[1:])\n```\n\n---\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAt the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes \\( A \\) seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.\n\nCurrently, there is no one in line at the ticket booth, and \\( N \\) people will come to buy tickets one after another. Specifically, the \\( i \\)-th person will arrive at the ticket booth \\( T_i \\) seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately. Here, \\( T_1 < T_2 < \\dots < T_N \\).\n\nFor each \\( i\\ (1 \\leq i \\leq N) \\), determine how many seconds from now the \\( i \\)-th person will finish purchasing their ticket.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 0 \\leq T_1 < T_2 < \\dots < T_N \\leq 10^6 \\)\n- \\( 1 \\leq A \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\nT_1 T_2 \\dots T_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the number of seconds from now that the \\( i \\)-th person will finish purchasing their ticket.\n\n**Sample Input 1:**\n\n```\n3 4\n0 2 10\n```\n\n**Sample Output 1:**\n\n```\n4\n8\n14\n```\n\nThe events proceed in the following order:\n\n- At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.\n- At 8 seconds: The 2nd person finishes purchasing their ticket.\n- At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 14 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 2:**\n\n```\n3 3\n1 4 7\n```\n\n**Sample Output 2:**\n\n```\n4\n7\n10\n```\n\nThe events proceed in the following order:\n\n- At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.\n- At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 10 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 3:**\n\n```\n10 50000\n120190 165111 196897 456895 540000 552614 561627 743796 757613 991216\n```\n\n**Sample Output 3:**\n\n```\n170190\n220190\n270190\n506895\n590000\n640000\n690000\n793796\n843796\n1041216\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nB - Ticket Counter Editorial by en_translator\n\nSuppose that the \\(i\\)-th person finishes buying a ticket at time \\(x_i\\). For convenience, let \\(x_0=0\\).\nFor each \\(i\\) (1 \\(\\leq i\\leq N\\)), we determine how to represent the value \\(x_i\\) using \\(x_{i-1}\\).\n\nIf \\(x_{i-1} \\leq T_i\\): there is no queue when the \\(i\\)-th person visits the ticket booth, so they can start purchasing instantly. Thus, \\(x_i=T_i+A\\).\nIf \\(x_{i-1} > T_i\\): someone is still purchasing a ticket when the \\(i\\)-th person visits the booth, so they start the process right after the \\((i-1)\\)-th person finishes. Thus, \\(x_i=x_{i-1}+A\\).\n\nTo summarize, \\(x_i=\\max(x_{i-1},T_i)+A\\). Use this to find \\(x_i\\) for each \\(i=1,2,\\dots,N\\).\n\nSample code (Python):\n```python\nn, a = map(int, input().split())\nt = list(map(int, input().split()))\npre = 0\nfor i in range(n):\n    ans = max(pre, t[i]) + a\n    print(ans)\n    pre = ans\n```\n \n\n", "problem_ids": ["abc358_f", "abc368_e", "abc358_b"]}, "abc325_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer \\( K \\). For a set \\( S \\) that is initially empty, you need to process \\( Q \\) queries of the following two types in order:\n\n1. `1 x`: An integer \\( x \\) is given. If \\( x \\) is in \\( S \\), remove \\( x \\) from \\( S \\). Otherwise, add \\( x \\) to \\( S \\).\n2. `2 x`: An integer \\( x \\) that is in \\( S \\) is given. Consider a graph where the vertices are the numbers in \\( S \\), and there is an edge between two numbers if and only if the absolute difference between them is at most \\( K \\). Print the count of vertices in the connected component that contains \\( x \\).\n\n**Constraints:**\n\n- \\( 1 \\leq Q \\leq 200,000 \\)\n- \\( 0 \\leq K \\leq 10^{18} \\)\n- For each query, \\( 1 \\leq x \\leq 10^{18} \\).\n- For each query of the second type, the given \\( x \\) is in \\( S \\) at that point.\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nQ K\nquery_1\n...\nquery_Q\n```\nEach query is given in the following format:\n- For type 1 query: `1 x`\n- For type 2 query: `2 x`\n\n**Output:**\n\nProcess the queries and for each query of type 2, output the size of the connected component containing \\( x \\).\n\n**Sample Input 1:**\n```\n7 5\n1 3\n1 10\n2 3\n1 7\n2 3\n1 10\n2 3\n```\n\n**Sample Output 1:**\n```\n1\n3\n2\n```\n\n**Explanation:**\n\n- In the first query, \\( 3 \\) is added to \\( S \\), resulting in \\( S=\\{3\\} \\).\n- In the second query, \\( 10 \\) is added to \\( S \\), resulting in \\( S=\\{3, 10\\} \\).\n- In the third query, consider a graph with vertices \\( 3 \\) and \\( 10 \\) and no edges. The connected component containing \\( 3 \\) has a size of 1, so print 1.\n- In the fourth query, \\( 7 \\) is added to \\( S \\), resulting in \\( S=\\{3, 7, 10\\} \\).\n- In the fifth query, consider a graph with vertices \\( 3, 7, \\) and \\( 10 \\), with edges between \\( 3 \\) and \\( 7 \\), and \\( 7 \\) and \\( 10 \\). The connected component containing \\( 3 \\) has a size of 3, so print 3.\n- In the sixth query, \\( 10 \\) is removed from \\( S \\), resulting in \\( S=\\{3, 7\\} \\).\n- In the seventh query, consider a graph with vertices \\( 3 \\) and \\( 7 \\), with an edge between them. The connected component containing \\( 3 \\) has a size of 2, so print 2.\n\n**Sample Input 2:**\n```\n11 1000000000000000000\n1 1\n1 100\n1 10000\n1 1000000\n1 100000000\n1 10000000000\n1 1000000000000\n1 100000000000000\n1 10000000000000000\n1 1000000000000000000\n2 1\n```\n\n**Sample Output 2:**\n```\n10\n```\n\n**Sample Input 3:**\n```\n8 0\n1 1\n1 2\n2 1\n1 1\n1 2\n1 1\n1 2\n2 1\n```\n\n**Sample Output 3:**\n```\n1\n1\n```\n\nSolution:\n\n```python\nclass SegmentTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (2 * size)\n\n    def update(self, pos, value):\n        pos += self.size\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left, right):\n        result = 0\n        left += self.size\n        right += self.size\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef add_or_remove_edge(segments, A, x):\n    A[x] = 1 - A[x]\n    segments.update(x, A[x])\n\ndef find_connected_component_size(segments, start_x, size):\n    left = start_x\n    right = start_x\n\n    # Extend to the right\n    while right < size - 1 and segments.query(start_x, right + 1) == right + 1 - start_x:\n        right += 1\n\n    # Extend to the left\n    while left > 0 and segments.query(left - 1, start_x) == start_x - left + 1:\n        left -= 1\n\n    return right - left + 1\n\n# Assuming the segment size is known and is sufficient\nsize = 10000\nsegments = SegmentTree(size)\nA = [0] * size\n\n# Example usage\nadd_or_remove_edge(segments, A, 5)\ncomponent_size = find_connected_component_size(segments, 5, size)\nprint(\"Component size:\", component_size)\n```\n\nFor three numbers \\(a < b < c\\) and any \\(K\\), if \\(c-a \\leq K\\), then \\(b-a \\leq K\\) and \\(c-b \\leq K\\). Consequently, if there is an edge between \\(a\\) and \\(c\\), then there are also edges between \\(a\\) and \\(b\\), and \\(b\\) and \\(c\\). Thus, one can only add edges between adjacent elements in the sorted \\(S\\) without changing connectivity.\n\nFirst, consider a graph with \\(N\\) vertices and \\(0\\) edges. Two types of queries are:\n\n1. Given \\(x\\), add an edge between vertices \\(x\\) and \\(x+1\\) if absent, or remove it if present.\n2. Find the size of the connected component containing vertex \\(x\\).\n\nLet \\(A_i\\) be \\(1\\) if there is an edge between \\(i\\) and \\(i+1\\), and \\(0\\) otherwise. The two queries can be processed as follows:\n\n- Addition and deletion of an edge are done by updating \\(A_i\\).\n- To find how far the connected component containing \\(x\\) extends to the right, \\(y > x\\) is connected to \\(x\\) if and only if \\(A[x] + \\ldots + A[y-1] = y-x\\). The maximum such \\(y\\) can be quickly found with binary search by finding the segment sum of \\(A\\). The same applies to the left.\n\nThe altered question can be solved by managing the array \\(A\\) in a segment tree. The original problem asks to add or remove vertices by maintaining the following two arrays \\(A\\) and \\(B\\) as segment trees to manage the existence of vertices and edges:\n\n- \\(A_i = 1\\) if \\(x\\) is contained in \\(S\\), and \\(A_i = 0\\) otherwise.\n- \\(B_i = 1\\) if there is an edge between \\(x\\) and \u201cthe next vertex to the right,\u201d and \\(B_i = 0\\) otherwise.\n\nCoordinate compression or a dynamic segment tree can keep the number of nodes small, making the complexity \\(O(Q\\log Q)\\) or \\(O(Q\\log\\max x_i)\\).\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\nYou can perform the following two types of operations zero or more times in any order:\n\n1. Choose a (contiguous) substring \\( ABA \\) in \\( S \\) and replace it with \\( A \\).\n2. Choose a (contiguous) substring \\( BAB \\) in \\( S \\) and replace it with \\( B \\).\n\nFind, modulo \\( 10^9+7 \\), the number of possible strings \\( S \\) after performing the operations.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 250000 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n4\nABAB\n```\n\n**Sample Output 1**\n\n```\n2\n```\n\nThe two possible strings \\( S \\) after the operations are as follows:\n- \\( ABAB \\): This string can be obtained by performing zero operations.\n- \\( AB \\): The 1st to 3rd characters of \\( S=ABAB \\) are \\( ABA \\). Replacing them with \\( A \\) results in \\( S=AB \\).\n\nHere, the 2nd to 4th characters of \\( S=ABAB \\) are \\( BAB \\), so you can also replace them with \\( B \\). Note, however, that the resulting \\( AB \\) does not count multiple times.\n\n**Sample Input 2**\n\n```\n1\nA\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\nNo operations can be performed.\n\n**Sample Input 3**\n\n```\n17\nBBABABAABABAAAABA\n```\n\n**Sample Output 3**\n\n```\n18\n```\n\n**Sample Input 4**\n\n```\n100\nABAABAABABBABAABAABAABABBABBABBABBABBABBABBABBABBABBABBABBABBABAABABAABABBABBABABBABAABAABAABAABA\n```\n\n**Sample Output 4**\n\n```\n415919090\n```\n\nRemember to take the result modulo \\( 10^9+7 \\).\n\nSolution:\n\n```\nIn competitive programming, a well-known technique is using parity to perform inversions. Let\u2019s apply it to this problem. Specifically, let\u2019s invert the characters A and B only at even positions in the input string. Then, the two available operations become:\n\nAAA \u2192 A  \nBBB \u2192 B  \n\nWith this transformation, the solution becomes straightforward. For a contiguous segment of A or B, as long as its length does not become zero, we can reduce the length by 2 each time. For example, if there is a segment AAAAA, the possible final states are AAAAA, AAA, and A: there are three. Therefore, if the length of a segment of consecutive identical characters is L, the number of possible final states for that segment is floor((L+1)/2). For all segments of consecutive identical characters, the final states can be chosen independently. Thus, the product of the above values for all such segments is the answer to this problem.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an \\( N \\times N \\) integer matrix \\( A = (A_{i,j})_{1 \\leq i \\leq N, 1 \\leq j \\leq N} \\) and an integer \\( M \\).\n\nFor an integer sequence \\( x = (x_1, x_2, \\cdots, x_M) \\) of length \\( M \\), consisting of integers between \\( 1 \\) and \\( N \\), inclusive, define \\( f(x) \\) as follows:\n\n- Let \\( y = (y_1, y_2, \\cdots, y_M) \\) be the sequence obtained by sorting the elements of \\( x \\) to be non-decreasing.\n- Define \\( f(x) = \\prod_{1 \\leq i \\leq M} A_{x_i, y_i} \\).\n\nFor each \\( k = 1, 2, \\cdots, N \\), solve the following problem:\n\n- Find the sum of \\( f(x) \\) over all sequences \\( x \\) satisfying \\( x_1 = k \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 50 \\)\n- \\( 1 \\leq M \\leq 50 \\)\n- \\( 0 \\leq A_{i,j} < 998244353 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1,1} A_{1,2} \\cdots A_{1,N}\nA_{2,1} A_{2,2} \\cdots A_{2,N}\n\\vdots\nA_{N,1} A_{N,2} \\cdots A_{N,N}\n```\n\n**Output**\n\nPrint the answer for each \\( k = 1, 2, \\cdots, N \\) in this order.\n\n**Sample Input 1**\n\n```\n2 2\n1 2\n3 4\n```\n\n**Sample Output 1**\n\n```\n5 22\n```\n\nAll possible \\( x \\) and the corresponding values of \\( f(x) \\) are as follows:\n- \\( x = (1, 1): y = (1, 1), f(x) = A_{1,1} \\times A_{1,1} = 1 \\)\n- \\( x = (1, 2): y = (1, 2), f(x) = A_{1,1} \\times A_{2,2} = 4 \\)\n- \\( x = (2, 1): y = (1, 2), f(x) = A_{2,1} \\times A_{1,2} = 6 \\)\n- \\( x = (2, 2): y = (2, 2), f(x) = A_{2,2} \\times A_{2,2} = 16 \\)\n\nThus, the answer is \\( 1 + 4 = 5 \\) for \\( k = 1 \\), and \\( 6 + 16 = 22 \\) for \\( k = 2 \\).\n\n**Sample Input 2**\n\n```\n2 3\n1 2\n3 4\n```\n\n**Sample Output 2**\n\n```\n27 118\n```\n\n**Sample Input 3**\n\n```\n5 4\n785439575 250040585 709423541 945005786 19237225\n404191279 250876592 22672563 519729086 344065186\n273714212 560047125 139793596 542901248 520999410\n855572558 498896932 418633758 742973826 248730678\n238856535 319502970 908902333 164543594 245101681\n```\n\n**Sample Output 3**\n\n```\n216530400 726773157 717209375 797938347 957133905\n```\n\n**Sample Input 4**\n\n```\n10 50\n197971506 714635866 966125570 768080799 80565655 459117401 256810168 775681305 582857561 948631706\n437330820 321722967 531470304 255908811 45459908 504089816 695016247 91058795 905527130 30860430\n151769562 979797105 619322493 298241991 360690308 480124392 297323928 284686636 922571073 627798362\n753705854 712639027 721488863 69714419 485979799 88704853 758288417 423073188 595934547 86264514\n272481811 622712481 221745114 225051881 433378197 985573661 210619166 851716760 283615535 834897126\n366075547 933505674 858395194 490049033 22039836 361481447 735151983 518458804 422209788 28981946\n907645400 111982636 978445563 686621115 486475154 734616351 587635888 527524079 454844580 826849288\n868863954 490627044 967828344 887235558 138021910 435784230 343307056 118718683 547282350 757693154\n32344652 101428952 585897722 693817619 790433406 848494439 873744405 604427602 951889915 989125209\n865548541 642980476 603592935 911086893 466178404 79002814 902745597 825893950 147052664 805753279\n```\n\n**Sample Output 4**\n\n```\n862518623 606960987 762676180 606184511 762408948 47716007 968649097 788324707 140177479 484063588\n```\n\nSolution:\n\n[BEGIN TEXT]\nOfficial Solution:\n\nPrepare \\(N\\) vertices and draw edges \\(y_i \\to x_i\\). In this graph, the out-degree and in-degree of each vertex are equal, and outgoing edges have a determined order for each vertex. Start at vertex \\(1\\) and traverse edges, choosing the next edge based on this order. This traversal ends at vertex \\(1\\), using all edges touching it. Repeat from vertices \\(2, 3, \\cdots, N\\) to use all edges. Solve for the number of ways to traverse by using dynamic programming: \\(dp[i][j]\\) is the number of ways to reach vertex \\(i\\) after \\(j\\) edges. Consider \\(x_1\\) as the first edge destination. Trying all \\(N\\) choices involves solving \\(N\\) similar problems, which can be optimized by reversing the movement order. The complexity is \\(O(N^3 M)\\).\n[END TEXT]\n \n\n", "problem_ids": ["abc356_f", "arc180_a", "agc068_e"]}, "abc325_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 300 points\n\nProblem Statement:\n\nIn AtCoder Land, there are \\( N \\) popcorn stands numbered from 1 to \\( N \\). They have \\( M \\) different flavors of popcorn, labeled from 1 to \\( M \\). However, not every stand sells all flavors of popcorn.\n\nTakahashi has obtained information about which flavors of popcorn are sold at each stand. This information is represented by \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\), each of length \\( M \\). If the \\( j \\)-th character of \\( S_i \\) is 'o', it means that stand \\( i \\) sells flavor \\( j \\) of popcorn. If it is 'x', it means that stand \\( i \\) does not sell flavor \\( j \\). Each stand sells at least one flavor of popcorn, and each flavor of popcorn is sold at least at one stand.\n\nTakahashi wants to try all the flavors of popcorn but does not want to move around too much. Determine the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn.\n\nConstraints:\n\n- \\( N \\) and \\( M \\) are integers.\n- \\( 1 \\leq N, M \\leq 10 \\)\n- Each \\( S_i \\) is a string of length \\( M \\) consisting of 'o' and 'x'.\n- For every \\( i \\) (1 \u2264 \\( i \\) \u2264 \\( N \\)), there is at least one 'o' in \\( S_i \\).\n- For every \\( j \\) (1 \u2264 \\( j \\) \u2264 \\( M \\)), there is at least one \\( i \\) such that the \\( j \\)-th character of \\( S_i \\) is 'o'.\n\nInput:\n\nThe input is given from Standard Input in the following format:\n```\nN M\nS_1\nS_2\n...\nS_N\n```\n\nOutput:\n\nPrint the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn.\n\nSample Input 1:\n```\n3 5\noooxx\nxooox\nxxooo\n```\n\nSample Output 1:\n```\n2\n```\n\nBy visiting the 1st and 3rd stands, you can buy all the flavors of popcorn. It is impossible to buy all the flavors from a single stand, so the answer is 2.\n\nSample Input 2:\n```\n3 2\noo\nox\nxo\n```\n\nSample Output 2:\n```\n1\n```\n\nSample Input 3:\n```\n8 6\nxxoxxo\nxxoxxx\nxoxxxx\nxxxoxx\nxxoooo\nxxxxox\nxoxxox\noxoxxo\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n```python\ndef main():\n    n, m = map(int, input().split())\n    s = [input().strip() for _ in range(n)]\n    ans = n\n    for bit in range(1 << n):\n        exist = [False] * m\n        cnt = 0\n        for i in range(n):\n            if (bit >> i) & 1:\n                cnt += 1\n                for j in range(m):\n                    if s[i][j] == 'o':\n                        exist[j] = True\n        all_exist = all(exist[j] for j in range(m))\n        if all_exist:\n            ans = min(ans, cnt)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe AtCoder railway line has \\( N \\) stations, numbered \\( 1, 2, \\ldots, N \\).\n\nOn this line, there are **inbound trains** that start at station \\( 1 \\) and stop at the stations \\( 2, 3, \\ldots, N \\) in order, and **outbound trains** that start at station \\( N \\) and stop at the stations \\( N - 1, N - 2, \\ldots, 1 \\) in order.\n\nTakahashi is about to travel from station \\( X \\) to station \\( Y \\) using only one of the inbound and outbound trains.\n\nDetermine whether the train stops at station \\( Z \\) during this travel.\n\n**Constraints**\n- \\( 3 \\leq N \\leq 100 \\)\n- \\( 1 \\leq X, Y, Z \\leq N \\)\n- \\( X \\), \\( Y \\), and \\( Z \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN X Y Z\n```\n\n**Output**\n\nIf the train stops at station \\( Z \\) during the travel from station \\( X \\) to station \\( Y \\), print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n```\n7 6 1 3\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Explanation:* To travel from station 6 to station 1, Takahashi will take an outbound train. After departing from station 6, the train stops at stations 5, 4, 3, 2, 1 in order, which include station 3, so you should print `Yes`.\n\n**Sample Input 2**\n```\n10 3 2 9\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n100 23 67 45\n```\n\n**Sample Output 3**\n```\nYes\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial content: \n\n---\n\nTakahashi takes an inbound train if \\(X < Y\\) and an outbound train if \\(X > Y\\). Takahashi\u2019s train will stop at station \\(Z\\) if and only if \\(X < Z < Y\\) if \\(X < Y\\), and \\(X > Z > Y\\) if \\(X > Y\\).\n\nSample code:\n```python\nn, x, y, z = map(int, input().split())\nif (x < z < y) or (y < z < x):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land is represented by a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i, j)\\) denote the cell at the \\(i\\)-th row and \\(j\\)-th column.\n\nTakahashi starts at cell \\((S_i, S_j)\\) and repeats the following action \\(K\\) times:\n- He either stays in the current cell or moves to an adjacent cell. After this action, if he is in cell \\((i, j)\\), he gains a fun value of \\(A_{i, j}\\).\n\nFind the maximum total fun value he can gain.\n\nHere, a cell \\((x', y')\\) is considered adjacent to cell \\((x, y)\\) if and only if \\(|x - x'| + |y - y'| = 1\\).\n\n**Constraints**\n\n- \\(1 \\leq H, W \\leq 50\\)\n- \\(1 \\leq K \\leq 10^9\\)\n- \\(1 \\leq S_i \\leq H\\)\n- \\(1 \\leq S_j \\leq W\\)\n- \\(1 \\leq A_{i, j} \\leq 10^9\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nH W K\nS_i S_j\nA_{1, 1} A_{1, 2} \\ldots A_{1, W}\nA_{2, 1} A_{2, 2} \\ldots A_{2, W}\n\\vdots\nA_{H, 1} A_{H, 2} \\ldots A_{H, W}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 3 3\n1 2\n2 1 2\n3 4 5\n```\n\n**Sample Output 1**\n\n```\n14\n```\n\nTakahashi can gain a total fun value of 14 by acting as follows:\n- Initially, he is at \\((1, 2)\\).\n- He moves to cell \\((2, 2)\\). Then, he gains a fun value of \\(A_{2, 2} = 4\\).\n- He moves to cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n- He stays in cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n\nHe cannot gain a total fun value greater than 14, so print 14.\n\n**Sample Input 2**\n\n```\n2 2 1000000000\n2 1\n100 100\n100 99\n```\n\n**Sample Output 2**\n\n```\n100000000000\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        In an optimal solution, one can assume that Takahashi stays at a cell with the maximum \\(A_{i,j}\\) among those he passes through. This means he can keep staying there indefinitely. Let \\((G_i, G_j)\\) be the final cell. We assume he travels from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) and then stays there zero or more times. In the travel, he never passes through the same cell twice because if he does, he can improve the score by staying more times at \\((G_i, G_j)\\). Paths from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) have a length not greater than \\(HW\\), allowing for a straightforward DP (Dynamic Programming) approach. Specifically, evaluate \\(dp_{i,j,k}\\) as the maximum total fun value after making \\(i\\) moves to end up at \\((j,k)\\). The answer is \\(\\max ((K - i) A_{j,k} + dp_{i,j,k})\\). The DP runs in \\(O((HW)^2)\\) time. Consider cases where \\(K \\leq HW\\).\n        [END TEXT]\n \n\n", "problem_ids": ["abc358_c", "abc352_a", "abc358_g"]}, "abc325_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), a non-negative integer \\( C \\), and an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nFind \\( \\displaystyle \\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace \\).\n\n**Constraints**\n\n- \\( 1 \\le N \\le 10^5 \\)\n- \\( 1 \\le M \\le 10^9 \\)\n- \\( 0 \\le C < M \\)\n- \\( 1 \\le K \\le 10^9 \\)\n- \\( 0 \\le A_i < M \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M C K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 5 3 3\n1 3\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nFor \\( k=0 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=3 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=1 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=2 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=2 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=2 \\).\n\nTherefore, the answer is \\( 1+1+2=4 \\). Hence, print 4.\n\n**Sample Input 2**\n\n```\n5 4 3 182\n0 3 2 1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Sample Input 3**\n\n```\n5 718 651 193855\n3 532 44 109 58\n```\n\n**Sample Output 3**\n\n```\n29484897\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 182\n\nE - Sum of Min of Mod of Linear Editorial\n\nAs a prerequisite, you need the floor_sum algorithm. This algorithm calculates \\(\\displaystyle f(n,m,a,b)=\\sum_{i=0}^{n-1}\\left\\lfloor\\frac{ai+b}m\\right\\rfloor\\) in \\(O(\\log m)\\) time.\n\nLet\u2019s assume that \\(A\\) has been sorted and duplicates removed so that \\(A_1 < A_2 < ... < A_N\\) holds. Fix \\(j\\), and let \\(S_j\\) be the set of \\(0\\le k < K\\) such that \\(\\displaystyle \\left\\{(Ck+A_j)\\ \\text{mod}\\ M\\right\\}=\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M\\right\\}\\). If \\(j\\geq 2\\), the condition for \\(k\\in S_j\\) can be rephrased as \\(\\left\\{(Ck+A_{j-1})\\ \\text{mod}\\ M \\right\\} > \\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\), and further as \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor=1\\). Since \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\) can only be \\(0\\) or \\(1\\), we have \\(\\displaystyle |S_j|=\\sum_{k=0}^{K-1}\\left(\\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\right)\\).\n\nTherefore,\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{k \\in S_j}\\left(\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\} - \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\right)\\\\\n&=\\sum_{k \\in S_j} (A_j-A_1-M)\\\\\n&=-(M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\nMeanwhile, for \\(j=1\\), we have\n\\[\n\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=0\n\\]\n\nThus, the answer is\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k\\in S_j}\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\} -\\sum_{j=2}^N(M+A_1-A_j)|S_j|\\\\\n&=\\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}-\\sum_{j=2}^N (M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\n\\(\\displaystyle \\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=\\sum_{k=0}^{K-1}\\left(Ck+A_1-M\\left\\lfloor\\frac{Ck+A_1}M \\right\\rfloor\\right)\\) and \\(|S_j|\\) can both be calculated quickly using the floor_sum algorithm.\n\nNow, the problem is solved. The complexity is \\(O(N(\\log N+\\log M))\\), with the bottlenecks being the sorting of \\(A\\) and the calculation of floor_sum. Be careful with overflow during implementation. You can avoid this issue by using multi-precision integers, 128-bit integers, or by using a modint with two different primes (e.g., \\(10^9+7\\) and \\(10^9+9\\)) and reconstructing the result using CRT. Alternatively, you can use a type like C++\u2019s unsigned long long, which guarantees that the correct value modulo \\(2^{64}\\) is returned even in case of overflow. The AtCoder Library\u2019s floor_sum uses unsigned long long and guarantees the correct answer modulo \\(2^{64}\\).\n\nSample Implementation (Python3):\n```python\nfrom atcoder.math import floor_sum\nn, m, c, k = map(int, input().split())\na = sorted(list(set(map(int, input().split()))))\nn = len(a)\nfl = [floor_sum(k, m, c, a[i]) for i in range(n)]\nans = c * k * (k - 1) // 2 + k * a[0] - m * fl[0]\nfor i in range(1, n):\n  ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\nprint(ans)\n```\n\nSample Implementation (Python3, translated from C++):\n```python\nfrom atcoder.math import floor_sum\n\ndef main():\n    n, m, c, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a = list(dict.fromkeys(a))\n    n = len(a)\n    fl = [floor_sum(k, m, c, a[i]) for i in range(n)]\n    ans = k * (k - 1) // 2 * c + k * a[0] - m * fl[0]\n    for i in range(1, n):\n        ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\n    print(ans)\n\nmain()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 100 points\n\n**Problem Statement**\n\nTakahashi is planning to eat \\( N \\) dishes. \n- The \\( i \\)-th dish he plans to eat is sweet if \\( S_i = \\text{sweet} \\), and salty if \\( S_i = \\text{salty} \\). \n- If he eats two sweet dishes consecutively, he will feel sick and be unable to eat any more dishes. \n\nDetermine whether he can eat all the dishes.\n\n**Constraints**\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is either \\text{sweet} or \\text{salty}.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nS_1\nS_2\n...\nS_N\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can eat all the dishes, and `No` otherwise.\n\n**Sample Input 1**\n```\n5\nsalty\nsweet\nsalty\nsalty\nsweet\n```\n\n**Sample Output 1**\n```\nYes\n```\n*Takahashi will not eat two sweet dishes consecutively, so he can eat all the dishes without feeling sick.*\n\n**Sample Input 2**\n```\n4\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 2**\n```\nYes\n```\n*He will feel sick but can still eat all the dishes.*\n\n**Sample Input 3**\n```\n6\nsalty\nsweet\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 3**\n```\nNo\n```\n*He feels sick when eating the 3rd dish and cannot eat the 4th and subsequent dishes.*\n\nSolution:\n\n        [BEGIN TEXT]\n        Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nIf there exists an integer \\(i\\) between \\(1\\) and \\((N-2)\\) such that the \\(i\\)-th and \\((i+1)\\)-th dishes to eat are both sweet, he cannot eat the \\((i+2)\\)-th dish and cannot eat all of the dishes. Otherwise, he does not get sick until eating the last dish, so he can eat all the dishes. Note that indices start from \\(0\\) in the following sample code.\n\n```python\nn = int(input())\ns = [input().strip() for _ in range(n)]\nans = \"Yes\"\nfor i in range(n - 2):\n    if s[i] == \"sweet\" and s[i + 1] == \"sweet\":\n        ans = \"No\"\nprint(ans)\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nFor a positive integer \\( N \\), let \\( V_N \\) be the integer formed by concatenating \\( N \\) exactly \\( N \\) times. More precisely, consider \\( N \\) as a string, concatenate \\( N \\) copies of it, and treat the result as an integer to get \\( V_N \\). For example, \\( V_3 = 333 \\) and \\( V_{10} = 10101010101010101010 \\).\n\nFind the remainder when \\( V_N \\) is divided by \\( 998244353 \\).\n\n**Constraints**:\n- \\( 1 \\leq N \\leq 10^{18} \\)\n- \\( N \\) is an integer.\n\n**Input**:\nThe input is given from Standard Input in the following format:\n```\nN\n```\n\n**Output**:\nPrint the remainder when \\( V_N \\) is divided by \\( 998244353 \\).\n\n**Sample Input 1**:\n```\n5\n```\n\n**Sample Output 1**:\n```\n55555\n```\nThe remainder when \\( V_5 = 55555 \\) is divided by \\( 998244353 \\) is \\( 55555 \\).\n\n**Sample Input 2**:\n```\n9\n```\n\n**Sample Output 2**:\n```\n1755646\n```\nThe remainder when \\( V_9 = 999999999 \\) is divided by \\( 998244353 \\) is \\( 1755646 \\).\n\n**Sample Input 3**:\n```\n10000000000\n```\n\n**Sample Output 3**:\n```\n468086693\n```\nNote that the input may not fit into a 32-bit integer type.\n\nSolution:\n\n```python\nfrom sys import stdin\n\nmod = 998244353\n\ndef modinv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef main():\n    n = int(stdin.readline())\n    x = n\n    r = 1\n\n    while x:\n        x //= 10\n        r *= 10\n\n    r %= mod\n\n    r_pow_n = pow(r, n, mod)\n    inv_r_minus_1 = modinv(r - 1, mod)\n\n    ans = (n * (r_pow_n - 1) * inv_r_minus_1) % mod\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n \n\n", "problem_ids": ["arc182_e", "abc364_a", "abc357_d"]}, "abc325_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi is heading to AtCoder Land. There is a signboard in front of him, and he wants to determine whether it says \"AtCoder Land.\"\n\nYou are given two strings \\( S \\) and \\( T \\) separated by a space. Determine whether \\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of uppercase and lowercase English letters, with lengths between 1 and 10, inclusive.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nIf \\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\), print \"Yes\"; otherwise, print \"No\".\n\n**Sample Input 1**\n```\nAtCoder Land\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n\\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\).\n\n**Sample Input 2**\n```\nCodeQUEEN Land\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n\\( S \\) is not \"AtCoder\".\n\n**Sample Input 3**\n```\naTcodeR lANd\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nUppercase and lowercase letters are distinguished.\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nIf you are new to learning programming, try Problem A \u201cWelcome to AtCoder\u201d from the practice contest, which provides sample code for each language. Also, explore the \u201cAtCoder Beginners Selection\u201d for more practice problems.\n\nReceive two strings as input, and implement a conditional branch to print the answer. In the conditional expression, compare strings and evaluate the logical sum of two conditions. Refer to the sample code below.\n\nSample code (Python):\n```python\ns, t = input().split()\nif s == \"AtCoder\" and t == \"Land\":\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 500 points\n\nProblem Statement\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- You are given a positive integer \\( N \\).\n- The judge has a hidden positive integer \\( R \\) and \\( N \\) integers \\( A_1, A_2, \\ldots, A_N \\). It is guaranteed that \\(|A_i| \\le R\\) and \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\).\n- There is a blackboard on which you can write integers with absolute values not exceeding \\( R \\). Initially, the blackboard is empty.\n- The judge has written the values \\( A_1, A_2, \\ldots, A_N \\) on the blackboard in this order. Your task is to make the blackboard contain only one value \\(\\sum_{i=1}^{N} A_i\\).\n- You cannot learn the values of \\( R \\) and \\( A_i \\) directly, but you can interact with the judge up to 25000 times.\n\nFor a positive integer \\( i \\), let \\( X_i \\) be the \\( i \\)-th integer written on the blackboard. Specifically, \\( X_i = A_i \\) for \\( i = 1, 2, \\ldots, N \\).\n\nIn one interaction, you can specify two distinct positive integers \\( i \\) and \\( j \\) and choose one of the following actions:\n\n1. Perform addition. The judge will erase \\( X_i \\) and \\( X_j \\) from the blackboard and write \\( X_i + X_j \\) on the blackboard.\n   - \\(|X_i + X_j| \\leq R\\) must hold.\n\n2. Perform comparison. The judge will tell you whether \\( X_i < X_j \\) is true or false.\n\nNote: At the beginning of each interaction, the \\( i \\)-th and \\( j \\)-th integers written on the blackboard must not have been erased.\n\nPerform the interactions appropriately so that after all interactions, the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\nThe values of \\( R \\) and \\( A_i \\) are determined before the start of the conversation between your program and the judge.\n\nConstraints:\n- \\( 2 \\leq N \\leq 1000 \\)\n- \\( 1 \\leq R \\leq 10^9 \\)\n- \\(|A_i| \\leq R\\)\n- \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\)\n- \\( N, R, \\) and \\( A_i \\) are integers.\n\nInput and Output\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- First, read \\( N \\) from Standard Input.\n\n  ```\n  N\n  ```\n\n- Next, repeat the interactions until the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\n- When performing addition, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  + i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  P\n  ```\n\n  Here, \\( P \\) is an integer:\n\n  - If \\( P \\geq N + 1 \\), it means that the value \\( X_i + X_j \\) has been written on the blackboard, and it is the \\( P \\)-th integer written.\n  - If \\( P = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\n- When performing comparison, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  ? i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  Q\n  ```\n\n  Here, \\( Q \\) is an integer:\n\n  - If \\( Q = 1 \\), it means that \\( X_i < X_j \\) is true.\n  - If \\( Q = 0 \\), it means that \\( X_i < X_j \\) is false.\n  - If \\( Q = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\nFor both types of interactions, if the judge's response is -1, your program is already considered incorrect. In this case, terminate your program immediately.\n\nWhen the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), report this to the judge in the following format. This does not count towards the number of interactions. Then, terminate your program immediately.\n\n  ```\n  !\n  ```\n\nIf you make an output in a format that does not match any of the above, -1 will be given from Standard Input.\n\n  ```\n  -1\n  ```\n\nIn this case, your program is already considered incorrect. Terminate your program immediately.\n\nNotes\n\n- For each output, append a newline at the end and flush Standard Output. Otherwise, the verdict may be TLE.\n- Terminate your program immediately after outputting the result (or receiving -1). Otherwise, the verdict will be indeterminate.\n- Extra newlines will be considered as malformed output.\n\nSample Input and Output\n\nHere is a possible conversation with \\( N=3, R=10, A_1=-1, A_2=10, A_3=1 \\).\n\n**Input:**\n```\n3\n```\n\n**Output:**\n```\n? 1 2\n1\n+ 1 3\n4\n+ 2 4\n5\n!\n```\n\n**Explanation:**\n\n1. First, the integer \\( N \\) is given.\n2. Perform a comparison between \\( X_1 \\) and \\( X_2 \\). The judge returns 1 because \\( X_1 < X_2 \\) (-1 < 10).\n3. Perform an addition of \\( X_1 \\) and \\( X_3 \\). The judge erases \\( X_1 = -1 \\) and \\( X_3 = 1 \\) from the blackboard and writes \\( X_1 + X_3 = 0 \\). This is the fourth integer written.\n4. Perform an addition of \\( X_2 \\) and \\( X_4 \\). The judge erases \\( X_2 = 10 \\) and \\( X_4 = 0 \\) from the blackboard and writes \\( X_2 + X_4 = 10 \\). This is the fifth integer written.\n5. The blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), so report this to the judge.\n\nSolution:\n\nBelow is the editorial as provided, since there's no code to translate to Python3:\n\n```\nAtCoder Regular Contest 179 - C: Beware of Overflow Editorial\n\nTo have only one integer on the blackboard, we need to perform exactly \\(N-1\\) additions. When there are two or more integers left on the blackboard, we should add the maximum and minimum values. The absolute value of their sum does not exceed \\(R\\). Let \\(X\\) be the multiset of integers on the blackboard, with maximum \\(M\\) and minimum \\(m\\). The absolute value of every element in \\(X\\) is at most \\(R\\), and \\(\\displaystyle\\left|\\sum_{x\\in X}x\\right|\\leq R\\).\n\n1. If \\(m \\geq 0\\), all integers are non-negative: \\(0 \\leq m + M \\leq R\\), so \\(|m + M| \\leq R\\).\n2. If \\(M \\leq 0\\), all integers are non-positive: \\(0 \\geq m + M \\geq -R\\), so \\(|m + M| \\leq R\\).\n3. If \\(m \\leq 0\\) and \\(M \\geq 0\\), \\(-R \\leq m \\leq m + M \\leq M \\leq R\\), so \\(|m + M| \\leq R\\).\n\nWe should add the maximum and minimum values. Use merge sort to arrange values in ascending order. Perform addition interactions to add the minimum and maximum values. Remove the first and last elements and insert the sum. Binary search determines the insertion position.\n\nEstimate interactions: Merge sort on a list of length \\(2^n\\) requires at most \\(a_n = n2^n\\) comparisons. Under \\(N \\leq 1000 \\leq 2^{10}\\), at most 10240 comparisons are needed. Finding insertion positions requires at most \\(10 \\times (N-1) \\leq 9990\\) comparisons. In total, at most 20230 comparisons plus \\(N-1 \\leq 999\\) additions remain well within the limit of 25000 interactions.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(N\\) where all elements are between \\(1\\) and \\(2^K - 1\\), inclusive, is called a **good sequence**.\n\nThe **score** of a good sequence \\(A = (A_1, A_2, \\ldots, A_N)\\) is defined as follows:\n- The number of distinct integers that can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) using an integer \\(i\\) between \\(1\\) and \\(N\\), inclusive, and a non-negative integer \\(k\\).\n\nFor example, for \\(A = (3, 5)\\), five integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3,\\) and \\(5\\), so the score is \\(5\\).\n\nFind one good sequence with the maximum score.\n\nFor each input file, you are given \\(T\\) test cases to solve.\n\n### Constraints\n- \\(1 \\leq T \\leq 10^5\\)\n- \\(1 \\leq N \\leq 10^5\\)\n- \\(1 \\leq K \\leq 30\\)\n- The sum of \\(N\\) across the test cases in a single input file is at most \\(2 \\times 10^5\\).\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format. Here, \\(\\text{case}_i\\) denotes the \\(i\\)-th test case.\n\n```\nT\n\\text{case}_1\n\\text{case}_2\n\\vdots\n\\text{case}_T\n```\n\nEach test case is given in the following format:\n```\nN K\n```\n\n### Output\nPrint \\(T\\) lines.\n\nThe \\(i\\)-th line should contain the answer for \\(\\text{case}_i\\).\n\nIf there are multiple good sequences with the maximum score, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n3 3\n7 2\n8 20\n```\n\n### Sample Output 1\n```\n5 6 7\n2 2 3 3 1 3 3\n662933 967505 876482 840117 1035841 651549 543175 781219\n```\n\n**Explanation for the first test case:**\nFor \\(A = (5, 6, 7)\\), seven integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3, 5, 6,\\) and \\(7\\), so its score is \\(7\\). Outputs such as \\(A = (7, 4, 5)\\) and \\(A = (6, 5, 4)\\) would also be accepted.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nB - |{floor(A_i/2^k)}| Editorial by evima\n\nIn this explanation, we assume that indices start from \\(0\\). First, it is unnecessary to include elements less than \\(2^{K-1}\\) in \\(A\\). This is because replacing elements less than \\(2^{K-1}\\) with their double will result in the same or a higher score. Therefore, we can limit the elements of \\(A\\) to be between \\(2^{K-1}\\) and \\(2^K-1\\).\n\n1. When \\(N \\geq 2^{K-1}\\): We can include all elements between \\(2^{K-1}\\) and \\(2^K-1\\) in \\(A\\) and set \\(A_i = \\max(1, 2^K - 1 - i)\\) \\((0 \\le i < N)\\).\n\n2. When \\(N < 2^{K-1}\\): Consider an upper bound of the score. For \\(0 \\le x < K\\), consider the number of elements that appear as \\(\\displaystyle \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) between \\(2^x\\) and \\(2^{x+1}-1\\). For each \\(A_i\\), there is at most one \\(k\\) that satisfies \\(\\displaystyle 2^x \\le \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor < 2^{x+1}\\), so the number of such elements is at most \\(N\\). On the other hand, there are only \\(2^x\\) integers between \\(2^x\\) and \\(2^{x+1}\\), so the number of elements that appear in this range is at most \\(\\min(N, 2^x)\\). Therefore, by summing over all \\(x\\), the score has an upper bound of \\(\\displaystyle 1 + \\sum_{x=0}^{K-1}\\min(N, 2^x)\\).\n\nThis upper bound can always be achieved. Specifically, construct \\(A\\) as follows: Set \\(A_i\\) to the sum of \\(2^{K-1}\\) and the bit-reversal of \\(i\\). \u201cThe bit-reversal of \\(i\\)\u201d means the value obtained by reversing the \\((K-1)\\)-bit binary representation of \\(i\\).\n\nBy implementing the above, we can solve this problem. The time complexity is \\(O(NK)\\) due to the bit-reversal calculation being the bottleneck.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n\n    def bit_reversal(x):\n        return int(bin(x)[2:].zfill(K - 1)[::-1], 2)\n\n    if N >= 2 ** (K - 1):\n        print(*[max(1, 2**K - i - 1) for i in range(N)])\n    else:\n        print(*[2 ** (K - 1) + bit_reversal(i) for i in range(N)])\n```\n\nAdditionally, you can also solve it by constructing from the highest bit downwards.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n    C = [1]\n    for _ in range(1, K):\n        D = [2 * c for c in C] + [2 * c + 1 for c in C]\n        C = D[:N]\n    while len(C) < N:\n        C.append(1)\n    print(*C)\n```\n```\n \n\n", "problem_ids": ["abc358_a", "arc179_c", "arc182_b"]}, "abc325_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Kingdom of AtCoder has \\( N \\) towns numbered from 1 to \\( N \\). To move from town \\( i \\) to town \\( j \\), you must pay a toll of \\( C \\times |i-j| \\) yen. Takahashi, a merchant, is considering participating in zero or more of \\( M \\) upcoming markets. The \\( i \\)-th market (\\( 1 \\leq i \\leq M \\)) is described by the pair of integers \\((T_i, P_i)\\), where the market is held in town \\( T_i \\) and he will earn \\( P_i \\) yen if he participates.\n\nFor all \\( 1 \\leq i < M \\), the \\( i \\)-th market ends before the \\((i+1)\\)-th market begins. The time it takes for him to move is negligible. He starts with \\( 10^{10^{100}} \\) yen and is initially in town 1. \n\nDetermine the maximum profit he can make by optimally choosing which markets to participate in and how to move. Formally, let \\( 10^{10^{100}} + X \\) be his final amount of money if he maximizes the amount of money he has after the \\( M \\) markets. Find \\( X \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq T_i \\leq N \\) (for \\( 1 \\leq i \\leq M \\))\n- \\( 1 \\leq P_i \\leq 10^{13} \\) (for \\( 1 \\leq i \\leq M \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN C\nM\nT_1 P_1\nT_2 P_2\n...\nT_M P_M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n6 3\n4\n5 30\n2 10\n4 25\n2 15\n```\n\n**Sample Output 1**\n\n```\n49\n```\n\n**Explanation for Sample 1**\n\nFor example, Takahashi can increase his money by 49 yen by acting as follows:\n- Move to town 5. His money becomes \\( 10^{10^{100}} - 12 \\) yen.\n- Participate in the first market. His money becomes \\( 10^{10^{100}} + 18 \\) yen.\n- Move to town 4. His money becomes \\( 10^{10^{100}} + 15 \\) yen.\n- Participate in the third market. His money becomes \\( 10^{10^{100}} + 40 \\) yen.\n- Move to town 2. His money becomes \\( 10^{10^{100}} + 34 \\) yen.\n- Participate in the fourth market. His money becomes \\( 10^{10^{100}} + 49 \\) yen.\n\nIt is impossible to increase his money to \\( 10^{10^{100}} + 50 \\) yen or more, so print 49.\n\n**Sample Input 2**\n\n```\n6 1000000000\n4\n5 30\n2 10\n4 25\n2 15\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Explanation for Sample 2**\n\nThe toll fee is so high that it is optimal for him not to move from town 1.\n\n**Sample Input 3**\n\n```\n50 10\n15\n37 261\n28 404\n49 582\n19 573\n18 633\n3 332\n31 213\n30 377\n50 783\n17 798\n4 561\n41 871\n15 525\n16 444\n26 453\n```\n\n**Sample Output 3**\n\n```\n5000\n```\n\n**Sample Input 4**\n\n```\n50 1000000000\n15\n30 60541209756\n48 49238708511\n1 73787345006\n24 47221018887\n9 20218773368\n34 40025202486\n14 28286410866\n24 82115648680\n37 62913240066\n14 92020110916\n24 20965327730\n32 67598565422\n39 79828753874\n40 52778306283\n40 67894622518\n```\n\n**Sample Output 4**\n\n```\n606214471001\n```\n\nNote that the output value may exceed the range of a 32-bit integer.\n\nSolution:\n\n```python\n# Python translation of the given C++ code\n\nclass SegmentTree:\n    OP = max\n    ID = 0\n\n    def __init__(self, n):\n        self.n = n\n        self.data = [self.ID] * (2 * n)\n\n    def set(self, p, value):\n        p += self.n\n        self.data[p] = value\n        p //= 2\n        while p > 0:\n            self.data[p] = self.OP(self.data[2 * p], self.data[2 * p + 1])\n            p //= 2\n\n    def prod(self, l, r):\n        l += self.n\n        r += self.n\n        result = self.ID\n        while l < r:\n            if l & 1:\n                result = self.OP(result, self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                result = self.OP(result, self.data[r])\n            l //= 2\n            r //= 2\n        return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    C = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    prefix = SegmentTree(N)\n    suffix = SegmentTree(N)\n    \n    offset = 2000000000000000000\n    \n    prefix.set(0, offset)\n    suffix.set(0, offset)\n    \n    ans = offset\n    \n    for _ in range(M):\n        T = int(data[idx]) - 1\n        idx += 1\n        P = int(data[idx])\n        idx += 1\n        \n        best = max(prefix.prod(0, T + 1) - C * T, suffix.prod(T, N) + C * T) + P\n        \n        ans = max(ans, best)\n        \n        prefix.set(T, best + C * T)\n        suffix.set(T, best - C * T)\n    \n    print(ans - offset)\n\n# The following is necessary since we are translating a full program.\n# In an actual competitive programming setting, you'd want to call main directly.\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a sequence \\( (X_1, X_2, \\dots, X_M) \\) of length \\( M \\) consisting of integers between \\( 1 \\) and \\( M \\), inclusive.\n\nFind the number, modulo \\( 998244353 \\), of sequences \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\) consisting of integers between \\( 1 \\) and \\( M \\), inclusive, that satisfy the following condition:\n\nFor each \\( B = 1, 2, \\dots, M \\), the value \\( X_B \\) exists between any two different occurrences of \\( B \\) in \\( A \\) (including both ends).\n\nMore formally, for each \\( B = 1, 2, \\dots, M \\), the following condition must hold:\n\nFor every pair of integers \\( (l, r) \\) such that \\( 1 \\leq l < r \\leq N \\) and \\( A_l = A_r = B \\), there exists an integer \\( m \\) (\\( l \\leq m \\leq r \\)) such that \\( A_m = X_B \\).\n\n**Constraints**\n- \\( 1 \\leq M \\leq 10 \\)\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq X_i \\leq M \\)\n- All input values are integers.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nM N\nX_1 X_2 \\cdots X_M\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n3 4\n2 1 2\n```\n\n**Sample Output 1**\n```\n14\n```\n\nHere are examples of sequences \\( A \\) that satisfy the condition:\n- \\( (1, 3, 2, 3) \\)\n- \\( (2, 1, 2, 1) \\)\n- \\( (3, 2, 1, 3) \\)\n\nHere are non-examples:\n- \\( (1, 3, 1, 3) \\) - There is no \\( X_3 = 2 \\) between the \\( 3 \\)s.\n- \\( (2, 2, 1, 3) \\) - There is no \\( X_2 = 1 \\) between the \\( 2 \\)s.\n\n**Sample Input 2**\n```\n4 8\n1 2 3 4\n```\n\n**Sample Output 2**\n```\n65536\n```\n\nAll sequences of length \\( 8 \\) consisting of integers between \\( 1 \\) and \\( 4 \\) satisfy the condition. Note that when \\( X_B = B \\), there is always a \\( B \\) between two different occurrences of \\( B \\).\n\n**Sample Input 3**\n```\n4 9\n2 3 4 1\n```\n\n**Sample Output 3**\n```\n628\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 179\n\n# B - Between B and B Editorial by evima\n\n# For each B = 1, 2, ..., M, the value X_B exists between any two different occurrences \n# of B in A (including both ends). This condition will be referred to as \u201cthe condition.\u201d \n# Let\u2019s consider determining the elements of A from the beginning. When deciding A_i, \n# we choose A_i such that (A_1, A_2, ..., A_i) satisfies the condition. Therefore, \n# let\u2019s consider the following dynamic programming approach.\n\n# Let dp[c][S] be the number of ways to determine the first c(=0,1,...,N) elements of \n# A such that the set of possible values for A_{c+1} is S (\u2286 {1,2,...,M}).\n\n# First, any of 1, 2, ..., M can be chosen as A_1. Therefore, dp[0][{1,2,...,M}] = 1. \n# Next, let\u2019s consider what happens when c and S are fixed, and we decide A_{c+1} to \n# be a \u2208 S. First, due to the condition that X_a must exist between any two occurrences \n# of a, we remove a from S. This can be interpreted as not being allowed to add a again \n# until X_a is added. Next, we add all b such that X_b = a to S. This can be interpreted \n# as allowing b to be added since X_b has been added. Let the new set obtained in this \n# way be written as S(a). The transition in the dynamic programming can be written as \n# follows:\n\n# dp[c+1][S(a)] += dp[c][S]  (a \u2208 S)\n\n# This is a bitDP. The time complexity is O(NM2^M), which is sufficiently fast under \n# the given constraints.\n```\n\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi eats three plates for breakfast: rice, miso soup, and salad. His table is long and narrow, so he arranged the three plates in a row. The arrangement is given by a string \\( S \\), where the \\( i \\)-th plate from the left is rice if \\( S_i \\) is \\( R \\), miso soup if \\( S_i \\) is \\( M \\), and salad if \\( S_i \\) is \\( S \\).\n\nDetermine whether the plate of rice is to the left of the plate of miso soup.\n\n**Constraints**\n\n- \\(|S| = 3\\)\n- \\( S \\) contains one \\( R \\), one \\( M \\), and one \\( S \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n**Output**\n\nPrint `Yes` if the plate of rice is to the left of the plate of miso soup, and `No` otherwise.\n\n**Sample Input 1**\n\n```\nRSM\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nThe plate of rice is at the 1st position from the left, and the plate of miso soup is at the 3rd position from the left. Since the plate of rice is to the left, print `Yes`.\n\n**Sample Input 2**\n\n```\nSMR\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nThe plates are arranged as salad, miso soup, and rice from left to right.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 360\n\nA - A Healthy Breakfast Editorial by en_translator\n\nFor beginners: If you are new to learning programming, please try \"Welcome to AtCoder\" from the practice contest. There you can find a sample code for each language. If you are not familiar with programming contests, try some problems in \"AtCoder Beginners Selection.\" \"C++\u5165\u9580 AtCoder Programming Guide for beginners (APG4b)\" is a C++ tutorial for competitive programmers (in Japanese).\n\nSolution: Prepare a string variable s. Read input into s. Use a for loop to determine positions of R and M in s. Let pos_r and pos_m be those indices. Use an if statement to print 'Yes' if pos_r < pos_m, otherwise print 'No'. With only six possible strings for \\(S\\), you can manually determine the answer using a conditional branch. Sample code in C++ provided.\n```\n\n \n\n", "problem_ids": ["abc353_g", "arc179_b", "abc360_a"]}, "abc325_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence of integers \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nDefine \\( f(l, r) \\) as the number of distinct values in the subsequence \\( (A_l, A_{l+1}, \\ldots, A_r) \\).\n\nEvaluate the following sum:\n\n\\[\n\\sum_{i=1}^{N}\\sum_{j=i}^N f(i,j)\n\\]\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\n\nThe input is given in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n3\n1 2 2\n```\n\n### Sample Output 1\n\n```\n8\n```\n\nConsider \\( f(1, 2) \\). The subsequence \\( (A_1, A_2) = (1, 2) \\) contains 2 distinct values, so \\( f(1,2) = 2 \\).\n\nConsider \\( f(2, 3) \\). The subsequence \\( (A_2, A_3) = (2, 2) \\) contains 1 distinct value, so \\( f(2,3) = 1 \\).\n\nThe sum of \\( f \\) is 8.\n\n### Sample Input 2\n\n```\n9\n5 4 2 2 3 2 4 4 1\n```\n\n### Sample Output 2\n\n```\n111\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 371\n\nE - I Hate Sigma Problems Editorial\n\nThe answer is the number of subarrays containing \\(1\\) \\(+\\) the number of subarrays containing \\(2\\) \\(+\\ldots+\\) the number of subarrays containing \\(N\\). We will explain how to count subarrays containing \\(i\\) in \\(\\mathrm{O}(C_i)\\) time (where \\(C_i\\) is the number of occurrences of \\(i\\) in \\(A\\)). Once this is possible, the problem can be solved in a total of \\(\\mathrm{O}(N)\\) time. A common technique of combinatorics is to consider complementary events. Let\u2019s count the number of subarrays not containing \\(i\\), subtracting the sum from the all. For simplicity, let us insert \\(i\\) to both ends of \\(A\\). Then, the indices \\(x\\) with \\(A_x = i\\) arranged in ascending order are represented as \\(x=(x_0=0,x_1,\\ldots,x_{C_i+1} = N+1)\\). The number of subarrays not containing \\(i\\) equals the number of subarrays whose left end is \\(x_0+1\\) or greater, and right end is \\(x_1-1\\) or less, plus subarrays whose left end is \\(x_1+1\\) or greater, and right end is \\(x_2-1\\) or less, and so on. This can be evaluated in \\(\\mathrm{O}(C_i)\\) time. Hence, the problem has been solved.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( N \\) and a sequence of \\( M \\) positive integers \\( A = (A_1, A_2, \\ldots, A_M) \\). All elements of \\( A \\) are distinct integers between \\( 1 \\) and \\( N \\), inclusive.\n\nA permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) is called a *good permutation* if it satisfies the following condition for all integers \\( i \\) such that \\( 1 \\leq i \\leq M \\):\n\n- No contiguous subsequence of \\( P \\) is a permutation of \\( (1, 2, \\ldots, A_i) \\).\n\nDetermine whether a *good permutation* exists, and if it does, find the lexicographically smallest *good permutation*.\n\n**What is lexicographical order?**\n\nA sequence \\( S = (S_1, S_2, \\ldots, S_{|S|}) \\) is said to be *lexicographically smaller* than a sequence \\( T = (T_1, T_2, \\ldots, T_{|T|}) \\) if one of the following conditions holds:\n\n1. \\( |S| < |T| \\) and \\( (S_1, S_2, \\ldots, S_{|S|}) = (T_1, T_2, \\ldots, T_{|S|}) \\).\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|S|, |T|\\} \\) such that both of the following hold:\n   - \\( (S_1, S_2, \\ldots, S_{i-1}) = (T_1, T_2, \\ldots, T_{i-1}) \\).\n   - \\( S_i \\) is smaller than \\( T_i \\) (as a number).\n\n**Constraints**\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All elements of \\( A \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\cdots A_M\n```\n\n**Output**\n\nIf a *good permutation* does not exist, print `-1`.  \nIf it exists, print the lexicographically smallest *good permutation*, separated by spaces.\n\n**Sample Input 1**\n```\n4 1\n2\n```\n\n**Sample Output 1**\n```\n1 3 2 4\n```\n\nFor example, \\( (4, 2, 1, 3) \\) is not a *good permutation* because it contains \\( (2, 1) \\) as a contiguous subsequence. Other non-*good permutations* are \\( (1, 2, 3, 4) \\) and \\( (3, 4, 2, 1) \\). Some *good permutations* are \\( (4, 1, 3, 2) \\) and \\( (2, 3, 4, 1) \\). Among these, the lexicographically smallest one is \\( (1, 3, 2, 4) \\), so print it separated by spaces.\n\n**Sample Input 2**\n```\n5 3\n4 3 2\n```\n\n**Sample Output 2**\n```\n1 3 4 5 2\n```\n\nExamples of *good permutations* include \\( (3, 4, 1, 5, 2) \\), \\( (2, 4, 5, 3, 1) \\), and \\( (4, 1, 5, 2, 3) \\). Examples of non-*good permutations* include \\( (1, 2, 5, 3, 4) \\), \\( (2, 3, 4, 1, 5) \\), and \\( (5, 3, 1, 2, 4) \\).\n\n**Sample Input 3**\n```\n92 4\n16 7 1 67\n```\n\n**Sample Output 3**\n```\n-1\n```\n\nIf a *good permutation* does not exist, print `-1`.\n\n**Sample Input 4**\n```\n43 2\n43 2\n```\n\n**Sample Output 4**\n```\n-1\n```\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nA - Good Permutation 2 Editorial by evima\n\nIf \\(A\\) contains either \\(1\\) or \\(N\\), a good permutation does not exist. Conversely, if neither \\(1\\) nor \\(N\\) is included in \\(A\\), a good permutation does exist. Let\u2019s consider this case. For example, if we set \\(P = (1, N, N - 1, N - 2, \\dots, 3, 2)\\), the only contiguous subsequence of \\(P\\) that includes both \\(1\\) and \\(2\\) is \\(P\\) itself, making \\(P\\) a good permutation. \n\nSince a good permutation with \\(P_{1} = 1\\) exists, the lexicographically smallest good permutation will have \\(P_{1} = 1\\). For any integer \\(x\\), if there exists a contiguous subsequence of \\(P\\) that is a permutation of \\((1, 2, \\dots, x)\\), it must be \\((P_{1}, P_{2}, \\dots, P_{x})\\). We determine \\(P_{i}\\) for \\(i \\neq 1\\) in ascending order of \\(i\\). When deciding \\(P_{i}\\), assume that all of \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\) are at most \\(i\\). Let \\(a\\) be the number that is at most \\(i\\) and not included in \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\).\n\nWhen \\(i\\) is included in \\(A\\):\nTo make the permutation lexicographically smallest, set \\(P_{i} = i + 1\\). Since \\(P_{i}\\) is not greater than \\(i + 1\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) does not change.\n\nWhen \\(i\\) is not included in \\(A\\):\nSet \\(P_{i} = a\\). Since this number is not greater than \\(i\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) becomes \\(i + 1\\).\n\nThe time complexity is \\(O(N)\\).\n\n```python\n# input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nban = [0] * N\nfor a in A:\n    ban[a - 1] = 1\n\n# impossible\nif ban[0] or ban[N - 1]:\n    print(-1)\n    quit()\n\n# init\nP = [0] * N\nP[0] = 1\na = 2\n\n# calc\nfor i in range(1, N):\n    if ban[i] == 1:\n        P[i] = i + 2\n    else:\n        P[i] = a\n        a = i + 2\n\n# output\nprint(*P)\n```\n\nYou can also construct the permutation as follows: Initialize \\(P = (1, 2, \\dots, N)\\), and for \\(i = 2, 3, \\dots, N - 1\\), perform the following operation: If \\(i\\) is included in \\(A\\), do \\(\\text{swap}(P_{i}, P_{i + 1})\\).\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nTakahashi can swim in \\( N \\) different styles. When he swims in the \\( i \\)-th style, he consumes \\( A_i \\) stamina per second and advances \\( B_i \\) meters per second. \n\nYou need to answer \\( Q \\) queries. The \\( i \\)-th query is as follows: determine if it is possible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\). If it is possible, find the minimum number of seconds required.\n\nTakahashi can freely combine different swimming styles, and the time to switch styles is negligible. Specifically, he can swim using the following steps:\n- Choose a positive integer \\( m \\), a sequence of positive real numbers \\( t = (t_1, t_2, \\dots, t_m) \\) of length \\( m \\), and a sequence of integers \\( x = (x_1, x_2, \\dots, x_m) \\) of length \\( m \\) where each element is between \\( 1 \\) and \\( N \\), inclusive.\n- Then, swim in the \\( x_i \\)-th style for \\( t_i \\) seconds in the order \\( i = 1, 2, \\dots, m \\).\n\n**Constraints:**\n- All input values are integers.\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C_i, D_i \\leq 10^9 \\)\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\nQ\nC_1 D_1\nC_2 D_2\n...\nC_Q D_Q\n```\n\n**Output:**\nPrint \\( Q \\) lines in total. For the \\( i \\)-th query, print the answer in the \\( i \\)-th line as follows:\n- If it is impossible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\), print \\(-1\\).\n- Otherwise, print the minimum required time. The output is considered correct if the absolute or relative error between the printed value and the true answer is at most \\( 10^{-9} \\).\n\n**Sample Input:**\n```\n4\n1 2\n2 3\n3 3\n4 4\n5\n4 7\n7 7\n49 100\n1000 500\n4 5\n```\n\n**Sample Output:**\n```\n3.000000000000000000\n1.750000000000000000\n-1\n125.000000000000000000\n1.500000000000000000\n```\n\nIn this input, Takahashi can swim in the following four styles:\n- Consumes 1 stamina and advances 2 meters per second.\n- Consumes 2 stamina and advances 3 meters per second.\n- Consumes 3 stamina and advances 3 meters per second.\n- Consumes 4 stamina and advances 4 meters per second.\n\nThis input contains five queries:\n- For the first query, \\( C_1 = 4, D_1 = 7 \\). Choose \\( t = (1,2) \\) and \\( x = (2,1) \\). Takahashi swims as follows:\n  - In the first 1 second, he consumes 2 stamina and advances 3 meters.\n  - In the next 2 seconds, he consumes 2 stamina and advances 4 meters.\n  - In total, he consumes 4 stamina and advances 7 meters. The required time is 3 seconds, which is the minimum.\n- For the second query, \\( C_2 = 7, D_2 = 7 \\). Choose \\( t = (7/4) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 7/4 seconds, he consumes 7 stamina and advances 7 meters.\n  - In total, he consumes 7 stamina and advances 7 meters. The required time is 7/4 seconds, which is the minimum.\n- For the third query, \\( C_3 = 49, D_3 = 100 \\). No matter how Takahashi swims, it is not possible to advance 100 meters while keeping the total stamina consumption at most 49.\n- For the fourth query, \\( C_4 = 1000, D_4 = 500 \\). Choose \\( t = (125) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 125 seconds, he consumes 500 stamina and advances 500 meters.\n  - In total, he consumes 500 stamina and advances 500 meters. The required time is 125 seconds, which is the minimum.\n- For the fifth query, \\( C_5 = 4, D_5 = 5 \\). Choose \\( t = (1/2,1) \\) and \\( x = (4,2) \\). Takahashi swims as follows:\n  - In the first 1/2 seconds, he consumes 2 stamina and advances 2 meters.\n  - In the next 1 second, he consumes 2 stamina and advances 3 meters.\n  - In total, he consumes 4 stamina and advances 5 meters. The required time is 3/2 seconds, which is the minimum.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 356\n\nConsider the case where Takahashi can swim using two styles: consume stamina of \\(A_1\\) to advance \\(B_1\\) meters per second or consume stamina of \\(A_2\\) to advance \\(B_2\\) meters per second. He can combine these styles to swim by consuming stamina of \\(tA_1+(1-t)A_2\\) to advance \\(tB_1+(1-t)B_2\\) meters per second. This corresponds to points on the segment connecting \\((B_1,A_1)\\) and \\((B_2,A_2)\\) in the \\(xy\\)-plane.\n\nIf there are \\(N\\) points \\((B_i,A_i)\\), he can swim for any point inside or on the convex hull's boundary, but not outside it. Plotting the styles on the \\(xy\\)-plane assists in this determination. The most time-efficient point has the maximum \\(B_i\\), and the most stamina-efficient point has the minimum \\(A_i/B_i\\). If he can't swim \\(D_i\\) meters using the stamina-efficient point, the answer is -1.\n\nTo swim \\(D_i\\) meters within stamina \\(C_i\\), locate the rightmost point in the intersection of the convex hull's circumference and a line passing through \\((0,0)\\) and \\((D_i,C_i)\\). This represents viable swimming styles under the stamina constraint. He should trace the convex hull from the stamina-efficient point to the time-efficient point counterclockwise. Using binary search helps identify which segment it lies on and then pinpoints \\(P_{opt}\\)'s exact coordinates.\n```\n \n\n", "problem_ids": ["abc371_e", "arc178_a", "abc356_g"]}, "abc326_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 450 points\n\n## Problem Statement\n\nThere are \\( N \\) islands and \\( M \\) bidirectional bridges connecting two islands. The islands and bridges are numbered \\( 1, 2, \\ldots, N \\) and \\( 1, 2, \\ldots, M \\), respectively. Bridge \\( i \\) connects islands \\( U_i \\) and \\( V_i \\), and the time it takes to cross it in either direction is \\( T_i \\). No bridge connects an island to itself, but it is possible for two islands to be directly connected by more than one bridge. One can travel between any two islands using some bridges.\n\nYou are given \\( Q \\) queries, so answer each of them. The \\( i \\)-th query is as follows:\n\n- You are given \\( K_i \\) distinct bridges: bridges \\( B_{i,1}, B_{i,2}, \\ldots, B_{i,K_i} \\).\n- Find the minimum time required to travel from island \\( 1 \\) to island \\( N \\) using each of these bridges at least once.\n- Only consider the time spent crossing bridges.\n- You can cross the given bridges in any order and in any direction.\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 400 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq T_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 3000 \\)\n- \\( 1 \\leq K_i \\leq 5 \\)\n- \\( 1 \\leq B_{i,1} < B_{i,2} < \\cdots < B_{i,K_i} \\leq M \\)\n- All input values are integers.\n- It is possible to travel between any two islands using some bridges.\n\n## Input\n\nThe input is given in the following format:\n```\nN M\nU_1 V_1 T_1\nU_2 V_2 T_2\n\u22ee\nU_M V_M T_M\nQ\nK_1\nB_{1,1} B_{1,2} \u22ef B_{1,{K_1}}\nK_2\nB_{2,1} B_{2,2} \u22ef B_{2,{K_2}}\n\u22ee\nK_Q\nB_{Q,1} B_{Q,2} \u22ef B_{Q,{K_Q}}\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq Q \\)) should contain the answer to the \\( i \\)-th query as an integer.\n\n## Sample Input 1\n\n```\n3 5\n1 2 10\n1 3 20\n1 3 30\n2 3 15\n2 3 25\n2\n1\n1\n2\n3 5\n```\n\n## Sample Output 1\n\n```\n25\n70\n```\n\nExplanation:\n- For the first query, the minimum time to travel from island 1 to island 3 using bridge 1 is achieved by using bridge 1 to move from island 1 to island 2, then bridge 4 to move from island 2 to island 3. The time taken is 10 + 15 = 25.\n- For the second query, the minimum time to travel from island 1 to island 3 using both bridges 3 and 5 is achieved by using bridge 3 to move from island 1 to island 3, then using bridge 5 to move to island 2, and finally bridge 4 to return to island 3. The time taken is 30 + 25 + 15 = 70.\n\n## Sample Input 2\n\n```\n6 6\n1 5 1\n2 5 1\n2 4 1\n3 4 1\n3 6 1\n1 6 1\n2\n5\n1 2 3 4 5\n1\n5\n```\n\n## Sample Output 2\n\n```\n5\n3\n```\n\nRemarks: You can cross the specified bridges in either direction.\n\n## Sample Input 3\n\n```\n5 5\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4 5 1000000000\n1 5 1000000000\n1\n1\n3\n```\n\n## Sample Output 3\n\n```\n4000000000\n```\n\nNote: The answer may not fit in a 32-bit integer.\n\nSolution:\n\n```python\nimport itertools\n\nN = 400\nM = int(2e5)\nINF = int(1e15)\n\nn = 0\nu = [0] * M\nv = [0] * M\nt = [0] * M\nd = [[0 if i == j else INF for j in range(N)] for i in range(N)]\nk = 0\na = []\n\ndef solve():\n    ans = INF\n    dp = [[0] * 2 for _ in range(5)]\n    b = list(range(k))\n    for perm in itertools.permutations(b):\n        dp[0][0] = d[0][v[a[perm[0]]]] + t[a[perm[0]]]\n        dp[0][1] = d[0][u[a[perm[0]]]] + t[a[perm[0]]]\n        for i in range(k - 1):\n            dp[i + 1][0] = min(dp[i][0] + d[u[a[perm[i]]]][v[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][v[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n            dp[i + 1][1] = min(dp[i][0] + d[u[a[perm[i]]]][u[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][u[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n        ans = min(ans, dp[k-1][0] + d[u[a[perm[k-1]]]][n-1])\n        ans = min(ans, dp[k-1][1] + d[v[a[perm[k-1]]]][n-1])\n    return ans\n\ndef main():\n    global n, k\n    m, q = map(int, input().split())\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d[i][j] = INF\n\n    for i in range(m):\n        u[i], v[i], t[i] = map(int, input().split())\n        u[i] -= 1\n        v[i] -= 1\n        d[u[i]][v[i]] = min(d[u[i]][v[i]], t[i])\n        d[v[i]][u[i]] = min(d[v[i]][u[i]], t[i])\n\n    for i1 in range(n):\n        for i0 in range(n):\n            for i2 in range(n):\n                d[i0][i2] = min(d[i0][i2], d[i0][i1] + d[i1][i2])\n    \n    for _ in range(q):\n        k = int(input())\n        a.clear()\n        for _ in range(k):\n            x = int(input())\n            a.append(x-1)\n        print(solve())\n\nif __name__ == '__main__':\n    main()\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(N\\) where all elements are between \\(1\\) and \\(2^K - 1\\), inclusive, is called a **good sequence**.\n\nThe **score** of a good sequence \\(A = (A_1, A_2, \\ldots, A_N)\\) is defined as follows:\n- The number of distinct integers that can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) using an integer \\(i\\) between \\(1\\) and \\(N\\), inclusive, and a non-negative integer \\(k\\).\n\nFor example, for \\(A = (3, 5)\\), five integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3,\\) and \\(5\\), so the score is \\(5\\).\n\nFind one good sequence with the maximum score.\n\nFor each input file, you are given \\(T\\) test cases to solve.\n\n### Constraints\n- \\(1 \\leq T \\leq 10^5\\)\n- \\(1 \\leq N \\leq 10^5\\)\n- \\(1 \\leq K \\leq 30\\)\n- The sum of \\(N\\) across the test cases in a single input file is at most \\(2 \\times 10^5\\).\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format. Here, \\(\\text{case}_i\\) denotes the \\(i\\)-th test case.\n\n```\nT\n\\text{case}_1\n\\text{case}_2\n\\vdots\n\\text{case}_T\n```\n\nEach test case is given in the following format:\n```\nN K\n```\n\n### Output\nPrint \\(T\\) lines.\n\nThe \\(i\\)-th line should contain the answer for \\(\\text{case}_i\\).\n\nIf there are multiple good sequences with the maximum score, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n3 3\n7 2\n8 20\n```\n\n### Sample Output 1\n```\n5 6 7\n2 2 3 3 1 3 3\n662933 967505 876482 840117 1035841 651549 543175 781219\n```\n\n**Explanation for the first test case:**\nFor \\(A = (5, 6, 7)\\), seven integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3, 5, 6,\\) and \\(7\\), so its score is \\(7\\). Outputs such as \\(A = (7, 4, 5)\\) and \\(A = (6, 5, 4)\\) would also be accepted.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nB - |{floor(A_i/2^k)}| Editorial by evima\n\nIn this explanation, we assume that indices start from \\(0\\). First, it is unnecessary to include elements less than \\(2^{K-1}\\) in \\(A\\). This is because replacing elements less than \\(2^{K-1}\\) with their double will result in the same or a higher score. Therefore, we can limit the elements of \\(A\\) to be between \\(2^{K-1}\\) and \\(2^K-1\\).\n\n1. When \\(N \\geq 2^{K-1}\\): We can include all elements between \\(2^{K-1}\\) and \\(2^K-1\\) in \\(A\\) and set \\(A_i = \\max(1, 2^K - 1 - i)\\) \\((0 \\le i < N)\\).\n\n2. When \\(N < 2^{K-1}\\): Consider an upper bound of the score. For \\(0 \\le x < K\\), consider the number of elements that appear as \\(\\displaystyle \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) between \\(2^x\\) and \\(2^{x+1}-1\\). For each \\(A_i\\), there is at most one \\(k\\) that satisfies \\(\\displaystyle 2^x \\le \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor < 2^{x+1}\\), so the number of such elements is at most \\(N\\). On the other hand, there are only \\(2^x\\) integers between \\(2^x\\) and \\(2^{x+1}\\), so the number of elements that appear in this range is at most \\(\\min(N, 2^x)\\). Therefore, by summing over all \\(x\\), the score has an upper bound of \\(\\displaystyle 1 + \\sum_{x=0}^{K-1}\\min(N, 2^x)\\).\n\nThis upper bound can always be achieved. Specifically, construct \\(A\\) as follows: Set \\(A_i\\) to the sum of \\(2^{K-1}\\) and the bit-reversal of \\(i\\). \u201cThe bit-reversal of \\(i\\)\u201d means the value obtained by reversing the \\((K-1)\\)-bit binary representation of \\(i\\).\n\nBy implementing the above, we can solve this problem. The time complexity is \\(O(NK)\\) due to the bit-reversal calculation being the bottleneck.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n\n    def bit_reversal(x):\n        return int(bin(x)[2:].zfill(K - 1)[::-1], 2)\n\n    if N >= 2 ** (K - 1):\n        print(*[max(1, 2**K - i - 1) for i in range(N)])\n    else:\n        print(*[2 ** (K - 1) + bit_reversal(i) for i in range(N)])\n```\n\nAdditionally, you can also solve it by constructing from the highest bit downwards.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n    C = [1]\n    for _ in range(1, K):\n        D = [2 * c for c in C] + [2 * c + 1 for c in C]\n        C = D[:N]\n    while len(C) < N:\n        C.append(1)\n    print(*C)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) strings. Each \\( i \\)-th string \\( S_i \\) (\\(1 \\leq i \\leq N\\)) is either \"Takahashi\" or \"Aoki\". Determine how many times \\( S_i \\) is equal to \"Takahashi\".\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( N \\) is an integer.\n- Each \\( S_i \\) is \"Takahashi\" or \"Aoki\". (\\(1 \\leq i \\leq N\\))\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\n**Output**\n\nPrint the count of \\( i \\) such that \\( S_i \\) is equal to \"Takahashi\" as an integer in a single line.\n\n**Sample Input 1**\n```\n3\nAoki\nTakahashi\nTakahashi\n```\n\n**Sample Output 1**\n```\n2\n```\n*S_2* and *S_3* are equal to \"Takahashi\", while *S_1* is not. Therefore, print 2.\n\n**Sample Input 2**\n```\n2\nAoki\nAoki\n```\n\n**Sample Output 2**\n```\n0\n```\nIt is possible that no \\( S_i \\) is equal to \"Takahashi\".\n\n**Sample Input 3**\n```\n20\nAoki\nTakahashi\nTakahashi\nAoki\nAoki\nAoki\nAoki\nTakahashi\nAoki\nAoki\nAoki\nTakahashi\nTakahashi\nAoki\nTakahashi\nAoki\nAoki\nAoki\nAoki\nTakahashi\n```\n\n**Sample Output 3**\n```\n7\n```\n\nSolution:\n\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nA - Count Takahashi Editorial\n\n1. A naive solution  \nDefine an integer variable `ans` for the integer, initializing it with `0`.  \nReceive `N` from the standard input.  \nRepeat the following operation `N` times:  \n\n- Receive a string from the standard input.  \n- If the received string equals \"Takahashi\", add `1` to `ans`.  \n\nPrint the value `ans`.  \n\nSample code in Python:\n```python\nans = 0\nN = int(input())\nfor _ in range(N):\n    S = input()\n    if S == 'Takahashi':\n        ans += 1\nprint(ans)\n```\n\n2. A little tricky solution  \nThe answer to this problem equals the number of occurrences of 'T' in the input.  \n\nSample code in Python:\n```python\nprint(open(0).read().count('T'))\n```\n\nSample code in Python (translated from Haskell):\n```python\nprint(len(list(filter(lambda x: x == 'T', open(0).read()))))\n```\n\nSample code in Bash translated to Python:\n```python\nimport sys\nprint(sum(1 for line in sys.stdin if 'T' in line))\n```\n \n\n", "problem_ids": ["abc369_e", "arc182_b", "abc359_a"]}, "abc326_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\nYou are given positive integers \\( N \\), \\( M \\), and \\( K \\), and a sequence of \\( M \\) non-negative integers \\( A = (A_0, A_1, \\ldots, A_{M-1}) \\). Here, \\( 2^{N-1} \\leq K < 2^N \\).\n\nIn the input, \\( K \\) is given as an \\( N \\)-digit number in binary notation, while the other integers are given in decimal notation.\n\nAdditionally, \\( A \\) is not given directly in the input. Instead, for each \\( i = 0, 1, \\ldots, M-1 \\), you are given a sequence of \\( L_i \\) integers \\( X_i = (X_{i,0}, X_{i,1}, \\ldots, X_{i,L_i-1}) \\) such that \\( A_i = \\sum_{j=0}^{L_i-1} 2^{X_{i,j}} \\). Here, \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\).\n\nFind the inversion number, modulo \\( 998244353 \\), of the sequence \\( B = (B_0, B_1, \\ldots, B_{MK-1}) \\) defined as follows:\n\n- For any integer \\( a \\) such that \\( 0 \\leq a < K \\) and any integer \\( b \\) such that \\( 0 \\leq b < M \\), the following holds:\n  - \\( B_{aM+b} \\) is equal to the remainder when \\( \\text{popcount}(a \\land A_b) \\) is divided by \\( 2 \\).\n\n**What is \\(\\operatorname{AND}\\)?**\nThe bitwise \\(\\operatorname{AND}\\) of integers \\( A \\) and \\( B \\), denoted as \\( A \\land B \\), is defined as follows:\n- In the binary representation of \\( A \\land B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) place is \\( 1 \\) if and only if the digits at the \\( 2^k \\) place in the binary representations of both \\( A \\) and \\( B \\) are \\( 1 \\); otherwise, it is \\( 0 \\).\n\nFor example, \\( 3 \\land 5 = 1 \\) (in binary: \\( 011 \\land 101 = 001 \\)).\n\nGenerally, the bitwise \\(\\operatorname{AND}\\) of \\( k \\) integers \\( p_1, p_2, p_3, \\ldots, p_k \\) is defined as \\(((\\ldots ((p_1 \\land p_2) \\land p_3) \\land \\ldots \\land p_k)\\), and it can be proved that this is independent of the order of \\( p_1, p_2, p_3, \\ldots, p_k \\).\n\n**What is \\(\\operatorname{popcount}\\)?**\nFor a non-negative integer \\( x \\), \\(\\operatorname{popcount}(x)\\) is the number of \\( 1 \\)s in the binary representation of \\( x \\). More precisely, for a non-negative integer \\( x \\) such that \\( x = \\sum_{i=0}^{\\infty} b_i 2^i \\) (\\( b_i \\in \\{0, 1\\} \\)), it holds that \\(\\operatorname{popcount}(x) = \\sum_{i=0}^{\\infty} b_i \\).\n\nFor example, \\( 13 \\) is \\( 1101 \\) in binary, so \\(\\operatorname{popcount}(13) = 3\\).\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2^{N-1} \\leq K < 2^N \\)\n- \\( 0 \\leq L_i \\leq N \\)\n- \\(\\sum L_i \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\)\n- All input values are integers.\n- \\( K \\) is given in binary notation.\n- All numbers except \\( K \\) are given in decimal notation.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M\nK\nL_0 X_{0,0} X_{0,1} \\cdots X_{0,L_0-1}\nL_1 X_{1,0} X_{1,1} \\cdots X_{1,L_1-1}\n\\vdots\nL_{M-1} X_{M-1,0} X_{M-1,1} \\cdots X_{M-1,L_{M-1}-1}\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n2 4\n11\n1 0\n2 0 1\n0\n1 1\n```\n\n**Sample Output 1**\n```\n9\n```\n\n**Explanation of Sample 1**\n\\( A = (1, 3, 0, 2) \\), \\( B = (0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1) \\).\n\n**Sample Input 2**\n```\n3 3\n101\n2 1 2\n2 0 1\n1 0\n```\n\n**Sample Output 2**\n```\n23\n```\n\n**Explanation of Sample 2**\n\\( A = (6, 3, 1) \\), \\( B = (0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0) \\).\n\n**Sample Input 3**\n```\n16 7\n1101010000100110\n11 0 1 2 3 7 10 11 12 13 14 15\n7 4 6 8 10 11 12 13\n6 0 1 6 8 10 12\n8 0 3 5 6 10 11 12 13\n10 0 1 2 3 4 5 6 8 12 13\n9 3 4 5 6 8 9 11 14 15\n8 0 4 7 9 10 11 13 14\n```\n\n**Sample Output 3**\n```\n97754354\n```\n\n**Sample Input 4**\n```\n92 4\n10101100101111111111011101111111101011001011111110011110111111101111111110100111100010111011\n23 1 2 5 13 14 20 28 32 34 39 52 56 59 60 62 64 67 69 71 78 84 87 91\n20 15 17 22 28 36 40 43 47 52 53 57 67 72 77 78 81 87 89 90 91\n23 7 8 9 10 11 13 16 19 22 23 30 33 42 49 51 52 58 64 71 73 76 79 83\n22 1 13 19 26 27 28 29 35 39 40 41 46 55 60 62 64 67 74 79 82 89 90\n```\n\n**Sample Output 4**\n```\n291412708\n```\n\nYou are required to find the number modulo \\( 998244353 \\).\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 178\n\nF - Long Sequence Inversion Editorial by evima\n\nThis explanation generally uses \\(0\\)-based indexing. For the inversion number of a binary sequence \\(Y = (Y_{0}, Y_{1}, \\dots, Y_{|Y|-1})\\), the following holds:\n\nIf there are \\(P\\) indices \\(i\\) where \\(Y_{i} = 0\\), and the sum of such indices is \\(Q\\), then the inversion number of \\(Y\\) is \\(Q - \\frac{P(P-1)}{2}\\).\n\nTherefore, we need to find the number of zeros in \\(B\\) and the sum of their indices. Here, we define a sequence of sequences \\(C = (C_{0}, C_{1}, \\dots, C_{M-1})\\) as follows:\n\n\\(C_{i} = (C_{i,0}, C_{i,1}, \\dots, C_{i,K-1})\\) is a sequence of length \\(K\\), where the \\(j\\)-th element \\(C_{i,j}\\) is equal to \\(\\operatorname{popcount}(j \\operatorname{AND} A_{i})\\).\n\nLet \\(P_{i}\\) be the number of \\(0\\)s in \\(C_{i}\\), and \\(Q_{i}\\) be the sum of indices where \\(C_{i}\\) is \\(0\\). The inversion number of \\(B\\) can be expressed as:\n\\[\n\\text{inversion}(B) = \\sum_{i=0}^{M-1}(Q_{i}M + iP_{i}) - \\frac{(\\sum P)(\\sum P - 1)}{2}\n\\]\nThus, if we know \\(P_{i}\\) and \\(Q_{i}\\) for each integer \\(i\\) from 0 to \\(M-1\\), we can determine the answer. To find \\(P_{i}\\) and \\(Q_{i}\\), we need the difference between the number of \\(0\\)s and \\(1\\)s in \\(C_{i}\\), and the difference between the sum of indices where \\(C_{i}\\) is \\(0\\) and where it is \\(1\\).\n\nHere, we find an integer sequence \\(Z\\) such that \\(K = \\sum 2^{Z_{j}}\\) and \\(0 \\leq Z_{0} < Z_{1} < \\cdots < Z_{L-1} = N-1\\). Using \\(Z\\), we decompose the interval \\([0, K)\\) and consider the contribution of each segment to \\(P_{i}\\) and \\(Q_{i}\\).\n\nFor the numbers of \\(0\\)s and \\(1\\)s in the contiguous subsequence \\((C_{i, K-2^{Z_{0}}}, C_{i, K-2^{Z_{0}+1}}, \\dots, C_{i, K-1})\\) in \\(C_{i}\\):\n- If \\((A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are equal to \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (K - 2^{Z_{0}}))\\).\n\nFor the sums of indices where \\(C_{i}\\) is \\(0\\) or \\(1\\):\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) \\geq 2\\), the difference is 0.\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are \\(0\\) or \\(1\\).\n\nThis gives us the contribution of the interval \\([K - 2^{Z_{0}}, K)\\) to \\(P_{i}\\) and \\(Q_{i}\\). We can similarly find the contributions of other intervals. By dividing the intervals appropriately and performing precomputations such as cumulative sums, we can compute \\(P_{i}\\) and \\(Q_{i}\\) in \\(O(L_{i})\\) time. The answer to this problem can be obtained in linear time relative to the input.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 300 points\n\n### Problem Statement\n\nPrint all integer sequences of length \\( N \\) that satisfy the following conditions, in ascending lexicographical order:\n\n1. The \\( i \\)-th element is between 1 and \\( R_i \\), inclusive.\n2. The sum of all elements is a multiple of \\( K \\).\n\nWhat is lexicographical order for sequences?\n\nA sequence \\( A = (A_1, \\ldots, A_{|A|}) \\) is lexicographically smaller than \\( B = (B_1, \\ldots, B_{|B|}) \\) if either 1. or 2. below holds:\n\n1. \\( |A| < |B| \\) and \\( (A_{1}, \\ldots, A_{|A|}) = (B_1, \\ldots, B_{|A|}) \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|A|,|B|\\} \\) such that both of the following are true:\n   - \\( (A_{1}, \\ldots, A_{i-1}) = (B_1, \\ldots, B_{i-1}) \\)\n   - \\( A_i < B_i \\)\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 8 \\)\n- \\( 2 \\le K \\le 10 \\)\n- \\( 1 \\le R_i \\le 5 \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nR_1 R_2 \\dots R_N\n```\n\n### Output\n\nPrint the answer in the following format, where \\( X \\) is the number of sequences to print, the \\( i \\)-th of which is \\( A_i = (A_{i,1}, A_{i,2}, \\dots, A_{i,N}) \\):\n\n```\nA_{1,1} A_{1,2} \\dots A_{1,N}\nA_{2,1} A_{2,2} \\dots A_{2,N}\n\u22ee\nA_{X,1} A_{X,2} \\dots A_{X,N}\n```\n\n### Sample Input 1\n\n```\n3 2\n2 1 3\n```\n\n### Sample Output 1\n\n```\n1 1 2\n2 1 1\n2 1 3\n```\n\nThere are three sequences to be printed, which are (1, 1, 2), (2, 1, 1), (2, 1, 3) in lexicographical order.\n\n### Sample Input 2\n\n```\n1 2\n1\n```\n\n### Sample Output 2\n\n```\n```\n\nThere may be no sequences to print. In this case, the output can be empty.\n\n### Sample Input 3\n\n```\n5 5\n2 3 2 3 2\n```\n\n### Sample Output 3\n\n```\n1 1 1 1 1\n1 2 2 3 2\n1 3 1 3 2\n1 3 2 2 2\n1 3 2 3 1\n2 1 2 3 2\n2 2 1 3 2\n2 2 2 2 2\n2 2 2 3 1\n2 3 1 2 2\n2 3 1 3 1\n2 3 2 1 2\n2 3 2 2 1\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 367\n\nC - Enumerate Sequences Editorial\n\nThere are \\(5^8=390625\\) sequences of length \\(8\\) consisting of integers between \\(1\\) and \\(5\\). Since the number of sequences to print is always not more than this count, we do not have to worry about too much output.\n\n**Approach 1: Use recursion to enumerate**  \n1. Fix the first element in ascending order.  \n2. Once the first element is fixed, call the recursion to fix the second element in ascending order.  \n3. Once all the elements are ready, check if the total sum is a multiple of \\(K\\) and print it.  \n\nImplementing this recursion will be accepted.\n\nSample code (Python3):\n```python\ndef solve(lv, n, k, r, seq):\n    if lv == n:\n        s = sum(seq[:n])\n        if s % k == 0:\n            print(\" \".join(map(str, seq[:n])))\n        return\n    \n    for i in range(1, r[lv] + 1):\n        seq[lv] = i\n        solve(lv + 1, n, k, r, seq)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    r = list(map(int, data[2:2 + n]))\n    seq = [0] * 8\n    solve(0, n, k, r, seq)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Approach 2: Decode integers corresponding to sequences**  \nIgnoring the condition \u201cmultiple of \\(K\\),\u201d there are \\(P=R_1 \\times R_2 \\times \\dots \\times R_N\\) possible sequences. If you decode an integer between \\(0\\) and \\(P-1\\), the results are sorted in ascending order.\n\nLet \\(S\\) be the decode result. Prepare a variable \\(x \\leftarrow t\\). For \\(i = N\\) down to \\(1\\), do the following:\n1. Let \\(S_i \\leftarrow (x \\% R_i)+1\\). Then, replace \\(x\\) with \\(\\displaystyle \\frac{x}{R_i}\\) (rounded down).\n\nIntuitively, a sequence corresponds to a special \\(N\\)-ary representation.\n\nSample code (Python3):\n```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    k = int(data[1])\n    r = list(map(int, data[2:2 + n]))\n\n    tot = 1\n    for i in range(n):\n        tot *= r[i]\n\n    for t in range(tot):\n        x = t\n        s = 0\n        seq = [0] * n\n        for i in range(n - 1, -1, -1):\n            seq[i] = (x % r[i]) + 1\n            s += seq[i]\n            x //= r[i]\n        \n        if s % k == 0:\n            print(\" \".join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) people participating in an event, and the transportation cost for the \\( i \\)-th person is \\( A_i \\) yen. Takahashi, the organizer of the event, decided to set a maximum limit \\( x \\) for the transportation subsidy. The subsidy for person \\( i \\) will be \\( \\min(x, A_i) \\) yen. Here, \\( x \\) must be a non-negative integer.\n\nGiven that Takahashi's budget is \\( M \\) yen, and he wants the total transportation subsidy for all \\( N \\) people to be at most \\( M \\) yen, what is the maximum possible value of the subsidy limit \\( x \\)?\n\nIf the subsidy limit can be made infinitely large, report that instead.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^{14} \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_{N}\n```\n\n**Output:**\n\nPrint the maximum value of the subsidy limit \\( x \\) that satisfies the budget condition, as an integer.\n\nIf the subsidy limit can be made infinitely large, print `infinite` instead.\n\n**Sample Input 1:**\n```\n4 8\n1 3 2 4\n```\n\n**Sample Output 1:**\n```\n2\n```\n\n*Explanation:*\n\nIf the subsidy limit is set to 2 yen, the total transportation subsidy for all \\( N \\) people is \\( \\min(2,1) + \\min(2,3) + \\min(2,2) + \\min(2,4) = 7 \\) yen, which is within the budget of 8 yen.\n\nIf the subsidy limit is set to 3 yen, the total transportation subsidy for all \\( N \\) people is \\( \\min(3,1) + \\min(3,3) + \\min(3,2) + \\min(3,4) = 9 \\) yen, which exceeds the budget of 8 yen. Therefore, the maximum possible value of the subsidy limit is 2 yen.\n\n**Sample Input 2:**\n```\n3 20\n5 3 2\n```\n\n**Sample Output 2:**\n```\ninfinite\n```\n\n*Explanation:*\n\nThe subsidy limit can be made infinitely large.\n\n**Sample Input 3:**\n```\n10 23\n2 5 6 5 2 1 7 9 7 2\n```\n\n**Sample Output 3:**\n```\n2\n```\n\nSolution:\n\n```\nToyota Programming Contest 2024#8 (AtCoder Beginner Contest 365) Editorial\n\nC - Transportation Expenses Editorial\n\nFirst, we consider when the answer is infinite. It is infinite when the total sum of \\(A\\) is not greater than \\(M\\), as the total cost required is never greater than \\(M\\). Conversely, if the total sum is greater than \\(M\\), setting the upper bound to the maximum value of \\(A\\) leads to exceeding the budget, so a maximum value exists.\n\nAssuming the answer is not infinite, a technique called binary search is effective for finding the maximum value subject to some condition. Given an upper bound \\(x\\), it can be determined if the total cost exceeds the budget in \\(O(N)\\) time. The number of iterations in the binary search is \\(O(\\log{\\max{A}})\\) because the upper bound of the answer is \\(\\max{A}\\). Therefore, the problem can be solved in \\(O(N\\log{\\max{A}})\\) time.\n```\n \n\n", "problem_ids": ["arc178_f", "abc367_c", "abc365_c"]}, "abc326_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a grid with \\( H \\) rows and \\( W \\) columns. Let \\( (i, j) \\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Initially, there is one wall in each cell. After processing \\( Q \\) queries as explained below, determine the number of remaining walls.\n\nIn the \\( q \\)-th query, you are given two integers \\( R_q \\) and \\( C_q \\). A bomb is placed at \\( (R_q, C_q) \\) to destroy walls. The following process occurs:\n\n- If there is a wall at \\( (R_q, C_q) \\), destroy that wall and end the process.\n- If there is no wall at \\( (R_q, C_q) \\), destroy the first walls that appear when looking up, down, left, and right from \\( (R_q, C_q) \\). Specifically, the following four processes occur simultaneously:\n  - If there exists an \\( i < R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( i < k < R_q \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists an \\( i > R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( R_q < k < i \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists a \\( j < C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( j < k < C_q \\), destroy the wall at \\( (R_q, j) \\).\n  - If there exists a \\( j > C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( C_q < k < j \\), destroy the wall at \\( (R_q, j) \\).\n\n**Constraints:**\n\n- \\( 1 \\leq H, W \\)\n- \\( H \\times W \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq R_q \\leq H \\)\n- \\( 1 \\leq C_q \\leq W \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nH W Q\nR_1 C_1\nR_2 C_2\n...\nR_Q C_Q\n```\n\n**Output:**\n\nPrint the number of remaining walls after processing all queries.\n\n**Sample Input 1:**\n\n```\n2 4 3\n1 2\n1 2\n1 3\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- In the 1st query, \\( (R_1, C_1) = (1, 2) \\). There is a wall at \\( (1, 2) \\), so it is destroyed.\n- In the 2nd query, \\( (R_2, C_2) = (1, 2) \\). No wall at \\( (1, 2) \\), so destroy the nearest walls at \\( (2,2) \\), \\( (1,1) \\), and \\( (1,3) \\).\n- In the 3rd query, \\( (R_3, C_3) = (1, 3) \\). No wall at \\( (1, 3) \\), so destroy the nearest walls at \\( (2,3) \\) and \\( (1,4) \\).\n\nAfter all queries, two walls remain, at \\( (2, 1) \\) and \\( (2, 4) \\).\n\nSolution:\n\n        Here is a cleaned version of the text focusing on the solution:\n\n---\n\nTo solve the problem efficiently, manage the remaining walls using data structures. Use two ordered sets (such as `std::set` in C++):\n\n1. `g1`: An array where each element is an ordered set maintaining column indices of the remaining walls in each row.\n2. `g2`: An array where each element is an ordered set maintaining row indices of the remaining walls in each column.\n\nBy utilizing binary search in these ordered sets (using `set::lower_bound`), each query can be processed in \\(\\mathrm{O}(\\log H + \\log W)\\) time. The overall time complexity for solving the problem is \\(\\mathrm{O}((HW + Q)(\\log H + \\log W))\\).\n\nSample Python3 code demonstrates this approach:\n\n```python\nimport sys\nfrom sortedcontainers import SortedSet\n\ninput = sys.stdin.read\ndata = input().split()\n\nH = int(data[0])\nW = int(data[1])\nQ = int(data[2])\nindex = 3\n\ng1 = [SortedSet() for _ in range(H)]\ng2 = [SortedSet() for _ in range(W)]\n\nfor i in range(H):\n    for j in range(W):\n        g1[i].add(j)\n        g2[j].add(i)\n\ndef erase(i, j):\n    g1[i].discard(j)\n    g2[j].discard(i)\n\nfor _ in range(Q):\n    R = int(data[index]) - 1\n    C = int(data[index + 1]) - 1\n    index += 2\n\n    if C in g1[R]:\n        erase(R, C)\n        continue\n\n    # up\n    it = g2[C].bisect_left(R)\n    if it > 0:\n        erase(g2[C][it - 1], C)\n    # down\n    if it < len(g2[C]):\n        erase(g2[C][it], C)\n    # left\n    it = g1[R].bisect_left(C)\n    if it > 0:\n        erase(R, g1[R][it - 1])\n    # right\n    if it < len(g1[R]):\n        erase(R, g1[R][it])\n\nans = sum(len(row) for row in g1)\nprint(ans)\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi has prepared \\(N\\) dishes for Snuke. The dishes are numbered from 1 to \\(N\\), and dish \\(i\\) has a sweetness of \\(A_i\\) and a saltiness of \\(B_i\\).\n\nTakahashi can arrange these dishes in any order he likes. Snuke will eat the dishes in the order they are arranged, but if at any point the total sweetness of the dishes he has eaten so far exceeds \\(X\\) or the total saltiness exceeds \\(Y\\), he will not eat any further dishes.\n\nTakahashi wants Snuke to eat as many dishes as possible. Find the maximum number of dishes Snuke will eat if Takahashi arranges the dishes optimally.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 80\\)\n- \\(1 \\leq A_i, B_i \\leq 10000\\)\n- \\(1 \\leq X, Y \\leq 10000\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN X Y\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\n```\n\n**Output:**\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 8 4\n1 5\n3 2\n4 1\n5 3\n```\n\n**Sample Output 1:**\n```\n3\n```\n\n*Explanation:*\nConsider the scenario where Takahashi arranges the dishes in the order 2, 3, 1, 4.\n- First, Snuke eats dish 2. The total sweetness so far is 3, and the total saltiness is 2.\n- Next, Snuke eats dish 3. The total sweetness so far is 7, and the total saltiness is 3.\n- Next, Snuke eats dish 1. The total sweetness so far is 8, and the total saltiness is 8.\n- The total saltiness has exceeded \\(Y=4\\), so Snuke will not eat any further dishes.\n\nThus, in this arrangement, Snuke will eat three dishes. No matter how Takahashi arranges the dishes, Snuke will not eat all four dishes, so the answer is 3.\n\n**Sample Input 2:**\n```\n2 1 1\n3 2\n3 2\n```\n\n**Sample Output 2:**\n```\n1\n```\n\n**Sample Input 3:**\n```\n2 100 100\n3 2\n3 2\n```\n\n**Sample Output 3:**\n```\n2\n```\n\n**Sample Input 4:**\n```\n6 364 463\n230 381\n154 200\n328 407\n339 94\n193 10\n115 309\n```\n\n**Sample Output 4:**\n```\n3\n```\n\nSolution:\n\n```python\nEditorial - Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nE - Maximum Glutton Editorial by en_translator\n\nNotice that the total sweetness and saltiness of all but last dishes that he eats do not exceed \\(X\\) and \\(Y\\), respectively. Let \\(x\\) be the maximum size of a set of dishes \\(S\\) such that the total sweetness does not exceed \\(X\\) and the total saltiness does not exceed \\(Y\\). Then, the answer to the original problem can be represented as \\(\\min(x+1, N)\\). If \\(x<N\\), he can eat at least \\((x+1)\\) dishes by eating those in \\(S\\) first. Thus, he can eat at most \\((x+1)\\) dishes.\n\nTo find the maximum number of dishes that can be chosen such that the total sweetness and saltiness do not exceed \\(X\\) and \\(Y\\), respectively, define a Dynamic Programming (DP) table:\n\n\\(dp_{i,j,k}\\) = (the minimum total saltiness when choosing exactly \\(k\\) dishes from dishes \\(1,2,\\dots,i\\) so that the total sweetness is exactly \\(j\\)).\n\nThis fills the DP table in \\(O(N^2X)\\) time. Find the maximum \\(k\\) such that there exists \\(j\\) with \\(dp'_{N,j,k} \\leq Y\\).\n\nSample code (Python3):\n```python\ndef chmin(a, b):\n    return min(a, b)\n\ndef main():\n    n, x, y = map(int, input().split())\n    a = []\n    b = []\n    for _ in range(n):\n        ai, bi = map(int, input().split())\n        a.append(ai)\n        b.append(bi)\n    \n    dp = [[[float('inf')] * (x + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 0\n    \n    for i in range(n):\n        for j in range(i + 1):\n            for k in range(x + 1):\n                dp[i + 1][j][k] = chmin(dp[i + 1][j][k], dp[i][j][k])\n                if k + a[i] <= x:\n                    dp[i + 1][j + 1][k + a[i]] = chmin(dp[i + 1][j + 1][k + a[i]], dp[i][j][k] + b[i])\n    \n    for i in range(n, -1, -1):\n        for j in range(x + 1):\n            if dp[n][i][j] <= y:\n                print(min(i + 1, n))\n                return\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land is represented by a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i, j)\\) denote the cell at the \\(i\\)-th row and \\(j\\)-th column.\n\nTakahashi starts at cell \\((S_i, S_j)\\) and repeats the following action \\(K\\) times:\n- He either stays in the current cell or moves to an adjacent cell. After this action, if he is in cell \\((i, j)\\), he gains a fun value of \\(A_{i, j}\\).\n\nFind the maximum total fun value he can gain.\n\nHere, a cell \\((x', y')\\) is considered adjacent to cell \\((x, y)\\) if and only if \\(|x - x'| + |y - y'| = 1\\).\n\n**Constraints**\n\n- \\(1 \\leq H, W \\leq 50\\)\n- \\(1 \\leq K \\leq 10^9\\)\n- \\(1 \\leq S_i \\leq H\\)\n- \\(1 \\leq S_j \\leq W\\)\n- \\(1 \\leq A_{i, j} \\leq 10^9\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nH W K\nS_i S_j\nA_{1, 1} A_{1, 2} \\ldots A_{1, W}\nA_{2, 1} A_{2, 2} \\ldots A_{2, W}\n\\vdots\nA_{H, 1} A_{H, 2} \\ldots A_{H, W}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 3 3\n1 2\n2 1 2\n3 4 5\n```\n\n**Sample Output 1**\n\n```\n14\n```\n\nTakahashi can gain a total fun value of 14 by acting as follows:\n- Initially, he is at \\((1, 2)\\).\n- He moves to cell \\((2, 2)\\). Then, he gains a fun value of \\(A_{2, 2} = 4\\).\n- He moves to cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n- He stays in cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n\nHe cannot gain a total fun value greater than 14, so print 14.\n\n**Sample Input 2**\n\n```\n2 2 1000000000\n2 1\n100 100\n100 99\n```\n\n**Sample Output 2**\n\n```\n100000000000\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        In an optimal solution, one can assume that Takahashi stays at a cell with the maximum \\(A_{i,j}\\) among those he passes through. This means he can keep staying there indefinitely. Let \\((G_i, G_j)\\) be the final cell. We assume he travels from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) and then stays there zero or more times. In the travel, he never passes through the same cell twice because if he does, he can improve the score by staying more times at \\((G_i, G_j)\\). Paths from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) have a length not greater than \\(HW\\), allowing for a straightforward DP (Dynamic Programming) approach. Specifically, evaluate \\(dp_{i,j,k}\\) as the maximum total fun value after making \\(i\\) moves to end up at \\((j,k)\\). The answer is \\(\\max ((K - i) A_{j,k} + dp_{i,j,k})\\). The DP runs in \\(O((HW)^2)\\) time. Consider cases where \\(K \\leq HW\\).\n        [END TEXT]\n \n\n", "problem_ids": ["abc370_d", "abc364_e", "abc358_g"]}, "abc326_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 450 points\n\n## Problem Statement\n\nThere are \\( N \\) islands and \\( M \\) bidirectional bridges connecting two islands. The islands and bridges are numbered \\( 1, 2, \\ldots, N \\) and \\( 1, 2, \\ldots, M \\), respectively. Bridge \\( i \\) connects islands \\( U_i \\) and \\( V_i \\), and the time it takes to cross it in either direction is \\( T_i \\). No bridge connects an island to itself, but it is possible for two islands to be directly connected by more than one bridge. One can travel between any two islands using some bridges.\n\nYou are given \\( Q \\) queries, so answer each of them. The \\( i \\)-th query is as follows:\n\n- You are given \\( K_i \\) distinct bridges: bridges \\( B_{i,1}, B_{i,2}, \\ldots, B_{i,K_i} \\).\n- Find the minimum time required to travel from island \\( 1 \\) to island \\( N \\) using each of these bridges at least once.\n- Only consider the time spent crossing bridges.\n- You can cross the given bridges in any order and in any direction.\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 400 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq T_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 3000 \\)\n- \\( 1 \\leq K_i \\leq 5 \\)\n- \\( 1 \\leq B_{i,1} < B_{i,2} < \\cdots < B_{i,K_i} \\leq M \\)\n- All input values are integers.\n- It is possible to travel between any two islands using some bridges.\n\n## Input\n\nThe input is given in the following format:\n```\nN M\nU_1 V_1 T_1\nU_2 V_2 T_2\n\u22ee\nU_M V_M T_M\nQ\nK_1\nB_{1,1} B_{1,2} \u22ef B_{1,{K_1}}\nK_2\nB_{2,1} B_{2,2} \u22ef B_{2,{K_2}}\n\u22ee\nK_Q\nB_{Q,1} B_{Q,2} \u22ef B_{Q,{K_Q}}\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq Q \\)) should contain the answer to the \\( i \\)-th query as an integer.\n\n## Sample Input 1\n\n```\n3 5\n1 2 10\n1 3 20\n1 3 30\n2 3 15\n2 3 25\n2\n1\n1\n2\n3 5\n```\n\n## Sample Output 1\n\n```\n25\n70\n```\n\nExplanation:\n- For the first query, the minimum time to travel from island 1 to island 3 using bridge 1 is achieved by using bridge 1 to move from island 1 to island 2, then bridge 4 to move from island 2 to island 3. The time taken is 10 + 15 = 25.\n- For the second query, the minimum time to travel from island 1 to island 3 using both bridges 3 and 5 is achieved by using bridge 3 to move from island 1 to island 3, then using bridge 5 to move to island 2, and finally bridge 4 to return to island 3. The time taken is 30 + 25 + 15 = 70.\n\n## Sample Input 2\n\n```\n6 6\n1 5 1\n2 5 1\n2 4 1\n3 4 1\n3 6 1\n1 6 1\n2\n5\n1 2 3 4 5\n1\n5\n```\n\n## Sample Output 2\n\n```\n5\n3\n```\n\nRemarks: You can cross the specified bridges in either direction.\n\n## Sample Input 3\n\n```\n5 5\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4 5 1000000000\n1 5 1000000000\n1\n1\n3\n```\n\n## Sample Output 3\n\n```\n4000000000\n```\n\nNote: The answer may not fit in a 32-bit integer.\n\nSolution:\n\n```python\nimport itertools\n\nN = 400\nM = int(2e5)\nINF = int(1e15)\n\nn = 0\nu = [0] * M\nv = [0] * M\nt = [0] * M\nd = [[0 if i == j else INF for j in range(N)] for i in range(N)]\nk = 0\na = []\n\ndef solve():\n    ans = INF\n    dp = [[0] * 2 for _ in range(5)]\n    b = list(range(k))\n    for perm in itertools.permutations(b):\n        dp[0][0] = d[0][v[a[perm[0]]]] + t[a[perm[0]]]\n        dp[0][1] = d[0][u[a[perm[0]]]] + t[a[perm[0]]]\n        for i in range(k - 1):\n            dp[i + 1][0] = min(dp[i][0] + d[u[a[perm[i]]]][v[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][v[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n            dp[i + 1][1] = min(dp[i][0] + d[u[a[perm[i]]]][u[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][u[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n        ans = min(ans, dp[k-1][0] + d[u[a[perm[k-1]]]][n-1])\n        ans = min(ans, dp[k-1][1] + d[v[a[perm[k-1]]]][n-1])\n    return ans\n\ndef main():\n    global n, k\n    m, q = map(int, input().split())\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d[i][j] = INF\n\n    for i in range(m):\n        u[i], v[i], t[i] = map(int, input().split())\n        u[i] -= 1\n        v[i] -= 1\n        d[u[i]][v[i]] = min(d[u[i]][v[i]], t[i])\n        d[v[i]][u[i]] = min(d[v[i]][u[i]], t[i])\n\n    for i1 in range(n):\n        for i0 in range(n):\n            for i2 in range(n):\n                d[i0][i2] = min(d[i0][i2], d[i0][i1] + d[i1][i2])\n    \n    for _ in range(q):\n        k = int(input())\n        a.clear()\n        for _ in range(k):\n            x = int(input())\n            a.append(x-1)\n        print(solve())\n\nif __name__ == '__main__':\n    main()\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are trying to implement collision detection in a 3D game.\n\nIn a 3-dimensional space, let \\( C(a,b,c,d,e,f) \\) denote the cuboid with a diagonal connecting \\((a,b,c)\\) and \\((d,e,f)\\), with all faces parallel to the xy-plane, yz-plane, or zx-plane. This definition uniquely determines \\( C(a,b,c,d,e,f) \\).\n\nGiven two cuboids \\( C(a,b,c,d,e,f) \\) and \\( C(g,h,i,j,k,l) \\), determine whether their intersection has a positive volume.\n\n**Constraints**\n\n- \\( 0 \\leq a < d \\leq 1000 \\)\n- \\( 0 \\leq b < e \\leq 1000 \\)\n- \\( 0 \\leq c < f \\leq 1000 \\)\n- \\( 0 \\leq g < j \\leq 1000 \\)\n- \\( 0 \\leq h < k \\leq 1000 \\)\n- \\( 0 \\leq i < l \\leq 1000 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from standard input in the following format:\n\n```\na b c d e f\ng h i j k l\n```\n\n**Output**\n\nPrint `Yes` if the intersection of the two cuboids has a positive volume, and `No` otherwise.\n\n**Sample Input 1**\n```\n0 0 0 4 5 6\n2 3 4 5 6 7\n```\n\n**Sample Output 1**\n```\nYes\n```\nThe positional relationship of the two cuboids is shown in the figure below, and their intersection has a volume of 8.\n\n**Sample Input 2**\n\n```\n0 0 0 2 2 2\n0 0 2 2 2 4\n```\n\n**Sample Output 2**\n```\nNo\n```\nThe two cuboids touch at a face, where the volume of the intersection is 0.\n\n**Sample Input 3**\n```\n0 0 0 1000 1000 1000\n10 10 10 100 100 100\n```\n\n**Sample Output 3**\n```\nYes\n```\n\nSolution:\n\n```\nHere is a cleaned version of the editorial:\n\nOfficial Editorial: B - Intersection of Cuboids\n\nLet \\([x,y]\\) denote the segment formed by all real numbers between \\(x\\) and \\(y\\), inclusive. \n\n**Problem:** Determine if two segments \\([a,b]\\) and \\([c,d]\\) have an intersection of a positive length. The length of intersection is \\(0\\) for one of the following cases:\n\n- \\([a,b]\\) is to the left of \\([c,d]\\).\n- \\([a,b]\\) is to the right of \\([c,d]\\).\n\nIn Pythonic pseudocode:\n```python\nif b <= c or d <= a:\n    print(\"0 intersection\")\nelse:\n    print(\"positive intersection\")\n```\n\nFor a three-dimensional problem, solve the one-dimensional problem for the three coordinates \\(x\\), \\(y\\), and \\(z\\). If the length of intersection for all coordinates is positive, the intersection of the cuboids has a positive volume; otherwise, it is \\(0\\). \n\nPython code:\n```python\nx1, y1, z1, x2, y2, z2 = map(int, input().split())\nx3, y3, z3, x4, y4, z4 = map(int, input().split())\n\ndef f(l1, r1, l2, r2):\n    # Returns True if the intersection of [l1, r1] and [l2, r2] has a positive length\n    return not (r1 <= l2 or r2 <= l1)\n\nif f(x1, x2, x3, x4) and f(y1, y2, y3, y4) and f(z1, z2, z3, z4):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) giants, each identified by an integer from 1 to \\( N \\). For each giant \\( i \\), when they stand on the ground, their shoulder height is \\( A_i \\) and their head height is \\( B_i \\).\n\nYou can arrange all the giants in a permutation \\( (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) and stack them one on top of another according to the following rules:\n\n1. Place giant \\( P_1 \\) on the ground. The shoulder height of giant \\( P_1 \\) from the ground is \\( A_{P_1} \\), and the head height is \\( B_{P_1} \\).\n2. Following this, for \\( i = 1, 2, \\ldots, N - 1 \\), place giant \\( P_{i+1} \\) on the shoulders of giant \\( P_i \\). If the shoulder height of giant \\( P_i \\) from the ground is \\( t \\), then the shoulder height of giant \\( P_{i+1} \\) from the ground is \\( t + A_{P_{i+1}} \\), and the head height is \\( t + B_{P_{i+1}} \\).\n\nThe goal is to determine the maximum possible head height from the ground of the topmost giant \\( P_N \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 200,000 \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq 1,000,000,000 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output:**\n\nPrint the maximum possible height of the head of the topmost giant from the ground.\n\n**Sample Input 1:**\n```\n3\n4 10\n5 8\n2 9\n```\n\n**Sample Output 1:**\n```\n18\n```\n\n*Explanation:* If the permutation \\( (P_1, P_2, P_3) = (2, 1, 3) \\) is chosen, the heights measured from the ground would be as follows:\n\n- Giant 2 will have a shoulder height of 5 and a head height of 8.\n- Giant 1 will be on top, having a shoulder height of 9 and a head height of 15.\n- Giant 3 will be on top, having a shoulder height of 11 and a head height of 18.\n\nThe maximum head height achievable with any arrangement of the giants is 18, and thus, 18 is printed.\n\n**Sample Input 2:**\n```\n5\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\n**Sample Output 2:**\n```\n5\n```\n\n**Sample Input 3:**\n```\n10\n690830957 868532399\n741145463 930111470\n612846445 948344128\n540375785 925723427\n723092548 925021315\n928915367 973970164\n563314352 832796216\n562681294 868338948\n923012648 954764623\n691107436 891127278\n```\n\n**Sample Output 3:**\n```\n7362669937\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\nThe height of the topmost giant\u2019s head when \\(P_N\\), i.e., when giant \\(i\\) is the topmost giant, is \\(B_i + \\sum_{j \\neq i}A_j\\). This can be expressed as \\(B_i - A_i + \\sum_{j = 1}^{N} A_j\\), and the answer is the maximum of this value for \\(i = 1, 2, \\ldots, N\\). Since \\(\\sum_{j = 1}^{N} A_j\\) is independent of \\(i\\), it is sufficient to find \\(\\max (B_i - A_i)\\). This can be computed using a for loop in a total of \\(O(N)\\) time.\n\nSample code:\n```python\nn = int(input())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nm = 0\nfor i in range(n):\n    m = max(m, b[i] - a[i])\nans = m + sum(a)\nprint(ans)\n```\n \n\n", "problem_ids": ["abc369_e", "abc361_b", "abc352_c"]}, "abc326_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a positive integer \\( N \\), and an integer \\( A_{x,y,z} \\) for each triple of integers \\( (x, y, z) \\) such that \\( 1 \\leq x, y, z \\leq N \\).\n\nYou will be given \\( Q \\) queries in the following format, which must be processed in order.\n\nFor the \\( i \\)-th query \\( (1 \\leq i \\leq Q) \\), you are given a tuple of integers \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\) such that \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\), \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\), and \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\). Find:\n\n\\[\n\\displaystyle{\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}}\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 0 \\leq A_{x,y,z} \\leq 999 \\) where \\( 1 \\leq x, y, z \\leq N \\)\n- \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n- The integer \\( N \\)\n- An \\( N \\times N \\times N \\) array \\( A \\) of integers, given in the order \\( A_{1,1,1}, A_{1,1,2}, \\ldots \\), i.e., iterating through \\( x \\), then \\( y \\), then \\( z \\).\n- The integer \\( Q \\)\n- \\( Q \\) lines, each containing six integers representing \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\)\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n\n```\n2\n1 2\n3 4\n5 6\n7 8\n2\n1 2 2 2 1 1\n2 2 1 2 1 2\n```\n\n**Sample Output 1:**\n\n```\n10\n26\n```\n\n**Explanation:**\n\nFor the 1st query, the sought value is \\( A_{1,2,1} + A_{2,2,1} = 3 + 7 = 10 \\). Thus, print 10.\n\nFor the 2nd query, the sought value is \\( A_{2,1,1} + A_{2,1,2} + A_{2,2,1} + A_{2,2,2} = 5 + 6 + 7 + 8 = 26 \\). Thus, print 26.\n\n**Sample Input 2:**\n\n```\n3\n733 857 714\n956 208 257\n123 719 648\n840 881 245\n245 112 746\n306 942 694\n58 870 849\n13 208 789\n687 906 783\n8\n3 3 3 3 1 1\n1 3 2 3 3 3\n2 2 2 3 1 1\n1 3 1 1 1 1\n2 3 2 3 2 3\n1 2 1 1 1 2\n3 3 2 2 1 3\n1 2 2 3 2 3\n```\n\n**Sample Output 2:**\n\n```\n687\n3917\n551\n1631\n5180\n3311\n1010\n4326\n```\n\nSolution:\n\n```plaintext\nD - Cuboid Sum Query Editorial\n\nThis problem is an exercise of cumulative sums. We assume the knowledge of cumulative sums for a sequence (one-dimensional cumulative sums).\n\nGiven a length-\\(N\\) sequence \\(A\\), process \\(Q\\) queries. In the \\(i\\)-th query, given an integer pair \\((L_i,R_i)\\) satisfying \\(1 \\leq L_i \\leq R_i \\leq N\\), find \\(\\sum_{k=L_i}^{R_i}A_k\\).\n\nA solution to this problem is as follows: Define a length-\\((N+1)\\) sequence \\(S=(S_0,S_1,\\ldots S_N)\\) by \\(S_0=0,S_i=\\sum_{k=1}^{i-1}A_k\\), and use \\(\\sum_{k=L_i}^{R_i}A_k=S_{R_i+1}-S_{L_i}\\) to answer the query fast. The sequence \\(S\\) is called the cumulative sums of \\(A\\).\n\nThe original problem is an extension of this one-dimensional cumulative sum problem into three dimensions.\n\nConsider \\(S\\) such that \\(S_{i,j,k}=\\sum_{x=1}^{i-1} \\sum_{y=1}^{j-1}\\sum_{z=1}^{k-1}A_{x,y,z}\\) for \\(1 \\leq i,j,k \\leq N+1\\). If \\(i\\), \\(j\\), or \\(k\\) is \\(0\\), define \\(S_{i,j,k}=0\\).\n\nIt holds that \\(\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}=S_{Rx_i+1,Ry_i+1,Rz_i+1}-S_{Lx_i,Rx_i+1,Rz_i+1}-S_{Rx_i+1,Ly_i,Rz_i+1}-S_{Rx_i+1,Ry_i+1,Lz_i}+S_{Lx_i,Ly_i,Rz_i+1}+S_{Lx_i,Ry_i+1,Lz_i}+S_{Rx_i+1,Ly_i,Lz_i}-S_{Lx_i,Ly_i,Lz_i}\\).\n\nTherefore, if one can compute \\(S\\) fast, then each query can be answered in constant time.\n\n\\(S\\) can be found by the property that \\(S_{i,j,k}=S_{i-1,j,k}+S_{i,j-1,k}+S_{i,j,k-1}-S_{i-1,j-1,k}-S_{i-1,j,k-1}-S_{i,j-1,k-1}+S_{i-1,j-1,k-1}+A_{i-1,j-1,k-1}\\). The time complexity is \\(O(N^3+Q)\\).\n\nSample code (Python):\n```python\nn = int(input())\n\na = [[[0] * n for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        a[i][j]=list(map(int,input().split()))\n\nsum = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            sum[i + 1][j + 1][k + 1] = (sum[i][j+1][k+1]\n                                        + sum[i+1][j][k+1]\n                                        + sum[i+1][j+1][k]\n                                        - sum[i][j][k+1]\n                                        - sum[i][j+1][k]\n                                        - sum[i+1][j][k]\n                                        + sum[i][j][k]\n                                        + a[i][j][k])\n\nq = int(input())\nfor _ in range(q):\n    lx, rx, ly, ry, lz, rz = map(int, input().split())\n    lx -= 1\n    ly -= 1\n    lz -= 1\n\n    result = (sum[rx][ry][rz]\n                - sum[lx][ry][rz]\n                - sum[rx][ly][rz]\n                - sum[rx][ry][lz]\n                + sum[lx][ly][rz]\n                + sum[lx][ry][lz]\n                + sum[rx][ly][lz]\n                - sum[lx][ly][lz])\n    print(result)\n```\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n---\n\n**Problem Statement**\n\nYou are given permutations \\(P = (P_1, P_2, \\ldots, P_N)\\) and \\(A = (A_1, A_2, \\ldots, A_N)\\) of \\((1, 2, \\ldots, N)\\).\n\nYou can perform the following operation any number of times, possibly zero: replace \\(A_i\\) with \\(A_{P_i}\\) simultaneously for all \\(i = 1, 2, \\ldots, N\\).\n\nPrint the lexicographically smallest \\(A\\) that can be obtained.\n\n---\n\n**What is lexicographical order?**\n\nFor sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\), \\(A\\) is lexicographically smaller than \\(B\\) if and only if there exists an integer \\(i\\) (1 \u2264 i \u2264 N) such that \\(A_i < B_i\\), and \\(A_j = B_j\\) for all \\(1 \\leq j < i\\).\n\n---\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n\n- \\(1 \\leq P_i \\leq N\\) (1 \u2264 i \u2264 N)\n\n- \\(P_i \\neq P_j\\) (1 \u2264 i < j \u2264 N)\n\n- \\(1 \\leq A_i \\leq N\\) (1 \u2264 i \u2264 N)\n\n- \\(A_i \\neq A_j\\) (1 \u2264 i < j \u2264 N)\n\nAll input values are integers.\n\n---\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nP_1 P_2 \\ldots P_N\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet \\( (A_1, A_2, \\ldots, A_N) \\) be the lexicographically smallest \\(A\\) that can be obtained. Print \\(A_1, A_2, \\ldots, A_N\\) in this order, separated by spaces, in one line.\n\n---\n\n**Sample Input 1**\n\n```\n6\n3 1 5 6 2 4\n4 3 1 6 2 5\n```\n\n**Sample Output 1**\n\n```\n1 4 2 5 3 6\n```\n\nInitially, \\(A = (4, 3, 1, 6, 2, 5)\\). Repeating the operation yields the following:\n- \\(A = (1, 4, 2, 5, 3, 6)\\)\n- \\(A = (2, 1, 3, 6, 4, 5)\\)\n- \\(A = (3, 2, 4, 5, 1, 6)\\)\n- \\(A = (4, 3, 1, 6, 2, 5)\\)\n\nAfter this, \\(A\\) will revert to the original state every four operations. Therefore, print the lexicographically smallest among these, which is `1 4 2 5 3 6`.\n\n---\n\n**Sample Input 2**\n\n```\n8\n3 5 8 7 2 6 1 4\n1 2 3 4 5 6 7 8\n```\n\n**Sample Output 2**\n\n```\n1 2 3 4 5 6 7 8\n```\n\nYou may choose to perform no operations.\n\n---\n\n**Sample Input 3**\n\n```\n26\n24 14 4 20 15 19 16 11 23 22 12 18 21 3 6 8 26 2 25 7 13 1 5 9 17 10\n15 3 10 1 13 19 22 24 20 4 14 23 7 26 25 18 11 6 9 12 2 21 5 16 8 17\n```\n\n**Sample Output 3**\n\n```\n4 1 22 18 20 13 14 6 15 11 3 26 2 12 5 23 9 10 25 24 7 17 16 21 19 8\n```\n\n\nSolution:\n\n```\nG - Lexicographically Smallest Permutation Editorial\n\nTo solve this problem, we consider minimizing elements sequentially, starting with the first. The key is to determine cycles in the permutation \\(P\\), and within each cycle, find the lexicographically smallest permutation. For a cycle with length \\(L\\), the number of minimal positions is \\(L / \\gcd(L, \\text{period})\\). We choose the minimal lexicographical arrangement by evaluating potential positions and adjusting the operation count \\(ans\\) accordingly. The process involves updating a result array based on minimized operations for each cycle, taking care of integer operations due to potential size. Here is the sample code:\n\n```python\nfrom math import gcd\n\nN = int(input())\nP = [int(x) - 1 for x in input().split()]\nA = list(map(int, input().split()))\n\nused = [False for i in range(N)]\n\nperiod = 1\nans = 0\n\nresult = [0 for i in range(N)]\n\nfor i in range(N):\n    if not used[i]:\n        cycle = [i]\n        while P[cycle[-1]] != i:\n            used[P[cycle[-1]]] = True\n            cycle.append(P[cycle[-1]])\n            \n        L = len(cycle)\n        choose = L // gcd(L, period)\n        offset = min((A[cycle[(ans + i * period) % L]], i) for i in range(choose))[1]\n        \n        ans += offset * period\n        period *= choose\n        \n        for i in range(L):\n            result[cycle[i]] = A[cycle[(i + ans) % L]]\n\nprint(*result)\n```\nThis effectively computes the lexicographically smallest permutation using the described method.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nTakahashi can swim in \\( N \\) different styles. When he swims in the \\( i \\)-th style, he consumes \\( A_i \\) stamina per second and advances \\( B_i \\) meters per second. \n\nYou need to answer \\( Q \\) queries. The \\( i \\)-th query is as follows: determine if it is possible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\). If it is possible, find the minimum number of seconds required.\n\nTakahashi can freely combine different swimming styles, and the time to switch styles is negligible. Specifically, he can swim using the following steps:\n- Choose a positive integer \\( m \\), a sequence of positive real numbers \\( t = (t_1, t_2, \\dots, t_m) \\) of length \\( m \\), and a sequence of integers \\( x = (x_1, x_2, \\dots, x_m) \\) of length \\( m \\) where each element is between \\( 1 \\) and \\( N \\), inclusive.\n- Then, swim in the \\( x_i \\)-th style for \\( t_i \\) seconds in the order \\( i = 1, 2, \\dots, m \\).\n\n**Constraints:**\n- All input values are integers.\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C_i, D_i \\leq 10^9 \\)\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\nQ\nC_1 D_1\nC_2 D_2\n...\nC_Q D_Q\n```\n\n**Output:**\nPrint \\( Q \\) lines in total. For the \\( i \\)-th query, print the answer in the \\( i \\)-th line as follows:\n- If it is impossible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\), print \\(-1\\).\n- Otherwise, print the minimum required time. The output is considered correct if the absolute or relative error between the printed value and the true answer is at most \\( 10^{-9} \\).\n\n**Sample Input:**\n```\n4\n1 2\n2 3\n3 3\n4 4\n5\n4 7\n7 7\n49 100\n1000 500\n4 5\n```\n\n**Sample Output:**\n```\n3.000000000000000000\n1.750000000000000000\n-1\n125.000000000000000000\n1.500000000000000000\n```\n\nIn this input, Takahashi can swim in the following four styles:\n- Consumes 1 stamina and advances 2 meters per second.\n- Consumes 2 stamina and advances 3 meters per second.\n- Consumes 3 stamina and advances 3 meters per second.\n- Consumes 4 stamina and advances 4 meters per second.\n\nThis input contains five queries:\n- For the first query, \\( C_1 = 4, D_1 = 7 \\). Choose \\( t = (1,2) \\) and \\( x = (2,1) \\). Takahashi swims as follows:\n  - In the first 1 second, he consumes 2 stamina and advances 3 meters.\n  - In the next 2 seconds, he consumes 2 stamina and advances 4 meters.\n  - In total, he consumes 4 stamina and advances 7 meters. The required time is 3 seconds, which is the minimum.\n- For the second query, \\( C_2 = 7, D_2 = 7 \\). Choose \\( t = (7/4) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 7/4 seconds, he consumes 7 stamina and advances 7 meters.\n  - In total, he consumes 7 stamina and advances 7 meters. The required time is 7/4 seconds, which is the minimum.\n- For the third query, \\( C_3 = 49, D_3 = 100 \\). No matter how Takahashi swims, it is not possible to advance 100 meters while keeping the total stamina consumption at most 49.\n- For the fourth query, \\( C_4 = 1000, D_4 = 500 \\). Choose \\( t = (125) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 125 seconds, he consumes 500 stamina and advances 500 meters.\n  - In total, he consumes 500 stamina and advances 500 meters. The required time is 125 seconds, which is the minimum.\n- For the fifth query, \\( C_5 = 4, D_5 = 5 \\). Choose \\( t = (1/2,1) \\) and \\( x = (4,2) \\). Takahashi swims as follows:\n  - In the first 1/2 seconds, he consumes 2 stamina and advances 2 meters.\n  - In the next 1 second, he consumes 2 stamina and advances 3 meters.\n  - In total, he consumes 4 stamina and advances 5 meters. The required time is 3/2 seconds, which is the minimum.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 356\n\nConsider the case where Takahashi can swim using two styles: consume stamina of \\(A_1\\) to advance \\(B_1\\) meters per second or consume stamina of \\(A_2\\) to advance \\(B_2\\) meters per second. He can combine these styles to swim by consuming stamina of \\(tA_1+(1-t)A_2\\) to advance \\(tB_1+(1-t)B_2\\) meters per second. This corresponds to points on the segment connecting \\((B_1,A_1)\\) and \\((B_2,A_2)\\) in the \\(xy\\)-plane.\n\nIf there are \\(N\\) points \\((B_i,A_i)\\), he can swim for any point inside or on the convex hull's boundary, but not outside it. Plotting the styles on the \\(xy\\)-plane assists in this determination. The most time-efficient point has the maximum \\(B_i\\), and the most stamina-efficient point has the minimum \\(A_i/B_i\\). If he can't swim \\(D_i\\) meters using the stamina-efficient point, the answer is -1.\n\nTo swim \\(D_i\\) meters within stamina \\(C_i\\), locate the rightmost point in the intersection of the convex hull's circumference and a line passing through \\((0,0)\\) and \\((D_i,C_i)\\). This represents viable swimming styles under the stamina constraint. He should trace the convex hull from the stamina-efficient point to the time-efficient point counterclockwise. Using binary search helps identify which segment it lies on and then pinpoints \\(P_{opt}\\)'s exact coordinates.\n```\n \n\n", "problem_ids": ["abc366_d", "abc371_g", "abc356_g"]}, "abc327_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nIn Japan, there are six types of coins in circulation: 1 yen, 5 yen, 10 yen, 50 yen, 100 yen, and 500 yen. Answer the following question regarding these coins.\n\nMr. AtCoder's wallet contains:\n- \\( A \\) 1-yen coins,\n- \\( B \\) 5-yen coins,\n- \\( C \\) 10-yen coins,\n- \\( D \\) 50-yen coins,\n- \\( E \\) 100-yen coins,\n- \\( F \\) 500-yen coins.\n\nHe plans to shop at \\( N \\) stores in sequence. Specifically, at the \\( i \\)-th store (\\( 1 \\leq i \\leq N \\)), he plans to buy one item that costs \\( X_i \\) yen (including tax).\n\nGiving and receiving change takes time, so he wants to choose his coins so that he can pay the **exact amount** at each store. Determine if this is possible.\n\n**Constraints**\n- \\( 0 \\leq A \\leq 200 \\)\n- \\( 0 \\leq B \\leq 200 \\)\n- \\( 0 \\leq C \\leq 200 \\)\n- \\( 0 \\leq D \\leq 200 \\)\n- \\( 0 \\leq E \\leq 200 \\)\n- \\( 0 \\leq F \\leq 200 \\)\n- \\( 1 \\leq N \\leq 10 \\)\n- \\( 1 \\leq X_i \\leq 10000 \\) (for each \\( i \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C D E F\nN\nX_1 X_2 ... X_N\n```\n\n**Output**\n\nPrint `Yes` if the objective is achievable, and `No` otherwise.\n\n**Sample Input 1**\n```\n0 0 6 3 4 1\n3\n700 250 160\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*For example, he can make exact payments at all three stores as follows:*\n- At the first store: Use two 100-yen coins and one 500-yen coin.\n- At the second store: Use five 10-yen coins and two 100-yen coins.\n- At the third store: Use one 10-yen coin and three 50-yen coins.\n\n**Sample Input 2**\n```\n0 0 0 2 4 0\n3\n100 200 300\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*The total amount in the wallet is 500 yen, but a total payment of 100+200+300=600 yen is required, making it impossible to purchase all the items.*\n\n**Sample Input 3**\n```\n0 0 0 0 8 8\n1\n250\n```\n\n**Sample Output 3**\n```\nNo\n```\n\n*There are no 50-yen or smaller coins in the wallet, so it's impossible to pay exactly 250 yen.*\n\n**Sample Input 4**\n```\n20 5 9 7 10 6\n5\n177 177 177 177 177\n```\n\n**Sample Output 4**\n```\nYes\n```\n\n**Sample Input 5**\n```\n17 5 9 7 10 6\n5\n177 177 177 177 177\n```\n\n**Sample Output 5**\n```\nNo\n```\n\n\nSolution:\n\n\n        Here's the cleaned version focused on the solution:\n\n---\n\nMr. AtCoder has \\(A\\) 1-yen coins and \\(C\\) 10-yen coins, and must shop at \\(N\\) stores, spending \\(X_1, \\dots, X_N\\) yen. The goal is to determine if it is possible to pay the exact amount at each store.\n\nWhen possible, use 10-yen coins first to conserve 1-yen coins. There's no benefit in saving higher-value coins when purchasing with lower-value coins.\n\nThe same strategy applies when dealing with all coin types: \\(1\\), \\(5\\), \\(10\\), \\(50\\), \\(100\\), and \\(500\\)-yen coins. Pay with higher denominations first, until the amount left can be paid with the smaller denominations available, simulating if exact payment is possible at all stores.\n\nSample Python Implementation:\n\n```python\na, b, c, d, e, f = map(int, input().split())\nn = int(input())\nx = list(map(int, input().split()))\n\nans = True\nfor v in x:\n    while v >= 500 and f >= 1:\n        v -= 500\n        f -= 1\n    while v >= 100 and e >= 1:\n        v -= 100\n        e -= 1\n    while v >= 50 and d >= 1:\n        v -= 50\n        d -= 1\n    while v >= 10 and c >= 1:\n        v -= 10\n        c -= 1\n    while v >= 5 and b >= 1:\n        v -= 5\n        b -= 1\n    while v >= 1 and a >= 1:\n        v -= 1\n        a -= 1\n    if v != 0:\n        ans = False\n        break\n\nprint('Yes' if ans else 'No')\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given positive integers \\( N \\) and \\( L \\), and a sequence of positive integers \\( A = (A_{1}, A_{2}, \\dots, A_{N}) \\) of length \\( N \\).\n\nFor each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nDetermine if there exists a sequence of \\( L \\) non-negative integers \\( B = (B_{1}, B_{2}, \\dots, B_{L}) \\) such that:\n\n\\[\n\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = A_{i}\n\\]\n\nIf it exists, find the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^{5} \\)\n- \\( 2 \\leq L \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq A_{i} \\leq 2 \\times 10^{5} \\)\n\nAll input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN L\nA_{1} A_{2} \\cdots A_{N}\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain \\(-1\\) if no sequence \\( B \\) satisfies the condition for \\( i = k \\); otherwise, it should contain the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Sample Input 1:**\n\n```\n2 4\n10 5\n```\n\n**Sample Output 1:**\n\n```\n3\n-1\n```\n\n*Explanation*:\n- For \\( A_{1} = 10 \\), if we take \\( B = (1, 0, 2, 3) \\), then \\(\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = 10\\), where \\( \\max(B) = 3 \\). No non-negative integer sequence \\( B \\) satisfies the condition with \\( \\max(B) < 3 \\), so print 3 in the first line.\n- For \\( A_{2} = 5 \\), there is no non-negative integer sequence \\( B \\) that satisfies the condition, so print -1 in the second line.\n\n**Sample Input 2:**\n\n```\n6 8\n167 924 167167 167924 116677 154308\n```\n\n**Sample Output 2:**\n\n```\n11\n58\n10448\n10496\n7293\n9645\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 178\n\nC - Sum of Abs 2 Editorial by evima\n\nIn this explanation, the \u201csum of abs\u201d refers to the following formula: \n\\[\\sum_{j=1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}|\\]\n\nWhen \\(B\\) exists, one \\(B\\) that minimizes \\(\\max(B)\\) satisfies the following two conditions:\n- \\(B\\) is sorted in ascending order.\n- \\(B_{1} = 0\\).\n\nThe sum of abs does not depend on the order of \\(B\\). If all elements of \\(B\\) are positive, subtracting \\(1\\) from all elements can reduce \\(\\max(B)\\) without changing the sum of abs. When \\(B\\) is sorted in ascending order, the sum of abs can be expressed as follows: \n\\[\\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}| = \\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} (B_{k} - B_{j}) =\\sum_{k = 1} ^ {L - 1} k(L - k)(B_{k + 1} - B_{k})\\]\n\nThis transformation is correct because \\(B_{a}-B_{b}=(B_{a}-B_{a-1}) + (B_{a-1}+B_{a-2}) + \\cdots +(B_{b+1}-B_{b})\\) for integers \\(a, b\\) satisfying \\(1\\leq b<a\\leq L\\), and the number of pairs \\((a, b)\\) satisfying \\(b\\leq k\\) and \\(k+1\\leq a\\) is \\(k(L-k)\\).\n\nIf we let \\(C_{k} = B_{k + 1} - B_{k}\\), then when \\(B\\) is sorted in ascending order and \\(B_{1} = 0\\), the following holds:\n- \\(0 \\leq C_{k}\\).\n- The sum of abs is equal to \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}\\).\n- \\(\\displaystyle\\max(B) = B_{L} = \\sum_{k = 1} ^ {L - 1} C_{k}\\).\n\nTherefore, we need to solve the following problem: Determine if there exists a sequence of non-negative integers \\(C\\) of length \\(L - 1\\) such that \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}  = A_{i}\\), and if it exists, find the minimum sum of such \\(C\\).\n\nThis can be solved using dynamic programming in the same manner as the knapsack problem, and it can be computed simultaneously for all \\(i\\). Since \\(C_{k} = 0\\) always holds for \\(k\\) satisfying \\(\\max(A)<k(L-k)\\), our solution has a space complexity of \\(O(\\max(A))\\) and a time complexity of \\(O(N + \\max(A)\\sqrt{\\max(A)})\\).\n\nPython implementation example:\n\n```python\nN, L = map(int, input().split())\nA = list(map(int, input().split()))\n\nM = 2 * 10 ** 5\nINF = 10 ** 9\ndp = [INF] * (M + 1)\ndp[0] = 0\nk = 1\n\nwhile k * (L - k) <= M and k * 2 <= L:\n    w = k * (L - k)\n    for i in range(w, M + 1):\n        dp[i] = min(dp[i], dp[i - w] + 1)\n    k += 1\n\nfor a in A:\n    print(-1 if dp[a] == INF else dp[a])\n``` \n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere is a grid with \\( H \\) rows and \\( W \\) columns. Let \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Cell \\((i, j)\\) is empty if \\( C_{i, j} \\) is `.` and not empty if \\( C_{i, j} \\) is `#`. Takahashi is currently at cell \\((S_i, S_j)\\), and he will act according to the following rules for \\( i = 1, 2, \\ldots, |X| \\) in order:\n\n- If the \\( i \\)-th character of \\( X \\) is `L`, and the cell to the left of his current cell exists and is empty, he moves to the cell to the left. Otherwise, he stays in the current cell.\n- If the \\( i \\)-th character of \\( X \\) is `R`, and the cell to the right of his current cell exists and is empty, he moves to the cell to the right. Otherwise, he stays in the current cell.\n- If the \\( i \\)-th character of \\( X \\) is `U`, and the cell above his current cell exists and is empty, he moves to the cell above. Otherwise, he stays in the current cell.\n- If the \\( i \\)-th character of \\( X \\) is `D`, and the cell below his current cell exists and is empty, he moves to the cell below. Otherwise, he stays in the current cell.\n\nPrint the cell where he is after completing the series of actions.\n\nConstraints:\n- \\( 1 \\leq H, W \\leq 50 \\)\n- \\( 1 \\leq S_i \\leq H \\)\n- \\( 1 \\leq S_j \\leq W \\)\n- \\( H, W, S_i, S_j \\) are integers.\n- \\( C_{i, j} \\) is `.` or `#`.\n- \\( C_{S_i, S_j} = .\\)\n- \\( X \\) is a string of length between 1 and 50, inclusive, consisting of `L`, `R`, `U`, `D`.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nH W\nS_i S_j\nC_{1, 1}C_{1, 2}\\ldots C_{1, W}\nC_{2, 1}C_{2, 2}\\ldots C_{2, W}\n\\vdots\nC_{H, 1}C_{H, 2}\\ldots C_{H, W}\nX\n```\n\nOutput:\nLet \\( (x, y) \\) be the cell where Takahashi is after completing the series of actions. Print \\( x \\) and \\( y \\), separated by a space.\n\nSample Input 1:\n```\n2 3\n2 1\n.#.\n...\nULDRU\n```\n\nSample Output 1:\n```\n2 2\n```\n\nExplanation:\nTakahashi starts at cell (2, 1). His series of actions are as follows:\n- The 1st character of \\( X \\) is `U`, and the cell above (2, 1) exists and is an empty cell, so he moves to the cell above, which is (1, 1).\n- The 2nd character of \\( X \\) is `L`, and the cell to the left of (1, 1) does not exist, so he stays at (1, 1).\n- The 3rd character of \\( X \\) is `D`, and the cell below (1, 1) exists and is an empty cell, so he moves to the cell below, which is (2, 1).\n- The 4th character of \\( X \\) is `R`, and the cell to the right of (2, 1) exists and is an empty cell, so he moves to the cell to the right, which is (2, 2).\n- The 5th character of \\( X \\) is `U`, and the cell above (2, 2) exists but is not an empty cell, so he stays at (2, 2).\n\nTherefore, after completing the series of actions, he is at cell (2, 2).\n\nSample Input 2:\n```\n4 4\n4 2\n....\n.#..\n...#\n....\nDUUUURULRD\n```\n\nSample Output 2:\n```\n2 4\n```\n\nSample Input 3:\n```\n6 6\n1 1\n.#####\n######\n######\n######\n######\n######\nRURLDLULLRULRDL\n```\n\nSample Output 3:\n```\n1 1\n```\n\nSolution:\n\nHere's a trimmed version focusing on the solution content from the editorial:\n\n---\n\nWhile managing Takahashi\u2019s current cell, simulate his action according to the rules. To determine if there is an adjacent cell in some direction, one can either check whether the current cell is on the edge or whether the cell that you move into is within the range of the grid, as in the sample code below.\n\n```python\nh, w = map(int, input().split())\nsi, sj = map(int, input().split())\nsi -= 1\nsj -= 1\nc = [list(input().strip()) for _ in range(h)]\nx = input().strip()\nfor o in x:\n    ni, nj = si, sj\n    if o == 'L':\n        nj -= 1\n    elif o == 'R':\n        nj += 1\n    elif o == 'U':\n        ni -= 1\n    else:\n        ni += 1\n    if 0 <= ni < h and 0 <= nj < w and c[ni][nj] == '.':\n        si, sj = ni, nj\nprint(si + 1, sj + 1)\n```\n\n---\n \n\n", "problem_ids": ["arc177_a", "arc178_c", "abc364_b"]}, "abc327_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 450 points\n\n## Problem Statement\n\nThere are \\( N \\) islands and \\( M \\) bidirectional bridges connecting two islands. The islands and bridges are numbered \\( 1, 2, \\ldots, N \\) and \\( 1, 2, \\ldots, M \\), respectively. Bridge \\( i \\) connects islands \\( U_i \\) and \\( V_i \\), and the time it takes to cross it in either direction is \\( T_i \\). No bridge connects an island to itself, but it is possible for two islands to be directly connected by more than one bridge. One can travel between any two islands using some bridges.\n\nYou are given \\( Q \\) queries, so answer each of them. The \\( i \\)-th query is as follows:\n\n- You are given \\( K_i \\) distinct bridges: bridges \\( B_{i,1}, B_{i,2}, \\ldots, B_{i,K_i} \\).\n- Find the minimum time required to travel from island \\( 1 \\) to island \\( N \\) using each of these bridges at least once.\n- Only consider the time spent crossing bridges.\n- You can cross the given bridges in any order and in any direction.\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 400 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq T_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 3000 \\)\n- \\( 1 \\leq K_i \\leq 5 \\)\n- \\( 1 \\leq B_{i,1} < B_{i,2} < \\cdots < B_{i,K_i} \\leq M \\)\n- All input values are integers.\n- It is possible to travel between any two islands using some bridges.\n\n## Input\n\nThe input is given in the following format:\n```\nN M\nU_1 V_1 T_1\nU_2 V_2 T_2\n\u22ee\nU_M V_M T_M\nQ\nK_1\nB_{1,1} B_{1,2} \u22ef B_{1,{K_1}}\nK_2\nB_{2,1} B_{2,2} \u22ef B_{2,{K_2}}\n\u22ee\nK_Q\nB_{Q,1} B_{Q,2} \u22ef B_{Q,{K_Q}}\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq Q \\)) should contain the answer to the \\( i \\)-th query as an integer.\n\n## Sample Input 1\n\n```\n3 5\n1 2 10\n1 3 20\n1 3 30\n2 3 15\n2 3 25\n2\n1\n1\n2\n3 5\n```\n\n## Sample Output 1\n\n```\n25\n70\n```\n\nExplanation:\n- For the first query, the minimum time to travel from island 1 to island 3 using bridge 1 is achieved by using bridge 1 to move from island 1 to island 2, then bridge 4 to move from island 2 to island 3. The time taken is 10 + 15 = 25.\n- For the second query, the minimum time to travel from island 1 to island 3 using both bridges 3 and 5 is achieved by using bridge 3 to move from island 1 to island 3, then using bridge 5 to move to island 2, and finally bridge 4 to return to island 3. The time taken is 30 + 25 + 15 = 70.\n\n## Sample Input 2\n\n```\n6 6\n1 5 1\n2 5 1\n2 4 1\n3 4 1\n3 6 1\n1 6 1\n2\n5\n1 2 3 4 5\n1\n5\n```\n\n## Sample Output 2\n\n```\n5\n3\n```\n\nRemarks: You can cross the specified bridges in either direction.\n\n## Sample Input 3\n\n```\n5 5\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4 5 1000000000\n1 5 1000000000\n1\n1\n3\n```\n\n## Sample Output 3\n\n```\n4000000000\n```\n\nNote: The answer may not fit in a 32-bit integer.\n\nSolution:\n\n```python\nimport itertools\n\nN = 400\nM = int(2e5)\nINF = int(1e15)\n\nn = 0\nu = [0] * M\nv = [0] * M\nt = [0] * M\nd = [[0 if i == j else INF for j in range(N)] for i in range(N)]\nk = 0\na = []\n\ndef solve():\n    ans = INF\n    dp = [[0] * 2 for _ in range(5)]\n    b = list(range(k))\n    for perm in itertools.permutations(b):\n        dp[0][0] = d[0][v[a[perm[0]]]] + t[a[perm[0]]]\n        dp[0][1] = d[0][u[a[perm[0]]]] + t[a[perm[0]]]\n        for i in range(k - 1):\n            dp[i + 1][0] = min(dp[i][0] + d[u[a[perm[i]]]][v[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][v[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n            dp[i + 1][1] = min(dp[i][0] + d[u[a[perm[i]]]][u[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][u[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n        ans = min(ans, dp[k-1][0] + d[u[a[perm[k-1]]]][n-1])\n        ans = min(ans, dp[k-1][1] + d[v[a[perm[k-1]]]][n-1])\n    return ans\n\ndef main():\n    global n, k\n    m, q = map(int, input().split())\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d[i][j] = INF\n\n    for i in range(m):\n        u[i], v[i], t[i] = map(int, input().split())\n        u[i] -= 1\n        v[i] -= 1\n        d[u[i]][v[i]] = min(d[u[i]][v[i]], t[i])\n        d[v[i]][u[i]] = min(d[v[i]][u[i]], t[i])\n\n    for i1 in range(n):\n        for i0 in range(n):\n            for i2 in range(n):\n                d[i0][i2] = min(d[i0][i2], d[i0][i1] + d[i1][i2])\n    \n    for _ in range(q):\n        k = int(input())\n        a.clear()\n        for _ in range(k):\n            x = int(input())\n            a.append(x-1)\n        print(solve())\n\nif __name__ == '__main__':\n    main()\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 400 points\n\n**Problem Statement**\n\nThere are \\( N \\) buildings, Building 1, Building 2, ..., Building \\( N \\), arranged in a line in this order. The height of Building \\( i \\) (\\( 1 \\leq i \\leq N \\)) is \\( H_i \\).\n\nFor each \\( i = 1, 2, \\ldots, N \\), find the number of integers \\( j \\) (\\( i < j \\leq N \\)) satisfying the following condition:\n\n- There is no building taller than Building \\( j \\) between Buildings \\( i \\) and \\( j \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq N \\)\n- \\( H_i \\neq H_j \\ (i \\neq j) \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nFor each \\( i = 1, 2, \\ldots, N \\), let \\( c_i \\) be the number of \\( j \\) satisfying the condition. Print \\( c_1, c_2, \\ldots, c_N \\) in order, separated by spaces.\n\n**Sample Input 1**\n\n```\n5\n2 1 4 3 5\n```\n\n**Sample Output 1**\n\n```\n3 2 2 1 0\n```\n\nFor \\( i=1 \\), the integers \\( j \\) satisfying the condition are 2, 3, and 5: there are three. (Between Buildings 1 and 4, there is a building taller than Building 4, which is Building 3, so \\( j=4 \\) does not satisfy the condition.) Therefore, the first number in the output is 3.\n\n**Sample Input 2**\n\n```\n4\n1 2 3 4\n```\n\n**Sample Output 2**\n\n```\n3 2 1 0\n```\n\n**Sample Input 3**\n\n```\n10\n1 9 6 5 2 7 10 4 8 3\n```\n\n**Sample Output 3**\n\n```\n2 3 3 3 2 1 2 1 1 0\n```\n\nSolution:\n\n        Here is a clean version of the coding problem editorial:\n\n---\n\n**D - Buildings Editorial**\n\nFor each \\(i\\), let \\(J_i\\) be the sequence of conforming \\(j\\) sorted in ascending order, so that \\(H_{J_{i,1}} < H_{J_{i,2}} < H_{J_{i,3}} < \\ldots\\) holds. For \\(i \\neq N\\), focus on the difference between \\(J_{i+1}\\) and \\(J_i\\). \\(J_i\\) always contains \\((i+1)\\). Any \\(j \\in J_{i+1}\\) with \\(H_{i+1} > H_j\\) is not in \\(J_i\\). Meanwhile, any \\(j \\in J_{i+1}\\) with \\(H_{i+1} < H_i\\) is always in \\(J_i\\). By this order, one can obtain \\(J_{i+1}\\) from \\(J_i\\):\n\nLet \\(A = J_{i+1}\\). While \\(A\\) is non-empty, repeat the following:\n\n1. Let \\(j\\) be the initial element of \\(A\\). If \\(H_{i+1} > H_j\\), remove \\(j\\) from \\(A\\). Otherwise, terminate this loop.\n2. Push \\((i+1)\\) to the front of \\(A\\).\n\nThe current \\(A\\) is \\(J_i\\). Manage \\(J_i\\) in reverse order using a stack. Total complexity is \\(O(N)\\), as each \\(j\\) is put in and out at most once.\n\n```python\nn = int(input())\nh = list(map(int, input().split()))\nans = [0] * n\nstc = []\nfor i in range(n - 2, -1, -1):\n    while stc and h[stc[-1]] < h[i + 1]:\n        stc.pop()\n    stc.append(i + 1)\n    ans[i] = len(stc)\nprint(*ans)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given \\( N \\) pairs of integers \\((L_1, R_1), (L_2, R_2), \\ldots, (L_N, R_N)\\).\n\nDetermine whether there exists a sequence of \\( N \\) integers \\( X = (X_1, X_2, \\ldots, X_N) \\) that satisfies the following conditions, and print one such sequence if it exists:\n\n1. \\( L_i \\leq X_i \\leq R_i \\) for each \\( i = 1, 2, \\ldots, N \\).\n2. \\( \\sum_{i=1}^N X_i = 0 \\).\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq L_i \\leq R_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nL_1 R_1\nL_2 R_2\n\u22ee\nL_N R_N\n```\n\n**Output:**\n\nIf no solution exists, print `No`. Otherwise, print an integer sequence \\( X \\) that satisfies the conditions in the following format:\n\n```\nYes\nX_1 X_2 ... X_N\n```\n\nIf multiple solutions exist, any of them will be considered correct.\n\n**Sample Input 1:**\n\n```\n3\n3 5\n-4 1\n-2 3\n```\n\n**Sample Output 1:**\n\n```\nYes\n4 -3 -1\n```\n\nThe sequence \\( X = (4, -3, -1) \\) satisfies all the conditions. Other valid sequences include \\( (3, -3, 0) \\) and \\( (5, -4, -1) \\).\n\n**Sample Input 2:**\n\n```\n3\n1 2\n1 2\n1 2\n```\n\n**Sample Output 2:**\n\n```\nNo\n```\n\nNo sequence \\( X \\) satisfies the conditions.\n\n**Sample Input 3:**\n\n```\n6\n-87 12\n-60 -54\n2 38\n-76 6\n87 96\n-17 38\n```\n\n**Sample Output 3:**\n\n```\nYes\n-66 -57 31 -6 89 9\n```\n\nSolution:\n\n```\n        Editorial - Toyota Programming Contest 2024#7\uff08AtCoder Beginner Contest 362\uff09\n\nC - Sum = 0 Editorial by en_translator\n\nProblem: Given a sequence of non-negative integers \\(A=(A_1,A_2,\\ldots,A_N)\\) and an integer \\(S\\), determine if there exists a length-\\(N\\) integer sequence \\(X=(X_1,X_2,\\ldots,X_N)\\) satisfying:\n- \\(0 \\leq X_i \\leq A_i\\)\n- \\(\\sum X = S\\)\n\nNecessary and sufficient condition: \\(\\sum A \\geq S\\). Construct \\(X\\) greedily by maximizing each \\(X_i\\) from left to right.\n\nIf \\(\\sum L > 0\\), then \\(\\sum X \\geq \\sum L > 0\\), so no \\(X\\) satisfies. If \\(\\sum R < 0\\), no \\(X\\) satisfies because \\(\\sum X \\leq \\sum R < 0\\). Otherwise, a conforming \\(X\\) exists. Initialize \\(X_i\\) with \\(L_i\\) and adjust as needed.\n\nFor each \\(i=1,2,\\ldots,N\\):\n1. Repeat incrementing \\(X_i\\) by \\(+1\\) while \\(X_i < R_i\\) and \\(\\sum X < 0\\).\n2. Efficiently find increment as \\(D_i=\\min(R_i-L_i,-\\sum X)\\) and update \\(X_i\\) with \\(+D_i\\).\n\nComplexity: \\(O(N)\\).\n\n```python\nN = int(input())\nL, R = [0] * N, [0] * N\nfor i in range(N):\n    L[i], R[i] = map(int, input().split())\n\nif sum(L) > 0 or sum(R) < 0:\n    print(\"No\")\n    exit()\n\nX = L.copy()\nsumX = sum(X)\nfor i in range(N):\n    d = min(R[i] - L[i], -sumX)\n    sumX += d\n    X[i] += d\n\nprint(\"Yes\")\nprint(*X)\n```\n```\n \n\n", "problem_ids": ["abc369_e", "abc372_d", "abc362_c"]}, "abc327_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a stack of `N` cards, and the `i-th` card from the top has an integer `A_i` written on it. You take `K` cards from the bottom of the stack and place them on top of the stack, maintaining their order.\n\nPrint the integers written on the cards from top to bottom after the operation.\n\n**Constraints**\n\n- \\(1 \\leq K < N \\leq 100\\)\n- \\(1 \\leq A_i \\leq 100\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet `B_i` be the integer written on the `i-th` card from the top of the stack after the operation. Print `B_1, B_2, \\ldots, B_N` in this order, separated by spaces.\n\n**Sample Input 1**\n\n```\n5 3\n1 2 3 4 5\n```\n\n**Sample Output 1**\n\n```\n3 4 5 1 2\n```\n\nInitially, the integers written on the cards are `1, 2, 3, 4, 5` from top to bottom. After taking three cards from the bottom of the stack and placing them on top, the integers written on the cards become `3, 4, 5, 1, 2` from top to bottom.\n\n**Sample Input 2**\n\n```\n6 2\n1 2 1 2 1 2\n```\n\n**Sample Output 2**\n\n```\n1 2 1 2 1 2\n```\n\nThe integers written on the cards are not necessarily distinct.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Hitachi Vantara Programming Contest 2024 (AtCoder Beginner Contest 368)\n\nThe topmost card after an operation is the \\(K\\)-th card from the bottom in the original pile. The \\(K\\)-th bottommost card is the \\((N-K+1)\\) card from the top, so the cards after the operation have \\(A_{N-K+1},A_{N-K+2},\\ldots,A_{N},A_{1},A_{2},\\ldots\\), and \\(A_{N-K}\\) written on them from the top. You may print these values. In many programming languages, indices start from \\(0\\), so beware of indices.\n\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\nfor i in range(N-K,N): print(A[i])\nfor i in range(N-K): print(A[i])\n```\n\nIn languages like Python, one can easily achieve the operation of splitting a pile into two and move the lower part to the top, as follows:\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\ntop = A[:-K]  # upper\nbottom = A[-K:]  # lower\nB = bottom + top  # put the lower part to the top\nprint(*B)\n```\n\nIn Python, you can also achieve a similar operation using list slicing:\n```python\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA = A[-K:] + A[:-K]\nprint(*A)\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two integer sequences, \\( A \\) and \\( B \\), each of length \\( N \\). Choose integers \\( i, j \\) (such that \\( 1 \\leq i, j \\leq N \\)) to maximize the value of \\( A_i + B_j \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 5 \\times 10^5 \\)\n- \\( |A_i| \\leq 10^9 \\) for \\( i = 1, 2, \\ldots, N \\)\n- \\( |B_j| \\leq 10^9 \\) for \\( j = 1, 2, \\ldots, N \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\nB_1 B_2 \\dots B_N\n```\n\n**Output**\n\nPrint the maximum possible value of \\( A_i + B_j \\).\n\n**Sample Input 1**\n\n```\n2\n-1 5\n3 -7\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\n_For \\( (i, j) = (1,1), (1,2), (2,1), (2,2) \\), the values of \\( A_i + B_j \\) are \\( 2, -8, 8, -2 \\) respectively, and \\( (i, j) = (2,1) \\) achieves the maximum value 8._\n\n**Sample Input 2**\n\n```\n6\n15 12 3 -13 -1 -19\n7 17 -13 -10 18 4\n```\n\n**Sample Output 2**\n\n```\n33\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 373 - C - Max Ai+Bj Editorial\n\nThere are \\(N^2\\) combinations of \\((i,j)\\), so evaluating \\(A_i+B_j\\) for all pairs \\((i,j)\\) does not finish within the execution time limit. Notice that \\(\\max_{1 \\leq i,j \\leq N} (A_i + B_j) = \\max_{1 \\leq i \\leq N} A_i + \\max_{1 \\leq j \\leq N} B_j\\). One can find \\(\\max_{1 \\leq i \\leq N} A_i\\) by scanning the elements of \\(A\\) in \\(O(N)\\) time, and the same applies to \\(\\max_{1 \\leq j \\leq N} B_j\\). Therefore, the problem is solved in \\(O(N)\\) time.\n\nSample code (Python):\n```python\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nprint(max(A) + max(B))\n```\n\nSample code (Python, translated from C++):\n```python\nN = int(input())\na = -1e9\nb = -1e9\nfor _ in range(N):\n    x = int(input())\n    a = max(a, x)\nfor _ in range(N):\n    x = int(input())\n    b = max(b, x)\nprint(a + b)\n```\n        [END TEXT]\n        \n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nAn undirected graph with numbered vertices is called a **good graph** if it has a spanning tree \\( T \\) that satisfies the following condition: For every edge \\( (u, v) \\) (\\( u < v \\)) in the graph, the minimum and maximum vertex numbers on the unique simple path connecting vertices \\( u \\) and \\( v \\) in \\( T \\) are \\( u \\) and \\( v \\), respectively.\n\nYou are given a simple connected undirected graph \\( G \\) with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). The graph \\( G \\) has \\( M \\) edges, and the \\( i \\)-th edge connects vertices \\( A_i \\) and \\( B_i \\) (\\( A_i < B_i \\)).\n\nFor each \\( i = 1, 2, \\dots, M \\), determine whether the graph obtained by removing the \\( i \\)-th edge from \\( G \\) is a **good graph**.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- All input values are integers.\n- The given graph is a simple connected undirected graph.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\n**Output**\n\nPrint \\( M \\) lines. The \\( i \\)-th line should contain `Yes` if the graph obtained by removing the \\( i \\)-th edge from \\( G \\) is a **good graph**, and `No` otherwise.\n\n**Sample Input 1**\n\n```\n6 9\n1 3\n1 5\n2 5\n2 6\n3 4\n3 5\n3 6\n4 6\n5 6\n```\n\n**Sample Output 1**\n\n```\nNo\nNo\nNo\nNo\nYes\nNo\nNo\nYes\nYes\n```\n\nConsider the case where edge \\( (4, 6) \\) is removed. A spanning tree formed by edges \\( (1, 3), (2, 5), (3, 4), (3, 5), (5, 6) \\) satisfies the condition. For example, for edge \\( (3, 6) \\), the simple path connecting vertices \\( 3 \\) and \\( 6 \\) traverses vertices \\( 3, 5, 6 \\) in this order, and the minimum and maximum vertex numbers on the path are \\( 3 \\) and \\( 6 \\), respectively, thus satisfying the condition. By verifying the other edges similarly, it can be seen that this spanning tree satisfies the condition, so the answer is `Yes`.\n\nOn the other hand, consider the case where edge \\( (1, 5) \\) is removed. The same spanning tree does not satisfy the condition. For edge \\( (4, 6) \\), the simple path connecting vertices \\( 4 \\) and \\( 6 \\) traverses vertices \\( 4, 3, 5, 6 \\) in this order, and the minimum and maximum vertex numbers on the path are \\( 3 \\) and \\( 6 \\), respectively, thus not satisfying the condition. It can also be shown that no other spanning tree satisfies the condition, so the answer is `No`.\n\n**Sample Input 2**\n\n```\n5 4\n1 2\n2 3\n3 4\n4 5\n```\n\n**Sample Output 2**\n\n```\nNo\nNo\nNo\nNo\n```\n\nRemoving an edge may disconnect the graph.\n\n**Sample Input 3**\n\n```\n15 20\n12 13\n7 8\n5 7\n8 10\n9 12\n4 5\n11 12\n2 4\n6 8\n4 14\n1 2\n14 15\n2 9\n3 8\n2 15\n10 11\n13 14\n8 9\n7 14\n5 13\n```\n\n**Sample Output 3**\n\n```\nNo\nNo\nNo\nYes\nYes\nNo\nYes\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nYes\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 181\n\nE - Min and Max at the edge Editorial by evima\n\nThe spanning tree that possesses the properties described in the conditions for a good graph will be referred to as a \u201cgood spanning tree.\u201d First, let\u2019s consider how to determine the existence of a good spanning tree for a fixed graph. If a good spanning tree exists, when we define the cost of an edge \\( (u,v) \\) as \\(|X_u - X_v|\\) using a strictly increasing sequence \\(X\\), the good spanning tree will be one of the minimum spanning trees. This follows from Kruskal's algorithm and the fact that for an edge \\( (u,v) \\) not included in the good spanning tree, the cost of the edges on the simple path connecting \\(u\\) and \\(v\\) will be less than \\(|X_u - X_v|\\). Specifically, if we consider setting \\(X_u = 10^u\\) or \\(-10^{N-u}\\), the costs of each edge will be distinct, so the minimum spanning tree will be uniquely determined. The good spanning tree will be equal to both of the following:\n\n1. The minimum spanning tree \\(T_1\\) when the cost of edge \\((u,v)\\) is \\((N+1)v - u\\)\n2. The minimum spanning tree \\(T_2\\) when the cost of edge \\((u,v)\\) is \\((N+1)(N+1-u) - (N+1-v)\\)\n\nTherefore, for a good spanning tree to exist, it is necessary that \\(T_1 = T_2\\). Conversely, in \\(T_1\\), for an edge \\((u,v)\\), the maximum vertex number on the simple path connecting \\(u\\) and \\(v\\) must be \\(v\\). In \\(T_2\\), for an edge \\((u,v)\\), the minimum vertex number on the simple path connecting \\(u\\) and \\(v\\) must be \\(u\\). Thus, the above conditions are also sufficient. From the above, the existence of a good spanning tree can be determined by finding \\(T_1\\) and \\(T_2\\) and checking if they are identical. Then, to determine the existence of a good spanning tree when each edge is removed, we can find the changes in the minimum spanning tree when the edge is removed and check for identicalness.\n\nFor the minimum spanning tree \\(T\\) of graph \\(G\\), the minimum spanning tree \\(T_{u,v}\\) of the graph obtained by removing edge \\((u,v)\\) can be obtained by the following steps:\n- If \\((u,v)\\) is not included in \\(T\\), then \\(T_{u,v} = T\\).\n- Otherwise, remove \\((u,v)\\) from \\(T\\). As a result, \\(T\\) will be divided into two connected components. Among the edges that span the two connected components, add the one with the minimum cost to \\(T\\) to obtain the tree \\(T_{u,v}\\).\n\nTherefore, we need to solve the following problem:\n\n1. For each edge \\(e\\) in the minimum spanning tree \\(T\\) of graph \\(G\\), initialize a variable \\(X_e\\) to \\(\\infty\\).\n2. For each edge \\((u,v)\\) in graph \\(G\\) that is not included in \\(T\\), update \\(X_e \\leftarrow \\min(X_e, C_{u,v})\\) (where \\(C_{u,v}\\) is the cost of edge \\((u,v)\\)) for each edge \\(e\\) included in the simple path connecting \\(u\\) and \\(v\\) in \\(T\\), and find the final values of \\(X_e\\).\n\nThis can be processed in \\(O(M \\log N)\\) time by handling range chmin queries with a segment tree while performing a DFS. Alternatively, by decomposing the tree into heavy and light paths and arranging the heavy paths, it can be converted into \\(O(\\log N)\\) range chmin queries, allowing it to be processed in \\(O(M \\log^2 N)\\) time, which is also sufficient.\n```\n\n \n\n", "problem_ids": ["abc368_a", "abc373_c", "arc181_e"]}, "abc327_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) intervals of real numbers. The \\( i \\)-th (\\( 1 \\leq i \\leq N \\)) interval is \\([l_i, r_i]\\). Find the number of pairs \\((i, j)\\) (\\( 1 \\leq i < j \\leq N \\)) such that the \\( i \\)-th and \\( j \\)-th intervals intersect.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 5 \\times 10^5 \\)\n- \\( 0 \\leq l_i < r_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nl_1 r_1\nl_2 r_2\n\u22ee\nl_N r_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n1 5\n7 8\n3 7\n```\n\n**Sample Output 1**\n```\n2\n```\n*Explanation*: The given intervals are \\([1,5], [7,8], [3,7]\\). Among these, the 1st and 3rd intervals intersect, as well as the 2nd and 3rd intervals, so the answer is 2.\n\n**Sample Input 2**\n```\n3\n3 4\n2 5\n1 6\n```\n\n**Sample Output 2**\n```\n3\n```\n\n**Sample Input 3**\n```\n2\n1 2\n3 4\n```\n\n**Sample Output 3**\n```\n0\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Inspecting all pairs of segments to check if they intersect has a time complexity of \\(O(N^2)\\), which exceeds the execution time limit. Instead, we find the number of disjoint segments \\(x\\) and subtract it from \\(N(N-1)/2\\). For each segment \\(i\\), count \\(j\\) such that \\(r_j < l_i\\) using a sliding window technique. Sort the sequences \\(L\\) and \\(R\\) obtained from \\(l_i\\) and \\(r_i\\) respectively. For each \\(i\\), find the number \\(c_i\\) of \\(j\\) such that \\(R_j < L_i\\) by leveraging the property \\(c_i\\leq c_{i+1}\\). This optimization results in a time complexity of \\(O(N)\\), allowing the algorithm to run efficiently.\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\). Print a string \\( S \\) that satisfies all of the following conditions. If no such string exists, print \\(-1\\).\n\n- \\( S \\) is a string of length between 1 and 1000, inclusive, consisting of the characters \\( 1, 2, 3, 4, 5, 6, 7, 8, 9 \\), and \\( * \\) (multiplication symbol).\n- \\( S \\) is a palindrome.\n- The first character of \\( S \\) is a digit.\n- The value of \\( S \\) when evaluated as a formula equals \\( N \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^{12} \\)\n- \\( N \\) is an integer.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\( N \\)\n\n**Output**\n\nIf there is a string \\( S \\) that satisfies the conditions, print such a string. Otherwise, print \\(-1\\).\n\n**Sample Input 1**\n\n```\n363\n```\n\n**Sample Output 1**\n\n```\n11*3*11\n```\n\n\\( S = 11*3*11 \\) satisfies the conditions in the problem statement. Another string that satisfies the conditions is \\( S = 363 \\).\n\n**Sample Input 2**\n\n```\n101\n```\n\n**Sample Output 2**\n\n```\n-1\n```\n\nNote that \\( S \\) must not contain the digit \\( 0 \\).\n\n**Sample Input 3**\n\n```\n3154625100\n```\n\n**Sample Output 3**\n\n```\n2*57*184481*75*2\n```\n\nSolution:\n\n```\nHere is the cleaned text of the coding problem editorial:\n\n---\n\nIn the editorial for the AtCoder Beginner Contest 363, the solution for the \"F - Palindromic Expression\" problem involves considering patterns for a conforming \\(S\\). The main patterns are \\(N\\) and \\(x*(\\text{expression})*\\mathrm{rev}(x)\\), where \\(\\mathrm{rev}(a)\\) is the reverse of \\(a\\). Several observations simplify the problem:\n\n1. \\(x = 1\\) is not considered because if \\(1*(\\text{expression})*1\\) qualifies, so does \\(\\text{expression}\\).\n2. For \\(x \\gt \\sqrt{N}\\), \\(\\mathrm{rev}(x) \\leq \\sqrt{N}\\), so \\(\\mathrm{rev}(x)*(\\text{expression})*x\\) also qualifies.\n\nDefine a function \\(f\\) as:\n\n- \\(f(n)\\) returns a string satisfying the problem's conditions if \\(n\\) is a palindrome without zero, otherwise an empty string.\n\nThe function works by checking potential factors \\(x\\) of \\(n\\), and if a palindrome condition is met through the factors, the corresponding string is returned.\n\nThe complexity is approximately \\(\\mathrm{O}(\\sqrt{N} \\times (\\text{number of divisors of } N))\\). With memorized recursion, the number of calls is manageable, ensuring the implementation is efficient.\n\nSample code (Python):\n\n```python\nimport functools\nimport math\n\n@functools.cache\ndef f(N):\n    if not \"0\" in str(N) and str(N) == str(N)[::-1]:\n        return str(N)\n    for x in range(2, math.isqrt(N) + 1):\n        if N % x == 0 and not \"0\" in str(x):\n            y = int(str(x)[::-1])\n            if N // x % y == 0 and len(f(N // x // y)) != 0:\n                return str(x) + \"*\" + f(N // x // y) + \"*\" + str(y)\n    return \"\"\n\nN = int(input())\nprint(\"-1\" if len(f(N)) == 0 else f(N))\n```\n\n--- \n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence \\( A \\) of length \\( N \\). Freely choose exactly \\( K \\) elements from \\( A \\) and remove them, then concatenate the remaining elements in their original order to form a new sequence \\( B \\). Find the minimum possible value of this: the maximum value of \\( B \\) minus the minimum value of \\( B \\).\n\n**Constraints**\n\n- All inputs are integers.\n- \\( 1 \\le K < N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le A_i \\le 10^9 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n5 2\n3 1 5 4 9\n```\n\n**Sample Output 1**\n```\n2\n```\n\n**Sample Input 2**\n```\n6 5\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n8 3\n31 43 26 6 18 36 22 13\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Editorial - Denso Create Programming Contest 2024 (AtCoder Beginner Contest 361)\n\nRemoving \\(K\\) elements of \\(A\\) is equivalent to retaining \\((N-K)\\) elements to form \\(B\\). To minimize (maximum value of \\(B\\)) - (minimum value of \\(B\\)), it is optimal to retain the \\((N-K)\\) smallest elements among the elements of \\(A\\) greater than or equal to \\(A_x\\), the fixed minimum of \\(B\\). In other words, it is optimal to choose \\((N-K)\\) consecutive elements in \\(A\\) sorted in ascending order.\n\nSolution: \n1. Sort \\(A\\) such that \\(A_1 \\le A_2 \\le \\dots \\le A_N\\).\n2. The answer is the minimum of \\(A_{l+(N-K)-1} - A_l\\) for \\(1 \\le l \\le K+1\\).\n3. Implement with sorting and a for loop, with a total time complexity of \\(O(N \\log N)\\).\n\nSample code (Python3):\n\n```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\nres = int(2e9)\nfor i in range(k + 1):\n    res = min(res, a[i + (n - k) - 1] - a[i])\n\nprint(res)\n```\n \n\n", "problem_ids": ["abc355_d", "abc363_f", "abc361_c"]}, "abc327_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given \\(N\\) strings \\(S_1, S_2, \\ldots, S_N\\) consisting of lowercase English letters and \\(N\\) positive integers \\(A_1, A_2, \\ldots, A_N\\).\n\nA subset \\(T\\) of \\(\\{1, 2, \\ldots, N\\}\\) is called a **good set** if there is no pair \\(i, j \\in T\\) (\\(i \\neq j\\)) such that \\(S_i\\) is a substring of \\(S_j\\).\n\nFind the maximum possible value of \\(\\sum_{i \\in T} A_i\\) for a good set \\(T\\).\n\n### What is a substring?\n\nA **substring** of a string \\(S\\) is a string obtained by deleting zero or more characters from the beginning and zero or more characters from the end of \\(S\\). For example, `ab` is a substring of `abc`, but `ac` is not a substring of `abc`.\n\n### Constraints\n\n- \\(1 \\leq N \\leq 100\\)\n- \\(S_i\\) is a string consisting of lowercase English letters.\n- \\(1 \\leq |S_i|\\)\n- \\(|S_1| + |S_2| + \\ldots + |S_N| \\leq 5000\\)\n- \\(1 \\leq A_i \\leq 10^9\\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1\nS_2\n.\n.\n.\nS_N\nA_1 A_2 ... A_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n4\natcoder\nat\ncoder\ncode\n5 2 3 4\n```\n\n### Sample Output 1\n\n```\n6\n```\n\nThe possible good sets \\(T\\) and their corresponding \\(\\sum_{i \\in T} A_i\\) are as follows:\n\n- \\(T = \\{1\\}\\): \\(\\sum_{i \\in T} A_i = 5\\)\n- \\(T = \\{2\\}\\): \\(\\sum_{i \\in T} A_i = 2\\)\n- \\(T = \\{3\\}\\): \\(\\sum_{i \\in T} A_i = 3\\)\n- \\(T = \\{4\\}\\): \\(\\sum_{i \\in T} A_i = 4\\)\n- \\(T = \\{2, 3\\}\\): \\(\\sum_{i \\in T} A_i = 5\\)\n- \\(T = \\{2, 4\\}\\): \\(\\sum_{i \\in T} A_i = 6\\)\n\nThe maximum among them is 6, so print 6.\n\n### Sample Input 2\n\n```\n10\nabcd\nabc\nab\na\nb\nc\nd\nab\nbc\ncd\n100 10 50 30 60 90 80 70 40 20\n```\n\n### Sample Output 2\n\n```\n260\n```\n\nSolution:\n\n        Editorial - Panasonic Programming Contest 2024 (AtCoder Beginner Contest 354)\n\nFor simplicity, assume \\(S_i \\neq S_j (i \\neq j)\\). Consider an \\(N\\)-vertex graph \\(G\\) with a directed edge from vertex \\(i\\) to vertex \\(j\\) if \\(S_i\\) is a substring of \\(S_j\\) for given \\(S_1, S_2, \\ldots, S_N\\). Then, \\(G\\) forms a DAG (Directed Acyclic Graph). Suppose each vertex has a weight of \\(A_1, A_2, \\ldots, A_n\\). The problem can be rephrased as follows: You are given a vertex-weighted \\(N\\)-vertex DAG \\(G\\). Choose some vertices without including a pair that has a path between them and find the maximum total weight of the chosen vertices.\n\nIgnoring weights, maximize the number of chosen vertices. If \\(G\\) has edges from vertex \\(i\\) \\(\\to\\) vertex \\(j\\) and vertex \\(j\\) \\(\\to\\) vertex \\(k\\), then it also has an edge from vertex \\(i\\) \\(\\to\\) vertex \\(k\\). Use Dilworth\u2019s theorem, which states that the size of a minimum path cover equals the size of a maximum independent set in such a DAG.\n\nFor an unweighted graph, find the size of a maximum independent set or a minimum path cover. The minimum path cover can be reduced to the maximum matching of a bipartite graph. Consider the \\(N\\)-vertex DAG \\(G\\) as a bipartite graph \\(H\\) with left vertices \\(1, 2, \\ldots, N\\) and right vertices \\(1', 2', \\ldots, N'\\). Then, \\(N - (\\text{maximum matching of }H) = (\\text{size of a minimum path cover of }G)\\). Thus, minimize the size of a path cover by maximizing the number of edges in it, corresponding to a maximum matching problem on the bipartite graph.\n\nFor the weighted problem, where we need the maximum total weight of the chosen vertices, set the maximum capacity of each edge \\(S \\to v\\) and \\(v' \\to T\\) to \\(A_v\\) and of \\(i \\to j'\\) to \\(\\infty\\). The solution is \\((\\sum A_i - (\\text{maximum flow of }S \\to T))\\). In implementation, handle edges between vertices \\(i\\) and \\(j\\) with identical strings by adding edges \\(i \\to j\\) if \\(S_i = S_j\\) and \\(i < j\\).\n\nTime complexity: Determine if \\(S_i\\) is a substring of \\(S_j\\) for all pairs \\(i, j\\) in \\(O(N^{2} + (\\sum |S_i|)^{2})\\), and find the maximum flow for a bipartite graph with \\(O(N)\\) vertices and \\(O(N^{2})\\) edges in \\(O(N^{4})\\), resulting in a total time complexity of \\(O(N^{4} + (\\sum |S_i|)^{2})\\).\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\nYou can perform the following two types of operations zero or more times in any order:\n\n1. Choose a (contiguous) substring \\( ABA \\) in \\( S \\) and replace it with \\( A \\).\n2. Choose a (contiguous) substring \\( BAB \\) in \\( S \\) and replace it with \\( B \\).\n\nFind, modulo \\( 10^9+7 \\), the number of possible strings \\( S \\) after performing the operations.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 250000 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n4\nABAB\n```\n\n**Sample Output 1**\n\n```\n2\n```\n\nThe two possible strings \\( S \\) after the operations are as follows:\n- \\( ABAB \\): This string can be obtained by performing zero operations.\n- \\( AB \\): The 1st to 3rd characters of \\( S=ABAB \\) are \\( ABA \\). Replacing them with \\( A \\) results in \\( S=AB \\).\n\nHere, the 2nd to 4th characters of \\( S=ABAB \\) are \\( BAB \\), so you can also replace them with \\( B \\). Note, however, that the resulting \\( AB \\) does not count multiple times.\n\n**Sample Input 2**\n\n```\n1\nA\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\nNo operations can be performed.\n\n**Sample Input 3**\n\n```\n17\nBBABABAABABAAAABA\n```\n\n**Sample Output 3**\n\n```\n18\n```\n\n**Sample Input 4**\n\n```\n100\nABAABAABABBABAABAABAABABBABBABBABBABBABBABBABBABBABBABBABBABBABAABABAABABBABBABABBABAABAABAABAABA\n```\n\n**Sample Output 4**\n\n```\n415919090\n```\n\nRemember to take the result modulo \\( 10^9+7 \\).\n\nSolution:\n\n```\nIn competitive programming, a well-known technique is using parity to perform inversions. Let\u2019s apply it to this problem. Specifically, let\u2019s invert the characters A and B only at even positions in the input string. Then, the two available operations become:\n\nAAA \u2192 A  \nBBB \u2192 B  \n\nWith this transformation, the solution becomes straightforward. For a contiguous segment of A or B, as long as its length does not become zero, we can reduce the length by 2 each time. For example, if there is a segment AAAAA, the possible final states are AAAAA, AAA, and A: there are three. Therefore, if the length of a segment of consecutive identical characters is L, the number of possible final states for that segment is floor((L+1)/2). For all segments of consecutive identical characters, the final states can be chosen independently. Thus, the product of the above values for all such segments is the answer to this problem.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 800 points\n\nProblem Statement: For positive integers \\(h\\) and \\(w\\), let \\((h, w)\\) denote a rectangle with height \\(h\\) and width \\(w\\). In this problem, rectangles are not considered to be rotatable, thus the rectangles \\((h, w)\\) and \\((w, h)\\) are considered different if \\(h \\neq w\\).\n\nA sequence of rectangles \\(((h_1, w_1), (h_2, w_2), \\dots, (h_n, w_n))\\) is called a **rectangle generation sequence** if there is a method that successfully follows the steps below:\n\n1. Let the rectangle \\(X\\) be \\((h_1, w_1)\\). Hereafter, let \\(H\\) and \\(W\\) denote the height and width of the rectangle \\(X\\) at each step.\n2. For \\(i = 2, 3, \\dots, n\\), perform one of the following operations. If neither can be performed, the procedure terminates unsuccessfully:\n   - If the height of \\(X\\) is equal to \\(h_i\\), attach the rectangle \\((h_i, w_i)\\) horizontally to \\(X\\). Formally, if \\(H = h_i\\) at that time, replace \\(X\\) with the rectangle \\((H, W + w_i)\\).\n   - If the width of \\(X\\) is equal to \\(w_i\\), attach the rectangle \\((h_i, w_i)\\) vertically to \\(X\\). Formally, if \\(W = w_i\\) at that time, replace \\(X\\) with the rectangle \\((H + h_i, W)\\).\n3. If the above series of operations does not fail, the procedure terminates successfully.\n\nYou are given \\(N\\) rectangles. The \\(i\\)-th rectangle has a height of \\(H_i\\) and a width of \\(W_i\\).\n\nFind the number of pairs of positive integers \\((l, r)\\) that satisfy \\(1 \\le l \\le r \\le N\\) and the following condition:\n\n- The sequence of rectangles \\(((H_l, W_l), (H_{l+1}, W_{l+1}), \\dots, (H_r, W_r))\\) is a rectangle generation sequence.\n\nConstraints:\n- \\(1 \\leq N \\leq 3 \\times 10^5\\)\n- \\(1 \\leq H_i, W_i \\leq 10^6\\)\n- All input values are integers.\n\nInput: The input is given from Standard Input in the following format:\n```\nN\nH_1 W_1\nH_2 W_2\n...\nH_N W_N\n```\n\nOutput: Print the answer.\n\nSample Input 1:\n```\n4\n1 2\n1 3\n2 3\n3 1\n```\n\nSample Output 1:\n```\n7\n```\nThe pairs \\((l, r)\\) that satisfy the condition are \\((1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (4, 4)\\); there are seven. For example, for \\((l, r) = (2, 4)\\), the procedure succeeds if the first attachment is done vertically and the second is done horizontally.\n\nSample Input 2:\n```\n5\n2 1\n2 1\n1 2\n3 2\n1 4\n```\n\nSample Output 2:\n```\n10\n```\n\nSample Input 3:\n```\n1\n1000000 1000000\n```\n\nSample Output 3:\n```\n1\n```\n\nSample Input 4:\n```\n10\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\nSample Output 4:\n```\n55\n```\n\nSolution:\n\n[BEGIN TEXT]\nObservation of Combining Rectangles: Let\u2019s consider combining rectangles consecutively. Starting from \\((h_1, w_1)\\), we combine \\((h_2, w_2)\\), and then continue to combine \\((h_3, w_3)\\). The condition is that if \\((h_2, w_2)\\) can be combined vertically/horizontally, then \\((h_3, w_3)\\) can also be combined similarly. For example, when \\(h_2 = h_3\\), if \\((h_2, w_2)\\) can be combined horizontally, then \\((h_3, w_3)\\) can also be combined horizontally. Similarly, when \\(w_2 = w_3\\), if \\((h_2, w_2)\\) can be combined vertically, then \\((h_3, w_3)\\) can also be combined vertically. \n\nCorrespondence to Graph and Counting: Let\u2019s count the number of pairs \\((l, r)\\) that satisfy the condition. When \\(l\\) is fixed, whether \\((l, r)\\) satisfies the condition is monotonic with respect to \\(r\\). For the orientation of the combination of two consecutive rectangles, we can determine whether the latter can be combined if the former can be combined. Represent this information in a graph with \\(2 \\times N\\) vertices.\n\nFor \\(i = 1, 2, \\dots, N\\), let vertex \\(i\\) represent that \\((H_i, W_i)\\) can be combined vertically, and vertex \\(N + i\\) represent that \\((H_i, W_i)\\) can be combined horizontally. For \\(i = 2, 3, \\dots, N\\):\n\n- If \\((H_{i-1}, W_{i-1})\\) can be combined vertically, and \\((H_i, W_i)\\) can also be combined vertically, span an edge between vertices \\(i-1\\) and \\(i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined vertically, and \\((H_i, W_i)\\) can be combined horizontally, span an edge between vertices \\(i-1\\) and \\(N + i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined horizontally, and \\((H_i, W_i)\\) can be combined vertically, span an edge between vertices \\(N + i - 1\\) and \\(i\\).\n- If \\((H_{i-1}, W_{i-1})\\) can be combined horizontally, and \\((H_i, W_i)\\) can be combined horizontally, span an edge between vertices \\(N + i - 1\\) and \\(N + i\\).\n\nAssume that \\((H_l, W_l)\\) can be combined both horizontally and vertically. Then, \\((l, r)\\) satisfies the condition if and only if either vertex \\(l\\) or \\(N + l\\) is connected to either vertex \\(r\\) or \\(N + r\\). Edges corresponding to combinations with different orientations will be spanned for at most one \\(l\\). Edges corresponding to combinations with the same orientation will be spanned for any \\(l\\) if they are initially spanned.\n\nRepresent the edges of the graph as a \\(2 \\times 2\\) matrix and load it on a segment tree. By performing binary search on the segment tree to find the maximum \\(r\\) that satisfies the condition, and updating the graph with segment tree updates, we process all \\(l\\) in \\(\\mathrm{O}(N \\log N)\\) time complexity.\n[END TEXT]\n \n\n", "problem_ids": ["abc354_g", "arc180_a", "arc179_e"]}, "abc328_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two strings, \\( S \\) and \\( T \\), consisting of lowercase English letters. Determine if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the following condition is satisfied. Here, \\( |S| \\) denotes the length of the string \\( S \\). Note that \\( w \\) must be less than \\( |S| \\).\n\n- If \\( S \\) is split at every \\( w \\) characters from the beginning, the concatenation of the \\( c \\)-th characters of the substrings of length at least \\( c \\) in order equals \\( T \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters.\n- \\( 1 \\leq |T| \\leq |S| \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nPrint `Yes` if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the condition is satisfied, and `No` otherwise.\n\n**Sample Input 1**\n```\natcoder toe\n```\n\n**Sample Output 1**\n```\nYes\n```\n\nExplanation: If \\( S \\) is split at every two characters, it looks like this:\n```\nat\nco\nde\nr\n```\nThen, the concatenation of the 2nd characters of the substrings of length at least 2 is `toe`, which equals \\( T \\). Thus, print `Yes`.\n\n**Sample Input 2**\n```\nbeginner r\n```\n\n**Sample Output 2**\n```\nNo\n```\n\nExplanation: \\( w = |S| \\) is not allowed, and no pair of integers \\( 1 \\leq c \\leq w < |S| \\) satisfies the condition. Thus, print `No`.\n\n**Sample Input 3**\n```\nverticalreading agh\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        Below is a clean version of the text with only the relevant solution details:\n\nEnumerate all possible \\(c\\) and \\(w\\), and determine if a conforming pair \\(c,w\\) exists. One can construct a string for \\(c\\) and \\(w\\) using a for statement and concatenation of strings. For more details, please refer to the sample code.\n\nSample code (Python 3):\n\n```python\ndef main():\n    s = input().strip()\n    t = input().strip()\n    for w in range(1, len(s)):\n        for c in range(w):\n            now = \"\"\n            for i in range(c, len(s), w):\n                now += s[i]\n            if now == t:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integer sequences of length \\( N \\): \\( A = (A_1, A_2, \\cdots, A_N) \\) and \\( B = (B_1, B_2, \\cdots, B_N) \\), and an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n- Choose integers \\( i \\) and \\( j \\) (where \\( 1 \\leq i, j \\leq N \\)) such that \\( |i-j| \\leq K \\). Then, change the value of \\( A_i \\) to \\( A_j \\).\n\nDetermine whether it is possible to make \\( A \\) identical to \\( B \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 125000 \\)\n- \\( 1 \\leq K < N \\leq 250000 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- The sum of \\( N \\) across all test cases in each input is at most 250000.\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\nB_1 B_2 \\cdots B_N\n```\n\n**Output Format**\n\nFor each test case, print `Yes` if it is possible to make \\( A \\) identical to \\( B \\), and `No` otherwise.\n\n**Sample Input 1**\n\n```\n4\n3 1\n1 1 2\n1 2 2\n5 4\n2 4 5 1 3\n2 1 3 2 2\n13 1\n3 1 3 3 5 3 3 4 2 2 2 5 1\n5 3 3 3 4 2 2 2 2 5 5 1 3\n20 14\n10 6 6 19 13 16 15 15 2 10 2 16 9 12 2 6 13 5 5 9\n5 9 6 2 10 19 16 15 13 12 10 2 9 6 5 16 19 12 15 13\n```\n\n**Sample Output 1**\n\n```\nYes\nYes\nNo\nYes\n```\n\n**Explanation for Sample Input 1**\n\nConsider the first test case. If we operate with \\( i=2 \\) and \\( j=3 \\), the value of \\( A_2 \\) will be changed to \\( A_3=2 \\), resulting in \\( A=(1,2,2) \\).\n\nSolution:\n\n```\nOfficial\n\nB - Near Assignment Editorial by evima\n\nIf \\(A = B\\), it is clearly possible, so we consider other cases. Consider two cases based on the value of \\(K\\).\n\nCase \\(K = 1\\): Considering the result of run-length encoding of the elements in \\(A\\), it can \u201cdecrease\u201d through operations, but not \u201cincrease.\u201d From this, we can deduce that the result of run-length encoding of \\(B\\) must be a subsequence of the run-length encoded \\(A\\). This condition is also sufficient because we can perform operations that extend the subsequence of \\(A\\) corresponding to \\(B\\). This solves the case where \\(K = 1\\).\n\nCase \\(K \\geq 2\\): Looking at the operations in reverse, they can be seen as follows:\n\nChoose \\(i,j\\) that satisfy \\(|i-j| \\leq K\\) and \\(B_i = B_j\\), then change \\(B_i\\) to any desired value. First, if no operation can be performed on \\(B\\), the answer is No. Also, if there is a value in \\(B\\) that does not appear in \\(A\\), the answer is No. Actually, in all other cases, the answer is Yes. Let\u2019s reinterpret the part where \\(B_i\\) can be changed to any desired value as an operation where \\(B_i\\) is changed to a wildcard \\(*\\). By performing one operation on \\(B\\), we create a state where there is exactly one \\(*\\). The involvement of \\(*\\) enables us to swap adjacent elements in \\(B\\).\n\nIf you want to change \\(*x\\) to \\(x*\\): think of \\(*x\\) as \\(xx\\) and perform the operation to turn it into \\(x*\\). If you want to change \\(*xy\\) to \\(*yx\\): follow the steps \\(*xy \\to yxy \\to yx* \\to y*x \\to *yx\\).\n\nBy combining these operations, you can remove all duplicates in \\(B\\) and arrange them in any desired order. In particular, you can arrange \\(B\\) to match \\(A\\). Therefore, it can be determined that \\(A\\) can be transformed into \\(B\\). Implementing the above operations directly yields an \\(O(N)\\) solution. The sample code below lazily uses sorting and is an \\(O(N\\log N)\\) solution.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n---\n\n**Problem Statement**\n\nYou are given permutations \\(P = (P_1, P_2, \\ldots, P_N)\\) and \\(A = (A_1, A_2, \\ldots, A_N)\\) of \\((1, 2, \\ldots, N)\\).\n\nYou can perform the following operation any number of times, possibly zero: replace \\(A_i\\) with \\(A_{P_i}\\) simultaneously for all \\(i = 1, 2, \\ldots, N\\).\n\nPrint the lexicographically smallest \\(A\\) that can be obtained.\n\n---\n\n**What is lexicographical order?**\n\nFor sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\), \\(A\\) is lexicographically smaller than \\(B\\) if and only if there exists an integer \\(i\\) (1 \u2264 i \u2264 N) such that \\(A_i < B_i\\), and \\(A_j = B_j\\) for all \\(1 \\leq j < i\\).\n\n---\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n\n- \\(1 \\leq P_i \\leq N\\) (1 \u2264 i \u2264 N)\n\n- \\(P_i \\neq P_j\\) (1 \u2264 i < j \u2264 N)\n\n- \\(1 \\leq A_i \\leq N\\) (1 \u2264 i \u2264 N)\n\n- \\(A_i \\neq A_j\\) (1 \u2264 i < j \u2264 N)\n\nAll input values are integers.\n\n---\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nP_1 P_2 \\ldots P_N\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet \\( (A_1, A_2, \\ldots, A_N) \\) be the lexicographically smallest \\(A\\) that can be obtained. Print \\(A_1, A_2, \\ldots, A_N\\) in this order, separated by spaces, in one line.\n\n---\n\n**Sample Input 1**\n\n```\n6\n3 1 5 6 2 4\n4 3 1 6 2 5\n```\n\n**Sample Output 1**\n\n```\n1 4 2 5 3 6\n```\n\nInitially, \\(A = (4, 3, 1, 6, 2, 5)\\). Repeating the operation yields the following:\n- \\(A = (1, 4, 2, 5, 3, 6)\\)\n- \\(A = (2, 1, 3, 6, 4, 5)\\)\n- \\(A = (3, 2, 4, 5, 1, 6)\\)\n- \\(A = (4, 3, 1, 6, 2, 5)\\)\n\nAfter this, \\(A\\) will revert to the original state every four operations. Therefore, print the lexicographically smallest among these, which is `1 4 2 5 3 6`.\n\n---\n\n**Sample Input 2**\n\n```\n8\n3 5 8 7 2 6 1 4\n1 2 3 4 5 6 7 8\n```\n\n**Sample Output 2**\n\n```\n1 2 3 4 5 6 7 8\n```\n\nYou may choose to perform no operations.\n\n---\n\n**Sample Input 3**\n\n```\n26\n24 14 4 20 15 19 16 11 23 22 12 18 21 3 6 8 26 2 25 7 13 1 5 9 17 10\n15 3 10 1 13 19 22 24 20 4 14 23 7 26 25 18 11 6 9 12 2 21 5 16 8 17\n```\n\n**Sample Output 3**\n\n```\n4 1 22 18 20 13 14 6 15 11 3 26 2 12 5 23 9 10 25 24 7 17 16 21 19 8\n```\n\n\nSolution:\n\n```\nG - Lexicographically Smallest Permutation Editorial\n\nTo solve this problem, we consider minimizing elements sequentially, starting with the first. The key is to determine cycles in the permutation \\(P\\), and within each cycle, find the lexicographically smallest permutation. For a cycle with length \\(L\\), the number of minimal positions is \\(L / \\gcd(L, \\text{period})\\). We choose the minimal lexicographical arrangement by evaluating potential positions and adjusting the operation count \\(ans\\) accordingly. The process involves updating a result array based on minimized operations for each cycle, taking care of integer operations due to potential size. Here is the sample code:\n\n```python\nfrom math import gcd\n\nN = int(input())\nP = [int(x) - 1 for x in input().split()]\nA = list(map(int, input().split()))\n\nused = [False for i in range(N)]\n\nperiod = 1\nans = 0\n\nresult = [0 for i in range(N)]\n\nfor i in range(N):\n    if not used[i]:\n        cycle = [i]\n        while P[cycle[-1]] != i:\n            used[P[cycle[-1]]] = True\n            cycle.append(P[cycle[-1]])\n            \n        L = len(cycle)\n        choose = L // gcd(L, period)\n        offset = min((A[cycle[(ans + i * period) % L]], i) for i in range(choose))[1]\n        \n        ans += offset * period\n        period *= choose\n        \n        for i in range(L):\n            result[cycle[i]] = A[cycle[(i + ans) % L]]\n\nprint(*result)\n```\nThis effectively computes the lexicographically smallest permutation using the described method.\n```\n \n\n", "problem_ids": ["abc360_b", "arc183_b", "abc371_g"]}, "abc328_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( N \\) and a sequence of \\( M \\) positive integers \\( A = (A_1, A_2, \\ldots, A_M) \\). All elements of \\( A \\) are distinct integers between \\( 1 \\) and \\( N \\), inclusive.\n\nA permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) is called a *good permutation* if it satisfies the following condition for all integers \\( i \\) such that \\( 1 \\leq i \\leq M \\):\n\n- No contiguous subsequence of \\( P \\) is a permutation of \\( (1, 2, \\ldots, A_i) \\).\n\nDetermine whether a *good permutation* exists, and if it does, find the lexicographically smallest *good permutation*.\n\n**What is lexicographical order?**\n\nA sequence \\( S = (S_1, S_2, \\ldots, S_{|S|}) \\) is said to be *lexicographically smaller* than a sequence \\( T = (T_1, T_2, \\ldots, T_{|T|}) \\) if one of the following conditions holds:\n\n1. \\( |S| < |T| \\) and \\( (S_1, S_2, \\ldots, S_{|S|}) = (T_1, T_2, \\ldots, T_{|S|}) \\).\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|S|, |T|\\} \\) such that both of the following hold:\n   - \\( (S_1, S_2, \\ldots, S_{i-1}) = (T_1, T_2, \\ldots, T_{i-1}) \\).\n   - \\( S_i \\) is smaller than \\( T_i \\) (as a number).\n\n**Constraints**\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All elements of \\( A \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\cdots A_M\n```\n\n**Output**\n\nIf a *good permutation* does not exist, print `-1`.  \nIf it exists, print the lexicographically smallest *good permutation*, separated by spaces.\n\n**Sample Input 1**\n```\n4 1\n2\n```\n\n**Sample Output 1**\n```\n1 3 2 4\n```\n\nFor example, \\( (4, 2, 1, 3) \\) is not a *good permutation* because it contains \\( (2, 1) \\) as a contiguous subsequence. Other non-*good permutations* are \\( (1, 2, 3, 4) \\) and \\( (3, 4, 2, 1) \\). Some *good permutations* are \\( (4, 1, 3, 2) \\) and \\( (2, 3, 4, 1) \\). Among these, the lexicographically smallest one is \\( (1, 3, 2, 4) \\), so print it separated by spaces.\n\n**Sample Input 2**\n```\n5 3\n4 3 2\n```\n\n**Sample Output 2**\n```\n1 3 4 5 2\n```\n\nExamples of *good permutations* include \\( (3, 4, 1, 5, 2) \\), \\( (2, 4, 5, 3, 1) \\), and \\( (4, 1, 5, 2, 3) \\). Examples of non-*good permutations* include \\( (1, 2, 5, 3, 4) \\), \\( (2, 3, 4, 1, 5) \\), and \\( (5, 3, 1, 2, 4) \\).\n\n**Sample Input 3**\n```\n92 4\n16 7 1 67\n```\n\n**Sample Output 3**\n```\n-1\n```\n\nIf a *good permutation* does not exist, print `-1`.\n\n**Sample Input 4**\n```\n43 2\n43 2\n```\n\n**Sample Output 4**\n```\n-1\n```\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nA - Good Permutation 2 Editorial by evima\n\nIf \\(A\\) contains either \\(1\\) or \\(N\\), a good permutation does not exist. Conversely, if neither \\(1\\) nor \\(N\\) is included in \\(A\\), a good permutation does exist. Let\u2019s consider this case. For example, if we set \\(P = (1, N, N - 1, N - 2, \\dots, 3, 2)\\), the only contiguous subsequence of \\(P\\) that includes both \\(1\\) and \\(2\\) is \\(P\\) itself, making \\(P\\) a good permutation. \n\nSince a good permutation with \\(P_{1} = 1\\) exists, the lexicographically smallest good permutation will have \\(P_{1} = 1\\). For any integer \\(x\\), if there exists a contiguous subsequence of \\(P\\) that is a permutation of \\((1, 2, \\dots, x)\\), it must be \\((P_{1}, P_{2}, \\dots, P_{x})\\). We determine \\(P_{i}\\) for \\(i \\neq 1\\) in ascending order of \\(i\\). When deciding \\(P_{i}\\), assume that all of \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\) are at most \\(i\\). Let \\(a\\) be the number that is at most \\(i\\) and not included in \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\).\n\nWhen \\(i\\) is included in \\(A\\):\nTo make the permutation lexicographically smallest, set \\(P_{i} = i + 1\\). Since \\(P_{i}\\) is not greater than \\(i + 1\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) does not change.\n\nWhen \\(i\\) is not included in \\(A\\):\nSet \\(P_{i} = a\\). Since this number is not greater than \\(i\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) becomes \\(i + 1\\).\n\nThe time complexity is \\(O(N)\\).\n\n```python\n# input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nban = [0] * N\nfor a in A:\n    ban[a - 1] = 1\n\n# impossible\nif ban[0] or ban[N - 1]:\n    print(-1)\n    quit()\n\n# init\nP = [0] * N\nP[0] = 1\na = 2\n\n# calc\nfor i in range(1, N):\n    if ban[i] == 1:\n        P[i] = i + 2\n    else:\n        P[i] = a\n        a = i + 2\n\n# output\nprint(*P)\n```\n\nYou can also construct the permutation as follows: Initialize \\(P = (1, 2, \\dots, N)\\), and for \\(i = 2, 3, \\dots, N - 1\\), perform the following operation: If \\(i\\) is included in \\(A\\), do \\(\\text{swap}(P_{i}, P_{i + 1})\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere is a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i,j)\\) denote the cell at the \\(i\\)-th row from the top and \\(j\\)-th column from the left. There are \\(N\\) coins on this grid, and the \\(i\\)-th coin can be picked up by passing through the cell \\((R_i,C_i)\\).\n\nYour goal is to start from cell \\((1,1)\\), repeatedly move either down or right by one cell, and reach cell \\((H,W)\\) while picking up as many coins as possible.\n\nFind the maximum number of coins you can pick up and one of the paths that achieves this maximum.\n\nConstraints:\n- \\(2 \\leq H, W \\leq 2 \\times 10^5\\)\n- \\(1 \\leq N \\leq \\min(HW-2, 2 \\times 10^5)\\)\n- \\(1 \\leq R_i \\leq H\\)\n- \\(1 \\leq C_i \\leq W\\)\n- \\((R_i, C_i) \\neq (1,1)\\)\n- \\((R_i, C_i) \\neq (H,W)\\)\n- \\((R_i, C_i)\\) are pairwise distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format: \n```\nH W N\nR_1 C_1\nR_2 C_2\n\u22ee\nR_N C_N\n```\n\nOutput:\nPrint two lines.\n- The first line should contain the maximum number of coins you can pick up.\n- The second line should contain one of the paths that achieves this maximum as a string of length \\(H+W-2\\). The \\(i\\)-th character of this string should be `D` if the \\(i\\)-th move is downward, and `R` if it is rightward.\n\nIf there are multiple paths that maximize the number of coins picked up, you may print any of them.\n\nSample Input 1:\n```\n3 4 4\n3 3\n2 1\n2 3\n1 4\n```\n\nSample Output 1:\n```\n3\nDRRDR\n```\nAs shown in the figure above, by moving \\((1,1)\\rightarrow (2,1)\\rightarrow (2,2)\\rightarrow (2,3)\\rightarrow (3,3)\\rightarrow (3,4)\\), you can pick up three coins at \\((2,1),(2,3),(3,3)\\).\n\nSample Input 2:\n```\n2 2 2\n2 1\n1 2\n```\n\nSample Output 2:\n```\n1\nDR\n```\nThe path `RD` is also acceptable.\n\nSample Input 3:\n```\n10 15 8\n2 7\n2 9\n7 9\n10 3\n7 11\n8 12\n9 6\n8 1\n```\n\nSample Output 3:\n```\n5\nDRRRRRRRRDDDDDRRDRDDRRR\n```\n\nSolution:\n\n```\nHere is the cleaned editorial without excess content unrelated to the solution:\n\n---\n\nLet us call the coin that can be collected by passing through square \\((r,c)\\) simply coin \\((r,c)\\). Given \\(k\\) coins \\((r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)\\), one can determine if there is a path that can collect all the coins as follows:\n\nSort the coins in ascending order of \\((r,c)\\). Here, \\((r_i, c_i) < (r_j, c_j) \\Leftrightarrow (r_i < r_j) \\lor (r_i = r_j \\land c_i < c_j)\\). Let \\(((r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k))\\) be the resulting sequence. There exists a path that can collect all the given \\(k\\) coins if and only if \\(c'_1 \\leq c'_2 \\leq \\dots \\leq c'_k\\).\n\nProof: If two coins $i$ and $j$ with $(r_i, c_i) < (r_j, c_j)$ are to be collected, coin $i$ has to be collected first. Thus, the $k$ coins $(r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)$ can be all collected if and only if the $k$ coins $(r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k)$ can be collected **in this order**. Given $(r_i, c_i) < (r_j, c_j)$, we have $(r_i \\leq r_j \\land c_i \\leq c_j) \\Leftrightarrow c_i \\leq c_j$, so the claim above has been shown.\n\nSuppose that the given \\(N\\) coins are sorted in ascending order of \\((r,c)\\). Then, by the fact above, this problem is boiled down to finding a longest (weakly) increasing subsequence (LIS). Given positive integer sequence \\(c=(c_1,c_2,\\dots,c_N)\\), one can find the length of a LIS of \\(c\\) (not its length) by the following famous algorithm:\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\). The length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\).\n\nIntuitively, each \\(d_j\\) manages the smallest last element of a length-\\(j\\) (weakly) increasing subsequence of \\(c_1,c_2,\\dots,c_i\\) (or \\(\\infty\\) if there is no such subsequence). To find an example of LIS instead of its length only, let us modify the algorithm as follows.\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Prepare a length-\\(N\\) sequence \\(\\text{id}\\) and \\(\\text{pre}\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\), and replace \\(\\text{id}_j\\) with \\(i\\). If \\(j > 1\\), replace \\(\\text{pre}_i\\) with \\(\\text{id}_{j-1}\\) too.\n\nThe length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\). Let \\(l\\) be the length of a LIS of \\(c\\). Consider a length-\\(l\\) sequence obtained by applying \\((l-1)\\) times the action \\(i\\mapsto \\text{pre}_i\\) to \\(\\text{id}_l\\), namely \\((\\text{id}_l, \\text{pre}_{\\text{id}_l},\\text{pre}_{\\text{pre}_{\\text{id}_l}},\\dots)\\). The reversal of this sequence is an example of a LIS of \\(c\\).\n\nThe fact that an example of LIS can be indeed obtained using this algorithm can be proved inductively. The complexity of this algorithm is \\(O(N\\log N)\\), same as the original algorithm. (To find the minimum \\(j\\) in step \\(3\\), use binary search.) Thus, the problem has been solved.\n\nSample code (Python3):\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    h, w, n = map(int, sys.stdin.readline().strip().split())\n    coins = []\n    for _ in range(n):\n        r, c = map(int, sys.stdin.readline().strip().split())\n        coins.append((r, c))\n    coins.sort()\n    dp = [float('inf')] * n\n    id_list = [-1] * n\n    pre = [0] * n\n    for i in range(n):\n        it = bisect_right(dp, coins[i][1])\n        dp[it] = coins[i][1]\n        id_list[it] = i\n        pre[i] = id_list[it - 1] if it else -1\n    m = n - 1\n    while id_list[m] == -1:\n        m -= 1\n    path = [(h, w)]\n    now = id_list[m]\n    while now != -1:\n        path.append(coins[now])\n        now = pre[now]\n    path.append((1, 1))\n    path.reverse()\n    s = []\n    for i in range(len(path) - 1):\n        d = path[i + 1][0] - path[i][0]\n        r = path[i + 1][1] - path[i][1]\n        s.append('D' * d + 'R' * r)\n    print(m + 1)\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi has a piano with 100 keys arranged in a row. The i-th key from the left is called key i.\n\nHe will play music by pressing N keys one by one. For the i-th press, he will press key \\( A_i \\), using his left hand if \\( S_i = L \\), and his right hand if \\( S_i = R \\).\n\nBefore starting to play, he can place both of his hands on any keys he likes, and his fatigue level at this point is 0. During the performance, if he moves one hand from key x to key y, the fatigue level increases by \\(|y-x|\\) (the fatigue level does not increase for any reason other than moving hands). To press a certain key with a hand, that hand must be placed on that key.\n\nFind the minimum possible fatigue level at the end of the performance.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq 100 \\)\n- \\( N \\) and \\( A_i \\) are integers.\n- \\( S_i \\) is 'L' or 'R'.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 S_1\nA_2 S_2\n...\nA_N S_N\n```\n\n**Output**\n\nPrint the minimum fatigue level at the end of the performance.\n\n**Sample Input 1**\n```\n4\n3 L\n6 R\n9 L\n1 R\n```\n\n**Sample Output 1**\n```\n11\n```\n\nFor example, the performance can be done as follows:\n- Initially, place the left hand on key 3 and the right hand on key 6.\n- Press key 3 with the left hand.\n- Press key 6 with the right hand.\n- Move the left hand from key 3 to key 9. The fatigue level increases by \\(|9-3| = 6\\).\n- Move the right hand from key 6 to key 1. The fatigue level increases by \\(|1-6| = 5\\).\n- Press key 9 with the left hand.\n- Press key 1 with the right hand.\n\nIn this case, the fatigue level at the end of the performance is \\(6 + 5 = 11\\), which is the minimum possible.\n\n**Sample Input 2**\n```\n3\n2 L\n2 L\n100 L\n```\n\n**Sample Output 2**\n```\n98\n```\n\n**Sample Input 3**\n```\n8\n22 L\n75 L\n26 R\n45 R\n72 R\n81 R\n47 L\n29 R\n```\n\n**Sample Output 3**\n```\n188\n```\n\nSolution:\n\n```\nEditorial - B - Piano 3\n\nManage the positions of left and right hands while inspecting the key to press for \\(1,2,\\dots,N\\)-th press, and add the fatigue level of each move required. In the sample code, an array \\(\\text{pos}\\) of length two is prepared, with \\(pos[0]\\) and \\(pos[1]\\) managing the current positions of left and right hands, respectively. Initial positions are set to \\(-1\\), and no fatigue is added when moving a hand from \\(-1\\) to another key. This simulates placing a hand at the first key to be pressed by that hand.\n\nSample code (Python):\n```python\nn = int(input())\npos = [-1, -1]   # 0: left, 1: right\nans = 0\nfor i in range(n):\n    a, s = input().split()\n    a = int(a)\n    hand = (0 if s == 'L' else 1)\n    if pos[hand] != -1:\n        ans += abs(pos[hand] - a)\n    pos[hand] = a\nprint(ans)\n```\n```\n \n\n", "problem_ids": ["arc178_a", "abc369_f", "abc369_b"]}, "abc328_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 300 points\n\nProblem Statement:\n\nIn AtCoder Land, there are \\( N \\) popcorn stands numbered from 1 to \\( N \\). They have \\( M \\) different flavors of popcorn, labeled from 1 to \\( M \\). However, not every stand sells all flavors of popcorn.\n\nTakahashi has obtained information about which flavors of popcorn are sold at each stand. This information is represented by \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\), each of length \\( M \\). If the \\( j \\)-th character of \\( S_i \\) is 'o', it means that stand \\( i \\) sells flavor \\( j \\) of popcorn. If it is 'x', it means that stand \\( i \\) does not sell flavor \\( j \\). Each stand sells at least one flavor of popcorn, and each flavor of popcorn is sold at least at one stand.\n\nTakahashi wants to try all the flavors of popcorn but does not want to move around too much. Determine the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn.\n\nConstraints:\n\n- \\( N \\) and \\( M \\) are integers.\n- \\( 1 \\leq N, M \\leq 10 \\)\n- Each \\( S_i \\) is a string of length \\( M \\) consisting of 'o' and 'x'.\n- For every \\( i \\) (1 \u2264 \\( i \\) \u2264 \\( N \\)), there is at least one 'o' in \\( S_i \\).\n- For every \\( j \\) (1 \u2264 \\( j \\) \u2264 \\( M \\)), there is at least one \\( i \\) such that the \\( j \\)-th character of \\( S_i \\) is 'o'.\n\nInput:\n\nThe input is given from Standard Input in the following format:\n```\nN M\nS_1\nS_2\n...\nS_N\n```\n\nOutput:\n\nPrint the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn.\n\nSample Input 1:\n```\n3 5\noooxx\nxooox\nxxooo\n```\n\nSample Output 1:\n```\n2\n```\n\nBy visiting the 1st and 3rd stands, you can buy all the flavors of popcorn. It is impossible to buy all the flavors from a single stand, so the answer is 2.\n\nSample Input 2:\n```\n3 2\noo\nox\nxo\n```\n\nSample Output 2:\n```\n1\n```\n\nSample Input 3:\n```\n8 6\nxxoxxo\nxxoxxx\nxoxxxx\nxxxoxx\nxxoooo\nxxxxox\nxoxxox\noxoxxo\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n```python\ndef main():\n    n, m = map(int, input().split())\n    s = [input().strip() for _ in range(n)]\n    ans = n\n    for bit in range(1 << n):\n        exist = [False] * m\n        cnt = 0\n        for i in range(n):\n            if (bit >> i) & 1:\n                cnt += 1\n                for j in range(m):\n                    if s[i][j] == 'o':\n                        exist[j] = True\n        all_exist = all(exist[j] for j in range(m))\n        if all_exist:\n            ans = min(ans, cnt)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi is growing a plant. The height of the plant at the time of germination is \\(0\\,\\mathrm{cm}\\). Each night from the day of germination, considered as day \\(0\\), the height of the plant increases by \\(2^i\\,\\mathrm{cm}\\) on day \\(i\\) (\\(0 \\le i\\)).\n\nTakahashi has a height of \\(H\\,\\mathrm{cm}\\).\n\nEvery morning, Takahashi measures his height against the plant. Find the first day such that the plant's height is strictly greater than Takahashi's height in the morning.\n\n### Constraints\n- \\(1 \\leq H \\leq 10^{9}\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nH\n```\n\n### Output\nPrint an integer representing the first day such that the plant's height is greater than Takahashi's height in the morning.\n\n### Sample Input 1\n```\n54\n```\n\n### Sample Output 1\n```\n6\n```\n**Explanation:** The plant's height in the mornings of days \\(1, 2, 3, 4, 5, 6\\) will be \\(1\\,\\mathrm{cm}, 3\\,\\mathrm{cm}, 7\\,\\mathrm{cm}, 15\\,\\mathrm{cm}, 31\\,\\mathrm{cm}, 63\\,\\mathrm{cm}\\), respectively. The plant becomes taller than Takahashi in the morning of day \\(6\\), so print \\(6\\).\n\n### Sample Input 2\n```\n7\n```\n\n### Sample Output 2\n```\n4\n```\n**Explanation:** The plant's height will be \\(7\\,\\mathrm{cm}\\) in the morning of day \\(3\\) and \\(15\\,\\mathrm{cm}\\) in the morning of day \\(4\\). The plant becomes taller than Takahashi in the morning of day \\(4\\), so print \\(4\\). Note that, in the morning of day \\(3\\), the plant is as tall as Takahashi, but not taller.\n\n### Sample Input 3\n```\n262144\n```\n\n### Sample Output 3\n```\n19\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\n## A - Exponential Plant Editorial\n\nUse a while statement to repeatedly add the delta to the height of the plant until it exceeds Takahashi\u2019s height. This simulation will allow you to solve this problem. Also, the height at day \\(30\\) is \\(1073741823\\, \\mathrm{cm}(> 10^{9}\\, \\mathrm{cm})\\), so just using a while statement to find the daily height is fast enough.\n\n**Sample code (Python):**\n```python\nh=int(input())\nnow=0\nans=0\nwhile now<=h:\n    now+=1<<ans\n    ans+=1\n\nprint(ans)\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a bottle of disinfectant that can disinfect exactly \\( M \\) hands. \\( N \\) aliens come one by one to disinfect their hands. The \\( i \\)-th alien (\\( 1 \\leq i \\leq N \\)) has \\( H_i \\) hands and wants to disinfect all of their hands once. Determine how many aliens can disinfect all of their hands. Here, even if there is not enough disinfectant left for an alien to disinfect all of their hands when they start, they will use up the remaining disinfectant.\n\n**Constraints**\n\n- \\( 1 \\leq N, M \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the number of aliens who can disinfect all of their hands.\n\n**Sample Input 1**\n\n```\n5 10\n2 3 2 5 3\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\n*Explanation:*\n\n1. The first alien disinfects their two hands. The remaining disinfectant can disinfect \\( 10-2=8 \\) hands.\n2. The second alien disinfects their three hands. The remaining disinfectant can disinfect \\( 8-3=5 \\) hands.\n3. The third alien disinfects their two hands. The remaining disinfectant can disinfect \\( 5-2=3 \\) hands.\n4. The fourth alien has five hands, but there is only enough disinfectant for three hands, so they use up the disinfectant without disinfecting all of their hands.\n\nThus, the first three aliens can disinfect all of their hands, so print 3.\n\n**Sample Input 2**\n\n```\n5 10\n2 3 2 3 5\n```\n\n**Sample Output 2**\n\n```\n4\n```\n\n**Sample Input 3**\n\n```\n1 5\n1\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\nAll aliens can disinfect their hands.\n\nSolution:\n\n[BEGIN TEXT]\nHere is the simplified version of the editorial:\n\nThe problem can be solved by simulating the remaining amount of disinfectant. Start from \\(M\\) and subtract \\(H_1, H_2, \\ldots, H_N\\) from it in order. If it never goes below \\(0\\), all aliens can disinfect their hands, and the answer is \\(N\\). If it becomes less than \\(0\\) for the first time when subtracting \\(H_i\\), the answer is \\(i-1\\). Ensure to use an appropriate conditional inequality to handle the case when the disinfectant is used up completely.\n\nSample code in Python:\n\n```python\nn, m = map(int, input().split())\nh = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n    m -= h[i]\n    if m >= 0:\n        ans += 1\nprint(ans)\n```\n[END TEXT]\n \n\n", "problem_ids": ["abc358_c", "abc354_a", "abc357_a"]}, "abc328_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree \\(T\\) with \\(N\\) vertices. The vertices are numbered from \\(1\\) to \\(N\\), and the \\(i\\)-th edge \\((1 \\leq i \\leq N-1)\\) connects vertices \\(u_i\\) and \\(v_i\\) bidirectionally.\n\nUsing \\(T\\), define a complete graph \\(G\\) with \\(N\\) vertices as follows:\n- The weight \\(w(x,y)\\) of the edge between vertices \\(x\\) and \\(y\\) in \\(G\\) is the shortest distance between vertices \\(x\\) and \\(y\\) in \\(T\\).\n\nFind one maximum weight maximum matching in \\(G\\). That is, find a set of \\(\\lfloor N/2 \\rfloor\\) pairs of vertices \\(M = \\{(x_1, y_1), (x_2, y_2), \\dots, (x_{\\lfloor N/2 \\rfloor}, y_{\\lfloor N/2 \\rfloor})\\}\\) such that each vertex \\(1, 2, \\dots, N\\) appears in \\(M\\) at most once, and \\(\\sum_{i=1}^{\\lfloor N/2 \\rfloor} w(x_i, y_i)\\) is maximized.\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq u_i < v_i \\leq N\\)\n- The input graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nu_1 v_1\nu_2 v_2\n...\nu_{N-1} v_{N-1}\n```\n\n**Output**\n\nPrint a solution as a set of pairs \\(\\{(x_1, y_1), (x_2, y_2), \\dots, (x_{\\lfloor N/2 \\rfloor}, y_{\\lfloor N/2 \\rfloor})\\}\\) in the following format. If multiple solutions exist, any of them is acceptable.\n\n```\nx_1 y_1\nx_2 y_2\n...\nx_{\\lfloor N/2 \\rfloor} y_{\\lfloor N/2 \\rfloor}\n```\n\n**Sample Input 1**\n\n```\n4\n1 2\n2 3\n3 4\n```\n\n**Sample Output 1**\n\n```\n2 4\n1 3\n```\n\nIn \\(T\\), the distance between vertices \\(2\\) and \\(4\\) is \\(2\\), and the distance between vertices \\(1\\) and \\(3\\) is \\(2\\), so the weight of the matching \\(\\{(2,4), (1,3)\\}\\) is \\(4\\). There is no matching with a weight greater than \\(4\\), so this is a maximum weight maximum matching. Other acceptable outputs include:\n\n```\n2 3\n1 4\n```\n\n**Sample Input 2**\n\n```\n3\n1 2\n2 3\n```\n\n**Sample Output 2**\n\n```\n1 3\n```\n\nIn \\(T\\), the distance between vertices \\(1\\) and \\(3\\) is \\(2\\), so the weight of the matching \\(\\{(1,3)\\}\\) is \\(2\\). There is no matching with a weight greater than \\(2\\), so this is a maximum weight maximum matching. Another acceptable output is:\n\n```\n3 1\n```\n\nSolution:\n\n```python\n# Editorial - Perfect Matching on a Tree\n\nDefine the contribution of an edge \\(i\\) of \\(T\\) in a matching as the number of pairs in the matching that stride over edge \\(i\\). The weight of the matching is the sum of the contributions of the edges. Removing an edge \\(i\\) from \\(T\\) splits it into two subtrees. If they have \\(c_i\\) and \\((N-c_i)\\) edges, the contribution of edge \\(i\\) never exceeds \\(\\min\\{c_i, N-c_i\\}\\). Thus, the weight of the matching is at most \\(\\sum_{i=1}^{N-1} \\min\\{c_i, N-c_i\\}\\).\n\nThere is a centroid \\(g\\) of a tree \\(T\\), a vertex such that by removing \\(g\\), every resulting subtree has a weight of \\(\\lfloor N/2 \\rfloor\\) or less. Every tree has a centroid, and it can be found in \\(O(N)\\) time with DFS. To construct a solution achieving the upper bound:\n\n1. Find a centroid \\(g\\) of the tree \\(T\\).\n2. Let \\(T_1, T_2, \\dots, T_k\\) be the subtrees obtained by removing \\(g\\) from \\(T\\).\n3. Construct an array \\(A\\) consisting of all vertices of \\(T_1\\), \\(T_2\\), ..., \\(T_k\\).\n4. If \\(N\\) is an even number, add \\(g\\) to the tail of \\(A\\).\n5. For each \\(i = 1, 2, \\dots, \\lfloor N/2 \\rfloor\\), match vertices \\(A_i\\) and \\(A_{i+\\lfloor N/2 \\rfloor}\\).\n\nThis algorithm ensures that for each matched pair \\((A_i, A_{i+\\lfloor N/2 \\rfloor})\\), the vertices belong to different subtrees. If all pairs belong to different subtrees, the weight of the matching achieves the upper bound. The \\(x-y\\) path always passes through the edge contributing the maximal count achievable in this configuration.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of the characters 'A' and 'B'. For a string \\( X \\) of length \\( N \\) consisting of the characters '1', '2', and '3', the score is determined by the following procedure:\n\n1. Initialize the variables \\( h_1, h_2, h_3, P \\) to 0.\n\n2. For \\( i = 1, 2, \\dots, N \\) in this order, perform the following operations:\n   - If the \\( i \\)-th character of \\( S \\) is 'A', perform operation A; if it is 'B', perform operation B. Let \\( d \\) be the number represented by the \\( i \\)-th character of \\( X \\).\n   - **Operation A:** Add 2 to \\( h_d \\).\n   - **Operation B:** If \\( d = 2 \\) or \\( h_d \\neq h_2 \\), set \\( P \\) to \\(-10^{100}\\). Otherwise, add 1 to both \\( h_d \\) and \\( h_2 \\).\n\n3. If \\( h_1 = h_2 = h_3 \\), add 1 to \\( P \\).\n\nThe final value of \\( P \\) is the score.\n\nPrint one string \\( X \\) that maximizes the score. You have \\( T \\) test cases to solve.\n\n**Constraints:**\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N \\leq 10^6 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of 'A' and 'B'.\n- \\( T \\) and \\( N \\) are integers.\n- The sum of \\( N \\) across all test cases is at most \\( 10^6 \\).\n\n**Input:**\nThe input is given from Standard Input in the following format. Here, \\(\\mathrm{test}_i\\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{test}_1\n\\mathrm{test}_2\n\\vdots\n\\mathrm{test}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nS\n```\n\n**Output:**\nPrint \\( T \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq T \\)) should contain a string \\( X \\) that maximizes the score for the \\( i \\)-th test case. If multiple strings \\( X \\) maximize the score, any of them is considered correct.\n\n**Sample Input 1:**\n```\n5\n4\nABBA\n5\nAAAAA\n6\nBBBBBB\n7\nABABABA\n20\nAAABBBBBBBBAAABBBABA\n```\n\n**Sample Output 1:**\n```\n1333\n12321\n333333\n1313212\n33311111133121111311\n```\n\nLet us describe the changes in \\((h_1, h_2, h_3, P)\\) as we proceed with \\( i = 1, 2, \\dots, N \\).\n\n- For the first test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,1,1,0) \\rightarrow (2,2,2,1) \\rightarrow (2,2,4,1)\\). The maximum score is 1.\n- For the second test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,2,0,0) \\rightarrow (2,2,2,1) \\rightarrow (2,4,2,1) \\rightarrow (4,4,2,1)\\). The maximum score is 1.\n\nFor the third, fourth, and fifth test cases, the maximum scores are 0, 0, and 2, respectively. There may be multiple strings \\( X \\) that maximize the score, but you only need to print one of them.\n\nSolution:\n\n[BEGIN TEXT]\nHere is a concise version of the provided text:\n\n---\n\n**F - All the Same Editorial by evima**\n\n**Observations on the Problem:**  \nThe problem can be visualized as a Tetris game with dominoes on a field width of 3, where dominoes cannot be rotated and there must be no gaps below horizontally placed dominoes. The score increases when all pieces are cleared. Flattening occurs when \\( h_1 = h_2 = h_3 \\).\n\n**Characteristics of \\( S \\):**  \nFor \\( i=0,1,\\ldots,N \\), let \\( a_i \\) be the number of As and \\( b_i \\) the number of Bs. The sequence can be flattened under the following conditions:\n- \\( a_i + b_i \\equiv 0 \\mod 3 \\)\n- \\( b_i \\equiv 0 \\mod 2 \\)\n- \\( b_i \\le 2a_i \\)\n\nDefining \\( V_i = 2a_i - b_i \\) gives:\n\\[ V_i \\ge 0, \\ V_i \\equiv 0 \\mod 6 \\]\nThese conditions are both necessary and sufficient for flattening.\n\n**Maximizing the Score:**  \nFind the longest non-decreasing subsequence \\( (V_{i_0}, V_{i_1}, \\ldots, V_{i_k}) \\) with:\n- \\( i_0 = 0 \\)\n- \\( V_{i_j} \\equiv 0 \\mod 6 \\)\n- \\( V_{i_j} \\le V_{i_{j+1}} \\)\n\nThis can be solved in \\( O(N \\log N) \\) time. \n\n**Constructing the Operation Sequence:**  \nDefine \\( T_j \\) as the substring of \\( S \\) from \\( (V_{i_j}+1) \\)-th to \\( V_{i_{j+1}} \\)-th character. Construct an operation sequence \\( X \\) for \\( S \\):\n- \\( A \\to 1 \\) (vertical domino)\n- \\( B \\to 3 \\) (horizontal domino)\n\nAdjust for \\( V_N \\ge 6 \\) by aligning extra vertical dominoes. Execute the basic idea when \\( V_N = 0 \\). Handle \\( V_i \\) conditions to reduce \\( V_N \\).\n\n**Summary:**  \n1. Compute \\( V \\) and solve the longest non-decreasing subsequence problem.\n2. For divided substrings, use the basic idea and reductions.\n\nThe solution operates in \\( O(|S|\\log |S|) \\) time per test case.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a stack of `N` cards, and the `i-th` card from the top has an integer `A_i` written on it. You take `K` cards from the bottom of the stack and place them on top of the stack, maintaining their order.\n\nPrint the integers written on the cards from top to bottom after the operation.\n\n**Constraints**\n\n- \\(1 \\leq K < N \\leq 100\\)\n- \\(1 \\leq A_i \\leq 100\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet `B_i` be the integer written on the `i-th` card from the top of the stack after the operation. Print `B_1, B_2, \\ldots, B_N` in this order, separated by spaces.\n\n**Sample Input 1**\n\n```\n5 3\n1 2 3 4 5\n```\n\n**Sample Output 1**\n\n```\n3 4 5 1 2\n```\n\nInitially, the integers written on the cards are `1, 2, 3, 4, 5` from top to bottom. After taking three cards from the bottom of the stack and placing them on top, the integers written on the cards become `3, 4, 5, 1, 2` from top to bottom.\n\n**Sample Input 2**\n\n```\n6 2\n1 2 1 2 1 2\n```\n\n**Sample Output 2**\n\n```\n1 2 1 2 1 2\n```\n\nThe integers written on the cards are not necessarily distinct.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Hitachi Vantara Programming Contest 2024 (AtCoder Beginner Contest 368)\n\nThe topmost card after an operation is the \\(K\\)-th card from the bottom in the original pile. The \\(K\\)-th bottommost card is the \\((N-K+1)\\) card from the top, so the cards after the operation have \\(A_{N-K+1},A_{N-K+2},\\ldots,A_{N},A_{1},A_{2},\\ldots\\), and \\(A_{N-K}\\) written on them from the top. You may print these values. In many programming languages, indices start from \\(0\\), so beware of indices.\n\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\nfor i in range(N-K,N): print(A[i])\nfor i in range(N-K): print(A[i])\n```\n\nIn languages like Python, one can easily achieve the operation of splitting a pile into two and move the lower part to the top, as follows:\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\ntop = A[:-K]  # upper\nbottom = A[-K:]  # lower\nB = bottom + top  # put the lower part to the top\nprint(*B)\n```\n\nIn Python, you can also achieve a similar operation using list slicing:\n```python\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA = A[-K:] + A[:-K]\nprint(*A)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc362_f", "arc179_f", "abc368_a"]}, "abc328_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a simple connected undirected graph with \\( N \\) vertices and \\( M \\) edges. Each vertex \\( i \\,(1 \\leq i \\leq N) \\) has a weight \\( A_i \\). Each edge \\( j \\,(1 \\leq j \\leq M) \\) connects vertices \\( U_j \\) and \\( V_j \\) bidirectionally and has a weight \\( B_j \\).\n\nThe weight of a path in this graph is defined as the sum of the weights of the vertices and edges that appear on the path.\n\nFor each \\( i = 2, 3, \\dots, N \\), solve the following problem:\n- Find the minimum weight of a path from vertex 1 to vertex \\( i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_j < V_j \\leq N \\)\n- \\( (U_i, V_i) \\neq (U_j, V_j) \\) if \\( i \\neq j \\).\n- The graph is connected.\n- \\( 0 \\leq A_i \\leq 10^9 \\)\n- \\( 0 \\leq B_j \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format: \n\n```\nN M\nA_1 A_2 \\dots A_N\nU_1 V_1 B_1\nU_2 V_2 B_2\n\\vdots\nU_M V_M B_M\n```\n\n**Output:**\n\nPrint the answers for \\( i = 2, 3, \\dots, N \\) in a single line, separated by spaces.\n\n**Sample Input 1:**\n\n```\n3 3\n1 2 3\n1 2 1\n1 3 6\n2 3 2\n```\n\n**Sample Output 1:**\n\n```\n4 9\n```\n\n**Explanation:**\n\nConsider the paths from vertex 1 to vertex 2. The weight of the path \\( 1 \\to 2 \\) is \\( A_1 + B_1 + A_2 = 1 + 1 + 2 = 4 \\), and the weight of the path \\( 1 \\to 3 \\to 2 \\) is \\( A_1 + B_2 + A_3 + B_3 + A_2 = 1 + 6 + 3 + 2 + 2 = 14 \\). The minimum weight is 4.\n\nConsider the paths from vertex 1 to vertex 3. The weight of the path \\( 1 \\to 3 \\) is \\( A_1 + B_2 + A_3 = 1 + 6 + 3 = 10 \\), and the weight of the path \\( 1 \\to 2 \\to 3 \\) is \\( A_1 + B_1 + A_2 + B_3 + A_3 = 1 + 1 + 2 + 2 + 3 = 9 \\). The minimum weight is 9.\n\n**Sample Input 2:**\n\n```\n2 1\n0 1\n1 2 3\n```\n\n**Sample Output 2:**\n\n```\n4\n```\n\n**Sample Input 3:**\n\n```\n5 8\n928448202 994752369 906965437 942744902 907560126\n2 5 975090662\n1 2 908843627\n1 5 969061140\n3 4 964249326\n2 3 957690728\n2 4 942986477\n4 5 948404113\n1 3 988716403\n```\n\n**Sample Output 3:**\n\n```\n2832044198 2824130042 4696218483 2805069468\n```\n\nNote that the answers may not fit in a 32-bit integer.\n\nSolution:\n\n```python\n\"\"\"\nEditorial - Toyota Programming Contest 2024#7 (AtCoder Beginner Contest 362)\n\nD - Shortest Path 3 Editorial\n\nThis is an exercise of an algorithm to find the shortest length of a path on a graph. For a graph with non-negative edge weights, the shortest length of a path can be found fast with Dijkstra\u2019s algorithm. In this problem, vertices have weights too, so we cannot directly apply Dijkstra\u2019s algorithm. Instead, we rephrase it into an edge-weighted problem. When traveling from vertex \\(U_i\\) to vertex \\(V_j\\) only via edge \\(j\\), the cost newly imposed is the cost to use edge \\(j\\) and to visit vertex \\(V_j\\), for a total of \\(B_j + A_{V_j}\\). Conversely, when traveling from vertex \\(V_i\\) to vertex \\(U_j\\) only via edge \\(j\\), the cost newly imposed is the cost to use edge \\(j\\) and to visit vertex \\(U_j\\), for a total of \\(B_j + A_{U_j}\\). Thus, by adding an edge of weight \\(B_j + A_{V_j}\\) in the direction of \\(U_j \\to V_j\\) and an edge of weight \\(B_j + A_{U_j}\\) in the direction of \\(V_j \\to U_j\\), every cost can be represented only with edge weights. By applying Dijkstra\u2019s algorithm on this graph and finally adding the weight of the initial point \\(A_1\\), one can find the answer. The time complexity is \\(O(M \\log N)\\).\n\"\"\"\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices. The vertices are numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge (\\( 1 \\leq i \\leq N-1 \\)) connects vertices \\( U_i \\) and \\( V_i \\), with a length of \\( L_i \\).\n\nFor each \\( K = 1, 2, \\ldots, N \\), solve the following problem.\n\nTakahashi and Aoki play a game. The game proceeds as follows:\n\n1. First, Aoki specifies \\( K \\) distinct vertices on the tree.\n2. Then, Takahashi constructs a walk that starts and ends at vertex 1, and passes through all the vertices specified by Aoki.\n\nThe score is defined as the length of the walk constructed by Takahashi. Takahashi wants to minimize the score, while Aoki wants to maximize it. Find the score when both players play optimally.\n\n**Definition of a walk:**\nA walk on an undirected graph (possibly a tree) is a sequence of \\( k \\) vertices and \\( k-1 \\) edges \\( v_1, e_1, v_2, \\ldots, v_{k-1}, e_{k-1}, v_k \\) (where \\( k \\) is a positive integer) such that edge \\( e_i \\) connects vertices \\( v_i \\) and \\( v_{i+1} \\). The same vertex or edge can appear multiple times in the sequence. A walk is said to pass through vertex \\( x \\) if there exists at least one \\( i \\) (\\( 1 \\leq i \\leq k \\)) such that \\( v_i = x \\). (There can be multiple such \\( i \\).) The walk is said to start and end at \\( v_1 \\) and \\( v_k \\), respectively, and the length of the walk is the sum of the lengths of \\( e_1, e_2, \\ldots, e_{k-1} \\).\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq L_i \\leq 10^9 \\)\n- All input values are integers.\n- The given graph is a tree.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nU_1 V_1 L_1\nU_2 V_2 L_2\n...\nU_{N-1} V_{N-1} L_{N-1}\n```\n\n**Output:**\nPrint \\( N \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq N \\)) should contain the answer to the problem for \\( K = i \\).\n\n**Sample Input 1:**\n```\n5\n1 2 3\n2 3 5\n2 4 2\n1 5 3\n```\n\n**Sample Output 1:**\n```\n16\n22\n26\n26\n26\n```\n\nFor \\( K=1 \\), Aoki's optimal move is to specify vertex 3, and Takahashi's optimal move is to construct a path vertex 1 \u2192 vertex 2 \u2192 vertex 3 \u2192 vertex 2 \u2192 vertex 1, resulting in a score of 16.\n\nFor \\( K=2 \\), Aoki's optimal move is to specify vertices 3 and 5, and Takahashi's optimal move is to construct a path such as vertex 1 \u2192 vertex 5 \u2192 vertex 1 \u2192 vertex 2 \u2192 vertex 3 \u2192 vertex 2 \u2192 vertex 1, resulting in a score of 22.\n\nFor \\( K \\geq 3 \\), the score when both players play optimally is 26.\n\n**Sample Input 2:**\n```\n3\n1 2 1000000000\n2 3 1000000000\n```\n\n**Sample Output 2:**\n```\n4000000000\n4000000000\n4000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n---\n\nWe will regard the given tree as a rooted tree rooted at \\(1\\). We first consider Takahashi\u2019s strategy. For any edge on the tree, when the tree is split into two parts by the edge, if Aoki has chosen at least one vertex in the part not containing vertex \\(1\\), then Takahashi has to construct a walk that passes through that edge at least twice (back and forth). Conversely, he can construct the shortest such walk, which passes through such edges exactly twice but not the others. It can be constructed as, for example, an Euler tour on the tree obtained by removing unnecessary edges. Based on this fact, we will try to solve the problem with tree DP (Dynamic Programming).\n\nFor each subtree \\(T_v\\) rooted at vertex \\(v\\), let us try to find \\((S_v(1), S_v(2), \\ldots, S_v(T_v))\\), defined as the minimum scores for \\(K=1,2,\\ldots,|T_v|\\) when they play optimally on \\(T_v\\). Here, \\(|T_v|\\) denotes the number of vertices in \\(T_v\\).\n\nIf \\(T_u\\) consist of a single vertex, then \\(|T_u|=1\\) and \\(S_u(1)=0\\). Suppose that vertex \\(u\\) has \\(v_1,v_2,\\ldots,v_c\\) as its direct children, with the lengths of the edge between \\(u\\) and them being \\(d_1,d_2,\\ldots,d_c\\), respectively, and the scores are already known for \\(T_{v_i}\\) \\((1\\leq i\\leq c)\\). Then, noticing it is useless to choose \\(u\\) if \\(K<|T_u|\\), the scores \\(S(u,K)\\) \\((1\\leq K < |T_u|)\\) satisfy:\n\n\\[\nS(u,K)=\\max_{x_1+x_2+x_c=K}\\sum_{i=1}^c\n\\begin{cases}\n0 & (x_i=0) \\\\\n2d_i+S(v_i,x_i) & (1\\leq x_i\\leq |T_i|),\n\\end{cases}\n\\]\n\nwhere each \\(x_i\\) ranges over \\(0\\leq x_i\\leq |T_i|\\). Finally, \\(S(u,|T_u|)=S(u,|T_u|-1)\\).\n\nSince \\(S(v,x)\\leq S(v,x+1)\\) for any \\(v\\), this can be interpreted as the maximum sum of a total of \\(K\\) elements chosen from the leading elements of \\(c\\) sequences \\((2d_i+S(v_i,1),S(v_i,2)-S(v_i,1),\\ldots, S(v_i,|T_i|)-S(v_i,|T_i|-1) )\\). Moreover, assume that they satisfy \\(S(v_i,1)\\geq S(v_i,2)-S(v_i,1)\\) and \\(S(v_i,x)-S(v_i,x-1)\\geq S(v_i,x+1)-S(v_i,x)\\).\n\nIf we define a multiset \\(\\mathcal{S}\\) as:\n\n\\[\n\\mathcal{S}_u= \\left[\\bigcup_{i=1}^c \\{2d_i+S(v_i,1),S(v_i,2)-S(v_i,1),\\ldots, S(v_i,|T_i|)-S(v_i,|T_i|-1) \\}\\right]\\cup\\{0\\},\n\\]\n\nthen the elements sorted in descending order, \\((z_1,z_2,\\ldots,z_{|T_u|})\\), coincide with \\((S(u,1),S(u,2)-S(u,1),\\ldots, S(u,|T_u|)-S(u,|T_u|-1))\\). Then, we have \\(S(u,1)\\geq S(u,2)-S(u,1)\\) and \\(S(u,x)-S(u,x-1)\\geq S(u,x+1)-S(u,x)\\) for \\(u\\) too. Since it automatically holds for \\(|T_u|=1\\), this property inductively holds always, and thus can be computed like this.\n\nBased on this fact, we can compute it as follows: When processing a non-leaf vertex, compute \\(2d_i+S(v_i,1)\\) \\((1\\leq i\\leq c)\\) and store the maximum among them to \\(S(u,1)\\), and store the other \\((c-1)\\) values and one \\(0\\) into a multiset \\(\\mathcal{S}\\). \\(S(1,1)\\) is the last value stored, and \\(S(1,K)\\) is \\(S(1,1)\\) plus the sum of the largest \\((K-1)\\) elements of \\(\\mathcal{S}\\). The complexity is \\(O(N)\\), which is fast enough. Thus, the problem has been solved.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere are \\(N+2\\) cells arranged in a row. Let cell \\(i\\) denote the \\(i\\)-th cell from the left.\n\nThere is one stone placed in each of the cells from cell \\(1\\) to cell \\(N\\).\n\nFor each \\(1 \\leq i \\leq N\\), the stone in cell \\(i\\) is white if \\(S_i\\) is 'W', and black if \\(S_i\\) is 'B'.\n\nCells \\(N+1\\) and \\(N+2\\) are empty.\n\nYou can perform the following operation any number of times (possibly zero):\n\n- Choose a pair of adjacent cells that both contain stones, and move these two stones to the empty two cells while preserving their order.\n\n  More precisely, choose an integer \\(x\\) such that \\(1 \\leq x \\leq N+1\\) and both cells \\(x\\) and \\(x+1\\) contain stones. Let \\(k\\) and \\(k+1\\) be the empty two cells. Move the stones from cells \\(x\\) and \\(x+1\\) to cells \\(k\\) and \\(k+1\\), respectively.\n\nDetermine if it is possible to achieve the following state, and if so, find the minimum number of operations required:\n\n- Each of the cells from cell \\(1\\) to cell \\(N\\) contains one stone, and for each \\(1 \\leq i \\leq N\\), the stone in cell \\(i\\) is white if \\(T_i\\) is 'W', and black if \\(T_i\\) is 'B'.\n\n**Constraints:**\n- \\(2 \\leq N \\leq 14\\)\n- \\(N\\) is an integer.\n- Each of \\(S\\) and \\(T\\) is a string of length \\(N\\) consisting of 'B' and 'W'.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\nT\n```\n\n**Output:**\n\nIf it is possible to achieve the desired state, print the minimum number of operations required. If it is impossible, print `-1`.\n\n**Sample Input 1:**\n```\n6\nBWBWBW\nWWWBBB\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n**Explanation:**\n\nUsing `.` to represent an empty cell, the desired state can be achieved in four operations as follows, which is the minimum:\n- `BWBWBW..`\n- `BW..BWBW`\n- `BWWBB..W`\n- `..WBBBWW`\n- `WWWBBB..`\n\n**Sample Input 2:**\n```\n6\nBBBBBB\nWWWWWW\n```\n\n**Sample Output 2:**\n```\n-1\n```\n\n**Sample Input 3:**\n```\n14\nBBBWBWWWBBWWBW\nWBWWBBWWWBWBBB\n```\n\n**Sample Output 3:**\n```\n7\n```\n\nSolution:\n\n[BEGIN TEXT]\nD - Go Stone Puzzle Editorial\n\nIf \\(S\\) and \\(T\\) have different numbers of W and B, then the answer is No. Assume they are equal. Let \\(W\\) be the number of W and \\(B\\) be the number of B. Since the empty squares are always adjacent, there are \\(\\frac{(N+1)!}{B!W!}=O(\\sqrt{N}2^N)\\) possible states of the cells. (The analysis is omitted here.) The maximum value \\(51480\\) occurs for \\(N=14\\) and \\(B=W=7\\). For each state, there are \\((N-1)\\) possible moves. Since the number of states and moves are small enough, use BFS to solve the problem. The total complexity is expected \\(O(N^{1.5}2^N)\\) using a hash map. Similar problem: 8 puzzle (AOJ).\n[END TEXT]\n \n\n", "problem_ids": ["abc362_d", "abc369_g", "abc361_d"]}, "abc329_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence \\( A \\) of length \\( N \\). Freely choose exactly \\( K \\) elements from \\( A \\) and remove them, then concatenate the remaining elements in their original order to form a new sequence \\( B \\). Find the minimum possible value of this: the maximum value of \\( B \\) minus the minimum value of \\( B \\).\n\n**Constraints**\n\n- All inputs are integers.\n- \\( 1 \\le K < N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le A_i \\le 10^9 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n5 2\n3 1 5 4 9\n```\n\n**Sample Output 1**\n```\n2\n```\n\n**Sample Input 2**\n```\n6 5\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n8 3\n31 43 26 6 18 36 22 13\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Editorial - Denso Create Programming Contest 2024 (AtCoder Beginner Contest 361)\n\nRemoving \\(K\\) elements of \\(A\\) is equivalent to retaining \\((N-K)\\) elements to form \\(B\\). To minimize (maximum value of \\(B\\)) - (minimum value of \\(B\\)), it is optimal to retain the \\((N-K)\\) smallest elements among the elements of \\(A\\) greater than or equal to \\(A_x\\), the fixed minimum of \\(B\\). In other words, it is optimal to choose \\((N-K)\\) consecutive elements in \\(A\\) sorted in ascending order.\n\nSolution: \n1. Sort \\(A\\) such that \\(A_1 \\le A_2 \\le \\dots \\le A_N\\).\n2. The answer is the minimum of \\(A_{l+(N-K)-1} - A_l\\) for \\(1 \\le l \\le K+1\\).\n3. Implement with sorting and a for loop, with a total time complexity of \\(O(N \\log N)\\).\n\nSample code (Python3):\n\n```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\nres = int(2e9)\nfor i in range(k + 1):\n    res = min(res, a[i + (n - k) - 1] - a[i])\n\nprint(res)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n## Problem Statement\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(NK\\) is called a **good** integer sequence if each integer from \\(1\\) to \\(N\\) appears exactly \\(K\\) times in the sequence.\n\nLet \\(S\\) be the number of good integer sequences. Find the \\(\\operatorname{floor}((S+1)/2)\\)-th good integer sequence in lexicographical order. Here, \\(\\operatorname{floor}(x)\\) represents the largest integer not exceeding \\(x\\).\n\n### What is lexicographical order for sequences?\nA sequence \\(S = (S_1,S_2,\\ldots,S_{|S|})\\) is **lexicographically smaller** than a sequence \\(T = (T_1,T_2,\\ldots,T_{|T|})\\) if either 1. or 2. below holds:\n1. \\(|S| < |T|\\) and \\((S_1,S_2,\\ldots,S_{|S|}) = (T_1,T_2,\\ldots,T_{|S|})\\).\n2. There exists an integer \\(1 \\leq i \\leq \\min\\lbrace |S|, |T| \\rbrace\\) such that both of the following hold:\n   - \\((S_1,S_2,\\ldots,S_{i-1}) = (T_1,T_2,\\ldots,T_{i-1})\\)\n   - \\(S_i\\) is (numerically) smaller than \\(T_i\\).\n\n### Constraints\n- \\(1 \\leq N \\leq 500\\)\n- \\(1 \\leq K \\leq 500\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\n```\n\n### Output\nPrint the desired integer sequence, with elements separated by spaces.\n\n### Sample Input 1\n```\n2 2\n```\n\n### Sample Output 1\n```\n1 2 2 1\n```\n\nThere are six good integer sequences:\n- (1,1,2,2)\n- (1,2,1,2)\n- (1,2,2,1)\n- (2,1,1,2)\n- (2,1,2,1)\n- (2,2,1,1)\n\nTherefore, the answer is the 3rd sequence in lexicographical order, (1,2,2,1).\n\n### Sample Input 2\n```\n1 5\n```\n\n### Sample Output 2\n```\n1 1 1 1 1\n```\n\n### Sample Input 3\n```\n6 1\n```\n\n### Sample Output 3\n```\n3 6 5 4 2 1\n```\n\n### Sample Input 4\n```\n3 3\n```\n\n### Sample Output 4\n```\n2 2 2 1 3 3 3 1 1\n```\n\nSolution:\n\n```python\ndef lexicographically_largest_sequence(N, K):\n    sequence = []\n    \n    if N % 2 == 0:\n        # When N is even\n        first_element = N // 2\n        sequence.extend([first_element] * K)\n        remaining_elements = list(range(1, first_element)) + list(range(first_element + 1, N + 1))\n        remaining_elements.sort(reverse=True)\n    else:\n        # When N is odd\n        first_element = (N + 1) // 2\n        sequence.extend([first_element] * K)\n        remaining_elements = list(range(1, first_element)) + list(range(first_element + 1, N + 1))\n        remaining_elements.sort(reverse=True)\n    \n    # Append the remaining elements to form the final sequence\n    sequence.extend(remaining_elements[:N-K])\n    \n    return sequence\n\n# Testing the function with an example case\nN = 7\nK = 3\nresult = lexicographically_largest_sequence(N, K)\nprint(\"Lexicographically largest sequence:\", result)\n```\n\nConsider two cases based on the parity of \\(N\\).\n\nWhen \\(N\\) is even: The number of good sequences starting with \\(1,2,\\cdots,N/2\\) matches exactly with those starting with \\(N/2+1,\\cdots,N\\). Therefore, the desired sequence is the lexicographically largest one among the good sequences that start with \\(N/2\\). This can be obtained simply by sorting the remaining elements in descending order.\n\nWhen \\(N\\) is odd: The number of good sequences starting with \\(1,2,\\cdots,(N-1)/2\\) matches exactly with those starting with \\((N+3)/2,\\cdots,N\\). Thus, the first element of the desired sequence will be \\((N+1)/2\\). The next step is to find the sequence that is exactly at the middle in lexicographical order among the sequences obtained by arranging the remaining elements. Now, let\u2019s consider the second element. If \\((N+1)/2\\) remains, we can apply the same logic, and thus the second element will also be \\((N+1)/2\\). In the end, the first \\(K\\) elements will be \\((N+1)/2\\). The remaining part of the sequence can be obtained in the same way as in the even case, so this case is resolved as well.\n\nImplementing the above steps directly yields an \\(O(NK)\\) time solution.\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence \\( X \\) of length \\( N \\) where each element is between \\( 1 \\) and \\( N \\), inclusive, and a sequence \\( A \\) of length \\( N \\). Perform the following operation \\( K \\) times on \\( A \\) and print the result.\n\n**Operation:** Replace \\( A \\) with \\( B \\) such that \\( B_i = A_{X_i} \\).\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\le N \\le 2 \\times 10^5 \\)\n- \\( 0 \\le K \\le 10^{18} \\)\n- \\( 1 \\le X_i \\le N \\)\n- \\( 1 \\le A_i \\le 2 \\times 10^5 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nX_1 X_2 \\dots X_N\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nLet \\( A' \\) be the sequence \\( A \\) after the operations. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n7 3\n5 2 6 3 1 4 6\n1 2 3 5 7 9 11\n```\n\n**Sample Output 1**\n```\n7 2 3 5 1 9 3\n```\n\n- In this input, \\( X = (5,2,6,3,1,4,6) \\) and the initial sequence is \\( A = (1,2,3,5,7,9,11) \\).\n  - After one operation, the sequence is \\( (7,2,9,3,1,5,9) \\).\n  - After two operations, the sequence is \\( (1,2,5,9,7,3,5) \\).\n  - After three operations, the sequence is \\( (7,2,3,5,1,9,3) \\).\n\n**Sample Input 2**\n```\n4 0\n3 4 1 2\n4 3 2 1\n```\n\n**Sample Output 2**\n```\n4 3 2 1\n```\n\n- There may be cases where no operations are performed.\n\n**Sample Input 3**\n```\n9 1000000000000000000\n3 7 8 5 9 3 7 4 2\n9 9 8 2 4 4 3 5 3\n```\n\n**Sample Output 3**\n```\n3 3 3 3 3 3 3 3 3\n```\n\nSolution:\n\n        Here is a clean version of the content related to the solution:\n\nThis problem can be solved with a technique called doubling. For \\(k=0,1,\\dots,59\\), consider finding the array \\(P_k\\):\n\n\\(P_{k,i} :=\\) (after \\(2^k\\) operations, the \\(i\\)-th element of the resulting sequence contains the \\(P_{k,i}\\)-th element of the sequence before the operations).\n\nFirst, \\(P_0 = X\\). Furthermore, \\(P_k\\) can be obtained from \\(P_{k-1}\\) as follows:\n\n\\(P_{k,i} = P_{k-1}[P_{k-1,i}]\\).\n\nIntuitively, applying \u201c\\(2^{k-1}\\) operations\u201d twice means applying \u201c\\(2^k\\) operations.\u201d For sequences \\(L\\) and \\(R\\) corresponding to \\(l\\) and \\(r\\) operations, \\(T_i=R[L_i]\\) yields \\(T\\), corresponding to \\(l+r\\) operations, called \u201ccomposition of operations.\u201d The goal is to find sequence \\(Q\\) such that after \\(K\\) operations, the \\(i\\)-th element of the resulting sequence contains the \\(Q_i\\)-th element of the original sequence. This can be achieved similarly to fast exponentiation:\n\nLet \\(Q=(1,2,\\dots,N)\\) (corresponding to \\(0\\) operations). For \\(i=0,1,\\dots,59\\), repeat:\n\n- If \\(K\\) mod \\(2\\) is \\(1\\), compose \\(Q\\) and \\(P_i\\). Then, divide \\(K\\) by \\(2\\).\n\nSample code (Python3):\n\n```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    index = 2\n    p = [[0] * (n + 1) for _ in range(60)]\n    \n    for i in range(1, n + 1):\n        p[0][i] = int(data[index])\n        index += 1\n    \n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = int(data[index])\n        index += 1\n    \n    for lv in range(1, 60):\n        for i in range(1, n + 1):\n            p[lv][i] = p[lv - 1][p[lv - 1][i]]\n    \n    q = list(range(n + 1))\n    \n    for lv in range(60):\n        if k % 2:\n            for i in range(1, n + 1):\n                q[i] = p[lv][q[i]]\n        k //= 2\n    \n    result = []\n    for i in range(1, n + 1):\n        result.append(str(a[q[i]]))\n    \n    print(\" \".join(result))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n \n\n", "problem_ids": ["abc361_c", "arc183_a", "abc367_e"]}, "abc329_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Country of AtCoder consists of \\( N \\) cities and \\( M \\) roads connecting them. One can travel between any two cities by traversing some roads. The cities are numbered from 1 to \\( N \\), and the roads are numbered from 1 to \\( M \\). Road \\( i \\) connects cities \\( A_i \\) and \\( B_i \\) bidirectionally.\n\nDue to increasing traffic in the country, there is a plan to expand some roads. Currently, no roads have been expanded, and the cost to expand road \\( i \\) is \\( C_i \\).\n\nSince it is difficult to expand all roads at once, the plan is to first designate \\( K \\) out of the \\( N \\) cities as **major cities** and perform the minimum necessary expansion work, so that one can travel between any two major cities using only expanded roads. It has already been decided that cities \\( 1, 2, \\ldots, K-1 \\) will be major cities, but the last major city has not yet been decided.\n\nFor each \\( i = K, K+1, \\ldots, N \\), answer the following question: If city \\( i \\) is designated as the last major city, what is the minimum total cost of the expansion work required to ensure that one can travel between any two major cities using only expanded roads?\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 4000 \\)\n- \\( N-1 \\leq M \\leq 8000 \\)\n- \\( 2 \\leq K \\leq \\min(N, 10) \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- One can travel between any two cities by traversing some roads.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n**Output**\n\nPrint \\( N-K+1 \\) lines. The \\( l \\)-th line \\( (1 \\leq l \\leq N-K+1) \\) should contain the answer to the question for \\( i = l+K-1 \\), as an integer.\n\n**Sample Input 1**\n```\n4 5 3\n1 4 3\n3 4 4\n1 2 4\n2 3 2\n1 3 1\n```\n\n**Sample Output 1**\n```\n3\n6\n```\n\nIn the above figure, circles with numbers represent cities with those numbers, and lines with numbers represent roads with the cost of expansion being that number. The left and right figures correspond to the cases \\( i=3 \\) and \\( i=4 \\), respectively. The colored circles represent the major cities, and the colored thick lines represent the roads that are expanded in an optimal solution. For \\( i=3 \\), expanding roads 4 and 5 results in a total cost of \\( 2+1=3 \\), which is the minimum. For \\( i=4 \\), expanding roads 1, 4, and 5 results in a total cost of \\( 3+2+1=6 \\), which is the minimum.\n\n**Sample Input 2**\n```\n4 3 2\n2 4 28\n1 4 56\n1 3 82\n```\n\n**Sample Output 2**\n```\n84\n82\n56\n```\n\n**Sample Input 3**\n```\n6 12 4\n2 6 68\n2 5 93\n4 6 28\n2 4 89\n3 6 31\n1 3 10\n1 2 53\n3 5 1\n3 5 74\n3 4 22\n4 5 80\n3 4 35\n```\n\n**Sample Output 3**\n```\n85\n64\n94\n```\n\nThere may be multiple roads connecting the same pair of cities.\n\nSolution:\n\nHere is the editorial with the C++ code translated to Python3:\n\n```\nJapan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nOfficial\n\nG - Last Major City Editorial\n\nThis problem is an extension of the minimum Steiner tree problem. We referred to an editorial slide by Yoichi Iwata. A city, road, and cost are simply a vertex, edge, and weight. In an optimal solution, the graph defined by the set of edges to be extended as well as their adjacent vertices forms a tree. For a subset of the vertex set \\(\\{1,2,\\dots,K-1\\}\\) and vertex \\(v\\), \\(f(S,v)\\) is the minimum total weight of the edges of a tree containing vertex \\(v\\) and all vertices in \\(S\\). We seek \\(f(\\{1,2,\\dots,K-1\\}, v)\\) for each \\(K\\leq v\\leq N\\).\n\nThe function \\(f(S,v)\\) can be calculated with Dynamic Programming (DP), using initial values \\(f(\\{i\\}, i)=0\\ (1 \\leq i \\leq K-1)\\). There are two transitions: \n\n1. \\(f(S,v) \\leftarrow \\min(f(S,v),f(S,u) + w)\\) if an edge of weight \\(w\\) connects vertices \\(u\\) and \\(v\\).\n2. \\(f(S,v) \\leftarrow \\min(f(S,v),f(T,v)+f(S\\setminus T,v))\\ (T\\subsetneq S, T\\neq \\emptyset)\\).\n\nThe transitions ensure efficient processing by filling the DP table in ascending order of the size of \\(S\\). The circular dependency in the former transition is managed by determining \\(f(S,v)\\) in ascending order of its value using Dijkstra\u2019s algorithm. The overall complexity is \\(O(3^KN+2^KM\\log M)\\).\n\nSample code (Python3):\n\n```python\nimport sys\nimport heapq\n\ndef chmin(a, b):\n    return b < a\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2]) - 1\n    \n    G = [[] for _ in range(n)]\n\n    index = 3\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        index += 3\n        G[a].append((b, c))\n        G[b].append((a, c))\n\n    dp = [[float('inf')] * n for _ in range(1 << k)]\n    for i in range(k):\n        dp[1 << i][i] = 0\n\n    for bit in range(1, 1 << k):\n        sub = bit\n        while sub > 0:\n            for i in range(n):\n                dp[bit][i] = min(dp[bit][i], dp[sub][i] + dp[bit - sub][i])\n            sub = (sub - 1) & bit\n\n        pq = [(dp[bit][i], i) for i in range(n)]\n        heapq.heapify(pq)\n\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dp[bit][u]:\n                continue\n            for v, l in G[u]:\n                if chmin(dp[bit][v], d + l):\n                    dp[bit][v] = d + l\n                    heapq.heappush(pq, (d + l, v))\n\n    for i in range(k, n):\n        print(dp[-1][i])\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nIn the Kingdom of AtCoder, residents are required to shout their love for takoyaki at \\( A \\) o'clock every day.\n\nTakahashi, who lives in the Kingdom of AtCoder, goes to bed at \\( B \\) o'clock and wakes up at \\( C \\) o'clock every day (in the 24-hour clock). He can shout his love for takoyaki when he is awake, but cannot when he is asleep. Determine whether he can shout his love for takoyaki every day. Here, a day has 24 hours, and his sleeping time is less than 24 hours.\n\n**Constraints**\n- \\( 0 \\leq A, B, C < 24 \\)\n- \\( A \\), \\( B \\), and \\( C \\) are pairwise different.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can shout his love for takoyaki every day, and `No` otherwise.\n\n**Sample Input 1**\n```\n21 8 14\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Takahashi goes to bed at 8 o'clock and wakes up at 14 o'clock every day. He is awake at 21 o'clock, so he can shout his love for takoyaki every day. Therefore, print `Yes`.*\n\n**Sample Input 2**\n```\n0 21 7\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*Takahashi goes to bed at 21 o'clock and wakes up at 7 o'clock every day. He is not awake at 0 o'clock, so he cannot shout his love for takoyaki every day. Therefore, print `No`.*\n\n**Sample Input 3**\n```\n10 7 17\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 367 - Editorial\n\n**Problem Solution:**\n\nThe problem can be solved by employing casework based on whether the person is asleep at midnight. \n\n1. **If not asleep at midnight:**\n   - The person sleeps from \\(B\\) to \\(C\\) o\u2019clock. The answer is \"No\" if \\(A\\) o\u2019clock is between \\(B\\) and \\(C\\) (\\(B<A<C\\)). Otherwise, the answer is \"Yes\".\n\n2. **If asleep at midnight:**\n   - The person is awake from \\(C\\) to \\(B\\) o\u2019clock. The answer is \"Yes\" if \\(A\\) o\u2019clock is between \\(C\\) and \\(B\\) (\\(C<A<B\\)). Otherwise, the answer is \"No\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A and A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A and A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Alternative Approach:**\n\nTo avoid casework, use a while statement starting from \\(B\\) and increment hour by hour. If \\(A\\) is reached before \\(C\\), print \"No\". Otherwise, print \"Yes\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nnow = B\nwhile now != C:\n    if now == A:\n        print(\"No\")\n        exit()\n    now += 1\n    now %= 24\n\nprint(\"Yes\")\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n## Problem Statement\n\nYou are given \\( N \\) intervals numbered from 1 to \\( N \\). Interval \\( i \\) is \\([L_i, R_i]\\).\n\nTwo intervals \\([l_a, r_a]\\) and \\([l_b, r_b]\\) are said to **intersect** if and only if they satisfy either \\((l_a < l_b < r_a < r_b)\\) or \\((l_b < l_a < r_b < r_a)\\).\n\nDefine \\( f(l, r) \\) as the number of intervals \\( i \\) \\((1 \\leq i \\leq N)\\) that intersect with the interval \\([l, r]\\).\n\nAmong all pairs of **integers** \\((l, r)\\) satisfying \\( 0 \\leq l < r \\leq 10^9 \\), find the pair \\((l, r)\\) that maximizes \\( f(l, r) \\). If there are multiple such pairs, choose the one with the smallest \\( l \\). If there are still multiple pairs, choose the one with the smallest \\( r \\) among them. (Since \\( 0 \\leq l < r \\), the pair \\((l, r)\\) to be answered is uniquely determined.)\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 0 \\leq L_i < R_i \\leq 10^9 \\) for \\( 1 \\leq i \\leq N \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nL_1 R_1\nL_2 R_2\n\u22ee\nL_N R_N\n```\n\n### Output\n\nPrint the sought pair \\((l, r)\\) in the following format:\n\n```\nl r\n```\n\n### Sample Input 1\n\n```\n5\n1 7\n3 9\n7 18\n10 14\n15 20\n```\n\n### Sample Output 1\n\n```\n4 11\n```\n\nThe maximum value of \\( f(l, r) \\) is \\( 4 \\), and among the pairs \\((l, r)\\) that achieve \\( f(l, r) = 4 \\), the smallest \\( l \\) is 4. The pairs \\((l, r)\\) that satisfy \\( f(l, r) = 4 \\) and \\( l = 4 \\) are the following five: \n\n- \\((l, r) = (4, 11)\\)\n- \\((l, r) = (4, 12)\\)\n- \\((l, r) = (4, 13)\\)\n- \\((l, r) = (4, 16)\\)\n- \\((l, r) = (4, 17)\\)\n\nAmong these, the smallest \\( r \\) is 11, so print 4 and 11.\n\n### Sample Input 2\n\n```\n11\n856977192 996441446\n298251737 935869360\n396653206 658841528\n710569907 929136831\n325371222 425309117\n379628374 697340458\n835681913 939343451\n140179224 887672320\n375607390 611397526\n93530028 581033295\n249611310 775998537\n```\n\n### Sample Output 2\n\n```\n396653207 887672321\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 360\n\n# We consider the problem by mapping segments [l,r] onto the two-dimensional plane.\n# Segments (l,r) that intersect with segment i satisfy L_i < l < R_i < r or l < L_i < r < R_i,\n# forming disjoint rectangular regions. Thus, it is sufficient to find the region of (l,r)\n# that intersects with each segment and find the place covered by the most number of regions.\n\n# Given N tuples of integers (x_i,y_i,z_i,w_i), find (L,R) that maximizes the number of indices i\n# with x_i <= L <= y_i, z_i <= R <= w_i.\n\n# This can be solved with a search line algorithm as follows:\n\n# You are given an array C whose elements are initially 0. Initialize the maximum value with 0.\n# Given N tuples of integers (x_i,y_i,z_i,w_i), perform the following procedure for l=0,...,10**9 in order:\n\n# 1. For each tuple (x_j,y_j,z_j,w_j) with x_j=l, for each r with z_j <= r <= w_j, increment C[r] by 1.\n# 2. Retrieve the maximum value of C. If the maximum value should be updated, record the current l and r\n#    that achieves the maximum.\n# 3. For each tuple (x_j,y_j,z_j,w_j) with y_j=l, for each r with z_j <= r <= w_j, increment C[r] by -1.\n\n# By applying coordinate compression, this can be reduced to O(N). Specifically, l can take L_i+1 or R_i-1.\n# Also, r can take L_i+1, R_i-1, or R_i+1. A segment-add segment-max lazy segment tree reduces the complexity\n# to O(N log N). If the maximum value of f(l,r) is 0, the answer is always l=0, r=1. For more details, refer to\n# the sample code.\n```\n \n\n", "problem_ids": ["abc364_g", "abc367_a", "abc360_f"]}, "abc329_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\nYou are given a horizontally written text. Convert it to vertical writing, filling spaces with `*`.\n\nYou are given \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\) consisting of lowercase English letters. Let \\( M \\) be the maximum length of these strings.\n\nPrint \\( M \\) strings \\( T_1, T_2, \\dots, T_M \\) that satisfy the following conditions:\n\n1. Each \\( T_i \\) consists of lowercase English letters and `*`.\n2. Each \\( T_i \\) does not end with `*`.\n3. For each \\( 1 \\leq i \\leq N \\), the following holds:\n    - For each \\( 1 \\leq j \\leq |S_i| \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) exists, and the concatenation of the \\( (N-i+1) \\)-th characters of \\( T_1, T_2, \\dots, T_{|S_i|} \\) in this order equals \\( S_i \\).\n    - For each \\( |S_i| + 1 \\leq j \\leq M \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) either does not exist or is `*`.\n\nHere, \\( |S_i| \\) denotes the length of the string \\( S_i \\).\n\nConstraints:\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is a string of lowercase English letters with length between 1 and 100, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\nOutput:\nPrint the answer in the following format:\n```\nT_1\nT_2\n\u22ee\nT_M\n```\n\nSample Input 1:\n```\n3\nabc\nde\nfghi\n```\n\nSample Output 1:\n```\nfda\ngeb\nh*c\ni\n```\n\nSample Input 2:\n```\n3\natcoder\nbeginner\ncontest\n```\n\nSample Output 2:\n```\ncba\noet\nngc\ntio\nend\nsne\nter\n*r\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        First, ignore the condition that \\(T_i\\) does not end with *. Initialize \\(T_1,T_2,\\dots,T_M\\) with a length-\\(N\\) string of *. For each \\(i\\) and \\(j\\), assign the \\(j\\)-th character of \\(S_i\\) to the \\((N-i+1)\\)-th character of \\(T_j\\). To satisfy the second condition, for each \\(T_i\\), remove the last character while it ends with *. \n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(map(len, S))\nT = [[\"*\"] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i][-1] == \"*\":\n        T[i].pop()\n    print(\"\".join(T[i]))\n```\n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(len(s) for s in S)\nT = [['*'] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i] and T[i][-1] == '*':\n        T[i].pop()\n    print(''.join(T[i]))\n}\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), a non-negative integer \\( C \\), and an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nFind \\( \\displaystyle \\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace \\).\n\n**Constraints**\n\n- \\( 1 \\le N \\le 10^5 \\)\n- \\( 1 \\le M \\le 10^9 \\)\n- \\( 0 \\le C < M \\)\n- \\( 1 \\le K \\le 10^9 \\)\n- \\( 0 \\le A_i < M \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M C K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 5 3 3\n1 3\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nFor \\( k=0 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=3 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=1 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=2 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=2 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=2 \\).\n\nTherefore, the answer is \\( 1+1+2=4 \\). Hence, print 4.\n\n**Sample Input 2**\n\n```\n5 4 3 182\n0 3 2 1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Sample Input 3**\n\n```\n5 718 651 193855\n3 532 44 109 58\n```\n\n**Sample Output 3**\n\n```\n29484897\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 182\n\nE - Sum of Min of Mod of Linear Editorial\n\nAs a prerequisite, you need the floor_sum algorithm. This algorithm calculates \\(\\displaystyle f(n,m,a,b)=\\sum_{i=0}^{n-1}\\left\\lfloor\\frac{ai+b}m\\right\\rfloor\\) in \\(O(\\log m)\\) time.\n\nLet\u2019s assume that \\(A\\) has been sorted and duplicates removed so that \\(A_1 < A_2 < ... < A_N\\) holds. Fix \\(j\\), and let \\(S_j\\) be the set of \\(0\\le k < K\\) such that \\(\\displaystyle \\left\\{(Ck+A_j)\\ \\text{mod}\\ M\\right\\}=\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M\\right\\}\\). If \\(j\\geq 2\\), the condition for \\(k\\in S_j\\) can be rephrased as \\(\\left\\{(Ck+A_{j-1})\\ \\text{mod}\\ M \\right\\} > \\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\), and further as \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor=1\\). Since \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\) can only be \\(0\\) or \\(1\\), we have \\(\\displaystyle |S_j|=\\sum_{k=0}^{K-1}\\left(\\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\right)\\).\n\nTherefore,\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{k \\in S_j}\\left(\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\} - \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\right)\\\\\n&=\\sum_{k \\in S_j} (A_j-A_1-M)\\\\\n&=-(M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\nMeanwhile, for \\(j=1\\), we have\n\\[\n\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=0\n\\]\n\nThus, the answer is\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k\\in S_j}\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\} -\\sum_{j=2}^N(M+A_1-A_j)|S_j|\\\\\n&=\\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}-\\sum_{j=2}^N (M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\n\\(\\displaystyle \\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=\\sum_{k=0}^{K-1}\\left(Ck+A_1-M\\left\\lfloor\\frac{Ck+A_1}M \\right\\rfloor\\right)\\) and \\(|S_j|\\) can both be calculated quickly using the floor_sum algorithm.\n\nNow, the problem is solved. The complexity is \\(O(N(\\log N+\\log M))\\), with the bottlenecks being the sorting of \\(A\\) and the calculation of floor_sum. Be careful with overflow during implementation. You can avoid this issue by using multi-precision integers, 128-bit integers, or by using a modint with two different primes (e.g., \\(10^9+7\\) and \\(10^9+9\\)) and reconstructing the result using CRT. Alternatively, you can use a type like C++\u2019s unsigned long long, which guarantees that the correct value modulo \\(2^{64}\\) is returned even in case of overflow. The AtCoder Library\u2019s floor_sum uses unsigned long long and guarantees the correct answer modulo \\(2^{64}\\).\n\nSample Implementation (Python3):\n```python\nfrom atcoder.math import floor_sum\nn, m, c, k = map(int, input().split())\na = sorted(list(set(map(int, input().split()))))\nn = len(a)\nfl = [floor_sum(k, m, c, a[i]) for i in range(n)]\nans = c * k * (k - 1) // 2 + k * a[0] - m * fl[0]\nfor i in range(1, n):\n  ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\nprint(ans)\n```\n\nSample Implementation (Python3, translated from C++):\n```python\nfrom atcoder.math import floor_sum\n\ndef main():\n    n, m, c, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a = list(dict.fromkeys(a))\n    n = len(a)\n    fl = [floor_sum(k, m, c, a[i]) for i in range(n)]\n    ans = k * (k - 1) // 2 * c + k * a[0] - m * fl[0]\n    for i in range(1, n):\n        ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\n    print(ans)\n\nmain()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\n", "problem_ids": ["abc366_b", "arc182_e", "abc361_a"]}, "abc329_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nIn AtCoder, a user's rating is represented as a positive integer. Based on the rating value, a certain number of `^` symbols are displayed. Specifically, here are the display rules for different rating ranges:\n\n- If the rating is between 1 and 99, inclusive, `^` is displayed once.\n- If the rating is between 100 and 199, inclusive, `^` is displayed twice.\n- If the rating is between 200 and 299, inclusive, `^` is displayed three times.\n- If the rating is between 300 and 399, inclusive, `^` is displayed four times.\n\nCurrently, Takahashi's rating is \\( R \\). It is guaranteed that \\( R \\) is an integer between 1 and 299, inclusive.\n\nFind the minimum increase in rating required for Takahashi to increase the number of displayed `^`.\n\nIt is guaranteed that under the constraints of this problem, it is possible for Takahashi to increase the number of `^` without his rating reaching 400 or above.\n\n**Constraints**\n\n- \\( 1 \\leq R \\leq 299 \\)\n- \\( R \\) is an integer.\n\n**Input**\n\nThe input is given from standard input as follows:\n```\nR\n```\n\n**Output**\n\nPrint, as an integer, the minimum increase in rating required for Takahashi to increase the number of displayed `^`.\n\n**Sample Input 1**\n```\n123\n```\n\n**Sample Output 1**\n```\n77\n```\n\nTakahashi's current rating is 123, and `^` is displayed twice. By increasing his rating by 77, his rating will become 200, and `^` will be displayed three times. When the rating is 199 or below, `^` is displayed not more than twice, so we print 77.\n\n**Sample Input 2**\n```\n250\n```\n\n**Sample Output 2**\n```\n50\n```\n\nSolution:\n\n        Here is the cleaned-up version of the coding problem editorial:\n\n---\n\n**Official A - Piling Up Editorial**\n\nTo determine the increase in rating required, we denote the current rating by \\(R\\):\n\n- \\((100-R)\\) if \\(1 \\leq R \\leq 99\\)\n- \\((200-R)\\) if \\(100 \\leq R \\leq 199\\)\n- \\((300-R)\\) if \\(200 \\leq R \\leq 299\\)\n\nThis value can be printed using an if statement. Alternatively, using the remainder when \\(R\\) is divided by \\(100\\), one can implement the solution without a conditional branch.\n\n**Sample code in C++:**\n\n```python\nr = int(input())\nif r < 100:\n    print(100 - r)\nelif r < 200:\n    print(200 - r)\nelse:\n    print(300 - r)\n```\n\n**Sample code in Python:**\n\n```python\nr = int(input())\nif r < 100:\n    print(100 - r)\nelif r < 200:\n    print(200 - r)\nelse:\n    print(300 - r)\n```\n\n**Sample code in C++ (alternate solution):**\n\n```python\nr = int(input())\nprint(100 - (r % 100))\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere are \\( N \\) people, numbered from 1 to \\( N \\). A competition was held among these \\( N \\) people, and they were ranked accordingly. The following information is given about their ranks:\n\n1. Each person has a unique rank.\n2. For each \\( 1 \\leq i \\leq M \\), if person \\( A_i \\) is ranked \\( x \\)-th and person \\( B_i \\) is ranked \\( y \\)-th, then \\( x - y = C_i \\).\n\nThe given input guarantees that there is at least one possible ranking that does not contradict the given information.\n\nYou need to answer \\( N \\) queries. The answer to the \\( i \\)-th query is determined as follows:\n- If the rank of person \\( i \\) can be uniquely determined, return that rank.\n- Otherwise, return \\(-1\\).\n\n### Constraints\n- \\( 2 \\leq N \\leq 16 \\)\n- \\( 0 \\leq M \\leq \\frac{N(N - 1)}{2} \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq N - 1 \\)\n- \\( (A_i, B_i) \\neq (A_j, B_j) \\) if \\( i \\neq j \\)\n- All input values are integers\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n### Output\nPrint the answers to the \\( 1 \\)-st, \\( 2 \\)-nd, ..., \\( N \\)-th queries in this order, separated by spaces.\n\n### Sample Input 1\n```\n5 2\n2 3 3\n5 4 3\n```\n\n### Sample Output 1\n```\n3 -1 -1 -1 -1\n```\n\nExplanation: Let \\( X_i \\) be the rank of person \\( i \\). The possible rankings could be \\( (3, 4, 1, 2, 5) \\) or \\( (3, 5, 2, 1, 4) \\). Therefore, only the rank of person 1 is uniquely determined as 3.\n\n### Sample Input 2\n```\n3 0\n```\n\n### Sample Output 2\n```\n-1 -1 -1\n```\n\n### Sample Input 3\n```\n8 5\n6 7 3\n8 1 7\n4 5 1\n7 2 1\n6 2 4\n```\n\n### Sample Output 3\n```\n1 -1 -1 -1 -1 -1 -1 8\n```\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 352\n\nConsider a \\(N\\)-vertex \\(M\\)-edge graph whose \\(i\\)-th edge connects vertex \\(A_i\\) and vertex \\(B_i\\). By the constraints, we can take an integer sequence \\(D = (D_1, D_2, \\ldots, D_N)\\) such that \\(D_{A_i} - D_{B_i} = C_i\\) for each \\(i\\). This sequence can be obtained by appropriately performing DFS (Depth-First Search) or BFS (Breadth-First Search) on the graph defined above. The sequence of person \\(i\\)\u2019s rank \\(X_i\\), collectively written as \\(X = (X_1, X_2, \\ldots, X_N)\\), is limited to permutations of \\((1,2,\\ldots, N)\\) such that:\n\n\\(X_i = D_i + v\\), where \\(v\\) is an arbitrary integer taken for each connected component and \\(i\\) is any of the vertices in it.\n\nWe try to respond to the query per connected component. When finding the answer to the \\(i\\)-th query, we perform a bit DP (Dynamic Programming) that places connected components not containing vertex \\(i\\). Specifically, maintain boolean values \\(dp_{x,y}\\) that represent whether the vertices in the first \\(x\\) connected components may correspond to the set of ranks \\(y\\). Since there are \\(O(N)\\) pairs of possible tuples of rank for each connected component, the DP above costs \\(O(N^2 2^N)\\) time naively, or \\(O(N 2^N)\\) time if you use the property that the value of \\(x\\) uniquely determines the popcount of \\(y\\). Therefore, the problem has been solved in a total of \\(O(N^2 2^N)\\) time.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n---\n**Problem Statement**\n\nYou are given a directed graph with \\( N \\) vertices and \\( M \\) edges. The \\( j \\)-th directed edge goes from vertex \\( u_j \\) to vertex \\( v_j \\) and has a weight of \\( w_j \\).\n\nFind one way to assign an integer between \\(-10^{18}\\) and \\(10^{18}\\), inclusive, to each vertex such that the following condition is satisfied:\n\n- Let \\( x_i \\) be the value assigned to vertex \\( i \\). For all edges \\( j = 1, 2, \\dots, M \\), it holds that \\( x_{v_j} - x_{u_j} = w_j \\).\n\nIt is guaranteed that at least one such assignment exists for the given input.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq \\min\\{2 \\times 10^5, \\frac{N(N-1)}{2}\\} \\)\n- \\( 1 \\leq u_j, v_j \\leq N \\)\n- \\( u_j \\neq v_j \\)\n- If \\( i \\neq j \\), then \\( (u_i, v_i) \\neq (u_j, v_j) \\) and \\( (u_i, v_i) \\neq (v_j, u_j) \\)\n- \\( |w_j| \\leq 10^9 \\)\n- All input values are integers.\n- There exists at least one assignment satisfying the conditions.\n\n**Input**\n\nThe input is given in the following format:\n\n```\nN M\nu_1 v_1 w_1\nu_2 v_2 w_2\n\u22ee\nu_M v_M w_M\n```\n\n**Output**\n\nLet \\( x_i \\) be the integer written on vertex \\( i \\). Print \\( x_1, x_2, \\dots, x_N \\) in this order, separated by spaces, on a single line. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n\n```\n3 3\n1 2 2\n3 2 3\n1 3 -1\n```\n\n**Sample Output 1**\n\n```\n3 5 2\n```\n\nBy setting \\( x = (3, 5, 2) \\), we have \\( x_2 - x_1 = w_1 = 2 \\), \\( x_2 - x_3 = w_2 = 3 \\), \\( x_3 - x_1 = w_3 = -1 \\), satisfying the conditions. For example, \\( x = (-1, 1, -2) \\) is also a valid answer.\n\n**Sample Input 2**\n\n```\n4 2\n2 1 5\n3 4 -3\n```\n\n**Sample Output 2**\n\n```\n5 0 6 3\n```\n\nFor example, \\( x = (0, -5, 4, 1) \\) and \\( x = (5, 0, 4, 1) \\) are also valid answers.\n\n**Sample Input 3**\n\n```\n5 7\n2 1 18169343\n3 1 307110901\n4 1 130955934\n2 3 -288941558\n2 5 96267410\n5 3 -385208968\n4 3 -176154967\n```\n\n**Sample Output 3**\n\n```\n200401298 182231955 -106709603 69445364 278499365\n```\n\nSolution:\n\n```python\n        For each connected component of the graph, once the value to be written on any vertex in it is fixed, all the values to be written are uniquely determined. This is because, once you determine the value for a vertex, the value for adjacent vertices is also determined in a chain. Thus, the problem can be solved by inspecting vertices one by one, and if the current vertex does not have a value assigned, set an arbitrary value (like 0) to it and determine the values for all the other connected vertices. This kind of process can be implemented as a Depth-First Search (DFS) or Breadth-First Search (BFS). The time complexity is \\(O(N+M)\\).\n\n```python\n# Read the input\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, w))\n    G[v].append((u, -w))\n\nvisited = [False] * N  # Whether the values are determined\nans = [0] * N  # The values to write\nfor i in range(N):\n    # Skip if the value is already determined\n    if visited[i]:\n        continue\n    # Set the value for vertex i to 0, and start searching\n    st = [i]\n    visited[i] = True\n    while st:\n        # Currently at vertex u\n        u = st.pop()\n        # Inspect vertex v adjacent to vertex u\n        for v, w in G[u]:\n            if not visited[v]:\n                # If the value for vertex v is undetermined, determine the value so that it is consistent with that for vertex u\n                visited[v] = True\n                ans[v] = ans[u] + w\n                st.append(v)\nprint(*ans)\n```\n```\n \n\n", "problem_ids": ["abc363_a", "abc352_f", "abc373_d"]}, "abc329_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a simple connected undirected graph with \\( N \\) vertices and \\( M \\) edges. Each vertex \\( i \\,(1 \\leq i \\leq N) \\) has a weight \\( A_i \\). Each edge \\( j \\,(1 \\leq j \\leq M) \\) connects vertices \\( U_j \\) and \\( V_j \\) bidirectionally and has a weight \\( B_j \\).\n\nThe weight of a path in this graph is defined as the sum of the weights of the vertices and edges that appear on the path.\n\nFor each \\( i = 2, 3, \\dots, N \\), solve the following problem:\n- Find the minimum weight of a path from vertex 1 to vertex \\( i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_j < V_j \\leq N \\)\n- \\( (U_i, V_i) \\neq (U_j, V_j) \\) if \\( i \\neq j \\).\n- The graph is connected.\n- \\( 0 \\leq A_i \\leq 10^9 \\)\n- \\( 0 \\leq B_j \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format: \n\n```\nN M\nA_1 A_2 \\dots A_N\nU_1 V_1 B_1\nU_2 V_2 B_2\n\\vdots\nU_M V_M B_M\n```\n\n**Output:**\n\nPrint the answers for \\( i = 2, 3, \\dots, N \\) in a single line, separated by spaces.\n\n**Sample Input 1:**\n\n```\n3 3\n1 2 3\n1 2 1\n1 3 6\n2 3 2\n```\n\n**Sample Output 1:**\n\n```\n4 9\n```\n\n**Explanation:**\n\nConsider the paths from vertex 1 to vertex 2. The weight of the path \\( 1 \\to 2 \\) is \\( A_1 + B_1 + A_2 = 1 + 1 + 2 = 4 \\), and the weight of the path \\( 1 \\to 3 \\to 2 \\) is \\( A_1 + B_2 + A_3 + B_3 + A_2 = 1 + 6 + 3 + 2 + 2 = 14 \\). The minimum weight is 4.\n\nConsider the paths from vertex 1 to vertex 3. The weight of the path \\( 1 \\to 3 \\) is \\( A_1 + B_2 + A_3 = 1 + 6 + 3 = 10 \\), and the weight of the path \\( 1 \\to 2 \\to 3 \\) is \\( A_1 + B_1 + A_2 + B_3 + A_3 = 1 + 1 + 2 + 2 + 3 = 9 \\). The minimum weight is 9.\n\n**Sample Input 2:**\n\n```\n2 1\n0 1\n1 2 3\n```\n\n**Sample Output 2:**\n\n```\n4\n```\n\n**Sample Input 3:**\n\n```\n5 8\n928448202 994752369 906965437 942744902 907560126\n2 5 975090662\n1 2 908843627\n1 5 969061140\n3 4 964249326\n2 3 957690728\n2 4 942986477\n4 5 948404113\n1 3 988716403\n```\n\n**Sample Output 3:**\n\n```\n2832044198 2824130042 4696218483 2805069468\n```\n\nNote that the answers may not fit in a 32-bit integer.\n\nSolution:\n\n```python\n\"\"\"\nEditorial - Toyota Programming Contest 2024#7 (AtCoder Beginner Contest 362)\n\nD - Shortest Path 3 Editorial\n\nThis is an exercise of an algorithm to find the shortest length of a path on a graph. For a graph with non-negative edge weights, the shortest length of a path can be found fast with Dijkstra\u2019s algorithm. In this problem, vertices have weights too, so we cannot directly apply Dijkstra\u2019s algorithm. Instead, we rephrase it into an edge-weighted problem. When traveling from vertex \\(U_i\\) to vertex \\(V_j\\) only via edge \\(j\\), the cost newly imposed is the cost to use edge \\(j\\) and to visit vertex \\(V_j\\), for a total of \\(B_j + A_{V_j}\\). Conversely, when traveling from vertex \\(V_i\\) to vertex \\(U_j\\) only via edge \\(j\\), the cost newly imposed is the cost to use edge \\(j\\) and to visit vertex \\(U_j\\), for a total of \\(B_j + A_{U_j}\\). Thus, by adding an edge of weight \\(B_j + A_{V_j}\\) in the direction of \\(U_j \\to V_j\\) and an edge of weight \\(B_j + A_{U_j}\\) in the direction of \\(V_j \\to U_j\\), every cost can be represented only with edge weights. By applying Dijkstra\u2019s algorithm on this graph and finally adding the weight of the initial point \\(A_1\\), one can find the answer. The time complexity is \\(O(M \\log N)\\).\n\"\"\"\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree \\(T\\) with \\(N\\) vertices. The vertices are numbered from \\(1\\) to \\(N\\), and the \\(i\\)-th edge \\((1 \\leq i \\leq N-1)\\) connects vertices \\(u_i\\) and \\(v_i\\) bidirectionally.\n\nUsing \\(T\\), define a complete graph \\(G\\) with \\(N\\) vertices as follows:\n- The weight \\(w(x,y)\\) of the edge between vertices \\(x\\) and \\(y\\) in \\(G\\) is the shortest distance between vertices \\(x\\) and \\(y\\) in \\(T\\).\n\nFind one maximum weight maximum matching in \\(G\\). That is, find a set of \\(\\lfloor N/2 \\rfloor\\) pairs of vertices \\(M = \\{(x_1, y_1), (x_2, y_2), \\dots, (x_{\\lfloor N/2 \\rfloor}, y_{\\lfloor N/2 \\rfloor})\\}\\) such that each vertex \\(1, 2, \\dots, N\\) appears in \\(M\\) at most once, and \\(\\sum_{i=1}^{\\lfloor N/2 \\rfloor} w(x_i, y_i)\\) is maximized.\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq u_i < v_i \\leq N\\)\n- The input graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nu_1 v_1\nu_2 v_2\n...\nu_{N-1} v_{N-1}\n```\n\n**Output**\n\nPrint a solution as a set of pairs \\(\\{(x_1, y_1), (x_2, y_2), \\dots, (x_{\\lfloor N/2 \\rfloor}, y_{\\lfloor N/2 \\rfloor})\\}\\) in the following format. If multiple solutions exist, any of them is acceptable.\n\n```\nx_1 y_1\nx_2 y_2\n...\nx_{\\lfloor N/2 \\rfloor} y_{\\lfloor N/2 \\rfloor}\n```\n\n**Sample Input 1**\n\n```\n4\n1 2\n2 3\n3 4\n```\n\n**Sample Output 1**\n\n```\n2 4\n1 3\n```\n\nIn \\(T\\), the distance between vertices \\(2\\) and \\(4\\) is \\(2\\), and the distance between vertices \\(1\\) and \\(3\\) is \\(2\\), so the weight of the matching \\(\\{(2,4), (1,3)\\}\\) is \\(4\\). There is no matching with a weight greater than \\(4\\), so this is a maximum weight maximum matching. Other acceptable outputs include:\n\n```\n2 3\n1 4\n```\n\n**Sample Input 2**\n\n```\n3\n1 2\n2 3\n```\n\n**Sample Output 2**\n\n```\n1 3\n```\n\nIn \\(T\\), the distance between vertices \\(1\\) and \\(3\\) is \\(2\\), so the weight of the matching \\(\\{(1,3)\\}\\) is \\(2\\). There is no matching with a weight greater than \\(2\\), so this is a maximum weight maximum matching. Another acceptable output is:\n\n```\n3 1\n```\n\nSolution:\n\n```python\n# Editorial - Perfect Matching on a Tree\n\nDefine the contribution of an edge \\(i\\) of \\(T\\) in a matching as the number of pairs in the matching that stride over edge \\(i\\). The weight of the matching is the sum of the contributions of the edges. Removing an edge \\(i\\) from \\(T\\) splits it into two subtrees. If they have \\(c_i\\) and \\((N-c_i)\\) edges, the contribution of edge \\(i\\) never exceeds \\(\\min\\{c_i, N-c_i\\}\\). Thus, the weight of the matching is at most \\(\\sum_{i=1}^{N-1} \\min\\{c_i, N-c_i\\}\\).\n\nThere is a centroid \\(g\\) of a tree \\(T\\), a vertex such that by removing \\(g\\), every resulting subtree has a weight of \\(\\lfloor N/2 \\rfloor\\) or less. Every tree has a centroid, and it can be found in \\(O(N)\\) time with DFS. To construct a solution achieving the upper bound:\n\n1. Find a centroid \\(g\\) of the tree \\(T\\).\n2. Let \\(T_1, T_2, \\dots, T_k\\) be the subtrees obtained by removing \\(g\\) from \\(T\\).\n3. Construct an array \\(A\\) consisting of all vertices of \\(T_1\\), \\(T_2\\), ..., \\(T_k\\).\n4. If \\(N\\) is an even number, add \\(g\\) to the tail of \\(A\\).\n5. For each \\(i = 1, 2, \\dots, \\lfloor N/2 \\rfloor\\), match vertices \\(A_i\\) and \\(A_{i+\\lfloor N/2 \\rfloor}\\).\n\nThis algorithm ensures that for each matched pair \\((A_i, A_{i+\\lfloor N/2 \\rfloor})\\), the vertices belong to different subtrees. If all pairs belong to different subtrees, the weight of the matching achieves the upper bound. The \\(x-y\\) path always passes through the edge contributing the maximal count achievable in this configuration.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) rest areas around a lake. The rest areas are numbered \\( 1, 2, \\ldots, N \\) in clockwise order. It takes \\( A_i \\) steps to walk clockwise from rest area \\( i \\) to rest area \\( i+1 \\) (where rest area \\( N+1 \\) refers to rest area \\( 1 \\)).\n\nThe minimum number of steps required to walk clockwise from rest area \\( s \\) to rest area \\( t \\) (\\( s \\neq t \\)) must be a multiple of \\( M \\).\n\nDetermine the number of possible pairs \\((s, t)\\).\n\n**Constraints**\n\n- All input values are integers\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 10^6 \\)\n\n**Input Format**\n\nThe input is given from the standard input in the following format:\n\n```\nN M\nA_1 A_2 \\ldots A_N\n```\n\n**Output Format**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n4 3\n2 1 4 3\n```\n\n**Sample Output 1**\n```\n4\n```\n\n**Explanation**\n\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 2 is 2, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 3 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 4 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 3 is 1, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 4 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 1 is 8, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 4 is 4, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 1 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 2 is 9, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 1 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 2 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 3 is 6, which is a multiple of 3.\n\nThus, there are four possible pairs \\( (s, t) \\).\n\n**Sample Input 2**\n```\n2 1000000\n1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n9 5\n9 9 8 2 4 4 3 5 3\n```\n\n**Sample Output 3**\n```\n11\n```\n\nSolution:\n\n```python\n# Here is the cleaned version of the editorial:\n\n# For convenience, reassign the index \\((k-1)\\) to rest area \\(k\\) to treat indices from \\(0\\) through \\((N-1)\\). Consider the following array. Let \\(R_i\\) be the number of steps, modulo \\(M\\), required to travel from rest area \\(0\\) to rest area \\(i \\% N\\) as the \\(i\\)-th rest area to encounter. Precalculate these values for \\(i\\) from \\(0\\) through \\(2N-1\\). For example, if \\(A=(1,2,3,4)\\) and \\(M=6\\)...ultiple of \\(M\\)?\n\n# If \\(s<t\\), it holds when \\(R_s = R_t\\). This is equivalent to \\(R_{N+s}=R_{N+t}\\). If \\(s>t\\), it holds when \\(R_s = R_{N+t}\\).\n\n# Therefore, it is sufficient to solve the following problem:\n\n# Find the sum of the following value for \\(i=N,N+1,\\dots,2N-1\\). How many elements among \\(R_{i-N+1},R_{i-N+2},\\dots,R_{i-1}\\) are equal to \\(R_i\\)?\n\n# Intuitively, we are summing up the number of rest areas \\(i \\% N\\) to which the minimum steps required is a multiple of \\(M\\), over \\(i=N,N+1,\\dots,2N-1\\). This problem can be solved as follows:\n\n# First, let \\(B=(B[0],B[1],\\dots,B[M-1])\\) be the array of occurrences of \\(k\\) between \\(0\\) and \\(M-1\\) in \\(R_0\\) through \\(R_{N-1}\\). For \\(i = N,N+1,\\dots,2N-1\\), repeat the following:\n\n# Decrease \\(B[R_{i-N}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i-1\\).\n\n# Add \\(B[R_{i}]\\) Increase \\(B[R_{i}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i\\).\n\n# Translated sample code (Python 3):\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    r = [0]\n    for i in range(2 * n):\n        r.append((r[-1] + a[i % n]) % m)\n    b = [0] * m\n    for i in range(n):\n        b[r[i]] += 1\n    res = 0\n    for i in range(n, 2 * n):\n        b[r[i - n]] -= 1\n        res += b[r[i]]\n        b[r[i]] += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc362_d", "abc362_f", "abc367_d"]}, "abc329_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) servals on a bridge of length \\( L \\). The \\( i \\)-th serval is located at position \\( A_i \\) from the left end of the bridge. Here, \\( 0 < A_1 < A_2 < \\cdots < A_N < L \\) holds. For each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nThe servals will perform the following three actions in order:\n\n1. **Action 1:** The \\( N - 1 \\) servals other than the \\( i \\)-th serval face left or right.\n2. **Action 2:** The \\( i \\)-th serval faces left or right.\n3. **Action 3:** All servals start moving simultaneously. All servals move at a constant speed of exactly 1 unit distance per unit time. When a serval reaches the end of the bridge, it leaves the bridge. If two servals collide, they both reverse their direction and continue moving.\n\nThe \\( i \\)-th serval is smart and loves this bridge, so when choosing a direction in Action 2, it will observe the directions of the other \\( N-1 \\) servals and choose the direction that allows it to stay on the bridge longer during Action 3. \n\nThere are \\( 2^{N-1} \\) possible combinations of directions for the \\( N-1 \\) servals in Action 1. Find the sum, modulo \\( 998244353 \\), over all these combinations, of the durations the \\( i \\)-th serval can stay on the bridge. It can be proved that the output value is an integer.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 10^{5} \\)\n- \\( 0 < A_1 < A_2 < \\cdots < A_N < L \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN L\nA_1 A_2 \\cdots A_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain the answer for \\( i = k \\).\n\n**Sample Input 1:**\n\n```\n2 167\n9 24\n```\n\n**Sample Output 1:**\n\n```\n182\n301\n```\n\nFor \\( i = 1 \\), it is always optimal to face right. For \\( i = 2 \\), it is optimal to face the opposite direction from the first serval.\n\n**Sample Input 2:**\n\n```\n1 924\n167\n```\n\n**Sample Output 2:**\n\n```\n757\n```\n\n**Sample Input 3:**\n\n```\n10 924924167\n46001560 235529797 272749755 301863061 359726177 470023587 667800476 696193062 741860924 809211293\n```\n\n**Sample Output 3:**\n\n```\n112048251\n409175578\n167800512\n997730745\n278651538\n581491882\n884751575\n570877705\n747965896\n80750577\n```\n\nSolution:\n\nHere is the cleaned version of the coding problem editorial:\n\n---\n\n**When and where do they leave the bridge?**  \nAfter Action 2, suppose there are \\(l\\) servals facing left: the \\(X_{1}\\)-th, \\(X_{2}\\)-th, \\(\\cdots\\), \\(X_{l}\\)-th servals from left to right. Also, suppose there are \\(r\\) servals facing right: the \\(Y_{1}\\)-th, \\(Y_{2}\\)-th, \\(\\cdots\\), \\(Y_{r}\\)-th servals from left to right.  \n- If \\(i \\leq l\\), the \\(i\\)-th serval will reach the left end, and the time it can stay on the bridge is \\(A_{X_{i}}\\).\n- If \\(l < i\\), the \\(i\\)-th serval will reach the right end, and the time it can stay on the bridge is \\(L - A_{Y_{N-i}}\\).\n\nThis holds because the relative positions of the servals do not change.\n\n**Optimal direction to face:**  \nGiven the properties, if \\((i \\leq l')\\), it is optimal for the \\(i\\)-th serval to face right to reach the left end. If \\((N+1-i \\leq r')\\), it should face left. If \\((l' = i - 1\\) and \\(r' = N - i)\\), evaluate the serval's optimal direction based on comparisons of \\(A_{i}\\) and \\(L - A_{i}\\).\n\n**Considering contributions:**  \nCalculate contributions for:\n\n1. When \\(i \\leq l'\\) and the time \\(i\\) reaches the left end to be \\(A_{j}\\).\n\n2. When \\(N+1-i \\leq r'\\) and the time \\(i\\) reaches the right end to be \\(L - A_{j}\\).\n\n3. When \\((l' = i - 1)\\) and \\((r' = N - i)\\) for the left. Calculate as a polynomial and evaluate using convolution.\n\nBy calculating all of the above and summing contributions, the final result is obtained with a complexity of \\(O(N(\\log{N})^{2})\\).\n\n**C++ Implementation:**  \nIncludes convolution and addition functions, input handling, and binomial calculations for solving the problem effectively.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\nYou can perform the following two types of operations zero or more times in any order:\n\n1. Choose a (contiguous) substring \\( ABA \\) in \\( S \\) and replace it with \\( A \\).\n2. Choose a (contiguous) substring \\( BAB \\) in \\( S \\) and replace it with \\( B \\).\n\nFind, modulo \\( 10^9+7 \\), the number of possible strings \\( S \\) after performing the operations.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 250000 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n4\nABAB\n```\n\n**Sample Output 1**\n\n```\n2\n```\n\nThe two possible strings \\( S \\) after the operations are as follows:\n- \\( ABAB \\): This string can be obtained by performing zero operations.\n- \\( AB \\): The 1st to 3rd characters of \\( S=ABAB \\) are \\( ABA \\). Replacing them with \\( A \\) results in \\( S=AB \\).\n\nHere, the 2nd to 4th characters of \\( S=ABAB \\) are \\( BAB \\), so you can also replace them with \\( B \\). Note, however, that the resulting \\( AB \\) does not count multiple times.\n\n**Sample Input 2**\n\n```\n1\nA\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\nNo operations can be performed.\n\n**Sample Input 3**\n\n```\n17\nBBABABAABABAAAABA\n```\n\n**Sample Output 3**\n\n```\n18\n```\n\n**Sample Input 4**\n\n```\n100\nABAABAABABBABAABAABAABABBABBABBABBABBABBABBABBABBABBABBABBABBABAABABAABABBABBABABBABAABAABAABAABA\n```\n\n**Sample Output 4**\n\n```\n415919090\n```\n\nRemember to take the result modulo \\( 10^9+7 \\).\n\nSolution:\n\n```\nIn competitive programming, a well-known technique is using parity to perform inversions. Let\u2019s apply it to this problem. Specifically, let\u2019s invert the characters A and B only at even positions in the input string. Then, the two available operations become:\n\nAAA \u2192 A  \nBBB \u2192 B  \n\nWith this transformation, the solution becomes straightforward. For a contiguous segment of A or B, as long as its length does not become zero, we can reduce the length by 2 each time. For example, if there is a segment AAAAA, the possible final states are AAAAA, AAA, and A: there are three. Therefore, if the length of a segment of consecutive identical characters is L, the number of possible final states for that segment is floor((L+1)/2). For all segments of consecutive identical characters, the final states can be chosen independently. Thus, the product of the above values for all such segments is the answer to this problem.\n```\n \n\n", "problem_ids": ["abc361_a", "arc178_e", "arc180_a"]}, "abc330_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThis problem is interactive, and the judge is adaptive. See the notes for details. Also, the parameters in the problem statement are fixed at \\( N = 1000 \\), \\( M = 10 \\), \\( Q = 950 \\).\n\nThere are \\( N \\) coins numbered \\( 1, 2, \\dots, N \\). Exactly \\( M \\) of these coins are counterfeit. An appraiser can, in one appraisal, determine whether two coins are of the same type or different types. Specifically:\n- If the two coins are both genuine or both counterfeit, they are judged to be of the same type.\n- Otherwise, they are judged to be of different types.\n\nIdentify all the counterfeit coins using at most \\( Q \\) appraisals.\n\n**Constraints**\n- \\( N = 1000 \\)\n- \\( M = 10 \\)\n- \\( Q = 950 \\)\n\n**Interaction**\n\nThis is an interactive problem. Initially, receive \\( N \\), \\( M \\), and \\( Q \\) from Standard Input:\n\n```\nN M Q\n```\n\nNext, you can perform appraisals between 0 and \\( Q \\) times, inclusive, as follows.\n\nFirst, by outputting to Standard Output in the following format, you indicate that you are appraising coins \\( x \\) and \\( y \\). (Include a newline at the end.)\n\n```\n? x y\n```\n\nHere, \\( x \\) and \\( y \\) must be distinct integers between 1 and \\( N \\), inclusive.\n\nIn response, the judge system will reply with one of the following three responses.\n\n- `0`: If the response is `0`, it means that coins \\( x \\) and \\( y \\) are of the same type.\n- `1`: If the response is `1`, it means that coins \\( x \\) and \\( y \\) are of different types.\n- `-1`: If the response is `-1`, it means that the appraisal is invalid. Specifically, this response is given when at least one of the following conditions is met:\n  - The outputted \\( x \\) and \\( y \\) do not satisfy the constraints.\n  - The number of appraisals exceeds \\( Q \\).\n\nIf you receive this response, your program is considered incorrect. Terminate your program immediately.\n\nFinally, by outputting to Standard Output in the following format, you answer that coins \\( A_1, A_2, \\ldots, A_M \\) are counterfeit. (Include a newline at the end.)\n\n```\n! A_1 A_2 \\dots A_M\n```\n\nHere, \\( A_i \\) must be distinct integers between 1 and \\( N \\), inclusive. After this output, terminate your program immediately.\n\nIf any of your outputs do not meet the specified format, your program will be considered incorrect. The judge will then respond with `-1`, so in that case, terminate your program immediately.\n\n**Notes**\n- Every time you output, include a newline at the end and flush Standard Output. Failure to do so may result in a verdict of Time Limit Exceeded (TLE) or Wrong Answer (WA).\n- After outputting your answer (or receiving `-1`), terminate your program immediately. Otherwise, the verdict is indeterminate.\n- Beware that unnecessary newlines are considered malformed.\n- The judge for this problem is adaptive. That is, at any point, as long as consistency can be maintained, the judge may change which coins are counterfeit. See the sample interaction for details.\n\n**Sample Interaction**\n\nIn this interaction, \\( N = 5 \\), \\( M = 2 \\), \\( Q = 10 \\), and the judge initially considers coins 1 and 2 to be counterfeit.\n\n*Note*: This example does not meet the constraints and is not included in the judge.\n\n**Input**\n```\n5 2 10\n```\n**Output**\n```\n? 1 2\n```\n**Explanation**: You appraise coins 1 and 2.\n\n**Input**\n```\n0\n```\n**Explanation**: Coins 1 and 2 are judged to be of the same type.\n\n**Output**\n```\n? 1 3\n```\n**Explanation**: You appraise coins 1 and 3.\n\n**Input**\n```\n1\n```\n**Explanation**: Coins 1 and 3 are judged to be of different types.\n\n**Output**\n```\n? 1 4\n```\n**Explanation**: You appraise coins 1 and 4.\n\n**Input**\n```\n1\n```\n**Explanation**: Coins 1 and 4 are judged to be of different types.\n\n**Output**\n```\n! 1 2\n```\n**Explanation**: You answer that coins 1 and 2 are counterfeit.\n\nIndeed, coins 1 and 2 are considered counterfeit, but it is also possible to consider coins 3 and 4 as counterfeit while maintaining consistency. Therefore, the judge may change the counterfeit coins to 3 and 4. As a result, the judge may judge this answer as incorrect.\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 184\n\nA - Appraiser Editorial by evima\n\nThe key point of this problem is that there are more genuine coins than counterfeit coins. Since there are \\(10\\) counterfeit coins, any group of \\(11\\) or more coins of the same type must be genuine.\n\nConsider dividing the \\(1000\\) coins into groups of \\(11\\). There will be \\(90\\) groups of \\(11\\) coins and a remainder of \\(10\\) coins. Among these \\(90\\) groups, at most \\(10\\) groups may contain counterfeit coins, so we can obtain at least \\(80\\) groups of \\(11\\) coins that are all of the same type. Also, we need \\(10\\) inspections to divide a group of \\(11\\) coins into two types (without knowing which is genuine).\n\nFirst, use \\(900\\) inspections to divide all the \\(11\\)-coin groups into two types. Next, exclude the coins that have been identified as genuine (where all \\(11\\) coins are of the same type). Record one coin number \\(x\\) identified as genuine. We have up to \\(20\\) groups of coins whose type is undetermined, and the \\(10\\) leftover coins. Using up to an additional \\(30\\) inspections, determine whether each remaining coin is of the same type as \\(x\\) to identify all counterfeit coins. This solution can identify all counterfeit coins using a maximum of \\(930\\) inspections.\n\nSample Implementation (Python 3):\n```python\ndef ask(x, y):\n    print(f\"? {x} {y}\")\n    # Assume here that we get a response from the interaction\n    res = int(input().strip())\n    return res\n\ndef ans(a):\n    print(\"!\", \" \".join(map(str, a)))\n\ndef main():\n    n, m, q = map(int, input().split())  # dummy input\n    ok = None\n    unknown = []\n    for i in range(90):\n        up = i * 11 + 1\n        g1 = [up]\n        g2 = []\n        for j in range(i * 11 + 2, i * 11 + 12):\n            if ask(up, j) == 0:\n                g1.append(j)\n            else:\n                g2.append(j)\n        if not g2:\n            ok = up\n        else:\n            unknown.append(g1)\n            unknown.append(g2)\n    for i in range(991, 1001):\n        unknown.append([i])\n    res = []\n    for nx in unknown:\n        if ask(nx[0], ok) == 1:\n            res.extend(nx)\n    ans(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nDefine the **score** of a sequence of positive integers \\( B = (B_1, B_2, \\dots, B_k) \\) as:\n\n\\[\n\\sum_{i=1}^{k-1} \\gcd(B_i, B_{i+1})\n\\]\n\nGiven a sequence of positive integers \\( A = (A_1, A_2, \\dots, A_N) \\), solve the following problem for \\( m = 1, 2, \\dots, N \\):\n\n- Find the sum of the scores of all non-empty subsequences of the sequence \\( (A_1, A_2, \\dots, A_m) \\), modulo 998244353. There are \\( 2^m - 1 \\) such subsequences. Two subsequences are distinguished if they are taken from different positions in the sequence, even if they coincide as sequences.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^5 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the answer for \\( m = i \\).\n\n**Sample Input 1**\n\n```\n3\n9 6 4\n```\n\n**Sample Output 1**\n\n```\n0\n3\n11\n```\n\n*Explanation*: \n\nConsider the case \\( m = 3 \\). Here are the non-empty subsequences of \\( (A_1, A_2, A_3) = (9, 6, 4) \\) and their scores:\n\n- \\( (9) \\): Score is 0.\n- \\( (6) \\): Score is 0.\n- \\( (4) \\): Score is 0.\n- \\( (9, 6) \\): Score is \\( \\gcd(9, 6) = 3 \\).\n- \\( (9, 4) \\): Score is \\( \\gcd(9, 4) = 1 \\).\n- \\( (6, 4) \\): Score is \\( \\gcd(6, 4) = 2 \\).\n- \\( (9, 6, 4) \\): Score is \\( \\gcd(9, 6) + \\gcd(6, 4) = 3 + 2 = 5 \\).\n\nTherefore, the answer for \\( m = 3 \\) is \\( 0 + 0 + 0 + 3 + 1 + 2 + 5 = 11 \\).\n\n**Sample Input 2**\n\n```\n5\n3 8 12 6 9\n```\n\n**Sample Output 2**\n\n```\n0\n1\n13\n57\n155\n```\n\n**Sample Input 3**\n\n```\n10\n47718 21994 74148 76721 98917 73766 29598 59035 69293 29127\n```\n\n**Sample Output 3**\n\n```\n0\n2\n14\n35\n97\n372\n866\n1859\n4273\n43287\n```\n\nSolution:\n\nHere is the translated editorial with all non-Python code converted to Python3:\n\n```python\ndef gcd(n, m):\n    while m:\n        n, m = m, n % m\n    return n\n\ndef euler_totient_function(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef compute_R(A):\n    max_A = max(A)\n    N = len(A)\n    \n    # Precompute divisors and Euler's totient function values\n    phi = [euler_totient_function(i) for i in range(max_A + 1)]\n    \n    s = [0] * (max_A + 1)\n    R = [0] * (N + 1)  # R_0 is already 0\n    \n    for i in range(1, N + 1):\n        a_i = A[i - 1]\n        # Computing R_i\n        R[i] = 2 * R[i - 1]\n        d = 1\n        while d * d <= a_i:\n            if a_i % d == 0:\n                # For divisor d\n                R[i] += phi[d] * s[d]\n                if d != a_i // d:\n                    # For divisor a_i // d\n                    R[i] += phi[a_i // d] * s[a_i // d]\n            d += 1\n\n        # Update s values for current a_i\n        d = 1\n        while d * d <= a_i:\n            if a_i % d == 0:\n                s[d] += 2 ** i\n                if d != a_i // d:\n                    s[a_i // d] += 2 ** i\n            d += 1\n\n    return R[1:]  # Return R_1 to R_N\n\n# Example usage with an array A\nA = [your_array_values_here]\nR_values = compute_R(A)\nprint(R_values)\n```\n\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 500 points\n\nProblem Statement\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- You are given a positive integer \\( N \\).\n- The judge has a hidden positive integer \\( R \\) and \\( N \\) integers \\( A_1, A_2, \\ldots, A_N \\). It is guaranteed that \\(|A_i| \\le R\\) and \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\).\n- There is a blackboard on which you can write integers with absolute values not exceeding \\( R \\). Initially, the blackboard is empty.\n- The judge has written the values \\( A_1, A_2, \\ldots, A_N \\) on the blackboard in this order. Your task is to make the blackboard contain only one value \\(\\sum_{i=1}^{N} A_i\\).\n- You cannot learn the values of \\( R \\) and \\( A_i \\) directly, but you can interact with the judge up to 25000 times.\n\nFor a positive integer \\( i \\), let \\( X_i \\) be the \\( i \\)-th integer written on the blackboard. Specifically, \\( X_i = A_i \\) for \\( i = 1, 2, \\ldots, N \\).\n\nIn one interaction, you can specify two distinct positive integers \\( i \\) and \\( j \\) and choose one of the following actions:\n\n1. Perform addition. The judge will erase \\( X_i \\) and \\( X_j \\) from the blackboard and write \\( X_i + X_j \\) on the blackboard.\n   - \\(|X_i + X_j| \\leq R\\) must hold.\n\n2. Perform comparison. The judge will tell you whether \\( X_i < X_j \\) is true or false.\n\nNote: At the beginning of each interaction, the \\( i \\)-th and \\( j \\)-th integers written on the blackboard must not have been erased.\n\nPerform the interactions appropriately so that after all interactions, the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\nThe values of \\( R \\) and \\( A_i \\) are determined before the start of the conversation between your program and the judge.\n\nConstraints:\n- \\( 2 \\leq N \\leq 1000 \\)\n- \\( 1 \\leq R \\leq 10^9 \\)\n- \\(|A_i| \\leq R\\)\n- \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\)\n- \\( N, R, \\) and \\( A_i \\) are integers.\n\nInput and Output\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- First, read \\( N \\) from Standard Input.\n\n  ```\n  N\n  ```\n\n- Next, repeat the interactions until the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\n- When performing addition, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  + i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  P\n  ```\n\n  Here, \\( P \\) is an integer:\n\n  - If \\( P \\geq N + 1 \\), it means that the value \\( X_i + X_j \\) has been written on the blackboard, and it is the \\( P \\)-th integer written.\n  - If \\( P = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\n- When performing comparison, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  ? i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  Q\n  ```\n\n  Here, \\( Q \\) is an integer:\n\n  - If \\( Q = 1 \\), it means that \\( X_i < X_j \\) is true.\n  - If \\( Q = 0 \\), it means that \\( X_i < X_j \\) is false.\n  - If \\( Q = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\nFor both types of interactions, if the judge's response is -1, your program is already considered incorrect. In this case, terminate your program immediately.\n\nWhen the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), report this to the judge in the following format. This does not count towards the number of interactions. Then, terminate your program immediately.\n\n  ```\n  !\n  ```\n\nIf you make an output in a format that does not match any of the above, -1 will be given from Standard Input.\n\n  ```\n  -1\n  ```\n\nIn this case, your program is already considered incorrect. Terminate your program immediately.\n\nNotes\n\n- For each output, append a newline at the end and flush Standard Output. Otherwise, the verdict may be TLE.\n- Terminate your program immediately after outputting the result (or receiving -1). Otherwise, the verdict will be indeterminate.\n- Extra newlines will be considered as malformed output.\n\nSample Input and Output\n\nHere is a possible conversation with \\( N=3, R=10, A_1=-1, A_2=10, A_3=1 \\).\n\n**Input:**\n```\n3\n```\n\n**Output:**\n```\n? 1 2\n1\n+ 1 3\n4\n+ 2 4\n5\n!\n```\n\n**Explanation:**\n\n1. First, the integer \\( N \\) is given.\n2. Perform a comparison between \\( X_1 \\) and \\( X_2 \\). The judge returns 1 because \\( X_1 < X_2 \\) (-1 < 10).\n3. Perform an addition of \\( X_1 \\) and \\( X_3 \\). The judge erases \\( X_1 = -1 \\) and \\( X_3 = 1 \\) from the blackboard and writes \\( X_1 + X_3 = 0 \\). This is the fourth integer written.\n4. Perform an addition of \\( X_2 \\) and \\( X_4 \\). The judge erases \\( X_2 = 10 \\) and \\( X_4 = 0 \\) from the blackboard and writes \\( X_2 + X_4 = 10 \\). This is the fifth integer written.\n5. The blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), so report this to the judge.\n\nSolution:\n\nBelow is the editorial as provided, since there's no code to translate to Python3:\n\n```\nAtCoder Regular Contest 179 - C: Beware of Overflow Editorial\n\nTo have only one integer on the blackboard, we need to perform exactly \\(N-1\\) additions. When there are two or more integers left on the blackboard, we should add the maximum and minimum values. The absolute value of their sum does not exceed \\(R\\). Let \\(X\\) be the multiset of integers on the blackboard, with maximum \\(M\\) and minimum \\(m\\). The absolute value of every element in \\(X\\) is at most \\(R\\), and \\(\\displaystyle\\left|\\sum_{x\\in X}x\\right|\\leq R\\).\n\n1. If \\(m \\geq 0\\), all integers are non-negative: \\(0 \\leq m + M \\leq R\\), so \\(|m + M| \\leq R\\).\n2. If \\(M \\leq 0\\), all integers are non-positive: \\(0 \\geq m + M \\geq -R\\), so \\(|m + M| \\leq R\\).\n3. If \\(m \\leq 0\\) and \\(M \\geq 0\\), \\(-R \\leq m \\leq m + M \\leq M \\leq R\\), so \\(|m + M| \\leq R\\).\n\nWe should add the maximum and minimum values. Use merge sort to arrange values in ascending order. Perform addition interactions to add the minimum and maximum values. Remove the first and last elements and insert the sum. Binary search determines the insertion position.\n\nEstimate interactions: Merge sort on a list of length \\(2^n\\) requires at most \\(a_n = n2^n\\) comparisons. Under \\(N \\leq 1000 \\leq 2^{10}\\), at most 10240 comparisons are needed. Finding insertion positions requires at most \\(10 \\times (N-1) \\leq 9990\\) comparisons. In total, at most 20230 comparisons plus \\(N-1 \\leq 999\\) additions remain well within the limit of 25000 interactions.\n```\n \n\n", "problem_ids": ["arc184_a", "arc185_e", "arc179_c"]}, "abc330_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). For each \\( t = 1, 2, \\dots, N \\), determine whether \\( A_t \\) is included in a longest increasing subsequence of \\( A \\).\n\nHere, \\( A_t \\) is included in a longest increasing subsequence of \\( A \\) if and only if the following holds:\n- Let \\( L \\) be the length of a longest increasing subsequence of \\( A \\). There exists a strictly increasing integer sequence \\( i = (i_1, i_2, \\dots, i_L) \\ (i_1 < i_2 < \\dots < i_L) \\), where each element is between \\( 1 \\) and \\( N \\), inclusive, that satisfies all of the following conditions:\n  - \\( A_{i_1} < A_{i_2} < \\dots < A_{i_L} \\).\n  - \\( i_k = t \\) for some \\( k \\ (1 \\leq k \\leq L) \\).\n\nYou are given \\( T \\) test cases; solve each of them.\n\n**What is a longest increasing subsequence?**\n- A subsequence of a sequence \\( A \\) is a sequence that can be derived by extracting some elements from \\( A \\) without changing the order.\n- A longest increasing subsequence of a sequence \\( A \\) is a subsequence of \\( A \\) that is strictly increasing with the greatest possible length.\n\n**Constraints**\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) across all test cases is at most \\( 2 \\times 10^5 \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\nHere, \\(\\mathrm{case}_i\\) represents the input for the \\(i\\)-th case. Each case is given in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\nPrint the answers in the following format:\n```\n\\mathrm{answer}_1\n\\mathrm{answer}_2\n\\vdots\n\\mathrm{answer}_T\n```\nHere, \\(\\mathrm{answer}_i\\) represents the output for the \\(i\\)-th case. For each case, let there be \\( m \\) indices \\( t \\) such that \\( A_t \\) is included in a longest increasing subsequence of \\( A \\), which are \\( i_1, i_2, \\dots, i_m \\) in ascending order. Print these in the following format:\n```\nm\ni_1 i_2 \\cdots i_m\n```\n\n**Sample Input 1**\n```\n1\n5\n2 1 4 5 3\n```\n\n**Sample Output 1**\n```\n4\n1 2 3 4\n```\nOne of the longest increasing subsequences is \\( (2, 4, 5) \\), with a length of 3. Another longest increasing subsequence is \\( (1, 4, 5) \\). However, no longest increasing subsequence includes \\( A_5 \\). Therefore, print \\( 1, 2, 3, 4 \\).\n\n**Sample Input 2**\n```\n2\n6\n2 5 3 4 3 4\n5\n10000 1000 100 1 10\n```\n\n**Sample Output 2**\n```\n5\n1 3 4 5 6\n2\n4 5\n```\n\nSolution:\n\n```\nEditorial - Useless for LIS\n\nGiven a sequence \\( A \\), its Longest Increasing Sequence (LIS) can be found as follows: Apply coordinate compression to assume \\( 1 \\leq A_i \\leq N \\). Use Dynamic Programming (DP) with `dp[i][j]` representing the length of a LIS chosen from the first \\( i \\) elements with the last element \\( j \\). Initialize `dp[0][0] = 0` and `dp[0][1] = dp[0][2] = ... = dp[0][N] = -float('inf')`. The transitions for \\( i = 1, 2, ..., N \\) are:\n\n1. `dp[i][j] = max(dp[i - 1][k] + 1 for k in range(j))` for `j = A[i]`.\n2. `dp[i][j] = dp[i - 1][j]` for `j != A[i]`.\n\nThe length of a LIS is `max(dp[N][k] for k in range(N + 1))`. It is possible to reconstruct a LIS. The complexity can be reduced to \\(O(N \\log N)\\) using a segment tree.\n\nThe DP can be efficiently implemented using pseudocode and a segment tree for segment-max retrieval, which allows LIS length to be obtained in \\(O(N \\log N)\\). Furthermore, by considering constrained LIS lengths `l_i` and `r_i`, and checking if `l_i + r_i - 1 = L`, where `L` is the LIS length, we can address this problem. `l` is found by memorizing DP results, and `r` by reversing the array and applying the same algorithm.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nAlice and Bob are playing a game with two positive integers \\( N \\) and \\( M \\), where \\( N < M \\). Each player has \\( N \\) cards numbered from 1 to \\( N \\). Alice starts the game, and they take turns playing one card from their hand onto the table. If, after a player plays a card, the sum of the numbers on the table is divisible by \\( M \\), the player who played the last card loses, and the other player wins. If all cards are played and the sum is never divisible by \\( M \\), Alice wins. Given \\( T \\) test cases, determine who will win (Alice or Bob) if both play optimally.\n\nConstraints:\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N < M \\leq 10^9 \\)\n\nInput:\n- The input consists of \\( T \\) test cases.\n- Each test case is described by two integers \\( N \\) and \\( M \\).\n\nOutput:\n- For each test case, output \"Alice\" if Alice wins or \"Bob\" if Bob wins when both players play optimally.\n\nSample Input:\n```\n8\n2 3\n3 6\n5 9\n45 58\n39 94\n36 54\n74 80\n61 95\n```\n\nSample Output:\n```\nAlice\nAlice\nBob\nBob\nAlice\nBob\nBob\nAlice\n```\n\nIn the first test case, both Alice and Bob have two cards: a 1 and a 2. Alice plays 1, and the sum is 1, which is not divisible by 3. Bob plays 1, making the sum 2, still not divisible by 3. Alice plays 2, making the sum 4, not divisible by 3. Bob plays 2, making the sum 6, which is divisible by 3, so Bob loses, and Alice wins. Alice wins regardless of Bob's strategy.\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 185\n\ndef mod_m_game(N, M):\n    # Calculate c\n    c = (N * (N + 1)) % M\n\n    # Determine if Alice loses or wins\n    if 1 <= c <= N:\n        return \"Bob wins\"\n    else:\n        return \"Alice wins\"\n\n# Example Usage\nN = 5\nM = 3\nresult = mod_m_game(N, M)\nprint(result)  # Output should be \"Bob wins\" or \"Alice wins\" based on the conditions\n```\n\nEditorial - AtCoder Regular Contest 185\n\nA - mod M Game 2 Editorial by evima\n\nFirst, focus on the moment when Alice plays her last card:\n\n- A player with two or more cards can avoid playing a losing card.\n- If Alice doesn't lose when playing her last card, she will win regardless of Bob's last move.\n\nDetermine if Alice loses with her last card using Bob\u2019s last card \\(b\\). The sum of the numbers on the cards played is \\(N(N+1) - b\\). We check if \\(N(N + 1) - b \\equiv 0 \\pmod{M}\\).\n\n1. If \\(1 \\leq (N(N+1) \\bmod M) \\leq N\\):\n   - Let \\(c = N(N + 1) \\bmod M\\). Bob can make his last card \\(b = c\\) by playing all cards except \\(c\\), leading to Alice's loss. Bob can achieve this by keeping \\(c\\) among his final cards.\n\n2. If \\(N(N + 1) - b\\) cannot be \\(0\\):\n   - Alice will not lose on her last card, leading to her victory.\n\nBob wins if \\(1 \\leq N(N + 1) \\bmod M \\leq N\\), otherwise Alice wins. This can be determined in \\(O(1)\\) time.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( M \\).\n\nFind a positive integer \\( N \\) and a sequence of non-negative integers \\( A = (A_1, A_2, \\ldots, A_N) \\) that satisfy all of the following conditions:\n\n1. \\( 1 \\le N \\le 20 \\)\n2. \\( 0 \\le A_i \\le 10 \\) for all \\( 1 \\le i \\le N \\)\n3. \\( \\sum_{i=1}^N 3^{A_i} = M \\)\n\nIt can be proved that under the constraints, there always exists at least one such pair of \\( N \\) and \\( A \\) satisfying the conditions.\n\n**Constraints**\n\n- \\( 1 \\le M \\le 10^5 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\( M \\)\n\n**Output**\n\nPrint \\( N \\) and \\( A \\) satisfying the conditions in the following format:\n\n\\( N \\)  \n\\( A_1 \\, A_2 \\, \\ldots \\, A_N \\)\n\nIf there are multiple valid pairs of \\( N \\) and \\( A \\), any of them is acceptable.\n\n**Sample Input 1**\n\n```\n6\n```\n\n**Sample Output 1**\n\n```\n2\n1 1\n```\n\nFor example, with \\( N=2 \\) and \\( A=(1, 1) \\), we have \\( \\sum_{i=1}^N 3^{A_i} = 3 + 3 = 6 \\), satisfying all conditions. Another example is \\( N=4 \\) and \\( A=(0, 0, 1, 0) \\), which also satisfies the conditions.\n\n**Sample Input 2**\n\n```\n100\n```\n\n**Sample Output 2**\n\n```\n4\n2 0 2 4\n```\n\n**Sample Input 3**\n\n```\n59048\n```\n\n**Sample Output 3**\n\n```\n20\n0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9\n```\n\nNote the condition \\( 1 \\le N \\le 20 \\).\n\nSolution:\n\n```python\nEditorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nB - 3^A Editorial by en_translator\n\nLet \\(C_k\\) \\((0\\le C_k < 3)\\) be the \\(3^k\\)s place \\((0\\le k\\le 10)\\) in the ternary representation of \\(M\\). Then, \\(\\displaystyle M=\\sum_{k=0}^{10} C_k3^k\\) holds. We can construct \\(A\\) as follows:\n\nLet \\(A=()\\). For \\(k=0,1,\\ldots,10\\) in order, do the following:\n\nInsert \\(C_k\\) copies of \\(k\\) to the tail of \\(A\\).\n\nFor example, \\(7_{(10)}=21_{(3)}\\), for which the procedure above yields \\(A=(0,1,1)\\). As \\(3^0+3^1+3^1=7\\), this \\(A\\) indeed satisfies the conditions.\n\nThe sequence \\(A\\) of length \\(N\\) obtained by the procedure above always satisfies the condition \\(1\\le N\\le 20\\) by constructing \\(A\\) for all integers \\(M\\) between \\(1\\) and \\(10^5\\) and checking their lengths.\n\nSample code (Python3):\n\n```python\nM = int(input())\nA = []\nfor k in range(11):\n    A += [k] * (M % 3)\n    M //= 3\nprint(len(A))\nprint(*A)\n```\n```\n \n\n", "problem_ids": ["abc354_f", "arc185_a", "abc372_b"]}, "abc330_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a grid with \\( H \\) rows and \\( W \\) columns. Let \\( (i, j) \\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Initially, there is one wall in each cell. After processing \\( Q \\) queries as explained below, determine the number of remaining walls.\n\nIn the \\( q \\)-th query, you are given two integers \\( R_q \\) and \\( C_q \\). A bomb is placed at \\( (R_q, C_q) \\) to destroy walls. The following process occurs:\n\n- If there is a wall at \\( (R_q, C_q) \\), destroy that wall and end the process.\n- If there is no wall at \\( (R_q, C_q) \\), destroy the first walls that appear when looking up, down, left, and right from \\( (R_q, C_q) \\). Specifically, the following four processes occur simultaneously:\n  - If there exists an \\( i < R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( i < k < R_q \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists an \\( i > R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( R_q < k < i \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists a \\( j < C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( j < k < C_q \\), destroy the wall at \\( (R_q, j) \\).\n  - If there exists a \\( j > C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( C_q < k < j \\), destroy the wall at \\( (R_q, j) \\).\n\n**Constraints:**\n\n- \\( 1 \\leq H, W \\)\n- \\( H \\times W \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq R_q \\leq H \\)\n- \\( 1 \\leq C_q \\leq W \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nH W Q\nR_1 C_1\nR_2 C_2\n...\nR_Q C_Q\n```\n\n**Output:**\n\nPrint the number of remaining walls after processing all queries.\n\n**Sample Input 1:**\n\n```\n2 4 3\n1 2\n1 2\n1 3\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- In the 1st query, \\( (R_1, C_1) = (1, 2) \\). There is a wall at \\( (1, 2) \\), so it is destroyed.\n- In the 2nd query, \\( (R_2, C_2) = (1, 2) \\). No wall at \\( (1, 2) \\), so destroy the nearest walls at \\( (2,2) \\), \\( (1,1) \\), and \\( (1,3) \\).\n- In the 3rd query, \\( (R_3, C_3) = (1, 3) \\). No wall at \\( (1, 3) \\), so destroy the nearest walls at \\( (2,3) \\) and \\( (1,4) \\).\n\nAfter all queries, two walls remain, at \\( (2, 1) \\) and \\( (2, 4) \\).\n\nSolution:\n\n        Here is a cleaned version of the text focusing on the solution:\n\n---\n\nTo solve the problem efficiently, manage the remaining walls using data structures. Use two ordered sets (such as `std::set` in C++):\n\n1. `g1`: An array where each element is an ordered set maintaining column indices of the remaining walls in each row.\n2. `g2`: An array where each element is an ordered set maintaining row indices of the remaining walls in each column.\n\nBy utilizing binary search in these ordered sets (using `set::lower_bound`), each query can be processed in \\(\\mathrm{O}(\\log H + \\log W)\\) time. The overall time complexity for solving the problem is \\(\\mathrm{O}((HW + Q)(\\log H + \\log W))\\).\n\nSample Python3 code demonstrates this approach:\n\n```python\nimport sys\nfrom sortedcontainers import SortedSet\n\ninput = sys.stdin.read\ndata = input().split()\n\nH = int(data[0])\nW = int(data[1])\nQ = int(data[2])\nindex = 3\n\ng1 = [SortedSet() for _ in range(H)]\ng2 = [SortedSet() for _ in range(W)]\n\nfor i in range(H):\n    for j in range(W):\n        g1[i].add(j)\n        g2[j].add(i)\n\ndef erase(i, j):\n    g1[i].discard(j)\n    g2[j].discard(i)\n\nfor _ in range(Q):\n    R = int(data[index]) - 1\n    C = int(data[index + 1]) - 1\n    index += 2\n\n    if C in g1[R]:\n        erase(R, C)\n        continue\n\n    # up\n    it = g2[C].bisect_left(R)\n    if it > 0:\n        erase(g2[C][it - 1], C)\n    # down\n    if it < len(g2[C]):\n        erase(g2[C][it], C)\n    # left\n    it = g1[R].bisect_left(C)\n    if it > 0:\n        erase(R, g1[R][it - 1])\n    # right\n    if it < len(g1[R]):\n        erase(R, g1[R][it])\n\nans = sum(len(row) for row in g1)\nprint(ans)\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), and a sequence of non-negative integers: \\( A = (A_1,A_2,\\ldots,A_N) \\).\n\nFor a non-empty non-negative integer sequence \\( B = (B_1,B_2,\\ldots,B_{|B|}) \\), we define its **score** as follows:\n- If the length of \\( B \\) is a multiple of \\( M \\): \\( (B_1 \\oplus B_2 \\oplus \\dots \\oplus B_{|B|})^K \\)\n- Otherwise: \\( 0 \\)\n\nHere, \\( \\oplus \\) represents the bitwise XOR.\n\nFind the sum, modulo \\( 998244353 \\), of the scores of the \\( 2^N-1 \\) non-empty subsequences of \\( A \\).\n\n### Constraints\n- \\( 1 \\leq N, K \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 0 \\leq A_i < 2^{20} \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n3 2 2\n1 2 3\n```\n\n### Sample Output 1\n```\n14\n```\n\nHere are the scores of the \\( 2^3-1=7 \\) non-empty subsequences of \\( A \\).\n- \\( (1) \\): \\( 0 \\)\n- \\( (2) \\): \\( 0 \\)\n- \\( (3) \\): \\( 0 \\)\n- \\( (1,2) \\): \\( (1 \\oplus 2)^2 = 9 \\)\n- \\( (1,3) \\): \\( (1 \\oplus 3)^2 = 4 \\)\n- \\( (2,3) \\): \\( (2 \\oplus 3)^2 = 1 \\)\n- \\( (1,2,3) \\): \\( 0 \\)\n\nTherefore, the sought sum is \\( 0 + 0 + 0 + 9 + 4 + 1 + 0 = 14 \\).\n\n### Sample Input 2\n```\n10 5 3\n100 100 100 100 100 100 100 100 100 100\n```\n\n### Sample Output 2\n```\n252000000\n```\n\n### Sample Input 3\n```\n16 4 100\n7053 3876 3178 8422 7802 5998 2334 6757 6889 6637 7365 9495 7848 9026 7312 6558\n```\n\n### Sample Output 3\n```\n432440016\n```\n\n\nSolution:\n\nThe problem requires knowledge of XOR convolution and Hadamard transform. Define \\(C_i\\) as the number of subsequences of \\(A\\) with length as a multiple of \\(M\\) and total XOR equals \\(i\\). We need to find \\(C_0, C_1, \\ldots, C_{2^L-1}\\) such that \\(\\sum_{i=0}^{2^L-1} C_i \\cdot i^K\\) is calculated, where \\(L=20\\).\n\nDefine sequences \\(v_i\\) such that each sequence term is a polynomial, with the 0-th term being 1, the \\(A_i\\)-th term as \\(x\\), and others 0. If \\(A_i=0\\), the 0-th term is \\(1+x\\). For two sequences \\(a, b\\), define the XOR convolution as \\((a \\ast b)_k = \\sum_{i \\oplus j = k} a_i \\times b_j\\). \n\nCompute the XOR convolution \\(V = v_1 \\ast v_2 \\ast \\cdots \\ast v_N\\). The coefficient of \\(x^j\\) of the \\(i\\)-th term (\\([x^j]V_i\\)) equals the number of length-\\(j\\) subsequences of \\(A\\) with a total XOR of \\(i\\), resulting in \\(C_i = [x^0]V_i + [x^M]V_i + \\cdots = [x^0]V_i \\, (\\text{mod } 1-x^M)\\).\n\nUtilize Hadamard conversion \\(H\\), where \\(H(a \\ast b)_i = H(a)_i \\times H(b)_i\\). Therefore, \\(H(V)_i = H(v_1)_i \\times \\cdots \\times H(v_N)_i\\). Compute \\(H(V)\\) using Hadamard conversion on sequences \\(v_1, v_2, \\ldots\\).\n\nGiven sequences that have 1 at the 0-th term and \\(x\\) at the \\(A_i\\)-th term, \\(H(v_i)\\) becomes \\((1+x)\\) or \\((1-x)\\). Thus, \\(H(V)_i\\) can be represented as \\((1+x)^{B_i}(1-x)^{N-B_i}\\). Calculate \\(B_i\\) efficiently using a combination of Hadamard conversion and population count divide-and-conquer strategy, allowing \\(O(L2^L)\\) calculation time. Alternatively, use \\(B_i = \\frac{H(\\text{cnt})_i + N}{2}\\).\n\nFind \\([x^0](1+x)^{B_i}(1-x)^{N-B_i} \\, (\\text{mod } 1-x^M)\\) in \\(O(NM)\\) using precalculated sequences for \\((1+x)^n\\) and \\((1-x)^n \\, (\\text{mod } 1-x^M)\\). Thus, the overall problem can be solved in \\(O(NM + 2^L (L + \\log K))\\) time.\n\nHere's the implementation:\n\n```python\nmod = 998244353\n\ndef hadamard(a, m):\n    for k in range(m):\n        i = 1 << k\n        for j in range(1 << m):\n            if not i & j:\n                a[j], a[i | j] = (a[j] + a[i | j]), (a[j] - a[i | j])\n\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nL = 20\ncnt = [0] * (1 << L)\nfor i in range(N):\n    cnt[A[i]] += 1\n\nF = [[0] * M for i in range(N + 1)]\nG = [[0] * M for i in range(N + 1)]\n\nF[0][0], G[0][0] = 1, 1\n\nfor i in range(N):\n    for j in range(M):\n        F[i + 1][j] = (F[i][j] + F[i][j - 1]) % mod\n        G[i + 1][j] = (G[i][j] - G[i][j - 1]) % mod\n\nres = [0] * (N + 1)\nfor i in range(N + 1):\n    for j in range(M):\n        res[i] += F[i][j] * G[N - i][-j]\n        res[i] %= mod\n\nhadamard(cnt, L)\nB = [(cnt[i] + N) // 2 for i in range(1 << L)]\nC = [res[B[i]] for i in range(1 << L)]\nhadamard(C, L)\n\ninv = pow(1 << L, mod - 2, mod)\nans = 0\nfor i in range(1 << L):\n    C[i] = C[i] % mod * inv % mod\n    ans += C[i] * pow(i, K, mod)\n    ans %= mod\n\nprint(ans)\n```\n\nCalculate \\(B\\) using divide-and-conquer:\n\n```python\ndef calc(off, k):\n    if k == 0:\n        return ([cnt[off]], cnt[off])\n    H0, c0 = calc(off, k - 1)\n    H1, c1 = calc(off | (1 << (k - 1)), k - 1)\n    H = [0] * (1 << k)\n    for i in range(1 << (k - 1)):\n        H[i] = H0[i] + H1[i]\n        H[i | (1 << (k - 1))] = H0[i] + c1 - H1[i]\n    return (H, c0 + c1)\n\nB = calc(0, L)[0]\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere are \\( N \\) people, numbered from 1 to \\( N \\). A competition was held among these \\( N \\) people, and they were ranked accordingly. The following information is given about their ranks:\n\n1. Each person has a unique rank.\n2. For each \\( 1 \\leq i \\leq M \\), if person \\( A_i \\) is ranked \\( x \\)-th and person \\( B_i \\) is ranked \\( y \\)-th, then \\( x - y = C_i \\).\n\nThe given input guarantees that there is at least one possible ranking that does not contradict the given information.\n\nYou need to answer \\( N \\) queries. The answer to the \\( i \\)-th query is determined as follows:\n- If the rank of person \\( i \\) can be uniquely determined, return that rank.\n- Otherwise, return \\(-1\\).\n\n### Constraints\n- \\( 2 \\leq N \\leq 16 \\)\n- \\( 0 \\leq M \\leq \\frac{N(N - 1)}{2} \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq N - 1 \\)\n- \\( (A_i, B_i) \\neq (A_j, B_j) \\) if \\( i \\neq j \\)\n- All input values are integers\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n### Output\nPrint the answers to the \\( 1 \\)-st, \\( 2 \\)-nd, ..., \\( N \\)-th queries in this order, separated by spaces.\n\n### Sample Input 1\n```\n5 2\n2 3 3\n5 4 3\n```\n\n### Sample Output 1\n```\n3 -1 -1 -1 -1\n```\n\nExplanation: Let \\( X_i \\) be the rank of person \\( i \\). The possible rankings could be \\( (3, 4, 1, 2, 5) \\) or \\( (3, 5, 2, 1, 4) \\). Therefore, only the rank of person 1 is uniquely determined as 3.\n\n### Sample Input 2\n```\n3 0\n```\n\n### Sample Output 2\n```\n-1 -1 -1\n```\n\n### Sample Input 3\n```\n8 5\n6 7 3\n8 1 7\n4 5 1\n7 2 1\n6 2 4\n```\n\n### Sample Output 3\n```\n1 -1 -1 -1 -1 -1 -1 8\n```\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 352\n\nConsider a \\(N\\)-vertex \\(M\\)-edge graph whose \\(i\\)-th edge connects vertex \\(A_i\\) and vertex \\(B_i\\). By the constraints, we can take an integer sequence \\(D = (D_1, D_2, \\ldots, D_N)\\) such that \\(D_{A_i} - D_{B_i} = C_i\\) for each \\(i\\). This sequence can be obtained by appropriately performing DFS (Depth-First Search) or BFS (Breadth-First Search) on the graph defined above. The sequence of person \\(i\\)\u2019s rank \\(X_i\\), collectively written as \\(X = (X_1, X_2, \\ldots, X_N)\\), is limited to permutations of \\((1,2,\\ldots, N)\\) such that:\n\n\\(X_i = D_i + v\\), where \\(v\\) is an arbitrary integer taken for each connected component and \\(i\\) is any of the vertices in it.\n\nWe try to respond to the query per connected component. When finding the answer to the \\(i\\)-th query, we perform a bit DP (Dynamic Programming) that places connected components not containing vertex \\(i\\). Specifically, maintain boolean values \\(dp_{x,y}\\) that represent whether the vertices in the first \\(x\\) connected components may correspond to the set of ranks \\(y\\). Since there are \\(O(N)\\) pairs of possible tuples of rank for each connected component, the DP above costs \\(O(N^2 2^N)\\) time naively, or \\(O(N 2^N)\\) time if you use the property that the value of \\(x\\) uniquely determines the popcount of \\(y\\). Therefore, the problem has been solved in a total of \\(O(N^2 2^N)\\) time.\n```\n \n\n", "problem_ids": ["abc370_d", "abc367_g", "abc352_f"]}, "abc330_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n---\n**Problem Statement**\n\nYou are given a directed graph with \\( N \\) vertices and \\( M \\) edges. The \\( j \\)-th directed edge goes from vertex \\( u_j \\) to vertex \\( v_j \\) and has a weight of \\( w_j \\).\n\nFind one way to assign an integer between \\(-10^{18}\\) and \\(10^{18}\\), inclusive, to each vertex such that the following condition is satisfied:\n\n- Let \\( x_i \\) be the value assigned to vertex \\( i \\). For all edges \\( j = 1, 2, \\dots, M \\), it holds that \\( x_{v_j} - x_{u_j} = w_j \\).\n\nIt is guaranteed that at least one such assignment exists for the given input.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq \\min\\{2 \\times 10^5, \\frac{N(N-1)}{2}\\} \\)\n- \\( 1 \\leq u_j, v_j \\leq N \\)\n- \\( u_j \\neq v_j \\)\n- If \\( i \\neq j \\), then \\( (u_i, v_i) \\neq (u_j, v_j) \\) and \\( (u_i, v_i) \\neq (v_j, u_j) \\)\n- \\( |w_j| \\leq 10^9 \\)\n- All input values are integers.\n- There exists at least one assignment satisfying the conditions.\n\n**Input**\n\nThe input is given in the following format:\n\n```\nN M\nu_1 v_1 w_1\nu_2 v_2 w_2\n\u22ee\nu_M v_M w_M\n```\n\n**Output**\n\nLet \\( x_i \\) be the integer written on vertex \\( i \\). Print \\( x_1, x_2, \\dots, x_N \\) in this order, separated by spaces, on a single line. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n\n```\n3 3\n1 2 2\n3 2 3\n1 3 -1\n```\n\n**Sample Output 1**\n\n```\n3 5 2\n```\n\nBy setting \\( x = (3, 5, 2) \\), we have \\( x_2 - x_1 = w_1 = 2 \\), \\( x_2 - x_3 = w_2 = 3 \\), \\( x_3 - x_1 = w_3 = -1 \\), satisfying the conditions. For example, \\( x = (-1, 1, -2) \\) is also a valid answer.\n\n**Sample Input 2**\n\n```\n4 2\n2 1 5\n3 4 -3\n```\n\n**Sample Output 2**\n\n```\n5 0 6 3\n```\n\nFor example, \\( x = (0, -5, 4, 1) \\) and \\( x = (5, 0, 4, 1) \\) are also valid answers.\n\n**Sample Input 3**\n\n```\n5 7\n2 1 18169343\n3 1 307110901\n4 1 130955934\n2 3 -288941558\n2 5 96267410\n5 3 -385208968\n4 3 -176154967\n```\n\n**Sample Output 3**\n\n```\n200401298 182231955 -106709603 69445364 278499365\n```\n\nSolution:\n\n```python\n        For each connected component of the graph, once the value to be written on any vertex in it is fixed, all the values to be written are uniquely determined. This is because, once you determine the value for a vertex, the value for adjacent vertices is also determined in a chain. Thus, the problem can be solved by inspecting vertices one by one, and if the current vertex does not have a value assigned, set an arbitrary value (like 0) to it and determine the values for all the other connected vertices. This kind of process can be implemented as a Depth-First Search (DFS) or Breadth-First Search (BFS). The time complexity is \\(O(N+M)\\).\n\n```python\n# Read the input\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, w))\n    G[v].append((u, -w))\n\nvisited = [False] * N  # Whether the values are determined\nans = [0] * N  # The values to write\nfor i in range(N):\n    # Skip if the value is already determined\n    if visited[i]:\n        continue\n    # Set the value for vertex i to 0, and start searching\n    st = [i]\n    visited[i] = True\n    while st:\n        # Currently at vertex u\n        u = st.pop()\n        # Inspect vertex v adjacent to vertex u\n        for v, w in G[u]:\n            if not visited[v]:\n                # If the value for vertex v is undetermined, determine the value so that it is consistent with that for vertex u\n                visited[v] = True\n                ans[v] = ans[u] + w\n                st.append(v)\nprint(*ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\).\nAnswer the following \\( Q \\) queries.\n\nFor the \\( i \\)-th query, you are given integers \\( L_i \\) and \\( R_i \\).\nSolve the following problem for \\( B = (A_{L_i}, A_{L_{i}+1}, \\cdots, A_{R_i}) \\).\n\nDivide \\( B \\) into three non-empty contiguous subsequences. For each contiguous subsequence, find the maximum value of its elements. The task is to find the minimum possible sum of these maximum values.\n\nIt is guaranteed that the length of \\( B \\) is at least 3, so there is always at least one way to divide it into three non-empty contiguous subsequences.\n\n### Constraints\n\n- \\( 3 \\leq N \\leq 250000 \\)\n- \\( 1 \\leq Q \\leq 250000 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- \\( 1 \\leq L_i \\leq R_i \\leq N \\)\n- \\( R_i - L_i \\geq 2 \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from standard input in the following format:\n```\nN Q\nA_1 A_2 \\ldots A_N\nL_1 R_1\nL_2 R_2\n\u22ee\nL_Q R_Q\n```\n\n### Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n### Sample Input 1\n```\n7 5\n4 3 1 1 4 5 2\n1 7\n2 4\n3 5\n1 5\n4 7\n```\n\n### Sample Output 1\n```\n10\n5\n6\n9\n8\n```\n\nExplanation for the first query: We have \\( B = (4, 3, 1, 1, 4, 5, 2) \\). If you divide it into \\( (4, 3), (1, 1), (4, 5, 2) \\), the maximum values of the contiguous subsequences are 4, 1, and 5 respectively, and their sum is 10. There is no way to make this sum smaller, so the answer to this query is 10.\n\n### Sample Input 2\n```\n10 15\n8 3 8 10 1 5 3 1 6 4\n4 6\n2 5\n6 9\n8 10\n2 9\n4 10\n1 5\n1 8\n1 3\n4 8\n1 10\n2 10\n6 10\n2 6\n2 6\n```\n\n### Sample Output 2\n```\n16\n14\n12\n11\n17\n17\n19\n14\n19\n14\n17\n17\n12\n16\n16\n```\n\n\nSolution:\n\n        [BEGIN TEXT]\n        First, consider the case with one query. Suppose the input is \\(B=(B_1,\\cdots,B_N)\\). Let \\(B_m=\\max(B)\\). When decomposing \\(B\\) into \\(XYZ\\), consider the scenarios based on where \\(B_m\\) is included among \\(X, Y, Z\\). If \\(B_m\\) is in \\(Y\\), \\(\\max(Y)\\) is \\(B_m\\), so make \\(Y\\) larger: \\(X=(B_1), Y=(B_2,\\cdots,B_{N-1}), Z=(B_N)\\). If \\(B_m\\) is in \\(X\\), assume \\(Y\\) has one element. Try all possible positions for \\(Y\\) to calculate the answer. If \\(B_m\\) is in \\(Z\\), reverse the sequence to solve it similarly. For multiple queries, if \\(B_m\\) is in \\(Y\\), handle it with a simple RMQ. When \\(B_m\\) is in \\(X\\), use two main approaches: manage \\(\\max(Z)\\) for each \\(Y\\) by processing queries in ascending order of \\(R_i\\) with a segment tree for range addition and range minimum query or manage \\(Y\\) for each \\(\\max(Z)\\) with a stack and a segment tree for range minimum query. Using either approach, the time complexity is \\(O((N+Q) \\log N)\\).\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe AtCoder railway line has \\( N \\) stations, numbered \\( 1, 2, \\ldots, N \\).\n\nOn this line, there are **inbound trains** that start at station \\( 1 \\) and stop at the stations \\( 2, 3, \\ldots, N \\) in order, and **outbound trains** that start at station \\( N \\) and stop at the stations \\( N - 1, N - 2, \\ldots, 1 \\) in order.\n\nTakahashi is about to travel from station \\( X \\) to station \\( Y \\) using only one of the inbound and outbound trains.\n\nDetermine whether the train stops at station \\( Z \\) during this travel.\n\n**Constraints**\n- \\( 3 \\leq N \\leq 100 \\)\n- \\( 1 \\leq X, Y, Z \\leq N \\)\n- \\( X \\), \\( Y \\), and \\( Z \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN X Y Z\n```\n\n**Output**\n\nIf the train stops at station \\( Z \\) during the travel from station \\( X \\) to station \\( Y \\), print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n```\n7 6 1 3\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Explanation:* To travel from station 6 to station 1, Takahashi will take an outbound train. After departing from station 6, the train stops at stations 5, 4, 3, 2, 1 in order, which include station 3, so you should print `Yes`.\n\n**Sample Input 2**\n```\n10 3 2 9\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n100 23 67 45\n```\n\n**Sample Output 3**\n```\nYes\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial content: \n\n---\n\nTakahashi takes an inbound train if \\(X < Y\\) and an outbound train if \\(X > Y\\). Takahashi\u2019s train will stop at station \\(Z\\) if and only if \\(X < Z < Y\\) if \\(X < Y\\), and \\(X > Z > Y\\) if \\(X > Y\\).\n\nSample code:\n```python\nn, x, y, z = map(int, input().split())\nif (x < z < y) or (y < z < x):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\n", "problem_ids": ["abc373_d", "arc180_d", "abc352_a"]}, "abc330_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a circular cake divided into \\(N\\) pieces by cut lines. Each cut line is a line segment connecting the center of the circle to a point on the arc. The pieces and cut lines are numbered \\(1, 2, \\ldots, N\\) in clockwise order, and piece \\(i\\) has a mass of \\(A_i\\). Piece \\(1\\) is also called piece \\(N + 1\\). Cut line \\(i\\) is between pieces \\(i\\) and \\(i + 1\\), and they are arranged clockwise in this order: piece \\(1\\), cut line \\(1\\), piece \\(2\\), cut line \\(2\\), \\(\\ldots\\), piece \\(N\\), cut line \\(N\\).\n\nWe want to divide this cake among \\(K\\) people under the following conditions. Let \\(w_i\\) be the sum of the masses of the pieces received by the \\(i\\)-th person.\n\n- Each person receives one or more **consecutive** pieces.\n- There are no pieces that no one receives.\n- Under the above two conditions, \\(\\min(w_1, w_2, \\ldots, w_K)\\) is maximized.\n\nFind the value of \\(\\min(w_1, w_2, \\ldots, w_K)\\) in a division that satisfies the conditions, and the number of cut lines that are never cut in the divisions that satisfy the conditions. Here, cut line \\(i\\) is considered cut if pieces \\(i\\) and \\(i + 1\\) are given to different people.\n\n**Constraints:**\n\n- \\(2 \\leq K \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq 10^4\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nLet \\(x\\) be the value of \\(\\min(w_1, w_2, \\ldots, w_K)\\) in a division that satisfies the conditions, and \\(y\\) be the number of cut lines that are never cut. Print \\(x\\) and \\(y\\) in this order, separated by a space.\n\n**Sample Input 1:**\n\n```\n5 2\n3 6 8 6 4\n```\n\n**Sample Output 1:**\n\n```\n13 1\n```\n\nThe following divisions satisfy the conditions:\n- Give pieces \\(2, 3\\) to one person and pieces \\(4, 5, 1\\) to the other. Pieces \\(2, 3\\) have a total mass of \\(14\\), and pieces \\(4, 5, 1\\) have a total mass of \\(13\\).\n- Give pieces \\(3, 4\\) to one person and pieces \\(5, 1, 2\\) to the other. Pieces \\(3, 4\\) have a total mass of \\(14\\), and pieces \\(5, 1, 2\\) have a total mass of \\(13\\).\n\nThe value of \\(\\min(w_1, w_2)\\) in divisions satisfying the conditions is \\(13\\), and there is one cut line that is not cut in either division: cut line \\(5\\).\n\n**Sample Input 2:**\n\n```\n6 3\n4 7 11 3 9 2\n```\n\n**Sample Output 2:**\n\n```\n11 1\n```\n\n**Sample Input 3:**\n\n```\n10 3\n2 9 8 1 7 9 1 3 5 8\n```\n\n**Sample Output 3:**\n\n```\n17 4\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\nF - Cake Division Editorial by en_translator\n\nLet us call a contiguous pieces a segment. Using binary search, it is sufficient to solve the following decision problem (fast): Can the \\(N\\) pieces be divided into \\(K\\) segments so that each segment has a mass of at least \\(X\\)? If possible, how many cut lines are never used by any division among such ways?\n\nFor each \\(1 \\leq i \\leq N\\), let us consider whether there exists a conforming division that uses cut line \\(i\\). Let us redefine the sequence \\(A\\) of length \\(2N\\) by letting \\(A_{N + i} \\coloneqq A_i\\) for all \\(i\\) with \\(1 \\leq i \\leq N\\). If there exists \\(j (\\leq 2N + 1)\\) such that \\(A_i + A_{i + 1} + \\ldots + A_{j - 1}  \\geq X\\), let \\(f(i)\\) be the minimum such \\(j\\); otherwise, let \\(f(i) = \\infty\\). Also, let \\(f(\\infty) = \\infty\\). Using the sliding window trick, \\(f\\) can be evaluated for all arguments in a total of \\(O(N)\\) time.\n\nThere exists a conforming division that uses cut line \\(i\\) if and only if \\(f^K(i + 1) \\leq N + i + 1\\). \\(f^K\\) can be evaluated in \\(O(N \\log K)\\) time using the doubling technique based on \\(f^2, f^4, f^8, \\ldots\\). Therefore, the number of \\(i\\) for which there is a division that uses cut line \\(i\\) can be counted in \\(O(N \\log K)\\) time. Noticing that there is at least one \\(i\\) such that cut line \\(i\\) is used by a division if and only if the \\(N\\) pieces can be divided into \\(K\\) segments so that each segment has a mass of at least \\(K\\), this also solves the decision problem.\n\nAlternatively, evaluating \\(f^K\\) can be boiled down to the Level Ancestor Problem in a tree which has an edge between \\(i\\) and \\(f(i)\\) for each \\(i\\) with \\(i \\neq f(i)\\), so the decision problem can be solved in \\(O(N)\\) time too. However, in the writer\u2019s and tester\u2019s solution, it was the solution that used doubling.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\). You are also given \\(Q\\) queries to process in order. There are three types of queries:\n\n1. `1 l r x`: Add \\(x\\) to each of \\(A_l, A_{l+1}, \\ldots, A_r\\).\n2. `2 l r x`: Add \\(x\\) to each of \\(B_l, B_{l+1}, \\ldots, B_r\\).\n3. `3 l r`: Print the remainder of \\(\\sum_{i=l}^r (A_i \\times B_i)\\) when divided by 998244353.\n\n**Constraints:**\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(0 \\leq A_i, B_i \\leq 10^9\\)\n- \\(1 \\leq l \\leq r \\leq N\\)\n- \\(1 \\leq x \\leq 10^9\\)\n- All input values are integers.\n- There is at least one query of the third type.\n\n**Input:**\n\nThe input is given from Standard Input in the following format. Here, \\(\\text{query}_i (1 \\leq i \\leq Q)\\) is the \\(i\\)-th query to be processed.\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n\\text{query}_1\n\\text{query}_2\n\\vdots\n\\text{query}_Q\n```\n\nEach query is given in one of the following formats:\n\n```\n1 l r x\n```\n\n```\n2 l r x\n```\n\n```\n3 l r\n```\n\n**Output:**\n\nIf there are \\(K\\) queries of the third type, print \\(K\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq K)\\) should contain the output for the \\(i\\)-th query of the third type.\n\n**Sample Input 1:**\n\n```\n5 6\n1 3 5 6 8\n3 1 2 1 2\n3 1 3\n1 2 5 3\n3 1 3\n1 1 3 1\n2 5 5 2\n3 1 5\n```\n\n**Sample Output 1:**\n\n```\n16\n25\n84\n```\n\nInitially, \\(A = (1, 3, 5, 6, 8)\\) and \\(B = (3, 1, 2, 1, 2)\\). The queries are processed in the following order:\n\n1. For the first query, print \\((1 \\times 3) + (3 \\times 1) + (5 \\times 2) = 16\\) modulo 998244353, which is 16.\n2. For the second query, add 3 to \\(A_2, A_3, A_4, A_5\\). Now \\(A = (1, 6, 8, 9, 11)\\).\n3. For the third query, print \\((1 \\times 3) + (6 \\times 1) + (8 \\times 2) = 25\\) modulo 998244353, which is 25.\n4. For the fourth query, add 1 to \\(A_1, A_2, A_3\\). Now \\(A = (2, 7, 9, 9, 11)\\).\n5. For the fifth query, add 2 to \\(B_5\\). Now \\(B = (3, 1, 2, 1, 4)\\).\n6. For the sixth query, print \\((2 \\times 3) + (7 \\times 1) + (9 \\times 2) + (9 \\times 1) + (11 \\times 4) = 84\\) modulo 998244353, which is 84.\n\nThus, the first, second, and third lines should contain 16, 25, and 84, respectively.\n\n**Sample Input 2:**\n\n```\n2 3\n1000000000 1000000000\n1000000000 1000000000\n3 1 1\n1 2 2 1000000000\n3 1 2\n```\n\n**Sample Output 2:**\n\n```\n2716070898\n151723988\n```\n\nMake sure to print the sum modulo 998244353 for the third type of query.\n\nSolution:\n\n[BEGIN TEXT]\nConsider solving this problem using a lazy segment tree. For details on lazy segment trees, please refer to other editorials and the AtCoder Library explanation. Specifically, for each segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) for integers \\(a,k\\geq 0\\) and \\(2^k(a+1)\\leq N\\), we want to manage the sum of \\(A_i\\times B_i\\) within the segment, and apply addition to \\(A_i\\) and \\(B_i\\) fast enough (in \\(O(1)\\) time). The set of actions consists of \u201cadding \\(x\\) to each element of \\(A\\) and \\(y\\) to that of \\(B\\) (within the segment)\u201d for all integers \\(x\\) and \\(y\\). \n\nFor a segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) (where \\(L=a\\cdot2^k+1\\) and \\(R=(a+1)2^k\\)), it is insufficient to store the values \\(\\sum_{i=L}^R (A_i\\times B_i)\\) for each segment. Instead, manage the length \\((R-L+1)\\), and three kinds of sum: \\(\\sum_{i=L}^R A_i\\), \\(\\sum_{i=L}^R B_i\\), and \\(\\sum_{i=L}^R (A_i\\times B_i)\\), for each segment. Then, one can update the value \\(\\sum_{i=L}^R (A_i\\times B_i)\\) in \\(O(1)\\) time. \n\nThe key updates are:\n\\[\n\\sum_{i=L}^R ((A_i+x)\\times (B_i+y)) = \\sum_{i=L}^R (A_i\\times B_i) + y\\sum_{i=L}^R A_i + x\\sum_{i=L}^R B_i + (R-L+1)xy\n\\]\n\\[\n\\sum_{i=L}^R (A_i+x) = \\sum_{i=L}^R A_i+(R-L+1)x, \n\\]\n\\[\n\\sum_{i=L}^R (B_i+y) = \\sum_{i=L}^R B_i+(R-L+1)y\n\\]\n\nTherefore, the lazy segment tree can find the answer with a complexity of \\(O(Q\\log N)\\), which is efficient. The answer should be printed modulo \\(998244353\\).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\) and a prime \\( P \\).\n\nCount the number, modulo \\( P \\), of undirected connected graphs \\( G \\) of \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) that satisfy the following conditions:\n\n1. There are no self-loops in \\( G \\). Note that multiple edges are allowed.\n2. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) remains connected. In other words, \\( G \\) is edge-biconnected.\n3. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) is no longer edge-biconnected.\n\nTwo graphs are considered different if and only if there exists a pair of distinct vertices \\( (u,v) \\) such that the numbers of edges connecting \\( u \\) and \\( v \\) in the two graphs are different.\n\n**Constraints**\n\n- \\( 2 \\le N \\le 50 \\)\n- \\( 10^9 < P < 1.01 \\times 10^9 \\)\n- \\( P \\) is prime.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**  \n```\n2 1005976817\n```\n\n**Sample Output 1**  \n```\n1\n```\n\n**Sample Input 2**  \n```\n5 1000837403\n```\n\n**Sample Output 2**  \n```\n372\n```\n\n**Sample Input 3**  \n```\n10 1001160547\n```\n\n**Sample Output 3**  \n```\n789846604\n```\n\n**Sample Input 4**  \n```\n20 1006779551\n```\n\n**Sample Output 4**  \n```\n888612770\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Grand Contest 067 - E: Biconnected Graph Editorial by Kubic\n\nIf an edge is deleted, the remaining graph will form a chain after shrinking biconnected components; it will become a cycle if the edge is added back. Solve the problem for each biconnected component and multiply the answers. In the subproblem, there's an additional edge connecting two vertices, allowing them to reach each other through the cycle. Repeat this method by taking an edge connected to vertex \\(1\\), leading to subproblems formatted as:\n\nCount good graphs of \\(n\\) vertices with the first \\(k\\) vertices able to reach each other externally.\n\nConsider the distribution of the first \\(k\\) vertices:\n\n\\(\\forall 1\\le u,v\\le k\\), \\(C(u),C(v)\\) are not adjacent in the cycle, where \\(C(u)\\) is the biconnected component containing \\(u\\).\n\nDP through the cycle without constraining the edge choice so every good graph is counted \\(\\deg(1)\\) times. Store \\(\\deg(1)\\) in the DP state and divide the final answer by it.\n\nTime complexity: \\(O(n^5)\\). Some \\(O(n^6)\\) solutions with small constants may pass.\n        [END TEXT]\n \n\n", "problem_ids": ["abc370_f", "abc357_f", "agc067_e"]}, "abc331_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nYou will perform the following operation exactly once:\n\n- Choose a non-empty subsequence of \\( A \\) (not necessarily contiguous) and replace it with its cumulative sums.\nMore precisely, first choose a sequence of indices \\( (i_1, i_2, \\ldots, i_k) \\) such that \\( 1 \\leq i_1 < i_2 < \\cdots < i_k \\leq N \\).\n  The length of the sequence \\( k \\) (\\( 1 \\leq k \\leq N \\)) can be chosen freely.\n  Then, for each \\( j \\) (\\( 1 \\leq j \\leq k \\)), replace the value of \\( A_{i_j} \\) with \\( \\sum_{1 \\leq x \\leq j} A_{i_x} \\).\n  This replacement is done simultaneously for all chosen indices.\n\nFind, modulo \\( 10^9 + 7 \\), the number of possible sequences \\( A \\) after the operation.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\(-10 \\leq A_i \\leq 10 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\[\nN \\\\\nA_1\\ A_2\\ \\cdots\\ A_N\n\\]\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n3\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nThe possible sequences \\( A \\) after the operation are as follows:\n- \\( A = (1, 1, 2) \\): This can be achieved with \\( k = 1 \\) and \\( (i_1) = (1) \\).\n- \\( A = (1, 2, 2) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 2) \\).\n- \\( A = (1, 1, 3) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 3) \\).\n- \\( A = (1, 2, 4) \\): This can be achieved with \\( k = 3 \\) and \\( (i_1, i_2, i_3) = (1, 2, 3) \\).\n\n**Sample Input 2**\n\n```\n4\n1 -1 1 -1\n```\n\n**Sample Output 2**\n\n```\n8\n```\n\n**Sample Input 3**\n\n```\n5\n0 0 0 0 0\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\n**Sample Input 4**\n\n```\n40\n2 -2 1 3 -3 -1 -2 -3 0 -1 -2 0 -3 0 0 2 0 -1 2 -2 -2 -1 3 -2 -2 -2 2 3 2 -3 0 -2 2 1 3 0 -1 0 -2 -3\n```\n\n**Sample Output 4**\n\n```\n420429545\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Regular Contest 180\n\nC - Subsequence and Prefix Sum Editorial by evima\n\nConsider the following DP: \\(dp[i][j]=\\) The number of ways to perform the operation on the first \\(i\\) terms so that \\(A_i\\) changes to \\(A_i+j\\) (\\(j \\neq 0\\)). Because \\(j \\neq 0\\), the operation counted in \\(dp[i][j]\\) always selects \\(A_i\\) for the operation. The next term will increase by \\(A_i+j\\). The transition for \\(A_i+j \\neq 0\\) is straightforward. For \\(A_i+j=0\\), let \\(A_k\\) be the next term to change. To change \\(A_k \\to A_k+v\\), select \\(v\\) from \\(A_{i+1},\\cdots,A_{k-1}\\). Implementing these covers all transitions. This problem can be solved in \\(O(N^3 \\max(|A_i|))\\) time.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given positive integers \\( N \\) and \\( L \\), and a sequence of positive integers \\( A = (A_{1}, A_{2}, \\dots, A_{N}) \\) of length \\( N \\).\n\nFor each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nDetermine if there exists a sequence of \\( L \\) non-negative integers \\( B = (B_{1}, B_{2}, \\dots, B_{L}) \\) such that:\n\n\\[\n\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = A_{i}\n\\]\n\nIf it exists, find the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^{5} \\)\n- \\( 2 \\leq L \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq A_{i} \\leq 2 \\times 10^{5} \\)\n\nAll input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN L\nA_{1} A_{2} \\cdots A_{N}\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain \\(-1\\) if no sequence \\( B \\) satisfies the condition for \\( i = k \\); otherwise, it should contain the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Sample Input 1:**\n\n```\n2 4\n10 5\n```\n\n**Sample Output 1:**\n\n```\n3\n-1\n```\n\n*Explanation*:\n- For \\( A_{1} = 10 \\), if we take \\( B = (1, 0, 2, 3) \\), then \\(\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = 10\\), where \\( \\max(B) = 3 \\). No non-negative integer sequence \\( B \\) satisfies the condition with \\( \\max(B) < 3 \\), so print 3 in the first line.\n- For \\( A_{2} = 5 \\), there is no non-negative integer sequence \\( B \\) that satisfies the condition, so print -1 in the second line.\n\n**Sample Input 2:**\n\n```\n6 8\n167 924 167167 167924 116677 154308\n```\n\n**Sample Output 2:**\n\n```\n11\n58\n10448\n10496\n7293\n9645\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 178\n\nC - Sum of Abs 2 Editorial by evima\n\nIn this explanation, the \u201csum of abs\u201d refers to the following formula: \n\\[\\sum_{j=1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}|\\]\n\nWhen \\(B\\) exists, one \\(B\\) that minimizes \\(\\max(B)\\) satisfies the following two conditions:\n- \\(B\\) is sorted in ascending order.\n- \\(B_{1} = 0\\).\n\nThe sum of abs does not depend on the order of \\(B\\). If all elements of \\(B\\) are positive, subtracting \\(1\\) from all elements can reduce \\(\\max(B)\\) without changing the sum of abs. When \\(B\\) is sorted in ascending order, the sum of abs can be expressed as follows: \n\\[\\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}| = \\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} (B_{k} - B_{j}) =\\sum_{k = 1} ^ {L - 1} k(L - k)(B_{k + 1} - B_{k})\\]\n\nThis transformation is correct because \\(B_{a}-B_{b}=(B_{a}-B_{a-1}) + (B_{a-1}+B_{a-2}) + \\cdots +(B_{b+1}-B_{b})\\) for integers \\(a, b\\) satisfying \\(1\\leq b<a\\leq L\\), and the number of pairs \\((a, b)\\) satisfying \\(b\\leq k\\) and \\(k+1\\leq a\\) is \\(k(L-k)\\).\n\nIf we let \\(C_{k} = B_{k + 1} - B_{k}\\), then when \\(B\\) is sorted in ascending order and \\(B_{1} = 0\\), the following holds:\n- \\(0 \\leq C_{k}\\).\n- The sum of abs is equal to \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}\\).\n- \\(\\displaystyle\\max(B) = B_{L} = \\sum_{k = 1} ^ {L - 1} C_{k}\\).\n\nTherefore, we need to solve the following problem: Determine if there exists a sequence of non-negative integers \\(C\\) of length \\(L - 1\\) such that \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}  = A_{i}\\), and if it exists, find the minimum sum of such \\(C\\).\n\nThis can be solved using dynamic programming in the same manner as the knapsack problem, and it can be computed simultaneously for all \\(i\\). Since \\(C_{k} = 0\\) always holds for \\(k\\) satisfying \\(\\max(A)<k(L-k)\\), our solution has a space complexity of \\(O(\\max(A))\\) and a time complexity of \\(O(N + \\max(A)\\sqrt{\\max(A)})\\).\n\nPython implementation example:\n\n```python\nN, L = map(int, input().split())\nA = list(map(int, input().split()))\n\nM = 2 * 10 ** 5\nINF = 10 ** 9\ndp = [INF] * (M + 1)\ndp[0] = 0\nk = 1\n\nwhile k * (L - k) <= M and k * 2 <= L:\n    w = k * (L - k)\n    for i in range(w, M + 1):\n        dp[i] = min(dp[i], dp[i - w] + 1)\n    k += 1\n\nfor a in A:\n    print(-1 if dp[a] == INF else dp[a])\n``` \n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\n", "problem_ids": ["arc180_c", "arc178_c", "abc361_a"]}, "abc331_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\(2N\\) points \\(P_1, P_2, \\ldots, P_N, Q_1, Q_2, \\ldots, Q_N\\) on a two-dimensional plane. The coordinates of \\(P_i\\) are \\((A_i, B_i)\\), and the coordinates of \\(Q_i\\) are \\((C_i, D_i)\\). No three different points lie on the same straight line.\n\nDetermine whether there exists a permutation \\(R = (R_1, R_2, \\ldots, R_N)\\) of \\((1, 2, \\ldots, N)\\) that satisfies the following condition. If such an \\(R\\) exists, find one.\n\nFor each integer \\(i\\) from \\(1\\) through \\(N\\), let segment \\(i\\) be the line segment connecting \\(P_i\\) and \\(Q_{R_i}\\). Then, segment \\(i\\) and segment \\(j\\) (\\(1 \\leq i < j \\leq N\\)) never intersect.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 300\\)\n- \\(0 \\leq A_i, B_i, C_i, D_i \\leq 5000\\) for \\(1 \\leq i \\leq N\\)\n- \\((A_i, B_i) \\neq (A_j, B_j)\\) for \\(1 \\leq i < j \\leq N\\)\n- \\((C_i, D_i) \\neq (C_j, D_j)\\) for \\(1 \\leq i < j \\leq N\\)\n- \\((A_i, B_i) \\neq (C_j, D_j)\\) for \\(1 \\leq i, j \\leq N\\)\n- No three different points lie on the same straight line.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n\u22ee\nA_N B_N\nC_1 D_1\nC_2 D_2\n\u22ee\nC_N D_N\n```\n\n**Output**\n\nIf there is no \\(R\\) satisfying the condition, print \\(-1\\). If such an \\(R\\) exists, print \\(R_1, R_2, \\ldots, R_N\\) separated by spaces. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n\n```\n3\n0 0\n2 4\n4 2\n0 2\n2 0\n4 4\n```\n\n**Sample Output 1**\n\n```\n2 1 3\n```\n\nBy setting \\(R = (2, 1, 3)\\), the three line segments do not cross each other. Also, any of \\(R = (1, 2, 3)\\), \\( (1, 3, 2)\\), \\( (2, 3, 1)\\), and \\( (3, 1, 2)\\) is a valid answer.\n\n**Sample Input 2**\n\n```\n8\n59 85\n60 57\n72 12\n3 27\n16 58\n41 94\n77 64\n97 20\n32 37\n7 2\n57 94\n35 70\n38 60\n97 100\n5 76\n38 8\n```\n\n**Sample Output 2**\n\n```\n3 5 8 2 7 4 6 1\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        ```markdown\nFor points \\(A\\) and \\(B\\), let \\(|AB|\\) denote the length of the segment \\(AB\\). The permutation \\(R\\) with the minimum \\(\\displaystyle \\sum_{i=0}^{N}|P_i Q_{R_i}|\\) is a solution to this problem.\n\n**Proof:**\n\nIf \\(R\\) does not satisfy the condition, there is \\(R'\\) such that \\(\\displaystyle \\sum_{i=0}^{N}|P_i Q_{R'_i}| < \\displaystyle \\sum_{i=0}^{N}|P_i Q_{R_i}|\\).\n\nSuppose \\(P_a Q_{R_a}\\) and \\(P_b Q_{R_b}\\) intersect. Then, define \\(R'\\) as:\n\n\\[\nR'_k= \n\\begin{cases} \nR_k & (k \\neq a \\land k \\neq b) \\\\\nR_a & (k = b) \\\\\nR_b & (k=a) \n\\end{cases}\n\\]\n\nIt holds that \\(|P_aQ_{R_a}|+|P_bQ_{R_b}| > |P_aQ_{R_b}|+|P_bQ_{R_a}|\\).\n\nBy bounding \\(\\displaystyle \\sum_{i=0}^{N}|P_i Q_{R_i}|\\), the minimum value exists, showing a permutation \\(R\\) minimizes \\(\\displaystyle \\sum_{i=0}^{N}|P_i Q_{R_i}|\\).\n\nTo find \\(R\\), solve a minimum-weight perfect matching problem with algorithms like the Hungarian algorithm or min-cost flow. AtCoder Library (ACL) facilitates this. Note ACL assures integer types; for floating-point costs, define edge costs as the actual cost multiplied by constant \\(C\\), rounded off. \\(C\\) should be at least \\(1.413 \\times 10^{12}\\).\n\nHere's the critical code implementation part for clarity:\n\n```python\nimport math\nfrom atcoder.mincostflow import McfGraph\n\nC = 1.5e12\n\ndef main():\n    n = int(input())\n    xb = [0] * n\n    yb = [0] * n\n    xw = [0] * n\n    yw = [0] * n\n    for i in range(n):\n        xb[i], yb[i] = map(int, input().split())\n    for i in range(n):\n        xw[i], yw[i] = map(int, input().split())\n\n    def dist(i, j):\n        return math.sqrt((xb[i] - xw[j]) ** 2 + (yb[i] - yw[j]) ** 2)\n\n    g = McfGraph(2 * n + 2)\n    s = 2 * n\n    t = 2 * n + 1\n\n    for i in range(n):\n        g.add_edge(s, i, 1, 0)\n        g.add_edge(i + n, t, 1, 0)\n        for j in range(n):\n            g.add_edge(i, j + n, 1, int(dist(i, j) * C + 0.5))\n\n    flow, cost = g.flow(s, t)\n    assert flow == n\n\n    edge_id = 0\n    ans = [0] * n\n    for i in range(n):\n        edge_id += 2\n        for j in range(n):\n            e = g.get_edge(edge_id)\n            if e.flow == 1:\n                ans[i] = j + 1\n            edge_id += 1\n\n    for i in range(n):\n        print(ans[i], end=\" \\n\" if i == n - 1 else \" \")\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nIn AtCoder, a user's rating is represented as a positive integer. Based on the rating value, a certain number of `^` symbols are displayed. Specifically, here are the display rules for different rating ranges:\n\n- If the rating is between 1 and 99, inclusive, `^` is displayed once.\n- If the rating is between 100 and 199, inclusive, `^` is displayed twice.\n- If the rating is between 200 and 299, inclusive, `^` is displayed three times.\n- If the rating is between 300 and 399, inclusive, `^` is displayed four times.\n\nCurrently, Takahashi's rating is \\( R \\). It is guaranteed that \\( R \\) is an integer between 1 and 299, inclusive.\n\nFind the minimum increase in rating required for Takahashi to increase the number of displayed `^`.\n\nIt is guaranteed that under the constraints of this problem, it is possible for Takahashi to increase the number of `^` without his rating reaching 400 or above.\n\n**Constraints**\n\n- \\( 1 \\leq R \\leq 299 \\)\n- \\( R \\) is an integer.\n\n**Input**\n\nThe input is given from standard input as follows:\n```\nR\n```\n\n**Output**\n\nPrint, as an integer, the minimum increase in rating required for Takahashi to increase the number of displayed `^`.\n\n**Sample Input 1**\n```\n123\n```\n\n**Sample Output 1**\n```\n77\n```\n\nTakahashi's current rating is 123, and `^` is displayed twice. By increasing his rating by 77, his rating will become 200, and `^` will be displayed three times. When the rating is 199 or below, `^` is displayed not more than twice, so we print 77.\n\n**Sample Input 2**\n```\n250\n```\n\n**Sample Output 2**\n```\n50\n```\n\nSolution:\n\n        Here is the cleaned-up version of the coding problem editorial:\n\n---\n\n**Official A - Piling Up Editorial**\n\nTo determine the increase in rating required, we denote the current rating by \\(R\\):\n\n- \\((100-R)\\) if \\(1 \\leq R \\leq 99\\)\n- \\((200-R)\\) if \\(100 \\leq R \\leq 199\\)\n- \\((300-R)\\) if \\(200 \\leq R \\leq 299\\)\n\nThis value can be printed using an if statement. Alternatively, using the remainder when \\(R\\) is divided by \\(100\\), one can implement the solution without a conditional branch.\n\n**Sample code in C++:**\n\n```python\nr = int(input())\nif r < 100:\n    print(100 - r)\nelif r < 200:\n    print(200 - r)\nelse:\n    print(300 - r)\n```\n\n**Sample code in Python:**\n\n```python\nr = int(input())\nif r < 100:\n    print(100 - r)\nelif r < 200:\n    print(200 - r)\nelse:\n    print(300 - r)\n```\n\n**Sample code in C++ (alternate solution):**\n\n```python\nr = int(input())\nprint(100 - (r % 100))\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\(N\\) boxes numbered from 1 to \\(N\\), and \\(N\\) balls numbered from 1 to \\(N\\).\n\nYou have assigned Snuke the following procedure as homework:\n\n1. Put each ball into any box he likes. Multiple balls can be placed in the same box, and there can be boxes without balls.\n\n2. For \\(i = 1, 2, \\ldots, N\\) in this order, perform the following operations:\n   - If box \\(i\\) contains no balls, do nothing.\n   - If box \\(i\\) contains balls, take all of them out and arrange them in a line in any order he likes. Let \\(k\\) be the number of balls taken out, and \\((x_1, x_2, \\ldots, x_k)\\) be the ball numbers in the line. For each \\(1 \\leq j \\leq k\\), put ball \\(x_j\\) into box \\(x_{j+1}\\). Here, \\(x_{k+1}\\) means \\(x_1\\). All these operations of putting balls into boxes happen simultaneously.\n\nHe claims that he has completed the homework and reports the final state to you. Specifically, he says that ball \\(i\\) is in box \\(A_i\\) after the procedure.\n\nYou doubt whether he has correctly performed the procedure. Determine whether the state he reported is a possible result of the procedure.\n\nThere are \\(T\\) test cases for each input.\n\n**Constraints**\n\n- \\(1 \\leq T \\leq 250000\\)\n- \\(1 \\leq N \\leq 250000\\)\n- \\(1 \\leq A_i \\leq N\\)\n- The sum of \\(N\\) over all test cases in each input is at most 250000.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \u22ef A_N\n```\n\n**Output**\n\nFor each test case, print \"Yes\" if the state Snuke reported is a possible result of the procedure, and \"No\" otherwise.\n\n**Sample Input**\n\n```\n5\n3\n1 1 1\n3\n2 2 2\n5\n1 2 3 4 5\n10\n8 3 8 10 1 5 3 1 6 4\n10\n1 5 1 2 4 8 8 6 7 3\n```\n\n**Sample Output**\n\n```\nYes\nNo\nYes\nNo\nYes\n```\n\nConsider the first test case: \nThe following steps yield the state Snuke reported, so the answer is \"Yes\".\n\n- Put balls 1, 2, 3 into boxes 1, 1, 2, respectively.\n- Take out the balls from box 1 and arrange them as (2, 1).\n  - Put ball 2 into box 1.\n  - Put ball 1 into box 2.\n- Take out the balls from box 2 and arrange them as (1, 3).\n  - Put ball 1 into box 3.\n  - Put ball 3 into box 1.\n- Take out the balls from box 3 and arrange them as (1).\n  - Put ball 1 into box 1.\n- Now, balls 1, 2, 3 are all in box 1.\n\nSolution:\n\n```\nEditorial - AtCoder Grand Contest 068\n\nC - Ball Redistribution Editorial by evima\n\nLet\u2019s consider the operations in reverse order. Consider a graph where we draw an edge from \\(i\\) to \\(A_i\\). Focus on vertex \\(N\\). First, consider whether vertex \\(N\\) is included in a cycle. \n\nIf vertex \\(N\\) is included in a cycle: The balls in this cycle correspond to those that were in box \\(N\\) before the operation. We break this cycle and add edges from the vertices on the cycle to vertex \\(N\\).\n\nIf vertex \\(N\\) is not included in a cycle: Some cycle corresponds to the balls that were in box \\(N\\) before the operation. We break this cycle and add edges from the vertices on the cycle to vertex \\(N\\). Here, it\u2019s also permissible to assume that box \\(N\\) was empty and change nothing.\n\nIn either case, if there exists a \u201cchild\u201d of vertex \\(N\\) (a vertex that extends an edge to vertex \\(N\\) and is not included in a cycle), it\u2019s impossible to reverse the operation, and we can conclude that the answer is No. When vertex \\(N\\) is not included in a cycle, there is freedom in choosing which cycle to break, but here, let\u2019s suppose we use the cycle in the connected component that includes vertex \\(N\\).\n\nLet\u2019s consider the conditions under which we can complete the reversal for \\(i = N, N-1, \\cdots, 1\\) when the operation can only be reversed in this form. Then, as a sufficient condition, we obtain that the following property holds for each vertex \\(v\\):\n\nLet \\(u_1, \\cdots, u_k\\) be the children of \\(v\\). Let \\(w_i\\) be the largest numbered vertex in the subtree rooted at \\(u_i\\). Then, \\(v < w_i\\).\n\nIn fact, this condition is also a necessary condition in the original problem (without limiting the form of the reversal operation). Therefore, by simply checking this condition, we can solve the problem. We will show that this condition is necessary. Take a vertex \\(v\\) that does not satisfy the condition and its child \\(u\\). No matter how we reverse the operations for \\(i = N, N-1, \\cdots, v + 1\\), they will not affect the subtree rooted at vertex \\(u\\). Then, consider \\(i = v\\), and \\(v\\) will have a child \\(u\\), so the reversal fails. This shows the necessity. The condition can be checked in \\(O(N)\\) time. Sample Solution (Python) Bonus: The number of valid \\(A\\) is \\((2N - 1)!!\\). Try proving it.\n```\n\nTranslated Sample Solution from C++ to Python3:\n\n```python\ndef is_valid_configuration(n, a):\n    # a is the array A with n elements\n    import sys\n    sys.setrecursionlimit(200000)\n    \n    # Graph will store the graph of connections\n    graph = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        graph[a[i - 1]].append(i)\n    \n    def dfs(v):\n        if dp[v] != -1:\n            return dp[v]\n        res = v\n        for u in graph[v]:\n            res = max(res, dfs(u))\n        dp[v] = res\n        return res\n\n    dp = [-1] * (n + 1)\n    # Try to validate the condition for every vertex\n    for v in range(1, n + 1):\n        for u in graph[v]:\n            if dfs(u) <= v:\n                return False\n    return True\n\n# Example usage\nn = 5\na = [2, 3, 4, 5, 2]\nprint(is_valid_configuration(n, a))  # Change this input to test different cases\n```\n\n \n\n", "problem_ids": ["abc373_g", "abc363_a", "agc068_c"]}, "abc331_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers \\( A \\) and \\( B \\) of length \\( N \\). Process \\( Q \\) queries given in the following forms in the order they are given. Each query is of one of the following three types:\n\n1. **Type 1**: Given in the form `1 i x`. Replace \\( A_i \\) with \\( x \\).\n2. **Type 2**: Given in the form `2 i x`. Replace \\( B_i \\) with \\( x \\).\n3. **Type 3**: Given in the form `3 l r`. Solve the following problem and print the answer:\n   - Initially, set \\( v = 0 \\). For \\( i = l, l+1, \\ldots, r \\) in this order, replace \\( v \\) with either \\( v + A_i \\) or \\( v \\times B_i \\). Find the maximum possible value of \\( v \\) at the end.\n\n**It is guaranteed that the answers to the given type 3 queries are at most \\( 10^{18} \\).**\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 10^5 \\)\n- For type 1 and 2 queries, \\( 1 \\leq i \\leq N \\).\n- For type 1 and 2 queries, \\( 1 \\leq x \\leq 10^9 \\).\n- For type 3 queries, \\( 1 \\leq l \\leq r \\leq N \\).\n- For type 3 queries, the value to be printed is at most \\( 10^{18} \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nQ\nquery_1\nquery_2\n\\vdots\nquery_Q\n```\n\nHere, `query_i` is the \\( i \\)-th query, given in one of the following formats:\n- `1 i x`\n- `2 i x`\n- `3 l r`\n\n**Output**\n\nLet \\( q \\) be the number of type 3 queries. Print \\( q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th type 3 query.\n\n**Sample Input 1**\n```\n3\n3 2 4\n1 2 2\n3\n3 1 3\n1 1 1\n3 1 3\n```\n\n**Sample Output 1**\n```\n12\n7\n```\n\nFor the first query, the answer is \\(((0 + A_1) \\times B_2) \\times B_3 = 12\\).\n\nFor the third query, the answer is \\(((0 + A_1) + A_2) + A_3 = 7\\).\n\n**Sample Input 2**\n```\n6\n65 32 12 5 8 312\n4 1 3 15 16 2\n6\n3 2 6\n3 1 5\n1 5 6\n2 4 9\n3 2 6\n3 3 5\n```\n\n**Sample Output 2**\n```\n46080\n69840\n27648\n1728\n```\n\nSolution:\n\n```\nConsider a type-3 query. Let \\(M\\) be the maximum \\(A\\). First, for \\(i = l\\), set \\(v = 0\\) and replace \\(v\\) with \\(v + A[i]\\). By the constraints, \\(v\\) becomes positive. Replace \\(v\\) with \\(v \\times B[i]\\) at most \\(\\log_2 M (< 60)\\) times, since \\(2^{60} > 10^{18}\\) and the input restricts this operation to under 60 times. Thus, the loop iterates a maximum of 59 times:\n\n```python\nv = A[l]\nwhile True:\n    next_l = min(r, smallest_i_after_l_plus_1_such_that_Bi_geq_2)\n    v += sum_a(l + 1, next_l)\n    v = max(v + A[next_l], v * B[next_l])\n    l = next_l\n    if l == r:\n        break\noutput(v)\n```\n\nBy using a segment tree appropriately, the complexity becomes \\(O(N + Q \\log N \\log M)\\). The algorithm is efficient due to the small constant factor.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a sequence of \\( N \\) positive integers \\( A = (A_1, A_2, \\dots, A_N) \\).\n\nFind the number of pairs of integers \\( (l, r) \\) satisfying \\( 1 \\leq l \\leq r \\leq N \\) such that the subsequence \\( (A_l, A_{l+1}, \\dots, A_r) \\) forms an arithmetic progression.\n\nA sequence \\( (x_1, x_2, \\dots, x_{|x|}) \\) is an arithmetic progression if and only if there exists a \\( d \\) such that \\( x_{i+1} - x_i = d \\) for \\( 1 \\leq i < |x| \\). In particular, a sequence of length \\( 1 \\) is always an arithmetic progression.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n4\n3 6 9 3\n```\n\n**Sample Output 1:**\n\n```\n8\n```\n\nThere are eight pairs of integers \\( (l, r) \\) satisfying the condition: \\( (1,1), (2,2), (3,3), (4,4), (1,2), (2,3), (3,4), (1,3) \\). Indeed, when \\( (l, r) = (1, 3) \\), \\( (A_l, \\dots, A_r) = (3, 6, 9) \\) is an arithmetic progression, so it satisfies the condition. However, when \\( (l, r) = (2, 4) \\), \\( (A_l, \\dots, A_r) = (6, 9, 3) \\) is not an arithmetic progression, so it does not satisfy the condition.\n\n**Sample Input 2:**\n\n```\n5\n1 1 1 1 1\n```\n\n**Sample Output 2:**\n\n```\n15\n```\n\nAll pairs of integers \\( (l, r) \\) satisfying \\( 1 \\leq l \\leq r \\leq 5 \\) satisfy the condition.\n\n**Sample Input 3:**\n\n```\n8\n87 42 64 86 72 58 44 30\n```\n\n**Sample Output 3:**\n\n```\n22\n```\n\nSolution:\n\n```markdown\n[C - Count Arithmetic Subarrays Editorial]\n\nThe condition is always satisfied if \\(l = r\\), so we will add \\(n\\) to the answer finally and consider pairs \\((l, r)\\) such that \\(l < r\\). Let \\(B = (B_1, B_2, \\dots, B_{N-1})\\) be the sequence of differences of \\(A\\); that is, \\(B_i = A_{i+1} - A_i\\). The subarray \\((l, r)\\) satisfies the condition of being an arithmetic progression if and only if \\(B_l = B_{l+1} = \\dots = B_{r-1}\\). Thus, the problem is reduced to finding the number of pairs \\((l, r)\\) such that \\(B_l = B_{l+1} = \\dots = B_r\\).\n\nTo solve this, apply run-length compression to \\(B\\), obtaining a sequence of integer pairs \\((C_1, D_1), (C_2, D_2), \\dots, (C_k, D_k)\\). The sequence \\(B\\) is a concatenation of runs \\(f(i)\\), where each \\(C_i\\) is repeated \\(D_i\\) times. A segment \\([l, r]\\) conforming to the condition is completely contained within a run \\(f(i)\\). The number of such segments in \\(f(i)\\) is \\(\\frac{D_i(D_i+1)}{2}\\). The answer is \\(\\displaystyle \\sum_{i=1}^{k} \\frac{D_i(D_i+1)}{2}\\).\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). For each \\( k = 1, 2, \\dots, N \\), find the number, modulo \\( 998244353 \\), of (not necessarily contiguous) subsequences of \\( A \\) of length \\( k \\) that are arithmetic sequences. Two subsequences are distinguished if they are taken from different positions, even if they are equal as sequences.\n\n**What is a subsequence?**  \nA subsequence of a sequence \\( A \\) is a sequence obtained by deleting zero or more elements from \\( A \\) and arranging the remaining elements without changing the order.\n\n### Constraints\n- \\( 1 \\leq N \\leq 80 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n### Output\nPrint the answers for \\( k = 1, 2, \\dots, N \\) in this order, in a single line, separated by spaces.\n\n### Sample Input 1\n```\n5\n1 2 3 2 3\n```\n\n### Sample Output 1\n```\n5 10 3 0 0\n```\n\n- There are 5 subsequences of length 1, all of which are arithmetic sequences.\n- There are 10 subsequences of length 2, all of which are arithmetic sequences.\n- There are 3 subsequences of length 3 that are arithmetic sequences: \\((A_1, A_2, A_3)\\), \\((A_1, A_2, A_5)\\), and \\((A_1, A_4, A_5)\\).\n- There are no arithmetic subsequences of length 4 or more.\n\n### Sample Input 2\n```\n4\n1 2 3 4\n```\n\n### Sample Output 2\n```\n4 6 2 1\n```\n\n### Sample Input 3\n```\n1\n100\n```\n\n### Sample Output 3\n```\n1\n```\n\nSolution:\n\n```python\n# Editorial - E - Count Arithmetic Subsequences\n\n# Every length-1 subsequence is an arithmetic sequence; there are N of them. \n# For counting sequences of length 2 or greater, consider Dynamic Programming (DP) \n# with the states: dp[i][j][l] = the number of arithmetic sequences with \n# initial and second terms A_i and A_j, and length l (l >= 2).\n\n# O(N^4) Solution:\n# Iterate over A_i in descending order. For each fixed A_i, brute-force over the \n# second term A_j (i < j) and the length l. If l = 2, then (A_i, A_j) is an \n# arithmetic sequence of length 2, so dp[i][j][2] += 1. If l >= 3, search over \n# A_k (j < k). If A_k - A_j = A_j - A_i, sequence can be extended by prepending \n# A_i. Thus, dp[i][j][l] += dp[j][k][l-1]. This gives an O(N^4) complexity due to \n# O(N^3) states and O(N) transition cost, feasible under the problem constraints.\n\n# O(N^3) Solution:\n# Optimize by considering dp[i][j][l] = sequences with initial term A_i, length \n# l (l >= 2), and common difference d. Again iterate over A_i in descending order. \n# For fixed A_i, brute-force over A_j (i < j) and l, determining common difference \n# d = A_j - A_i. For l = 2, add 1 to dp[i][2][d]. For l >= 3, extend sequence by \n# adding dp[j][l-1][d] to dp[i][l][d]. As d can be large, use an associative array \n# for indices of d. \n\n# Note: Python automatically accommodates large integers and provides a dictionary \n# (map) data structure that can be used similarly to C++'s map. Here is a Python \n# illustration with comments for flexibility.\n```\n\n(Note: The above solution does not provide the full implementation of the algorithm since it abstractly discusses the logic, but translates the structure and logic described in the editorial to Python format.)\n \n\n", "problem_ids": ["abc368_g", "abc369_c", "abc362_e"]}, "abc331_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi attempted to type a string \\( S \\) consisting of lowercase English letters using a keyboard. He typed while looking only at the keyboard, not the screen. Whenever he mistakenly typed a different lowercase English letter, he immediately pressed the backspace key. However, since the backspace key was broken, the mistakenly typed letter was not deleted, resulting in the actual string \\( T \\). He did not mistakenly press any keys other than those for lowercase English letters. The characters in \\( T \\) that were not mistakenly typed are called correctly typed characters.\n\nYour task is to determine the positions in \\( T \\) of the correctly typed characters.\n\n**Constraints:**\n\n- \\( S \\) and \\( T \\) are strings of lowercase English letters with lengths between 1 and \\( 2 \\times 10^5 \\), inclusive.\n- \\( T \\) is a string obtained by the procedure described.\n\n**Input:**\n\nThe input is given in the following format:\n\n\\( S \\)  \n\\( T \\)\n\n**Output:**\n\nLet \\(|S|\\) be the length of \\( S \\). If the correctly typed characters are the \\( A_1 \\)-th, \\( A_2 \\)-th, \\(\\ldots\\), \\( A_{|S|} \\)-th characters of \\( T \\), print the values of \\( A_1, A_2, \\ldots, A_{|S|} \\) in this order, separated by spaces. Ensure that the output is in ascending order, i.e., \\( A_i < A_{i + 1} \\) should hold for each \\( 1 \\leq i \\leq |S| - 1 \\).\n\n**Sample Input 1:**\n\n```\nabc\naxbxyc\n```\n\n**Sample Output 1:**\n\n```\n1 3 6\n```\n\n**Sample Input 2:**\n\n```\naaaa\nbbbbaaaa\n```\n\n**Sample Output 2:**\n\n```\n5 6 7 8\n```\n\n**Sample Input 3:**\n\n```\natcoder\natcoder\n```\n\n**Sample Output 3:**\n\n```\n1 2 3 4 5 6 7\n```\nIn Sample 1, the sequence of Takahashi's typing is as follows:\n\n1. Type `a`.\n2. Try to type `b` but mistakenly type `x`.\n3. Press the backspace key, but the character is not deleted.\n4. Type `b`.\n5. Try to type `c` but mistakenly type `x`.\n6. Press the backspace key, but the character is not deleted.\n7. Try to type `c` but mistakenly type `y`.\n8. Press the backspace key, but the character is not deleted.\n9. Type `c`.\n\nThe correctly typed characters are the first, third, and sixth characters.\n\nSolution:\n\n        [BEGIN TEXT]\n        Maintain a variable to manage how many first characters of \\(S\\) have been typed while scanning the characters of \\(T\\).\n\n```python\nn, m = 0, 0\ns, t = input(), input()\nn = len(s)\nm = len(t)\na = [0] * n\nj = 0\nfor i in range(m):\n    if s[j] == t[i]:\n        a[j] = i + 1\n        j += 1\nfor i in range(n):\n    print(a[i], end=\" \\n\" if i == n - 1 else \" \")\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two integers \\( A \\) and \\( B \\).\n\nHow many integers \\( x \\) satisfy the following condition?\n\n**Condition:** It is possible to arrange the three integers \\( A \\), \\( B \\), and \\( x \\) in some order to form an arithmetic sequence.\n\nA sequence of three integers \\( p \\), \\( q \\), and \\( r \\) in this order is an arithmetic sequence if and only if \\( q-p \\) is equal to \\( r-q \\).\n\n**Constraints**\n\n- \\( 1 \\leq A, B \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B\n```\n\n**Output**\n\nPrint the number of integers \\( x \\) that satisfy the condition in the problem statement. It can be proved that the answer is finite.\n\n**Sample Input 1**\n```\n5 7\n```\n\n**Sample Output 1**\n```\n3\n```\n\nThe integers \\( x = 3, 6, 9 \\) all satisfy the condition as follows:\n- When \\( x = 3 \\), for example, arranging \\( x, A, B \\) forms the arithmetic sequence \\( 3, 5, 7 \\).\n- When \\( x = 6 \\), for example, arranging \\( B, x, A \\) forms the arithmetic sequence \\( 7, 6, 5 \\).\n- When \\( x = 9 \\), for example, arranging \\( A, B, x \\) forms the arithmetic sequence \\( 5, 7, 9 \\).\n\nConversely, there are no other values of \\( x \\) that satisfy the condition. Therefore, the answer is \\( 3 \\).\n\n**Sample Input 2**\n```\n6 1\n```\n\n**Sample Output 2**\n```\n2\n```\n\nOnly \\( x = -4 \\) and \\( 11 \\) satisfy the condition.\n\n**Sample Input 3**\n```\n3 3\n```\n\n**Sample Output 3**\n```\n1\n```\n\nOnly \\( x = 3 \\) satisfies the condition.\n\nSolution:\n\nHere is the cleaned-up version of the editorial text, focusing only on the solution:\n\n---\n\nFor simplicity, we assume \\(A \\leq B\\). If not, we may swap \\(A\\) and \\(B\\). The condition for arranging \\(A, B, x\\) in an arithmetic sequence is: Among \\(A, B\\), and \\(x\\), the difference between the first and second largest values is equal to the difference between the second and third largest values.\n\nConsider two cases: \n\n1. **If \\(A = B\\):** The condition is satisfied if and only if \\(x = A = B\\), thus the answer is \\(1\\).\n\n2. **If \\(A < B\\):** There are three patterns for the order of \\(A, B\\), and \\(x\\): \n   - \\(x < A < B\\): The condition is represented as \\(B-A = A-x\\), so \\(x = 2A-B\\).\n   - \\(A < B < x\\): The condition is represented as \\(x = 2B-A\\).\n   - \\(A < x < B\\): The condition is represented as \\(B-x = x-A\\). Solving it yields \\(x = \\frac{A+B}{2}\\), so \\(x\\) must be an integer, existing only if \\(A+B\\) is even.\n\nSummary of solutions:\n- \\(1\\) if \\(A = B\\).\n- \\(3\\) if \\(A \\neq B\\) and \\(A + B\\) is even.\n- \\(2\\) if \\(A \\neq B\\) and \\(A + B\\) is odd.\n\nSample Code in Python:\n\n```python\na, b = map(int, input().split())\nif a == b:\n    print(1)\nelif (a + b) % 2 == 0:\n    print(3)\nelse:\n    print(2)\n```\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou have 12 strings \\( S_1, S_2, \\ldots, S_{12} \\) consisting of lowercase English letters. Determine how many integers \\( i \\) (where \\( 1 \\leq i \\leq 12 \\)) satisfy the condition that the length of the string \\( S_i \\) is exactly \\( i \\).\n\n**Constraints:**\n\n- Each \\( S_i \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters for \\( 1 \\leq i \\leq 12 \\).\n\n**Input:**\n\nThe input consists of 12 lines, where each line contains a single string representing \\( S_1, S_2, \\ldots, S_{12} \\).\n\n**Output:**\n\nPrint the number of integers \\( i \\) (where \\( 1 \\leq i \\leq 12 \\)) such that the length of \\( S_i \\) is \\( i \\).\n\n**Sample Input 1:**\n\n```\njanuary\nfebruary\nmarch\napril\nmay\njune\njuly\naugust\nseptember\noctober\nnovember\ndecember\n```\n\n**Sample Output 1:**\n\n```\n1\n```\n\nExplanation: There is only one integer \\( i \\) such that the length of \\( S_i \\) is \\( i \\): 9. Thus, print 1.\n\n**Sample Input 2:**\n\n```\nve\ninrtfa\nnpccxva\ndjiq\nlmbkktngaovl\nmlfiv\nfmbvcmuxuwggfq\nqgmtwxmb\njii\nts\nbfxrvs\neqvy\n```\n\n**Sample Output 2:**\n\n```\n2\n```\n\nExplanation: There are two integers \\( i \\) such that the length of \\( S_i \\) is \\( i \\): 4 and 8. Thus, print 2.\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 373\n\nThis problem requires the usage of a for statement and the retrieval of the length of a string. Use a for statement to repeat the operation for \\(i=1,2,\\ldots, 12\\):\n\n1. Read a string.\n2. If its length equals \\(i\\), add \\(1\\) to the answer.\n\nTo implement this, use the appropriate function for string length retrieval provided by your programming language. In C++, a string type is represented by `std::string`; for a `std::string s`, its length can be obtained as `s.size()`. In Python, the length of `s` can be obtained as `len(s)`. Here are sample codes:\n\n**Sample code (Python3):**\n```python\nans = 0\n\nfor i in range(1, 12 + 1):\n    s = input()  # Read string s\n    if len(s) == i:  # Check if its length equals i\n        ans += 1  # If so, add 1 to the answer\n\nprint(ans)\n```\n \n\n", "problem_ids": ["abc352_b", "abc369_a", "abc373_a"]}, "abc331_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nMr. AtCoder has created a device consisting of \\(N\\) small light bulbs arranged in a row from left to right, and two switches A and B. Each light bulb can be in one of two states: 0 (OFF) and 1 (ON). Pressing each switch causes the following:\n\n- Pressing switch A turns the leftmost light bulb in the 0 state into 1.\n- Pressing switch B turns the leftmost light bulb in the 1 state into 0.\n\nIf there is no applicable light bulb, you cannot press the switch.\n\nInitially, all light bulbs are in the 0 state. He wants the states of the light bulbs to be \\(S_1, S_2, \\dots, S_N\\) from left to right. Determine the order and number of times the switches should be pressed to achieve this. It is not necessary to minimize the number of presses, but it should be at most \\(10^6\\) so that the operations can finish in a realistic time. It can be proved that a solution exists under the constraints of this problem.\n\n**Constraints:**\n\n- \\(1 \\leq N \\leq 30\\)\n- Each of \\(S_1, S_2, \\dots, S_N\\) is 0 or 1.\n- Not all of \\(S_1, S_2, \\dots, S_N\\) are 0.\n- \\(N\\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1 S_2 \\dots S_N\n```\n\nNote that the second line is given as a string of length \\(N\\).\n\n**Output:**\n\nIf your solution presses the switches \\(m\\) times \\((1 \\leq m \\leq 10^6)\\) in the order \\(t_1, t_2, \\dots, t_m\\) (each being A or B), print these in the following format:\n\n```\nm\nt_1 t_2 \\dots t_m\n```\n\nThe second line should be printed as a string of length \\(m\\).\n\n**Sample Input 1:**\n\n```\n5\n01100\n```\n\n**Sample Output 1:**\n\n```\n4\nAAAB\n```\n\nThis sample output presents a solution that presses the switches in the order A, A, A, B. This sets the light bulbs to the desired states, as shown in the figure below:\n\nAlternatively, pressing switches in the order A, A, B, A, A, B also sets the light bulbs to the desired states. The following output corresponding to this solution would also be accepted:\n\n```\n6\nAABAAB\n```\n\nSolution:\n\n```\n        Editorial - B - Puzzle of Lamps\n\nFinding hints for the solution by trial and error:\nIn competitive programming, experimenting with cases like sample inputs can lead to clues for the solution. \n\nFor example, to change the state from 00000 to 01010:\n\n1. First, turn the fourth character into 1. Press A four times and B three times in order to change from 00000 to 00010.\n\n2. Next, turn the second character into 1. Press A twice and then B, which changes 00010 to 01010.\n\nSolution Strategy:\nTo turn only the \\(k\\)-th character into 1 from 000...0, press switch A \\(k\\) times in a row, then press switch B \\(k-1\\) times in a row. For multiple characters:\n- For \\(x_k\\)-th character, press A \\(x_k\\) times and B \\(x_k-1\\) times.\n- Repeat onwards for each \\(x_2, x_1,\\) etc.\n\nSample Python Implementation:\n```python\n# Input\nn = int(input())\ns = input()\n\n# Find the solution\nans = ''\nfor i in range(n-1, -1, -1):\n    if s[i] == '1':\n        ans += 'A' * (i+1) + 'B' * i\n\n# Output\nprint(len(ans))\nprint(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThe Republic of AtCoder consists of \\(L+1\\) islands aligned east-west, numbered \\(0\\) to \\(L\\) from west to east. The islands are connected by air routes, where for each \\(1 \\leq i \\leq L\\), there is a bidirectional air route between islands \\(i-1\\) and \\(i\\). Each air route is owned by company A or company J, and the route between islands \\(i-1\\) and \\(i\\) is owned by company \\(S_i\\).\n\nThe nation has \\(N\\) residents, numbered \\(1\\) to \\(N\\). Resident \\(i\\) is currently on island \\(X_i\\). Each resident has a coupon of one of the companies. Specifically, resident \\(i\\) has a coupon of company \\(C_i\\). With a coupon, a resident can take that company's routes for free any number of times, but taking a route of the other company costs 1 coin per trip.\n\nNow, there is a treasure chest on island 0. The residents want to cooperate to carry it to the capital, which is on island \\(L\\). Determine the minimum total number of coins required to achieve this goal. The residents can pass the treasure chest to each other, but not their coupons.\n\nConstraints:\n- \\(1 \\leq L \\leq 6 \\times 10^4\\)\n- \\(1 \\leq N \\leq 6 \\times 10^4\\)\n- \\(S_i \\ (1 \\leq i \\leq L)\\) is 'A' or 'J'.\n- \\(0 \\leq X_i \\leq L \\ (1 \\leq i \\leq N)\\)\n- \\(C_i \\ (1 \\leq i \\leq N)\\) is 'A' or 'J'.\n- \\(L, N, X_i\\) are integers.\n\nInput:\n- Input is given from Standard Input in the following format:\n  \\[\n  L \\, N \\\\\n  S_1 S_2 \\cdots S_L \\\\\n  X_1 \\, C_1 \\\\\n  X_2 \\, C_2 \\\\\n  \\vdots \\\\\n  X_N \\, C_N\n  \\]\n- Note that the second line is a string of length \\(L\\).\n\nOutput:\n- Print the answer.\n\nSample Input 1:\n```\n4 3\nAAJJ\n3 A\n1 J\n1 J\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation for Sample 1:\nTo carry the treasure chest to island 4 for a total of 2 coins, the following steps are taken:\n1. Resident 1 moves from island 3 to island 2, costing 1 coin as the route is not covered by the coupon.\n2. Resident 1 moves from island 2 to island 1, requiring no coins as the route is covered by the coupon.\n3. Resident 1 moves from island 1 to island 0, requiring no coins as the route is covered by the coupon.\n4. Resident 1 picks up the treasure chest.\n5. Resident 1 moves, carrying the treasure chest, from island 0 to island 1 without costing any coins as the route is covered by the coupon.\n6. Resident 1 passes the treasure chest to resident 2.\n7. Resident 2, with the treasure chest, moves from island 1 to island 2, costing 1 coin as the route is not covered by the coupon.\n8. Resident 2 moves with the treasure chest from island 2 to island 3, requiring no coins as the route is covered by the coupon.\n9. Resident 2 moves with the treasure chest from island 3 to island 4, requiring no coins as the route is covered by the coupon.\n\nSample Input 2:\n```\n8 3\nJJAAJJAJ\n2 A\n6 A\n8 J\n```\n\nSample Output 2:\n```\n6\n```\n\nSample Input 3:\n```\n8 6\nJJAAJJAJ\n2 A\n6 A\n8 J\n8 J\n8 J\n8 J\n```\n\nSample Output 3:\n```\n4\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 177 - F - Two Airlines Editorial\n\nStep 1:\nConsider the optimal movement strategy for residents with company A and J coupons, labeled Blue 1, 2, 3,..., and Red 1, 2, 3,... It is suboptimal for a resident to move luggage after a fellow resident of the same color. Utilize dynamic programming with states recording the current position, count of used Blue and Red residents, and current luggage holder. This yields  \\(\\mathrm{dp}[\\mathrm{pos}][b][r][\\mathrm{type}]\\) but results in an \\(O(N^3)\\) complexity, leading to time limit exceeded.\n\nStep 2:\nReduce state count by assuming residents more than two positions left don't touch luggage, resulting in \\(b \\geq b_{\\mathrm{left}}\\), \\(r \\geq r_{\\mathrm{left}}\\). Still results in \\(O(N^3)\\) complexity, leading to time exceedance.\n\nStep 3:\nFurther constrain by assuming residents over 20 positions to the right do not touch the luggage: \\(b \\leq b_{\\mathrm{left}} + 20\\), \\(r \\leq r_{\\mathrm{left}} + 20\\). The worst-case scenario involves 21 Blue at a single position, causing theoretical upper limit issues, but proven correct under \\(L \\leq 6 \\times 10^4\\).\n\nSample Implementation (C++):\nImplement the strategy noted above with an emphasis on memory and time management due to \\(O(N^3)\\) complexity states. The sample outlines initializing cumulative sums, initializing DP states, and processing state transitions to determine the minimum cost of operations involving agents and positions.\n\n[Code Example Not Included for Brevity]\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nTakahashi and Aoki are playing a game using \\(N\\) cards. The front side of the \\(i\\)-th card has \\(A_i\\) written on it, and the back side has \\(B_i\\) written on it. Initially, the \\(N\\) cards are laid out on the table. With Takahashi going first, the two players take turns performing the following operation:\n\n- Choose a pair of cards from the table such that either the numbers on their front sides are the same or the numbers on their back sides are the same, and remove these two cards from the table. If no such pair of cards exists, the player cannot perform the operation.\n\nThe player who is first to be unable to perform the operation loses, and the other player wins. Determine who wins if both players play optimally.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 18\\)\n- \\(1 \\leq A_i, B_i \\leq 10^9\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\n```\n\n**Output:**\n\nPrint `Takahashi` if Takahashi wins when both players play optimally, and `Aoki` otherwise.\n\n**Sample Input 1:**\n```\n5\n1 9\n2 5\n4 9\n1 4\n2 5\n```\n\n**Sample Output 1:**\n```\nAoki\n```\n\nIf Takahashi first removes:\n- the first and third cards: Aoki can win by removing the second and fifth cards.\n- the first and fourth cards: Aoki can win by removing the second and fifth cards.\n- the second and fifth cards: Aoki can win by removing the first and third cards.\n\nThese are the only three pairs of cards Takahashi can remove in his first move, and Aoki can win in all cases. Therefore, the answer is Aoki.\n\n**Sample Input 2:**\n```\n9\n3 2\n1 7\n4 1\n1 8\n5 2\n9 8\n2 1\n6 8\n5 2\n```\n\n**Sample Output 2:**\n```\nTakahashi\n```\n\nSolution:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nE - Remove Pairs Editorial by en_translator\n\nThere are \\(2^{N}\\) possible sets of cards on the table. It is sufficient to determine for each of them whether the first or second player will win if these cards are on the table right before the first player makes a move. This can be solved with a technique called bit DP. Let \\(dp[S]\\) = true if the first player will win if the cards in \\(S\\) are on the table right before the first player makes a move, and false otherwise. The transitions are as follows:\n\nFor a set \\(S\\) of cards, if \\(dp[S \\setminus \\{i,j\\}]\\) is false for some pair \\(i,j \\in S\\) such that \\(A_i=A_j\\) or \\(B_i=B_j\\), then \\(dp[S]\\) is true; otherwise, it is false.\n\nThe final answer is Takahashi if \\(dp[S]\\) for \\(S=\\{1,2,\\ldots,N\\}\\) is true, and Aoki otherwise. The number of states is \\(O(2^{N})\\) and each transition costs \\(O(N^{2})\\) time, so the total complexity is \\(O(2^{N} N^{2})\\), which is fast enough.\n\nSample code (Python):\n```python\ndef main():\n    n = int(input())\n    a = [0] * n\n    b = [0] * n\n    for i in range(n):\n        a[i], b[i] = map(int, input().split())\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n    for i in range(1, 1 << n):\n        f = False\n        for j in range(n):\n            for k in range(j + 1, n):\n                if (i >> j) & 1 and (i >> k) & 1:\n                    if (a[j] == a[k] or b[j] == b[k]) and dp[i ^ (1 << j) ^ (1 << k)] == 0:\n                        f = True\n        dp[i] = f\n    print(\"Takahashi\" if dp[-1] else \"Aoki\")\n\nmain()\n```\n```\n \n\n", "problem_ids": ["arc177_b", "arc177_f", "abc354_e"]}, "abc332_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nSnuke is planning to build a maze as a new attraction in AtCoder Land. The maze is represented as a grid with \\( N \\) rows and \\( M \\) columns, with the top edge of the top-right cell being the entrance and the bottom edge of the bottom-right cell being the exit. He will create the maze by appropriately placing walls between adjacent cells.\n\nHe loves simple mazes, so he wants the path from the entrance to the exit to pass through exactly \\( K \\) cells without any branches. Determine if it is possible to create such a maze, and if possible, construct one.\n\nFor example, in the following figure, \\( N = 3 \\) and \\( M = 3 \\), and walls are placed at the solid lines (walls are always placed around the outer perimeter except for the entrance and exit). In this case, the path from the entrance to the exit passes through exactly 7 cells without any branches.\n\n### Formal Statement\n\nThere is a grid with \\( N \\) rows and \\( M \\) columns. Let \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. For each pair of side-adjacent cells, you can decide whether to place a wall between them. Determine whether it is possible to place walls to satisfy the following condition, and if it is possible, construct one such placement.\n\n**Condition**: There exists a simple path with \\( K \\) vertices that connects the two vertices \\((1, M)\\) and \\((N, M)\\), and the connected component containing the vertices \\((1, M)\\) and \\((N, M)\\) consists only of this path.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 100 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 1 \\leq K \\leq NM \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\n```\n\n### Output\n\nIf there is no placement of walls that satisfies the condition, print `No`. Otherwise, print one such placement in the following format. If multiple valid placements exist, any of them can be printed.\n\n**See also the sample outputs below to better understand the complicated output format.**\n\n```\nYes\n+++++ \\dots +++S+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n\\vdots\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+++++ \\dots +++G+\n```\n\nHere, `S`, `G`, `+`, and `o` represent the entrance, exit, a wall, and a cell, respectively, and `?` between cells represents a position where a wall can be placed. Replace `?` between two horizontally adjacent cells with `|` if a wall is placed, and `.` otherwise. Replace `?` between two vertically adjacent cells with `-` if a wall is placed, and `.` otherwise.\n\n**Formal Instruction:**\n\n- The output should consist of \\( 2N+2 \\) lines.\n  - Line 1 should contain the string `Yes`.\n  - Lines 2 to \\( 2N+2 \\) should contain strings of length \\( 2M+1 \\) as described below:\n    - Line 2 should be a concatenation of `+` repeated \\( 2M-1 \\) times, `S`, and `+`, in this order.\n    - Line \\( 1+2i \\) (\\( 1 \\leq i \\leq N \\)) should be a concatenation of `+`, `o`, \\( c_{i,1} \\), `o`, \\( c_{i,2} \\), \\(\\dots\\), \\( c_{i,M-1} \\), `o`, `+`, in this order. Here, \\( c_{i,j} \\) is `|` if a wall is placed between cells \\((i,j)\\) and \\((i,j+1)\\), and `.` otherwise.\n    - Line \\( 2+2i \\) (\\( 1 \\leq i \\leq N-1 \\)) should be a concatenation of `+`, \\( r_{i,1} \\), `+`, \\( r_{i,2} \\), `+`, \\(\\dots\\), `+`, \\( r_{i,M} \\), `+`, in this order. Here, \\( r_{i,j} \\) is `-` if a wall is placed between cells \\((i,j)\\) and \\((i+1,j)\\), and `.` otherwise.\n    - Line \\( 2N+2 \\) should be a concatenation of `+` repeated \\( 2M-1 \\) times, `G`, and `+`, in this order.\n\n### Sample Input 1\n\n```\n3 3 7\n```\n\n### Sample Output 1\n\n```\nYes\n+++++S+\n+o.o.o+\n+.+-+-+\n+o.o.o+\n+-+-+.+\n+o.o|o+\n+++++G+\n```\n\nThis is the same placement of walls as in the figure in the problem statement.\n\n### Sample Input 2\n\n```\n3 3 2\n```\n\n### Sample Output 2\n\n```\nNo\n```\n\n### Sample Input 3\n\n```\n4 1 4\n```\n\n### Sample Output 3\n\n```\nYes\n+S+\n+o+\n+.+\n+o+\n+.+\n+o+\n+.+\n+o+\n+G+\n```\n\nSolution:\n\n```python\n        Editorial - AtCoder Beginner Contest 358\n\nF - Easiest Maze Editorial by en_translator\n\nFor what kind of \\(K\\) does the solution exist? Obviously, \\(K\\geq N\\) is required, considering the length of the shortest path between squares \\((1,M)\\) and \\((N,M)\\). Let's draw the grid in a checkered pattern:\n\nAny path visits red square \\(\\rightarrow\\) blue square \\(\\rightarrow\\) red square \\(\\rightarrow\\dots\\). The color parity of squares \\((1,M)\\) and \\((N,M)\\) depends on \\(N\\). Thus, \\(N\\) and \\(K\\) must have the same parity. If \\(N\\) is even, the path ends with an even number of vertices. If \\(K\\geq N\\) and parities are the same, a solution can always be constructed. Starting from the path of the shortest length \\(N\\), increase the length by \\(2\\) incrementally, as \\(N, N+2, N+4, \\dots\\).\n\nImplement carefully with some casework. Use casework and construction separately. The sample code outlines how to compute the sequence of squares, build walls, and remove those between adjacent squares.\n\nSample code (Python 3):\n```python\ndef main():\n    n, m, k = map(int, input().split())\n    if k < n or k % 2 != n % 2:\n        print(\"No\")\n        return\n    print(\"Yes\")\n    path = []\n    k -= n\n    i = 0\n    while i < n - 1:\n        if i != n - 3:\n            w = 1 + min(m - 1, k // 2)\n            k -= (w - 1) * 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n        elif k <= (m - 1) * 2:\n            w = 1 + k // 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n            path.append((i + 2, m - 1))\n        else:\n            for j in range(m):\n                path.append((i, m - 1 - j))\n            k -= (m - 1) * 2\n            j = 0\n            while j < m:\n                if k:\n                    path.append((i + 1, j))\n                    path.append((i + 2, j))\n                    path.append((i + 2, j + 1))\n                    path.append((i + 1, j + 1))\n                    j += 2\n                    k -= 2\n                else:\n                    path.append((i + 1, j))\n                    j += 1\n            path.append((i + 2, m - 1))\n        i += 2\n    \n    c = [['|' for _ in range(m - 1)] for _ in range(n)]\n    r = [['-' for _ in range(m)] for _ in range(n - 1)]\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i + 1]\n        if x1 == x2:\n            c[x1][min(y1, y2)] = '.'\n        else:\n            r[min(x1, x2)][y1] = '.'\n    \n    print('+' + 'S'.join([''] + ['-' * (2 * m - 1), '+']))\n    for i in range(n):\n        print('+', end='')\n        for j in range(m - 1):\n            print('o' + c[i][j], end='')\n        print(\"o+\")\n        if i < n - 1:\n            for j in range(m):\n                print('+' + r[i][j], end='')\n            print('+')\n    print('+' + 'G'.join([''] + ['-' * (2 * m - 1), '+']))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) buildings aligned in a row. The \\( i \\)-th building from the left has a height of \\( H_i \\).\n\nDetermine if there is a building taller than the first one from the left. If such a building exists, find the position of the leftmost such building from the left.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nIf no building is taller than the first one from the left, print `-1`.\nIf such a building exists, print the position (index) of the leftmost such building from the left.\n\n**Sample Input 1**\n```\n4\n3 2 5 2\n```\n\n**Sample Output 1**\n```\n3\n```\n*Explanation*: The building taller than the first one from the left is the third one from the left.\n\n**Sample Input 2**\n```\n3\n4 3 2\n```\n\n**Sample Output 2**\n```\n-1\n```\n*Explanation*: No building is taller than the first one from the left.\n\n**Sample Input 3**\n```\n7\n10 5 10 2 10 13 15\n```\n\n**Sample Output 3**\n```\n6\n```\n*Explanation*: The buildings taller than the first one from the left are the sixth and seventh ones. Among them, the leftmost is the sixth one.\n\nSolution:\n\nHere is a cleaned version of the coding problem editorial:\n\n---\n\nUse a for statement to check for each \\(i=2,3,\\ldots,N\\) if \\(H_i > H_1\\). If such an \\(i\\) is found, print that \\(i\\) and terminate the program. Otherwise, print \\(-1\\). Note that most programming languages adopt \\(0\\)-based indexing.\n\nSample code (Python):\n```python\nn = int(input())\nh = list(map(int, input().split()))\nfor i in range(1, n):\n  if h[i] > h[0]:\n    print(i + 1)\n    exit()\nprint(-1)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a tree with \\(N \\times M + 1\\) vertices numbered \\(0, 1, \\dots, N \\times M\\). The \\(i\\)-th edge (\\(1 \\leq i \\leq N \\times M\\)) connects vertices \\(i\\) and \\(\\max(i - N, 0)\\).\n\nVertex \\(0\\) is painted. The other vertices are unpainted. Takahashi is at vertex \\(0\\). As long as there exists an unpainted vertex, he performs the following operation:\n\n- He chooses one of the vertices adjacent to his current vertex uniformly at random (all choices are independent) and moves to that vertex. Then, if the vertex he is on is unpainted, he paints it.\n\nFind the expected number of times he performs the operation, modulo \\(998244353\\).\n\nWhat is the expected value modulo \\(998244353\\)?\n\nIt can be proved that the sought expected value is always rational. Under the constraints of this problem, when that value is expressed as an irreducible fraction \\(\\frac{P}{Q}\\), it can also be proved that \\(Q \\not\\equiv 0 \\pmod{998244353}\\). Then, there uniquely exists an integer \\(R\\) such that \\(R \\times Q \\equiv P \\pmod{998244353}, 0 \\leq R < 998244353\\). Report this \\(R\\).\n\n**Constraints:**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq M \\leq 2 \\times 10^5\\)\n- \\(N\\) and \\(M\\) are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\n```\n\n**Output:**\n\nPrint the expected number of times he performs the operation, modulo \\(998244353\\).\n\n**Sample Input 1:**\n\n```\n2 2\n```\n\n**Sample Output 1:**\n\n```\n20\n```\n\nFor example, Takahashi could behave as follows.\n- Moves to vertex 1 and paints it. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 0. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 1. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 3 and paints it. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 1. This action is chosen with probability 1.\n- Moves to vertex 0. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 2 and paints it. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 4 and paints it. This action is chosen with probability \\(\\frac{1}{2}\\).\n\nHe behaves in this way with probability \\(\\frac{1}{128}\\), in which case the number of operations is 8. The expected number of operations is 20.\n\n**Sample Input 2:**\n\n```\n123456 185185\n```\n\n**Sample Output 2:**\n\n```\n69292914\n```\n\nSolution:\n\nHere is the text:\n\n[BEGIN TEXT]\nLet\u2019s consider the answer when \\(M = 1\\). In this case, Takahashi alternates between moving to one of the leaf vertices and returning to vertex \\(0\\). We can consider the operation of going to a leaf and returning to the root as a single unit called a round trip. We consider the expected number of operations needed until all leaves are painted. When \\(i\\) leaves are already painted, the expected number of round trips needed until a new leaf is painted is \\(\\frac{N}{N - i}\\). Thus, the expected number of round trips until all leaves are painted is the sum of \\(\\frac{N}{N - i}\\) over \\(i = 0, 1, \\dots, N - 1\\). Each round trip requires \\(2\\) operations, and it is unnecessary to return to the root after all vertices are painted, so the answer is \\(\\left(\\frac{N}{N} + \\frac{N}{N - 1} + \\dots + \\frac{N}{2} + \\frac{N}{1}\\right) \\times 2 - 1\\). Actually, we can handle a general \\(M\\) in the same way. Through some calculations, we find that the average number of operations per round trip is \\(2M^2\\), and the rest of the argument proceeds similarly. Thus, the answer is \\(M^2\\) times the answer for the case \\(M = 1\\).\n\nThe fact that the expected number of operations per round trip is \\(2M^2\\) can be shown by focusing on the depth of the vertex where he is on. By considering the depth, we essentially solve the problem: \u201cWhen performing a random walk on a path graph consisting of vertices \\(0, 1, \\dots, M\\) connected in this order, what is the expected number of steps needed to reach vertex \\(M\\) from vertex \\(0\\) and then return to vertex \\(0\\)?\u201d The answer to this problem is \\(2M^2\\).\n\nTherefore, we have solved this problem. The computational complexity is about \\(\\mathrm{O}(N)\\), which is sufficiently small.\n[END TEXT]\n \n\n", "problem_ids": ["abc358_f", "abc353_a", "arc185_d"]}, "abc332_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 700 points\n\nProblem Statement:  \nYou are given a positive integer \\( N \\). There is an empty set \\( S \\), and you can perform the following operation any number of times:  \n- Choose any positive integer \\( x \\). For each of \\( x \\), \\( 2x \\), and \\( 3x \\), add it to \\( S \\) if it is not already in \\( S \\).\n\nFind the minimum number of operations required to satisfy \\( \\{1, 2, \\dots, N\\} \\subseteq S \\).\n\nConstraints:  \n- \\( 1 \\leq N \\leq 10^9 \\)\n\nInput:  \nThe input is given from Standard Input in the following format:  \n\\( N \\)\n\nOutput:  \nPrint the answer in one line.\n\nSample Input 1:  \n```\n7\n```\n\nSample Output 1:  \n```\n4\n```\n\nExplanation:  \nChoosing \\( 1, 2, 5, \\) and \\( 7 \\) yields \\( S = \\{1, 2, 3, 4, 5, 6, 7, 10, 14, 15, 21\\} \\), which satisfies the condition. It is impossible to satisfy the condition with three or fewer operations.\n\nSample Input 2:  \n```\n25\n```\n\nSample Output 2:  \n```\n14\n```\n\nSolution:\n\n        Editorial - AtCoder Regular Contest 184\n\nProblem B - 123 Set\n\nFirst, divide the problem into sub-problems for each multiset of prime factors other than \\(2\\) and \\(3\\). For each non-negative integer \\(u \\leq N\\) that is neither a multiple of \\(2\\) nor \\(3\\), consider the following:\n\nLet \\(T(u)\\) be the set of integers not greater than \\(\\frac{N}{u}\\) that can be expressed as \\(2^a 3^b\\) using non-negative integers \\(a\\) and \\(b\\). Find the minimum number of operations required so that \\(T(u) \\subseteq S\\) is satisfied.\n\nBy summing up the answers for all \\(u\\), we find the solution to the original problem. Consider the \\(ab\\) plane, associating \\(2^a 3^b\\) with the point \\((a, b)\\). An operation corresponds to selecting \\((x, y)\\) and adding the integers at \\((x, y), (x + 1, y), (x, y + 1)\\) to \\(S\\).\n\nDefine a bit DP:\n\n\\(\\mathrm{dp}[i][s]\\) is the minimum number of operations for all points with \\(a < i\\) added to \\(S\\), and for points with \\(a = i\\), the integers in \\(S\\) correspond to \\(s\\).\n\nThis DP uses fast zeta transform and transitions with time \\(\\displaystyle O\\left(\\left(\\frac{N}{u}\\right)^{0.64} \\log^2 \\frac{N}{u}\\right)\\).\n\nThe number of different choices of \\(u\\) ensuring distinct \\(T(u)\\) is approximately \\((1 + \\log_2 N)(1 + \\log_3 N)\\), and the DP is fast for large \\(u\\). The intended C++ solution runs in about 700 ms. Slower languages can still achieve acceptance with optimized DP implementations.\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), and a sequence of non-negative integers: \\( A = (A_1,A_2,\\ldots,A_N) \\).\n\nFor a non-empty non-negative integer sequence \\( B = (B_1,B_2,\\ldots,B_{|B|}) \\), we define its **score** as follows:\n- If the length of \\( B \\) is a multiple of \\( M \\): \\( (B_1 \\oplus B_2 \\oplus \\dots \\oplus B_{|B|})^K \\)\n- Otherwise: \\( 0 \\)\n\nHere, \\( \\oplus \\) represents the bitwise XOR.\n\nFind the sum, modulo \\( 998244353 \\), of the scores of the \\( 2^N-1 \\) non-empty subsequences of \\( A \\).\n\n### Constraints\n- \\( 1 \\leq N, K \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 0 \\leq A_i < 2^{20} \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n3 2 2\n1 2 3\n```\n\n### Sample Output 1\n```\n14\n```\n\nHere are the scores of the \\( 2^3-1=7 \\) non-empty subsequences of \\( A \\).\n- \\( (1) \\): \\( 0 \\)\n- \\( (2) \\): \\( 0 \\)\n- \\( (3) \\): \\( 0 \\)\n- \\( (1,2) \\): \\( (1 \\oplus 2)^2 = 9 \\)\n- \\( (1,3) \\): \\( (1 \\oplus 3)^2 = 4 \\)\n- \\( (2,3) \\): \\( (2 \\oplus 3)^2 = 1 \\)\n- \\( (1,2,3) \\): \\( 0 \\)\n\nTherefore, the sought sum is \\( 0 + 0 + 0 + 9 + 4 + 1 + 0 = 14 \\).\n\n### Sample Input 2\n```\n10 5 3\n100 100 100 100 100 100 100 100 100 100\n```\n\n### Sample Output 2\n```\n252000000\n```\n\n### Sample Input 3\n```\n16 4 100\n7053 3876 3178 8422 7802 5998 2334 6757 6889 6637 7365 9495 7848 9026 7312 6558\n```\n\n### Sample Output 3\n```\n432440016\n```\n\n\nSolution:\n\nThe problem requires knowledge of XOR convolution and Hadamard transform. Define \\(C_i\\) as the number of subsequences of \\(A\\) with length as a multiple of \\(M\\) and total XOR equals \\(i\\). We need to find \\(C_0, C_1, \\ldots, C_{2^L-1}\\) such that \\(\\sum_{i=0}^{2^L-1} C_i \\cdot i^K\\) is calculated, where \\(L=20\\).\n\nDefine sequences \\(v_i\\) such that each sequence term is a polynomial, with the 0-th term being 1, the \\(A_i\\)-th term as \\(x\\), and others 0. If \\(A_i=0\\), the 0-th term is \\(1+x\\). For two sequences \\(a, b\\), define the XOR convolution as \\((a \\ast b)_k = \\sum_{i \\oplus j = k} a_i \\times b_j\\). \n\nCompute the XOR convolution \\(V = v_1 \\ast v_2 \\ast \\cdots \\ast v_N\\). The coefficient of \\(x^j\\) of the \\(i\\)-th term (\\([x^j]V_i\\)) equals the number of length-\\(j\\) subsequences of \\(A\\) with a total XOR of \\(i\\), resulting in \\(C_i = [x^0]V_i + [x^M]V_i + \\cdots = [x^0]V_i \\, (\\text{mod } 1-x^M)\\).\n\nUtilize Hadamard conversion \\(H\\), where \\(H(a \\ast b)_i = H(a)_i \\times H(b)_i\\). Therefore, \\(H(V)_i = H(v_1)_i \\times \\cdots \\times H(v_N)_i\\). Compute \\(H(V)\\) using Hadamard conversion on sequences \\(v_1, v_2, \\ldots\\).\n\nGiven sequences that have 1 at the 0-th term and \\(x\\) at the \\(A_i\\)-th term, \\(H(v_i)\\) becomes \\((1+x)\\) or \\((1-x)\\). Thus, \\(H(V)_i\\) can be represented as \\((1+x)^{B_i}(1-x)^{N-B_i}\\). Calculate \\(B_i\\) efficiently using a combination of Hadamard conversion and population count divide-and-conquer strategy, allowing \\(O(L2^L)\\) calculation time. Alternatively, use \\(B_i = \\frac{H(\\text{cnt})_i + N}{2}\\).\n\nFind \\([x^0](1+x)^{B_i}(1-x)^{N-B_i} \\, (\\text{mod } 1-x^M)\\) in \\(O(NM)\\) using precalculated sequences for \\((1+x)^n\\) and \\((1-x)^n \\, (\\text{mod } 1-x^M)\\). Thus, the overall problem can be solved in \\(O(NM + 2^L (L + \\log K))\\) time.\n\nHere's the implementation:\n\n```python\nmod = 998244353\n\ndef hadamard(a, m):\n    for k in range(m):\n        i = 1 << k\n        for j in range(1 << m):\n            if not i & j:\n                a[j], a[i | j] = (a[j] + a[i | j]), (a[j] - a[i | j])\n\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nL = 20\ncnt = [0] * (1 << L)\nfor i in range(N):\n    cnt[A[i]] += 1\n\nF = [[0] * M for i in range(N + 1)]\nG = [[0] * M for i in range(N + 1)]\n\nF[0][0], G[0][0] = 1, 1\n\nfor i in range(N):\n    for j in range(M):\n        F[i + 1][j] = (F[i][j] + F[i][j - 1]) % mod\n        G[i + 1][j] = (G[i][j] - G[i][j - 1]) % mod\n\nres = [0] * (N + 1)\nfor i in range(N + 1):\n    for j in range(M):\n        res[i] += F[i][j] * G[N - i][-j]\n        res[i] %= mod\n\nhadamard(cnt, L)\nB = [(cnt[i] + N) // 2 for i in range(1 << L)]\nC = [res[B[i]] for i in range(1 << L)]\nhadamard(C, L)\n\ninv = pow(1 << L, mod - 2, mod)\nans = 0\nfor i in range(1 << L):\n    C[i] = C[i] % mod * inv % mod\n    ans += C[i] * pow(i, K, mod)\n    ans %= mod\n\nprint(ans)\n```\n\nCalculate \\(B\\) using divide-and-conquer:\n\n```python\ndef calc(off, k):\n    if k == 0:\n        return ([cnt[off]], cnt[off])\n    H0, c0 = calc(off, k - 1)\n    H1, c1 = calc(off | (1 << (k - 1)), k - 1)\n    H = [0] * (1 << k)\n    for i in range(1 << (k - 1)):\n        H[i] = H0[i] + H1[i]\n        H[i | (1 << (k - 1))] = H0[i] + c1 - H1[i]\n    return (H, c0 + c1)\n\nB = calc(0, L)[0]\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nGiven integers \\(N\\) and \\(M\\), compute the sum \\(\\sum_{k=0}^{N} \\text{popcount}(k \\& M)\\), modulo \\(998244353\\).\n\nHere, \\(\\&\\) represents the bitwise AND operation.\n\n**What is the bitwise AND operation?**\n\nThe result \\(x = a \\& b\\) of the bitwise AND operation between non-negative integers \\(a\\) and \\(b\\) is defined as follows:\n\n- \\(x\\) is the unique non-negative integer that satisfies the following conditions for all non-negative integers \\(k\\):\n  - If the \\(2^k\\) place in the binary representation of \\(a\\) and \\(b\\) are both \\(1\\), then the \\(2^k\\) place in the binary representation of \\(x\\) is \\(1\\).\n  - Otherwise, the \\(2^k\\) place in the binary representation of \\(x\\) is \\(0\\).\n\nFor example, \\(3=11_{(2)}\\) and \\(5=101_{(2)}\\), so \\(3 \\& 5 = 1\\).\n\n**What is popcount?**\n\n\\(\\text{popcount}(x)\\) represents the number of \\(1\\)s in the binary representation of \\(x\\).\n\nFor example, \\(13=1101_{(2)}\\), so \\(\\text{popcount}(13) = 3\\).\n\n**Constraints:**\n\n- \\(N\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n- \\(M\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\n```\n\n**Output:**\n\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 3\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n- \\(\\text{popcount}(0 \\& 3) = 0\\)\n- \\(\\text{popcount}(1 \\& 3) = 1\\)\n- \\(\\text{popcount}(2 \\& 3) = 1\\)\n- \\(\\text{popcount}(3 \\& 3) = 2\\)\n- \\(\\text{popcount}(4 \\& 3) = 0\\)\n\nThe sum of these values is \\(4\\).\n\n**Sample Input 2:**\n```\n0 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\nIt is possible that \\(N = 0\\) or \\(M = 0\\).\n\n**Sample Input 3:**\n```\n1152921504606846975 1152921504606846975\n```\n\n**Sample Output 3:**\n```\n499791890\n```\n\nRemember to compute the result modulo \\(998244353\\).\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial presents the solution to a problem from AtCoder Beginner Contest 356, specifically the \"D - Masked Popcount\" problem. The goal is to compute the sum of set bits in the result of bitwise AND operations between each integer from 0 to N and a given integer M with the following steps:\n\n1. Iterate over each bit position \\( j \\) from 0 to 59.\n2. If the \\( j \\)-th bit of \\( M \\) is set, for each \\( j \\), add to the result the count of integers between 0 and N whose \\( j \\)-th bit is set.\n3. The number of integers with the \\( j \\)-th bit set is calculated by examining ranges defined by powers of two.\n4. During computation, handle overflow by taking results modulo 998244353.\n\nThe solution involves efficiently counting set bits using bit operations and properties of numbers, ensuring accurate summing even under large values.\n[END TEXT]\n \n\n", "problem_ids": ["arc184_b", "abc367_g", "abc356_d"]}, "abc332_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 600 points\n\nProblem Statement:\nThere are \\(N\\) stones placed on a 2-dimensional plane. The \\(i\\)-th stone is located at coordinates \\((X_i, Y_i)\\). All stones are located at lattice points in the first quadrant (including the axes).\n\nCount the number of lattice points \\((x, y)\\) where no stone is placed and it is **impossible** to reach \\((-1, -1)\\) from \\((x, y)\\) by repeatedly moving up, down, left, or right by 1 without passing through coordinates where a stone is placed.\n\nMore precisely, count the number of lattice points \\((x, y)\\) where no stone is placed, and there does **not** exist a finite sequence of integer pairs \\((x_0, y_0), \\ldots, (x_k, y_k)\\) that satisfies all of the following four conditions:\n1. \\((x_0, y_0) = (x, y)\\).\n2. \\((x_k, y_k) = (-1, -1)\\).\n3. \\(|x_i - x_{i+1}| + |y_i - y_{i+1}| = 1\\) for all \\(0 \\leq i < k\\).\n4. There is no stone at \\((x_i, y_i)\\) for all \\(0 \\leq i \\leq k\\).\n\nConstraints:\n- \\(0 \\leq N \\leq 2 \\times 10^5\\)\n- \\(0 \\leq X_i, Y_i \\leq 2 \\times 10^5\\)\n- The pairs \\((X_i, Y_i)\\) are distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nX_1 Y_1\n\\vdots\nX_N Y_N\n```\n\nOutput:\nPrint the number of lattice points that satisfy the conditions.\n\nSample Input 1:\n```\n5\n1 0\n0 1\n2 3\n1 2\n2 1\n```\n\nSample Output 1:\n```\n1\n```\nIt is impossible to reach \\((-1, -1)\\) from \\((1, 1)\\).\n\nSample Input 2:\n```\n0\n```\n\nSample Output 2:\n```\n0\n```\nThere may be cases where no stones are placed.\n\nSample Input 3:\n```\n22\n0 1\n0 2\n0 3\n1 0\n1 4\n2 0\n2 2\n2 4\n3 0\n3 1\n3 2\n3 4\n5 1\n5 2\n5 3\n6 0\n6 4\n7 0\n7 4\n8 1\n8 2\n8 3\n```\n\nSample Output 3:\n```\n6\n```\nThere are six such points: \\((6, 1), (6, 2), (6, 3), (7, 1), (7, 2), (7, 3)\\).\n\nSolution:\n\n```python\n'''\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nG - Go Territory Editorial by en_translator\n\nWe will consider a grid instead of a coordinate plane. We call those cells reachable to (-1,-1) \u201cinside,\u201d \nand unreachable \u201coutside.\u201d We first consider the case where the stones are connected in eight directions. \nBy enumerating eight cells around each cell beforehand, one can easily determine if these cells are inside or \noutside easily with BFS (Breadth First Search). The top-left cell is always outside; by performing BFS from this cell \nin four directions, one can reach all cells outside.\n\nExample: black cells represent lattice points with stones. Then, inspect each row. If there is a segment with \n\u201coutside stone inside \u2026 inside stone outside,\u201d then that segment can be counted as \u201cinside\u201d to count \u201cinside\u201d points. \nBeware of cases with consecutive stones, or stones between inside cells.\n\nNow we consider disconnected cases. It may seem we can consider each connected component independently, \nbut note that there may be a nested structure. After performing BFS for each connected component and determining whether \neach cell is outside or inside, when scanning the entire row, there may be parts like \n\u201coutside stone inside \u2026\u2026 outside stone inside \u2026\u2026 inside stone outside \u2026\u2026 inside stone outside,\u201d where some cells \ninside are labeled outside.\n\nEvery time you encounter \u201coutside, one or more stones, inside,\u201d the nest increases by one; for \n\u201cinside, one or more stones, outside,\u201d it decreases by one. By using this method to manage how many times the current \nposition is surrounded, one can handle this issue. Also, if there are different connected components sufficiently close \nto each other, the label (outside/inside) might be overwritten. This can be avoided by defining that stones are connected \nif the Chebyshev distance is two or less, instead of being eight-adjacent.\n'''\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\(N\\) linear functions \\(f_1, f_2, \\ldots, f_N\\), where \\(f_i(x) = A_i x + B_i\\). Your task is to find the maximum possible value of \n\\[ \nf_{p_1}(f_{p_2}(\\ldots f_{p_K}(1) \\ldots )) \n\\]\nfor a sequence \\(p = (p_1, p_2, \\ldots, p_K)\\) composed of \\(K\\) distinct integers between \\(1\\) and \\(N\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq K \\leq \\text{min}(N,10)\\)\n- \\(1 \\leq A_i, B_i \\leq 50\\) for all \\(1 \\leq i \\leq N\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2\n2 3\n1 5\n4 2\n```\n\n**Sample Output 1**\n```\n26\n```\n\n**Explanation for Sample Input 1**\n\nHere are all possible \\(p\\) and the corresponding values of \\(f_{p_1}(f_{p_2}(1))\\):\n- \\(p= (1,2)\\): \\(f_1(f_2(1))=15\\)\n- \\(p= (1,3)\\): \\(f_1(f_3(1))=15\\)\n- \\(p= (2,1)\\): \\(f_2(f_1(1))=10\\)\n- \\(p= (2,3)\\): \\(f_2(f_3(1))=11\\)\n- \\(p= (3,1)\\): \\(f_3(f_1(1))=22\\)\n- \\(p= (3,2)\\): \\(f_3(f_2(1))=26\\)\n\nTherefore, the maximum value is \\(26\\), and you should print \\(26\\).\n\n**Sample Input 2**\n```\n10 3\n48 40\n34 22\n24 37\n45 40\n48 31\n49 44\n45 40\n44 6\n35 22\n39 28\n```\n\n**Sample Output 2**\n```\n216223\n```\n\nSolution:\n\n```python\nn, k = map(int, input().split())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nord_indices = list(range(n))\nord_indices.sort(key=lambda i: b[i] * (a[i] - 1), reverse=True)\n\ndp = [int(-1e9)] * (k + 1)\ndp[0] = 1\n\nfor i in ord_indices:\n    ndp = dp[:]\n    for j in range(k):\n        if dp[j] > int(-1e9):\n            ndp[j + 1] = max(ndp[j + 1], dp[j] * a[i] + b[i])\n    dp = ndp\n\nprint(dp[k])\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAt the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes \\( A \\) seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.\n\nCurrently, there is no one in line at the ticket booth, and \\( N \\) people will come to buy tickets one after another. Specifically, the \\( i \\)-th person will arrive at the ticket booth \\( T_i \\) seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately. Here, \\( T_1 < T_2 < \\dots < T_N \\).\n\nFor each \\( i\\ (1 \\leq i \\leq N) \\), determine how many seconds from now the \\( i \\)-th person will finish purchasing their ticket.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 0 \\leq T_1 < T_2 < \\dots < T_N \\leq 10^6 \\)\n- \\( 1 \\leq A \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\nT_1 T_2 \\dots T_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the number of seconds from now that the \\( i \\)-th person will finish purchasing their ticket.\n\n**Sample Input 1:**\n\n```\n3 4\n0 2 10\n```\n\n**Sample Output 1:**\n\n```\n4\n8\n14\n```\n\nThe events proceed in the following order:\n\n- At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.\n- At 8 seconds: The 2nd person finishes purchasing their ticket.\n- At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 14 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 2:**\n\n```\n3 3\n1 4 7\n```\n\n**Sample Output 2:**\n\n```\n4\n7\n10\n```\n\nThe events proceed in the following order:\n\n- At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.\n- At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 10 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 3:**\n\n```\n10 50000\n120190 165111 196897 456895 540000 552614 561627 743796 757613 991216\n```\n\n**Sample Output 3:**\n\n```\n170190\n220190\n270190\n506895\n590000\n640000\n690000\n793796\n843796\n1041216\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nB - Ticket Counter Editorial by en_translator\n\nSuppose that the \\(i\\)-th person finishes buying a ticket at time \\(x_i\\). For convenience, let \\(x_0=0\\).\nFor each \\(i\\) (1 \\(\\leq i\\leq N\\)), we determine how to represent the value \\(x_i\\) using \\(x_{i-1}\\).\n\nIf \\(x_{i-1} \\leq T_i\\): there is no queue when the \\(i\\)-th person visits the ticket booth, so they can start purchasing instantly. Thus, \\(x_i=T_i+A\\).\nIf \\(x_{i-1} > T_i\\): someone is still purchasing a ticket when the \\(i\\)-th person visits the booth, so they start the process right after the \\((i-1)\\)-th person finishes. Thus, \\(x_i=x_{i-1}+A\\).\n\nTo summarize, \\(x_i=\\max(x_{i-1},T_i)+A\\). Use this to find \\(x_i\\) for each \\(i=1,2,\\dots,N\\).\n\nSample code (Python):\n```python\nn, a = map(int, input().split())\nt = list(map(int, input().split()))\npre = 0\nfor i in range(n):\n    ans = max(pre, t[i]) + a\n    print(ans)\n    pre = ans\n```\n \n\n", "problem_ids": ["abc361_g", "abc366_f", "abc358_b"]}, "abc332_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n Problem Statement:  \nYou are given integers \\( N \\) and \\( Q \\), and two integer sequences of length \\( Q \\): \\( A = (A_1, A_2, \\ldots, A_Q) \\) and \\( B = (B_1, B_2, \\ldots, B_Q) \\). For each \\( k = 1, 2, \\ldots, Q \\), solve the following problem:  \n\nThere is an undirected graph with \\( N \\) vertices numbered from \\( 0 \\) to \\( N-1 \\) and \\( N \\) edges. The \\( i \\)-th edge \\( (0 \\leq i < N) \\) connects vertices \\( i \\) and \\( (A_k \\times i + B_k) \\mod N \\) bidirectionally. Find the number of connected components in this undirected graph.  \n\nConstraints:  \n- \\( 1 \\leq N \\leq 10^6 \\)  \n- \\( 1 \\leq Q \\leq 10^5 \\)  \n- \\( 0 \\leq A_k < N \\)  \n- \\( 0 \\leq B_k < N \\)  \n- All input values are integers.  \n\nInput:  \nThe input is given from Standard Input in the following format:  \n```\nN Q  \nA_1 B_1  \nA_2 B_2  \n\\vdots  \nA_Q B_Q  \n```  \n\nOutput:  \nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer for \\( k = i \\).  \n\nSample Input 1:  \n```\n6 3  \n2 1  \n0 1  \n1 0  \n```  \n\nSample Output 1:  \n```\n2  \n1  \n6  \n```  \n\nExplanation for \\( k = 1 \\):  \nThe graph has the following two connected components:  \n- A connected component with vertices \\( 0, 1, 3, 4 \\).  \n- A connected component with vertices \\( 2, 5 \\).  \n\nThus, the answer for \\( k = 1 \\) is \\( 2 \\).  \n\nSample Input 2:  \n```\n11 3  \n9 1  \n5 3  \n8 0  \n```  \n\nSample Output 2:  \n```\n3  \n3  \n2  \n```  \n\nExplanation for \\( k = 1 \\):  \nThe graph has the following three connected components:  \n- A connected component with vertices \\( 0, 1, 3, 6, 10 \\).  \n- A connected component with vertices \\( 2, 5, 7, 8, 9 \\).  \n- A connected component with vertex \\( 4 \\).  \n\nThus, the answer for \\( k = 1 \\) is \\( 3 \\).  \n\nSample Input 3:  \n```\n182 3  \n61 2  \n77 88  \n180 55  \n```  \n\nSample Output 3:  \n```\n36  \n14  \n9  \n```\n\nSolution:\n\n[BEGIN TEXT]\nBelow is a cleaner version of the editorial:\n\n---\n\n**Editorial - AtCoder Regular Contest 182**\n\n**Official Problem F - Graph of Mod of Linear**\n\nWe will analyze the problem in terms of directed graphs. The number of connected components in the undirected graph corresponds to the number of cycles in the directed graph, so we will focus on the latter.\n\n1. **When \\(\\gcd(N, A) \\neq 1\\):**\n\n   Let \\(f^N(x)\\) represent the vertex reached after \\(N\\) moves starting from vertex \\(x\\). We have \\(\\displaystyle f^N(x)\\equiv A^N x + B\\frac{A^N-1}{A-1}\\ \\text{mod}\\ N\\). Here, let \\(d = \\gcd(N, A^N)\\). Since \\(\\displaystyle f^N(x+1)-f^N(x)\\equiv A^N\\equiv 0\\ \\text{mod}\\ d\\), the vertices forming a cycle all match \\(f^N(0)\\) modulo \\(d\\). Considering only these vertices, the problem can be reduced to the case where \\(\\displaystyle(N, A, B) \\leftarrow \\left(\\frac{N}{d}, A \\mod \\frac{N}{d}, \\frac{A^N}{d}B \\mod \\frac{N}{d}\\right)\\). By performing this substitution, the problem can be reduced to the case where \\(\\gcd(N, A) = 1\\).\n\n2. **When \\(\\gcd(N, A) = 1\\):**\n\n   If \\(\\gcd(N, A) = 1\\), all vertices form some cycle. Therefore, the answer is the sum of the reciprocals of the lengths of the cycles formed by each vertex. If vertex \\(x\\) returns to its original position after \\(K\\) moves, then \\(\\displaystyle A^K x + B\\frac{A^K-1}{A-1}\\equiv x\\ \\text{mod}\\ N\\), which implies \\(\\displaystyle A^K\\equiv 1\\ \\text{mod}\\ \\frac{N(A-1)}{\\gcd(N(A-1), (A-1)x+B)}\\). Letting \\(G = \\gcd(A-1, B)\\), \\(A'=\\frac{A-1}{G}\\), \\(B'=\\frac{B}{G}\\), and \\(N'=\\frac{N}{\\gcd(A'^N, N)}\\), we have \\(\\displaystyle \\gcd(N(A-1), (A-1)x+B)=G\\gcd(N', A'x+B')\\). Since \\(A'\\) and \\(N'\\) are coprime, for each \\(0\\le y<N'\\), there exist exactly \\(\\displaystyle \\frac{N}{N'}\\) values \\(0\\le x<N\\) such that \\(y\\equiv A'x+B'\\ \\text{mod}\\ N'\\). Therefore, if we let \\(C_y\\) be the smallest positive integer \\(K\\) such that \\(\\displaystyle A^K\\equiv 1\\ \\text{mod}\\ \\frac{NA'}{\\gcd(y, N')}\\) for each \\(0\\le y<N'\\), the desired answer is \\(\\displaystyle \\frac{N}{N'}\\sum_{y=0}^{N'-1}\\frac{1}{C_y}\\). Values of \\(y\\) with the same \\(\\gcd(y, N')\\) have the same \\(C_y\\). Therefore, for each divisor \\(n\\) of \\(N'\\), we need to find the answer for \\(n = \\gcd(y, N')\\), and sum them up. The number of values \\(0\\le y<N'\\) such that \\(n = \\gcd(y, N')\\) is \\(\\displaystyle \\phi\\left(\\frac{N'}{n}\\right)\\), so the answer can be expressed as \\(\\displaystyle \\frac{N}{N'}\\sum_{n| N'}\\frac{1}{C_n}\\phi\\left(\\frac{N'}{n}\\right)\\). Here, \\(\\phi\\) is the Euler\u2019s totient function.\n\nTo compute \\(C_n\\) for each \\(n\\), we can use the following facts:\n\n- By Euler\u2019s theorem, the candidates for \\(C_1\\) are divisors of \\(\\phi(NA')\\).\n- Let \\(n_1\\) and \\(n_2\\) be divisors of \\(N'\\). If \\(n_1\\) divides \\(n_2\\), then \\(C_{n_2}\\) divides \\(C_{n_1}\\).\n\nThis approach can be implemented using a DFS-like method. The value of \\(\\phi(NA')\\) and its prime factorization can be computed quickly by precomputing the prime factorizations of all positive integers up to \\(N\\).\n\n---\n\nThis concise editorial provides a clear breakdown of the problem-solving approach without unnecessary content.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 450 points\n\n## Problem Statement\n\nThere are \\( N \\) islands and \\( M \\) bidirectional bridges connecting two islands. The islands and bridges are numbered \\( 1, 2, \\ldots, N \\) and \\( 1, 2, \\ldots, M \\), respectively. Bridge \\( i \\) connects islands \\( U_i \\) and \\( V_i \\), and the time it takes to cross it in either direction is \\( T_i \\). No bridge connects an island to itself, but it is possible for two islands to be directly connected by more than one bridge. One can travel between any two islands using some bridges.\n\nYou are given \\( Q \\) queries, so answer each of them. The \\( i \\)-th query is as follows:\n\n- You are given \\( K_i \\) distinct bridges: bridges \\( B_{i,1}, B_{i,2}, \\ldots, B_{i,K_i} \\).\n- Find the minimum time required to travel from island \\( 1 \\) to island \\( N \\) using each of these bridges at least once.\n- Only consider the time spent crossing bridges.\n- You can cross the given bridges in any order and in any direction.\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 400 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq T_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 3000 \\)\n- \\( 1 \\leq K_i \\leq 5 \\)\n- \\( 1 \\leq B_{i,1} < B_{i,2} < \\cdots < B_{i,K_i} \\leq M \\)\n- All input values are integers.\n- It is possible to travel between any two islands using some bridges.\n\n## Input\n\nThe input is given in the following format:\n```\nN M\nU_1 V_1 T_1\nU_2 V_2 T_2\n\u22ee\nU_M V_M T_M\nQ\nK_1\nB_{1,1} B_{1,2} \u22ef B_{1,{K_1}}\nK_2\nB_{2,1} B_{2,2} \u22ef B_{2,{K_2}}\n\u22ee\nK_Q\nB_{Q,1} B_{Q,2} \u22ef B_{Q,{K_Q}}\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq Q \\)) should contain the answer to the \\( i \\)-th query as an integer.\n\n## Sample Input 1\n\n```\n3 5\n1 2 10\n1 3 20\n1 3 30\n2 3 15\n2 3 25\n2\n1\n1\n2\n3 5\n```\n\n## Sample Output 1\n\n```\n25\n70\n```\n\nExplanation:\n- For the first query, the minimum time to travel from island 1 to island 3 using bridge 1 is achieved by using bridge 1 to move from island 1 to island 2, then bridge 4 to move from island 2 to island 3. The time taken is 10 + 15 = 25.\n- For the second query, the minimum time to travel from island 1 to island 3 using both bridges 3 and 5 is achieved by using bridge 3 to move from island 1 to island 3, then using bridge 5 to move to island 2, and finally bridge 4 to return to island 3. The time taken is 30 + 25 + 15 = 70.\n\n## Sample Input 2\n\n```\n6 6\n1 5 1\n2 5 1\n2 4 1\n3 4 1\n3 6 1\n1 6 1\n2\n5\n1 2 3 4 5\n1\n5\n```\n\n## Sample Output 2\n\n```\n5\n3\n```\n\nRemarks: You can cross the specified bridges in either direction.\n\n## Sample Input 3\n\n```\n5 5\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4 5 1000000000\n1 5 1000000000\n1\n1\n3\n```\n\n## Sample Output 3\n\n```\n4000000000\n```\n\nNote: The answer may not fit in a 32-bit integer.\n\nSolution:\n\n```python\nimport itertools\n\nN = 400\nM = int(2e5)\nINF = int(1e15)\n\nn = 0\nu = [0] * M\nv = [0] * M\nt = [0] * M\nd = [[0 if i == j else INF for j in range(N)] for i in range(N)]\nk = 0\na = []\n\ndef solve():\n    ans = INF\n    dp = [[0] * 2 for _ in range(5)]\n    b = list(range(k))\n    for perm in itertools.permutations(b):\n        dp[0][0] = d[0][v[a[perm[0]]]] + t[a[perm[0]]]\n        dp[0][1] = d[0][u[a[perm[0]]]] + t[a[perm[0]]]\n        for i in range(k - 1):\n            dp[i + 1][0] = min(dp[i][0] + d[u[a[perm[i]]]][v[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][v[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n            dp[i + 1][1] = min(dp[i][0] + d[u[a[perm[i]]]][u[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][u[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n        ans = min(ans, dp[k-1][0] + d[u[a[perm[k-1]]]][n-1])\n        ans = min(ans, dp[k-1][1] + d[v[a[perm[k-1]]]][n-1])\n    return ans\n\ndef main():\n    global n, k\n    m, q = map(int, input().split())\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d[i][j] = INF\n\n    for i in range(m):\n        u[i], v[i], t[i] = map(int, input().split())\n        u[i] -= 1\n        v[i] -= 1\n        d[u[i]][v[i]] = min(d[u[i]][v[i]], t[i])\n        d[v[i]][u[i]] = min(d[v[i]][u[i]], t[i])\n\n    for i1 in range(n):\n        for i0 in range(n):\n            for i2 in range(n):\n                d[i0][i2] = min(d[i0][i2], d[i0][i1] + d[i1][i2])\n    \n    for _ in range(q):\n        k = int(input())\n        a.clear()\n        for _ in range(k):\n            x = int(input())\n            a.append(x-1)\n        print(solve())\n\nif __name__ == '__main__':\n    main()\n```\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi has a piano with 100 keys arranged in a row. The i-th key from the left is called key i.\n\nHe will play music by pressing N keys one by one. For the i-th press, he will press key \\( A_i \\), using his left hand if \\( S_i = L \\), and his right hand if \\( S_i = R \\).\n\nBefore starting to play, he can place both of his hands on any keys he likes, and his fatigue level at this point is 0. During the performance, if he moves one hand from key x to key y, the fatigue level increases by \\(|y-x|\\) (the fatigue level does not increase for any reason other than moving hands). To press a certain key with a hand, that hand must be placed on that key.\n\nFind the minimum possible fatigue level at the end of the performance.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq 100 \\)\n- \\( N \\) and \\( A_i \\) are integers.\n- \\( S_i \\) is 'L' or 'R'.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 S_1\nA_2 S_2\n...\nA_N S_N\n```\n\n**Output**\n\nPrint the minimum fatigue level at the end of the performance.\n\n**Sample Input 1**\n```\n4\n3 L\n6 R\n9 L\n1 R\n```\n\n**Sample Output 1**\n```\n11\n```\n\nFor example, the performance can be done as follows:\n- Initially, place the left hand on key 3 and the right hand on key 6.\n- Press key 3 with the left hand.\n- Press key 6 with the right hand.\n- Move the left hand from key 3 to key 9. The fatigue level increases by \\(|9-3| = 6\\).\n- Move the right hand from key 6 to key 1. The fatigue level increases by \\(|1-6| = 5\\).\n- Press key 9 with the left hand.\n- Press key 1 with the right hand.\n\nIn this case, the fatigue level at the end of the performance is \\(6 + 5 = 11\\), which is the minimum possible.\n\n**Sample Input 2**\n```\n3\n2 L\n2 L\n100 L\n```\n\n**Sample Output 2**\n```\n98\n```\n\n**Sample Input 3**\n```\n8\n22 L\n75 L\n26 R\n45 R\n72 R\n81 R\n47 L\n29 R\n```\n\n**Sample Output 3**\n```\n188\n```\n\nSolution:\n\n```\nEditorial - B - Piano 3\n\nManage the positions of left and right hands while inspecting the key to press for \\(1,2,\\dots,N\\)-th press, and add the fatigue level of each move required. In the sample code, an array \\(\\text{pos}\\) of length two is prepared, with \\(pos[0]\\) and \\(pos[1]\\) managing the current positions of left and right hands, respectively. Initial positions are set to \\(-1\\), and no fatigue is added when moving a hand from \\(-1\\) to another key. This simulates placing a hand at the first key to be pressed by that hand.\n\nSample code (Python):\n```python\nn = int(input())\npos = [-1, -1]   # 0: left, 1: right\nans = 0\nfor i in range(n):\n    a, s = input().split()\n    a = int(a)\n    hand = (0 if s == 'L' else 1)\n    if pos[hand] != -1:\n        ans += abs(pos[hand] - a)\n    pos[hand] = a\nprint(ans)\n```\n```\n \n\n", "problem_ids": ["arc182_f", "abc369_e", "abc369_b"]}, "abc333_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 550 points\n\n## Problem Statement\n\nYou are given a weighted undirected connected graph \\( G \\) with \\( N \\) vertices and \\( N-1 \\) edges, where vertices are numbered from \\( 1 \\) to \\( N \\) and edges are numbered from \\( 1 \\) to \\( N-1 \\). Edge \\( i \\) connects vertices \\( a_i \\) and \\( b_i \\) with a weight of \\( c_i \\).\n\nYou are given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- You are given integers \\( u_i, v_i, w_i \\). Add an edge with weight \\( w_i \\) between vertices \\( u_i \\) and \\( v_i \\) in \\( G \\). Then, print the sum of the weights of the edges in a minimum spanning tree of \\( G \\).\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i < b_i \\leq N \\)\n- \\( 1 \\leq u_i < v_i \\leq N \\)\n- \\( 1 \\leq c_i, w_i \\leq 10 \\)\n- The graph is connected before processing the queries.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\na_1 b_1 c_1\n.\n.\n.\na_{N-1} b_{N-1} c_{N-1}\nu_1 v_1 w_1\n.\n.\n.\nu_Q v_Q w_Q\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n## Sample Input 1\n\n```\n4 4\n1 2 6\n2 3 5\n2 4 4\n1 3 3\n1 2 3\n1 4 10\n3 4 1\n```\n\n## Sample Output 1\n\n```\n12\n10\n10\n7\n```\n\nHere is the graph after adding the edge for each query. The edges included in the minimum spanning tree are colored red.\n\n## Sample Input 2\n\n```\n8 6\n1 8 8\n1 6 10\n1 5 8\n2 6 6\n6 7 6\n1 3 9\n2 4 7\n1 3 4\n1 6 7\n3 4 6\n1 5 1\n7 8 4\n3 5 3\n```\n\n## Sample Output 2\n\n```\n49\n46\n45\n38\n34\n33\n```\n\nSolution:\n\n```\nHere is the trimmed editorial:\n\n---\n\n**F - MST Query Editorial**\n\nLet \\(W=10\\) be the maximum edge weight. Let \\(G_k (0\\leq k\\leq W)\\) be the (unweighted) subgraph of \\(G\\) consisting of the edges of \\(G\\) with weights not more than \\(k\\). Let \\(H\\) be the number of connected components of a graph \\(H\\), then the sum of weights of edges in an MST of graph \\(G\\) equals \\(\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Proof) Approach 1:** Among the edges in an MST of \\(G\\), there are \\(N-c(G_k)\\) edges whose weight is not greater than \\(k\\). Therefore, there are \\(\\left(N-c(G_k)\\right)-\\left(N-c(G_{k-1})\\right)=c(G_{k-1})-c(G_k)\\) edges whose weight is exactly \\(k\\), so the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle \\sum_{k=1}^{W}k\\left(c(G_{k-1})-c(G_k)\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)\\right)-W\\cdot c(G_W)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Approach 2):** Among the edges in an MST of \\(G\\), there are \\(c(G_{k-1})-1\\) edges whose weight is not greater than \\(c(G_{k-1})-1\\). Thus, the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle\\sum_{k=1}^{W}\\left(c(G_{k-1})-1\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left(c(G_k)-1\\right)\\).\n\nFor each \\(k(0\\leq k\\lt W)\\), one can manage the number of connected components of \\(G_k\\) with a disjoint set union (DSU) to solve this problem in a total of \\(O(W(N+Q)\\alpha(N))\\). The complexity can be reduced to \\(O((WN+Q)\\alpha(N))\\).\n\n**Sample Code:**\n\n```python\nfrom atcoder.dsu import DSU\n\nN, Q = map(int, input().split())\nuf = [DSU(N + 1) for i in range(10)]\nans = 10 * N - 10\nfor i in range(N - 1 + Q):\n    a, b, c = map(int, input().split())\n    for j in range(c, 10):\n        if not uf[j].same(a, b):\n            ans -= 1\n            uf[j].merge(a, b)\n    if i >= N - 1:\n        print(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a permutation \\( P = (P_1, P_2, \\dots, P_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nA sequence of indices \\((i_1, i_2, \\dots, i_K)\\) of length \\( K \\) is called a **good index sequence** if it satisfies both of the following conditions:\n\n1. \\(1 \\leq i_1 < i_2 < \\dots < i_K \\leq N\\).\n2. The subsequence \\((P_{i_1}, P_{i_2}, \\dots, P_{i_K})\\) can be obtained by rearranging some consecutive \\( K \\) integers. Formally, there exists an integer \\( a \\) such that \\(\\{ P_{i_1}, P_{i_2}, \\dots, P_{i_K} \\} = \\{ a, a+1, \\dots, a+K-1 \\}\\).\n\nFind the minimum value of \\( i_K - i_1 \\) among all good index sequences. It can be shown that at least one good index sequence exists under the constraints of this problem.\n\n**Constraints**\n\n- \\(1 \\leq K \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq P_i \\leq N\\)\n- \\(P_i \\neq P_j\\) if \\(i \\neq j\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n**Output**\n\nPrint the minimum value of \\( i_K - i_1 \\) among all good index sequences.\n\n**Sample Input 1**\n\n```\n4 2\n2 3 1 4\n```\n\n**Sample Output 1**\n\n```\n1\n```\n\nThe good index sequences are \\((1, 2), (1, 3), (2, 4)\\). For example, \\((i_1, i_2) = (1, 3)\\) is a good index sequence because \\(1 \\leq i_1 < i_2 \\leq N\\) and \\((P_{i_1}, P_{i_2}) = (2, 1)\\) is a rearrangement of two consecutive integers 1, 2. Among these good index sequences, the smallest value of \\( i_K - i_1 \\) is for \\((1, 2)\\), which is \\(2-1=1\\).\n\n**Sample Input 2**\n\n```\n4 1\n2 3 1 4\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n\\(i_K - i_1 = i_1 - i_1 = 0\\) in all good index sequences.\n\n**Sample Input 3**\n\n```\n10 5\n10 1 6 8 7 2 5 9 3 4\n```\n\n**Sample Output 3**\n\n```\n5\n```\n\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 352\n\n# D - Permutation Subsequence Editorial, by en_translator\n\n# We will exhaustively enumerate the value \\(a\\) in the problem statement. For each \\(a=1,2,\\dots,N-K+1\\), \n# we will find the minimum \\(i_K-i_1\\) when choosing \\(i_1 < i_2 < \\dots < i_K\\) so that \n# \\(\\{P_{i_1},P_{i_2},\\dots,P_{i_K}\\}=\\{a,a+1,\\dots,a+K-1\\}\\).\n\n# Define \\(Q=(Q_1,Q_2,\\dots,Q_N)\\) by \\(Q_j=(\\) the value \\(i\\) such that \\(P_i=j)\\). \n# When \\(P\\) is a permutation of \\((1,2,\\dots,N)\\), so is \\(Q\\). \n# The objective can be rephrased as the difference between the maximum and minimum values among \\(Q_a,Q_{a+1},\\dots,Q_{a+K-1}\\).\n\n# Evaluate this value while iterating \\(a\\) in ascending order. The set \\(\\{Q_a,Q_{a+1},\\dots,Q_{a+K-1}\\}\\) changes by one element \n# as \\(a\\) increases by one. We need a data structure \\(D\\) that manages a set and supports:\n\n# - Insert one element into \\(D\\).\n# - Remove one element from \\(D\\).\n# - Retrieve the minimum and maximum element of \\(D\\).\n\n# A balanced binary search tree like `std::set` in C++ fulfills these requirements. For implementation using `std::set`,\n# see the sample code below. For other languages, refer to their documentation.\n\n# Sample code (Python3):\nfrom sortedcontainers import SortedSet\n\ndef main():\n    n, k = map(int, input().split())\n    q = [0] * n\n    for i in range(n):\n        p = int(input().strip())\n        p -= 1\n        q[p] = i\n    \n    st = SortedSet()\n    for i in range(k):\n        st.add(q[i])\n    \n    ans = st[-1] - st[0]\n    for i in range(k, n):\n        st.remove(q[i - k])\n        st.add(q[i])\n        ans = min(ans, st[-1] - st[0])\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 150 points\n\nProblem Statement:\nThere are \\(2N\\) people standing in a row, and the person at the \\(i\\)-th position from the left is wearing clothes of color \\(A_i\\). The clothes have \\(N\\) colors from \\(1\\) to \\(N\\), and exactly two people are wearing clothes of each color.\n\nFind how many of the integers \\(i=1,2,\\ldots,N\\) satisfy the following condition:\n- There is exactly one person between the two people wearing clothes of color \\(i\\).\n\nConstraints:\n- \\(2 \\leq N \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- Each integer from \\(1\\) through \\(N\\) appears exactly twice in \\(A\\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{2N}\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n3\n1 2 1 3 2 3\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation:\nThere are two values of \\(i\\) that satisfy the condition: \\(1\\) and \\(3\\).\nIn fact, the people wearing clothes of color \\(1\\) are at the 1st and 3rd positions from the left, with exactly one person in between.\n\nSample Input 2:\n```\n2\n1 1 2 2\n```\n\nSample Output 2:\n```\n0\n```\n\nExplanation:\nThere may be no \\(i\\) that satisfies the condition.\n\nSample Input 3:\n```\n4\n4 3 2 3 2 1 4 1\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nB - Couples Editorial by en_translator\n\nBy mathematically interpreting the problem statement, it turns out that it is asking to count \\(i\\) such that \\(A_i=A_{i+2}\\). Use for and if statements to check if each \\(i\\) satisfies the condition. Sample code (Python3):\n\n```python\nn = int(input())\na = [int(input()) for _ in range(n * 2)]\nres = 0\nfor i in range(n * 2 - 2):\n    if a[i] == a[i + 2]:\n        res += 1\nprint(res)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc355_f", "abc352_d", "abc359_b"]}, "abc333_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally.\n\nInitially, all vertices are painted white.\n\nTo efficiently visit all vertices of this tree, Alice has invented a magical gate. She uses one piece and one gate to travel according to the following procedure.\n\nFirst, she chooses a vertex and places both the piece and the gate on that vertex. Then, she repeatedly performs the following operations until all vertices are painted black.\n\nChoose one of the following actions:\n\n1. Paint the vertex where the piece is placed black.\n2. Choose a vertex adjacent to the vertex where the piece is placed and move the piece to that vertex. The cost of this action is 1.\n3. Move the piece to the vertex where the gate is placed.\n4. Move the gate to the vertex where the piece is placed.\n\nNote that only the second action incurs a cost.\n\nIt can be proved that it is possible to paint all vertices black in a finite number of operations. Find the minimum total cost required.\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- The given graph is a tree.\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nu_1 v_1\n\\vdots\nu_{N-1} v_{N-1}\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n4\n1 2\n1 3\n1 4\n```\n\n**Sample Output 1:**\n```\n3\n```\n\nHere is an example of Alice's procedure. Let \\((u, v)\\) denote the state where the piece is at vertex \\( u \\) and the gate is at vertex \\( v \\).\n\n- Place the piece and the gate at vertex 4.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 1.\n  - Vertex 4 is painted black.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 2 and move the piece to vertex 1.\n  - This costs 1.\n  - The state is now \\((1, 4)\\).\n\n- Perform action 1.\n  - Vertex 1 is painted black.\n\n- Perform action 4.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 2.\n  - This costs 1.\n  - The state is now \\((2, 1)\\).\n\n- Perform action 1.\n  - Vertex 2 is painted black.\n\n- Perform action 3.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 3.\n  - This costs 1.\n  - The state is now \\((3, 1)\\).\n\n- Perform action 1.\n  - Vertex 3 is painted black.\n  - All vertices are now painted black, so the procedure ends.\n\nThe total cost of performing action 2 is 3, and there is no procedure with a smaller cost.\n\n**Sample Input 2:**\n```\n10\n1 7\n7 10\n10 8\n8 3\n8 4\n10 9\n9 6\n9 5\n7 2\n```\n\n**Sample Output 2:**\n```\n10\n```\n\nSolution:\n\n```\nHere is the cleaned version:\n\nEditorial - AtCoder Regular Contest 179\n\nD - Portable Gate Editorial by evima\n\nWhen moving the gate, it can be considered to move simultaneously with the piece. We will perform operation 1 as needed and consider the following operations:\n\nOperation A: When the piece and the gate are on the same vertex, move both the piece and the gate to an adjacent vertex. Operation B: Move the piece to an adjacent vertex. Operation C: Move the piece to the vertex where the gate is located.\n\nOperations A and B each incur a cost of 1. Once operation B is performed, the gate remains in its position until operation C is performed. It's inefficient to move the piece to the gate using operation B, so we will not consider this.\n\nLet \\(v\\) be the initial position of the piece and gate. By performing operation C at the end, the process ends when the piece and the gate are on the same vertex. Label the vertices and edges the gate moves to with A, and the rest with B. The vertices and edges labeled A form a connected subgraph, or subtree A. Vertex \\(v\\) is included in subtree A. Edges labeled B with one endpoint as A are boundary edges.\n\nVertices and edges labeled B not connected to boundary edges form connected components. Each component is a tree connected to a vertex in subtree A by a boundary edge \\(e_i\\). Let them form subtree \\(B_i\\), connected to vertex \\(l_i\\) in A.\n\nKey points:\n\n1. In optimal operations, assume edges labeled A are not traversed by operation B. By rearranging operations, the cost does not increase:\n\n   - The piece and gate start from \\(v\\), visit all vertices in A using operation A, and return to \\(v\\). This is the journey in A.\n   - If \\(l_i\\) is visited during A's journey, it's interrupted. The piece starts from \\(l_i\\), visits all vertices in \\(B_i\\) using operation B, and returns to \\(l_i\\). This is the journey in \\(B_i\\). The gate stays at \\(l_i\\).\n\n2. Assume moving along boundary edge \\(e_i\\) occurs only once in B's journey. If done more than once, moving with the gate using operation A during the first move and returning does not increase the cost. In \\(B_i\\)'s journey, operation C is done once at the end.\n\n3. In the journeys of A and \\(B_i\\), the farthest vertex is visited last. If the distance from start to the farthest vertex is \\(d\\) and the number of edges is \\(m\\), the cost is \\(2m - d\\).\n\nThe total number of edges in subtrees is \\(N-1\\). Minimize cost by maximizing \\(d\\)'s total sum. Calculate for fixed \\(v\\) using tree DP. Maintain:\n\n- Maximum distance to vertex where \\(B_i\\)'s journey ends, assuming \\(u = l_i\\).\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex in \\(u\\)'s subtree.\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex not in \\(u\\)'s subtree.\n\nExtend to rerooting DP to examine all possible starting vertices. Time complexity \\(\\mathrm{O}(N)\\).\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nAn integer sequence where no two adjacent elements are the same is called a *good sequence*. You are given two good sequences of length \\( N \\): \\( A = (A_1, A_2, \\dots, A_N) \\) and \\( B = (B_1, B_2, \\dots, B_N) \\). Each element of \\( A \\) and \\( B \\) is between \\( 0 \\) and \\( M-1 \\), inclusive.\n\nYou can perform the following operations on \\( A \\) any number of times, possibly zero:\n\n- Choose an integer \\( i \\) between \\( 1 \\) and \\( N \\), inclusive, and perform one of the following:\n  - Set \\( A_i \\leftarrow (A_i + 1) \\bmod M \\).\n  - Set \\( A_i \\leftarrow (A_i - 1) \\bmod M \\). Here, \\((-1) \\bmod M = M - 1\\).\n\nHowever, you cannot perform an operation that makes \\( A \\) no longer a good sequence.\n\nDetermine if it is possible to make \\( A \\) equal to \\( B \\), and if it is possible, find the minimum number of operations required to do so.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq M \\leq 10^6 \\)\n- \\( 0 \\leq A_i, B_i < M \\) for \\( 1 \\leq i \\leq N \\)\n- \\( A_i \\ne A_{i+1} \\) for \\( 1 \\leq i \\leq N-1 \\)\n- \\( B_i \\ne B_{i+1} \\) for \\( 1 \\leq i \\leq N-1 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_1 A_2 \\dots A_N\nB_1 B_2 \\dots B_N\n```\n\n**Output**\n\nIf the goal is unachievable, print `-1`. Otherwise, print the minimum number of operations required as an integer.\n\n**Sample Input 1**\n\n```\n3 9\n2 0 1\n4 8 1\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\nYou can achieve the goal in three operations as follows:\n- Set \\( A_1 \\leftarrow (A_1 + 1) \\bmod M \\). Now \\( A = (3, 0, 1) \\).\n- Set \\( A_2 \\leftarrow (A_2 - 1) \\bmod M \\). Now \\( A = (3, 8, 1) \\).\n- Set \\( A_1 \\leftarrow (A_1 + 1) \\bmod M \\). Now \\( A = (4, 8, 1) \\).\n\nIt is impossible to achieve the goal in two or fewer operations, so the answer is 3. For example, you cannot set \\( A_2 \\leftarrow (A_2 + 1) \\bmod M \\) in the first operation, because it would make \\( A = (2, 1, 1) \\), which is not a good sequence.\n\n**Sample Input 2**\n\n```\n3 9\n1 8 2\n1 8 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n\\( A \\) and \\( B \\) might be equal from the beginning.\n\n**Sample Input 3**\n\n```\n24 182\n128 115 133 52 166 92 164 119 143 99 54 162 86 2 59 166 24 78 81 5 109 67 172 99\n136 103 136 28 16 52 2 85 134 64 123 74 64 28 85 161 19 74 14 110 125 104 180 75\n```\n\n**Sample Output 3**\n\n```\n811\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 182\n\nD - Increment Decrement Again Editorial\n\nSolution:\nWe first process the case \\(M=2\\). If \\(A\\) and \\(B\\) match, the answer is 0; otherwise, it is -1. From now on, we assume \\(M \\geq 3\\). Eliminate the operation of taking \\(\\bmod\\) and simply perform the operations as follows:\n\n1. Set \\(A_i \\leftarrow A_i + 1\\) (addition operation)\n2. Set \\(A_i \\leftarrow A_i - 1\\) (subtraction operation)\n\nMaintain the condition \\(|A_i - A_{i+1}| < M\\). If the final sequence is \\(C\\), it must satisfy \\(C_i \\bmod M = B_i\\) and \\(|C_i - C_{i+1}| < M\\). Ensure the magnitude relationship of \\(A_i\\) and \\(A_{i+1}\\) matches that of \\(C_i\\) and \\(C_{i+1}\\). Once $C_1$ is determined, other terms are also uniquely determined. For \\(M \\geq 3\\), it is always possible to make \\(A\\) match \\(C\\), and \\(\\sum_{i=1}^{N} |A_i - C_i|\\) will be the number of operations.\n\nFind the optimal way to determine \\(C_1\\). It can be seen that the possible \\(C\\) are limited to sequences where \\(C_1 = B_1\\), and adding multiples of \\(M\\). Consider minimizing \\(\\sum_{i=1}^{N} |x_i - a|\\), where \\(a\\) that minimizes this is the median of \\(x\\). It is sufficient to consider only the multiples of \\(M\\) around \\(a\\) that minimized the value. The computational complexity is \\(O(N \\log N)\\), but it can be reduced to \\(O(N)\\).\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nFor positive integers \\( x \\) and \\( y \\), define \\( f(x, y) \\) as follows:\n- Interpret the decimal representations of \\( x \\) and \\( y \\) as strings and concatenate them in this order to obtain a string \\( z \\). The value of \\( f(x, y) \\) is the value of \\( z \\) when interpreted as a decimal integer.\n\nFor example, \\( f(3, 14) = 314 \\) and \\( f(100, 1) = 1001 \\).\n\nYou are given a sequence of positive integers \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression modulo \\( 998244353 \\):\n\n\\[\n\\sum_{i=1}^{N-1} \\sum_{j=i+1}^N f(A_i, A_j)\n\\]\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n3\n3 14 15\n```\n\n**Sample Output 1:**\n```\n2044\n```\n\n- \\( f(A_1, A_2) = 314 \\)\n- \\( f(A_1, A_3) = 315 \\)\n- \\( f(A_2, A_3) = 1415 \\)\n\nThus, the answer is \\( f(A_1, A_2) + f(A_1, A_3) + f(A_2, A_3) = 2044 \\).\n\n**Sample Input 2:**\n```\n5\n1001 5 1000000 1000000000 100000\n```\n\n**Sample Output 2:**\n```\n625549048\n```\n\nBe sure to calculate the value modulo \\( 998244353 \\).\n\nSolution:\n\n        Here is the cleaned version of the text, focusing solely on the solution content:\n\n---\n\nWe reinterpret \\(f(x,y)\\) in a more useful form: \\(f(x,y) = 10^{\\mathrm{len}(y)} x + y\\), where \\(\\mathrm{len}(y)\\) is the length of \\(y\\) interpreted as a string. For each \\(i\\), let us find the contributions of \\(A_i\\) in the form of \\(f(*,A_i)\\) and of \\(f(A_i, *)\\). The former is easy; \\(f(*,A_i)\\) has the term \\(A_i\\) itself, so the contribution to the answer is \\((i-1)A_i\\). We consider the latter. The contribution is \\(\\sum_{k=1}^{10} d_k 10^{k} A_i\\), where \\(d_k\\) is the number of \\(j\\) such that \\(i < j\\) and \\(\\mathrm{len}(A_j) = k\\). \\(d_k\\) can be updated in a constant time for each \\(i\\), so the latter contribution can be computed in \\(\\mathrm{O}(\\log M)\\) for each \\(i\\), where \\(M\\) is the maximum value in \\(A\\). Therefore, the answer has been found in a total of \\(\\mathrm{O}(N\\log M)\\) time.\n\nSample code (Python 3):\n\n```python\nimport sys\nfrom atcoder.modint import ModInt998244353\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    d = [0] * 11\n    for v in a:\n        d[len(str(v))] += 1\n    res = ModInt998244353(0)\n    p10 = [ModInt998244353(1)] * 11\n    for i in range(1, 11):\n        p10[i] = p10[i - 1] * 10\n    for i in range(n):\n        res += ModInt998244353(a[i]) * i\n        d[len(str(a[i]))] -= 1\n        for j in range(1, 11):\n            res += p10[j] * a[i] * d[j]\n    print(res.val())\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n \n\n", "problem_ids": ["arc179_d", "arc182_d", "abc353_d"]}, "abc333_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers of length \\( N \\): \\( A = (A_1, A_2, \\ldots, A_N) \\) and \\( B = (B_1, B_2, \\ldots, B_N) \\).\n\nYou are given \\( Q \\) queries to process in order. The \\( i \\)-th query is explained below:\n\n- You are given positive integers \\( l_i, r_i, L_i, R_i \\). Print \"Yes\" if it is possible to rearrange the subsequence \\( (A_{l_i}, A_{l_i+1}, \\ldots, A_{r_i}) \\) to match the subsequence \\( (B_{L_i}, B_{L_i+1}, \\ldots, B_{R_i}) \\), and \"No\" otherwise.\n\n**Constraints**\n\n- \\( 1 \\leq N, Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq l_i \\leq r_i \\leq N \\)\n- \\( 1 \\leq L_i \\leq R_i \\leq N \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nl_1 r_1 L_1 R_1\nl_2 r_2 L_2 R_2\n\\vdots\nl_Q r_Q L_Q R_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n\n```\n5 4\n1 2 3 2 4\n2 3 1 4 2\n1 3 1 3\n1 2 3 5\n1 4 2 5\n1 5 1 5\n```\n\n**Sample Output 1**\n\n```\nYes\nNo\nNo\nYes\n```\n\n**Explanation**\n\n- For the 1st query, it is possible to rearrange \\( (1, 2, 3) \\) to match \\( (2, 3, 1) \\). Hence, we print \"Yes\".\n- For the 2nd query, it is impossible to rearrange \\( (1, 2) \\) in any way to match \\( (1, 4, 2) \\). Hence, we print \"No\".\n- For the 3rd query, it is impossible to rearrange \\( (1, 2, 3, 2) \\) in any way to match \\( (3, 1, 4, 2) \\). Hence, we print \"No\".\n- For the 4th query, it is possible to rearrange \\( (1, 2, 3, 2, 4) \\) to match \\( (2, 3, 1, 4, 2) \\). Hence, we print \"Yes\".\n\n**Sample Input 2**\n\n```\n4 4\n4 4 4 4\n4 4 4 4\n1 2 2 3\n3 3 1 1\n1 3 1 4\n1 4 2 3\n```\n\n**Sample Output 2**\n\n```\nYes\nYes\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe problem requires processing queries to check if \\(\\{A_l,A_{l+1},\\ldots,A_r\\}\\) coincides with \\(\\{B_L,B_{L+1},\\ldots,B_R\\}\\) as a multiset. A method for this involves using Zobrist Hashing to determine set equivalence. The hash function \\(H\\) should meet these requirements: \n\n1. Compute \\(H(S)\\) of a multiset quickly.\n2. If two multisets \\(S\\) and \\(T\\) are equal, then \\(H(S)=H(T)\\).\n3. If \\(S\\) and \\(T\\) are not equal, then \\(H(S)\\neq H(T)\\) with high probability.\n\nTo implement this, assign a hash value to each integer between \\(1\\) and \\(N\\), and define the hash function of \\(S\\) as the sum of its element hash values, modulo \\(P\\) (a large prime). Precalculate cumulative sums of hash values to compute the hash of subsequences in \\(O(1)\\) time. Hence, the total time complexity is \\(O(N+Q)\\).\n\n```python\nimport random\nmod = (1 << 61) - 1\n\nN, Q = map(int, input().split())\nA = list(map(lambda x: int(x) - 1, input().split()))\nB = list(map(lambda x: int(x) - 1, input().split()))\n\nhash = [random.randint(1, mod - 1) for i in range(N)]\ncumA = [0] * (N + 1)\ncumB = [0] * (N + 1)\nfor i in range(N):\n    cumA[i + 1] = (cumA[i] + hash[A[i]]) % mod\n    cumB[i + 1] = (cumB[i] + hash[B[i]]) % mod\n\nfor i in range(Q):\n    l, r, L, R = map(int, input().split())\n    if (cumA[r] - cumA[l - 1]) % mod == (cumB[R] - cumB[L - 1]) % mod:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nFor positive integers \\( x \\) and \\( y \\), define \\( f(x, y) \\) as the remainder of \\( (x + y) \\) divided by \\( 10^8 \\).\n\nYou are given a sequence of positive integers \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i, A_j) \\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 3 \\times 10^5 \\)\n- \\( 1 \\leq A_i < 10^8 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n3\n3 50000001 50000002\n```\n\n**Sample Output 1**\n\n```\n100000012\n```\n\n\\( f(A_1, A_2) = 50000004 \\), \\( f(A_1, A_3) = 50000005 \\), and \\( f(A_2, A_3) = 3 \\). Thus, the answer is \\( f(A_1, A_2) + f(A_1, A_3) + f(A_2, A_3) = 100000012 \\).\n\nNote that you are not asked to compute the remainder of the sum divided by \\( 10^8 \\).\n\n**Sample Input 2**\n\n```\n5\n1 3 99999999 99999994 1000000\n```\n\n**Sample Output 2**\n\n```\n303999988\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere is the clean version of the provided coding problem editorial:\n\n---\n\nWe reinterpret \\(f(x,y)\\) in a more useful form. In the constraints of this problem, \\(f(x,y)\\) is \\(x+y\\) if \\(x+y < 10^8\\) and \\(x+y-10^8\\) if \\(x+y\\geq 10^8\\). Thus, the answer can be found by evaluating \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N A_i + A_j\\), and then subtracting from it \\(10^8 \\times\\) the number of pairs \\((i,j)\\ (1\\leq i <j\\leq N)\\) such that \\(A_i + A_j\\) is greater than or equal to \\(10^8\\).\n\nRegarding \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N A_i + A_j\\), each term is added \\((N-1)\\) times, so it can be rewritten as \\((N-1)\\sum_{i=1}^{N} A_i\\), which can be found in \\(\\mathrm{O}(N)\\) time. Next, let us count the integer pairs \\((i,j)\\ (1\\leq i <j\\leq N)\\) such that \\(A_i + A_j\\) is greater than or equal to \\(10^8\\). The answer does not change by sorting \\(A\\) in ascending order, so we do so. Then, the minimum \\(j\\) with \\(A_i + A_j\\geq 10^8\\) monotonically decreases as \\(i\\) increases. Thus, the number of conforming integer pairs can be counted with the sliding window trick. Be careful not to count too much when \\(A_i = 5\\times 10^7\\).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). For each \\( k = 1, 2, \\dots, N \\), find the number, modulo \\( 998244353 \\), of (not necessarily contiguous) subsequences of \\( A \\) of length \\( k \\) that are arithmetic sequences. Two subsequences are distinguished if they are taken from different positions, even if they are equal as sequences.\n\n**What is a subsequence?**  \nA subsequence of a sequence \\( A \\) is a sequence obtained by deleting zero or more elements from \\( A \\) and arranging the remaining elements without changing the order.\n\n### Constraints\n- \\( 1 \\leq N \\leq 80 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n### Output\nPrint the answers for \\( k = 1, 2, \\dots, N \\) in this order, in a single line, separated by spaces.\n\n### Sample Input 1\n```\n5\n1 2 3 2 3\n```\n\n### Sample Output 1\n```\n5 10 3 0 0\n```\n\n- There are 5 subsequences of length 1, all of which are arithmetic sequences.\n- There are 10 subsequences of length 2, all of which are arithmetic sequences.\n- There are 3 subsequences of length 3 that are arithmetic sequences: \\((A_1, A_2, A_3)\\), \\((A_1, A_2, A_5)\\), and \\((A_1, A_4, A_5)\\).\n- There are no arithmetic subsequences of length 4 or more.\n\n### Sample Input 2\n```\n4\n1 2 3 4\n```\n\n### Sample Output 2\n```\n4 6 2 1\n```\n\n### Sample Input 3\n```\n1\n100\n```\n\n### Sample Output 3\n```\n1\n```\n\nSolution:\n\n```python\n# Editorial - E - Count Arithmetic Subsequences\n\n# Every length-1 subsequence is an arithmetic sequence; there are N of them. \n# For counting sequences of length 2 or greater, consider Dynamic Programming (DP) \n# with the states: dp[i][j][l] = the number of arithmetic sequences with \n# initial and second terms A_i and A_j, and length l (l >= 2).\n\n# O(N^4) Solution:\n# Iterate over A_i in descending order. For each fixed A_i, brute-force over the \n# second term A_j (i < j) and the length l. If l = 2, then (A_i, A_j) is an \n# arithmetic sequence of length 2, so dp[i][j][2] += 1. If l >= 3, search over \n# A_k (j < k). If A_k - A_j = A_j - A_i, sequence can be extended by prepending \n# A_i. Thus, dp[i][j][l] += dp[j][k][l-1]. This gives an O(N^4) complexity due to \n# O(N^3) states and O(N) transition cost, feasible under the problem constraints.\n\n# O(N^3) Solution:\n# Optimize by considering dp[i][j][l] = sequences with initial term A_i, length \n# l (l >= 2), and common difference d. Again iterate over A_i in descending order. \n# For fixed A_i, brute-force over A_j (i < j) and l, determining common difference \n# d = A_j - A_i. For l = 2, add 1 to dp[i][2][d]. For l >= 3, extend sequence by \n# adding dp[j][l-1][d] to dp[i][l][d]. As d can be large, use an associative array \n# for indices of d. \n\n# Note: Python automatically accommodates large integers and provides a dictionary \n# (map) data structure that can be used similarly to C++'s map. Here is a Python \n# illustration with comments for flexibility.\n```\n\n(Note: The above solution does not provide the full implementation of the algorithm since it abstractly discusses the logic, but translates the structure and logic described in the editorial to Python format.)\n \n\n", "problem_ids": ["abc367_f", "abc353_c", "abc362_e"]}, "abc333_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two strings, \\( S \\) and \\( T \\), consisting of lowercase English letters. Determine if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the following condition is satisfied. Here, \\( |S| \\) denotes the length of the string \\( S \\). Note that \\( w \\) must be less than \\( |S| \\).\n\n- If \\( S \\) is split at every \\( w \\) characters from the beginning, the concatenation of the \\( c \\)-th characters of the substrings of length at least \\( c \\) in order equals \\( T \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters.\n- \\( 1 \\leq |T| \\leq |S| \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nPrint `Yes` if there exists a pair of integers \\( c \\) and \\( w \\) such that \\( 1 \\leq c \\leq w < |S| \\) and the condition is satisfied, and `No` otherwise.\n\n**Sample Input 1**\n```\natcoder toe\n```\n\n**Sample Output 1**\n```\nYes\n```\n\nExplanation: If \\( S \\) is split at every two characters, it looks like this:\n```\nat\nco\nde\nr\n```\nThen, the concatenation of the 2nd characters of the substrings of length at least 2 is `toe`, which equals \\( T \\). Thus, print `Yes`.\n\n**Sample Input 2**\n```\nbeginner r\n```\n\n**Sample Output 2**\n```\nNo\n```\n\nExplanation: \\( w = |S| \\) is not allowed, and no pair of integers \\( 1 \\leq c \\leq w < |S| \\) satisfies the condition. Thus, print `No`.\n\n**Sample Input 3**\n```\nverticalreading agh\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        Below is a clean version of the text with only the relevant solution details:\n\nEnumerate all possible \\(c\\) and \\(w\\), and determine if a conforming pair \\(c,w\\) exists. One can construct a string for \\(c\\) and \\(w\\) using a for statement and concatenation of strings. For more details, please refer to the sample code.\n\nSample code (Python 3):\n\n```python\ndef main():\n    s = input().strip()\n    t = input().strip()\n    for w in range(1, len(s)):\n        for c in range(w):\n            now = \"\"\n            for i in range(c, len(s), w):\n                now += s[i]\n            if now == t:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\(N\\) and a prime \\(P\\).\n\nWe call a sequence of \\(N\\) intervals \\(([L_1,R_1],[L_2,R_2], \\ldots, [L_N,R_N])\\) **good** if and only if both of the following conditions are satisfied:\n\n1. \\(1 \\leq L_i \\leq R_i \\leq N\\) holds for all \\(1 \\leq i \\leq N\\).\n2. There exists a **unique** permutation \\(x = (x_1, x_2, \\ldots, x_N)\\) of \\((1, 2, \\ldots, N)\\) such that \\(L_i \\leq x_i \\leq R_i\\) holds for all \\(1 \\leq i \\leq N\\).\n\nCount the number of **good** sequences of intervals, modulo \\(P\\).\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 5000\\)\n- \\(10^9 < P < 1.01 \\times 10^9\\)\n- \\(P\\) is a prime number.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1005488041\n```\n\n**Sample Output 1**\n\n```\n6\n```\n\nThe following 6 sequences are good:\n1. \\(([1,1],[2,2])\\)\n2. \\(([1,2],[2,2])\\)\n3. \\(([1,1],[1,2])\\)\n4. \\(([2,2],[1,1])\\)\n5. \\(([2,2],[1,2])\\)\n6. \\(([1,2],[1,1])\\)\n\n**Sample Input 2**\n\n```\n5 1005488041\n```\n\n**Sample Output 2**\n\n```\n102960\n```\n\n**Sample Input 3**\n\n```\n100 1005488041\n```\n\n**Sample Output 3**\n\n```\n47599495\n```\n\n**Sample Input 4**\n\n```\n1000 1005488041\n```\n\n**Sample Output 4**\n\n```\n632708165\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Grand Contest 067\n\nD - Unique Matching Editorial by Kubic\n\nObviously, the intervals \\([l_i,r_i]\\) are distinct. So we can just let \\(x_i=i\\) and finally multiply the answer by \\(n!\\). Consider the uniqueness of bipartite graph matching. Fix a perfect matching; it is equivalent to not existing augmenting cycles. We claim that \\(l,r\\) is good if and only if there isn\u2019t \\(i,j\\) such that \\(1\\le i<j\\le n,r_i\\ge j,l_j\\le i\\). It means there is no cycle of length \\(2\\). Moreover, it can be proven that there will be no cycle under this condition. View \\(l\\) as constraints on \\(r\\), \\(\\forall l_i\\le j<i\\), then \\(r_j<i\\) must hold. Let \\(a_i=\\min\\limits_{l_j\\le i<j}j\\) (if \\(j\\) doesn\u2019t exist, then \\(a_i=n+1\\)). We need to calculate the sum of \\(\\prod (a_i-i)\\) for all possible sequences of \\(l\\). Fixing \\(a\\), we consider the number of \\(l\\) that generates \\(a\\). The main idea is to consider all maximums of \\(a\\) and divide \\(a\\) into several independent parts. Let \\(f_{i,j}\\) denote the answer when only considering \\([i,j]\\), requiring all \\(a_i\\dots a_j\\le j+1\\), with \\(l_{j+1}\\) determined (\\(l_{j+1}<i\\)). Let \\(g_{i,j}\\) denote the answer when \\(l_{j+1}\\) is undetermined (\\(l_{j+1}\\ge i\\)). Particularly, \\(f_{i+1,i}=g_{i+1,i}=1\\). The final answer is \\(f_{1,n}\\). Find the smallest \\(k\\) such that \\(i\\le k\\le j\\) and \\(a_k=j+1\\) (obviously \\(a_j=j+1\\), then such \\(k\\) exists). Now, \\([i,k-1]\\) and \\([k+1,j]\\) are independent subproblems. Thus, we have:\n\n```python\ndef f_i_j(i, j):\n    return sum((j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n\ndef g_i_j(i, j):\n    return sum((k - i + 1) * (j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n```\n\nFurthermore, \\(f_{i,j}\\) is only related to \\(j-i+1\\), thus it can be rewritten as follows:\n\n```python\ndef f_i(i):\n    return sum((i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n\ndef g_i(i):\n    return sum(j * (i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n```\n\nBrute force runs in \\(O(n^2)\\) and is allowed to pass. DC & FFT solution runs in \\(O(n\\log^2 n)\\).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( N \\) and a sequence of \\( M \\) positive integers \\( A = (A_1, A_2, \\ldots, A_M) \\). All elements of \\( A \\) are distinct integers between \\( 1 \\) and \\( N \\), inclusive.\n\nA permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) is called a *good permutation* if it satisfies the following condition for all integers \\( i \\) such that \\( 1 \\leq i \\leq M \\):\n\n- No contiguous subsequence of \\( P \\) is a permutation of \\( (1, 2, \\ldots, A_i) \\).\n\nDetermine whether a *good permutation* exists, and if it does, find the lexicographically smallest *good permutation*.\n\n**What is lexicographical order?**\n\nA sequence \\( S = (S_1, S_2, \\ldots, S_{|S|}) \\) is said to be *lexicographically smaller* than a sequence \\( T = (T_1, T_2, \\ldots, T_{|T|}) \\) if one of the following conditions holds:\n\n1. \\( |S| < |T| \\) and \\( (S_1, S_2, \\ldots, S_{|S|}) = (T_1, T_2, \\ldots, T_{|S|}) \\).\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|S|, |T|\\} \\) such that both of the following hold:\n   - \\( (S_1, S_2, \\ldots, S_{i-1}) = (T_1, T_2, \\ldots, T_{i-1}) \\).\n   - \\( S_i \\) is smaller than \\( T_i \\) (as a number).\n\n**Constraints**\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All elements of \\( A \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\cdots A_M\n```\n\n**Output**\n\nIf a *good permutation* does not exist, print `-1`.  \nIf it exists, print the lexicographically smallest *good permutation*, separated by spaces.\n\n**Sample Input 1**\n```\n4 1\n2\n```\n\n**Sample Output 1**\n```\n1 3 2 4\n```\n\nFor example, \\( (4, 2, 1, 3) \\) is not a *good permutation* because it contains \\( (2, 1) \\) as a contiguous subsequence. Other non-*good permutations* are \\( (1, 2, 3, 4) \\) and \\( (3, 4, 2, 1) \\). Some *good permutations* are \\( (4, 1, 3, 2) \\) and \\( (2, 3, 4, 1) \\). Among these, the lexicographically smallest one is \\( (1, 3, 2, 4) \\), so print it separated by spaces.\n\n**Sample Input 2**\n```\n5 3\n4 3 2\n```\n\n**Sample Output 2**\n```\n1 3 4 5 2\n```\n\nExamples of *good permutations* include \\( (3, 4, 1, 5, 2) \\), \\( (2, 4, 5, 3, 1) \\), and \\( (4, 1, 5, 2, 3) \\). Examples of non-*good permutations* include \\( (1, 2, 5, 3, 4) \\), \\( (2, 3, 4, 1, 5) \\), and \\( (5, 3, 1, 2, 4) \\).\n\n**Sample Input 3**\n```\n92 4\n16 7 1 67\n```\n\n**Sample Output 3**\n```\n-1\n```\n\nIf a *good permutation* does not exist, print `-1`.\n\n**Sample Input 4**\n```\n43 2\n43 2\n```\n\n**Sample Output 4**\n```\n-1\n```\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nA - Good Permutation 2 Editorial by evima\n\nIf \\(A\\) contains either \\(1\\) or \\(N\\), a good permutation does not exist. Conversely, if neither \\(1\\) nor \\(N\\) is included in \\(A\\), a good permutation does exist. Let\u2019s consider this case. For example, if we set \\(P = (1, N, N - 1, N - 2, \\dots, 3, 2)\\), the only contiguous subsequence of \\(P\\) that includes both \\(1\\) and \\(2\\) is \\(P\\) itself, making \\(P\\) a good permutation. \n\nSince a good permutation with \\(P_{1} = 1\\) exists, the lexicographically smallest good permutation will have \\(P_{1} = 1\\). For any integer \\(x\\), if there exists a contiguous subsequence of \\(P\\) that is a permutation of \\((1, 2, \\dots, x)\\), it must be \\((P_{1}, P_{2}, \\dots, P_{x})\\). We determine \\(P_{i}\\) for \\(i \\neq 1\\) in ascending order of \\(i\\). When deciding \\(P_{i}\\), assume that all of \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\) are at most \\(i\\). Let \\(a\\) be the number that is at most \\(i\\) and not included in \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\).\n\nWhen \\(i\\) is included in \\(A\\):\nTo make the permutation lexicographically smallest, set \\(P_{i} = i + 1\\). Since \\(P_{i}\\) is not greater than \\(i + 1\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) does not change.\n\nWhen \\(i\\) is not included in \\(A\\):\nSet \\(P_{i} = a\\). Since this number is not greater than \\(i\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) becomes \\(i + 1\\).\n\nThe time complexity is \\(O(N)\\).\n\n```python\n# input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nban = [0] * N\nfor a in A:\n    ban[a - 1] = 1\n\n# impossible\nif ban[0] or ban[N - 1]:\n    print(-1)\n    quit()\n\n# init\nP = [0] * N\nP[0] = 1\na = 2\n\n# calc\nfor i in range(1, N):\n    if ban[i] == 1:\n        P[i] = i + 2\n    else:\n        P[i] = a\n        a = i + 2\n\n# output\nprint(*P)\n```\n\nYou can also construct the permutation as follows: Initialize \\(P = (1, 2, \\dots, N)\\), and for \\(i = 2, 3, \\dots, N - 1\\), perform the following operation: If \\(i\\) is included in \\(A\\), do \\(\\text{swap}(P_{i}, P_{i + 1})\\).\n```\n \n\n", "problem_ids": ["abc360_b", "agc067_d", "arc178_a"]}, "abc333_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( N \\) and a sequence of \\( M \\) positive integers \\( A = (A_1, A_2, \\ldots, A_M) \\). All elements of \\( A \\) are distinct integers between \\( 1 \\) and \\( N \\), inclusive.\n\nA permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) is called a *good permutation* if it satisfies the following condition for all integers \\( i \\) such that \\( 1 \\leq i \\leq M \\):\n\n- No contiguous subsequence of \\( P \\) is a permutation of \\( (1, 2, \\ldots, A_i) \\).\n\nDetermine whether a *good permutation* exists, and if it does, find the lexicographically smallest *good permutation*.\n\n**What is lexicographical order?**\n\nA sequence \\( S = (S_1, S_2, \\ldots, S_{|S|}) \\) is said to be *lexicographically smaller* than a sequence \\( T = (T_1, T_2, \\ldots, T_{|T|}) \\) if one of the following conditions holds:\n\n1. \\( |S| < |T| \\) and \\( (S_1, S_2, \\ldots, S_{|S|}) = (T_1, T_2, \\ldots, T_{|S|}) \\).\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|S|, |T|\\} \\) such that both of the following hold:\n   - \\( (S_1, S_2, \\ldots, S_{i-1}) = (T_1, T_2, \\ldots, T_{i-1}) \\).\n   - \\( S_i \\) is smaller than \\( T_i \\) (as a number).\n\n**Constraints**\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All elements of \\( A \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\cdots A_M\n```\n\n**Output**\n\nIf a *good permutation* does not exist, print `-1`.  \nIf it exists, print the lexicographically smallest *good permutation*, separated by spaces.\n\n**Sample Input 1**\n```\n4 1\n2\n```\n\n**Sample Output 1**\n```\n1 3 2 4\n```\n\nFor example, \\( (4, 2, 1, 3) \\) is not a *good permutation* because it contains \\( (2, 1) \\) as a contiguous subsequence. Other non-*good permutations* are \\( (1, 2, 3, 4) \\) and \\( (3, 4, 2, 1) \\). Some *good permutations* are \\( (4, 1, 3, 2) \\) and \\( (2, 3, 4, 1) \\). Among these, the lexicographically smallest one is \\( (1, 3, 2, 4) \\), so print it separated by spaces.\n\n**Sample Input 2**\n```\n5 3\n4 3 2\n```\n\n**Sample Output 2**\n```\n1 3 4 5 2\n```\n\nExamples of *good permutations* include \\( (3, 4, 1, 5, 2) \\), \\( (2, 4, 5, 3, 1) \\), and \\( (4, 1, 5, 2, 3) \\). Examples of non-*good permutations* include \\( (1, 2, 5, 3, 4) \\), \\( (2, 3, 4, 1, 5) \\), and \\( (5, 3, 1, 2, 4) \\).\n\n**Sample Input 3**\n```\n92 4\n16 7 1 67\n```\n\n**Sample Output 3**\n```\n-1\n```\n\nIf a *good permutation* does not exist, print `-1`.\n\n**Sample Input 4**\n```\n43 2\n43 2\n```\n\n**Sample Output 4**\n```\n-1\n```\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nA - Good Permutation 2 Editorial by evima\n\nIf \\(A\\) contains either \\(1\\) or \\(N\\), a good permutation does not exist. Conversely, if neither \\(1\\) nor \\(N\\) is included in \\(A\\), a good permutation does exist. Let\u2019s consider this case. For example, if we set \\(P = (1, N, N - 1, N - 2, \\dots, 3, 2)\\), the only contiguous subsequence of \\(P\\) that includes both \\(1\\) and \\(2\\) is \\(P\\) itself, making \\(P\\) a good permutation. \n\nSince a good permutation with \\(P_{1} = 1\\) exists, the lexicographically smallest good permutation will have \\(P_{1} = 1\\). For any integer \\(x\\), if there exists a contiguous subsequence of \\(P\\) that is a permutation of \\((1, 2, \\dots, x)\\), it must be \\((P_{1}, P_{2}, \\dots, P_{x})\\). We determine \\(P_{i}\\) for \\(i \\neq 1\\) in ascending order of \\(i\\). When deciding \\(P_{i}\\), assume that all of \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\) are at most \\(i\\). Let \\(a\\) be the number that is at most \\(i\\) and not included in \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\).\n\nWhen \\(i\\) is included in \\(A\\):\nTo make the permutation lexicographically smallest, set \\(P_{i} = i + 1\\). Since \\(P_{i}\\) is not greater than \\(i + 1\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) does not change.\n\nWhen \\(i\\) is not included in \\(A\\):\nSet \\(P_{i} = a\\). Since this number is not greater than \\(i\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) becomes \\(i + 1\\).\n\nThe time complexity is \\(O(N)\\).\n\n```python\n# input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nban = [0] * N\nfor a in A:\n    ban[a - 1] = 1\n\n# impossible\nif ban[0] or ban[N - 1]:\n    print(-1)\n    quit()\n\n# init\nP = [0] * N\nP[0] = 1\na = 2\n\n# calc\nfor i in range(1, N):\n    if ban[i] == 1:\n        P[i] = i + 2\n    else:\n        P[i] = a\n        a = i + 2\n\n# output\nprint(*P)\n```\n\nYou can also construct the permutation as follows: Initialize \\(P = (1, 2, \\dots, N)\\), and for \\(i = 2, 3, \\dots, N - 1\\), perform the following operation: If \\(i\\) is included in \\(A\\), do \\(\\text{swap}(P_{i}, P_{i + 1})\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nAn integer sequence where no two adjacent elements are the same is called a *good sequence*. You are given two good sequences of length \\( N \\): \\( A = (A_1, A_2, \\dots, A_N) \\) and \\( B = (B_1, B_2, \\dots, B_N) \\). Each element of \\( A \\) and \\( B \\) is between \\( 0 \\) and \\( M-1 \\), inclusive.\n\nYou can perform the following operations on \\( A \\) any number of times, possibly zero:\n\n- Choose an integer \\( i \\) between \\( 1 \\) and \\( N \\), inclusive, and perform one of the following:\n  - Set \\( A_i \\leftarrow (A_i + 1) \\bmod M \\).\n  - Set \\( A_i \\leftarrow (A_i - 1) \\bmod M \\). Here, \\((-1) \\bmod M = M - 1\\).\n\nHowever, you cannot perform an operation that makes \\( A \\) no longer a good sequence.\n\nDetermine if it is possible to make \\( A \\) equal to \\( B \\), and if it is possible, find the minimum number of operations required to do so.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq M \\leq 10^6 \\)\n- \\( 0 \\leq A_i, B_i < M \\) for \\( 1 \\leq i \\leq N \\)\n- \\( A_i \\ne A_{i+1} \\) for \\( 1 \\leq i \\leq N-1 \\)\n- \\( B_i \\ne B_{i+1} \\) for \\( 1 \\leq i \\leq N-1 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_1 A_2 \\dots A_N\nB_1 B_2 \\dots B_N\n```\n\n**Output**\n\nIf the goal is unachievable, print `-1`. Otherwise, print the minimum number of operations required as an integer.\n\n**Sample Input 1**\n\n```\n3 9\n2 0 1\n4 8 1\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\nYou can achieve the goal in three operations as follows:\n- Set \\( A_1 \\leftarrow (A_1 + 1) \\bmod M \\). Now \\( A = (3, 0, 1) \\).\n- Set \\( A_2 \\leftarrow (A_2 - 1) \\bmod M \\). Now \\( A = (3, 8, 1) \\).\n- Set \\( A_1 \\leftarrow (A_1 + 1) \\bmod M \\). Now \\( A = (4, 8, 1) \\).\n\nIt is impossible to achieve the goal in two or fewer operations, so the answer is 3. For example, you cannot set \\( A_2 \\leftarrow (A_2 + 1) \\bmod M \\) in the first operation, because it would make \\( A = (2, 1, 1) \\), which is not a good sequence.\n\n**Sample Input 2**\n\n```\n3 9\n1 8 2\n1 8 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n\\( A \\) and \\( B \\) might be equal from the beginning.\n\n**Sample Input 3**\n\n```\n24 182\n128 115 133 52 166 92 164 119 143 99 54 162 86 2 59 166 24 78 81 5 109 67 172 99\n136 103 136 28 16 52 2 85 134 64 123 74 64 28 85 161 19 74 14 110 125 104 180 75\n```\n\n**Sample Output 3**\n\n```\n811\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 182\n\nD - Increment Decrement Again Editorial\n\nSolution:\nWe first process the case \\(M=2\\). If \\(A\\) and \\(B\\) match, the answer is 0; otherwise, it is -1. From now on, we assume \\(M \\geq 3\\). Eliminate the operation of taking \\(\\bmod\\) and simply perform the operations as follows:\n\n1. Set \\(A_i \\leftarrow A_i + 1\\) (addition operation)\n2. Set \\(A_i \\leftarrow A_i - 1\\) (subtraction operation)\n\nMaintain the condition \\(|A_i - A_{i+1}| < M\\). If the final sequence is \\(C\\), it must satisfy \\(C_i \\bmod M = B_i\\) and \\(|C_i - C_{i+1}| < M\\). Ensure the magnitude relationship of \\(A_i\\) and \\(A_{i+1}\\) matches that of \\(C_i\\) and \\(C_{i+1}\\). Once $C_1$ is determined, other terms are also uniquely determined. For \\(M \\geq 3\\), it is always possible to make \\(A\\) match \\(C\\), and \\(\\sum_{i=1}^{N} |A_i - C_i|\\) will be the number of operations.\n\nFind the optimal way to determine \\(C_1\\). It can be seen that the possible \\(C\\) are limited to sequences where \\(C_1 = B_1\\), and adding multiples of \\(M\\). Consider minimizing \\(\\sum_{i=1}^{N} |x_i - a|\\), where \\(a\\) that minimizes this is the median of \\(x\\). It is sufficient to consider only the multiples of \\(M\\) around \\(a\\) that minimized the value. The computational complexity is \\(O(N \\log N)\\), but it can be reduced to \\(O(N)\\).\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given two integers \\( A \\) and \\( B \\).\n\nHow many integers \\( x \\) satisfy the following condition?\n\n**Condition:** It is possible to arrange the three integers \\( A \\), \\( B \\), and \\( x \\) in some order to form an arithmetic sequence.\n\nA sequence of three integers \\( p \\), \\( q \\), and \\( r \\) in this order is an arithmetic sequence if and only if \\( q-p \\) is equal to \\( r-q \\).\n\n**Constraints**\n\n- \\( 1 \\leq A, B \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B\n```\n\n**Output**\n\nPrint the number of integers \\( x \\) that satisfy the condition in the problem statement. It can be proved that the answer is finite.\n\n**Sample Input 1**\n```\n5 7\n```\n\n**Sample Output 1**\n```\n3\n```\n\nThe integers \\( x = 3, 6, 9 \\) all satisfy the condition as follows:\n- When \\( x = 3 \\), for example, arranging \\( x, A, B \\) forms the arithmetic sequence \\( 3, 5, 7 \\).\n- When \\( x = 6 \\), for example, arranging \\( B, x, A \\) forms the arithmetic sequence \\( 7, 6, 5 \\).\n- When \\( x = 9 \\), for example, arranging \\( A, B, x \\) forms the arithmetic sequence \\( 5, 7, 9 \\).\n\nConversely, there are no other values of \\( x \\) that satisfy the condition. Therefore, the answer is \\( 3 \\).\n\n**Sample Input 2**\n```\n6 1\n```\n\n**Sample Output 2**\n```\n2\n```\n\nOnly \\( x = -4 \\) and \\( 11 \\) satisfy the condition.\n\n**Sample Input 3**\n```\n3 3\n```\n\n**Sample Output 3**\n```\n1\n```\n\nOnly \\( x = 3 \\) satisfies the condition.\n\nSolution:\n\nHere is the cleaned-up version of the editorial text, focusing only on the solution:\n\n---\n\nFor simplicity, we assume \\(A \\leq B\\). If not, we may swap \\(A\\) and \\(B\\). The condition for arranging \\(A, B, x\\) in an arithmetic sequence is: Among \\(A, B\\), and \\(x\\), the difference between the first and second largest values is equal to the difference between the second and third largest values.\n\nConsider two cases: \n\n1. **If \\(A = B\\):** The condition is satisfied if and only if \\(x = A = B\\), thus the answer is \\(1\\).\n\n2. **If \\(A < B\\):** There are three patterns for the order of \\(A, B\\), and \\(x\\): \n   - \\(x < A < B\\): The condition is represented as \\(B-A = A-x\\), so \\(x = 2A-B\\).\n   - \\(A < B < x\\): The condition is represented as \\(x = 2B-A\\).\n   - \\(A < x < B\\): The condition is represented as \\(B-x = x-A\\). Solving it yields \\(x = \\frac{A+B}{2}\\), so \\(x\\) must be an integer, existing only if \\(A+B\\) is even.\n\nSummary of solutions:\n- \\(1\\) if \\(A = B\\).\n- \\(3\\) if \\(A \\neq B\\) and \\(A + B\\) is even.\n- \\(2\\) if \\(A \\neq B\\) and \\(A + B\\) is odd.\n\nSample Code in Python:\n\n```python\na, b = map(int, input().split())\nif a == b:\n    print(1)\nelif (a + b) % 2 == 0:\n    print(3)\nelse:\n    print(2)\n```\n\n \n\n", "problem_ids": ["arc178_a", "arc182_d", "abc369_a"]}, "abc334_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) balls on a two-dimensional plane, numbered from \\( 1 \\) to \\( N \\). Ball \\( i \\) is located at point \\( (X_i, Y_i) \\). Here, \\( X = (X_1, X_2, \\dots, X_N) \\) and \\( Y = (Y_1, Y_2, \\dots, Y_N) \\) are permutations of \\( (1, 2, \\dots, N) \\).\n\nYou can perform the following operation any number of times:\n\n- Choose one of the remaining balls, say ball \\( k \\). Then, for each remaining ball \\( i \\), if either \\( X_i < X_k \\) and \\( Y_i < Y_k \\), or \\( X_i > X_k \\) and \\( Y_i > Y_k \\) holds, remove ball \\( i \\).\n\nFind the number of possible sets of balls remaining after performing operations, modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 300 \\)\n- \\( X \\) and \\( Y \\) are permutations of \\( (1, 2, \\dots, N) \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nX_1 Y_1\nX_2 Y_2\n...\nX_N Y_N\n```\n\n**Output**\n\nPrint the answer in one line.\n\n**Sample Input 1**\n\n```\n3\n1 3\n2 1\n3 2\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\nThe possible sets of balls remaining after operations are \\(\\{1, 2, 3\\}\\), \\(\\{1, 3\\}\\), and \\(\\{1, 2\\}\\).\n\n**Sample Input 2**\n\n```\n4\n4 2\n2 1\n3 3\n1 4\n```\n\n**Sample Output 2**\n\n```\n3\n```\n\nSolution:\n\nHere is the cleaned version of the editorial:\n\n---\n\nHere, we assume that \\(X = (1, 2, \\dots, N)\\). First, let\u2019s consider the operations. Since the order in which the operations are performed does not affect the possibility of operations or the set of remaining points, only the set of points on which we perform operations is important. The condition under which we can perform operations on all points in a set \\(s\\) is as follows:\n\nLet \\(s' = (s'_1, s'_2, \\dots, s'_m)\\) be the sequence obtained by sorting the points in \\(s\\) in ascending order; then it must satisfy \\(Y_{s'_1} > Y_{s'_2} > \\dots > Y_{s'_m}\\).\n\nThe condition under which a point \\(i\\) remains when we perform operations on all points belonging to set \\(s\\) is:\n\nLet \\(t = (t_1, t_2, \\dots, t_m)\\) be the sequence obtained by sorting the points in \\(s \\cup \\{i\\}\\) in ascending order; then it must satisfy \\(Y_{t_1} > Y_{t_2} > \\dots > Y_{t_m}\\).\n\nSince it is difficult to find the answer directly, we count the maximal sets of points on which we perform operations. Specifically, we count the sets \\(s\\) satisfying the following:\n\n1. It is possible to perform operations on all points in \\(s\\).\n2. After performing operations on all points in \\(s\\), performing an operation on any other point will necessarily remove at least one point.\n\nThere is a one-to-one correspondence between maximal sets of operation points and the sets of points that can possibly remain after operations. The maximal sets of operation points can be counted using DP with cumulative sums, with a worst-case time complexity of \\(O(N^3)\\). With some ingenuity, this can be improved further.\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\nYou are given positive integers \\( N \\), \\( M \\), and \\( K \\), and a sequence of \\( M \\) non-negative integers \\( A = (A_0, A_1, \\ldots, A_{M-1}) \\). Here, \\( 2^{N-1} \\leq K < 2^N \\).\n\nIn the input, \\( K \\) is given as an \\( N \\)-digit number in binary notation, while the other integers are given in decimal notation.\n\nAdditionally, \\( A \\) is not given directly in the input. Instead, for each \\( i = 0, 1, \\ldots, M-1 \\), you are given a sequence of \\( L_i \\) integers \\( X_i = (X_{i,0}, X_{i,1}, \\ldots, X_{i,L_i-1}) \\) such that \\( A_i = \\sum_{j=0}^{L_i-1} 2^{X_{i,j}} \\). Here, \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\).\n\nFind the inversion number, modulo \\( 998244353 \\), of the sequence \\( B = (B_0, B_1, \\ldots, B_{MK-1}) \\) defined as follows:\n\n- For any integer \\( a \\) such that \\( 0 \\leq a < K \\) and any integer \\( b \\) such that \\( 0 \\leq b < M \\), the following holds:\n  - \\( B_{aM+b} \\) is equal to the remainder when \\( \\text{popcount}(a \\land A_b) \\) is divided by \\( 2 \\).\n\n**What is \\(\\operatorname{AND}\\)?**\nThe bitwise \\(\\operatorname{AND}\\) of integers \\( A \\) and \\( B \\), denoted as \\( A \\land B \\), is defined as follows:\n- In the binary representation of \\( A \\land B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) place is \\( 1 \\) if and only if the digits at the \\( 2^k \\) place in the binary representations of both \\( A \\) and \\( B \\) are \\( 1 \\); otherwise, it is \\( 0 \\).\n\nFor example, \\( 3 \\land 5 = 1 \\) (in binary: \\( 011 \\land 101 = 001 \\)).\n\nGenerally, the bitwise \\(\\operatorname{AND}\\) of \\( k \\) integers \\( p_1, p_2, p_3, \\ldots, p_k \\) is defined as \\(((\\ldots ((p_1 \\land p_2) \\land p_3) \\land \\ldots \\land p_k)\\), and it can be proved that this is independent of the order of \\( p_1, p_2, p_3, \\ldots, p_k \\).\n\n**What is \\(\\operatorname{popcount}\\)?**\nFor a non-negative integer \\( x \\), \\(\\operatorname{popcount}(x)\\) is the number of \\( 1 \\)s in the binary representation of \\( x \\). More precisely, for a non-negative integer \\( x \\) such that \\( x = \\sum_{i=0}^{\\infty} b_i 2^i \\) (\\( b_i \\in \\{0, 1\\} \\)), it holds that \\(\\operatorname{popcount}(x) = \\sum_{i=0}^{\\infty} b_i \\).\n\nFor example, \\( 13 \\) is \\( 1101 \\) in binary, so \\(\\operatorname{popcount}(13) = 3\\).\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2^{N-1} \\leq K < 2^N \\)\n- \\( 0 \\leq L_i \\leq N \\)\n- \\(\\sum L_i \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\)\n- All input values are integers.\n- \\( K \\) is given in binary notation.\n- All numbers except \\( K \\) are given in decimal notation.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M\nK\nL_0 X_{0,0} X_{0,1} \\cdots X_{0,L_0-1}\nL_1 X_{1,0} X_{1,1} \\cdots X_{1,L_1-1}\n\\vdots\nL_{M-1} X_{M-1,0} X_{M-1,1} \\cdots X_{M-1,L_{M-1}-1}\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n2 4\n11\n1 0\n2 0 1\n0\n1 1\n```\n\n**Sample Output 1**\n```\n9\n```\n\n**Explanation of Sample 1**\n\\( A = (1, 3, 0, 2) \\), \\( B = (0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1) \\).\n\n**Sample Input 2**\n```\n3 3\n101\n2 1 2\n2 0 1\n1 0\n```\n\n**Sample Output 2**\n```\n23\n```\n\n**Explanation of Sample 2**\n\\( A = (6, 3, 1) \\), \\( B = (0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0) \\).\n\n**Sample Input 3**\n```\n16 7\n1101010000100110\n11 0 1 2 3 7 10 11 12 13 14 15\n7 4 6 8 10 11 12 13\n6 0 1 6 8 10 12\n8 0 3 5 6 10 11 12 13\n10 0 1 2 3 4 5 6 8 12 13\n9 3 4 5 6 8 9 11 14 15\n8 0 4 7 9 10 11 13 14\n```\n\n**Sample Output 3**\n```\n97754354\n```\n\n**Sample Input 4**\n```\n92 4\n10101100101111111111011101111111101011001011111110011110111111101111111110100111100010111011\n23 1 2 5 13 14 20 28 32 34 39 52 56 59 60 62 64 67 69 71 78 84 87 91\n20 15 17 22 28 36 40 43 47 52 53 57 67 72 77 78 81 87 89 90 91\n23 7 8 9 10 11 13 16 19 22 23 30 33 42 49 51 52 58 64 71 73 76 79 83\n22 1 13 19 26 27 28 29 35 39 40 41 46 55 60 62 64 67 74 79 82 89 90\n```\n\n**Sample Output 4**\n```\n291412708\n```\n\nYou are required to find the number modulo \\( 998244353 \\).\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 178\n\nF - Long Sequence Inversion Editorial by evima\n\nThis explanation generally uses \\(0\\)-based indexing. For the inversion number of a binary sequence \\(Y = (Y_{0}, Y_{1}, \\dots, Y_{|Y|-1})\\), the following holds:\n\nIf there are \\(P\\) indices \\(i\\) where \\(Y_{i} = 0\\), and the sum of such indices is \\(Q\\), then the inversion number of \\(Y\\) is \\(Q - \\frac{P(P-1)}{2}\\).\n\nTherefore, we need to find the number of zeros in \\(B\\) and the sum of their indices. Here, we define a sequence of sequences \\(C = (C_{0}, C_{1}, \\dots, C_{M-1})\\) as follows:\n\n\\(C_{i} = (C_{i,0}, C_{i,1}, \\dots, C_{i,K-1})\\) is a sequence of length \\(K\\), where the \\(j\\)-th element \\(C_{i,j}\\) is equal to \\(\\operatorname{popcount}(j \\operatorname{AND} A_{i})\\).\n\nLet \\(P_{i}\\) be the number of \\(0\\)s in \\(C_{i}\\), and \\(Q_{i}\\) be the sum of indices where \\(C_{i}\\) is \\(0\\). The inversion number of \\(B\\) can be expressed as:\n\\[\n\\text{inversion}(B) = \\sum_{i=0}^{M-1}(Q_{i}M + iP_{i}) - \\frac{(\\sum P)(\\sum P - 1)}{2}\n\\]\nThus, if we know \\(P_{i}\\) and \\(Q_{i}\\) for each integer \\(i\\) from 0 to \\(M-1\\), we can determine the answer. To find \\(P_{i}\\) and \\(Q_{i}\\), we need the difference between the number of \\(0\\)s and \\(1\\)s in \\(C_{i}\\), and the difference between the sum of indices where \\(C_{i}\\) is \\(0\\) and where it is \\(1\\).\n\nHere, we find an integer sequence \\(Z\\) such that \\(K = \\sum 2^{Z_{j}}\\) and \\(0 \\leq Z_{0} < Z_{1} < \\cdots < Z_{L-1} = N-1\\). Using \\(Z\\), we decompose the interval \\([0, K)\\) and consider the contribution of each segment to \\(P_{i}\\) and \\(Q_{i}\\).\n\nFor the numbers of \\(0\\)s and \\(1\\)s in the contiguous subsequence \\((C_{i, K-2^{Z_{0}}}, C_{i, K-2^{Z_{0}+1}}, \\dots, C_{i, K-1})\\) in \\(C_{i}\\):\n- If \\((A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are equal to \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (K - 2^{Z_{0}}))\\).\n\nFor the sums of indices where \\(C_{i}\\) is \\(0\\) or \\(1\\):\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) \\geq 2\\), the difference is 0.\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are \\(0\\) or \\(1\\).\n\nThis gives us the contribution of the interval \\([K - 2^{Z_{0}}, K)\\) to \\(P_{i}\\) and \\(Q_{i}\\). We can similarly find the contributions of other intervals. By dividing the intervals appropriately and performing precomputations such as cumulative sums, we can compute \\(P_{i}\\) and \\(Q_{i}\\) in \\(O(L_{i})\\) time. The answer to this problem can be obtained in linear time relative to the input.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree with \\( N \\) vertices. The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally. Additionally, you are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\).\n\nDefine \\( f(i, j) \\) as follows:\n\n- If \\( A_i = A_j \\), then \\( f(i, j) \\) is the minimum number of edges needed to traverse from vertex \\( i \\) to vertex \\( j \\).\n- If \\( A_i \\neq A_j \\), then \\( f(i, j) = 0 \\).\n\nCalculate the value of the following expression:\n\n\\[\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(i,j)\n\\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- The input graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nu_1 v_1\n...\nu_{N-1} v_{N-1}\nA_1 A_2 ... A_N\n```\n\n**Output**\n\nPrint the computed answer.\n\n**Sample Input 1**\n\n```\n4\n3 4\n4 2\n1 2\n2 1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nExplanation: \\( f(1,4)=2, f(2,3)=2 \\). For all other \\( i, j \\) \\((1 \\leq i < j \\leq N)\\), we have \\( f(i,j)=0 \\), so the answer is \\( 2+2=4 \\).\n\n**Sample Input 2**\n\n```\n8\n8 6\n3 8\n1 4\n7 8\n4 5\n3 4\n8 2\n1 2 2 2 3 1 1 3\n```\n\n**Sample Output 2**\n\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nApplying the centroid decomposition, it is sufficient to find the answer for paths passing through the root. We consider two cases depending on whether the endpoint of the path is the root or not. If it is root, one can naively perform BFS (Breadth-First Search). Otherwise, for each vertex \\(v\\), count how many times the path between vertex \\(v\\) and the root contributes to the answer. Let \\(c_1,\\ldots,c_k\\) be the children of the root, and suppose that vertex \\(v\\) is contained in the subtree \\(c_i\\). Then, the number of times the path between vertex \\(v\\) and the root contributes to the answer is found as (the number of vertices \\(u\\) contained in the current tree such that \\(A_v = A_u\\)) - (the number of vertices \\(u\\) in the subtree \\(c_i\\) such that \\(A_v = A_u\\)). The values required can all be found using a DFS (Depth-First Search), so the problem has been solved.\n[END TEXT]\n \n\n", "problem_ids": ["arc184_d", "arc178_f", "abc359_g"]}, "abc334_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi can swim in \\( N \\) different styles. When he swims in the \\( i \\)-th style, he consumes \\( A_i \\) stamina per second and advances \\( B_i \\) meters per second. \n\nYou need to answer \\( Q \\) queries. The \\( i \\)-th query is as follows: determine if it is possible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\). If it is possible, find the minimum number of seconds required.\n\nTakahashi can freely combine different swimming styles, and the time to switch styles is negligible. Specifically, he can swim using the following steps:\n- Choose a positive integer \\( m \\), a sequence of positive real numbers \\( t = (t_1, t_2, \\dots, t_m) \\) of length \\( m \\), and a sequence of integers \\( x = (x_1, x_2, \\dots, x_m) \\) of length \\( m \\) where each element is between \\( 1 \\) and \\( N \\), inclusive.\n- Then, swim in the \\( x_i \\)-th style for \\( t_i \\) seconds in the order \\( i = 1, 2, \\dots, m \\).\n\n**Constraints:**\n- All input values are integers.\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C_i, D_i \\leq 10^9 \\)\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\nQ\nC_1 D_1\nC_2 D_2\n...\nC_Q D_Q\n```\n\n**Output:**\nPrint \\( Q \\) lines in total. For the \\( i \\)-th query, print the answer in the \\( i \\)-th line as follows:\n- If it is impossible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\), print \\(-1\\).\n- Otherwise, print the minimum required time. The output is considered correct if the absolute or relative error between the printed value and the true answer is at most \\( 10^{-9} \\).\n\n**Sample Input:**\n```\n4\n1 2\n2 3\n3 3\n4 4\n5\n4 7\n7 7\n49 100\n1000 500\n4 5\n```\n\n**Sample Output:**\n```\n3.000000000000000000\n1.750000000000000000\n-1\n125.000000000000000000\n1.500000000000000000\n```\n\nIn this input, Takahashi can swim in the following four styles:\n- Consumes 1 stamina and advances 2 meters per second.\n- Consumes 2 stamina and advances 3 meters per second.\n- Consumes 3 stamina and advances 3 meters per second.\n- Consumes 4 stamina and advances 4 meters per second.\n\nThis input contains five queries:\n- For the first query, \\( C_1 = 4, D_1 = 7 \\). Choose \\( t = (1,2) \\) and \\( x = (2,1) \\). Takahashi swims as follows:\n  - In the first 1 second, he consumes 2 stamina and advances 3 meters.\n  - In the next 2 seconds, he consumes 2 stamina and advances 4 meters.\n  - In total, he consumes 4 stamina and advances 7 meters. The required time is 3 seconds, which is the minimum.\n- For the second query, \\( C_2 = 7, D_2 = 7 \\). Choose \\( t = (7/4) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 7/4 seconds, he consumes 7 stamina and advances 7 meters.\n  - In total, he consumes 7 stamina and advances 7 meters. The required time is 7/4 seconds, which is the minimum.\n- For the third query, \\( C_3 = 49, D_3 = 100 \\). No matter how Takahashi swims, it is not possible to advance 100 meters while keeping the total stamina consumption at most 49.\n- For the fourth query, \\( C_4 = 1000, D_4 = 500 \\). Choose \\( t = (125) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 125 seconds, he consumes 500 stamina and advances 500 meters.\n  - In total, he consumes 500 stamina and advances 500 meters. The required time is 125 seconds, which is the minimum.\n- For the fifth query, \\( C_5 = 4, D_5 = 5 \\). Choose \\( t = (1/2,1) \\) and \\( x = (4,2) \\). Takahashi swims as follows:\n  - In the first 1/2 seconds, he consumes 2 stamina and advances 2 meters.\n  - In the next 1 second, he consumes 2 stamina and advances 3 meters.\n  - In total, he consumes 4 stamina and advances 5 meters. The required time is 3/2 seconds, which is the minimum.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 356\n\nConsider the case where Takahashi can swim using two styles: consume stamina of \\(A_1\\) to advance \\(B_1\\) meters per second or consume stamina of \\(A_2\\) to advance \\(B_2\\) meters per second. He can combine these styles to swim by consuming stamina of \\(tA_1+(1-t)A_2\\) to advance \\(tB_1+(1-t)B_2\\) meters per second. This corresponds to points on the segment connecting \\((B_1,A_1)\\) and \\((B_2,A_2)\\) in the \\(xy\\)-plane.\n\nIf there are \\(N\\) points \\((B_i,A_i)\\), he can swim for any point inside or on the convex hull's boundary, but not outside it. Plotting the styles on the \\(xy\\)-plane assists in this determination. The most time-efficient point has the maximum \\(B_i\\), and the most stamina-efficient point has the minimum \\(A_i/B_i\\). If he can't swim \\(D_i\\) meters using the stamina-efficient point, the answer is -1.\n\nTo swim \\(D_i\\) meters within stamina \\(C_i\\), locate the rightmost point in the intersection of the convex hull's circumference and a line passing through \\((0,0)\\) and \\((D_i,C_i)\\). This represents viable swimming styles under the stamina constraint. He should trace the convex hull from the stamina-efficient point to the time-efficient point counterclockwise. Using binary search helps identify which segment it lies on and then pinpoints \\(P_{opt}\\)'s exact coordinates.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\). Additionally, you are given an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n1. Choose integers \\( l \\) and \\( r \\) such that \\( 1 \\leq l < r \\leq N \\).\n   - The pair \\((l, r)\\) must satisfy the following conditions:\n     - \\( K \\leq r - l \\).\n     - \\( P_l > P_r \\) at the time of the operation.\n     - The pair \\((l, r)\\) has never been chosen before.\n\n2. Swap the values of \\( P_l \\) and \\( P_r \\).\n\nYour goal is to maximize the number of operations. Find one way to achieve this.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( 1 \\leq K \\leq N - 1 \\)\n- \\( (P_1, P_2, \\ldots, P_N) \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\ldots P_N\n```\n\n### Output\n\nPrint the answer in the following format:\n```\nm\nl_1 r_1\nl_2 r_2\n\\vdots\nl_m r_m\n```\n\nHere, \\( m \\) is the maximum number of operations, and \\( l_i \\) and \\( r_i \\) are the values of \\( l \\) and \\( r \\) chosen in the \\( i \\)-th operation, respectively. If multiple solutions exist, you can print any of them.\n\n### Sample Input 1\n```\n3 1\n3 2 1\n```\n\n### Sample Output 1\n```\n3\n2 3\n1 3\n1 2\n```\n\nIn this example, the maximum number of operations is \\( 3 \\). The operations in the sample output proceed as follows:\n\n1. Choose \\((l, r) = (2, 3)\\). We have \\( 1 \\leq 3 - 2 \\) and \\( P_2 > P_3 \\), and \\((2, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_2 \\) and \\( P_3 \\), resulting in \\( P = (3, 1, 2) \\).\n\n2. Choose \\((l, r) = (1, 3)\\). We have \\( 1 \\leq 3 - 1 \\) and \\( P_1 > P_3 \\), and \\((1, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_3 \\), resulting in \\( P = (2, 1, 3) \\).\n\n3. Choose \\((l, r) = (1, 2)\\). We have \\( 1 \\leq 2 - 1 \\) and \\( P_1 > P_2 \\), and \\((1, 2)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_2 \\), resulting in \\( P = (1, 2, 3) \\).\n\nSolution:\n\n[BEGIN TEXT]\nLet\u2019s consider the inverse permutation \\(Q\\) of \\(P\\). In other words, \\(Q_{P_i} = i\\). Rephrasing the operation with \\(Q\\) as the main focus, it becomes: Choose \\(i, j\\) such that \\(1 \\leq i < j \\leq N\\) and \\(Q_i - Q_j \\geq K\\). Here, the pair \\((Q_i, Q_j)\\) must not have been chosen before. Swap \\(Q_i\\) and \\(Q_j\\).\n\nWe define the pseudo-inversion count of \\(Q\\) as the number of integer pairs \\((i, j)\\) such that \\(i < j\\) and \\(Q_i - Q_j \\geq K\\). Performing the operation decreases the pseudo-inversion count by at least \\(1\\). It is possible to construct a sequence of operations that decreases the pseudo-inversion count by \\(1\\) each time. Specifically, proceed as follows: Iterate \\(x = 1, 2, \\cdots, N\\). Assume that, when processing a certain \\(x\\), the pseudo-inversion count of \\(Q_1, \\cdots, Q_{x-1}\\) is \\(0\\). Enumerate \\(Q_i\\) that satisfy \\(i < x\\) and \\(Q_i - Q_x \\geq K\\), and denote them as \\(i_1, i_2, \\cdots, i_s\\). Then, process \\((i_s, x), (i_{s-1}, i_s), \\cdots, (i_1, i_2)\\) in this order. This decreases the pseudo-inversion count by \\(1\\) with each operation. The same pair \\((Q_i, Q_j)\\) will not be operated on more than once. A straightforward implementation of these steps yields an \\(O(N^2)\\) time solution.\n[END TEXT]\n \n\n", "problem_ids": ["abc366_e", "abc356_g", "arc180_b"]}, "abc334_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\).\n\nYou can perform the following operation any number of times, possibly zero: Choose an integer pair \\((i, j)\\) satisfying \\(1 \\leq i < j \\leq N\\), and replace \\(A_i\\) with \\(A_i + 1\\) and \\(A_j\\) with \\(A_j - 1\\).\n\nDetermine whether it is possible to make \\( A \\) a non-decreasing sequence through the operations.\n\nYou are given \\( T \\) test cases. Solve each of them.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format. Here, \\( \\mathrm{case}_i \\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\nFor each test case, if it is possible to make \\( A \\) a non-decreasing sequence through the operations, print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n\n```\n3\n3\n1 7 5\n2\n9 0\n10\n607 495 419 894 610 636 465 331 925 724\n```\n\n**Sample Output 1**\n\n```\nYes\nNo\nYes\n```\n\nIn the first test case, you can make \\( A \\) into a non-decreasing sequence by performing the following operations:\n1. Choose \\((i, j) = (1, 2)\\). After the operation, \\( A \\) is \\( (2, 6, 5) \\).\n2. Choose \\((i, j) = (1, 2)\\). After the operation, \\( A \\) is \\( (3, 5, 5) \\).\n\nIn the second test case, you cannot make \\( A \\) into a non-decreasing sequence no matter how you perform the operations.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - AtCoder Regular Contest 185\n\nB - +1 and -1 Editorial by evima\n\nIt is possible to turn \\(A\\) into a non-decreasing sequence if and only if the following condition is satisfied: A non-decreasing sequence where the difference between the maximum and minimum values is at most \\(1\\) is called a good sequence. It is possible to turn \\(A\\) into a good sequence through operations.\n\nProof: If we can make \\(A\\) into a good sequence, then \\(A\\) can be made into a non-decreasing sequence. Suppose we transform \\(A\\) into a non-decreasing sequence. After that, we can perform operations to transform \\(A\\) into a good sequence:\n\nInvariant: Initially, the sequence \\((A_1)\\) is a good sequence, and \\(A\\) is non-decreasing. For \\(i = 2, 3, \\dots, N\\), do the following:\n\nInvariant: \\((A_1, A_2, \\dots, A_{i-1})\\) is a good sequence. While \\((A_1, A_2, \\dots, A_i)\\) is not a good sequence, find exactly one position \\(j\\) \\((1 \\leq j \\leq i-1)\\) where adding \\(1\\) to \\(A_j\\) maintains \\((A_1, A_2, \\dots, A_{i-1})\\) as a good sequence. Perform the operation on \\((j, i)\\).\n\nRepeat the operation until \\((A_1, A_2, \\dots, A_i)\\) becomes a good sequence. \\((A_1, A_2, \\dots, A_i)\\) becomes a good sequence if \\(A_{i-1}\\) and \\(A_i\\) coincide, reducing the difference by \\(1\\) or \\(2\\). If it is not obtained, choosing \\(j = i - 1\\) when the difference is \\(1\\) results in \\((A_1, A_2, \\dots, A_{i-1}, A_i) = (x, x, \\dots, x, x+1)\\), which is a good sequence, so no operation is performed.\n\nAfter the operation, \\((A_1, A_2, \\dots, A_i)\\) is a good sequence, and \\(A_i \\leq A_{i+1}\\), so \\(A\\) remains non-decreasing.\n\nThus, the two propositions are equivalent. We can determine if \\(A\\) can become a good sequence in \\(\\mathrm{O}(N)\\) time using cumulative sums, solving this problem in \\(\\mathrm{O}(N)\\) per test case.\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), and a sequence of non-negative integers: \\( A = (A_1,A_2,\\ldots,A_N) \\).\n\nFor a non-empty non-negative integer sequence \\( B = (B_1,B_2,\\ldots,B_{|B|}) \\), we define its **score** as follows:\n- If the length of \\( B \\) is a multiple of \\( M \\): \\( (B_1 \\oplus B_2 \\oplus \\dots \\oplus B_{|B|})^K \\)\n- Otherwise: \\( 0 \\)\n\nHere, \\( \\oplus \\) represents the bitwise XOR.\n\nFind the sum, modulo \\( 998244353 \\), of the scores of the \\( 2^N-1 \\) non-empty subsequences of \\( A \\).\n\n### Constraints\n- \\( 1 \\leq N, K \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 0 \\leq A_i < 2^{20} \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n3 2 2\n1 2 3\n```\n\n### Sample Output 1\n```\n14\n```\n\nHere are the scores of the \\( 2^3-1=7 \\) non-empty subsequences of \\( A \\).\n- \\( (1) \\): \\( 0 \\)\n- \\( (2) \\): \\( 0 \\)\n- \\( (3) \\): \\( 0 \\)\n- \\( (1,2) \\): \\( (1 \\oplus 2)^2 = 9 \\)\n- \\( (1,3) \\): \\( (1 \\oplus 3)^2 = 4 \\)\n- \\( (2,3) \\): \\( (2 \\oplus 3)^2 = 1 \\)\n- \\( (1,2,3) \\): \\( 0 \\)\n\nTherefore, the sought sum is \\( 0 + 0 + 0 + 9 + 4 + 1 + 0 = 14 \\).\n\n### Sample Input 2\n```\n10 5 3\n100 100 100 100 100 100 100 100 100 100\n```\n\n### Sample Output 2\n```\n252000000\n```\n\n### Sample Input 3\n```\n16 4 100\n7053 3876 3178 8422 7802 5998 2334 6757 6889 6637 7365 9495 7848 9026 7312 6558\n```\n\n### Sample Output 3\n```\n432440016\n```\n\n\nSolution:\n\nThe problem requires knowledge of XOR convolution and Hadamard transform. Define \\(C_i\\) as the number of subsequences of \\(A\\) with length as a multiple of \\(M\\) and total XOR equals \\(i\\). We need to find \\(C_0, C_1, \\ldots, C_{2^L-1}\\) such that \\(\\sum_{i=0}^{2^L-1} C_i \\cdot i^K\\) is calculated, where \\(L=20\\).\n\nDefine sequences \\(v_i\\) such that each sequence term is a polynomial, with the 0-th term being 1, the \\(A_i\\)-th term as \\(x\\), and others 0. If \\(A_i=0\\), the 0-th term is \\(1+x\\). For two sequences \\(a, b\\), define the XOR convolution as \\((a \\ast b)_k = \\sum_{i \\oplus j = k} a_i \\times b_j\\). \n\nCompute the XOR convolution \\(V = v_1 \\ast v_2 \\ast \\cdots \\ast v_N\\). The coefficient of \\(x^j\\) of the \\(i\\)-th term (\\([x^j]V_i\\)) equals the number of length-\\(j\\) subsequences of \\(A\\) with a total XOR of \\(i\\), resulting in \\(C_i = [x^0]V_i + [x^M]V_i + \\cdots = [x^0]V_i \\, (\\text{mod } 1-x^M)\\).\n\nUtilize Hadamard conversion \\(H\\), where \\(H(a \\ast b)_i = H(a)_i \\times H(b)_i\\). Therefore, \\(H(V)_i = H(v_1)_i \\times \\cdots \\times H(v_N)_i\\). Compute \\(H(V)\\) using Hadamard conversion on sequences \\(v_1, v_2, \\ldots\\).\n\nGiven sequences that have 1 at the 0-th term and \\(x\\) at the \\(A_i\\)-th term, \\(H(v_i)\\) becomes \\((1+x)\\) or \\((1-x)\\). Thus, \\(H(V)_i\\) can be represented as \\((1+x)^{B_i}(1-x)^{N-B_i}\\). Calculate \\(B_i\\) efficiently using a combination of Hadamard conversion and population count divide-and-conquer strategy, allowing \\(O(L2^L)\\) calculation time. Alternatively, use \\(B_i = \\frac{H(\\text{cnt})_i + N}{2}\\).\n\nFind \\([x^0](1+x)^{B_i}(1-x)^{N-B_i} \\, (\\text{mod } 1-x^M)\\) in \\(O(NM)\\) using precalculated sequences for \\((1+x)^n\\) and \\((1-x)^n \\, (\\text{mod } 1-x^M)\\). Thus, the overall problem can be solved in \\(O(NM + 2^L (L + \\log K))\\) time.\n\nHere's the implementation:\n\n```python\nmod = 998244353\n\ndef hadamard(a, m):\n    for k in range(m):\n        i = 1 << k\n        for j in range(1 << m):\n            if not i & j:\n                a[j], a[i | j] = (a[j] + a[i | j]), (a[j] - a[i | j])\n\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nL = 20\ncnt = [0] * (1 << L)\nfor i in range(N):\n    cnt[A[i]] += 1\n\nF = [[0] * M for i in range(N + 1)]\nG = [[0] * M for i in range(N + 1)]\n\nF[0][0], G[0][0] = 1, 1\n\nfor i in range(N):\n    for j in range(M):\n        F[i + 1][j] = (F[i][j] + F[i][j - 1]) % mod\n        G[i + 1][j] = (G[i][j] - G[i][j - 1]) % mod\n\nres = [0] * (N + 1)\nfor i in range(N + 1):\n    for j in range(M):\n        res[i] += F[i][j] * G[N - i][-j]\n        res[i] %= mod\n\nhadamard(cnt, L)\nB = [(cnt[i] + N) // 2 for i in range(1 << L)]\nC = [res[B[i]] for i in range(1 << L)]\nhadamard(C, L)\n\ninv = pow(1 << L, mod - 2, mod)\nans = 0\nfor i in range(1 << L):\n    C[i] = C[i] % mod * inv % mod\n    ans += C[i] * pow(i, K, mod)\n    ans %= mod\n\nprint(ans)\n```\n\nCalculate \\(B\\) using divide-and-conquer:\n\n```python\ndef calc(off, k):\n    if k == 0:\n        return ([cnt[off]], cnt[off])\n    H0, c0 = calc(off, k - 1)\n    H1, c1 = calc(off | (1 << (k - 1)), k - 1)\n    H = [0] * (1 << k)\n    for i in range(1 << (k - 1)):\n        H[i] = H0[i] + H1[i]\n        H[i | (1 << (k - 1))] = H0[i] + c1 - H1[i]\n    return (H, c0 + c1)\n\nB = calc(0, L)[0]\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n### Problem Statement\n\nThere is a keyboard with 26 keys arranged on a number line. The arrangement of this keyboard is represented by a string \\( S \\), which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character \\( S_x \\) is located at coordinate \\( x \\) \\((1 \\leq x \\leq 26)\\). Here, \\( S_x \\) denotes the \\( x \\)-th character of \\( S \\).\n\nYou will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key. Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.\n\n### Constraints\n\n- \\( S \\) is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n### Sample Output 1\n```\n25\n```\n\nFrom pressing the key for `A` to pressing the key for `Z`, you need to move your finger 1 unit at a time in the positive direction, resulting in a total traveled distance of 25. It is impossible to press all keys with a total traveled distance less than 25, so print 25.\n\n### Sample Input 2\n```\nMGJYIZDKSBHPVENFLQURTCWOAX\n```\n\n### Sample Output 2\n```\n223\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        For a character \\(c\\), let \\(X_c\\) be the coordinate of the key corresponding to the character \\(c\\). We need to find \\(|X_A-X_B|+|X_B-X_C|+\\ldots+|X_Y-X_Z|\\). If we can find \\(S\\) from \\(X\\), the sought value can be found using a for loop. An array can correspond the integer \\(0\\) to A, \\(1\\) to B, \\(\\ldots\\), and \\(25\\) to Z, so that \\(X\\) can be managed as an array. Alternatively, an associative array with its key as a character type can be used.\n\nSample code in Python3:\n\n```python\ns = input()\nx = [0] * 26\nfor i in range(26):\n    x[ord(s[i]) - ord(\"A\")] = i\nans = 0\nfor i in range(25):\n    ans += abs(x[i] - x[i + 1])\nprint(ans)\n```\n        [END TEXT]\n        \n \n\n", "problem_ids": ["arc185_b", "abc367_g", "abc373_b"]}, "abc334_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi can swim in \\( N \\) different styles. When he swims in the \\( i \\)-th style, he consumes \\( A_i \\) stamina per second and advances \\( B_i \\) meters per second. \n\nYou need to answer \\( Q \\) queries. The \\( i \\)-th query is as follows: determine if it is possible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\). If it is possible, find the minimum number of seconds required.\n\nTakahashi can freely combine different swimming styles, and the time to switch styles is negligible. Specifically, he can swim using the following steps:\n- Choose a positive integer \\( m \\), a sequence of positive real numbers \\( t = (t_1, t_2, \\dots, t_m) \\) of length \\( m \\), and a sequence of integers \\( x = (x_1, x_2, \\dots, x_m) \\) of length \\( m \\) where each element is between \\( 1 \\) and \\( N \\), inclusive.\n- Then, swim in the \\( x_i \\)-th style for \\( t_i \\) seconds in the order \\( i = 1, 2, \\dots, m \\).\n\n**Constraints:**\n- All input values are integers.\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C_i, D_i \\leq 10^9 \\)\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\nQ\nC_1 D_1\nC_2 D_2\n...\nC_Q D_Q\n```\n\n**Output:**\nPrint \\( Q \\) lines in total. For the \\( i \\)-th query, print the answer in the \\( i \\)-th line as follows:\n- If it is impossible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\), print \\(-1\\).\n- Otherwise, print the minimum required time. The output is considered correct if the absolute or relative error between the printed value and the true answer is at most \\( 10^{-9} \\).\n\n**Sample Input:**\n```\n4\n1 2\n2 3\n3 3\n4 4\n5\n4 7\n7 7\n49 100\n1000 500\n4 5\n```\n\n**Sample Output:**\n```\n3.000000000000000000\n1.750000000000000000\n-1\n125.000000000000000000\n1.500000000000000000\n```\n\nIn this input, Takahashi can swim in the following four styles:\n- Consumes 1 stamina and advances 2 meters per second.\n- Consumes 2 stamina and advances 3 meters per second.\n- Consumes 3 stamina and advances 3 meters per second.\n- Consumes 4 stamina and advances 4 meters per second.\n\nThis input contains five queries:\n- For the first query, \\( C_1 = 4, D_1 = 7 \\). Choose \\( t = (1,2) \\) and \\( x = (2,1) \\). Takahashi swims as follows:\n  - In the first 1 second, he consumes 2 stamina and advances 3 meters.\n  - In the next 2 seconds, he consumes 2 stamina and advances 4 meters.\n  - In total, he consumes 4 stamina and advances 7 meters. The required time is 3 seconds, which is the minimum.\n- For the second query, \\( C_2 = 7, D_2 = 7 \\). Choose \\( t = (7/4) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 7/4 seconds, he consumes 7 stamina and advances 7 meters.\n  - In total, he consumes 7 stamina and advances 7 meters. The required time is 7/4 seconds, which is the minimum.\n- For the third query, \\( C_3 = 49, D_3 = 100 \\). No matter how Takahashi swims, it is not possible to advance 100 meters while keeping the total stamina consumption at most 49.\n- For the fourth query, \\( C_4 = 1000, D_4 = 500 \\). Choose \\( t = (125) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 125 seconds, he consumes 500 stamina and advances 500 meters.\n  - In total, he consumes 500 stamina and advances 500 meters. The required time is 125 seconds, which is the minimum.\n- For the fifth query, \\( C_5 = 4, D_5 = 5 \\). Choose \\( t = (1/2,1) \\) and \\( x = (4,2) \\). Takahashi swims as follows:\n  - In the first 1/2 seconds, he consumes 2 stamina and advances 2 meters.\n  - In the next 1 second, he consumes 2 stamina and advances 3 meters.\n  - In total, he consumes 4 stamina and advances 5 meters. The required time is 3/2 seconds, which is the minimum.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 356\n\nConsider the case where Takahashi can swim using two styles: consume stamina of \\(A_1\\) to advance \\(B_1\\) meters per second or consume stamina of \\(A_2\\) to advance \\(B_2\\) meters per second. He can combine these styles to swim by consuming stamina of \\(tA_1+(1-t)A_2\\) to advance \\(tB_1+(1-t)B_2\\) meters per second. This corresponds to points on the segment connecting \\((B_1,A_1)\\) and \\((B_2,A_2)\\) in the \\(xy\\)-plane.\n\nIf there are \\(N\\) points \\((B_i,A_i)\\), he can swim for any point inside or on the convex hull's boundary, but not outside it. Plotting the styles on the \\(xy\\)-plane assists in this determination. The most time-efficient point has the maximum \\(B_i\\), and the most stamina-efficient point has the minimum \\(A_i/B_i\\). If he can't swim \\(D_i\\) meters using the stamina-efficient point, the answer is -1.\n\nTo swim \\(D_i\\) meters within stamina \\(C_i\\), locate the rightmost point in the intersection of the convex hull's circumference and a line passing through \\((0,0)\\) and \\((D_i,C_i)\\). This represents viable swimming styles under the stamina constraint. He should trace the convex hull from the stamina-efficient point to the time-efficient point counterclockwise. Using binary search helps identify which segment it lies on and then pinpoints \\(P_{opt}\\)'s exact coordinates.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 150 points\n\nProblem Statement:\nThere are \\(2N\\) people standing in a row, and the person at the \\(i\\)-th position from the left is wearing clothes of color \\(A_i\\). The clothes have \\(N\\) colors from \\(1\\) to \\(N\\), and exactly two people are wearing clothes of each color.\n\nFind how many of the integers \\(i=1,2,\\ldots,N\\) satisfy the following condition:\n- There is exactly one person between the two people wearing clothes of color \\(i\\).\n\nConstraints:\n- \\(2 \\leq N \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- Each integer from \\(1\\) through \\(N\\) appears exactly twice in \\(A\\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{2N}\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n3\n1 2 1 3 2 3\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation:\nThere are two values of \\(i\\) that satisfy the condition: \\(1\\) and \\(3\\).\nIn fact, the people wearing clothes of color \\(1\\) are at the 1st and 3rd positions from the left, with exactly one person in between.\n\nSample Input 2:\n```\n2\n1 1 2 2\n```\n\nSample Output 2:\n```\n0\n```\n\nExplanation:\nThere may be no \\(i\\) that satisfies the condition.\n\nSample Input 3:\n```\n4\n4 3 2 3 2 1 4 1\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nB - Couples Editorial by en_translator\n\nBy mathematically interpreting the problem statement, it turns out that it is asking to count \\(i\\) such that \\(A_i=A_{i+2}\\). Use for and if statements to check if each \\(i\\) satisfies the condition. Sample code (Python3):\n\n```python\nn = int(input())\na = [int(input()) for _ in range(n * 2)]\nres = 0\nfor i in range(n * 2 - 2):\n    if a[i] == a[i + 2]:\n        res += 1\nprint(res)\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given two integers \\( N \\) and \\( M \\). An integer sequence of length between 1 and \\( N \\) (inclusive), where each element is between 1 and \\( M \\) (inclusive), is called a *good sequence*.\n\nThe *score* of a good sequence is defined as the number of positive divisors of \\( X \\), where \\( X \\) is the product of the elements in the sequence.\n\nThere are \\(\\displaystyle \\sum_{k=1}^{N}M^k\\) good sequences. Your task is to find the sum of the scores of all those sequences modulo 998244353.\n\n**Constraints:**\n\n- \\(1 \\leq N \\leq 10^{18}\\)\n- \\(1 \\leq M \\leq 16\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is provided in the following format:\n\n```\nN M\n```\n\n**Output:**\n\nOutput the answer as an integer.\n\n**Examples:**\n\n- **Input:**\n  ```\n  1 7\n  ```\n\n  **Output:**\n  ```\n  16\n  ```\n  *Explanation:* \n  There are seven good sequences: (1), (2), (3), (4), (5), (6), (7). Their scores are 1, 2, 2, 3, 2, 4, 2, respectively, so the answer is 1 + 2 + 2 + 3 + 2 + 4 + 2 = 16.\n\n- **Input:**\n  ```\n  3 11\n  ```\n\n  **Output:**\n  ```\n  16095\n  ```\n  *Explanation:*\n  For example, (8, 11) and (1, 8, 2) are good sequences.\n  \n  - The product of the elements in (8, 11) is \\(8 \\times 11 = 88\\). 88 has eight positive divisors: 1, 2, 4, 8, 11, 22, 44, 88, so the score of (8, 11) is 8.\n  - The product of the elements in (1, 8, 2) is \\(1 \\times 8 \\times 2 = 16\\). 16 has five positive divisors: 1, 2, 4, 8, 16, so the score of (1, 8, 2) is 5.\n\n- **Input:**\n  ```\n  81131 14\n  ```\n\n  **Output:**\n  ```\n  182955659\n  ```\n  *Note:* Remember to take the result modulo 998244353.\n\nSolution:\n\n```python\nfrom collections import defaultdict\n\nMOD = 998244353\nMAX_PRIME = 6\nPRIMES = [2, 3, 5, 7, 11, 13]\n\ndef matrix_pow(a, x):\n    mat_size = len(a)\n    ret = [[0]*mat_size for _ in range(mat_size)]\n    for i in range(mat_size):\n        ret[i][i] = 1\n    while x > 0:\n        if x & 1:\n            nret = [[0]*mat_size for _ in range(mat_size)]\n            for i in range(mat_size):\n                for k in range(mat_size):\n                    for j in range(mat_size):\n                        nret[i][j] += ret[i][k] * a[k][j]\n                        nret[i][j] %= MOD\n            ret = nret\n        na = [[0]*mat_size for _ in range(mat_size)]\n        for i in range(mat_size):\n            for k in range(mat_size):\n                for j in range(mat_size):\n                    na[i][j] += a[i][k] * a[k][j]\n                    na[i][j] %= MOD\n        a = na\n        x >>= 1\n    return ret\n\nN, M = map(int, input().split())\nmat = [[0]*((1 << MAX_PRIME) + 1) for _ in range((1 << MAX_PRIME) + 1)]\nnxt = defaultdict(int)\nfor i in range(1 << MAX_PRIME):\n    for j in range(1, M + 1):\n        add = 1\n        for k in range(MAX_PRIME):\n            if not (i >> k) & 1:\n                continue\n            cnt = 0\n            while j % PRIMES[k] == 0:\n                cnt += 1\n                j //= PRIMES[k]\n            add *= cnt\n        nxt[i] += add\nfor i in range(1 << MAX_PRIME):\n    for j in nxt:\n        if (i & j) == 0:\n            mat[i][i | j] += nxt[j]\nmat[(1 << MAX_PRIME) - 1][1 << MAX_PRIME] = 1\nmat[1 << MAX_PRIME][1 << MAX_PRIME] = 1\nmat = matrix_pow(mat, N + 1)\nans = 0\nfor i in range(1 << MAX_PRIME):\n    ans += mat[i][1 << MAX_PRIME]\nprint((ans - 1) % MOD)\n```\n \n\n", "problem_ids": ["abc356_g", "abc359_b", "arc182_c"]}, "abc334_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 350 points\n\n**Problem Statement:**\n\nA souvenir shop at AtCoder Land sells \\(N\\) boxes. The boxes are numbered from 1 to \\(N\\), and box \\(i\\) has a price of \\(A_i\\) yen and contains \\(A_i\\) pieces of candy. Takahashi wants to buy \\(M\\) out of the \\(N\\) boxes and give one box each to \\(M\\) people named 1, 2, ..., \\(M\\).\n\nHe wants to select the boxes such that:\n- For each \\(i = 1, 2, \\ldots, M\\), person \\(i\\) is given a box containing at least \\(B_i\\) pieces of candy.\n\nIt is not allowed to give more than one box to a single person or to give the same box to multiple people.\n\nDetermine whether it is possible to buy \\(M\\) boxes that can satisfy the condition. If it is possible, compute the minimum total cost Takahashi needs to pay.\n\n**Constraints:**\n- \\(1 \\leq M \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq A_i, B_i \\leq 10^9\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_M\n```\n\n**Output:**\n\nIf it is possible to buy \\(M\\) boxes that can satisfy the condition, print the minimum total amount of money Takahashi needs to pay. Otherwise, print \\(-1\\).\n\n**Sample Input 1:**\n```\n4 2\n3 4 5 4\n1 4\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n*Takahashi can buy boxes 1 and 4, and give box 1 to person 1 and box 4 to person 2 to satisfy the condition. In this case, he needs to pay 7 yen in total, and it is impossible to satisfy the condition by paying less than 7 yen, so print 7.*\n\n**Sample Input 2:**\n```\n3 3\n1 1 1\n1000000000 1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n-1\n```\n\n**Sample Input 3:**\n```\n7 3\n2 6 8 9 5 1 11\n3 5 7\n```\n\n**Sample Output 3:**\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nConsider determining the box to give to people \\(1, 2, \\ldots, M\\) in this order. The following greedy strategy executed for each \\(i = 1, 2, \\ldots , M\\) in order is valid.\n\nTo person \\(i\\), give the undistributed box containing at least \\(B_i\\) candies with the smallest number of candies in it. (Let us call this strategy \\((\\bigstar)\\).)\n\nWe will assume that this solution is not optimal to deduce a contradiction. Take an optimal solution. In this optimal solution, there is an \\(i\\) that violates the strategy \\((\\bigstar)\\). Take the minimum such \\(i\\). Let box \\(X\\) be the box that you would give to person \\(i\\) if you obey the strategy \\((\\bigstar)\\) up to \\(1,2,\\ldots, i-1, i\\). In the taken optimal solution, if box \\(X\\) is not given to anyone, then giving person \\(i\\) box \\(X\\) improves the solution, which contradicts the optimality. Thus you will give it to a person \\(j\\). Consider swapping the boxes to give to person \\(i\\) and to person \\(j\\). This operation keeps optimality, but the minimum \\(i\\) that violates \\((\\bigstar)\\) strictly increases, so repeating this yields a contradiction. Hence, the greedy algorithm has been justified.\n\nTherefore, it is sufficient to simulate this greedy algorithm fast enough. This can be done by using a data structure like `sortedcontainers.SortedList` in Python, or using the sliding window trick by using the fact that \\(A\\) and \\(B\\) can be sorted without changing the answer.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\). Additionally, you are given an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n1. Choose integers \\( l \\) and \\( r \\) such that \\( 1 \\leq l < r \\leq N \\).\n   - The pair \\((l, r)\\) must satisfy the following conditions:\n     - \\( K \\leq r - l \\).\n     - \\( P_l > P_r \\) at the time of the operation.\n     - The pair \\((l, r)\\) has never been chosen before.\n\n2. Swap the values of \\( P_l \\) and \\( P_r \\).\n\nYour goal is to maximize the number of operations. Find one way to achieve this.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( 1 \\leq K \\leq N - 1 \\)\n- \\( (P_1, P_2, \\ldots, P_N) \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\ldots P_N\n```\n\n### Output\n\nPrint the answer in the following format:\n```\nm\nl_1 r_1\nl_2 r_2\n\\vdots\nl_m r_m\n```\n\nHere, \\( m \\) is the maximum number of operations, and \\( l_i \\) and \\( r_i \\) are the values of \\( l \\) and \\( r \\) chosen in the \\( i \\)-th operation, respectively. If multiple solutions exist, you can print any of them.\n\n### Sample Input 1\n```\n3 1\n3 2 1\n```\n\n### Sample Output 1\n```\n3\n2 3\n1 3\n1 2\n```\n\nIn this example, the maximum number of operations is \\( 3 \\). The operations in the sample output proceed as follows:\n\n1. Choose \\((l, r) = (2, 3)\\). We have \\( 1 \\leq 3 - 2 \\) and \\( P_2 > P_3 \\), and \\((2, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_2 \\) and \\( P_3 \\), resulting in \\( P = (3, 1, 2) \\).\n\n2. Choose \\((l, r) = (1, 3)\\). We have \\( 1 \\leq 3 - 1 \\) and \\( P_1 > P_3 \\), and \\((1, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_3 \\), resulting in \\( P = (2, 1, 3) \\).\n\n3. Choose \\((l, r) = (1, 2)\\). We have \\( 1 \\leq 2 - 1 \\) and \\( P_1 > P_2 \\), and \\((1, 2)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_2 \\), resulting in \\( P = (1, 2, 3) \\).\n\nSolution:\n\n[BEGIN TEXT]\nLet\u2019s consider the inverse permutation \\(Q\\) of \\(P\\). In other words, \\(Q_{P_i} = i\\). Rephrasing the operation with \\(Q\\) as the main focus, it becomes: Choose \\(i, j\\) such that \\(1 \\leq i < j \\leq N\\) and \\(Q_i - Q_j \\geq K\\). Here, the pair \\((Q_i, Q_j)\\) must not have been chosen before. Swap \\(Q_i\\) and \\(Q_j\\).\n\nWe define the pseudo-inversion count of \\(Q\\) as the number of integer pairs \\((i, j)\\) such that \\(i < j\\) and \\(Q_i - Q_j \\geq K\\). Performing the operation decreases the pseudo-inversion count by at least \\(1\\). It is possible to construct a sequence of operations that decreases the pseudo-inversion count by \\(1\\) each time. Specifically, proceed as follows: Iterate \\(x = 1, 2, \\cdots, N\\). Assume that, when processing a certain \\(x\\), the pseudo-inversion count of \\(Q_1, \\cdots, Q_{x-1}\\) is \\(0\\). Enumerate \\(Q_i\\) that satisfy \\(i < x\\) and \\(Q_i - Q_x \\geq K\\), and denote them as \\(i_1, i_2, \\cdots, i_s\\). Then, process \\((i_s, x), (i_{s-1}, i_s), \\cdots, (i_1, i_2)\\) in this order. This decreases the pseudo-inversion count by \\(1\\) with each operation. The same pair \\((Q_i, Q_j)\\) will not be operated on more than once. A straightforward implementation of these steps yields an \\(O(N^2)\\) time solution.\n[END TEXT]\n \n\n", "problem_ids": ["abc358_d", "abc366_e", "arc180_b"]}, "abc335_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given two strings \\( S \\) and \\( T \\) consisting of lowercase English letters. Here, \\( S \\) and \\( T \\) have equal lengths.\n\nLet \\( X \\) be an empty array, and repeat the following operation until \\( S \\) equals \\( T \\):\n\n- Change one character in \\( S \\), and append \\( S \\) to the end of \\( X \\).\n\nFind the array of strings \\( X \\) with the minimum number of elements obtained in this way. If there are multiple such arrays with the minimum number of elements, find the lexicographically smallest one among them.\n\n**Lexicographical order on arrays of strings:**\n\nA string \\( S = S_1 S_2 \\ldots S_N \\) of length \\( N \\) is lexicographically smaller than a string \\( T = T_1 T_2 \\ldots T_N \\) of length \\( N \\) if there exists an integer \\( 1 \\leq i \\leq N \\) such that both of the following are satisfied:\n\n1. \\( S_1 S_2 \\ldots S_{i-1} = T_1 T_2 \\ldots T_{i-1} \\)\n2. \\( S_i \\) comes earlier than \\( T_i \\) in alphabetical order.\n\nAn array of strings \\( X = (X_1, X_2, \\ldots, X_M) \\) with \\( M \\) elements is lexicographically smaller than an array of strings \\( Y = (Y_1, Y_2, \\ldots, Y_M) \\) with \\( M \\) elements if there exists an integer \\( 1 \\leq j \\leq M \\) such that both of the following are satisfied:\n\n1. \\( (X_1, X_2, \\ldots, X_{j-1}) = (Y_1, Y_2, \\ldots, Y_{j-1}) \\)\n2. \\( X_j \\) is lexicographically smaller than \\( Y_j \\).\n\n**Constraints:**\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters with lengths between 1 and 100, inclusive.\n- The lengths of \\( S \\) and \\( T \\) are equal.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n- Line 1: String \\( S \\)\n- Line 2: String \\( T \\)\n\n**Output:**\nLet \\( M \\) be the number of elements in the desired array. Print \\( M + 1 \\) lines:\n- The first line should contain the value of \\( M \\).\n- The \\( i + 1 \\)-th line (for \\( 1 \\leq i \\leq M \\)) should contain the \\( i \\)-th element of the array.\n\n**Sample Input 1:**\n```\nadbe\nbcbc\n```\n\n**Sample Output 1:**\n```\n3\nacbe\nacbc\nbcbc\n```\n\n**Explanation:**\nInitially, \\( S = \\) `adbe`. We can obtain \\( X = ( \\) `acbe`, `acbc`, `bcbc` \\( ) \\) by performing the following operations:\n1. Change \\( S \\) to `acbe` and append `acbe` to the end of \\( X \\).\n2. Change \\( S \\) to `acbc` and append `acbc` to the end of \\( X \\).\n3. Change \\( S \\) to `bcbc` and append `bcbc` to the end of \\( X \\).\n\n**Sample Input 2:**\n```\nabcde\nabcde\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\nafwgebrw\noarbrenq\n```\n\n**Sample Output 3:**\n```\n8\naawgebrw\naargebrw\naarbebrw\naarbebnw\naarbebnq\naarbeenq\naarbrenq\noarbrenq\n```\n\nSolution:\n\n        Here is a cleaned-up version of the text:\n\n---\n\nLet \\(N\\) be the length of the string, and \\(x\\) be the number of \\(i\\) with \\(S_i \\neq T_i\\). The minimum possible number of operations is \\(x\\), and each operation replaces \\(S_i\\) with \\(T_i\\) for some \\(i\\) where \\(S_i \\neq T_i\\).\n\nThe order of these operations can vary, and to achieve a lexicographically minimum string, we can consider doing the operation that results in the minimal string. This brute-force approach can be accomplished in \\(O(N^3)\\) time. It can be further optimized: when \\(S_i\\) is replaced with \\(T_i\\), the string becomes larger if \\(S_i < T_i\\) and smaller if \\(S_i > T_i\\). Therefore, it's optimal to apply operations on the minimum \\(i\\) with \\(S_i > T_i\\). If there\u2019s no such \\(i\\), apply the operation against the maximum \\(i\\) with \\(S_i < T_i\\). This approach runs in \\(O(N^2)\\) time.\n\nSample code (\\(O(N^3)\\)):\n\n```python\ndef main():\n    s = input()\n    t = input()\n    ans = []\n    n = len(s)\n    while s != t:\n        nxt = 'z' * n\n        for i in range(n):\n            if s[i] != t[i]:\n                tmp = list(s)\n                tmp[i] = t[i]\n                s_tmp = ''.join(tmp)\n                nxt = min(nxt, s_tmp)\n        ans.append(nxt)\n        s = nxt\n    sz = len(ans)\n    print(sz)\n    for e in ans:\n        print(e)\n\nmain()\n```\n\nSample code (\\(O(N^2)\\)):\n\n```python\ndef main():\n    s = input()\n    t = input()\n    ans = []\n    v = []\n    n = len(s)\n    for i in range(n):\n        if s[i] > t[i]:\n            v.append(i)\n    for i in range(n - 1, -1, -1):\n        if s[i] < t[i]:\n            v.append(i)\n    sz = len(v)\n    for i in range(sz):\n        s = list(s)\n        s[v[i]] = t[v[i]]\n        ans.append(''.join(s))\n        s = ''.join(s)\n    print(sz)\n    for e in ans:\n        print(e)\n\nmain()\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere are \\( N \\) people, and the current hair length of the \\( i \\)-th person \\( (1 \\leq i \\leq N) \\) is \\( L_i \\).\nEach person's hair grows by 1 per day.\n\nPrint the number of days after which the number of people whose hair length is at least \\( T \\) becomes \\( P \\) or more for the first time.\nIf there are already \\( P \\) or more people whose hair length is at least \\( T \\) now, print 0.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq L_i \\leq 100 \\)\n- \\( 1 \\leq T \\leq 100 \\)\n- \\( 1 \\leq P \\leq N \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN T P\nL_1 L_2 \\ldots L_N\n```\n\n**Output:**\nPrint the number of days after which the number of people whose hair length is at least \\( T \\) becomes \\( P \\) or more for the first time. \nIf this condition is already satisfied now, print 0.\n\n**Sample Input 1:**\n```\n5 10 3\n3 11 1 6 2\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n*Explanation:*\nThere are five people, and their current hair lengths are 3, 11, 1, 6, and 2, so there is one person whose hair length is at least 10.\nAfter seven days, the hair lengths of the people will be 10, 18, 8, 13, and 9, respectively, and there will be three people whose hair length is at least 10.\nAfter six days, there are only two people whose hair length is at least 10, not satisfying the condition, so print 7.\n\n**Sample Input 2:**\n```\n2 5 2\n10 10\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n*Explanation:*\nSince there are already two people whose hair length is at least 5 now, satisfying the condition, print 0.\n\n**Sample Input 3:**\n```\n3 10 1\n1 2 3\n```\n\n**Sample Output 3:**\n```\n7\n```\n\nSolution:\n\n        Editorial - B - Japanese Cursed Doll\n\n\\((T-1)\\) days later, everyone has hair of length \\(T\\) or greater. Together with \\(P\\leq N\\), the condition is always satisfied. One can find the answer by checking if the conditions are satisfied on day \\(i\\) for each \\(i=0,1,\\ldots,(T-1)\\) in order. The complexity is \\(O(NT)\\), which is fast enough for the constraints. The problem can also be solved in \\(O(N\\log N)\\) time by recording how many days are required for each person to have hair of length \\(T\\) or greater, sorting the counts of days, and finding the \\(P\\)-th smallest one among them.\n\nSample code in C++:\n```python\nn, t, p = map(int, input().split())\nl = list(map(int, input().split()))\n\nfor i in range(t):\n    cnt = 0\n    for j in range(n):\n        if l[j] + i >= t:\n            cnt += 1\n    if cnt >= p:\n        print(i)\n        break\n```\n\nSample code in Python:\n```python\nn,t,p=map(int, input().split())\nl=list(map(int, input().split()))\n\nfor i in range(t):\n    cnt=0\n    for j in range(n):\n        if l[j]+i>=t:\n            cnt+=1\n    if cnt>=p:\n        print(i)\n        break\n```\n\nSample code in C++ (another solution):\n```python\nn, t, p = map(int, input().split())\nl = []\n\nfor i in range(n):\n    x = int(input())\n    l.append(max(0, t - x))\n\nl.sort()\nprint(l[p - 1])\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAt the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes \\( A \\) seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.\n\nCurrently, there is no one in line at the ticket booth, and \\( N \\) people will come to buy tickets one after another. Specifically, the \\( i \\)-th person will arrive at the ticket booth \\( T_i \\) seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately. Here, \\( T_1 < T_2 < \\dots < T_N \\).\n\nFor each \\( i\\ (1 \\leq i \\leq N) \\), determine how many seconds from now the \\( i \\)-th person will finish purchasing their ticket.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 0 \\leq T_1 < T_2 < \\dots < T_N \\leq 10^6 \\)\n- \\( 1 \\leq A \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\nT_1 T_2 \\dots T_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the number of seconds from now that the \\( i \\)-th person will finish purchasing their ticket.\n\n**Sample Input 1:**\n\n```\n3 4\n0 2 10\n```\n\n**Sample Output 1:**\n\n```\n4\n8\n14\n```\n\nThe events proceed in the following order:\n\n- At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.\n- At 8 seconds: The 2nd person finishes purchasing their ticket.\n- At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 14 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 2:**\n\n```\n3 3\n1 4 7\n```\n\n**Sample Output 2:**\n\n```\n4\n7\n10\n```\n\nThe events proceed in the following order:\n\n- At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.\n- At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 10 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 3:**\n\n```\n10 50000\n120190 165111 196897 456895 540000 552614 561627 743796 757613 991216\n```\n\n**Sample Output 3:**\n\n```\n170190\n220190\n270190\n506895\n590000\n640000\n690000\n793796\n843796\n1041216\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nB - Ticket Counter Editorial by en_translator\n\nSuppose that the \\(i\\)-th person finishes buying a ticket at time \\(x_i\\). For convenience, let \\(x_0=0\\).\nFor each \\(i\\) (1 \\(\\leq i\\leq N\\)), we determine how to represent the value \\(x_i\\) using \\(x_{i-1}\\).\n\nIf \\(x_{i-1} \\leq T_i\\): there is no queue when the \\(i\\)-th person visits the ticket booth, so they can start purchasing instantly. Thus, \\(x_i=T_i+A\\).\nIf \\(x_{i-1} > T_i\\): someone is still purchasing a ticket when the \\(i\\)-th person visits the booth, so they start the process right after the \\((i-1)\\)-th person finishes. Thus, \\(x_i=x_{i-1}+A\\).\n\nTo summarize, \\(x_i=\\max(x_{i-1},T_i)+A\\). Use this to find \\(x_i\\) for each \\(i=1,2,\\dots,N\\).\n\nSample code (Python):\n```python\nn, a = map(int, input().split())\nt = list(map(int, input().split()))\npre = 0\nfor i in range(n):\n    ans = max(pre, t[i]) + a\n    print(ans)\n    pre = ans\n```\n \n\n", "problem_ids": ["abc370_c", "abc363_b", "abc358_b"]}, "abc335_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence \\( (X_1, X_2, \\dots, X_M) \\) of length \\( M \\) consisting of integers between \\( 1 \\) and \\( M \\), inclusive.\n\nFind the number, modulo \\( 998244353 \\), of sequences \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\) consisting of integers between \\( 1 \\) and \\( M \\), inclusive, that satisfy the following condition:\n\nFor each \\( B = 1, 2, \\dots, M \\), the value \\( X_B \\) exists between any two different occurrences of \\( B \\) in \\( A \\) (including both ends).\n\nMore formally, for each \\( B = 1, 2, \\dots, M \\), the following condition must hold:\n\nFor every pair of integers \\( (l, r) \\) such that \\( 1 \\leq l < r \\leq N \\) and \\( A_l = A_r = B \\), there exists an integer \\( m \\) (\\( l \\leq m \\leq r \\)) such that \\( A_m = X_B \\).\n\n**Constraints**\n- \\( 1 \\leq M \\leq 10 \\)\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq X_i \\leq M \\)\n- All input values are integers.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nM N\nX_1 X_2 \\cdots X_M\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n3 4\n2 1 2\n```\n\n**Sample Output 1**\n```\n14\n```\n\nHere are examples of sequences \\( A \\) that satisfy the condition:\n- \\( (1, 3, 2, 3) \\)\n- \\( (2, 1, 2, 1) \\)\n- \\( (3, 2, 1, 3) \\)\n\nHere are non-examples:\n- \\( (1, 3, 1, 3) \\) - There is no \\( X_3 = 2 \\) between the \\( 3 \\)s.\n- \\( (2, 2, 1, 3) \\) - There is no \\( X_2 = 1 \\) between the \\( 2 \\)s.\n\n**Sample Input 2**\n```\n4 8\n1 2 3 4\n```\n\n**Sample Output 2**\n```\n65536\n```\n\nAll sequences of length \\( 8 \\) consisting of integers between \\( 1 \\) and \\( 4 \\) satisfy the condition. Note that when \\( X_B = B \\), there is always a \\( B \\) between two different occurrences of \\( B \\).\n\n**Sample Input 3**\n```\n4 9\n2 3 4 1\n```\n\n**Sample Output 3**\n```\n628\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 179\n\n# B - Between B and B Editorial by evima\n\n# For each B = 1, 2, ..., M, the value X_B exists between any two different occurrences \n# of B in A (including both ends). This condition will be referred to as \u201cthe condition.\u201d \n# Let\u2019s consider determining the elements of A from the beginning. When deciding A_i, \n# we choose A_i such that (A_1, A_2, ..., A_i) satisfies the condition. Therefore, \n# let\u2019s consider the following dynamic programming approach.\n\n# Let dp[c][S] be the number of ways to determine the first c(=0,1,...,N) elements of \n# A such that the set of possible values for A_{c+1} is S (\u2286 {1,2,...,M}).\n\n# First, any of 1, 2, ..., M can be chosen as A_1. Therefore, dp[0][{1,2,...,M}] = 1. \n# Next, let\u2019s consider what happens when c and S are fixed, and we decide A_{c+1} to \n# be a \u2208 S. First, due to the condition that X_a must exist between any two occurrences \n# of a, we remove a from S. This can be interpreted as not being allowed to add a again \n# until X_a is added. Next, we add all b such that X_b = a to S. This can be interpreted \n# as allowing b to be added since X_b has been added. Let the new set obtained in this \n# way be written as S(a). The transition in the dynamic programming can be written as \n# follows:\n\n# dp[c+1][S(a)] += dp[c][S]  (a \u2208 S)\n\n# This is a bitDP. The time complexity is O(NM2^M), which is sufficiently fast under \n# the given constraints.\n```\n\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere are \\(N+Q\\) points \\(A_1, \\dots, A_N, B_1, \\dots, B_Q\\) on a number line, where point \\(A_i\\) has a coordinate \\(a_i\\) and point \\(B_j\\) has a coordinate \\(b_j\\).\n\nFor each \\(j = 1, 2, \\dots, Q\\), answer the following question:\n\nFind the distance between the point \\(X\\), which is the \\(k_j\\)-th closest among \\(A_1, A_2, \\dots, A_N\\) to point \\(B_j\\), and \\(B_j\\).\n\nMore formally, let \\(d_i\\) be the distance between points \\(A_i\\) and \\(B_j\\). Sort \\( (d_1, d_2, \\dots, d_N) \\) in ascending order to get the sequence \\( (d_1', d_2', \\dots, d_N') \\). Find \\( d_{k_j}' \\).\n\n### Constraints\n\n- \\(1 \\leq N, Q \\leq 100,000\\)\n- \\(-10^8 \\leq a_i, b_j \\leq 10^8\\)\n- \\(1 \\leq k_j \\leq N\\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\na_1 a_2 \\dots a_N\nb_1 k_1\nb_2 k_2\n\\vdots\nb_Q k_Q\n```\n\n### Output\n\nPrint \\( Q \\) lines.\nThe \\( l \\)-th line \\( (1 \\leq l \\leq Q) \\) should contain the answer to the question for \\( j = l \\) as an integer.\n\n### Sample Input 1\n\n```\n4 3\n-3 -1 5 6\n-2 3\n2 1\n10 4\n```\n\n### Sample Output 1\n\n```\n7\n3\n13\n```\n\nExplanation for the first query: The distances from points \\( A_1, A_2, A_3, A_4 \\) to point \\( B_1 \\) are \\( 1, 1, 7, 8 \\), respectively, so the 3rd closest to point \\( B_1 \\) is point \\( A_3 \\). Therefore, print the distance between point \\( A_3 \\) and point \\( B_1 \\), which is \\( 7 \\).\n\n### Sample Input 2\n\n```\n2 2\n0 0\n0 1\n0 2\n```\n\n### Sample Output 2\n\n```\n0\n0\n```\n\nThere may be multiple points with the same coordinates.\n\n### Sample Input 3\n\n```\n10 5\n-84 -60 -41 -100 8 -8 -52 -62 -61 -76\n-52 5\n14 4\n-2 6\n46 2\n26 7\n```\n\n### Sample Output 3\n\n```\n11\n66\n59\n54\n88\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe problem requires finding the \\(k\\)-th nearest point to a given point among a set of points. To achieve this, binary search is employed. Define \\(f_j(x)\\) as the number of points within a distance \\(x\\) from a specific point \\(B_j\\). The task is reduced to finding the smallest \\(x\\) for which \\(f_j(x) \\geq k_j\\). Since \\(f_j(x)\\) increases monotonically, binary search is suitable and is applied \\(O(Q\\log A)\\) times. Pre-sorting the points allows efficient range counting with binary search. The overall complexity is \\(O(N\\log N + Q\\log A)\\).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nTakahashi will encounter \\( N \\) monsters in order. The \\( i \\)-th monster \\((1 \\leq i \\leq N)\\) has a strength of \\( A_i \\).\n\nFor each monster, he can choose to either let it go or defeat it. Each action awards him experience points as follows:\n- If he lets a monster go, he gains 0 experience points.\n- If he defeats a monster with strength \\( X \\), he gains \\( X \\) experience points. If it is an even-numbered defeated monster (2nd, 4th, ...), he gains an additional \\( X \\) experience points.\n\nFind the maximum total experience points he can gain from the \\( N \\) monsters.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the maximum total experience points he can gain from the \\( N \\) monsters as an integer.\n\n**Sample Input 1:**\n```\n5\n1 5 3 2 7\n```\n\n**Sample Output 1:**\n```\n28\n```\n\n**Explanation:**\n\nIf Takahashi defeats the 1st, 2nd, 3rd, and 5th monsters, and lets the 4th monster go, he gains experience points as follows:\n- Defeats a monster with strength \\( A_1 = 1 \\). He gains 1 experience point.\n- Defeats a monster with strength \\( A_2 = 5 \\). He gains 5 experience points. As it is the 2nd defeated monster, he gains an additional 5 points.\n- Defeats a monster with strength \\( A_3 = 3 \\). He gains 3 experience points.\n- Lets the 4th monster go. Takahashi gains no experience points.\n- Defeats a monster with strength \\( A_5 = 7 \\). He gains 7 experience points. As it is the 4th defeated monster, he gains an additional 7 points.\n\nTherefore, in this case, he gains \\( 1+(5+5)+3+0+(7+7)=28 \\) experience points. Note that even if he encounters a monster, if he lets it go, it does not count as defeated. He can gain at most 28 experience points no matter how he acts, so print 28. As a side note, if he defeats all monsters in this case, he would gain \\( 1+(5+5)+3+(2+2)+7=25 \\) experience points.\n\n**Sample Input 2:**\n```\n2\n1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n3000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 369\n\nD - Bonus EXP Editorial\n\nThis problem can be solved with dynamic programming (DP). Let \\(dp_{even}[k]\\) be the maximum total experience point when defeating an even number of monsters out of the first \\(k\\) monsters encountered, and \\(dp_{odd}[k]\\) be that for an odd number of monsters (or \\(-\\infty\\) if it is impossible). Initially, \\(dp_{even}[0]=0\\) and \\(dp_{odd}[0]=-\\infty\\).\n\nFor \\(1\\leq i\\leq N\\), the experience point from the \\(i\\)-th monster depends on whether Takahashi chooses to defeat it or not, and whether the number of defeated monsters is even or odd. To encounter the first \\(i\\) monsters and defeat an even number, we have two cases:\n\n1. Defeat an even number of monsters from the first \\((i-1)\\) and let the \\(i\\)-th go.\n2. Defeat an odd number of monsters from the first \\((i-1)\\) and defeat the \\(i\\)-th.\n\nThus, we can find \\(dp_{even}[i]\\) as \n\\[\ndp_{even}[i]=\\max(dp_{even}[i-1],dp_{odd}[i-1]+2A_i).\n\\]\n\nSimilarly, \\(dp_{odd}[i]\\) is\n\\[\ndp_{odd}[i]=\\max(dp_{odd}[i-1],dp_{even}[i-1]+A_i).\n\\]\n\nThe final answer is \\(\\max(dp_{even}[N],dp_{odd}[N])\\), with a complexity of \\(O(N)\\).\n\nSample code in Python:\n```python\nINF = 10**18\n\ndef main():\n    n = int(input())\n    dp0, dp1 = 0, -INF\n    for _ in range(n):\n        x = int(input())\n        tmp = dp0\n        dp0 = max(dp1 + 2*x, dp0)\n        dp1 = max(tmp + x, dp1)\n    print(max(dp0, dp1))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["arc179_b", "abc364_d", "abc369_d"]}, "abc335_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), a non-negative integer \\( C \\), and an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nFind \\( \\displaystyle \\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace \\).\n\n**Constraints**\n\n- \\( 1 \\le N \\le 10^5 \\)\n- \\( 1 \\le M \\le 10^9 \\)\n- \\( 0 \\le C < M \\)\n- \\( 1 \\le K \\le 10^9 \\)\n- \\( 0 \\le A_i < M \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M C K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 5 3 3\n1 3\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nFor \\( k=0 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=3 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=1 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=1 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=1 \\).\n\nFor \\( k=2 \\), \\( \\lbrace(3k+1) \\ \\mathrm{mod} \\ 5 \\rbrace=2 \\) and \\( \\lbrace(3k+3) \\ \\mathrm{mod} \\ 5 \\rbrace=4 \\), so \\( \\displaystyle \\min_{1\\le i\\le N}\\lbrace(Ck+A_i) \\ \\mathrm{mod} \\ M \\rbrace=2 \\).\n\nTherefore, the answer is \\( 1+1+2=4 \\). Hence, print 4.\n\n**Sample Input 2**\n\n```\n5 4 3 182\n0 3 2 1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Sample Input 3**\n\n```\n5 718 651 193855\n3 532 44 109 58\n```\n\n**Sample Output 3**\n\n```\n29484897\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 182\n\nE - Sum of Min of Mod of Linear Editorial\n\nAs a prerequisite, you need the floor_sum algorithm. This algorithm calculates \\(\\displaystyle f(n,m,a,b)=\\sum_{i=0}^{n-1}\\left\\lfloor\\frac{ai+b}m\\right\\rfloor\\) in \\(O(\\log m)\\) time.\n\nLet\u2019s assume that \\(A\\) has been sorted and duplicates removed so that \\(A_1 < A_2 < ... < A_N\\) holds. Fix \\(j\\), and let \\(S_j\\) be the set of \\(0\\le k < K\\) such that \\(\\displaystyle \\left\\{(Ck+A_j)\\ \\text{mod}\\ M\\right\\}=\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M\\right\\}\\). If \\(j\\geq 2\\), the condition for \\(k\\in S_j\\) can be rephrased as \\(\\left\\{(Ck+A_{j-1})\\ \\text{mod}\\ M \\right\\} > \\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\), and further as \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor=1\\). Since \\(\\displaystyle \\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\) can only be \\(0\\) or \\(1\\), we have \\(\\displaystyle |S_j|=\\sum_{k=0}^{K-1}\\left(\\left\\lfloor\\frac{Ck+A_{j}}{M} \\right\\rfloor-\\left\\lfloor\\frac{Ck+A_{j-1}}{M} \\right\\rfloor\\right)\\).\n\nTherefore,\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{k \\in S_j}\\left(\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\} - \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}\\right)\\\\\n&=\\sum_{k \\in S_j} (A_j-A_1-M)\\\\\n&=-(M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\nMeanwhile, for \\(j=1\\), we have\n\\[\n\\sum_{k\\in S_j}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}-\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=0\n\\]\n\nThus, the answer is\n\\[\n\\begin{aligned}\n&\\phantom{=}\\sum_{k=0}^{K-1}\\min_{1\\le i\\le N}\\left\\{(Ck+A_i)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k\\in S_j}\\left\\{(Ck+A_j)\\ \\text{mod}\\ M \\right\\}\\\\\n&=\\sum_{j=1}^N\\sum_{k \\in S_j} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\} -\\sum_{j=2}^N(M+A_1-A_j)|S_j|\\\\\n&=\\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}-\\sum_{j=2}^N (M+A_1-A_j)|S_j|\n\\end{aligned}\n\\]\n\n\\(\\displaystyle \\sum_{k=0}^{K-1} \\left\\{(Ck+A_1)\\ \\text{mod}\\ M \\right\\}=\\sum_{k=0}^{K-1}\\left(Ck+A_1-M\\left\\lfloor\\frac{Ck+A_1}M \\right\\rfloor\\right)\\) and \\(|S_j|\\) can both be calculated quickly using the floor_sum algorithm.\n\nNow, the problem is solved. The complexity is \\(O(N(\\log N+\\log M))\\), with the bottlenecks being the sorting of \\(A\\) and the calculation of floor_sum. Be careful with overflow during implementation. You can avoid this issue by using multi-precision integers, 128-bit integers, or by using a modint with two different primes (e.g., \\(10^9+7\\) and \\(10^9+9\\)) and reconstructing the result using CRT. Alternatively, you can use a type like C++\u2019s unsigned long long, which guarantees that the correct value modulo \\(2^{64}\\) is returned even in case of overflow. The AtCoder Library\u2019s floor_sum uses unsigned long long and guarantees the correct answer modulo \\(2^{64}\\).\n\nSample Implementation (Python3):\n```python\nfrom atcoder.math import floor_sum\nn, m, c, k = map(int, input().split())\na = sorted(list(set(map(int, input().split()))))\nn = len(a)\nfl = [floor_sum(k, m, c, a[i]) for i in range(n)]\nans = c * k * (k - 1) // 2 + k * a[0] - m * fl[0]\nfor i in range(1, n):\n  ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\nprint(ans)\n```\n\nSample Implementation (Python3, translated from C++):\n```python\nfrom atcoder.math import floor_sum\n\ndef main():\n    n, m, c, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a = list(dict.fromkeys(a))\n    n = len(a)\n    fl = [floor_sum(k, m, c, a[i]) for i in range(n)]\n    ans = k * (k - 1) // 2 * c + k * a[0] - m * fl[0]\n    for i in range(1, n):\n        ans -= (m + a[0] - a[i]) * (fl[i] - fl[i - 1])\n    print(ans)\n\nmain()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nA mayoral election is being held in AtCoder City. The candidates are Takahashi and Aoki. There are \\( N \\) valid votes cast for either of the two candidates, and the counting is currently underway. Here, \\( N \\) is an odd number. The current vote count is \\( T \\) votes for Takahashi and \\( A \\) votes for Aoki. Determine if the outcome of the election is already decided at this point.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 99 \\)\n- \\( N \\) is an odd number.\n- \\( 0 \\leq T, A \\leq N \\)\n- \\( T + A \\leq N \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from standard input in the following format:\n\n```\nN T A\n```\n\n**Output**\n\nPrint `Yes` if the outcome of the election is already decided, and `No` otherwise.\n\n**Sample Input 1**\n\n```\n7 4 2\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nEven if the remaining one vote goes to Aoki, Takahashi will still win. That is, his victory is decided, so print `Yes`.\n\n**Sample Input 2**\n\n```\n99 12 48\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nAlthough Aoki currently has more votes, Takahashi would win if he receives the remaining 39 votes. Therefore, print `No`.\n\n**Sample Input 3**\n\n```\n1 0 0\n```\n\n**Sample Output 3**\n\n```\nNo\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Here is the cleaned version with only the relevant solution content:\n\nFirst, let us consider when Takahashi\u2019s or Aoki\u2019s victory is already decided. If either candidate already has \\(\\lceil \\frac{N}{2} \\rceil\\) or more votes, then the other never wins even if he gets the remaining. Conversely, if both candidates do not have \\(\\lceil \\frac{N}{2} \\rceil\\) votes yet, then both may win, so the winner is not confirmed yet.\n\nImplement this condition in an if statement. Determine if \\(T \\geq \\lceil \\frac{N}{2} \\rceil\\) or \\(A \\geq \\lceil \\frac{N}{2} \\rceil \\). In most programming languages, \\(N / 2\\) is a floor division. If you want to find \\( \\lceil \\frac{N}{2} \\rceil \\), evaluate \\((N + 1) / 2\\).\n\nSample code (Python3):\n```python\nn, t, a = map(int, input().split())\nif a >= (n+1)//2 or t >= (n+1)//2:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nIn the Kingdom of AtCoder, the eldest son is always given the name Taro. No one else is given the name Taro. The eldest son is the earliest born male child in each family.\n\nThere are \\(N\\) families in the Kingdom, and \\(M\\) babies were born. Before the \\(M\\) babies were born, none of the \\(N\\) families had had any babies.\n\nInformation about the babies is given in chronological order of their birth. The \\(i\\)-th baby born was born in family \\(A_i\\), and the baby is male if \\(B_i\\) is \\(M\\), and female if it is \\(F\\).\n\nDetermine for each of the \\(M\\) babies whether the name given is Taro.\n\nConstraints:\n- \\(1 \\leq N, M \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- \\(B_i\\) is \\(M\\) or \\(F\\).\n- All numbers in the input are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\nOutput:\nPrint \\(M\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq M)\\) should contain `Yes` if the name given to the \\(i\\)-th baby is Taro, and `No` otherwise.\n\nSample Input 1:\n```\n2 4\n1 M\n1 M\n2 F\n2 M\n```\n\nSample Output 1:\n```\nYes\nNo\nNo\nYes\n```\n\nExplanation of Sample Output 1:\n- The first baby is the earliest born boy in family 1, so he is named Taro.\n- The second baby is not the earliest born boy in family 1, so he is not named Taro.\n- The third baby is a girl, so she is not named Taro.\n- The fourth baby is the earliest born **boy** in family 2, so he is named Taro. Note that the third baby is also born in family 2, but it is the earliest born boy who is named Taro.\n\nSample Input 2:\n```\n4 7\n2 M\n3 M\n1 F\n4 F\n4 F\n1 F\n2 M\n```\n\nSample Output 2:\n```\nYes\nYes\nNo\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Beginner Contest 371\n\nB - Taro Editorial by en_translator\n\nMaintain a flag to manage whether each family had had Taro already. The flags are initialized with False. Inspect the babies in order. If the baby is a girl, print No, and nothing more is required. If the baby is a boy, check the flag of his family. If the flag is False, print Yes, and set the flag to True. If the flag is already True, print No. The operations so far can be implemented with for statements, if statements, and arrays.\n\nSample code (Python):\n```python\nn, m = map(int, input().split())\ntaro_exist = [False for i in range(n)]\nfor i in range(m):\n    a, b = input().split()\n    a = int(a) - 1\n    if b == 'F' or taro_exist[a]:\n        print('No')\n    else:\n        taro_exist[a] = True\n        print('Yes')\n```\n\n[END TEXT]\n \n\n", "problem_ids": ["arc182_e", "abc366_a", "abc371_b"]}, "abc335_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( A \\). You will perform the following operations:\n\n1. Generate \\( N \\) real numbers uniformly at random between 0 and 1, inclusive. All generations are independent, and the random numbers are uniformly distributed.\n   \n2. Call the generated \\( N \\) real numbers \\( x_1, x_2, \\ldots, x_N \\) in ascending order. That is, \\( 0 \\leq x_1 \\leq x_2 \\leq \\ldots \\leq x_N \\leq 1 \\).\n\n3. Your score is given by the following formula:\n\n   \\[\n   \\prod_{i=1}^{N} \\left(1 + \\sum_{j=i+1}^N x_j^A \\right)\n   \\]\n\nCalculate the expected value, modulo \\( 10^9+7 \\), of the score.\n\n**Definition of expected value modulo \\( 10^9+7 \\)**\n\nIt can be proved that the sought expected value is always rational. Furthermore, under the constraints of this problem, it can be proved that if the expected value is expressed as an irreducible fraction \\(\\frac{P}{Q}\\), then \\( Q \\not\\equiv 0 \\pmod{10^9+7} \\). Therefore, there exists a unique integer \\( R \\) such that \\( R \\times Q \\equiv P \\pmod{10^9+7} \\) and \\( 0 \\leq R < 10^9+7 \\). Report this \\( R \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq A \\leq 5 \\times 10^4 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1\n```\n\n**Sample Output 1**\n\n```\n666666673\n```\n\nThe expected value of the score is \\( \\frac{5}{3} \\).\n\n**Sample Input 2**\n\n```\n1 1\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\n**Sample Input 3**\n\n```\n2 2\n```\n\n**Sample Output 3**\n\n```\n500000005\n```\n\n**Sample Input 4**\n\n```\n3 2\n```\n\n**Sample Output 4**\n\n```\n142857147\n```\n\n**Sample Input 5**\n\n```\n5 3\n```\n\n**Sample Output 5**\n\n```\n758371066\n```\n\n**Sample Input 6**\n\n```\n10000 12345\n```\n\n**Sample Output 6**\n\n```\n32201773\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Let \\(a_n(y)\\) be the expected value for a real number \\(y\\) (\\(0 \\leq y \\leq 1\\)) and a non-negative integer \\(n\\). Generate \\(n\\) real numbers within \\([0,1]\\) as \\(x_1, \\cdots, x_n\\). If \\(x_1 < \\cdots < x_n < y\\) is not satisfied, output \\(0\\). If they are in ascending order, output \\(\\prod_{1 \\leq i \\leq n} (y^A + \\sum_{i < j \\leq n} x_j^A)\\).\n\nDefine \\(f(y,x) = \\sum_{0 \\leq n} a_n(y)x^n\\). \\(a_n(y)\\) is a polynomial in \\(y\\), and \\(f\\) is a formal power series. We aim to find \\(N! [x^N]f(1,x)\\). Consider choosing one term from \\(y^A, x_{i+1}^A, \\cdots x_N^A\\) for each \\(i\\) and calculating their product, forming a tree. We draw arrows based on choices: from \\(i\\) to \\(j\\) for \\(x_j^A\\), and \\(i\\) to * for choosing \\(y^A\\). This setup reveals an equation for \\(f\\), decomposed into subproblems for each subtree. The weight of a subtree rooted at child \\(v\\) is \\(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt\\).\n\nIf * has \\(k\\) children, subtrees are ordered and multiplied by \\(1/k!\\). Thus, \\(f\\) satisfies: \\(f(y,x) = \\exp(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt)\\). \\(a_n(y)\\) is a polynomial and a constant multiple of \\(y^{(A+1)n}\\). Write \\(g(z) = f(x,y)\\) with \\(z = y^{A+1}x\\) using power series \\(g(z) = \\sum_{0 \\leq n} b_n z^n\\). Rewrite \\(f\\) for \\(g\\): \\(g(z) = \\exp(\\sum_{0 \\leq n} \\frac{b_n}{(A+1)n+1} z^{n+1})\\).\n\nLet \\(h(z)\\) be inside \\(\\exp\\). Knowing \\([z^n] g\\) allows calculation of \\([z^{n+1}] h(z)\\) and \\([z^{n+1}] g(z)\\). The coefficients of \\(g\\) can be determined in order. Calculate \\([z^{n+1}] g(z)\\) using \\(\\frac{d}{dz}g = \\frac{d}{dz}\\exp(h) = \\frac{d}{dz}h \\times g\\), achievable in \\(O(n)\\). Solve the problem in \\(O(N^2)\\) time overall.\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a weighted undirected graph \\( G \\) with \\( N \\) vertices, numbered from 1 to \\( N \\). Initially, the graph \\( G \\) has no edges.\n\nYou will perform \\( M \\) operations to add edges to the graph \\( G \\). The \\( i \\)-th operation \\((1 \\leq i \\leq M)\\) is as follows:\n\n- You are given a subset of vertices \\( S_i = \\{ A_{i,1}, A_{i,2}, \\dots, A_{i,K_i} \\} \\) consisting of \\( K_i \\) vertices.\n- For every pair of vertices \\( u, v \\) such that \\( u, v \\in S_i \\) and \\( u < v \\), add an edge between vertices \\( u \\) and \\( v \\) with weight \\( C_i \\).\n\nAfter performing all \\( M \\) operations, determine whether the graph \\( G \\) is connected. If it is connected, find the total weight of the edges in a minimum spanning tree of \\( G \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq K_i \\leq N \\)\n- \\( \\sum_{i=1}^{M} K_i \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq A_{i,1} < A_{i,2} < \\dots < A_{i,K_i} \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nK_1 C_1\nA_{1,1} A_{1,2} \\dots A_{1,K_1}\nK_2 C_2\nA_{2,1} A_{2,2} \\dots A_{2,K_2}\n...\nK_M C_M\nA_{M,1} A_{M,2} \\dots A_{M,K_M}\n```\n\n**Output Format**\n\nIf the graph \\( G \\) is not connected after all \\( M \\) operations, print `-1`. If \\( G \\) is connected, print the total weight of the edges in a minimum spanning tree of \\( G \\).\n\nSolution:\n\n\n[BEGIN TEXT]\nOne of the algorithms to find the spanning tree is Kruskal\u2019s algorithm. Starting from a state where no edge is added to the graph, inspect the edges in ascending order of weight. If the edge currently being inspected between vertices \\(u\\) and \\(v\\) is not connected yet, add it to the graph. By managing the connectivity of the graph using a data structure like Disjoint Set Union (DSU), the algorithm runs in a total of \\(O(E\\log E)\\) time, where sorting is the bottleneck. (\\(E\\) is the number of edges.)\n\nIn this problem, there are at most \\(O((\\sum K)^2)\\) edges, making it infeasible to apply the algorithm directly within the time limit. Instead, we use the following property about the minimum spanning tree: if there is an edge \\(e=(u,v)\\) that satisfies the condition where there exists a path connecting vertex \\(u\\) and vertex \\(v\\) consisting of edges with weights not greater than that of edge \\(e\\), but not containing edge \\(e\\), removing edge \\(e\\) from the candidates does not change the total weight of the minimum spanning tree.\n\nThis is due to the behavior of Kruskal's algorithm. On edge \\(e\\)\u2019s turn, \\(u\\) and \\(v\\) are already connected, so edge \\(e\\) is never used. In this problem, the edges added are: an edge of weight \\(C_i\\) connecting vertices \\(u\\) and \\(v\\) for all pairs of different vertices contained in \\(\\lbrace A_{i,1},A_{i,2},\\dots,A_{i,K_i}\\rbrace\\).\n\nBy the property above, we find it sufficient to add only the following edges: an edge of weight \\(C_i\\) connecting vertices \\(A_{i,1}\\) and \\(A_{i,j}\\) for each \\(j=2,3,\\dots,K_i\\). This modification reduces the total number of edges to \\(O(\\sum K)\\), making it feasible to apply Kruskal\u2019s algorithm to solve the problem.\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nFor a positive integer \\( N \\), let \\( V_N \\) be the integer formed by concatenating \\( N \\) exactly \\( N \\) times. More precisely, consider \\( N \\) as a string, concatenate \\( N \\) copies of it, and treat the result as an integer to get \\( V_N \\). For example, \\( V_3 = 333 \\) and \\( V_{10} = 10101010101010101010 \\).\n\nFind the remainder when \\( V_N \\) is divided by \\( 998244353 \\).\n\n**Constraints**:\n- \\( 1 \\leq N \\leq 10^{18} \\)\n- \\( N \\) is an integer.\n\n**Input**:\nThe input is given from Standard Input in the following format:\n```\nN\n```\n\n**Output**:\nPrint the remainder when \\( V_N \\) is divided by \\( 998244353 \\).\n\n**Sample Input 1**:\n```\n5\n```\n\n**Sample Output 1**:\n```\n55555\n```\nThe remainder when \\( V_5 = 55555 \\) is divided by \\( 998244353 \\) is \\( 55555 \\).\n\n**Sample Input 2**:\n```\n9\n```\n\n**Sample Output 2**:\n```\n1755646\n```\nThe remainder when \\( V_9 = 999999999 \\) is divided by \\( 998244353 \\) is \\( 1755646 \\).\n\n**Sample Input 3**:\n```\n10000000000\n```\n\n**Sample Output 3**:\n```\n468086693\n```\nNote that the input may not fit into a 32-bit integer type.\n\nSolution:\n\n```python\nfrom sys import stdin\n\nmod = 998244353\n\ndef modinv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef main():\n    n = int(stdin.readline())\n    x = n\n    r = 1\n\n    while x:\n        x //= 10\n        r *= 10\n\n    r %= mod\n\n    r_pow_n = pow(r, n, mod)\n    inv_r_minus_1 = modinv(r - 1, mod)\n\n    ans = (n * (r_pow_n - 1) * inv_r_minus_1) % mod\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n \n\n", "problem_ids": ["arc180_f", "abc352_e", "abc357_d"]}, "abc336_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a grid with \\( H \\) rows and \\( W \\) columns. Let \\( (i, j) \\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Initially, there is one wall in each cell. After processing \\( Q \\) queries as explained below, determine the number of remaining walls.\n\nIn the \\( q \\)-th query, you are given two integers \\( R_q \\) and \\( C_q \\). A bomb is placed at \\( (R_q, C_q) \\) to destroy walls. The following process occurs:\n\n- If there is a wall at \\( (R_q, C_q) \\), destroy that wall and end the process.\n- If there is no wall at \\( (R_q, C_q) \\), destroy the first walls that appear when looking up, down, left, and right from \\( (R_q, C_q) \\). Specifically, the following four processes occur simultaneously:\n  - If there exists an \\( i < R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( i < k < R_q \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists an \\( i > R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( R_q < k < i \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists a \\( j < C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( j < k < C_q \\), destroy the wall at \\( (R_q, j) \\).\n  - If there exists a \\( j > C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( C_q < k < j \\), destroy the wall at \\( (R_q, j) \\).\n\n**Constraints:**\n\n- \\( 1 \\leq H, W \\)\n- \\( H \\times W \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq R_q \\leq H \\)\n- \\( 1 \\leq C_q \\leq W \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nH W Q\nR_1 C_1\nR_2 C_2\n...\nR_Q C_Q\n```\n\n**Output:**\n\nPrint the number of remaining walls after processing all queries.\n\n**Sample Input 1:**\n\n```\n2 4 3\n1 2\n1 2\n1 3\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- In the 1st query, \\( (R_1, C_1) = (1, 2) \\). There is a wall at \\( (1, 2) \\), so it is destroyed.\n- In the 2nd query, \\( (R_2, C_2) = (1, 2) \\). No wall at \\( (1, 2) \\), so destroy the nearest walls at \\( (2,2) \\), \\( (1,1) \\), and \\( (1,3) \\).\n- In the 3rd query, \\( (R_3, C_3) = (1, 3) \\). No wall at \\( (1, 3) \\), so destroy the nearest walls at \\( (2,3) \\) and \\( (1,4) \\).\n\nAfter all queries, two walls remain, at \\( (2, 1) \\) and \\( (2, 4) \\).\n\nSolution:\n\n        Here is a cleaned version of the text focusing on the solution:\n\n---\n\nTo solve the problem efficiently, manage the remaining walls using data structures. Use two ordered sets (such as `std::set` in C++):\n\n1. `g1`: An array where each element is an ordered set maintaining column indices of the remaining walls in each row.\n2. `g2`: An array where each element is an ordered set maintaining row indices of the remaining walls in each column.\n\nBy utilizing binary search in these ordered sets (using `set::lower_bound`), each query can be processed in \\(\\mathrm{O}(\\log H + \\log W)\\) time. The overall time complexity for solving the problem is \\(\\mathrm{O}((HW + Q)(\\log H + \\log W))\\).\n\nSample Python3 code demonstrates this approach:\n\n```python\nimport sys\nfrom sortedcontainers import SortedSet\n\ninput = sys.stdin.read\ndata = input().split()\n\nH = int(data[0])\nW = int(data[1])\nQ = int(data[2])\nindex = 3\n\ng1 = [SortedSet() for _ in range(H)]\ng2 = [SortedSet() for _ in range(W)]\n\nfor i in range(H):\n    for j in range(W):\n        g1[i].add(j)\n        g2[j].add(i)\n\ndef erase(i, j):\n    g1[i].discard(j)\n    g2[j].discard(i)\n\nfor _ in range(Q):\n    R = int(data[index]) - 1\n    C = int(data[index + 1]) - 1\n    index += 2\n\n    if C in g1[R]:\n        erase(R, C)\n        continue\n\n    # up\n    it = g2[C].bisect_left(R)\n    if it > 0:\n        erase(g2[C][it - 1], C)\n    # down\n    if it < len(g2[C]):\n        erase(g2[C][it], C)\n    # left\n    it = g1[R].bisect_left(C)\n    if it > 0:\n        erase(R, g1[R][it - 1])\n    # right\n    if it < len(g1[R]):\n        erase(R, g1[R][it])\n\nans = sum(len(row) for row in g1)\nprint(ans)\n```\n\n---\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi will encounter \\( N \\) monsters in order. The \\( i \\)-th monster \\((1 \\leq i \\leq N)\\) has a strength of \\( A_i \\).\n\nFor each monster, he can choose to either let it go or defeat it. Each action awards him experience points as follows:\n- If he lets a monster go, he gains 0 experience points.\n- If he defeats a monster with strength \\( X \\), he gains \\( X \\) experience points. If it is an even-numbered defeated monster (2nd, 4th, ...), he gains an additional \\( X \\) experience points.\n\nFind the maximum total experience points he can gain from the \\( N \\) monsters.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the maximum total experience points he can gain from the \\( N \\) monsters as an integer.\n\n**Sample Input 1:**\n```\n5\n1 5 3 2 7\n```\n\n**Sample Output 1:**\n```\n28\n```\n\n**Explanation:**\n\nIf Takahashi defeats the 1st, 2nd, 3rd, and 5th monsters, and lets the 4th monster go, he gains experience points as follows:\n- Defeats a monster with strength \\( A_1 = 1 \\). He gains 1 experience point.\n- Defeats a monster with strength \\( A_2 = 5 \\). He gains 5 experience points. As it is the 2nd defeated monster, he gains an additional 5 points.\n- Defeats a monster with strength \\( A_3 = 3 \\). He gains 3 experience points.\n- Lets the 4th monster go. Takahashi gains no experience points.\n- Defeats a monster with strength \\( A_5 = 7 \\). He gains 7 experience points. As it is the 4th defeated monster, he gains an additional 7 points.\n\nTherefore, in this case, he gains \\( 1+(5+5)+3+0+(7+7)=28 \\) experience points. Note that even if he encounters a monster, if he lets it go, it does not count as defeated. He can gain at most 28 experience points no matter how he acts, so print 28. As a side note, if he defeats all monsters in this case, he would gain \\( 1+(5+5)+3+(2+2)+7=25 \\) experience points.\n\n**Sample Input 2:**\n```\n2\n1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n3000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 369\n\nD - Bonus EXP Editorial\n\nThis problem can be solved with dynamic programming (DP). Let \\(dp_{even}[k]\\) be the maximum total experience point when defeating an even number of monsters out of the first \\(k\\) monsters encountered, and \\(dp_{odd}[k]\\) be that for an odd number of monsters (or \\(-\\infty\\) if it is impossible). Initially, \\(dp_{even}[0]=0\\) and \\(dp_{odd}[0]=-\\infty\\).\n\nFor \\(1\\leq i\\leq N\\), the experience point from the \\(i\\)-th monster depends on whether Takahashi chooses to defeat it or not, and whether the number of defeated monsters is even or odd. To encounter the first \\(i\\) monsters and defeat an even number, we have two cases:\n\n1. Defeat an even number of monsters from the first \\((i-1)\\) and let the \\(i\\)-th go.\n2. Defeat an odd number of monsters from the first \\((i-1)\\) and defeat the \\(i\\)-th.\n\nThus, we can find \\(dp_{even}[i]\\) as \n\\[\ndp_{even}[i]=\\max(dp_{even}[i-1],dp_{odd}[i-1]+2A_i).\n\\]\n\nSimilarly, \\(dp_{odd}[i]\\) is\n\\[\ndp_{odd}[i]=\\max(dp_{odd}[i-1],dp_{even}[i-1]+A_i).\n\\]\n\nThe final answer is \\(\\max(dp_{even}[N],dp_{odd}[N])\\), with a complexity of \\(O(N)\\).\n\nSample code in Python:\n```python\nINF = 10**18\n\ndef main():\n    n = int(input())\n    dp0, dp1 = 0, -INF\n    for _ in range(n):\n        x = int(input())\n        tmp = dp0\n        dp0 = max(dp1 + 2*x, dp0)\n        dp1 = max(tmp + x, dp1)\n    print(max(dp0, dp1))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n## Problem Statement\n\nSnuke is planning to build a maze as a new attraction in AtCoder Land. The maze is represented as a grid with \\( N \\) rows and \\( M \\) columns, with the top edge of the top-right cell being the entrance and the bottom edge of the bottom-right cell being the exit. He will create the maze by appropriately placing walls between adjacent cells.\n\nHe loves simple mazes, so he wants the path from the entrance to the exit to pass through exactly \\( K \\) cells without any branches. Determine if it is possible to create such a maze, and if possible, construct one.\n\nFor example, in the following figure, \\( N = 3 \\) and \\( M = 3 \\), and walls are placed at the solid lines (walls are always placed around the outer perimeter except for the entrance and exit). In this case, the path from the entrance to the exit passes through exactly 7 cells without any branches.\n\n### Formal Statement\n\nThere is a grid with \\( N \\) rows and \\( M \\) columns. Let \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. For each pair of side-adjacent cells, you can decide whether to place a wall between them. Determine whether it is possible to place walls to satisfy the following condition, and if it is possible, construct one such placement.\n\n**Condition**: There exists a simple path with \\( K \\) vertices that connects the two vertices \\((1, M)\\) and \\((N, M)\\), and the connected component containing the vertices \\((1, M)\\) and \\((N, M)\\) consists only of this path.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 100 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 1 \\leq K \\leq NM \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\n```\n\n### Output\n\nIf there is no placement of walls that satisfies the condition, print `No`. Otherwise, print one such placement in the following format. If multiple valid placements exist, any of them can be printed.\n\n**See also the sample outputs below to better understand the complicated output format.**\n\n```\nYes\n+++++ \\dots +++S+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n\\vdots\n+o?o? \\dots ?o?o+\n+?+?+ \\dots +?+?+\n+o?o? \\dots ?o?o+\n+++++ \\dots +++G+\n```\n\nHere, `S`, `G`, `+`, and `o` represent the entrance, exit, a wall, and a cell, respectively, and `?` between cells represents a position where a wall can be placed. Replace `?` between two horizontally adjacent cells with `|` if a wall is placed, and `.` otherwise. Replace `?` between two vertically adjacent cells with `-` if a wall is placed, and `.` otherwise.\n\n**Formal Instruction:**\n\n- The output should consist of \\( 2N+2 \\) lines.\n  - Line 1 should contain the string `Yes`.\n  - Lines 2 to \\( 2N+2 \\) should contain strings of length \\( 2M+1 \\) as described below:\n    - Line 2 should be a concatenation of `+` repeated \\( 2M-1 \\) times, `S`, and `+`, in this order.\n    - Line \\( 1+2i \\) (\\( 1 \\leq i \\leq N \\)) should be a concatenation of `+`, `o`, \\( c_{i,1} \\), `o`, \\( c_{i,2} \\), \\(\\dots\\), \\( c_{i,M-1} \\), `o`, `+`, in this order. Here, \\( c_{i,j} \\) is `|` if a wall is placed between cells \\((i,j)\\) and \\((i,j+1)\\), and `.` otherwise.\n    - Line \\( 2+2i \\) (\\( 1 \\leq i \\leq N-1 \\)) should be a concatenation of `+`, \\( r_{i,1} \\), `+`, \\( r_{i,2} \\), `+`, \\(\\dots\\), `+`, \\( r_{i,M} \\), `+`, in this order. Here, \\( r_{i,j} \\) is `-` if a wall is placed between cells \\((i,j)\\) and \\((i+1,j)\\), and `.` otherwise.\n    - Line \\( 2N+2 \\) should be a concatenation of `+` repeated \\( 2M-1 \\) times, `G`, and `+`, in this order.\n\n### Sample Input 1\n\n```\n3 3 7\n```\n\n### Sample Output 1\n\n```\nYes\n+++++S+\n+o.o.o+\n+.+-+-+\n+o.o.o+\n+-+-+.+\n+o.o|o+\n+++++G+\n```\n\nThis is the same placement of walls as in the figure in the problem statement.\n\n### Sample Input 2\n\n```\n3 3 2\n```\n\n### Sample Output 2\n\n```\nNo\n```\n\n### Sample Input 3\n\n```\n4 1 4\n```\n\n### Sample Output 3\n\n```\nYes\n+S+\n+o+\n+.+\n+o+\n+.+\n+o+\n+.+\n+o+\n+G+\n```\n\nSolution:\n\n```python\n        Editorial - AtCoder Beginner Contest 358\n\nF - Easiest Maze Editorial by en_translator\n\nFor what kind of \\(K\\) does the solution exist? Obviously, \\(K\\geq N\\) is required, considering the length of the shortest path between squares \\((1,M)\\) and \\((N,M)\\). Let's draw the grid in a checkered pattern:\n\nAny path visits red square \\(\\rightarrow\\) blue square \\(\\rightarrow\\) red square \\(\\rightarrow\\dots\\). The color parity of squares \\((1,M)\\) and \\((N,M)\\) depends on \\(N\\). Thus, \\(N\\) and \\(K\\) must have the same parity. If \\(N\\) is even, the path ends with an even number of vertices. If \\(K\\geq N\\) and parities are the same, a solution can always be constructed. Starting from the path of the shortest length \\(N\\), increase the length by \\(2\\) incrementally, as \\(N, N+2, N+4, \\dots\\).\n\nImplement carefully with some casework. Use casework and construction separately. The sample code outlines how to compute the sequence of squares, build walls, and remove those between adjacent squares.\n\nSample code (Python 3):\n```python\ndef main():\n    n, m, k = map(int, input().split())\n    if k < n or k % 2 != n % 2:\n        print(\"No\")\n        return\n    print(\"Yes\")\n    path = []\n    k -= n\n    i = 0\n    while i < n - 1:\n        if i != n - 3:\n            w = 1 + min(m - 1, k // 2)\n            k -= (w - 1) * 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n        elif k <= (m - 1) * 2:\n            w = 1 + k // 2\n            for j in range(w):\n                path.append((i, m - 1 - j))\n            for j in range(w):\n                path.append((i + 1, m - w + j))\n            path.append((i + 2, m - 1))\n        else:\n            for j in range(m):\n                path.append((i, m - 1 - j))\n            k -= (m - 1) * 2\n            j = 0\n            while j < m:\n                if k:\n                    path.append((i + 1, j))\n                    path.append((i + 2, j))\n                    path.append((i + 2, j + 1))\n                    path.append((i + 1, j + 1))\n                    j += 2\n                    k -= 2\n                else:\n                    path.append((i + 1, j))\n                    j += 1\n            path.append((i + 2, m - 1))\n        i += 2\n    \n    c = [['|' for _ in range(m - 1)] for _ in range(n)]\n    r = [['-' for _ in range(m)] for _ in range(n - 1)]\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i + 1]\n        if x1 == x2:\n            c[x1][min(y1, y2)] = '.'\n        else:\n            r[min(x1, x2)][y1] = '.'\n    \n    print('+' + 'S'.join([''] + ['-' * (2 * m - 1), '+']))\n    for i in range(n):\n        print('+', end='')\n        for j in range(m - 1):\n            print('o' + c[i][j], end='')\n        print(\"o+\")\n        if i < n - 1:\n            for j in range(m):\n                print('+' + r[i][j], end='')\n            print('+')\n    print('+' + 'G'.join([''] + ['-' * (2 * m - 1), '+']))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc370_d", "abc369_d", "abc358_f"]}, "abc336_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are trying to implement collision detection in a 3D game.\n\nIn a 3-dimensional space, let \\( C(a,b,c,d,e,f) \\) denote the cuboid with a diagonal connecting \\((a,b,c)\\) and \\((d,e,f)\\), with all faces parallel to the xy-plane, yz-plane, or zx-plane. This definition uniquely determines \\( C(a,b,c,d,e,f) \\).\n\nGiven two cuboids \\( C(a,b,c,d,e,f) \\) and \\( C(g,h,i,j,k,l) \\), determine whether their intersection has a positive volume.\n\n**Constraints**\n\n- \\( 0 \\leq a < d \\leq 1000 \\)\n- \\( 0 \\leq b < e \\leq 1000 \\)\n- \\( 0 \\leq c < f \\leq 1000 \\)\n- \\( 0 \\leq g < j \\leq 1000 \\)\n- \\( 0 \\leq h < k \\leq 1000 \\)\n- \\( 0 \\leq i < l \\leq 1000 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from standard input in the following format:\n\n```\na b c d e f\ng h i j k l\n```\n\n**Output**\n\nPrint `Yes` if the intersection of the two cuboids has a positive volume, and `No` otherwise.\n\n**Sample Input 1**\n```\n0 0 0 4 5 6\n2 3 4 5 6 7\n```\n\n**Sample Output 1**\n```\nYes\n```\nThe positional relationship of the two cuboids is shown in the figure below, and their intersection has a volume of 8.\n\n**Sample Input 2**\n\n```\n0 0 0 2 2 2\n0 0 2 2 2 4\n```\n\n**Sample Output 2**\n```\nNo\n```\nThe two cuboids touch at a face, where the volume of the intersection is 0.\n\n**Sample Input 3**\n```\n0 0 0 1000 1000 1000\n10 10 10 100 100 100\n```\n\n**Sample Output 3**\n```\nYes\n```\n\nSolution:\n\n```\nHere is a cleaned version of the editorial:\n\nOfficial Editorial: B - Intersection of Cuboids\n\nLet \\([x,y]\\) denote the segment formed by all real numbers between \\(x\\) and \\(y\\), inclusive. \n\n**Problem:** Determine if two segments \\([a,b]\\) and \\([c,d]\\) have an intersection of a positive length. The length of intersection is \\(0\\) for one of the following cases:\n\n- \\([a,b]\\) is to the left of \\([c,d]\\).\n- \\([a,b]\\) is to the right of \\([c,d]\\).\n\nIn Pythonic pseudocode:\n```python\nif b <= c or d <= a:\n    print(\"0 intersection\")\nelse:\n    print(\"positive intersection\")\n```\n\nFor a three-dimensional problem, solve the one-dimensional problem for the three coordinates \\(x\\), \\(y\\), and \\(z\\). If the length of intersection for all coordinates is positive, the intersection of the cuboids has a positive volume; otherwise, it is \\(0\\). \n\nPython code:\n```python\nx1, y1, z1, x2, y2, z2 = map(int, input().split())\nx3, y3, z3, x4, y4, z4 = map(int, input().split())\n\ndef f(l1, r1, l2, r2):\n    # Returns True if the intersection of [l1, r1] and [l2, r2] has a positive length\n    return not (r1 <= l2 or r2 <= l1)\n\nif f(x1, x2, x3, x4) and f(y1, y2, y3, y4) and f(z1, z2, z3, z4):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of characters \\( A \\), \\( B \\), and \\( ? \\). You are also given a positive integer \\( K \\).\n\nA string \\( T \\) consisting of \\( A \\) and \\( B \\) is considered a **good string** if it satisfies the following condition:\n\n- **No** contiguous substring of length \\( K \\) in \\( T \\) is a palindrome.\n\nLet \\( q \\) be the number of \\( ? \\) characters in \\( S \\).\n\nThere are \\( 2^q \\) strings that can be obtained by replacing each \\( ? \\) in \\( S \\) with either \\( A \\) or \\( B \\). Find how many of these strings are good strings.\n\nThe count can be very large, so find it modulo \\( 998244353 \\).\n\n### Constraints\n- \\( 2 \\leq K \\leq N \\leq 1000 \\)\n- \\( K \\leq 10 \\)\n- \\( S \\) is a string consisting of \\( A \\), \\( B \\), and \\( ? \\).\n- The length of \\( S \\) is \\( N \\).\n- \\( N \\) and \\( K \\) are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nS\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n7 4\nAB?A?BA\n```\n\n### Sample Output 1\n```\n1\n```\n\n*Explanation:*\n\nThe given string has two \\( ? \\)s. There are four strings obtained by replacing each \\( ? \\) with \\( A \\) or \\( B \\):\n\n- `ABAAABA`\n- `ABAABBA`\n- `ABBAABA`\n- `ABBABBA`\n\nAmong these, the last three contain the contiguous substring `ABBA` of length 4, which is a palindrome, and thus are not good strings.\n\nTherefore, you should print `1`.\n\n### Sample Input 2\n```\n40 7\n????????????????????????????????????????\n```\n\n### Sample Output 2\n```\n116295436\n```\n\n*Note:* Ensure to find the number of good strings modulo \\( 998244353 \\).\n\n### Sample Input 3\n```\n15 5\nABABA??????????\n```\n\n### Sample Output 3\n```\n0\n```\n\n*Explanation:* It is possible that there is no way to replace the `?`s to obtain a good string.\n\n### Sample Input 4\n```\n40 8\n?A?B??B?B?AA?A?B??B?A???B?BB?B???BA??BAA\n```\n\n### Sample Output 4\n```\n259240\n```\n\n\nSolution:\n\n```plaintext\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nD - Avoid K Palindrome Editorial by en_translator\n\nFor a string \\(T\\) consisting of A, B, and ?, define \\(\\operatorname{dp} _ T[P]\\) as follows (DP stands for Dynamic Programming):\n\nThe number of strings obtained by replacing each occurrence of ? with either A or B such that:\n\n1. It is a good string, and \n2. Its last \\(\\min\\lbrace K-1,|T|\\rbrace\\) characters coincide with \\(P\\).\n\nFor a string \\(T\\) consisting of A, B, and ?, suppose that \\(\\operatorname{dp} _ T[P]\\) is known for all possible \\(P\\).\nThen, if \\(\\operatorname{dp} _ {T+\\mathtt{A}}[P]\\) and \\(\\operatorname{dp} _ {T+\\mathtt{B}}[P],\\operatorname{dp} _ {T+\\mathtt{?}}[P]\\) can be found fast, then the problem can be solved using Dynamic Programming. (Here, the string \\(X\\) succeeded by a character \\(c\\) is denoted by \\(X+c\\)).\n\nLet us consider an algorithm to find \\(\\operatorname{dp} _ {T+\\mathtt A}\\) from \\(\\operatorname{dp} _ T\\). (Same applies to B, and for ? we can take their sum.)\n\nInitially, initialize \\(\\operatorname{dp} _ {T+\\mathtt A}[P]=0\\) for all \\(P\\).\nFor all possible \\(P\\), do the following:\n\nIf \\(P+\\mathtt A\\) is a length-\\(W\\) palindrome, do nothing.\nOtherwise, let \\(P ^ \\prime\\) be the string formed by the last \\(\\min\\lbrace K-1,|P|+1\\rbrace\\) characters of \\(P+\\mathtt A\\). Add \\(\\operatorname{dp} _ T[P]\\) to \\(\\operatorname{dp} _ {T+\\mathtt A}[P ^ \\prime]\\).\n\nConsider finding \\(\\operatorname{dp} _ S\\) for the given string \\(S\\) using these values. \nEven if you spend \\(\\Theta(K)\\) time to check if a string is palindrome, the overall complexity is \\(O(2 ^ KKN)\\), which is fast enough.\n\nFor implementation, one can use a string or a non-negative integer as the key of the DP table. \nIf you use a string, the key is easy to understand, and you can also use a sentinel to evaluate the DP table for string of length less than \\(K\\), but the constant factor may be bad. \nIf you use a non-negative integer, the constant factors of the time and spatial complexity is good, but the implementation may be complicated.\n\nSample Code:\n```python\nfrom functools import reduce\n\ndef main():\n    N, K = map(int, input().split())\n    S = input()\n\n    not_palindrome = []\n    for i in range(1 << K):\n        is_palindrome = True\n        j, k = 0, K - 1\n        while j < k:\n            if ((1 & (i >> j)) != (1 & (i >> k))):\n                is_palindrome = False\n                break\n            j += 1\n            k -= 1\n        if not is_palindrome:\n            not_palindrome.append(i)\n\n    dp = [0] * (1 << (K - 1))\n    prev = [0] * (1 << (K - 1))\n    a_mask = 0\n    q_mask = 0\n    for c in S[:K - 1]:\n        a_mask = (a_mask * 2) + (c == 'A')\n        q_mask = (q_mask * 2) + (c != '?')\n\n    for i in range(q_mask, 1 << (K - 1)):\n        if i | q_mask == i:\n            dp[i ^ a_mask] = 1\n\n    mask = (1 << (K - 1)) - 1\n    for c in S[K - 1:]:\n        dp, prev = prev, [0] * (1 << (K - 1))\n        \n        if c != 'B':\n            for i in not_palindrome:\n                if ~i & 1:\n                    dp[i & mask] += prev[i // 2]\n\n        if c != 'A':\n            for i in not_palindrome:\n                if i & 1:\n                    dp[i & mask] += prev[i // 2]\n\n    print(sum(dp) % 998244353)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n```python\nN, K = map(int, input().split())\n\nS = input()\n\nmp = {'C' * (K - 1) : 1}\n\nfor c in S:\n    tmp = ({s + 'A' : v for s, v in mp.items()} if c != 'B' else {}) | ({s + 'B' : v for s, v in mp.items()} if c != 'A' else {})\n    \n    mp = {}\n    \n    for s, v in tmp.items():\n        if s != s[::-1]:\n            if s[1:] in mp:\n                mp[s[1:]] += v\n            else:\n                mp[s[1:]] = v\n\nprint(sum(mp.values()) % 998244353)\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) sequences of length \\( M \\), where each element is either 0 or 1. The \\( i \\)-th sequence is \\( A_i = (A_{i, 1}, A_{i, 2}, \\dots, A_{i, M}) \\).\n\nFor integers \\( i, j \\) \\((1 \\leq i, j \\leq N)\\), define \\( f(i, j) \\) as follows: \\( f(i, j) \\) is the smallest non-negative integer \\( x \\) such that \\( A_i \\) and \\( A_j \\) become identical after performing the following operation \\( x \\) times, or \\( 0 \\) if such \\( x \\) does not exist.\n\nOperation: For all integers \\( k \\) \\((1 \\leq k \\leq M)\\) simultaneously, replace \\( A_{i, k} \\) with \\( \\left (\\sum_{l=1}^{k} A_{i, l} \\right ) \\bmod 2 \\).\n\nFind \\( \\sum_{i=1}^{N} \\sum_{j=i}^{N} f(i, j) \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\times M \\leq 10^6 \\)\n- \\( A_{i, j} \\in \\{0, 1\\} \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1, 1} A_{1, 2} \\cdots A_{1, M}\nA_{2, 1} A_{2, 2} \\cdots A_{2, M}\n\\vdots\nA_{N, 1} A_{N, 2} \\cdots A_{N, M}\n```\n\n**Output**\n\nPrint the answer in one line.\n\n**Sample Input 1**\n\n```\n4 3\n1 0 0\n1 1 0\n1 0 1\n0 1 1\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\nExplanation: \\( f(1, 1) = 0 \\), \\( f(1, 2) = 3 \\), \\( f(1, 3) = 2 \\), \\( f(1, 4) = 0 \\), \\( f(2, 2) = 0 \\), \\( f(2, 3) = 3 \\), \\( f(2, 4) = 0 \\), \\( f(3, 3) = 0 \\), \\( f(3, 4) = 0 \\), \\( f(4, 4) = 0 \\), summing to 8.\n\n**Sample Input 2**\n\n```\n7 6\n1 0 0 0 0 0\n1 1 1 0 0 0\n1 0 1 1 0 0\n1 0 0 0 1 1\n1 0 0 0 0 1\n1 0 0 0 0 0\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n\n```\n6\n```\n\nSolution:\n\n```plaintext\nEditorial - E - Accumulating Many Times\n\nFirst, treat sequences that differ in the position of their first \\(1\\) as separate problems, since operations do not change this position. Assume \\(A_{i, 1} = 1\\). Define the inverse operation for the problem's operation. The graph formed by length-\\(M\\) binary sequences starting with \\(1\\) has operations as edges and is a collection of cycles. \n\nEvery sequence can be transformed into a \u201cstandard form\u201d where all elements at positions \\((2^x + 1)\\) using non-negative integer \\(x\\) are \\(0\\). This is proven using Lucas\u2019s theorem. Cycle length is \\(2^m\\), where \\(m\\) is the smallest non-negative integer such that \\(2^m + 1 \\leq M\\).\n\nTo solve, first transform sequences to their standard forms and calculate the required operations. For each \\(i = 1, 2, \\dots, N\\), compute the standard form of sequence \\(A_i\\) and the cost to reach it. Transform \\(A_{i, 2^x + 1}\\) into \\(0\\) by performing the operation \\(2^x\\) times if \\(A_{i, 2^x + 1} = 1\\).\n\nNext, solve for each standard form: for integer sequence \\(B\\), compute \\(\\displaystyle \\sum_{i=1}^{m} \\sum_{j=i}^{m} \\left( (B_j - B_i) \\bmod 2^m \\right)\\) using Segment Tree or similar structures.\n\nThe computational bottleneck is computing the standard forms. Multiple operations using FFT help, but we may exceed the time limit if performed every time. Instead, keep track of operations count to determine value at a position in \\(O(M)\\) time. Overall complexity is \\(O(NM \\log NM)\\).\n```\n \n\n", "problem_ids": ["abc361_b", "abc359_d", "arc184_e"]}, "abc336_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement (Score: 650 points)**\n\nWe call a positive integer \\( n \\) a \"good integer\" if and only if the sum of its positive divisors is divisible by 3. You are given two positive integers \\( N \\) and \\( M \\). Find the number, modulo 998244353, of length-\\( M \\) sequences \\( A \\) of positive integers such that the product of the elements in \\( A \\) is a good integer not exceeding \\( N \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^{10} \\)\n- \\( 1 \\leq M \\leq 10^5 \\)\n- \\( N \\) and \\( M \\) are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n10 1\n```\n\n**Sample Output 1**\n\n```\n5\n```\n\nThere are five sequences that satisfy the conditions:\n\n- (2)\n- (5)\n- (6)\n- (8)\n- (10)\n\n**Sample Input 2**\n\n```\n4 2\n```\n\n**Sample Output 2**\n\n```\n2\n```\n\nThere are two sequences that satisfy the conditions:\n\n- (1, 2)\n- (2, 1)\n\n**Sample Input 3**\n\n```\n370 907\n```\n\n**Sample Output 3**\n\n```\n221764640\n```\n\n**Sample Input 4**\n\n```\n10000000000 100000\n```\n\n**Sample Output 4**\n\n```\n447456146\n```\n\nSolution:\n\n```python\n# Here is the rewritten editorial with Python code:\n\n# Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\n# G - Divisible by 3 Editorial\n\n# This problem can be solved by finding a prefix sum of a multiplicative function. \n# A function f(n) is multiplicative if f(ab) = f(a) f(b) for all positive integers gcd(a, b) = 1.\n\n# Given a multiplicative function f(n), evaluate:\n# sum(1 <= n <= N) f(n).\n\n# **Facts and Problem Rephrasing:**\n\n# 1. sigma(n), the sum of the divisors of n, is multiplicative as per the formula:\n#    sigma(n) = prod(i=1 to k) (1 + p_i + ... + p_i^e_i)\n\n# 2. g(n), the number of length-M sequences of positive integers such that their product is M, is multiplicative:\n#    g(n) = prod(i=1 to k) comb(e_i + M - 1, M - 1)\n\n# Original problem:\n# sum(1 <= n <= N, sigma(n) % 3 = 0) g(n)\n\n# Define:\n# h(n) = \n# if sigma(n) % 3 == 0:\n#     0\n# else:\n#     g(n)\n\n# Rephrased Problem:\n# sum(n=1 to N) (g(n) - h(n))\n\n# Final expression:\n# sum(n=1 to N) g(n) - sum(n=1 to N) h(n)\n\n# There are efficient algorithms to compute these prefix sums:\n\n# **Lucy DP:**\n# Define:\n# F(n) = sum(1 <= m <= n) f(m),\n# F_prime(n) = sum(1 <= p <= n, p: prime) f(p),\n\n# Evaluate F_prime(n) for all n in Q_N using a dynamic programming approach, Lucy DP.\n\n# **Black Algorithm and Min_25 sieve:**\n# Evaluate F(N) using F_prime(n) results.\n\n# Black Algorithm: Uses a tree structure to compute F(N) leveraging the multiplicativity of the function.\n\n# Min_25 Sieve: Offers a more efficient approach with complexity O(N^(2/3)).\n\n# By implementing Lucy DP and one of the other methods, the problem is solved efficiently with complexity O(N^(3/4)/log N) or O(N^(1 - epsilon)).\n\n# **Advanced Topics:**\n\n# More efficient algorithms, like those by zhoukangyang (O(sqrt(N))) and Zhenting Zhu (Theta (N^(2/3) / (log N)^(4/3))), exist.\n# Other algorithms like Dujiao sieve or PowerfulNumber sieve can be used under specific conditions.\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:  \nIn the \\( xy \\)-plane, there are three points \\( A(x_A, y_A) \\), \\( B(x_B, y_B) \\), and \\( C(x_C, y_C) \\) that are not collinear. Determine whether the triangle \\( ABC \\) is a right triangle.\n\nConstraints:  \n- \\( -1000 \\leq x_A, y_A, x_B, y_B, x_C, y_C \\leq 1000 \\)\n- The three points \\( A \\), \\( B \\), and \\( C \\) are not collinear.\n- All input values are integers.\n\nInput:  \nThe input is given from Standard Input in the following format:\n\n```\nx_A y_A  \nx_B y_B  \nx_C y_C  \n```\n\nOutput:  \nPrint `Yes` if the triangle \\( ABC \\) is a right triangle, and `No` otherwise.\n\nSample Input 1:  \n```\n0 0  \n4 0  \n0 3  \n```\n\nSample Output 1:  \n```\nYes\n```\n\nThe triangle \\( ABC \\) is a right triangle.\n\nSample Input 2:  \n```\n-4 3  \n2 1  \n3 4  \n```\n\nSample Output 2:  \n```\nYes\n```\n\nThe triangle \\( ABC \\) is a right triangle.\n\nSample Input 3:  \n```\n2 4  \n-3 2  \n1 -2  \n```\n\nSample Output 3:  \n```\nNo\n```\n\nThe triangle \\( ABC \\) is not a right triangle.\n\nSolution:\n\n```python\nxA, yA = map(int, input().split())\nxB, yB = map(int, input().split())\nxC, yC = map(int, input().split())\n\nAB2 = (xA - xB) ** 2 + (yA - yB) ** 2\nBC2 = (xB - xC) ** 2 + (yB - yC) ** 2\nCA2 = (xC - xA) ** 2 + (yC - yA) ** 2\n\nif AB2 + BC2 == CA2 or BC2 + CA2 == AB2 or CA2 + AB2 == BC2:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 650 points\n\nProblem Statement:\nThere is a special grid with \\( N \\) rows. (\\( N \\) is even.) The \\( i \\)-th row from the top has \\(\\left \\lceil \\frac{i}{2} \\right \\rceil \\times 2\\) cells from the left end. For example, when \\( N = 6 \\), the grid looks like the following:\n\nLet \\((i, j)\\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Each cell is either an empty cell or a wall cell. There are \\( M \\) wall cells, and the \\( i \\)-th wall cell is \\((a_i, b_i)\\). Here, \\((1, 1)\\) and \\((N, N)\\) are empty.\n\nStarting from \\((1, 1)\\), how many ways are there to reach \\((N, N)\\) by repeatedly moving right or down to an adjacent empty cell? Find the count modulo 998244353.\n\nConstraints:\n- \\( 2 \\leq N \\leq 2.5 \\times 10^5 \\)\n- \\( N \\) is even.\n- \\( 0 \\leq M \\leq 50 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- \\( 1 \\leq b_i \\leq \\left \\lceil \\frac{a_i}{2} \\right \\rceil \\times 2 \\)\n- \\((a_i, b_i) \\neq (1, 1)\\) and \\((a_i, b_i) \\neq (N, N)\\).\n- \\((a_i, b_i) \\neq (a_j, b_j)\\) if \\( i \\neq j \\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\na_1 b_1\na_2 b_2\n...\na_M b_M\n```\n\nOutput:\nPrint the number of ways to reach \\((N, N)\\) from \\((1, 1)\\) by repeatedly moving right or down to an adjacent empty cell, modulo 998244353.\n\nSample Input 1:\n```\n4 2\n2 1\n4 2\n```\nSample Output 1:\n```\n2\n```\nThere are two paths that satisfy the conditions of the problem:\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (3, 4) \\to (4, 4)\\)\n- \\((1, 1) \\to (1, 2) \\to (2, 2) \\to (3, 2) \\to (3, 3) \\to (4, 3) \\to (4, 4)\\)\n\nSample Input 2:\n```\n6 3\n2 1\n3 3\n4 2\n```\nSample Output 2:\n```\n0\n```\n\nSample Input 3:\n```\n100 10\n36 9\n38 5\n38 30\n45 1\n48 40\n71 52\n85 27\n86 52\n92 34\n98 37\n```\nSample Output 3:\n```\n619611437\n```\n\nSample Input 4:\n```\n100000 10\n552 24\n4817 255\n7800 954\n23347 9307\n28028 17652\n39207 11859\n48670 22013\n74678 53158\n75345 45891\n88455 4693\n```\nSample Output 4:\n```\n175892766\n```\n\nSolution:\n\nSure, here is the editorial with all code translated to Python3:\n\n```python\ndef g(a, b):\n    \"\"\"Calculate the number of shortest paths from a to b.\"\"\"\n    # This function implementation depends on the specific grid configuration\n    pass\n\ndef calculate_dp_and_x(wall_squares, grid_size):\n    \"\"\"Calculate dp values and the sought count X using the wall squares.\"\"\"\n    S = wall_squares\n    N, M = grid_size\n    \n    # Initialize dp with base values\n    w = [(1, 1)] + S + [(N, N)]\n    dp = [0] * (len(S) + 2)\n    dp[0] = 1\n    \n    # Fill dp array according to the derived relations\n    for i in range(1, len(S) + 2):\n        dp_i_sum = sum(g(w[j], w[i]) * dp[j] for j in range(i))\n        dp[i] = -dp_i_sum\n    \n    # Calculate the sought count X\n    X = -dp[len(S) + 1]\n    \n    return X\n\n# Example usage\noriginal_wall_squares = []  # Replace with actual coordinates of original wall squares\ncalculate_dp_and_x(original_wall_squares, (N, M))\n```\n\nNote: In the provided code, `g(a, b)` is a placeholder function that needs actual implementation based on the specific problem constraints. The function `calculate_dp_and_x` calculates the dp values and the sought count `X` using the dynamic programming approach described in the editorial.\n \n\n", "problem_ids": ["abc370_g", "abc362_b", "abc357_g"]}, "abc336_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 300 points\n\n### Problem Statement\n\nPrint all integer sequences of length \\( N \\) that satisfy the following conditions, in ascending lexicographical order:\n\n1. The \\( i \\)-th element is between 1 and \\( R_i \\), inclusive.\n2. The sum of all elements is a multiple of \\( K \\).\n\nWhat is lexicographical order for sequences?\n\nA sequence \\( A = (A_1, \\ldots, A_{|A|}) \\) is lexicographically smaller than \\( B = (B_1, \\ldots, B_{|B|}) \\) if either 1. or 2. below holds:\n\n1. \\( |A| < |B| \\) and \\( (A_{1}, \\ldots, A_{|A|}) = (B_1, \\ldots, B_{|A|}) \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|A|,|B|\\} \\) such that both of the following are true:\n   - \\( (A_{1}, \\ldots, A_{i-1}) = (B_1, \\ldots, B_{i-1}) \\)\n   - \\( A_i < B_i \\)\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 8 \\)\n- \\( 2 \\le K \\le 10 \\)\n- \\( 1 \\le R_i \\le 5 \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nR_1 R_2 \\dots R_N\n```\n\n### Output\n\nPrint the answer in the following format, where \\( X \\) is the number of sequences to print, the \\( i \\)-th of which is \\( A_i = (A_{i,1}, A_{i,2}, \\dots, A_{i,N}) \\):\n\n```\nA_{1,1} A_{1,2} \\dots A_{1,N}\nA_{2,1} A_{2,2} \\dots A_{2,N}\n\u22ee\nA_{X,1} A_{X,2} \\dots A_{X,N}\n```\n\n### Sample Input 1\n\n```\n3 2\n2 1 3\n```\n\n### Sample Output 1\n\n```\n1 1 2\n2 1 1\n2 1 3\n```\n\nThere are three sequences to be printed, which are (1, 1, 2), (2, 1, 1), (2, 1, 3) in lexicographical order.\n\n### Sample Input 2\n\n```\n1 2\n1\n```\n\n### Sample Output 2\n\n```\n```\n\nThere may be no sequences to print. In this case, the output can be empty.\n\n### Sample Input 3\n\n```\n5 5\n2 3 2 3 2\n```\n\n### Sample Output 3\n\n```\n1 1 1 1 1\n1 2 2 3 2\n1 3 1 3 2\n1 3 2 2 2\n1 3 2 3 1\n2 1 2 3 2\n2 2 1 3 2\n2 2 2 2 2\n2 2 2 3 1\n2 3 1 2 2\n2 3 1 3 1\n2 3 2 1 2\n2 3 2 2 1\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 367\n\nC - Enumerate Sequences Editorial\n\nThere are \\(5^8=390625\\) sequences of length \\(8\\) consisting of integers between \\(1\\) and \\(5\\). Since the number of sequences to print is always not more than this count, we do not have to worry about too much output.\n\n**Approach 1: Use recursion to enumerate**  \n1. Fix the first element in ascending order.  \n2. Once the first element is fixed, call the recursion to fix the second element in ascending order.  \n3. Once all the elements are ready, check if the total sum is a multiple of \\(K\\) and print it.  \n\nImplementing this recursion will be accepted.\n\nSample code (Python3):\n```python\ndef solve(lv, n, k, r, seq):\n    if lv == n:\n        s = sum(seq[:n])\n        if s % k == 0:\n            print(\" \".join(map(str, seq[:n])))\n        return\n    \n    for i in range(1, r[lv] + 1):\n        seq[lv] = i\n        solve(lv + 1, n, k, r, seq)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    r = list(map(int, data[2:2 + n]))\n    seq = [0] * 8\n    solve(0, n, k, r, seq)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Approach 2: Decode integers corresponding to sequences**  \nIgnoring the condition \u201cmultiple of \\(K\\),\u201d there are \\(P=R_1 \\times R_2 \\times \\dots \\times R_N\\) possible sequences. If you decode an integer between \\(0\\) and \\(P-1\\), the results are sorted in ascending order.\n\nLet \\(S\\) be the decode result. Prepare a variable \\(x \\leftarrow t\\). For \\(i = N\\) down to \\(1\\), do the following:\n1. Let \\(S_i \\leftarrow (x \\% R_i)+1\\). Then, replace \\(x\\) with \\(\\displaystyle \\frac{x}{R_i}\\) (rounded down).\n\nIntuitively, a sequence corresponds to a special \\(N\\)-ary representation.\n\nSample code (Python3):\n```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    k = int(data[1])\n    r = list(map(int, data[2:2 + n]))\n\n    tot = 1\n    for i in range(n):\n        tot *= r[i]\n\n    for t in range(tot):\n        x = t\n        s = 0\n        seq = [0] * n\n        for i in range(n - 1, -1, -1):\n            seq[i] = (x % r[i]) + 1\n            s += seq[i]\n            x //= r[i]\n        \n        if s % k == 0:\n            print(\" \".join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere is a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i,j)\\) denote the cell at the \\(i\\)-th row from the top and \\(j\\)-th column from the left. There are \\(N\\) coins on this grid, and the \\(i\\)-th coin can be picked up by passing through the cell \\((R_i,C_i)\\).\n\nYour goal is to start from cell \\((1,1)\\), repeatedly move either down or right by one cell, and reach cell \\((H,W)\\) while picking up as many coins as possible.\n\nFind the maximum number of coins you can pick up and one of the paths that achieves this maximum.\n\nConstraints:\n- \\(2 \\leq H, W \\leq 2 \\times 10^5\\)\n- \\(1 \\leq N \\leq \\min(HW-2, 2 \\times 10^5)\\)\n- \\(1 \\leq R_i \\leq H\\)\n- \\(1 \\leq C_i \\leq W\\)\n- \\((R_i, C_i) \\neq (1,1)\\)\n- \\((R_i, C_i) \\neq (H,W)\\)\n- \\((R_i, C_i)\\) are pairwise distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format: \n```\nH W N\nR_1 C_1\nR_2 C_2\n\u22ee\nR_N C_N\n```\n\nOutput:\nPrint two lines.\n- The first line should contain the maximum number of coins you can pick up.\n- The second line should contain one of the paths that achieves this maximum as a string of length \\(H+W-2\\). The \\(i\\)-th character of this string should be `D` if the \\(i\\)-th move is downward, and `R` if it is rightward.\n\nIf there are multiple paths that maximize the number of coins picked up, you may print any of them.\n\nSample Input 1:\n```\n3 4 4\n3 3\n2 1\n2 3\n1 4\n```\n\nSample Output 1:\n```\n3\nDRRDR\n```\nAs shown in the figure above, by moving \\((1,1)\\rightarrow (2,1)\\rightarrow (2,2)\\rightarrow (2,3)\\rightarrow (3,3)\\rightarrow (3,4)\\), you can pick up three coins at \\((2,1),(2,3),(3,3)\\).\n\nSample Input 2:\n```\n2 2 2\n2 1\n1 2\n```\n\nSample Output 2:\n```\n1\nDR\n```\nThe path `RD` is also acceptable.\n\nSample Input 3:\n```\n10 15 8\n2 7\n2 9\n7 9\n10 3\n7 11\n8 12\n9 6\n8 1\n```\n\nSample Output 3:\n```\n5\nDRRRRRRRRDDDDDRRDRDDRRR\n```\n\nSolution:\n\n```\nHere is the cleaned editorial without excess content unrelated to the solution:\n\n---\n\nLet us call the coin that can be collected by passing through square \\((r,c)\\) simply coin \\((r,c)\\). Given \\(k\\) coins \\((r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)\\), one can determine if there is a path that can collect all the coins as follows:\n\nSort the coins in ascending order of \\((r,c)\\). Here, \\((r_i, c_i) < (r_j, c_j) \\Leftrightarrow (r_i < r_j) \\lor (r_i = r_j \\land c_i < c_j)\\). Let \\(((r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k))\\) be the resulting sequence. There exists a path that can collect all the given \\(k\\) coins if and only if \\(c'_1 \\leq c'_2 \\leq \\dots \\leq c'_k\\).\n\nProof: If two coins $i$ and $j$ with $(r_i, c_i) < (r_j, c_j)$ are to be collected, coin $i$ has to be collected first. Thus, the $k$ coins $(r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)$ can be all collected if and only if the $k$ coins $(r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k)$ can be collected **in this order**. Given $(r_i, c_i) < (r_j, c_j)$, we have $(r_i \\leq r_j \\land c_i \\leq c_j) \\Leftrightarrow c_i \\leq c_j$, so the claim above has been shown.\n\nSuppose that the given \\(N\\) coins are sorted in ascending order of \\((r,c)\\). Then, by the fact above, this problem is boiled down to finding a longest (weakly) increasing subsequence (LIS). Given positive integer sequence \\(c=(c_1,c_2,\\dots,c_N)\\), one can find the length of a LIS of \\(c\\) (not its length) by the following famous algorithm:\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\). The length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\).\n\nIntuitively, each \\(d_j\\) manages the smallest last element of a length-\\(j\\) (weakly) increasing subsequence of \\(c_1,c_2,\\dots,c_i\\) (or \\(\\infty\\) if there is no such subsequence). To find an example of LIS instead of its length only, let us modify the algorithm as follows.\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Prepare a length-\\(N\\) sequence \\(\\text{id}\\) and \\(\\text{pre}\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\), and replace \\(\\text{id}_j\\) with \\(i\\). If \\(j > 1\\), replace \\(\\text{pre}_i\\) with \\(\\text{id}_{j-1}\\) too.\n\nThe length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\). Let \\(l\\) be the length of a LIS of \\(c\\). Consider a length-\\(l\\) sequence obtained by applying \\((l-1)\\) times the action \\(i\\mapsto \\text{pre}_i\\) to \\(\\text{id}_l\\), namely \\((\\text{id}_l, \\text{pre}_{\\text{id}_l},\\text{pre}_{\\text{pre}_{\\text{id}_l}},\\dots)\\). The reversal of this sequence is an example of a LIS of \\(c\\).\n\nThe fact that an example of LIS can be indeed obtained using this algorithm can be proved inductively. The complexity of this algorithm is \\(O(N\\log N)\\), same as the original algorithm. (To find the minimum \\(j\\) in step \\(3\\), use binary search.) Thus, the problem has been solved.\n\nSample code (Python3):\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    h, w, n = map(int, sys.stdin.readline().strip().split())\n    coins = []\n    for _ in range(n):\n        r, c = map(int, sys.stdin.readline().strip().split())\n        coins.append((r, c))\n    coins.sort()\n    dp = [float('inf')] * n\n    id_list = [-1] * n\n    pre = [0] * n\n    for i in range(n):\n        it = bisect_right(dp, coins[i][1])\n        dp[it] = coins[i][1]\n        id_list[it] = i\n        pre[i] = id_list[it - 1] if it else -1\n    m = n - 1\n    while id_list[m] == -1:\n        m -= 1\n    path = [(h, w)]\n    now = id_list[m]\n    while now != -1:\n        path.append(coins[now])\n        now = pre[now]\n    path.append((1, 1))\n    path.reverse()\n    s = []\n    for i in range(len(path) - 1):\n        d = path[i + 1][0] - path[i][0]\n        r = path[i + 1][1] - path[i][1]\n        s.append('D' * d + 'R' * r)\n    print(m + 1)\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAtCoder Street is represented by a straight line on flat ground, with \\(N\\) utility poles of height \\(H\\) standing on it. These poles are numbered \\(1, 2, \\dots, N\\) in chronological order. Each pole \\(i\\) (where \\(1 \\leq i \\leq N\\)) is vertically positioned at coordinate \\(X_i\\), and the base of each pole is fixed to the ground. Assume the poles are sufficiently thin.\n\nThe street will experience \\(N\\) earthquakes. During the \\(i\\)-th earthquake (for \\(1 \\leq i \\leq N\\)), the following events occur:\n1. If pole \\(i\\) has not yet fallen, it falls to the left or the right on the number line, each with a probability of \\(\\frac{1}{2}\\).\n2. If a falling pole collides with another pole that has not yet fallen (including collision at the base), the latter pole will also fall in the same direction. This may trigger a chain reaction.\n\nThe direction in which a pole falls is independent of the direction in which other poles have fallen.\n\nFor earthquake preparedness, for each \\(t = 1, 2, \\dots, N\\), find the probability that all poles have fallen by exactly the \\(t\\)-th earthquake. Multiply it by \\(2^N\\) and print the result modulo \\(998244353\\). It can be proved that the values to be printed are integers.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq H \\leq 10^9\\)\n- \\(0 \\leq X_i \\leq 10^9\\) (for \\(1 \\leq i \\leq N\\))\n- \\(X_1, X_2, \\dots, X_N\\) are all distinct.\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n```\nN H\nX_1 X_2 \\cdots X_N\n```\n\n**Output:**\n\nPrint the answers for \\(t = 1, 2, \\dots, N\\) in this order, separated by spaces.\n\n**Sample Input 1:**\n```\n3 2\n0 3 1\n```\n\n**Sample Output 1:**\n```\n4 2 2\n```\n\n**Sample Input 2:**\n```\n4 10\n10 55 20 45\n```\n\n**Sample Output 2:**\n```\n0 4 4 8\n```\n\n**Sample Input 3:**\n```\n8 1\n5 0 6 3 8 1 7 2\n```\n\n**Sample Output 3:**\n```\n0 64 32 48 24 28 28 32\n```\n\n**Sample Input 4:**\n```\n40 20\n695 793 11 502 114 861 559 4 212 609 894 435 429 94 91 258 161 45 33 605 673 634 629 163 283 826 409 84 507 548 31 248 588 340 357 168 926 949 322 912\n```\n\n**Sample Output 4:**\n```\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41942627 41942627 360709869\n```\n\nSolution:\n\n```python\ndef find_probability_last_pole_falls(m, s):\n    \"\"\"Calculate the probability that the last pole to fall is the i-th pole.\"\"\"\n    # Step 3: Calculate probability\n    a = calculate_a(m, s)\n    b = calculate_b(m, s)\n    probability = (1 / (2 ** a)) * (b / 2)\n    return probability\n\ndef calculate_a(m, s):\n    \"\"\"Calculate the number of earthquakes for condition in Step 2.\"\"\"\n    count = 0\n    for earthquake in s:\n        if some_condition(earthquake):  # Replace with specific condition\n            count += 1\n    return count\n\ndef calculate_b(m, s):\n    \"\"\"Count conditions like p_i > p_{i+1} or i == m.\"\"\"\n    count = 0\n    for i in range(m):\n        if specific_condition(i, s):  # Replace with specific condition\n            count += 1\n    return count\n\ndef use_stack_for_min_updates(array):\n    \"\"\"Use a stack to manage minimum updates.\"\"\"\n    stack = []\n    result = {}\n    for index, value in enumerate(array):\n        while stack and stack[-1] > value:\n            stack.pop()\n        if not stack or stack[-1] != value:\n            result[index] = value\n        stack.append(value)\n    return result\n\nclass SegmentTree:\n    def __init__(self, data):\n        # Initialize the segment tree with the provided data\n        self.data = data\n        # Additional initialization as needed\n\n    def update(self, index, value):\n        # Update the segment tree at index with the new value\n        pass\n    \n    def calculate_modular_inverse(self, s1_times_sK):\n        # Calculate the modular inverse in real-time\n        pass\n\ndef aggregate_results(poles, earthquakes):\n    \"\"\"Aggregate results for problems concerning the poles.\"\"\"\n    last_pole_falls = []\n    for group in range(len(poles)):\n        if last_pole_falls[group] == group:\n            # Calculate probabilities using defined methods or classes\n            pass\n\n# Example on how the functions and classes could be used\nm = 5\ns = [1, 2, 3, 4, 5]  # Example data, replace with actual\nfind_probability_last_pole_falls(m, s)\n```\n \n\n", "problem_ids": ["abc367_c", "abc369_f", "arc177_d"]}, "abc337_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi has prepared \\(N\\) dishes for Snuke. The dishes are numbered from 1 to \\(N\\), and dish \\(i\\) has a sweetness of \\(A_i\\) and a saltiness of \\(B_i\\).\n\nTakahashi can arrange these dishes in any order he likes. Snuke will eat the dishes in the order they are arranged, but if at any point the total sweetness of the dishes he has eaten so far exceeds \\(X\\) or the total saltiness exceeds \\(Y\\), he will not eat any further dishes.\n\nTakahashi wants Snuke to eat as many dishes as possible. Find the maximum number of dishes Snuke will eat if Takahashi arranges the dishes optimally.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 80\\)\n- \\(1 \\leq A_i, B_i \\leq 10000\\)\n- \\(1 \\leq X, Y \\leq 10000\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN X Y\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\n```\n\n**Output:**\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 8 4\n1 5\n3 2\n4 1\n5 3\n```\n\n**Sample Output 1:**\n```\n3\n```\n\n*Explanation:*\nConsider the scenario where Takahashi arranges the dishes in the order 2, 3, 1, 4.\n- First, Snuke eats dish 2. The total sweetness so far is 3, and the total saltiness is 2.\n- Next, Snuke eats dish 3. The total sweetness so far is 7, and the total saltiness is 3.\n- Next, Snuke eats dish 1. The total sweetness so far is 8, and the total saltiness is 8.\n- The total saltiness has exceeded \\(Y=4\\), so Snuke will not eat any further dishes.\n\nThus, in this arrangement, Snuke will eat three dishes. No matter how Takahashi arranges the dishes, Snuke will not eat all four dishes, so the answer is 3.\n\n**Sample Input 2:**\n```\n2 1 1\n3 2\n3 2\n```\n\n**Sample Output 2:**\n```\n1\n```\n\n**Sample Input 3:**\n```\n2 100 100\n3 2\n3 2\n```\n\n**Sample Output 3:**\n```\n2\n```\n\n**Sample Input 4:**\n```\n6 364 463\n230 381\n154 200\n328 407\n339 94\n193 10\n115 309\n```\n\n**Sample Output 4:**\n```\n3\n```\n\nSolution:\n\n```python\nEditorial - Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nE - Maximum Glutton Editorial by en_translator\n\nNotice that the total sweetness and saltiness of all but last dishes that he eats do not exceed \\(X\\) and \\(Y\\), respectively. Let \\(x\\) be the maximum size of a set of dishes \\(S\\) such that the total sweetness does not exceed \\(X\\) and the total saltiness does not exceed \\(Y\\). Then, the answer to the original problem can be represented as \\(\\min(x+1, N)\\). If \\(x<N\\), he can eat at least \\((x+1)\\) dishes by eating those in \\(S\\) first. Thus, he can eat at most \\((x+1)\\) dishes.\n\nTo find the maximum number of dishes that can be chosen such that the total sweetness and saltiness do not exceed \\(X\\) and \\(Y\\), respectively, define a Dynamic Programming (DP) table:\n\n\\(dp_{i,j,k}\\) = (the minimum total saltiness when choosing exactly \\(k\\) dishes from dishes \\(1,2,\\dots,i\\) so that the total sweetness is exactly \\(j\\)).\n\nThis fills the DP table in \\(O(N^2X)\\) time. Find the maximum \\(k\\) such that there exists \\(j\\) with \\(dp'_{N,j,k} \\leq Y\\).\n\nSample code (Python3):\n```python\ndef chmin(a, b):\n    return min(a, b)\n\ndef main():\n    n, x, y = map(int, input().split())\n    a = []\n    b = []\n    for _ in range(n):\n        ai, bi = map(int, input().split())\n        a.append(ai)\n        b.append(bi)\n    \n    dp = [[[float('inf')] * (x + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 0\n    \n    for i in range(n):\n        for j in range(i + 1):\n            for k in range(x + 1):\n                dp[i + 1][j][k] = chmin(dp[i + 1][j][k], dp[i][j][k])\n                if k + a[i] <= x:\n                    dp[i + 1][j + 1][k + a[i]] = chmin(dp[i + 1][j + 1][k + a[i]], dp[i][j][k] + b[i])\n    \n    for i in range(n, -1, -1):\n        for j in range(x + 1):\n            if dp[n][i][j] <= y:\n                print(min(i + 1, n))\n                return\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\). You are also given \\(Q\\) queries to process in order. There are three types of queries:\n\n1. `1 l r x`: Add \\(x\\) to each of \\(A_l, A_{l+1}, \\ldots, A_r\\).\n2. `2 l r x`: Add \\(x\\) to each of \\(B_l, B_{l+1}, \\ldots, B_r\\).\n3. `3 l r`: Print the remainder of \\(\\sum_{i=l}^r (A_i \\times B_i)\\) when divided by 998244353.\n\n**Constraints:**\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(0 \\leq A_i, B_i \\leq 10^9\\)\n- \\(1 \\leq l \\leq r \\leq N\\)\n- \\(1 \\leq x \\leq 10^9\\)\n- All input values are integers.\n- There is at least one query of the third type.\n\n**Input:**\n\nThe input is given from Standard Input in the following format. Here, \\(\\text{query}_i (1 \\leq i \\leq Q)\\) is the \\(i\\)-th query to be processed.\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n\\text{query}_1\n\\text{query}_2\n\\vdots\n\\text{query}_Q\n```\n\nEach query is given in one of the following formats:\n\n```\n1 l r x\n```\n\n```\n2 l r x\n```\n\n```\n3 l r\n```\n\n**Output:**\n\nIf there are \\(K\\) queries of the third type, print \\(K\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq K)\\) should contain the output for the \\(i\\)-th query of the third type.\n\n**Sample Input 1:**\n\n```\n5 6\n1 3 5 6 8\n3 1 2 1 2\n3 1 3\n1 2 5 3\n3 1 3\n1 1 3 1\n2 5 5 2\n3 1 5\n```\n\n**Sample Output 1:**\n\n```\n16\n25\n84\n```\n\nInitially, \\(A = (1, 3, 5, 6, 8)\\) and \\(B = (3, 1, 2, 1, 2)\\). The queries are processed in the following order:\n\n1. For the first query, print \\((1 \\times 3) + (3 \\times 1) + (5 \\times 2) = 16\\) modulo 998244353, which is 16.\n2. For the second query, add 3 to \\(A_2, A_3, A_4, A_5\\). Now \\(A = (1, 6, 8, 9, 11)\\).\n3. For the third query, print \\((1 \\times 3) + (6 \\times 1) + (8 \\times 2) = 25\\) modulo 998244353, which is 25.\n4. For the fourth query, add 1 to \\(A_1, A_2, A_3\\). Now \\(A = (2, 7, 9, 9, 11)\\).\n5. For the fifth query, add 2 to \\(B_5\\). Now \\(B = (3, 1, 2, 1, 4)\\).\n6. For the sixth query, print \\((2 \\times 3) + (7 \\times 1) + (9 \\times 2) + (9 \\times 1) + (11 \\times 4) = 84\\) modulo 998244353, which is 84.\n\nThus, the first, second, and third lines should contain 16, 25, and 84, respectively.\n\n**Sample Input 2:**\n\n```\n2 3\n1000000000 1000000000\n1000000000 1000000000\n3 1 1\n1 2 2 1000000000\n3 1 2\n```\n\n**Sample Output 2:**\n\n```\n2716070898\n151723988\n```\n\nMake sure to print the sum modulo 998244353 for the third type of query.\n\nSolution:\n\n[BEGIN TEXT]\nConsider solving this problem using a lazy segment tree. For details on lazy segment trees, please refer to other editorials and the AtCoder Library explanation. Specifically, for each segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) for integers \\(a,k\\geq 0\\) and \\(2^k(a+1)\\leq N\\), we want to manage the sum of \\(A_i\\times B_i\\) within the segment, and apply addition to \\(A_i\\) and \\(B_i\\) fast enough (in \\(O(1)\\) time). The set of actions consists of \u201cadding \\(x\\) to each element of \\(A\\) and \\(y\\) to that of \\(B\\) (within the segment)\u201d for all integers \\(x\\) and \\(y\\). \n\nFor a segment \\(a\\cdot2^k+1\\leq i\\leq (a+1)2^k\\) (where \\(L=a\\cdot2^k+1\\) and \\(R=(a+1)2^k\\)), it is insufficient to store the values \\(\\sum_{i=L}^R (A_i\\times B_i)\\) for each segment. Instead, manage the length \\((R-L+1)\\), and three kinds of sum: \\(\\sum_{i=L}^R A_i\\), \\(\\sum_{i=L}^R B_i\\), and \\(\\sum_{i=L}^R (A_i\\times B_i)\\), for each segment. Then, one can update the value \\(\\sum_{i=L}^R (A_i\\times B_i)\\) in \\(O(1)\\) time. \n\nThe key updates are:\n\\[\n\\sum_{i=L}^R ((A_i+x)\\times (B_i+y)) = \\sum_{i=L}^R (A_i\\times B_i) + y\\sum_{i=L}^R A_i + x\\sum_{i=L}^R B_i + (R-L+1)xy\n\\]\n\\[\n\\sum_{i=L}^R (A_i+x) = \\sum_{i=L}^R A_i+(R-L+1)x, \n\\]\n\\[\n\\sum_{i=L}^R (B_i+y) = \\sum_{i=L}^R B_i+(R-L+1)y\n\\]\n\nTherefore, the lazy segment tree can find the answer with a complexity of \\(O(Q\\log N)\\), which is efficient. The answer should be printed modulo \\(998244353\\).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of the characters 'A' and 'B'. For a string \\( X \\) of length \\( N \\) consisting of the characters '1', '2', and '3', the score is determined by the following procedure:\n\n1. Initialize the variables \\( h_1, h_2, h_3, P \\) to 0.\n\n2. For \\( i = 1, 2, \\dots, N \\) in this order, perform the following operations:\n   - If the \\( i \\)-th character of \\( S \\) is 'A', perform operation A; if it is 'B', perform operation B. Let \\( d \\) be the number represented by the \\( i \\)-th character of \\( X \\).\n   - **Operation A:** Add 2 to \\( h_d \\).\n   - **Operation B:** If \\( d = 2 \\) or \\( h_d \\neq h_2 \\), set \\( P \\) to \\(-10^{100}\\). Otherwise, add 1 to both \\( h_d \\) and \\( h_2 \\).\n\n3. If \\( h_1 = h_2 = h_3 \\), add 1 to \\( P \\).\n\nThe final value of \\( P \\) is the score.\n\nPrint one string \\( X \\) that maximizes the score. You have \\( T \\) test cases to solve.\n\n**Constraints:**\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N \\leq 10^6 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of 'A' and 'B'.\n- \\( T \\) and \\( N \\) are integers.\n- The sum of \\( N \\) across all test cases is at most \\( 10^6 \\).\n\n**Input:**\nThe input is given from Standard Input in the following format. Here, \\(\\mathrm{test}_i\\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{test}_1\n\\mathrm{test}_2\n\\vdots\n\\mathrm{test}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nS\n```\n\n**Output:**\nPrint \\( T \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq T \\)) should contain a string \\( X \\) that maximizes the score for the \\( i \\)-th test case. If multiple strings \\( X \\) maximize the score, any of them is considered correct.\n\n**Sample Input 1:**\n```\n5\n4\nABBA\n5\nAAAAA\n6\nBBBBBB\n7\nABABABA\n20\nAAABBBBBBBBAAABBBABA\n```\n\n**Sample Output 1:**\n```\n1333\n12321\n333333\n1313212\n33311111133121111311\n```\n\nLet us describe the changes in \\((h_1, h_2, h_3, P)\\) as we proceed with \\( i = 1, 2, \\dots, N \\).\n\n- For the first test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,1,1,0) \\rightarrow (2,2,2,1) \\rightarrow (2,2,4,1)\\). The maximum score is 1.\n- For the second test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,2,0,0) \\rightarrow (2,2,2,1) \\rightarrow (2,4,2,1) \\rightarrow (4,4,2,1)\\). The maximum score is 1.\n\nFor the third, fourth, and fifth test cases, the maximum scores are 0, 0, and 2, respectively. There may be multiple strings \\( X \\) that maximize the score, but you only need to print one of them.\n\nSolution:\n\n[BEGIN TEXT]\nHere is a concise version of the provided text:\n\n---\n\n**F - All the Same Editorial by evima**\n\n**Observations on the Problem:**  \nThe problem can be visualized as a Tetris game with dominoes on a field width of 3, where dominoes cannot be rotated and there must be no gaps below horizontally placed dominoes. The score increases when all pieces are cleared. Flattening occurs when \\( h_1 = h_2 = h_3 \\).\n\n**Characteristics of \\( S \\):**  \nFor \\( i=0,1,\\ldots,N \\), let \\( a_i \\) be the number of As and \\( b_i \\) the number of Bs. The sequence can be flattened under the following conditions:\n- \\( a_i + b_i \\equiv 0 \\mod 3 \\)\n- \\( b_i \\equiv 0 \\mod 2 \\)\n- \\( b_i \\le 2a_i \\)\n\nDefining \\( V_i = 2a_i - b_i \\) gives:\n\\[ V_i \\ge 0, \\ V_i \\equiv 0 \\mod 6 \\]\nThese conditions are both necessary and sufficient for flattening.\n\n**Maximizing the Score:**  \nFind the longest non-decreasing subsequence \\( (V_{i_0}, V_{i_1}, \\ldots, V_{i_k}) \\) with:\n- \\( i_0 = 0 \\)\n- \\( V_{i_j} \\equiv 0 \\mod 6 \\)\n- \\( V_{i_j} \\le V_{i_{j+1}} \\)\n\nThis can be solved in \\( O(N \\log N) \\) time. \n\n**Constructing the Operation Sequence:**  \nDefine \\( T_j \\) as the substring of \\( S \\) from \\( (V_{i_j}+1) \\)-th to \\( V_{i_{j+1}} \\)-th character. Construct an operation sequence \\( X \\) for \\( S \\):\n- \\( A \\to 1 \\) (vertical domino)\n- \\( B \\to 3 \\) (horizontal domino)\n\nAdjust for \\( V_N \\ge 6 \\) by aligning extra vertical dominoes. Execute the basic idea when \\( V_N = 0 \\). Handle \\( V_i \\) conditions to reduce \\( V_N \\).\n\n**Summary:**  \n1. Compute \\( V \\) and solve the longest non-decreasing subsequence problem.\n2. For divided substrings, use the basic idea and reductions.\n\nThe solution operates in \\( O(|S|\\log |S|) \\) time per test case.\n[END TEXT]\n \n\n", "problem_ids": ["abc364_e", "abc357_f", "arc179_f"]}, "abc337_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). For each \\( k = 1, 2, \\dots, N \\), find the number, modulo \\( 998244353 \\), of (not necessarily contiguous) subsequences of \\( A \\) of length \\( k \\) that are arithmetic sequences. Two subsequences are distinguished if they are taken from different positions, even if they are equal as sequences.\n\n**What is a subsequence?**  \nA subsequence of a sequence \\( A \\) is a sequence obtained by deleting zero or more elements from \\( A \\) and arranging the remaining elements without changing the order.\n\n### Constraints\n- \\( 1 \\leq N \\leq 80 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n### Output\nPrint the answers for \\( k = 1, 2, \\dots, N \\) in this order, in a single line, separated by spaces.\n\n### Sample Input 1\n```\n5\n1 2 3 2 3\n```\n\n### Sample Output 1\n```\n5 10 3 0 0\n```\n\n- There are 5 subsequences of length 1, all of which are arithmetic sequences.\n- There are 10 subsequences of length 2, all of which are arithmetic sequences.\n- There are 3 subsequences of length 3 that are arithmetic sequences: \\((A_1, A_2, A_3)\\), \\((A_1, A_2, A_5)\\), and \\((A_1, A_4, A_5)\\).\n- There are no arithmetic subsequences of length 4 or more.\n\n### Sample Input 2\n```\n4\n1 2 3 4\n```\n\n### Sample Output 2\n```\n4 6 2 1\n```\n\n### Sample Input 3\n```\n1\n100\n```\n\n### Sample Output 3\n```\n1\n```\n\nSolution:\n\n```python\n# Editorial - E - Count Arithmetic Subsequences\n\n# Every length-1 subsequence is an arithmetic sequence; there are N of them. \n# For counting sequences of length 2 or greater, consider Dynamic Programming (DP) \n# with the states: dp[i][j][l] = the number of arithmetic sequences with \n# initial and second terms A_i and A_j, and length l (l >= 2).\n\n# O(N^4) Solution:\n# Iterate over A_i in descending order. For each fixed A_i, brute-force over the \n# second term A_j (i < j) and the length l. If l = 2, then (A_i, A_j) is an \n# arithmetic sequence of length 2, so dp[i][j][2] += 1. If l >= 3, search over \n# A_k (j < k). If A_k - A_j = A_j - A_i, sequence can be extended by prepending \n# A_i. Thus, dp[i][j][l] += dp[j][k][l-1]. This gives an O(N^4) complexity due to \n# O(N^3) states and O(N) transition cost, feasible under the problem constraints.\n\n# O(N^3) Solution:\n# Optimize by considering dp[i][j][l] = sequences with initial term A_i, length \n# l (l >= 2), and common difference d. Again iterate over A_i in descending order. \n# For fixed A_i, brute-force over A_j (i < j) and l, determining common difference \n# d = A_j - A_i. For l = 2, add 1 to dp[i][2][d]. For l >= 3, extend sequence by \n# adding dp[j][l-1][d] to dp[i][l][d]. As d can be large, use an associative array \n# for indices of d. \n\n# Note: Python automatically accommodates large integers and provides a dictionary \n# (map) data structure that can be used similarly to C++'s map. Here is a Python \n# illustration with comments for flexibility.\n```\n\n(Note: The above solution does not provide the full implementation of the algorithm since it abstractly discusses the logic, but translates the structure and logic described in the editorial to Python format.)\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally.\n\nInitially, all vertices are painted white.\n\nTo efficiently visit all vertices of this tree, Alice has invented a magical gate. She uses one piece and one gate to travel according to the following procedure.\n\nFirst, she chooses a vertex and places both the piece and the gate on that vertex. Then, she repeatedly performs the following operations until all vertices are painted black.\n\nChoose one of the following actions:\n\n1. Paint the vertex where the piece is placed black.\n2. Choose a vertex adjacent to the vertex where the piece is placed and move the piece to that vertex. The cost of this action is 1.\n3. Move the piece to the vertex where the gate is placed.\n4. Move the gate to the vertex where the piece is placed.\n\nNote that only the second action incurs a cost.\n\nIt can be proved that it is possible to paint all vertices black in a finite number of operations. Find the minimum total cost required.\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- The given graph is a tree.\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nu_1 v_1\n\\vdots\nu_{N-1} v_{N-1}\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n4\n1 2\n1 3\n1 4\n```\n\n**Sample Output 1:**\n```\n3\n```\n\nHere is an example of Alice's procedure. Let \\((u, v)\\) denote the state where the piece is at vertex \\( u \\) and the gate is at vertex \\( v \\).\n\n- Place the piece and the gate at vertex 4.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 1.\n  - Vertex 4 is painted black.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 2 and move the piece to vertex 1.\n  - This costs 1.\n  - The state is now \\((1, 4)\\).\n\n- Perform action 1.\n  - Vertex 1 is painted black.\n\n- Perform action 4.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 2.\n  - This costs 1.\n  - The state is now \\((2, 1)\\).\n\n- Perform action 1.\n  - Vertex 2 is painted black.\n\n- Perform action 3.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 3.\n  - This costs 1.\n  - The state is now \\((3, 1)\\).\n\n- Perform action 1.\n  - Vertex 3 is painted black.\n  - All vertices are now painted black, so the procedure ends.\n\nThe total cost of performing action 2 is 3, and there is no procedure with a smaller cost.\n\n**Sample Input 2:**\n```\n10\n1 7\n7 10\n10 8\n8 3\n8 4\n10 9\n9 6\n9 5\n7 2\n```\n\n**Sample Output 2:**\n```\n10\n```\n\nSolution:\n\n```\nHere is the cleaned version:\n\nEditorial - AtCoder Regular Contest 179\n\nD - Portable Gate Editorial by evima\n\nWhen moving the gate, it can be considered to move simultaneously with the piece. We will perform operation 1 as needed and consider the following operations:\n\nOperation A: When the piece and the gate are on the same vertex, move both the piece and the gate to an adjacent vertex. Operation B: Move the piece to an adjacent vertex. Operation C: Move the piece to the vertex where the gate is located.\n\nOperations A and B each incur a cost of 1. Once operation B is performed, the gate remains in its position until operation C is performed. It's inefficient to move the piece to the gate using operation B, so we will not consider this.\n\nLet \\(v\\) be the initial position of the piece and gate. By performing operation C at the end, the process ends when the piece and the gate are on the same vertex. Label the vertices and edges the gate moves to with A, and the rest with B. The vertices and edges labeled A form a connected subgraph, or subtree A. Vertex \\(v\\) is included in subtree A. Edges labeled B with one endpoint as A are boundary edges.\n\nVertices and edges labeled B not connected to boundary edges form connected components. Each component is a tree connected to a vertex in subtree A by a boundary edge \\(e_i\\). Let them form subtree \\(B_i\\), connected to vertex \\(l_i\\) in A.\n\nKey points:\n\n1. In optimal operations, assume edges labeled A are not traversed by operation B. By rearranging operations, the cost does not increase:\n\n   - The piece and gate start from \\(v\\), visit all vertices in A using operation A, and return to \\(v\\). This is the journey in A.\n   - If \\(l_i\\) is visited during A's journey, it's interrupted. The piece starts from \\(l_i\\), visits all vertices in \\(B_i\\) using operation B, and returns to \\(l_i\\). This is the journey in \\(B_i\\). The gate stays at \\(l_i\\).\n\n2. Assume moving along boundary edge \\(e_i\\) occurs only once in B's journey. If done more than once, moving with the gate using operation A during the first move and returning does not increase the cost. In \\(B_i\\)'s journey, operation C is done once at the end.\n\n3. In the journeys of A and \\(B_i\\), the farthest vertex is visited last. If the distance from start to the farthest vertex is \\(d\\) and the number of edges is \\(m\\), the cost is \\(2m - d\\).\n\nThe total number of edges in subtrees is \\(N-1\\). Minimize cost by maximizing \\(d\\)'s total sum. Calculate for fixed \\(v\\) using tree DP. Maintain:\n\n- Maximum distance to vertex where \\(B_i\\)'s journey ends, assuming \\(u = l_i\\).\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex in \\(u\\)'s subtree.\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex not in \\(u\\)'s subtree.\n\nExtend to rerooting DP to examine all possible starting vertices. Time complexity \\(\\mathrm{O}(N)\\).\n```\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\). Additionally, you are given an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n1. Choose integers \\( l \\) and \\( r \\) such that \\( 1 \\leq l < r \\leq N \\).\n   - The pair \\((l, r)\\) must satisfy the following conditions:\n     - \\( K \\leq r - l \\).\n     - \\( P_l > P_r \\) at the time of the operation.\n     - The pair \\((l, r)\\) has never been chosen before.\n\n2. Swap the values of \\( P_l \\) and \\( P_r \\).\n\nYour goal is to maximize the number of operations. Find one way to achieve this.\n\n### Constraints\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( 1 \\leq K \\leq N - 1 \\)\n- \\( (P_1, P_2, \\ldots, P_N) \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\ldots P_N\n```\n\n### Output\n\nPrint the answer in the following format:\n```\nm\nl_1 r_1\nl_2 r_2\n\\vdots\nl_m r_m\n```\n\nHere, \\( m \\) is the maximum number of operations, and \\( l_i \\) and \\( r_i \\) are the values of \\( l \\) and \\( r \\) chosen in the \\( i \\)-th operation, respectively. If multiple solutions exist, you can print any of them.\n\n### Sample Input 1\n```\n3 1\n3 2 1\n```\n\n### Sample Output 1\n```\n3\n2 3\n1 3\n1 2\n```\n\nIn this example, the maximum number of operations is \\( 3 \\). The operations in the sample output proceed as follows:\n\n1. Choose \\((l, r) = (2, 3)\\). We have \\( 1 \\leq 3 - 2 \\) and \\( P_2 > P_3 \\), and \\((2, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_2 \\) and \\( P_3 \\), resulting in \\( P = (3, 1, 2) \\).\n\n2. Choose \\((l, r) = (1, 3)\\). We have \\( 1 \\leq 3 - 1 \\) and \\( P_1 > P_3 \\), and \\((1, 3)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_3 \\), resulting in \\( P = (2, 1, 3) \\).\n\n3. Choose \\((l, r) = (1, 2)\\). We have \\( 1 \\leq 2 - 1 \\) and \\( P_1 > P_2 \\), and \\((1, 2)\\) has not been chosen before, so the conditions are satisfied. Swap \\( P_1 \\) and \\( P_2 \\), resulting in \\( P = (1, 2, 3) \\).\n\nSolution:\n\n[BEGIN TEXT]\nLet\u2019s consider the inverse permutation \\(Q\\) of \\(P\\). In other words, \\(Q_{P_i} = i\\). Rephrasing the operation with \\(Q\\) as the main focus, it becomes: Choose \\(i, j\\) such that \\(1 \\leq i < j \\leq N\\) and \\(Q_i - Q_j \\geq K\\). Here, the pair \\((Q_i, Q_j)\\) must not have been chosen before. Swap \\(Q_i\\) and \\(Q_j\\).\n\nWe define the pseudo-inversion count of \\(Q\\) as the number of integer pairs \\((i, j)\\) such that \\(i < j\\) and \\(Q_i - Q_j \\geq K\\). Performing the operation decreases the pseudo-inversion count by at least \\(1\\). It is possible to construct a sequence of operations that decreases the pseudo-inversion count by \\(1\\) each time. Specifically, proceed as follows: Iterate \\(x = 1, 2, \\cdots, N\\). Assume that, when processing a certain \\(x\\), the pseudo-inversion count of \\(Q_1, \\cdots, Q_{x-1}\\) is \\(0\\). Enumerate \\(Q_i\\) that satisfy \\(i < x\\) and \\(Q_i - Q_x \\geq K\\), and denote them as \\(i_1, i_2, \\cdots, i_s\\). Then, process \\((i_s, x), (i_{s-1}, i_s), \\cdots, (i_1, i_2)\\) in this order. This decreases the pseudo-inversion count by \\(1\\) with each operation. The same pair \\((Q_i, Q_j)\\) will not be operated on more than once. A straightforward implementation of these steps yields an \\(O(N^2)\\) time solution.\n[END TEXT]\n \n\n", "problem_ids": ["abc362_e", "arc179_d", "arc180_b"]}, "abc337_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThe pattern of AtCoder's wallpaper can be represented on the xy-plane as follows:\n\n- The plane is divided by the following three types of lines:\n  - \\( x = n \\) (where \\( n \\) is an integer)\n  - \\( y = n \\) (where \\( n \\) is an even number)\n  - \\( x + y = n \\) (where \\( n \\) is an even number)\n\n- Each region is painted black or white. Any two regions adjacent along one of these lines are painted in different colors.\n- The region containing (0.5, 0.5) is painted black.\n\nYou are given integers \\( A, B, C, \\) and \\( D \\). Consider a rectangle whose sides are parallel to the x- and y-axes, with its bottom-left vertex at \\( (A, B) \\) and its top-right vertex at \\( (C, D) \\). Calculate the area of the regions painted black inside this rectangle, and print twice that area.\n\nIt can be proved that the output value will be an integer.\n\n**Constraints:**\n\n- \\( -10^9 \\leq A, B, C, D \\leq 10^9 \\)\n- \\( A < C \\) and \\( B < D \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nA B C D\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n\n```\n0 0 3 3\n```\n\n**Sample Output 1:**\n\n```\n10\n```\n\nThe area of the black-painted region inside the following square is 5, so print twice that value: 10.\n\n**Sample Input 2:**\n\n```\n-1 -2 1 3\n```\n\n**Sample Output 2:**\n\n```\n11\n```\n\nThe area is 5.5, but the output value is an integer.\n\n**Sample Input 3:**\n\n```\n-1000000000 -1000000000 1000000000 1000000000\n```\n\n**Sample Output 3:**\n\n```\n4000000000000000000\n```\n\nThis is the case with the largest rectangle, where the output still fits into a 64-bit signed integer.\n\nSolution:\n\n        Editorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nD - AtCoder Wallpaper Editorial by en_translator\n\nThe pattern of the wallpaper is an infinite repetition of this \\(4 \\times 2\\) rectangle. Thus, one can solve this problem by counting for each of the eight \\(1 \\times 1\\) squares how many instances of them are contained in the given rectangle. In order to count the number of squares at each position, it may be difficult to handle boundaries. As an example, we take the following approach in the sample code below.\n\nCount squares along \\(x\\) and \\(y\\) axes independently, and multiply it afterward. To count squares along the \\(x\\) axis, take a sufficiently large constant \\(P\\) that is a multiple of four (such as \\(1.1 \\times 10^9\\)), and compute \\((\\text{The number of squares between }x = -P\\text{ and }x = C) - (\\text{The number of squares between }x = -P\\text{ and }x = A)\\).\n\nWe pick such \\(P\\) to avoid issues on rounding-down division toward \\(0\\). Do the same thing for the \\(y\\) axis.\n\nAlso, when debugging this type of problem, it is effective to generate cases by yourself. In this problem, if it is a boundary issue that matters, it is a good idea to try many cases for \\(0 \\leq A, B, C, D \\leq 8\\).\n\nSample code (Python):\n```python\nmass = [[2, 1, 0, 1],\n        [1, 2, 1, 0]]\n# mass[i][j] : area of rectangle [[j, j + 1], [i, i + 1]] x 2\n\ninf = 4000000000\n\n# input\na, b, c, d = map(int, input().split())\n\n# calculation\nans = 0\nfor fy in range(2):\n    for fx in range(4):\n        x1 = (a - fx + 3 + inf) // 4\n        x2 = (c - fx + 3 + inf) // 4\n        count_x = x2 - x1  # count along x axis\n        y1 = (b - fy + 1 + inf) // 2\n        y2 = (d - fy + 1 + inf) // 2\n        count_y = y2 - y1  # count along y axis\n        ans += count_x * count_y * mass[fy][fx]\n\n# output\nprint(ans)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) balls on a two-dimensional plane, numbered from \\( 1 \\) to \\( N \\). Ball \\( i \\) is located at point \\( (X_i, Y_i) \\). Here, \\( X = (X_1, X_2, \\dots, X_N) \\) and \\( Y = (Y_1, Y_2, \\dots, Y_N) \\) are permutations of \\( (1, 2, \\dots, N) \\).\n\nYou can perform the following operation any number of times:\n\n- Choose one of the remaining balls, say ball \\( k \\). Then, for each remaining ball \\( i \\), if either \\( X_i < X_k \\) and \\( Y_i < Y_k \\), or \\( X_i > X_k \\) and \\( Y_i > Y_k \\) holds, remove ball \\( i \\).\n\nFind the number of possible sets of balls remaining after performing operations, modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 300 \\)\n- \\( X \\) and \\( Y \\) are permutations of \\( (1, 2, \\dots, N) \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nX_1 Y_1\nX_2 Y_2\n...\nX_N Y_N\n```\n\n**Output**\n\nPrint the answer in one line.\n\n**Sample Input 1**\n\n```\n3\n1 3\n2 1\n3 2\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\nThe possible sets of balls remaining after operations are \\(\\{1, 2, 3\\}\\), \\(\\{1, 3\\}\\), and \\(\\{1, 2\\}\\).\n\n**Sample Input 2**\n\n```\n4\n4 2\n2 1\n3 3\n1 4\n```\n\n**Sample Output 2**\n\n```\n3\n```\n\nSolution:\n\nHere is the cleaned version of the editorial:\n\n---\n\nHere, we assume that \\(X = (1, 2, \\dots, N)\\). First, let\u2019s consider the operations. Since the order in which the operations are performed does not affect the possibility of operations or the set of remaining points, only the set of points on which we perform operations is important. The condition under which we can perform operations on all points in a set \\(s\\) is as follows:\n\nLet \\(s' = (s'_1, s'_2, \\dots, s'_m)\\) be the sequence obtained by sorting the points in \\(s\\) in ascending order; then it must satisfy \\(Y_{s'_1} > Y_{s'_2} > \\dots > Y_{s'_m}\\).\n\nThe condition under which a point \\(i\\) remains when we perform operations on all points belonging to set \\(s\\) is:\n\nLet \\(t = (t_1, t_2, \\dots, t_m)\\) be the sequence obtained by sorting the points in \\(s \\cup \\{i\\}\\) in ascending order; then it must satisfy \\(Y_{t_1} > Y_{t_2} > \\dots > Y_{t_m}\\).\n\nSince it is difficult to find the answer directly, we count the maximal sets of points on which we perform operations. Specifically, we count the sets \\(s\\) satisfying the following:\n\n1. It is possible to perform operations on all points in \\(s\\).\n2. After performing operations on all points in \\(s\\), performing an operation on any other point will necessarily remove at least one point.\n\nThere is a one-to-one correspondence between maximal sets of operation points and the sets of points that can possibly remain after operations. The maximal sets of operation points can be counted using DP with cumulative sums, with a worst-case time complexity of \\(O(N^3)\\). With some ingenuity, this can be improved further.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\n", "problem_ids": ["abc354_d", "arc184_d", "abc368_c"]}, "abc337_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nWe define an infinite sequence of positive integers \\( (a_1, a_2, \\ldots) \\) as \"good\" if and only if it satisfies both of the following conditions:\n1. There exists a finite constant \\( C \\) such that \\( a_n \\leq C \\cdot n \\) for all \\( 1 \\leq n \\).\n2. For all pairs of positive integers \\( (n, m) \\), \\( a_n \\mid a_m \\) if and only if \\( n \\mid m \\). Here, \\( x \\mid y \\) denotes that \\( x \\) divides \\( y \\).\n\nYou are given a positive integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\). Check if there exists a good infinite sequence starting with \\( (A_1, A_2, \\ldots, A_N) \\). You have \\( T \\) test cases to solve.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 5000 \\)\n- \\( 1 \\leq N \\leq 5000 \\)\n- \\( 1 \\leq A_i \\leq 10^{18} \\)\n- The sum of \\( N \\) across the test cases in a single input is at most 5000.\n- All input values are integers.\n\n**Input**\n\nThe input is given from standard input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nFor each test case, if there exists a good infinite sequence starting with \\( (A_1, A_2, \\ldots, A_N) \\), print `Yes`, and otherwise print `No`. In printing `Yes` or `No`, you can output each letter in any case (upper or lower).\n\n**Sample Input 1:**\n\n```\n5\n5\n1 2 3 4 5\n5\n1 4 9 16 25\n5\n1 4 6 8 10\n5\n1 2 4 4 5\n5\n1 2 3 5 4\n```\n\n**Sample Output 1:**\n\n```\nYes\nYes\nYes\nNo\nNo\n```\n\nFor the 1st test case, we can let \\( a_n = n \\) and that satisfies the condition.\n\nSolution:\n\n```\nAtCoder Grand Contest 067 - Editorial for Problem C: Divisibility Homomorphism\n\nClearly, all the \\(f(n)\\) are distinct. Let the primes be \\(p_1,p_2,\\cdots,p_k\\) in ascending order. We prove by induction on \\(k\\) that for all \\(u\\), \\(\\frac{f(p_ku)}{f(u)}\\) contains a prime factor at least \\(p_k\\), while \\(f(p_k^N)=C_k p_k^N\\) for sufficiently large \\(N\\).\n\nThe base is trivial for \\(k=0\\). For the induction step, consider an \\(X\\) with sufficient powers of \\(p_1,p_2,\\cdots,p_{k-1}\\). By \\(\\operatorname{LCM}(f(u),f(X))\\mid f(uX)\\) while \\(f(p_ku)\\nmid f(uX)\\), or \\(\\frac{f(p_ku)}{f(u)}\\nmid \\frac{f(uX)}{f(u)}\\), we know that the LHS contains a prime factor bigger than \\(p_{k-1}\\). We conclude \\(f(p_k^{N+1})\\ge p_kf(p_k^N)\\), and the strict inequality can occur at most \\(\\log_{p_{k+1}/p_k}C\\) times, proving the latter.\n\nAfter the induction, if \\(v_p(x)>v_p(y)\\), then \\(v_p (f(x)) > v_p (f(y))\\); otherwise, we can pick \\(Z\\) with sufficient prime powers of \\(f(x)\\) except \\(p\\), contradicting \\(f(x)|f(yZ)\\) and \\(x\\nmid yZ\\). This condition is sufficient as long as the given numbers don\u2019t contradict divisibility.\n\nFor \\(x\\nmid y\\), considering a prime \\(p\\) with \\(v_p(x)>v_p(y)\\), we conclude that \\(f(x)\\nmid f(y)\\). To make \\(f(x)\\mid f(y)\\) for all \\(x\\mid y\\), construct as follows: for each prime and each \u201clayer\u201d (meaning numbers \\(x\\) with \\(v_p(x)=\\text{Const}\\)), let the power of \\(p\\) be the maximum among its descendants (if the layer is empty, make the power all the same, at the minimal nonexisting integer).\n\nChecking all by brute force works in \\(O(n\\log (\\max a_i)+n \\pi (n))\\) time.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAtCoder Street is represented by a straight line on flat ground, with \\(N\\) utility poles of height \\(H\\) standing on it. These poles are numbered \\(1, 2, \\dots, N\\) in chronological order. Each pole \\(i\\) (where \\(1 \\leq i \\leq N\\)) is vertically positioned at coordinate \\(X_i\\), and the base of each pole is fixed to the ground. Assume the poles are sufficiently thin.\n\nThe street will experience \\(N\\) earthquakes. During the \\(i\\)-th earthquake (for \\(1 \\leq i \\leq N\\)), the following events occur:\n1. If pole \\(i\\) has not yet fallen, it falls to the left or the right on the number line, each with a probability of \\(\\frac{1}{2}\\).\n2. If a falling pole collides with another pole that has not yet fallen (including collision at the base), the latter pole will also fall in the same direction. This may trigger a chain reaction.\n\nThe direction in which a pole falls is independent of the direction in which other poles have fallen.\n\nFor earthquake preparedness, for each \\(t = 1, 2, \\dots, N\\), find the probability that all poles have fallen by exactly the \\(t\\)-th earthquake. Multiply it by \\(2^N\\) and print the result modulo \\(998244353\\). It can be proved that the values to be printed are integers.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq H \\leq 10^9\\)\n- \\(0 \\leq X_i \\leq 10^9\\) (for \\(1 \\leq i \\leq N\\))\n- \\(X_1, X_2, \\dots, X_N\\) are all distinct.\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n```\nN H\nX_1 X_2 \\cdots X_N\n```\n\n**Output:**\n\nPrint the answers for \\(t = 1, 2, \\dots, N\\) in this order, separated by spaces.\n\n**Sample Input 1:**\n```\n3 2\n0 3 1\n```\n\n**Sample Output 1:**\n```\n4 2 2\n```\n\n**Sample Input 2:**\n```\n4 10\n10 55 20 45\n```\n\n**Sample Output 2:**\n```\n0 4 4 8\n```\n\n**Sample Input 3:**\n```\n8 1\n5 0 6 3 8 1 7 2\n```\n\n**Sample Output 3:**\n```\n0 64 32 48 24 28 28 32\n```\n\n**Sample Input 4:**\n```\n40 20\n695 793 11 502 114 861 559 4 212 609 894 435 429 94 91 258 161 45 33 605 673 634 629 163 283 826 409 84 507 548 31 248 588 340 357 168 926 949 322 912\n```\n\n**Sample Output 4:**\n```\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41942627 41942627 360709869\n```\n\nSolution:\n\n```python\ndef find_probability_last_pole_falls(m, s):\n    \"\"\"Calculate the probability that the last pole to fall is the i-th pole.\"\"\"\n    # Step 3: Calculate probability\n    a = calculate_a(m, s)\n    b = calculate_b(m, s)\n    probability = (1 / (2 ** a)) * (b / 2)\n    return probability\n\ndef calculate_a(m, s):\n    \"\"\"Calculate the number of earthquakes for condition in Step 2.\"\"\"\n    count = 0\n    for earthquake in s:\n        if some_condition(earthquake):  # Replace with specific condition\n            count += 1\n    return count\n\ndef calculate_b(m, s):\n    \"\"\"Count conditions like p_i > p_{i+1} or i == m.\"\"\"\n    count = 0\n    for i in range(m):\n        if specific_condition(i, s):  # Replace with specific condition\n            count += 1\n    return count\n\ndef use_stack_for_min_updates(array):\n    \"\"\"Use a stack to manage minimum updates.\"\"\"\n    stack = []\n    result = {}\n    for index, value in enumerate(array):\n        while stack and stack[-1] > value:\n            stack.pop()\n        if not stack or stack[-1] != value:\n            result[index] = value\n        stack.append(value)\n    return result\n\nclass SegmentTree:\n    def __init__(self, data):\n        # Initialize the segment tree with the provided data\n        self.data = data\n        # Additional initialization as needed\n\n    def update(self, index, value):\n        # Update the segment tree at index with the new value\n        pass\n    \n    def calculate_modular_inverse(self, s1_times_sK):\n        # Calculate the modular inverse in real-time\n        pass\n\ndef aggregate_results(poles, earthquakes):\n    \"\"\"Aggregate results for problems concerning the poles.\"\"\"\n    last_pole_falls = []\n    for group in range(len(poles)):\n        if last_pole_falls[group] == group:\n            # Calculate probabilities using defined methods or classes\n            pass\n\n# Example on how the functions and classes could be used\nm = 5\ns = [1, 2, 3, 4, 5]  # Example data, replace with actual\nfind_probability_last_pole_falls(m, s)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou have an undirected graph with \\( N \\) vertices and initially, it has 0 edges. The vertices are labeled with integers from 1 to \\( N \\).\n\nYou need to process \\( Q \\) queries in sequence. Each query is one of the following types:\n\n1. Type 1: Given in the format `1 u v`. This indicates that you should add an edge between vertex \\( u \\) and vertex \\( v \\).\n2. Type 2: Given in the format `2 v k`. You need to print the \\( k \\)-th largest vertex number among the vertices connected to vertex \\( v \\). If there are fewer than \\( k \\) vertices connected to \\( v \\), print `-1`.\n\n**Constraints**\n\n- \\( 1 \\leq N, Q \\leq 2 \\times 10^5 \\)\n\n- For Type 1 queries, \\( 1 \\leq u < v \\leq N \\).\n\n- For Type 2 queries, \\( 1 \\leq v \\leq N \\) and \\( 1 \\leq k \\leq 10 \\).\n\n- All input values are integers.\n\n**Input Format**\n\nThe input is provided as follows:\n\n```\nN Q\nquery_1\nquery_2\n\u22ee\nquery_Q\n```\n\nEach `query_i` is one of the following formats:\n\n- `1 u v`\n- `2 v k`\n\n**Output Format**\n\nFor the \\( q \\) Type 2 queries, output \\( q \\) lines. The \\( i \\)-th line should contain the result of the \\( i \\)-th Type 2 query.\n\n**Sample Input 1**\n\n```\n4 10\n1 1 2\n2 1 1\n2 1 2\n2 1 3\n1 1 3\n1 2 3\n1 3 4\n2 1 1\n2 1 3\n2 1 5\n```\n\n**Sample Output 1**\n\n```\n2\n1\n-1\n4\n2\n-1\n```\n\n**Explanation of Sample Input 1**\n\n- In the first query, an edge is added between vertices 1 and 2.\n- In the second query, vertices connected to 1 are 1 and 2. The 1st largest vertex is 2, so we print 2.\n- In the third query, vertices connected to 1 are 1 and 2. The 2nd largest vertex is 1, so we print 1.\n- In the fourth query, vertices connected to 1 are 1 and 2, which are fewer than 3, so we print -1.\n- Subsequent queries modify the graph and queries for connected components are handled similarly.\n\n**Sample Input 2**\n\n```\n6 20\n1 3 4\n1 3 5\n2 1 1\n2 3 1\n1 1 5\n2 6 9\n2 1 3\n2 6 1\n1 4 6\n2 2 1\n2 6 2\n2 4 7\n1 1 4\n2 6 2\n2 3 4\n1 2 5\n2 4 1\n1 1 6\n2 3 3\n2 1 3\n```\n\n**Sample Output 2**\n\n```\n-1\n5\n-1\n-1\n-1\n3\n6\n2\n5\n-1\n5\n3\n6\n4\n4\n```\n\nSolution:\n\n```\nUNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nE - K-th Largest Connected Components Editorial by en_translator\n\nThis problem can be solved with a Disjoint Set Union (DSU). For each connected component, maintain the \\(K\\) vertices with the largest vertex numbers. On query \\(1\\), merge the two lists of \\(K\\) vertices with the largest vertex numbers for the two connected components in \\(O(K \\log K)\\) time. On query \\(2\\), the \\(k\\)-th largest vertex number can be retrieved in \\(O(1)\\) time. Modify the DSU struct as follows:\n\n1. On initializing DSU, add necessary data.\n2. On merging two vertices, merge the information of one of them into the other.\n\n```python\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.member = [[i] for i in range(n)]\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def merge(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n        self.member[x] += self.member[y]\n        self.member[x] = sorted(self.member[x], reverse=True)[:10]\n\nN, Q = map(int, input().split())\nuf = UnionFind(N + 1)\nfor _ in range(Q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        u, v = query[1:]\n        uf.merge(u, v)\n    else:\n        v, k = query[1:]\n        v = uf.find(v)\n        if len(uf.member[v]) < k:\n            print(-1)\n        else:\n            print(uf.member[v][k - 1])\n```\n```\n \n\n", "problem_ids": ["agc067_c", "arc177_d", "abc372_e"]}, "abc337_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( L \\), and \\( R \\). For a sequence \\( A = (1, 2, \\dots, N) \\) of length \\( N \\), an operation of reversing the \\( L \\)-th through \\( R \\)-th elements was performed once. Print the sequence after this operation.\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\leq L \\leq R \\leq N \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN L R\n```\n\n**Output**\n\nLet \\( A' = (A'_1, A'_2, \\dots, A'_N) \\) be the sequence after the operation. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n5 2 3\n```\n\n**Sample Output 1**\n```\n1 3 2 4 5\n```\n\nExplanation: Initially, \\( A = (1, 2, 3, 4, 5) \\). After reversing the second through third elements, the sequence becomes \\( (1, 3, 2, 4, 5) \\), which should be printed.\n\n**Sample Input 2**\n```\n7 1 1\n```\n\n**Sample Output 2**\n```\n1 2 3 4 5 6 7\n```\n\nExplanation: It is possible that \\( L = R \\).\n\n**Sample Input 3**\n```\n10 1 10\n```\n\n**Sample Output 3**\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nExplanation: It is possible that \\( L = 1 \\) or \\( R = N \\).\n\nSolution:\n\nHere is the cleaned version of the editorial text:\n\nApproach 1: Actually construct an array and apply reversion. Solve the problem by constructing the sequence \\(A=(1,2,\\dots,N)\\) as an array, reverse the \\(L\\)-th through \\(R\\)-th elements, and print the result. First, let \\(l=L\\) and \\(r=R\\). While \\(l<r\\), swap the \\(l\\)-th and \\(r\\)-th element, add \\(1\\) to \\(l\\), and subtract \\(1\\) from \\(r\\). Note that the first element might be treated as the \\(0\\)-th one depending on array usage.\n\nSample code 1 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nwhile L < R:\n    A[L], A[R] = A[R], A[L]\n    L += 1\n    R -= 1\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nSample code 2 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nA[L:R + 1] = reversed(A[L:R + 1])\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nApproach 2: Directly construct the sought sequence. The structure is as follows: arrange \\(1,2,\\dots,L-1\\), then \\(R,R-1,\\dots,L\\), and finally \\(R+1,R+2,\\dots,N\\).\n\nSample code (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nres = []\n\nfor i in range(1, L):\n    res.append(i)\nfor i in range(R, L - 1, -1):\n    res.append(i)\nfor i in range(R + 1, N + 1):\n    res.append(i)\n\nfor i in range(N):\n    if i:\n        print(\" \", end=\"\")\n    print(res[i], end=\"\")\nprint()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers \\( A \\) and \\( B \\) of length \\( N \\). Process \\( Q \\) queries given in the following forms in the order they are given. Each query is of one of the following three types:\n\n1. **Type 1**: Given in the form `1 i x`. Replace \\( A_i \\) with \\( x \\).\n2. **Type 2**: Given in the form `2 i x`. Replace \\( B_i \\) with \\( x \\).\n3. **Type 3**: Given in the form `3 l r`. Solve the following problem and print the answer:\n   - Initially, set \\( v = 0 \\). For \\( i = l, l+1, \\ldots, r \\) in this order, replace \\( v \\) with either \\( v + A_i \\) or \\( v \\times B_i \\). Find the maximum possible value of \\( v \\) at the end.\n\n**It is guaranteed that the answers to the given type 3 queries are at most \\( 10^{18} \\).**\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 10^5 \\)\n- For type 1 and 2 queries, \\( 1 \\leq i \\leq N \\).\n- For type 1 and 2 queries, \\( 1 \\leq x \\leq 10^9 \\).\n- For type 3 queries, \\( 1 \\leq l \\leq r \\leq N \\).\n- For type 3 queries, the value to be printed is at most \\( 10^{18} \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nQ\nquery_1\nquery_2\n\\vdots\nquery_Q\n```\n\nHere, `query_i` is the \\( i \\)-th query, given in one of the following formats:\n- `1 i x`\n- `2 i x`\n- `3 l r`\n\n**Output**\n\nLet \\( q \\) be the number of type 3 queries. Print \\( q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th type 3 query.\n\n**Sample Input 1**\n```\n3\n3 2 4\n1 2 2\n3\n3 1 3\n1 1 1\n3 1 3\n```\n\n**Sample Output 1**\n```\n12\n7\n```\n\nFor the first query, the answer is \\(((0 + A_1) \\times B_2) \\times B_3 = 12\\).\n\nFor the third query, the answer is \\(((0 + A_1) + A_2) + A_3 = 7\\).\n\n**Sample Input 2**\n```\n6\n65 32 12 5 8 312\n4 1 3 15 16 2\n6\n3 2 6\n3 1 5\n1 5 6\n2 4 9\n3 2 6\n3 3 5\n```\n\n**Sample Output 2**\n```\n46080\n69840\n27648\n1728\n```\n\nSolution:\n\n```\nConsider a type-3 query. Let \\(M\\) be the maximum \\(A\\). First, for \\(i = l\\), set \\(v = 0\\) and replace \\(v\\) with \\(v + A[i]\\). By the constraints, \\(v\\) becomes positive. Replace \\(v\\) with \\(v \\times B[i]\\) at most \\(\\log_2 M (< 60)\\) times, since \\(2^{60} > 10^{18}\\) and the input restricts this operation to under 60 times. Thus, the loop iterates a maximum of 59 times:\n\n```python\nv = A[l]\nwhile True:\n    next_l = min(r, smallest_i_after_l_plus_1_such_that_Bi_geq_2)\n    v += sum_a(l + 1, next_l)\n    v = max(v + A[next_l], v * B[next_l])\n    l = next_l\n    if l == r:\n        break\noutput(v)\n```\n\nBy using a segment tree appropriately, the complexity becomes \\(O(N + Q \\log N \\log M)\\). The algorithm is efficient due to the small constant factor.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given positive integers \\( N \\) and \\( L \\), and a sequence of positive integers \\( A = (A_{1}, A_{2}, \\dots, A_{N}) \\) of length \\( N \\).\n\nFor each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nDetermine if there exists a sequence of \\( L \\) non-negative integers \\( B = (B_{1}, B_{2}, \\dots, B_{L}) \\) such that:\n\n\\[\n\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = A_{i}\n\\]\n\nIf it exists, find the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^{5} \\)\n- \\( 2 \\leq L \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq A_{i} \\leq 2 \\times 10^{5} \\)\n\nAll input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN L\nA_{1} A_{2} \\cdots A_{N}\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain \\(-1\\) if no sequence \\( B \\) satisfies the condition for \\( i = k \\); otherwise, it should contain the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Sample Input 1:**\n\n```\n2 4\n10 5\n```\n\n**Sample Output 1:**\n\n```\n3\n-1\n```\n\n*Explanation*:\n- For \\( A_{1} = 10 \\), if we take \\( B = (1, 0, 2, 3) \\), then \\(\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = 10\\), where \\( \\max(B) = 3 \\). No non-negative integer sequence \\( B \\) satisfies the condition with \\( \\max(B) < 3 \\), so print 3 in the first line.\n- For \\( A_{2} = 5 \\), there is no non-negative integer sequence \\( B \\) that satisfies the condition, so print -1 in the second line.\n\n**Sample Input 2:**\n\n```\n6 8\n167 924 167167 167924 116677 154308\n```\n\n**Sample Output 2:**\n\n```\n11\n58\n10448\n10496\n7293\n9645\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 178\n\nC - Sum of Abs 2 Editorial by evima\n\nIn this explanation, the \u201csum of abs\u201d refers to the following formula: \n\\[\\sum_{j=1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}|\\]\n\nWhen \\(B\\) exists, one \\(B\\) that minimizes \\(\\max(B)\\) satisfies the following two conditions:\n- \\(B\\) is sorted in ascending order.\n- \\(B_{1} = 0\\).\n\nThe sum of abs does not depend on the order of \\(B\\). If all elements of \\(B\\) are positive, subtracting \\(1\\) from all elements can reduce \\(\\max(B)\\) without changing the sum of abs. When \\(B\\) is sorted in ascending order, the sum of abs can be expressed as follows: \n\\[\\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}| = \\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} (B_{k} - B_{j}) =\\sum_{k = 1} ^ {L - 1} k(L - k)(B_{k + 1} - B_{k})\\]\n\nThis transformation is correct because \\(B_{a}-B_{b}=(B_{a}-B_{a-1}) + (B_{a-1}+B_{a-2}) + \\cdots +(B_{b+1}-B_{b})\\) for integers \\(a, b\\) satisfying \\(1\\leq b<a\\leq L\\), and the number of pairs \\((a, b)\\) satisfying \\(b\\leq k\\) and \\(k+1\\leq a\\) is \\(k(L-k)\\).\n\nIf we let \\(C_{k} = B_{k + 1} - B_{k}\\), then when \\(B\\) is sorted in ascending order and \\(B_{1} = 0\\), the following holds:\n- \\(0 \\leq C_{k}\\).\n- The sum of abs is equal to \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}\\).\n- \\(\\displaystyle\\max(B) = B_{L} = \\sum_{k = 1} ^ {L - 1} C_{k}\\).\n\nTherefore, we need to solve the following problem: Determine if there exists a sequence of non-negative integers \\(C\\) of length \\(L - 1\\) such that \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}  = A_{i}\\), and if it exists, find the minimum sum of such \\(C\\).\n\nThis can be solved using dynamic programming in the same manner as the knapsack problem, and it can be computed simultaneously for all \\(i\\). Since \\(C_{k} = 0\\) always holds for \\(k\\) satisfying \\(\\max(A)<k(L-k)\\), our solution has a space complexity of \\(O(\\max(A))\\) and a time complexity of \\(O(N + \\max(A)\\sqrt{\\max(A)})\\).\n\nPython implementation example:\n\n```python\nN, L = map(int, input().split())\nA = list(map(int, input().split()))\n\nM = 2 * 10 ** 5\nINF = 10 ** 9\ndp = [INF] * (M + 1)\ndp[0] = 0\nk = 1\n\nwhile k * (L - k) <= M and k * 2 <= L:\n    w = k * (L - k)\n    for i in range(w, M + 1):\n        dp[i] = min(dp[i], dp[i - w] + 1)\n    k += 1\n\nfor a in A:\n    print(-1 if dp[a] == INF else dp[a])\n``` \n```\n \n\n", "problem_ids": ["abc356_a", "abc368_g", "arc178_c"]}, "abc338_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\(N\\) linear functions \\(f_1, f_2, \\ldots, f_N\\), where \\(f_i(x) = A_i x + B_i\\). Your task is to find the maximum possible value of \n\\[ \nf_{p_1}(f_{p_2}(\\ldots f_{p_K}(1) \\ldots )) \n\\]\nfor a sequence \\(p = (p_1, p_2, \\ldots, p_K)\\) composed of \\(K\\) distinct integers between \\(1\\) and \\(N\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq K \\leq \\text{min}(N,10)\\)\n- \\(1 \\leq A_i, B_i \\leq 50\\) for all \\(1 \\leq i \\leq N\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2\n2 3\n1 5\n4 2\n```\n\n**Sample Output 1**\n```\n26\n```\n\n**Explanation for Sample Input 1**\n\nHere are all possible \\(p\\) and the corresponding values of \\(f_{p_1}(f_{p_2}(1))\\):\n- \\(p= (1,2)\\): \\(f_1(f_2(1))=15\\)\n- \\(p= (1,3)\\): \\(f_1(f_3(1))=15\\)\n- \\(p= (2,1)\\): \\(f_2(f_1(1))=10\\)\n- \\(p= (2,3)\\): \\(f_2(f_3(1))=11\\)\n- \\(p= (3,1)\\): \\(f_3(f_1(1))=22\\)\n- \\(p= (3,2)\\): \\(f_3(f_2(1))=26\\)\n\nTherefore, the maximum value is \\(26\\), and you should print \\(26\\).\n\n**Sample Input 2**\n```\n10 3\n48 40\n34 22\n24 37\n45 40\n48 31\n49 44\n45 40\n44 6\n35 22\n39 28\n```\n\n**Sample Output 2**\n```\n216223\n```\n\nSolution:\n\n```python\nn, k = map(int, input().split())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nord_indices = list(range(n))\nord_indices.sort(key=lambda i: b[i] * (a[i] - 1), reverse=True)\n\ndp = [int(-1e9)] * (k + 1)\ndp[0] = 1\n\nfor i in ord_indices:\n    ndp = dp[:]\n    for j in range(k):\n        if dp[j] > int(-1e9):\n            ndp[j + 1] = max(ndp[j + 1], dp[j] * a[i] + b[i])\n    dp = ndp\n\nprint(dp[k])\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement (Score: 650 points)**\n\nWe call a positive integer \\( n \\) a \"good integer\" if and only if the sum of its positive divisors is divisible by 3. You are given two positive integers \\( N \\) and \\( M \\). Find the number, modulo 998244353, of length-\\( M \\) sequences \\( A \\) of positive integers such that the product of the elements in \\( A \\) is a good integer not exceeding \\( N \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^{10} \\)\n- \\( 1 \\leq M \\leq 10^5 \\)\n- \\( N \\) and \\( M \\) are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n10 1\n```\n\n**Sample Output 1**\n\n```\n5\n```\n\nThere are five sequences that satisfy the conditions:\n\n- (2)\n- (5)\n- (6)\n- (8)\n- (10)\n\n**Sample Input 2**\n\n```\n4 2\n```\n\n**Sample Output 2**\n\n```\n2\n```\n\nThere are two sequences that satisfy the conditions:\n\n- (1, 2)\n- (2, 1)\n\n**Sample Input 3**\n\n```\n370 907\n```\n\n**Sample Output 3**\n\n```\n221764640\n```\n\n**Sample Input 4**\n\n```\n10000000000 100000\n```\n\n**Sample Output 4**\n\n```\n447456146\n```\n\nSolution:\n\n```python\n# Here is the rewritten editorial with Python code:\n\n# Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\n# G - Divisible by 3 Editorial\n\n# This problem can be solved by finding a prefix sum of a multiplicative function. \n# A function f(n) is multiplicative if f(ab) = f(a) f(b) for all positive integers gcd(a, b) = 1.\n\n# Given a multiplicative function f(n), evaluate:\n# sum(1 <= n <= N) f(n).\n\n# **Facts and Problem Rephrasing:**\n\n# 1. sigma(n), the sum of the divisors of n, is multiplicative as per the formula:\n#    sigma(n) = prod(i=1 to k) (1 + p_i + ... + p_i^e_i)\n\n# 2. g(n), the number of length-M sequences of positive integers such that their product is M, is multiplicative:\n#    g(n) = prod(i=1 to k) comb(e_i + M - 1, M - 1)\n\n# Original problem:\n# sum(1 <= n <= N, sigma(n) % 3 = 0) g(n)\n\n# Define:\n# h(n) = \n# if sigma(n) % 3 == 0:\n#     0\n# else:\n#     g(n)\n\n# Rephrased Problem:\n# sum(n=1 to N) (g(n) - h(n))\n\n# Final expression:\n# sum(n=1 to N) g(n) - sum(n=1 to N) h(n)\n\n# There are efficient algorithms to compute these prefix sums:\n\n# **Lucy DP:**\n# Define:\n# F(n) = sum(1 <= m <= n) f(m),\n# F_prime(n) = sum(1 <= p <= n, p: prime) f(p),\n\n# Evaluate F_prime(n) for all n in Q_N using a dynamic programming approach, Lucy DP.\n\n# **Black Algorithm and Min_25 sieve:**\n# Evaluate F(N) using F_prime(n) results.\n\n# Black Algorithm: Uses a tree structure to compute F(N) leveraging the multiplicativity of the function.\n\n# Min_25 Sieve: Offers a more efficient approach with complexity O(N^(2/3)).\n\n# By implementing Lucy DP and one of the other methods, the problem is solved efficiently with complexity O(N^(3/4)/log N) or O(N^(1 - epsilon)).\n\n# **Advanced Topics:**\n\n# More efficient algorithms, like those by zhoukangyang (O(sqrt(N))) and Zhenting Zhu (Theta (N^(2/3) / (log N)^(4/3))), exist.\n# Other algorithms like Dujiao sieve or PowerfulNumber sieve can be used under specific conditions.\n```\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n---\n\n**Problem Statement**\n\nYou are given permutations \\(P = (P_1, P_2, \\ldots, P_N)\\) and \\(A = (A_1, A_2, \\ldots, A_N)\\) of \\((1, 2, \\ldots, N)\\).\n\nYou can perform the following operation any number of times, possibly zero: replace \\(A_i\\) with \\(A_{P_i}\\) simultaneously for all \\(i = 1, 2, \\ldots, N\\).\n\nPrint the lexicographically smallest \\(A\\) that can be obtained.\n\n---\n\n**What is lexicographical order?**\n\nFor sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\), \\(A\\) is lexicographically smaller than \\(B\\) if and only if there exists an integer \\(i\\) (1 \u2264 i \u2264 N) such that \\(A_i < B_i\\), and \\(A_j = B_j\\) for all \\(1 \\leq j < i\\).\n\n---\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n\n- \\(1 \\leq P_i \\leq N\\) (1 \u2264 i \u2264 N)\n\n- \\(P_i \\neq P_j\\) (1 \u2264 i < j \u2264 N)\n\n- \\(1 \\leq A_i \\leq N\\) (1 \u2264 i \u2264 N)\n\n- \\(A_i \\neq A_j\\) (1 \u2264 i < j \u2264 N)\n\nAll input values are integers.\n\n---\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nP_1 P_2 \\ldots P_N\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet \\( (A_1, A_2, \\ldots, A_N) \\) be the lexicographically smallest \\(A\\) that can be obtained. Print \\(A_1, A_2, \\ldots, A_N\\) in this order, separated by spaces, in one line.\n\n---\n\n**Sample Input 1**\n\n```\n6\n3 1 5 6 2 4\n4 3 1 6 2 5\n```\n\n**Sample Output 1**\n\n```\n1 4 2 5 3 6\n```\n\nInitially, \\(A = (4, 3, 1, 6, 2, 5)\\). Repeating the operation yields the following:\n- \\(A = (1, 4, 2, 5, 3, 6)\\)\n- \\(A = (2, 1, 3, 6, 4, 5)\\)\n- \\(A = (3, 2, 4, 5, 1, 6)\\)\n- \\(A = (4, 3, 1, 6, 2, 5)\\)\n\nAfter this, \\(A\\) will revert to the original state every four operations. Therefore, print the lexicographically smallest among these, which is `1 4 2 5 3 6`.\n\n---\n\n**Sample Input 2**\n\n```\n8\n3 5 8 7 2 6 1 4\n1 2 3 4 5 6 7 8\n```\n\n**Sample Output 2**\n\n```\n1 2 3 4 5 6 7 8\n```\n\nYou may choose to perform no operations.\n\n---\n\n**Sample Input 3**\n\n```\n26\n24 14 4 20 15 19 16 11 23 22 12 18 21 3 6 8 26 2 25 7 13 1 5 9 17 10\n15 3 10 1 13 19 22 24 20 4 14 23 7 26 25 18 11 6 9 12 2 21 5 16 8 17\n```\n\n**Sample Output 3**\n\n```\n4 1 22 18 20 13 14 6 15 11 3 26 2 12 5 23 9 10 25 24 7 17 16 21 19 8\n```\n\n\nSolution:\n\n```\nG - Lexicographically Smallest Permutation Editorial\n\nTo solve this problem, we consider minimizing elements sequentially, starting with the first. The key is to determine cycles in the permutation \\(P\\), and within each cycle, find the lexicographically smallest permutation. For a cycle with length \\(L\\), the number of minimal positions is \\(L / \\gcd(L, \\text{period})\\). We choose the minimal lexicographical arrangement by evaluating potential positions and adjusting the operation count \\(ans\\) accordingly. The process involves updating a result array based on minimized operations for each cycle, taking care of integer operations due to potential size. Here is the sample code:\n\n```python\nfrom math import gcd\n\nN = int(input())\nP = [int(x) - 1 for x in input().split()]\nA = list(map(int, input().split()))\n\nused = [False for i in range(N)]\n\nperiod = 1\nans = 0\n\nresult = [0 for i in range(N)]\n\nfor i in range(N):\n    if not used[i]:\n        cycle = [i]\n        while P[cycle[-1]] != i:\n            used[P[cycle[-1]]] = True\n            cycle.append(P[cycle[-1]])\n            \n        L = len(cycle)\n        choose = L // gcd(L, period)\n        offset = min((A[cycle[(ans + i * period) % L]], i) for i in range(choose))[1]\n        \n        ans += offset * period\n        period *= choose\n        \n        for i in range(L):\n            result[cycle[i]] = A[cycle[(i + ans) % L]]\n\nprint(*result)\n```\nThis effectively computes the lexicographically smallest permutation using the described method.\n```\n \n\n", "problem_ids": ["abc366_f", "abc370_g", "abc371_g"]}, "abc338_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nYou are given a string \\( S \\) consisting of lowercase and uppercase English letters. The length of \\( S \\) is odd. If the number of uppercase letters in \\( S \\) is greater than the number of lowercase letters, convert all lowercase letters in \\( S \\) to uppercase. Otherwise, convert all uppercase letters in \\( S \\) to lowercase.\n\nConstraints:\n- \\( S \\) is a string consisting of lowercase and uppercase English letters.\n- The length of \\( S \\) is an odd number between 1 and 99, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n\\( S \\)\n\nOutput:\nPrint the string \\( S \\) after converting the letters according to the problem statement.\n\nSample Input 1:\n```\nAtCoder\n```\n\nSample Output 1:\n```\natcoder\n```\nThe string `AtCoder` contains five lowercase letters and two uppercase letters. Thus, convert all uppercase letters in `AtCoder` to lowercase, which results in `atcoder`.\n\nSample Input 2:\n```\nSunTORY\n```\n\nSample Output 2:\n```\nSUNTORY\n```\nThe string `SunTORY` contains two lowercase letters and five uppercase letters. Thus, convert all lowercase letters in `SunTORY` to uppercase, which results in `SUNTORY`.\n\nSample Input 3:\n```\na\n```\n\nSample Output 3:\n```\na\n```\n\nSolution:\n\n        Here is the text:\n\n        [BEGIN TEXT]\n        Here is a succinct version of the editorial content relevant to the solution:\n\nThis problem requires processing strings by counting the occurrences of lowercase and uppercase letters in \\(S\\), and comparing them. If the number of lowercase letters is fewer, convert all uppercase letters to lowercase. Otherwise, convert all lowercase letters to uppercase. Most programming languages have functions for handling letter cases, such as:\n\n- `islower(c)`: checks if `c` is lowercase.\n- `isupper(c)`: checks if `c` is uppercase.\n- `tolower(c)`: converts `c` to lowercase.\n- `toupper(c)`: converts `c` to uppercase.\n\nThese functions can be used to implement the solution efficiently with a complexity of \\(\\mathrm{O}(|S|)\\).\n\nSample code (Python 3):\n\n```python\ndef process_string(S):\n    lower = sum(1 for c in S if c.islower())\n    upper = sum(1 for c in S if c.isupper())\n\n    if lower < upper:\n        S = ''.join(c.upper() for c in S)\n    else:\n        S = ''.join(c.lower() for c in S)\n\n    return S\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(process_string(S))\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 550 points\n\nProblem Statement:\nYou are given a sequence of integers \\( A = (A_1, \\ldots, A_N) \\). For a tree \\( T \\) with \\( N \\) vertices, define \\( f(T) \\) as follows:\n- Let \\( d_i \\) be the degree of vertex \\( i \\) in \\( T \\). Then, \\( f(T) = \\sum_{i=1}^N {d_i}^2 A_i \\).\n\nFind the minimum possible value of \\( f(T) \\).\n\nThe constraints guarantee that the answer will be less than \\( 2^{63} \\).\n\nConstraints:\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n4\n3 2 5 2\n```\n\nSample Output 1:\n```\n24\n```\n\nExplanation for Sample Output 1:\nConsider a tree \\( T \\) with an edge connecting vertices 1 and 2, an edge connecting vertices 2 and 4, and an edge connecting vertices 4 and 3. Then, \\( f(T) = 1^2 \\times 3 + 2^2 \\times 2 + 1^2 \\times 5 + 2^2 \\times 2 = 24 \\). It can be proven that this is the minimum value of \\( f(T) \\).\n\nSample Input 2:\n```\n3\n4 3 2\n```\n\nSample Output 2:\n```\n15\n```\n\nSample Input 3:\n```\n7\n10 5 10 2 10 13 15\n```\n\nSample Output 3:\n```\n128\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        **Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359) - Tree Degree Optimization**\n\nAn integer sequence \\(d=(d_1,\\ldots,d_N)\\) is eligible for a sequence of degrees if and only if:\n\n1. \\(d_i \\geq 1\\)\n2. \\(\\sum_{i=1}^N d_i = 2N-2\\)\n\nAny such sequence can be a sequence of degrees, so it is sufficient to minimize the cost over such sequences. The additional cost when incrementing \\(d_i\\) monotonically increases as \\(d_i\\) increases; thus, the problem can be solved greedily. First, initialize as \\(d_i=1\\) for all \\(i\\), and then repeat \\((N-2)\\) times by incrementing \\(d_i\\) for \\(i\\) with the minimal additional cost. This greedy algorithm can be optimized using a priority_queue, resulting in running in \\(\\mathrm{O}(N\\log N)\\) time.\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a string \\( S \\) consisting of lowercase English letters and periods (`.`). Your task is to find the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Constraints**\n\n- \\( S \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters and periods (`.`).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\( S \\)\n\n**Output**\n\nPrint the string obtained by removing all periods (`.`) from \\( S \\).\n\n**Sample Input 1**\n\n```\n.v.\n```\n\n**Sample Output 1**\n\n```\nv\n```\n\nRemoving all periods (`.`) from `.v.` yields `v`, so we print `v`.\n\n**Sample Input 2**\n\n```\nchokudai\n```\n\n**Sample Output 2**\n\n```\nchokudai\n```\n\nThere are cases where \\( S \\) does not contain periods (`.`).\n\n**Sample Input 3**\n\n```\n...\n```\n\n**Sample Output 3**\n\n```\n\n```\n\nThere are also cases where all characters in \\( S \\) are periods (`.`).\n\nSolution:\n\n```python\n# Python equivalent of C++ code\n\n# Standard implementation\n\nS = input()\nT = \"\"\nfor c in S:\n    if c != '.':\n        T += c\nprint(T)\n\n# Concise implementation\n\nS = input()\nS = S.replace('.', '')\nprint(S)\n```\n \n\n", "problem_ids": ["abc357_b", "abc359_f", "abc372_a"]}, "abc338_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\(N - 1\\) white balls and one black ball. These \\(N\\) balls are arranged in a row, with the black ball initially at the leftmost position.\n\nTakahashi will perform the following operation exactly \\(K\\) times:\n\n- Choose two distinct integers \\(a\\) and \\(b\\) uniformly at random from the range [1, \\(N\\)]. If \\(a \\neq b\\), swap the \\(a\\)-th and \\(b\\)-th balls from the left.\n\nAfter \\(K\\) operations, let the black ball be at the \\(x\\)-th position from the left. Find the expected value of \\(x\\), modulo \\(998244353\\).\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 998244352\\)\n- \\(1 \\leq K \\leq 10^5\\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n    N K\n\n**Output**\n\nPrint the answer in one line.\n\n**Notes on Computation**\n\nThe expected value modulo \\(998244353\\) is defined as follows:\n\nThe expected value can always be expressed as a rational number \\(\\frac{P}{Q}\\). Under these constraints, it is guaranteed that \\(Q\\) is not divisible by \\(998244353\\), ensuring the existence of a unique integer \\(R\\) such that:\n\\[ \nR \\times Q \\equiv P \\pmod{998244353} \n\\]\nwhere \\(0 \\leq R < 998244353\\). You need to report this \\(R\\).\n\n**Sample Input 1**\n\n    2 1\n\n**Sample Output 1**\n\n    499122178\n\nExplanation: After one operation, the probabilities that the black ball is at the 1st position and the 2nd position from the left are both \\(\\frac{1}{2}\\). Thus, the expected value is \\(\\frac{3}{2}\\).\n\n**Sample Input 2**\n\n    3 2\n\n**Sample Output 2**\n\n    554580198\n\n**Sample Input 3**\n\n    4 4\n\n**Sample Output 3**\n\n    592707587\n\nSolution:\n\n[BEGIN TEXT]\nHere is the cleaned version of the editorial text:\n\n---\n\n**E - Random Swaps of Balls Editorial**\n\nBy the symmetry of the operation, if the probability that a black ball is at the leftmost position is \\(p\\), then that of being each of the other positions is \\(\\displaystyle \\frac{1 - p}{N - 1}\\). Thus, one can solve the problem by finding the probability that \\(K\\) operations make the leftmost ball black. This can be computed with Dynamic Programming (DP). Define\n\n\\(\\mathrm{dp}[i] :=\\) Probability that \\(i\\) operations make the leftmost ball black.\n\nWhat we want is \\(\\mathrm{dp}[K]\\). The transition requires the following two probabilities:\n\n- The probability that an operation moves the leftmost black ball to somewhere else.\n- The probability that an operation moves the black ball elsewhere to the leftmost position.\n\nDenoting them by \\(p, q\\), the transitions are as follows:\n\n\\(\\mathrm{dp}[0] = 1\\)  \n\\(\\mathrm{dp}[i+1] = (1 - p) \\mathrm{dp}[i] + q(1 - \\mathrm{dp}[i])\\)\n\nBy simple combinatorics:\n\n\\(\\displaystyle p = \\frac{2(n - 1)}{n^2}\\)  \n\\(\\displaystyle q = \\frac{2}{n^2}\\)\n\nImplementing it naively yields an \\(\\mathcal{O}(K)\\) solution, but it simplifies to a first-order recurrence relation, which can be efficiently computed, allowing \\(\\mathrm{dp}[K]\\) to be found in \\(\\mathcal{O}(\\log K)\\) time. This transforms the problem into a typical high-school math problem. More generally, algorithms such as the matrix powering algorithm and Fiduccia\u2019s algorithm can find the \\(N\\)-th term of a linear recurrence relation.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nAlice and Bob are playing a game with two positive integers \\( N \\) and \\( M \\), where \\( N < M \\). Each player has \\( N \\) cards numbered from 1 to \\( N \\). Alice starts the game, and they take turns playing one card from their hand onto the table. If, after a player plays a card, the sum of the numbers on the table is divisible by \\( M \\), the player who played the last card loses, and the other player wins. If all cards are played and the sum is never divisible by \\( M \\), Alice wins. Given \\( T \\) test cases, determine who will win (Alice or Bob) if both play optimally.\n\nConstraints:\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N < M \\leq 10^9 \\)\n\nInput:\n- The input consists of \\( T \\) test cases.\n- Each test case is described by two integers \\( N \\) and \\( M \\).\n\nOutput:\n- For each test case, output \"Alice\" if Alice wins or \"Bob\" if Bob wins when both players play optimally.\n\nSample Input:\n```\n8\n2 3\n3 6\n5 9\n45 58\n39 94\n36 54\n74 80\n61 95\n```\n\nSample Output:\n```\nAlice\nAlice\nBob\nBob\nAlice\nBob\nBob\nAlice\n```\n\nIn the first test case, both Alice and Bob have two cards: a 1 and a 2. Alice plays 1, and the sum is 1, which is not divisible by 3. Bob plays 1, making the sum 2, still not divisible by 3. Alice plays 2, making the sum 4, not divisible by 3. Bob plays 2, making the sum 6, which is divisible by 3, so Bob loses, and Alice wins. Alice wins regardless of Bob's strategy.\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 185\n\ndef mod_m_game(N, M):\n    # Calculate c\n    c = (N * (N + 1)) % M\n\n    # Determine if Alice loses or wins\n    if 1 <= c <= N:\n        return \"Bob wins\"\n    else:\n        return \"Alice wins\"\n\n# Example Usage\nN = 5\nM = 3\nresult = mod_m_game(N, M)\nprint(result)  # Output should be \"Bob wins\" or \"Alice wins\" based on the conditions\n```\n\nEditorial - AtCoder Regular Contest 185\n\nA - mod M Game 2 Editorial by evima\n\nFirst, focus on the moment when Alice plays her last card:\n\n- A player with two or more cards can avoid playing a losing card.\n- If Alice doesn't lose when playing her last card, she will win regardless of Bob's last move.\n\nDetermine if Alice loses with her last card using Bob\u2019s last card \\(b\\). The sum of the numbers on the cards played is \\(N(N+1) - b\\). We check if \\(N(N + 1) - b \\equiv 0 \\pmod{M}\\).\n\n1. If \\(1 \\leq (N(N+1) \\bmod M) \\leq N\\):\n   - Let \\(c = N(N + 1) \\bmod M\\). Bob can make his last card \\(b = c\\) by playing all cards except \\(c\\), leading to Alice's loss. Bob can achieve this by keeping \\(c\\) among his final cards.\n\n2. If \\(N(N + 1) - b\\) cannot be \\(0\\):\n   - Alice will not lose on her last card, leading to her victory.\n\nBob wins if \\(1 \\leq N(N + 1) \\bmod M \\leq N\\), otherwise Alice wins. This can be determined in \\(O(1)\\) time.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) sequences of length \\( M \\), where each element is either 0 or 1. The \\( i \\)-th sequence is \\( A_i = (A_{i, 1}, A_{i, 2}, \\dots, A_{i, M}) \\).\n\nFor integers \\( i, j \\) \\((1 \\leq i, j \\leq N)\\), define \\( f(i, j) \\) as follows: \\( f(i, j) \\) is the smallest non-negative integer \\( x \\) such that \\( A_i \\) and \\( A_j \\) become identical after performing the following operation \\( x \\) times, or \\( 0 \\) if such \\( x \\) does not exist.\n\nOperation: For all integers \\( k \\) \\((1 \\leq k \\leq M)\\) simultaneously, replace \\( A_{i, k} \\) with \\( \\left (\\sum_{l=1}^{k} A_{i, l} \\right ) \\bmod 2 \\).\n\nFind \\( \\sum_{i=1}^{N} \\sum_{j=i}^{N} f(i, j) \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\times M \\leq 10^6 \\)\n- \\( A_{i, j} \\in \\{0, 1\\} \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1, 1} A_{1, 2} \\cdots A_{1, M}\nA_{2, 1} A_{2, 2} \\cdots A_{2, M}\n\\vdots\nA_{N, 1} A_{N, 2} \\cdots A_{N, M}\n```\n\n**Output**\n\nPrint the answer in one line.\n\n**Sample Input 1**\n\n```\n4 3\n1 0 0\n1 1 0\n1 0 1\n0 1 1\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\nExplanation: \\( f(1, 1) = 0 \\), \\( f(1, 2) = 3 \\), \\( f(1, 3) = 2 \\), \\( f(1, 4) = 0 \\), \\( f(2, 2) = 0 \\), \\( f(2, 3) = 3 \\), \\( f(2, 4) = 0 \\), \\( f(3, 3) = 0 \\), \\( f(3, 4) = 0 \\), \\( f(4, 4) = 0 \\), summing to 8.\n\n**Sample Input 2**\n\n```\n7 6\n1 0 0 0 0 0\n1 1 1 0 0 0\n1 0 1 1 0 0\n1 0 0 0 1 1\n1 0 0 0 0 1\n1 0 0 0 0 0\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n\n```\n6\n```\n\nSolution:\n\n```plaintext\nEditorial - E - Accumulating Many Times\n\nFirst, treat sequences that differ in the position of their first \\(1\\) as separate problems, since operations do not change this position. Assume \\(A_{i, 1} = 1\\). Define the inverse operation for the problem's operation. The graph formed by length-\\(M\\) binary sequences starting with \\(1\\) has operations as edges and is a collection of cycles. \n\nEvery sequence can be transformed into a \u201cstandard form\u201d where all elements at positions \\((2^x + 1)\\) using non-negative integer \\(x\\) are \\(0\\). This is proven using Lucas\u2019s theorem. Cycle length is \\(2^m\\), where \\(m\\) is the smallest non-negative integer such that \\(2^m + 1 \\leq M\\).\n\nTo solve, first transform sequences to their standard forms and calculate the required operations. For each \\(i = 1, 2, \\dots, N\\), compute the standard form of sequence \\(A_i\\) and the cost to reach it. Transform \\(A_{i, 2^x + 1}\\) into \\(0\\) by performing the operation \\(2^x\\) times if \\(A_{i, 2^x + 1} = 1\\).\n\nNext, solve for each standard form: for integer sequence \\(B\\), compute \\(\\displaystyle \\sum_{i=1}^{m} \\sum_{j=i}^{m} \\left( (B_j - B_i) \\bmod 2^m \\right)\\) using Segment Tree or similar structures.\n\nThe computational bottleneck is computing the standard forms. Multiple operations using FFT help, but we may exceed the time limit if performed every time. Instead, keep track of operations count to determine value at a position in \\(O(M)\\) time. Overall complexity is \\(O(NM \\log NM)\\).\n```\n \n\n", "problem_ids": ["abc360_e", "arc185_a", "arc184_e"]}, "abc338_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( L \\), and \\( R \\). For a sequence \\( A = (1, 2, \\dots, N) \\) of length \\( N \\), an operation of reversing the \\( L \\)-th through \\( R \\)-th elements was performed once. Print the sequence after this operation.\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\leq L \\leq R \\leq N \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN L R\n```\n\n**Output**\n\nLet \\( A' = (A'_1, A'_2, \\dots, A'_N) \\) be the sequence after the operation. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n5 2 3\n```\n\n**Sample Output 1**\n```\n1 3 2 4 5\n```\n\nExplanation: Initially, \\( A = (1, 2, 3, 4, 5) \\). After reversing the second through third elements, the sequence becomes \\( (1, 3, 2, 4, 5) \\), which should be printed.\n\n**Sample Input 2**\n```\n7 1 1\n```\n\n**Sample Output 2**\n```\n1 2 3 4 5 6 7\n```\n\nExplanation: It is possible that \\( L = R \\).\n\n**Sample Input 3**\n```\n10 1 10\n```\n\n**Sample Output 3**\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nExplanation: It is possible that \\( L = 1 \\) or \\( R = N \\).\n\nSolution:\n\nHere is the cleaned version of the editorial text:\n\nApproach 1: Actually construct an array and apply reversion. Solve the problem by constructing the sequence \\(A=(1,2,\\dots,N)\\) as an array, reverse the \\(L\\)-th through \\(R\\)-th elements, and print the result. First, let \\(l=L\\) and \\(r=R\\). While \\(l<r\\), swap the \\(l\\)-th and \\(r\\)-th element, add \\(1\\) to \\(l\\), and subtract \\(1\\) from \\(r\\). Note that the first element might be treated as the \\(0\\)-th one depending on array usage.\n\nSample code 1 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nwhile L < R:\n    A[L], A[R] = A[R], A[L]\n    L += 1\n    R -= 1\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nSample code 2 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nA[L:R + 1] = reversed(A[L:R + 1])\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nApproach 2: Directly construct the sought sequence. The structure is as follows: arrange \\(1,2,\\dots,L-1\\), then \\(R,R-1,\\dots,L\\), and finally \\(R+1,R+2,\\dots,N\\).\n\nSample code (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nres = []\n\nfor i in range(1, L):\n    res.append(i)\nfor i in range(R, L - 1, -1):\n    res.append(i)\nfor i in range(R + 1, N + 1):\n    res.append(i)\n\nfor i in range(N):\n    if i:\n        print(\" \", end=\"\")\n    print(res[i], end=\"\")\nprint()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nIn the Kingdom of AtCoder, residents are required to shout their love for takoyaki at \\( A \\) o'clock every day.\n\nTakahashi, who lives in the Kingdom of AtCoder, goes to bed at \\( B \\) o'clock and wakes up at \\( C \\) o'clock every day (in the 24-hour clock). He can shout his love for takoyaki when he is awake, but cannot when he is asleep. Determine whether he can shout his love for takoyaki every day. Here, a day has 24 hours, and his sleeping time is less than 24 hours.\n\n**Constraints**\n- \\( 0 \\leq A, B, C < 24 \\)\n- \\( A \\), \\( B \\), and \\( C \\) are pairwise different.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can shout his love for takoyaki every day, and `No` otherwise.\n\n**Sample Input 1**\n```\n21 8 14\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Takahashi goes to bed at 8 o'clock and wakes up at 14 o'clock every day. He is awake at 21 o'clock, so he can shout his love for takoyaki every day. Therefore, print `Yes`.*\n\n**Sample Input 2**\n```\n0 21 7\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*Takahashi goes to bed at 21 o'clock and wakes up at 7 o'clock every day. He is not awake at 0 o'clock, so he cannot shout his love for takoyaki every day. Therefore, print `No`.*\n\n**Sample Input 3**\n```\n10 7 17\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 367 - Editorial\n\n**Problem Solution:**\n\nThe problem can be solved by employing casework based on whether the person is asleep at midnight. \n\n1. **If not asleep at midnight:**\n   - The person sleeps from \\(B\\) to \\(C\\) o\u2019clock. The answer is \"No\" if \\(A\\) o\u2019clock is between \\(B\\) and \\(C\\) (\\(B<A<C\\)). Otherwise, the answer is \"Yes\".\n\n2. **If asleep at midnight:**\n   - The person is awake from \\(C\\) to \\(B\\) o\u2019clock. The answer is \"Yes\" if \\(A\\) o\u2019clock is between \\(C\\) and \\(B\\) (\\(C<A<B\\)). Otherwise, the answer is \"No\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A and A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A and A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Alternative Approach:**\n\nTo avoid casework, use a while statement starting from \\(B\\) and increment hour by hour. If \\(A\\) is reached before \\(C\\), print \"No\". Otherwise, print \"Yes\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nnow = B\nwhile now != C:\n    if now == A:\n        print(\"No\")\n        exit()\n    now += 1\n    now %= 24\n\nprint(\"Yes\")\n```\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integer sequences of length \\( N \\): \\( A = (A_1, A_2, \\cdots, A_N) \\) and \\( B = (B_1, B_2, \\cdots, B_N) \\), and an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n- Choose integers \\( i \\) and \\( j \\) (where \\( 1 \\leq i, j \\leq N \\)) such that \\( |i-j| \\leq K \\). Then, change the value of \\( A_i \\) to \\( A_j \\).\n\nDetermine whether it is possible to make \\( A \\) identical to \\( B \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 125000 \\)\n- \\( 1 \\leq K < N \\leq 250000 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- The sum of \\( N \\) across all test cases in each input is at most 250000.\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\nB_1 B_2 \\cdots B_N\n```\n\n**Output Format**\n\nFor each test case, print `Yes` if it is possible to make \\( A \\) identical to \\( B \\), and `No` otherwise.\n\n**Sample Input 1**\n\n```\n4\n3 1\n1 1 2\n1 2 2\n5 4\n2 4 5 1 3\n2 1 3 2 2\n13 1\n3 1 3 3 5 3 3 4 2 2 2 5 1\n5 3 3 3 4 2 2 2 2 5 5 1 3\n20 14\n10 6 6 19 13 16 15 15 2 10 2 16 9 12 2 6 13 5 5 9\n5 9 6 2 10 19 16 15 13 12 10 2 9 6 5 16 19 12 15 13\n```\n\n**Sample Output 1**\n\n```\nYes\nYes\nNo\nYes\n```\n\n**Explanation for Sample Input 1**\n\nConsider the first test case. If we operate with \\( i=2 \\) and \\( j=3 \\), the value of \\( A_2 \\) will be changed to \\( A_3=2 \\), resulting in \\( A=(1,2,2) \\).\n\nSolution:\n\n```\nOfficial\n\nB - Near Assignment Editorial by evima\n\nIf \\(A = B\\), it is clearly possible, so we consider other cases. Consider two cases based on the value of \\(K\\).\n\nCase \\(K = 1\\): Considering the result of run-length encoding of the elements in \\(A\\), it can \u201cdecrease\u201d through operations, but not \u201cincrease.\u201d From this, we can deduce that the result of run-length encoding of \\(B\\) must be a subsequence of the run-length encoded \\(A\\). This condition is also sufficient because we can perform operations that extend the subsequence of \\(A\\) corresponding to \\(B\\). This solves the case where \\(K = 1\\).\n\nCase \\(K \\geq 2\\): Looking at the operations in reverse, they can be seen as follows:\n\nChoose \\(i,j\\) that satisfy \\(|i-j| \\leq K\\) and \\(B_i = B_j\\), then change \\(B_i\\) to any desired value. First, if no operation can be performed on \\(B\\), the answer is No. Also, if there is a value in \\(B\\) that does not appear in \\(A\\), the answer is No. Actually, in all other cases, the answer is Yes. Let\u2019s reinterpret the part where \\(B_i\\) can be changed to any desired value as an operation where \\(B_i\\) is changed to a wildcard \\(*\\). By performing one operation on \\(B\\), we create a state where there is exactly one \\(*\\). The involvement of \\(*\\) enables us to swap adjacent elements in \\(B\\).\n\nIf you want to change \\(*x\\) to \\(x*\\): think of \\(*x\\) as \\(xx\\) and perform the operation to turn it into \\(x*\\). If you want to change \\(*xy\\) to \\(*yx\\): follow the steps \\(*xy \\to yxy \\to yx* \\to y*x \\to *yx\\).\n\nBy combining these operations, you can remove all duplicates in \\(B\\) and arrange them in any desired order. In particular, you can arrange \\(B\\) to match \\(A\\). Therefore, it can be determined that \\(A\\) can be transformed into \\(B\\). Implementing the above operations directly yields an \\(O(N)\\) solution. The sample code below lazily uses sorting and is an \\(O(N\\log N)\\) solution.\n```\n \n\n", "problem_ids": ["abc356_a", "abc367_a", "arc183_b"]}, "abc338_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 550 points\n\n## Problem Statement\n\nYou are given a weighted undirected connected graph \\( G \\) with \\( N \\) vertices and \\( N-1 \\) edges, where vertices are numbered from \\( 1 \\) to \\( N \\) and edges are numbered from \\( 1 \\) to \\( N-1 \\). Edge \\( i \\) connects vertices \\( a_i \\) and \\( b_i \\) with a weight of \\( c_i \\).\n\nYou are given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- You are given integers \\( u_i, v_i, w_i \\). Add an edge with weight \\( w_i \\) between vertices \\( u_i \\) and \\( v_i \\) in \\( G \\). Then, print the sum of the weights of the edges in a minimum spanning tree of \\( G \\).\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i < b_i \\leq N \\)\n- \\( 1 \\leq u_i < v_i \\leq N \\)\n- \\( 1 \\leq c_i, w_i \\leq 10 \\)\n- The graph is connected before processing the queries.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\na_1 b_1 c_1\n.\n.\n.\na_{N-1} b_{N-1} c_{N-1}\nu_1 v_1 w_1\n.\n.\n.\nu_Q v_Q w_Q\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n## Sample Input 1\n\n```\n4 4\n1 2 6\n2 3 5\n2 4 4\n1 3 3\n1 2 3\n1 4 10\n3 4 1\n```\n\n## Sample Output 1\n\n```\n12\n10\n10\n7\n```\n\nHere is the graph after adding the edge for each query. The edges included in the minimum spanning tree are colored red.\n\n## Sample Input 2\n\n```\n8 6\n1 8 8\n1 6 10\n1 5 8\n2 6 6\n6 7 6\n1 3 9\n2 4 7\n1 3 4\n1 6 7\n3 4 6\n1 5 1\n7 8 4\n3 5 3\n```\n\n## Sample Output 2\n\n```\n49\n46\n45\n38\n34\n33\n```\n\nSolution:\n\n```\nHere is the trimmed editorial:\n\n---\n\n**F - MST Query Editorial**\n\nLet \\(W=10\\) be the maximum edge weight. Let \\(G_k (0\\leq k\\leq W)\\) be the (unweighted) subgraph of \\(G\\) consisting of the edges of \\(G\\) with weights not more than \\(k\\). Let \\(H\\) be the number of connected components of a graph \\(H\\), then the sum of weights of edges in an MST of graph \\(G\\) equals \\(\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Proof) Approach 1:** Among the edges in an MST of \\(G\\), there are \\(N-c(G_k)\\) edges whose weight is not greater than \\(k\\). Therefore, there are \\(\\left(N-c(G_k)\\right)-\\left(N-c(G_{k-1})\\right)=c(G_{k-1})-c(G_k)\\) edges whose weight is exactly \\(k\\), so the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle \\sum_{k=1}^{W}k\\left(c(G_{k-1})-c(G_k)\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)\\right)-W\\cdot c(G_W)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Approach 2):** Among the edges in an MST of \\(G\\), there are \\(c(G_{k-1})-1\\) edges whose weight is not greater than \\(c(G_{k-1})-1\\). Thus, the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle\\sum_{k=1}^{W}\\left(c(G_{k-1})-1\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left(c(G_k)-1\\right)\\).\n\nFor each \\(k(0\\leq k\\lt W)\\), one can manage the number of connected components of \\(G_k\\) with a disjoint set union (DSU) to solve this problem in a total of \\(O(W(N+Q)\\alpha(N))\\). The complexity can be reduced to \\(O((WN+Q)\\alpha(N))\\).\n\n**Sample Code:**\n\n```python\nfrom atcoder.dsu import DSU\n\nN, Q = map(int, input().split())\nuf = [DSU(N + 1) for i in range(10)]\nans = 10 * N - 10\nfor i in range(N - 1 + Q):\n    a, b, c = map(int, input().split())\n    for j in range(c, 10):\n        if not uf[j].same(a, b):\n            ans -= 1\n            uf[j].merge(a, b)\n    if i >= N - 1:\n        print(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi will encounter \\( N \\) monsters in order. The \\( i \\)-th monster \\((1 \\leq i \\leq N)\\) has a strength of \\( A_i \\).\n\nFor each monster, he can choose to either let it go or defeat it. Each action awards him experience points as follows:\n- If he lets a monster go, he gains 0 experience points.\n- If he defeats a monster with strength \\( X \\), he gains \\( X \\) experience points. If it is an even-numbered defeated monster (2nd, 4th, ...), he gains an additional \\( X \\) experience points.\n\nFind the maximum total experience points he can gain from the \\( N \\) monsters.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the maximum total experience points he can gain from the \\( N \\) monsters as an integer.\n\n**Sample Input 1:**\n```\n5\n1 5 3 2 7\n```\n\n**Sample Output 1:**\n```\n28\n```\n\n**Explanation:**\n\nIf Takahashi defeats the 1st, 2nd, 3rd, and 5th monsters, and lets the 4th monster go, he gains experience points as follows:\n- Defeats a monster with strength \\( A_1 = 1 \\). He gains 1 experience point.\n- Defeats a monster with strength \\( A_2 = 5 \\). He gains 5 experience points. As it is the 2nd defeated monster, he gains an additional 5 points.\n- Defeats a monster with strength \\( A_3 = 3 \\). He gains 3 experience points.\n- Lets the 4th monster go. Takahashi gains no experience points.\n- Defeats a monster with strength \\( A_5 = 7 \\). He gains 7 experience points. As it is the 4th defeated monster, he gains an additional 7 points.\n\nTherefore, in this case, he gains \\( 1+(5+5)+3+0+(7+7)=28 \\) experience points. Note that even if he encounters a monster, if he lets it go, it does not count as defeated. He can gain at most 28 experience points no matter how he acts, so print 28. As a side note, if he defeats all monsters in this case, he would gain \\( 1+(5+5)+3+(2+2)+7=25 \\) experience points.\n\n**Sample Input 2:**\n```\n2\n1000000000 1000000000\n```\n\n**Sample Output 2:**\n```\n3000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 369\n\nD - Bonus EXP Editorial\n\nThis problem can be solved with dynamic programming (DP). Let \\(dp_{even}[k]\\) be the maximum total experience point when defeating an even number of monsters out of the first \\(k\\) monsters encountered, and \\(dp_{odd}[k]\\) be that for an odd number of monsters (or \\(-\\infty\\) if it is impossible). Initially, \\(dp_{even}[0]=0\\) and \\(dp_{odd}[0]=-\\infty\\).\n\nFor \\(1\\leq i\\leq N\\), the experience point from the \\(i\\)-th monster depends on whether Takahashi chooses to defeat it or not, and whether the number of defeated monsters is even or odd. To encounter the first \\(i\\) monsters and defeat an even number, we have two cases:\n\n1. Defeat an even number of monsters from the first \\((i-1)\\) and let the \\(i\\)-th go.\n2. Defeat an odd number of monsters from the first \\((i-1)\\) and defeat the \\(i\\)-th.\n\nThus, we can find \\(dp_{even}[i]\\) as \n\\[\ndp_{even}[i]=\\max(dp_{even}[i-1],dp_{odd}[i-1]+2A_i).\n\\]\n\nSimilarly, \\(dp_{odd}[i]\\) is\n\\[\ndp_{odd}[i]=\\max(dp_{odd}[i-1],dp_{even}[i-1]+A_i).\n\\]\n\nThe final answer is \\(\\max(dp_{even}[N],dp_{odd}[N])\\), with a complexity of \\(O(N)\\).\n\nSample code in Python:\n```python\nINF = 10**18\n\ndef main():\n    n = int(input())\n    dp0, dp1 = 0, -INF\n    for _ in range(n):\n        x = int(input())\n        tmp = dp0\n        dp0 = max(dp1 + 2*x, dp0)\n        dp1 = max(tmp + x, dp1)\n    print(max(dp0, dp1))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 150 points\n\nProblem Statement:\nThere are \\(2N\\) people standing in a row, and the person at the \\(i\\)-th position from the left is wearing clothes of color \\(A_i\\). The clothes have \\(N\\) colors from \\(1\\) to \\(N\\), and exactly two people are wearing clothes of each color.\n\nFind how many of the integers \\(i=1,2,\\ldots,N\\) satisfy the following condition:\n- There is exactly one person between the two people wearing clothes of color \\(i\\).\n\nConstraints:\n- \\(2 \\leq N \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- Each integer from \\(1\\) through \\(N\\) appears exactly twice in \\(A\\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{2N}\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n3\n1 2 1 3 2 3\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation:\nThere are two values of \\(i\\) that satisfy the condition: \\(1\\) and \\(3\\).\nIn fact, the people wearing clothes of color \\(1\\) are at the 1st and 3rd positions from the left, with exactly one person in between.\n\nSample Input 2:\n```\n2\n1 1 2 2\n```\n\nSample Output 2:\n```\n0\n```\n\nExplanation:\nThere may be no \\(i\\) that satisfies the condition.\n\nSample Input 3:\n```\n4\n4 3 2 3 2 1 4 1\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nB - Couples Editorial by en_translator\n\nBy mathematically interpreting the problem statement, it turns out that it is asking to count \\(i\\) such that \\(A_i=A_{i+2}\\). Use for and if statements to check if each \\(i\\) satisfies the condition. Sample code (Python3):\n\n```python\nn = int(input())\na = [int(input()) for _ in range(n * 2)]\nres = 0\nfor i in range(n * 2 - 2):\n    if a[i] == a[i + 2]:\n        res += 1\nprint(res)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc355_f", "abc369_d", "abc359_b"]}, "abc338_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 100 points\n\n**Problem Statement**\n\nTakahashi is planning to eat \\( N \\) dishes. \n- The \\( i \\)-th dish he plans to eat is sweet if \\( S_i = \\text{sweet} \\), and salty if \\( S_i = \\text{salty} \\). \n- If he eats two sweet dishes consecutively, he will feel sick and be unable to eat any more dishes. \n\nDetermine whether he can eat all the dishes.\n\n**Constraints**\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is either \\text{sweet} or \\text{salty}.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nS_1\nS_2\n...\nS_N\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can eat all the dishes, and `No` otherwise.\n\n**Sample Input 1**\n```\n5\nsalty\nsweet\nsalty\nsalty\nsweet\n```\n\n**Sample Output 1**\n```\nYes\n```\n*Takahashi will not eat two sweet dishes consecutively, so he can eat all the dishes without feeling sick.*\n\n**Sample Input 2**\n```\n4\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 2**\n```\nYes\n```\n*He will feel sick but can still eat all the dishes.*\n\n**Sample Input 3**\n```\n6\nsalty\nsweet\nsweet\nsalty\nsweet\nsweet\n```\n\n**Sample Output 3**\n```\nNo\n```\n*He feels sick when eating the 3rd dish and cannot eat the 4th and subsequent dishes.*\n\nSolution:\n\n        [BEGIN TEXT]\n        Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nIf there exists an integer \\(i\\) between \\(1\\) and \\((N-2)\\) such that the \\(i\\)-th and \\((i+1)\\)-th dishes to eat are both sweet, he cannot eat the \\((i+2)\\)-th dish and cannot eat all of the dishes. Otherwise, he does not get sick until eating the last dish, so he can eat all the dishes. Note that indices start from \\(0\\) in the following sample code.\n\n```python\nn = int(input())\ns = [input().strip() for _ in range(n)]\nans = \"Yes\"\nfor i in range(n - 2):\n    if s[i] == \"sweet\" and s[i + 1] == \"sweet\":\n        ans = \"No\"\nprint(ans)\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a simple undirected graph \\( G \\) with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). The graph \\( G \\) has \\( M \\) edges, and the \\( i \\)-th edge connects vertices \\( A_i \\) and \\( B_i \\).\n\nCheck if \\( G \\) satisfies the following condition:\n- For every subset \\( X \\) of the vertex set \\(\\{1, 2, \\cdots, N\\}\\), there exists a subset \\( Y \\) of \\( X \\) such that \\(|Y| \\ge \\frac{|X|}{2}\\) and \\( Y \\) forms a clique.\n\nYou have \\( T \\) test cases to solve.\n\n**Constraints:**\n- \\( 1 \\le T \\le 10^3 \\)\n- \\( 1 \\le N \\le 10^5 \\)\n- \\( 0 \\le M \\le 10^6 \\)\n- \\( 1 \\le A_i, B_i \\le N \\)\n- The given graph doesn't contain self-loops or multiple edges.\n- The sum of \\( N \\) across the test cases in a single input is at most \\( 10^5 \\).\n- The sum of \\( M \\) across the test cases in a single input is at most \\( 10^6 \\).\n- All input values are integers.\n\n**Input**\n\nInput is given from the standard input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN M\nA_1 B_1\nA_2 B_2\n\\vdots\nA_M B_M\n```\n\n**Output**\n\nFor each test case, if \\( G \\) satisfies the condition, output `Yes`; otherwise, output `No`. You can output each letter in any case (upper or lower).\n\n**Sample Input**\n```\n4\n3 3\n1 2\n1 3\n2 3\n3 2\n1 2\n1 3\n3 1\n1 2\n3 0\n```\n\n**Sample Output**\n```\nYes\nYes\nYes\nNo\n```\n\n**Explanation**\n\n- For the 1st test case, \\( G \\) satisfies the condition. In this case, every subset \\( X \\) is a clique, so we can just let \\( Y = X \\).\n- For the 2nd test case, \\( G \\) satisfies the condition. For example, for \\( X = \\{2, 3\\} \\), we can let \\( Y = \\{2\\} \\).\n- For the 4th test case, \\( G \\) doesn't satisfy the condition. If we let \\( X = \\{1, 2, 3\\} \\), no subset \\( Y \\) of \\( X \\) satisfies the condition.\n\nSolution:\n\nHere is the cleaned version of the solution editorial:\n\nWe claim that a graph is good if and only if its complement is bipartite. Taking the complement, the condition is equivalent to each subset containing an independent set of size at least half. If there is an odd cycle, the maximal independent set is smaller than half if we only consider the vertices in this cycle. On the other hand, if the complement is bipartite, for each subset, the bigger part is an independent set of size at least half. To implement this, directly output \"No\" if \\(m < \\binom{n}{2} - \\lfloor\\frac{n^2}{4}\\rfloor\\), and check by brute force otherwise. This works in \\(O(m)\\) time. Alternatively, we can simply output \"No\" if \\(n \\ge 2002\\), which also passes in the given time.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( K \\).\n\nThe **cumulative sums** of an integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is defined as a sequence \\( Y = (Y_0, Y_1, \\dots, Y_N) \\) of length \\( N+1 \\) as follows:\n\n- \\( Y_0 = 0 \\)\n- \\( Y_i = \\sum_{j=1}^{i} X_j \\) for \\( i = 1, 2, \\dots, N \\)\n\nAn integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is called a **good sequence** if and only if it satisfies the following condition:\n\n- Any value in the cumulative sums of \\( X \\) that is less than \\( K \\) appears before any value that is not less than \\( K \\).\n  \n  Formally, for the cumulative sums \\( Y \\) of \\( X \\), for any pair of integers \\( (i, j) \\) such that \\( 0 \\le i, j \\le N \\), if \\( (Y_i < K \\) and \\( Y_j \\ge K) \\), then \\( i < j \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). Determine whether the elements of \\( A \\) can be rearranged to form a good sequence. If so, print one such rearrangement.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq K \\leq 10^9 \\)\n- \\( -10^9 \\leq A_i \\leq 10^9 \\)\n\nAll input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nIf the elements of \\( A \\) can be rearranged to a good sequence, print the rearranged sequence \\( (A'_1, A'_2, \\dots, A'_N) \\) in the following format:\n\n```\nYes\nA'_1 A'_2 \\cdots A'_N\n```\n\nIf there are multiple valid rearrangements, any of them is considered correct.\n\nIf a good sequence cannot be obtained, print `No`.\n\n**Sample Input 1**\n```\n4 1\n-1 2 -3 4\n```\n\n**Sample Output 1**\n```\nYes\n-3 -1 2 4\n```\n\nIf you rearrange \\( A \\) to \\((-3, -1, 2, 4)\\), the cumulative sums \\( Y \\) will be \\( (0, -3, -4, -2, 2) \\). In this \\( Y \\), any value less than 1 appears before any value not less than 1.\n\n**Sample Input 2**\n```\n4 -1\n1 -2 3 -4\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n10 1000000000\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\nYes\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 179 - A - Partition Editorial by evima\n\nIf \\(K \\geq 1\\):\nBy sorting \\(A\\) in ascending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in ascending order. Let \\(B\\) be the cumulative sums of \\(A\\). Values in \\(A\\) that are less than \\(0\\) appear before values that are \\(0\\) or greater. Therefore, \\(B\\) can be represented as a concatenation of a strictly decreasing sequence and a non-decreasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 < K\\) and decreasing for a while, it begins to increase from a value less than \\(K\\). Once it becomes \\(K\\) or greater, it remains so thereafter. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i \\geq K\\):\nBy sorting \\(A\\) in descending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in descending order. Let \\(B\\) be the cumulative sum of \\(A\\). Values in \\(A\\) that are \\(0\\) or greater appear before values that are less than \\(0\\). Therefore, \\(B\\) can be represented as a concatenation of a strictly increasing sequence and a non-increasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 \\geq K\\) and increasing for a while, it begins to decrease from a value not less than \\(K\\). Since \\(B_0 \\geq K\\), it is \\(K\\) or greater from the start, and since \\(B_N = \\sum_{i=1}^{N}A_i \\geq K\\), it remains \\(K\\) or greater until the end. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i < K\\):\nNo matter how \\(A\\) is rearranged, it cannot be made into a good sequence. No matter how \\(A\\) is rearranged, the initial and final terms of the cumulative sum \\(B\\) of \\(A\\) are fixed. Since \\(B_0 = 0 \\geq K\\) and \\(B_N = \\sum_{i=1}^{N}A_i < K\\), it does not satisfy the conditions for a good sequence.\n[END TEXT]\n \n\n", "problem_ids": ["abc364_a", "agc067_a", "arc179_a"]}, "abc339_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\n\nFor a non-negative integer \\( K \\), we define a level-\\( K \\) carpet as follows:\n\n- A level-0 carpet is a \\( 1 \\times 1 \\) grid consisting of a single black cell.\n- For \\( K > 0 \\), a level-\\( K \\) carpet is a \\( 3^K \\times 3^K \\) grid. When this grid is divided into nine \\( 3^{K-1} \\times 3^{K-1} \\) blocks:\n  - The central block consists entirely of white cells.\n  - The other eight blocks are level-\\( (K-1) \\) carpets.\n\nYou are given a non-negative integer \\( N \\). Print a level-\\( N \\) carpet according to the specified format.\n\nConstraints:\n- \\( 0 \\leq N \\leq 6 \\)\n- \\( N \\) is an integer.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\n```\n\nOutput:\nPrint \\( 3^N \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq 3^N \\)) should contain a string \\( S_i \\) of length \\( 3^N \\) consisting of `.` and `#`. The \\( j \\)-th character of \\( S_i \\) (\\( 1 \\leq j \\leq 3^N \\)) should be `#` if the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left of a level-\\( N \\) carpet is black, and `.` if it is white.\n\nSample Input 1:\n```\n1\n```\n\nSample Output 1:\n```\n###\n#.#\n###\n```\n\nA level-1 carpet is a \\( 3 \\times 3 \\) grid as follows. When output according to the specified format, it looks like the sample output.\n\nSample Input 2:\n```\n2\n```\n\nSample Output 2:\n```\n#########\n#.##.##.#\n#########\n###...###\n#.#...#.#\n###...###\n#########\n#.##.##.#\n#########\n```\n\nA level-2 carpet is a \\( 9 \\times 9 \\) grid.\n\nSolution:\n\n```python\ndef main():\n    n = int(input())\n    l = 1\n    a = [['\\0' for _ in range(730)] for _ in range(729)]\n    \n    a[0][0] = '#'\n    for k in range(n):\n        for x in range(3):\n            for y in range(3):\n                if (x == 0) and (y == 0):\n                    continue\n                if (x == 1) and (y == 1):\n                    for i in range(l):\n                        for j in range(l):\n                            a[x * l + i][y * l + j] = '.'\n                else:\n                    for i in range(l):\n                        for j in range(l):\n                            a[x * l + i][y * l + j] = a[i][j]\n        l *= 3\n    \n    for i in range(l):\n        print(''.join(a[i]))\n\nmain()\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a bottle of disinfectant that can disinfect exactly \\( M \\) hands. \\( N \\) aliens come one by one to disinfect their hands. The \\( i \\)-th alien (\\( 1 \\leq i \\leq N \\)) has \\( H_i \\) hands and wants to disinfect all of their hands once. Determine how many aliens can disinfect all of their hands. Here, even if there is not enough disinfectant left for an alien to disinfect all of their hands when they start, they will use up the remaining disinfectant.\n\n**Constraints**\n\n- \\( 1 \\leq N, M \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the number of aliens who can disinfect all of their hands.\n\n**Sample Input 1**\n\n```\n5 10\n2 3 2 5 3\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\n*Explanation:*\n\n1. The first alien disinfects their two hands. The remaining disinfectant can disinfect \\( 10-2=8 \\) hands.\n2. The second alien disinfects their three hands. The remaining disinfectant can disinfect \\( 8-3=5 \\) hands.\n3. The third alien disinfects their two hands. The remaining disinfectant can disinfect \\( 5-2=3 \\) hands.\n4. The fourth alien has five hands, but there is only enough disinfectant for three hands, so they use up the disinfectant without disinfecting all of their hands.\n\nThus, the first three aliens can disinfect all of their hands, so print 3.\n\n**Sample Input 2**\n\n```\n5 10\n2 3 2 3 5\n```\n\n**Sample Output 2**\n\n```\n4\n```\n\n**Sample Input 3**\n\n```\n1 5\n1\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\nAll aliens can disinfect their hands.\n\nSolution:\n\n[BEGIN TEXT]\nHere is the simplified version of the editorial:\n\nThe problem can be solved by simulating the remaining amount of disinfectant. Start from \\(M\\) and subtract \\(H_1, H_2, \\ldots, H_N\\) from it in order. If it never goes below \\(0\\), all aliens can disinfect their hands, and the answer is \\(N\\). If it becomes less than \\(0\\) for the first time when subtracting \\(H_i\\), the answer is \\(i-1\\). Ensure to use an appropriate conditional inequality to handle the case when the disinfectant is used up completely.\n\nSample code in Python:\n\n```python\nn, m = map(int, input().split())\nh = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n    m -= h[i]\n    if m >= 0:\n        ans += 1\nprint(ans)\n```\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThe Republic of AtCoder consists of \\(L+1\\) islands aligned east-west, numbered \\(0\\) to \\(L\\) from west to east. The islands are connected by air routes, where for each \\(1 \\leq i \\leq L\\), there is a bidirectional air route between islands \\(i-1\\) and \\(i\\). Each air route is owned by company A or company J, and the route between islands \\(i-1\\) and \\(i\\) is owned by company \\(S_i\\).\n\nThe nation has \\(N\\) residents, numbered \\(1\\) to \\(N\\). Resident \\(i\\) is currently on island \\(X_i\\). Each resident has a coupon of one of the companies. Specifically, resident \\(i\\) has a coupon of company \\(C_i\\). With a coupon, a resident can take that company's routes for free any number of times, but taking a route of the other company costs 1 coin per trip.\n\nNow, there is a treasure chest on island 0. The residents want to cooperate to carry it to the capital, which is on island \\(L\\). Determine the minimum total number of coins required to achieve this goal. The residents can pass the treasure chest to each other, but not their coupons.\n\nConstraints:\n- \\(1 \\leq L \\leq 6 \\times 10^4\\)\n- \\(1 \\leq N \\leq 6 \\times 10^4\\)\n- \\(S_i \\ (1 \\leq i \\leq L)\\) is 'A' or 'J'.\n- \\(0 \\leq X_i \\leq L \\ (1 \\leq i \\leq N)\\)\n- \\(C_i \\ (1 \\leq i \\leq N)\\) is 'A' or 'J'.\n- \\(L, N, X_i\\) are integers.\n\nInput:\n- Input is given from Standard Input in the following format:\n  \\[\n  L \\, N \\\\\n  S_1 S_2 \\cdots S_L \\\\\n  X_1 \\, C_1 \\\\\n  X_2 \\, C_2 \\\\\n  \\vdots \\\\\n  X_N \\, C_N\n  \\]\n- Note that the second line is a string of length \\(L\\).\n\nOutput:\n- Print the answer.\n\nSample Input 1:\n```\n4 3\nAAJJ\n3 A\n1 J\n1 J\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation for Sample 1:\nTo carry the treasure chest to island 4 for a total of 2 coins, the following steps are taken:\n1. Resident 1 moves from island 3 to island 2, costing 1 coin as the route is not covered by the coupon.\n2. Resident 1 moves from island 2 to island 1, requiring no coins as the route is covered by the coupon.\n3. Resident 1 moves from island 1 to island 0, requiring no coins as the route is covered by the coupon.\n4. Resident 1 picks up the treasure chest.\n5. Resident 1 moves, carrying the treasure chest, from island 0 to island 1 without costing any coins as the route is covered by the coupon.\n6. Resident 1 passes the treasure chest to resident 2.\n7. Resident 2, with the treasure chest, moves from island 1 to island 2, costing 1 coin as the route is not covered by the coupon.\n8. Resident 2 moves with the treasure chest from island 2 to island 3, requiring no coins as the route is covered by the coupon.\n9. Resident 2 moves with the treasure chest from island 3 to island 4, requiring no coins as the route is covered by the coupon.\n\nSample Input 2:\n```\n8 3\nJJAAJJAJ\n2 A\n6 A\n8 J\n```\n\nSample Output 2:\n```\n6\n```\n\nSample Input 3:\n```\n8 6\nJJAAJJAJ\n2 A\n6 A\n8 J\n8 J\n8 J\n8 J\n```\n\nSample Output 3:\n```\n4\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 177 - F - Two Airlines Editorial\n\nStep 1:\nConsider the optimal movement strategy for residents with company A and J coupons, labeled Blue 1, 2, 3,..., and Red 1, 2, 3,... It is suboptimal for a resident to move luggage after a fellow resident of the same color. Utilize dynamic programming with states recording the current position, count of used Blue and Red residents, and current luggage holder. This yields  \\(\\mathrm{dp}[\\mathrm{pos}][b][r][\\mathrm{type}]\\) but results in an \\(O(N^3)\\) complexity, leading to time limit exceeded.\n\nStep 2:\nReduce state count by assuming residents more than two positions left don't touch luggage, resulting in \\(b \\geq b_{\\mathrm{left}}\\), \\(r \\geq r_{\\mathrm{left}}\\). Still results in \\(O(N^3)\\) complexity, leading to time exceedance.\n\nStep 3:\nFurther constrain by assuming residents over 20 positions to the right do not touch the luggage: \\(b \\leq b_{\\mathrm{left}} + 20\\), \\(r \\leq r_{\\mathrm{left}} + 20\\). The worst-case scenario involves 21 Blue at a single position, causing theoretical upper limit issues, but proven correct under \\(L \\leq 6 \\times 10^4\\).\n\nSample Implementation (C++):\nImplement the strategy noted above with an emphasis on memory and time management due to \\(O(N^3)\\) complexity states. The sample outlines initializing cumulative sums, initializing DP states, and processing state transitions to determine the minimum cost of operations involving agents and positions.\n\n[Code Example Not Included for Brevity]\n[END TEXT]\n \n\n", "problem_ids": ["abc357_c", "abc357_a", "arc177_f"]}, "abc339_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\). Print a string \\( S \\) that satisfies all of the following conditions. If no such string exists, print \\(-1\\).\n\n- \\( S \\) is a string of length between 1 and 1000, inclusive, consisting of the characters \\( 1, 2, 3, 4, 5, 6, 7, 8, 9 \\), and \\( * \\) (multiplication symbol).\n- \\( S \\) is a palindrome.\n- The first character of \\( S \\) is a digit.\n- The value of \\( S \\) when evaluated as a formula equals \\( N \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^{12} \\)\n- \\( N \\) is an integer.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\( N \\)\n\n**Output**\n\nIf there is a string \\( S \\) that satisfies the conditions, print such a string. Otherwise, print \\(-1\\).\n\n**Sample Input 1**\n\n```\n363\n```\n\n**Sample Output 1**\n\n```\n11*3*11\n```\n\n\\( S = 11*3*11 \\) satisfies the conditions in the problem statement. Another string that satisfies the conditions is \\( S = 363 \\).\n\n**Sample Input 2**\n\n```\n101\n```\n\n**Sample Output 2**\n\n```\n-1\n```\n\nNote that \\( S \\) must not contain the digit \\( 0 \\).\n\n**Sample Input 3**\n\n```\n3154625100\n```\n\n**Sample Output 3**\n\n```\n2*57*184481*75*2\n```\n\nSolution:\n\n```\nHere is the cleaned text of the coding problem editorial:\n\n---\n\nIn the editorial for the AtCoder Beginner Contest 363, the solution for the \"F - Palindromic Expression\" problem involves considering patterns for a conforming \\(S\\). The main patterns are \\(N\\) and \\(x*(\\text{expression})*\\mathrm{rev}(x)\\), where \\(\\mathrm{rev}(a)\\) is the reverse of \\(a\\). Several observations simplify the problem:\n\n1. \\(x = 1\\) is not considered because if \\(1*(\\text{expression})*1\\) qualifies, so does \\(\\text{expression}\\).\n2. For \\(x \\gt \\sqrt{N}\\), \\(\\mathrm{rev}(x) \\leq \\sqrt{N}\\), so \\(\\mathrm{rev}(x)*(\\text{expression})*x\\) also qualifies.\n\nDefine a function \\(f\\) as:\n\n- \\(f(n)\\) returns a string satisfying the problem's conditions if \\(n\\) is a palindrome without zero, otherwise an empty string.\n\nThe function works by checking potential factors \\(x\\) of \\(n\\), and if a palindrome condition is met through the factors, the corresponding string is returned.\n\nThe complexity is approximately \\(\\mathrm{O}(\\sqrt{N} \\times (\\text{number of divisors of } N))\\). With memorized recursion, the number of calls is manageable, ensuring the implementation is efficient.\n\nSample code (Python):\n\n```python\nimport functools\nimport math\n\n@functools.cache\ndef f(N):\n    if not \"0\" in str(N) and str(N) == str(N)[::-1]:\n        return str(N)\n    for x in range(2, math.isqrt(N) + 1):\n        if N % x == 0 and not \"0\" in str(x):\n            y = int(str(x)[::-1])\n            if N // x % y == 0 and len(f(N // x // y)) != 0:\n                return str(x) + \"*\" + f(N // x // y) + \"*\" + str(y)\n    return \"\"\n\nN = int(input())\nprint(\"-1\" if len(f(N)) == 0 else f(N))\n```\n\n--- \n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) buildings aligned in a row. The \\( i \\)-th building from the left has a height of \\( H_i \\).\n\nDetermine if there is a building taller than the first one from the left. If such a building exists, find the position of the leftmost such building from the left.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq H_i \\leq 100 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nIf no building is taller than the first one from the left, print `-1`.\nIf such a building exists, print the position (index) of the leftmost such building from the left.\n\n**Sample Input 1**\n```\n4\n3 2 5 2\n```\n\n**Sample Output 1**\n```\n3\n```\n*Explanation*: The building taller than the first one from the left is the third one from the left.\n\n**Sample Input 2**\n```\n3\n4 3 2\n```\n\n**Sample Output 2**\n```\n-1\n```\n*Explanation*: No building is taller than the first one from the left.\n\n**Sample Input 3**\n```\n7\n10 5 10 2 10 13 15\n```\n\n**Sample Output 3**\n```\n6\n```\n*Explanation*: The buildings taller than the first one from the left are the sixth and seventh ones. Among them, the leftmost is the sixth one.\n\nSolution:\n\nHere is a cleaned version of the coding problem editorial:\n\n---\n\nUse a for statement to check for each \\(i=2,3,\\ldots,N\\) if \\(H_i > H_1\\). If such an \\(i\\) is found, print that \\(i\\) and terminate the program. Otherwise, print \\(-1\\). Note that most programming languages adopt \\(0\\)-based indexing.\n\nSample code (Python):\n```python\nn = int(input())\nh = list(map(int, input().split()))\nfor i in range(1, n):\n  if h[i] > h[0]:\n    print(i + 1)\n    exit()\nprint(-1)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\). Here, it is guaranteed that \\( 0 \\leq A_i < i \\) for each \\( i \\).\n\nThe **score** and **cost** of a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) are defined as follows:\n\n- The score of \\( P \\) is the length of the longest increasing subsequence of \\( P \\).\n- The cost of \\( P \\) is the number of integers \\( i \\) (\\( 1 \\leq i \\leq N \\)) that satisfy the following condition:\n  - There are fewer than \\( A_i \\) integers \\( j \\) such that \\( j < i \\) and \\( P_j > P_i \\).\n\nFor each \\( k = 1, 2, \\ldots, N \\), solve the following problem:\n\n- Find the minimum cost of a permutation \\( P \\) whose score is at least \\( k \\).\n\n### Constraints\n- \\( 1 \\leq N \\leq 250,000 \\)\n- \\( 0 \\leq A_i < i \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answers for \\( k = 1, 2, \\ldots, N \\) in this order.\n\n### Sample Input 1\n```\n4\n0 1 2 1\n```\n\n### Sample Output 1\n```\n0 0 1 3\n```\n\nFor each \\( k \\), a solution \\( P \\) is as follows:\n- \\( k=1 \\): If \\( P=(4, 2, 1, 3) \\), then \\( P \\) has the score of \\( 2 \\) and the cost of \\( 0 \\).\n- \\( k=2 \\): If \\( P=(4, 3, 1, 2) \\), then \\( P \\) has the score of \\( 2 \\) and the cost of \\( 0 \\).\n- \\( k=3 \\): If \\( P=(4, 1, 2, 3) \\), then \\( P \\) has the score of \\( 3 \\) and the cost of \\( 1 \\).\n- \\( k=4 \\): If \\( P=(1, 2, 3, 4) \\), then \\( P \\) has the score of \\( 4 \\) and the cost of \\( 3 \\).\n\n### Sample Input 2\n```\n3\n0 0 0\n```\n\n### Sample Output 2\n```\n0 0 0\n```\n\n### Sample Input 3\n```\n5\n0 1 2 3 4\n```\n\n### Sample Output 3\n```\n0 1 2 3 4\n```\n\n### Sample Input 4\n```\n11\n0 0 2 3 4 5 3 7 8 2 10\n```\n\n### Sample Output 4\n```\n0 0 0 1 2 3 4 5 7 8 9\n```\n\nSolution:\n\n```python\n# Consider the maximum score that can be achieved with a cost of 0.\n# Let's define the DP as:\n\n# dp[i][j] = when the order of P_1, ..., P_i is determined optimally,\n# the maximum length of an increasing subsequence ending with the j-th largest value among them.\n\n# Initialize N as the number of elements\nN = ...\n\n# Function to calculate maximum score with cost 0\ndef calculate_max_score(A):\n    dp = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    \n    # Initialize set S with elements from 1 to N\n    S = set(range(1, N + 1))\n    \n    for i in range(1, N + 1):\n        max_value_in_S = max(S)\n        \n        # Remove the maximum element from S not greater than A[i]\n        if max_value_in_S <= A[i - 1]:\n            S.remove(max_value_in_S)\n        \n        # Add i to S\n        S.add(i)\n        \n        # Calculate dp using set S\n        # The LIS length is the maximum value of dp[i]\n        dp[i] = sorted(list(S), reverse=True)\n\n    # Return the maximum LIS length\n    return len(S)\n\n# Assuming paying a cost of 1 allows setting one A_i to 0\n\ndef calculate_with_cost(A):\n    cost = N\n    result = []\n    \n    # Traverse A in descending order\n    for i in range(N, 0, -1):\n        A[i - 1] = 0\n        \n        # Calculate maximum score with new A\n        score = calculate_max_score(A)\n        result.append((cost, score))\n        \n        cost -= 1\n\n    # Return results in ascending order of cost\n    return sorted(result)\n\n# Example usage:\nA = [your_sequence_here]\nmax_score = calculate_max_score(A)\nprint('Maximum Score with cost 0:', max_score)\n\nscores_with_cost = calculate_with_cost(A)\nfor cost, score in scores_with_cost:\n    print(f'Cost: {cost}, Score: {score}')\n    \n# Time complexity is O(N log N)\n```\n \n\n", "problem_ids": ["abc363_f", "abc353_a", "arc180_e"]}, "abc339_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given three sequences of positive integers each of length \\( N \\):  \n\\( A = (A_1, A_2, \\ldots, A_N) \\),  \n\\( B = (B_1, B_2, \\ldots, B_N) \\), and  \n\\( C = (C_1, C_2, \\ldots, C_N) \\).  \n\nFind the number of pairs of positive integers \\( (x, y) \\) that satisfy the following condition for all \\( 1 \\leq i \\leq N \\):  \n\\[ A_i \\times x + B_i \\times y < C_i \\]\n\nIt can be proved that the number of such pairs of positive integers satisfying the condition is finite.\n\nYou are given \\( T \\) test cases, each of which should be solved.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq A_i, B_i, C_i \\leq 10^9 \\)  \n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).  \n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:  \n\\[\n\\begin{align*}\nT & \\\\\n\\mathrm{case}_1 & \\\\\n\\mathrm{case}_2 & \\\\\n\\vdots & \\\\\n\\mathrm{case}_T & \\\\\n\\end{align*}\n\\]\n\nEach test case is given in the following format:  \n\\[\n\\begin{align*}\nN & \\\\\nA_1 & B_1 & C_1 \\\\\nA_2 & B_2 & C_2 \\\\\n\\vdots & \\\\\nA_N & B_N & C_N \\\\\n\\end{align*}\n\\]\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line \\( (1 \\leq i \\leq T) \\) should contain the answer for the \\( i \\)-th test case.\n\n**Sample Input 1**\n\n```\n2\n2\n1 1 4\n1 2 5\n1\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n2\n0\n```\n\nIn the first test case, there are two valid pairs of integers: \\( (x, y) = (1, 1), (2, 1) \\). Thus, the first line should contain 2.  \nIn the second test case, there are no valid pairs of integers. Thus, the second line should contain 0.\n\n**Sample Input 2**\n\n```\n3\n7\n138 16011 918976\n5478 7748 499926\n5234 17727 748589\n1157 10511 643136\n31200 3005 721285\n28839 14469 798851\n1933 5378 864127\n9\n17775 1665 386430\n37001 863 922418\n9756 4182 746671\n12379 9106 807578\n3984 4049 640539\n25333 9869 780810\n20372 7000 688738\n16107 11974 827227\n10779 10531 770510\n5\n4916 14132 460944\n11856 45422 610561\n56014 18216 825793\n10363 6220 945356\n37418 33866 851593\n```\n\n**Sample Output 2**\n\n```\n660\n995\n140\n```\n\nSolution:\n\n```python\n# Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nfrom math import ceil, floor\n\ndef count_lattice_points(N, lines):\n    # Sort the lines in ascending order of their slopes\n    lines.sort(key=lambda line: line[0] / line[1])\n    \n    # Prepare an empty list to manage the lowermost lines\n    L = []\n    \n    # Implement the convex hull algorithm-like approach to filter lines\n    for line in lines:\n        while len(L) >= 2 and is_unnecessary(L[-2], L[-1], line):\n            L.pop()\n        L.append(line)\n    \n    # Adjust N to the number of lines in L\n    N = len(L)\n    \n    # Find X_max\n    X_max = min(ceil(C / A) for A, B, C in L)\n    \n    # Calculate the sum of contributions for each line\n    total = 0\n    for i in range(N):\n        A_i, B_i, C_i = L[i]\n        \n        # Determine x_i\n        x_i = float('inf') if i == N - 1 else ceil((L[i + 1][2] - C_i) / (A_i - L[i + 1][0]))\n        x_prev = -float('inf') if i == 0 else x_i\n        \n        # Sum over the valid x in the range [x_prev, x_i) and [1, X_max)\n        for x in range(max(1, ceil(x_prev)), min(x_i, X_max)):\n            total += floor((C_i - 1 - A_i * x) / B_i)\n    \n    return total\n\ndef is_unnecessary(line1, line2, line3):\n    \"\"\"\n    Determine if the line2 is unnecessary in the convex hull structure. \n    It can be computed by comparing cross products.\n    \"\"\"\n    A1, B1, C1 = line1\n    A2, B2, C2 = line2\n    A3, B3, C3 = line3\n    \n    # Return true if line2 is unnecessary\n    # Cross product comparison: (C2 - C1, A2 - A1) vs (C3 - C1, A3 - A1)\n    return (C2 - C1) * (A3 - A1) <= (C3 - C1) * (A2 - A1)\n```\n\nIn this Python code, we implement the algorithm described in the given editorial. The code converts the explanation into a function that computes the number of lattice points under the given lines, following the steps of sorting the lines, maintaining a valid set using a convex hull-like approach, and then summing contributions using a specified method.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\nYou can perform the following two types of operations zero or more times in any order:\n\n1. Choose a (contiguous) substring \\( ABA \\) in \\( S \\) and replace it with \\( A \\).\n2. Choose a (contiguous) substring \\( BAB \\) in \\( S \\) and replace it with \\( B \\).\n\nFind, modulo \\( 10^9+7 \\), the number of possible strings \\( S \\) after performing the operations.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 250000 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n4\nABAB\n```\n\n**Sample Output 1**\n\n```\n2\n```\n\nThe two possible strings \\( S \\) after the operations are as follows:\n- \\( ABAB \\): This string can be obtained by performing zero operations.\n- \\( AB \\): The 1st to 3rd characters of \\( S=ABAB \\) are \\( ABA \\). Replacing them with \\( A \\) results in \\( S=AB \\).\n\nHere, the 2nd to 4th characters of \\( S=ABAB \\) are \\( BAB \\), so you can also replace them with \\( B \\). Note, however, that the resulting \\( AB \\) does not count multiple times.\n\n**Sample Input 2**\n\n```\n1\nA\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\nNo operations can be performed.\n\n**Sample Input 3**\n\n```\n17\nBBABABAABABAAAABA\n```\n\n**Sample Output 3**\n\n```\n18\n```\n\n**Sample Input 4**\n\n```\n100\nABAABAABABBABAABAABAABABBABBABBABBABBABBABBABBABBABBABBABBABBABAABABAABABBABBABABBABAABAABAABAABA\n```\n\n**Sample Output 4**\n\n```\n415919090\n```\n\nRemember to take the result modulo \\( 10^9+7 \\).\n\nSolution:\n\n```\nIn competitive programming, a well-known technique is using parity to perform inversions. Let\u2019s apply it to this problem. Specifically, let\u2019s invert the characters A and B only at even positions in the input string. Then, the two available operations become:\n\nAAA \u2192 A  \nBBB \u2192 B  \n\nWith this transformation, the solution becomes straightforward. For a contiguous segment of A or B, as long as its length does not become zero, we can reduce the length by 2 each time. For example, if there is a segment AAAAA, the possible final states are AAAAA, AAA, and A: there are three. Therefore, if the length of a segment of consecutive identical characters is L, the number of possible final states for that segment is floor((L+1)/2). For all segments of consecutive identical characters, the final states can be chosen independently. Thus, the product of the above values for all such segments is the answer to this problem.\n```\n \n\n", "problem_ids": ["abc366_e", "abc372_g", "arc180_a"]}, "abc339_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi eats three plates for breakfast: rice, miso soup, and salad. His table is long and narrow, so he arranged the three plates in a row. The arrangement is given by a string \\( S \\), where the \\( i \\)-th plate from the left is rice if \\( S_i \\) is \\( R \\), miso soup if \\( S_i \\) is \\( M \\), and salad if \\( S_i \\) is \\( S \\).\n\nDetermine whether the plate of rice is to the left of the plate of miso soup.\n\n**Constraints**\n\n- \\(|S| = 3\\)\n- \\( S \\) contains one \\( R \\), one \\( M \\), and one \\( S \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n**Output**\n\nPrint `Yes` if the plate of rice is to the left of the plate of miso soup, and `No` otherwise.\n\n**Sample Input 1**\n\n```\nRSM\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nThe plate of rice is at the 1st position from the left, and the plate of miso soup is at the 3rd position from the left. Since the plate of rice is to the left, print `Yes`.\n\n**Sample Input 2**\n\n```\nSMR\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nThe plates are arranged as salad, miso soup, and rice from left to right.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 360\n\nA - A Healthy Breakfast Editorial by en_translator\n\nFor beginners: If you are new to learning programming, please try \"Welcome to AtCoder\" from the practice contest. There you can find a sample code for each language. If you are not familiar with programming contests, try some problems in \"AtCoder Beginners Selection.\" \"C++\u5165\u9580 AtCoder Programming Guide for beginners (APG4b)\" is a C++ tutorial for competitive programmers (in Japanese).\n\nSolution: Prepare a string variable s. Read input into s. Use a for loop to determine positions of R and M in s. Let pos_r and pos_m be those indices. Use an if statement to print 'Yes' if pos_r < pos_m, otherwise print 'No'. With only six possible strings for \\(S\\), you can manually determine the answer using a conditional branch. Sample code in C++ provided.\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given two permutations \\( P = (P_1, P_2, \\dots, P_N) \\) and \\( Q = (Q_1, Q_2, \\dots, Q_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nWrite one of the characters '0' and '1' in each cell of an \\( N \\)-by-\\( N \\) grid so that all of the following conditions are satisfied:\n\n1. Let \\( S_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th row from the 1st to the \\( N \\)-th column. Then, \\( S_{P_1} < S_{P_2} < \\dots < S_{P_N} \\) in lexicographical order.\n\n2. Let \\( T_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th column from the 1st to the \\( N \\)-th row. Then, \\( T_{Q_1} < T_{Q_2} < \\dots < T_{Q_N} \\) in lexicographical order.\n\nIt can be proved that for any \\( P \\) and \\( Q \\), there is at least one way to write the characters that satisfies all the conditions.\n\n**Lexicographical Order Explanation:**\n\nFor strings \\( X = X_1 X_2 \\dots X_{|X|} \\) and \\( Y = Y_1 Y_2 \\dots Y_{|Y|} \\), \" \\( X < Y \\) in lexicographical order\" means that condition 1 or 2 below holds:\n\n1. \\( |X| < |Y| \\) and \\( X_1 X_2 \\ldots X_{|X|} = Y_1 Y_2 \\ldots Y_{|X|} \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\lbrace |X|, |Y| \\rbrace \\) such that both of the following are true:\n   - \\( X_1 X_2 \\ldots X_{i-1} = Y_1 Y_2 \\ldots Y_{i-1} \\)\n   - \\( X_i \\) is less than \\( Y_i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( P \\) and \\( Q \\) are permutations of \\( (1, 2, \\dots, N) \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n\n```\nN\nP_1 P_2 \\dots P_N\nQ_1 Q_2 \\dots Q_N\n```\n\n**Output:**\n\nPrint a way to fill the grid that satisfies the conditions in the following format, where \\( A_{ij} \\) is the character written at the \\( i \\)-th row and \\( j \\)-th column:\n\n```\nA_{11} A_{12} \\dots A_{1N}\n...\nA_{N1} A_{N2} \\dots A_{NN}\n```\n\nIf there are multiple ways to satisfy the conditions, any of them will be accepted.\n\n**Sample Input 1:**\n\n```\n3\n1 2 3\n2 1 3\n```\n\n**Sample Output 1:**\n\n```\n001\n101\n110\n```\n\nIn this sample, \\( S_1 = \\) \"001\", \\( S_2 = \\) \"101\", \\( S_3 = \\) \"110\", and \\( T_1 = \\) \"011\", \\( T_2 = \\) \"001\", \\( T_3 = \\) \"110\". Therefore, \\( S_1 < S_2 < S_3 \\) and \\( T_2 < T_1 < T_3 \\) hold, satisfying the conditions.\n\n**Sample Input 2:**\n\n```\n15\n8 15 10 2 4 3 1 13 5 12 9 6 14 11 7\n4 1 5 14 3 12 13 7 11 8 6 2 9 15 10\n```\n\n**Sample Output 2:**\n\n```\n010001111110101\n001000000101001\n010001001100010\n010000011110010\n010011101101101\n100101110100000\n111100011001000\n000001001100000\n100011011000101\n000111101011110\n101010101010101\n011010101011110\n010011000010011\n100110010110101\n000101101100100\n```\n\nSolution:\n\n```python\ndef fill_grid(N, P, Q):\n    grid = [[None] * N for _ in range(N)]\n\n    # Step 1: Write 0 in all cells of row P_1\n    for j in range(N):\n        grid[P[0]][j] = 0\n\n    # Step 2: Write 1 in all cells of column Q_N that are still empty\n    for i in range(N):\n        if grid[i][Q[N-1]] is None:\n            grid[i][Q[N-1]] = 1\n\n    # Recursive filling for remaining (N-1) x (N-1) cells\n    def fill_recursive(start, end, P, Q):\n        if start >= end:\n            return\n        # Write in row P[start]\n        for j in range(N):\n            if grid[P[start]][j] is None:\n                grid[P[start]][j] = 0\n        # Write in column Q[end]\n        for i in range(N):\n            if grid[i][Q[end]] is None:\n                grid[i][Q[end]] = 1\n        # Recurse on remaining subproblem\n        fill_recursive(start + 1, end - 1, P, Q)\n\n    fill_recursive(1, N-1, P, Q)\n\n    return grid\n\n# Example usage\nN = 3\nP = [0, 1, 2]  # Row order\nQ = [2, 1, 0]  # Column order\ngrid = fill_grid(N, P, Q)\nfor row in grid:\n    print(row)\n```\n\n**C - Row and Column Order Editorial by evima**\n\n**Solution**\n\n1. Write 0 in all cells of row \\(P_1\\).\n2. Write 1 in all cells of column \\(Q_N\\) that are still empty.\n3. For the remaining \\((N-1) \\times (N-1)\\) cells, let \\(S'_i\\) be the string obtained by concatenating row \\(i\\) excluding column \\(Q_N\\), and \\(T'_j\\) be the string obtained by concatenating column \\(j\\) excluding row \\(P_1\\). Then, recursively write in the same way so that \\(S'_{P_2} < S'_{P_3} < \\dots < S'_{P_N}\\) and \\(T'_{Q_2} < T'_{Q_3} < \\dots < T'_{Q_N}\\) hold.\n\nThe grid filled by this algorithm will satisfy the problem's conditions. Additionally, each column will contain at least one cell with 0, as 0 is always written in row \\(P_1\\). The lexicographical order of \\(S_{P_i}\\) and \\(T_{Q_i}\\) is maintained through recursive writing. The order of writing is \\(i=1,2,\\dots,N\\): first, write 0 in row \\(P_i\\) cells not yet written, then write 1 in column \\(Q_{N+1-i}\\) cells still empty.\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( A_1, A_2, A_3 \\). Find the number of tuples of positive integers \\( (X_1, X_2, X_3) \\) that satisfy all of the following conditions, modulo \\( 998244353 \\):\n\n1. \\( X_1 \\) is a positive integer with \\( A_1 \\) digits in decimal notation.\n2. \\( X_2 \\) is a positive integer with \\( A_2 \\) digits in decimal notation.\n3. \\( X_3 \\) is a positive integer with \\( A_3 \\) digits in decimal notation.\n4. \\( X_1 + X_2 = X_3 \\).\n\nYou are given \\( T \\) test cases per input file; solve each of them.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\) for \\( i = 1, 2, 3 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is provided from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach case is given in the following format:\n\n```\nA_1 A_2 A_3\n```\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for \\( case_i \\).\n\n**Sample Input 1**\n\n```\n4\n1 1 1\n1 6 7\n167 167 167\n111 666 777\n```\n\n**Sample Output 1**\n\n```\n36\n45\n731780675\n0\n```\n\n- For the first case, tuples such as \\( (X_1, X_2, X_3) = (1, 6, 7), (2, 1, 3) \\) satisfy the conditions. On the other hand, tuples such as \\( (X_1, X_2, X_3) = (6, 7, 13), (3, 4, 5) \\) do not. There are 36 tuples \\( (X_1, X_2, X_3) \\) that satisfy the conditions, so print 36.\n- For the third case, remember to print the result modulo 998244353.\n- For the fourth case, there may be no tuples \\( (X_1, X_2, X_3) \\) that satisfy the conditions.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nB - 1 + 6 = 7 Editorial by evima\n\nWe aim to find the number of pairs of integers \\((X_{1}, X_{2})\\) satisfying:\n\n\\(10^{A_{1} - 1} \\leq X_{1}\\)\n\n\\(10^{A_{2}-1} \\leq X_{2}\\)\n\n\\(X_{1} + X_{2} < 10^{A_{3}}\\)\n\n\\(10^{A_{1}} \\leq X_{1}\\) does not hold.\n\n\\(10^{A_{2}} \\leq X_{2}\\) does not hold.\n\n\\(X_{1} + X_{2} < 10^{A_{3}-1}\\) does not hold.\n\nUsing the inclusion-exclusion principle, the answer can be expressed as:\n\\[\\sum_{i=0}^{1}\\sum_{j=0}^{1}\\sum_{k=0}^{1}f(A_{1} - i, A_{2} - j, A_{3} - k)(-1)^{i+j+k} \\]\n\nFor \\(f(B_{1}, B_{2}, B_{3})\\):\n\nIf \\(B_{3} \\leq \\max(B_{1}, B_{2})\\), \\(f(B_{1}, B_{2}, B_{3}) = 0\\).\n\nIf \\(B_{3} > \\max(B_{1}, B_{2})\\), \\(f(B_{1}, B_{2}, B_{3}) = \\dfrac{(10^{B_{3}}-10^{B_{1}}-10^{B_{2}})(10^{B_{3}}-10^{B_{1}}-10^{B_{2}} + 1)}{2}\\).\n\nThis computation can be done in \\(O(\\log(A_{3}))\\) time per test case.\n\nPython Implementation Example:\n```python\nMOD = 998244353\n\ndef f(b1, b2, b3):\n    if max(b1, b2) >= b3:\n        return 0\n    tmp = pow(10, b3, MOD) - pow(10, b1, MOD) - pow(10, b2, MOD)\n    return (tmp + 1) * tmp // 2\n\nT = int(input())\nfor _ in range(T):\n    a1, a2, a3 = map(int, input().split())\n    ans = 0\n    pm = 1\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                ans = (ans + f(a1 - i, a2 - j, a3 - k) * pm) % MOD\n                pm *= -1\n            pm *= -1\n        pm *= -1\n    print(ans)\n```\n```\n \n\n", "problem_ids": ["abc360_a", "arc181_c", "arc178_b"]}, "abc340_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nIn the Kingdom of AtCoder, residents are required to shout their love for takoyaki at \\( A \\) o'clock every day.\n\nTakahashi, who lives in the Kingdom of AtCoder, goes to bed at \\( B \\) o'clock and wakes up at \\( C \\) o'clock every day (in the 24-hour clock). He can shout his love for takoyaki when he is awake, but cannot when he is asleep. Determine whether he can shout his love for takoyaki every day. Here, a day has 24 hours, and his sleeping time is less than 24 hours.\n\n**Constraints**\n- \\( 0 \\leq A, B, C < 24 \\)\n- \\( A \\), \\( B \\), and \\( C \\) are pairwise different.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C\n```\n\n**Output**\n\nPrint `Yes` if Takahashi can shout his love for takoyaki every day, and `No` otherwise.\n\n**Sample Input 1**\n```\n21 8 14\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Takahashi goes to bed at 8 o'clock and wakes up at 14 o'clock every day. He is awake at 21 o'clock, so he can shout his love for takoyaki every day. Therefore, print `Yes`.*\n\n**Sample Input 2**\n```\n0 21 7\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*Takahashi goes to bed at 21 o'clock and wakes up at 7 o'clock every day. He is not awake at 0 o'clock, so he cannot shout his love for takoyaki every day. Therefore, print `No`.*\n\n**Sample Input 3**\n```\n10 7 17\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 367 - Editorial\n\n**Problem Solution:**\n\nThe problem can be solved by employing casework based on whether the person is asleep at midnight. \n\n1. **If not asleep at midnight:**\n   - The person sleeps from \\(B\\) to \\(C\\) o\u2019clock. The answer is \"No\" if \\(A\\) o\u2019clock is between \\(B\\) and \\(C\\) (\\(B<A<C\\)). Otherwise, the answer is \"Yes\".\n\n2. **If asleep at midnight:**\n   - The person is awake from \\(C\\) to \\(B\\) o\u2019clock. The answer is \"Yes\" if \\(A\\) o\u2019clock is between \\(C\\) and \\(B\\) (\\(C<A<B\\)). Otherwise, the answer is \"No\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nif B < C:\n    if B < A and A < C:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    if C < A and A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n\n**Alternative Approach:**\n\nTo avoid casework, use a while statement starting from \\(B\\) and increment hour by hour. If \\(A\\) is reached before \\(C\\), print \"No\". Otherwise, print \"Yes\".\n\n**Sample Code (Python):**\n\n```python\nA, B, C = map(int, input().split())\nnow = B\nwhile now != C:\n    if now == A:\n        print(\"No\")\n        exit()\n    now += 1\n    now %= 24\n\nprint(\"Yes\")\n```\n        [END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a sequence \\( (X_1, X_2, \\dots, X_M) \\) of length \\( M \\) consisting of integers between \\( 1 \\) and \\( M \\), inclusive.\n\nFind the number, modulo \\( 998244353 \\), of sequences \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\) consisting of integers between \\( 1 \\) and \\( M \\), inclusive, that satisfy the following condition:\n\nFor each \\( B = 1, 2, \\dots, M \\), the value \\( X_B \\) exists between any two different occurrences of \\( B \\) in \\( A \\) (including both ends).\n\nMore formally, for each \\( B = 1, 2, \\dots, M \\), the following condition must hold:\n\nFor every pair of integers \\( (l, r) \\) such that \\( 1 \\leq l < r \\leq N \\) and \\( A_l = A_r = B \\), there exists an integer \\( m \\) (\\( l \\leq m \\leq r \\)) such that \\( A_m = X_B \\).\n\n**Constraints**\n- \\( 1 \\leq M \\leq 10 \\)\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq X_i \\leq M \\)\n- All input values are integers.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nM N\nX_1 X_2 \\cdots X_M\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n3 4\n2 1 2\n```\n\n**Sample Output 1**\n```\n14\n```\n\nHere are examples of sequences \\( A \\) that satisfy the condition:\n- \\( (1, 3, 2, 3) \\)\n- \\( (2, 1, 2, 1) \\)\n- \\( (3, 2, 1, 3) \\)\n\nHere are non-examples:\n- \\( (1, 3, 1, 3) \\) - There is no \\( X_3 = 2 \\) between the \\( 3 \\)s.\n- \\( (2, 2, 1, 3) \\) - There is no \\( X_2 = 1 \\) between the \\( 2 \\)s.\n\n**Sample Input 2**\n```\n4 8\n1 2 3 4\n```\n\n**Sample Output 2**\n```\n65536\n```\n\nAll sequences of length \\( 8 \\) consisting of integers between \\( 1 \\) and \\( 4 \\) satisfy the condition. Note that when \\( X_B = B \\), there is always a \\( B \\) between two different occurrences of \\( B \\).\n\n**Sample Input 3**\n```\n4 9\n2 3 4 1\n```\n\n**Sample Output 3**\n```\n628\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 179\n\n# B - Between B and B Editorial by evima\n\n# For each B = 1, 2, ..., M, the value X_B exists between any two different occurrences \n# of B in A (including both ends). This condition will be referred to as \u201cthe condition.\u201d \n# Let\u2019s consider determining the elements of A from the beginning. When deciding A_i, \n# we choose A_i such that (A_1, A_2, ..., A_i) satisfies the condition. Therefore, \n# let\u2019s consider the following dynamic programming approach.\n\n# Let dp[c][S] be the number of ways to determine the first c(=0,1,...,N) elements of \n# A such that the set of possible values for A_{c+1} is S (\u2286 {1,2,...,M}).\n\n# First, any of 1, 2, ..., M can be chosen as A_1. Therefore, dp[0][{1,2,...,M}] = 1. \n# Next, let\u2019s consider what happens when c and S are fixed, and we decide A_{c+1} to \n# be a \u2208 S. First, due to the condition that X_a must exist between any two occurrences \n# of a, we remove a from S. This can be interpreted as not being allowed to add a again \n# until X_a is added. Next, we add all b such that X_b = a to S. This can be interpreted \n# as allowing b to be added since X_b has been added. Let the new set obtained in this \n# way be written as S(a). The transition in the dynamic programming can be written as \n# follows:\n\n# dp[c+1][S(a)] += dp[c][S]  (a \u2208 S)\n\n# This is a bitDP. The time complexity is O(NM2^M), which is sufficiently fast under \n# the given constraints.\n```\n\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( L \\), and \\( R \\). For a sequence \\( A = (1, 2, \\dots, N) \\) of length \\( N \\), an operation of reversing the \\( L \\)-th through \\( R \\)-th elements was performed once. Print the sequence after this operation.\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\leq L \\leq R \\leq N \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN L R\n```\n\n**Output**\n\nLet \\( A' = (A'_1, A'_2, \\dots, A'_N) \\) be the sequence after the operation. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n5 2 3\n```\n\n**Sample Output 1**\n```\n1 3 2 4 5\n```\n\nExplanation: Initially, \\( A = (1, 2, 3, 4, 5) \\). After reversing the second through third elements, the sequence becomes \\( (1, 3, 2, 4, 5) \\), which should be printed.\n\n**Sample Input 2**\n```\n7 1 1\n```\n\n**Sample Output 2**\n```\n1 2 3 4 5 6 7\n```\n\nExplanation: It is possible that \\( L = R \\).\n\n**Sample Input 3**\n```\n10 1 10\n```\n\n**Sample Output 3**\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nExplanation: It is possible that \\( L = 1 \\) or \\( R = N \\).\n\nSolution:\n\nHere is the cleaned version of the editorial text:\n\nApproach 1: Actually construct an array and apply reversion. Solve the problem by constructing the sequence \\(A=(1,2,\\dots,N)\\) as an array, reverse the \\(L\\)-th through \\(R\\)-th elements, and print the result. First, let \\(l=L\\) and \\(r=R\\). While \\(l<r\\), swap the \\(l\\)-th and \\(r\\)-th element, add \\(1\\) to \\(l\\), and subtract \\(1\\) from \\(r\\). Note that the first element might be treated as the \\(0\\)-th one depending on array usage.\n\nSample code 1 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nwhile L < R:\n    A[L], A[R] = A[R], A[L]\n    L += 1\n    R -= 1\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nSample code 2 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nA[L:R + 1] = reversed(A[L:R + 1])\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nApproach 2: Directly construct the sought sequence. The structure is as follows: arrange \\(1,2,\\dots,L-1\\), then \\(R,R-1,\\dots,L\\), and finally \\(R+1,R+2,\\dots,N\\).\n\nSample code (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nres = []\n\nfor i in range(1, L):\n    res.append(i)\nfor i in range(R, L - 1, -1):\n    res.append(i)\nfor i in range(R + 1, N + 1):\n    res.append(i)\n\nfor i in range(N):\n    if i:\n        print(\" \", end=\"\")\n    print(res[i], end=\"\")\nprint()\n```\n \n\n", "problem_ids": ["abc367_a", "arc179_b", "abc356_a"]}, "abc340_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( N \\) and a sequence of \\( M \\) positive integers \\( A = (A_1, A_2, \\ldots, A_M) \\). All elements of \\( A \\) are distinct integers between \\( 1 \\) and \\( N \\), inclusive.\n\nA permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) is called a *good permutation* if it satisfies the following condition for all integers \\( i \\) such that \\( 1 \\leq i \\leq M \\):\n\n- No contiguous subsequence of \\( P \\) is a permutation of \\( (1, 2, \\ldots, A_i) \\).\n\nDetermine whether a *good permutation* exists, and if it does, find the lexicographically smallest *good permutation*.\n\n**What is lexicographical order?**\n\nA sequence \\( S = (S_1, S_2, \\ldots, S_{|S|}) \\) is said to be *lexicographically smaller* than a sequence \\( T = (T_1, T_2, \\ldots, T_{|T|}) \\) if one of the following conditions holds:\n\n1. \\( |S| < |T| \\) and \\( (S_1, S_2, \\ldots, S_{|S|}) = (T_1, T_2, \\ldots, T_{|S|}) \\).\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\{|S|, |T|\\} \\) such that both of the following hold:\n   - \\( (S_1, S_2, \\ldots, S_{i-1}) = (T_1, T_2, \\ldots, T_{i-1}) \\).\n   - \\( S_i \\) is smaller than \\( T_i \\) (as a number).\n\n**Constraints**\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All elements of \\( A \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 A_2 \\cdots A_M\n```\n\n**Output**\n\nIf a *good permutation* does not exist, print `-1`.  \nIf it exists, print the lexicographically smallest *good permutation*, separated by spaces.\n\n**Sample Input 1**\n```\n4 1\n2\n```\n\n**Sample Output 1**\n```\n1 3 2 4\n```\n\nFor example, \\( (4, 2, 1, 3) \\) is not a *good permutation* because it contains \\( (2, 1) \\) as a contiguous subsequence. Other non-*good permutations* are \\( (1, 2, 3, 4) \\) and \\( (3, 4, 2, 1) \\). Some *good permutations* are \\( (4, 1, 3, 2) \\) and \\( (2, 3, 4, 1) \\). Among these, the lexicographically smallest one is \\( (1, 3, 2, 4) \\), so print it separated by spaces.\n\n**Sample Input 2**\n```\n5 3\n4 3 2\n```\n\n**Sample Output 2**\n```\n1 3 4 5 2\n```\n\nExamples of *good permutations* include \\( (3, 4, 1, 5, 2) \\), \\( (2, 4, 5, 3, 1) \\), and \\( (4, 1, 5, 2, 3) \\). Examples of non-*good permutations* include \\( (1, 2, 5, 3, 4) \\), \\( (2, 3, 4, 1, 5) \\), and \\( (5, 3, 1, 2, 4) \\).\n\n**Sample Input 3**\n```\n92 4\n16 7 1 67\n```\n\n**Sample Output 3**\n```\n-1\n```\n\nIf a *good permutation* does not exist, print `-1`.\n\n**Sample Input 4**\n```\n43 2\n43 2\n```\n\n**Sample Output 4**\n```\n-1\n```\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nA - Good Permutation 2 Editorial by evima\n\nIf \\(A\\) contains either \\(1\\) or \\(N\\), a good permutation does not exist. Conversely, if neither \\(1\\) nor \\(N\\) is included in \\(A\\), a good permutation does exist. Let\u2019s consider this case. For example, if we set \\(P = (1, N, N - 1, N - 2, \\dots, 3, 2)\\), the only contiguous subsequence of \\(P\\) that includes both \\(1\\) and \\(2\\) is \\(P\\) itself, making \\(P\\) a good permutation. \n\nSince a good permutation with \\(P_{1} = 1\\) exists, the lexicographically smallest good permutation will have \\(P_{1} = 1\\). For any integer \\(x\\), if there exists a contiguous subsequence of \\(P\\) that is a permutation of \\((1, 2, \\dots, x)\\), it must be \\((P_{1}, P_{2}, \\dots, P_{x})\\). We determine \\(P_{i}\\) for \\(i \\neq 1\\) in ascending order of \\(i\\). When deciding \\(P_{i}\\), assume that all of \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\) are at most \\(i\\). Let \\(a\\) be the number that is at most \\(i\\) and not included in \\(P_{1}, P_{2}, \\dots, P_{i - 1}\\).\n\nWhen \\(i\\) is included in \\(A\\):\nTo make the permutation lexicographically smallest, set \\(P_{i} = i + 1\\). Since \\(P_{i}\\) is not greater than \\(i + 1\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) does not change.\n\nWhen \\(i\\) is not included in \\(A\\):\nSet \\(P_{i} = a\\). Since this number is not greater than \\(i\\), all of \\(P_{1}, P_{2}, \\dots, P_{i}\\) will be at most \\(i + 1\\), and \\(a\\) becomes \\(i + 1\\).\n\nThe time complexity is \\(O(N)\\).\n\n```python\n# input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nban = [0] * N\nfor a in A:\n    ban[a - 1] = 1\n\n# impossible\nif ban[0] or ban[N - 1]:\n    print(-1)\n    quit()\n\n# init\nP = [0] * N\nP[0] = 1\na = 2\n\n# calc\nfor i in range(1, N):\n    if ban[i] == 1:\n        P[i] = i + 2\n    else:\n        P[i] = a\n        a = i + 2\n\n# output\nprint(*P)\n```\n\nYou can also construct the permutation as follows: Initialize \\(P = (1, 2, \\dots, N)\\), and for \\(i = 2, 3, \\dots, N - 1\\), perform the following operation: If \\(i\\) is included in \\(A\\), do \\(\\text{swap}(P_{i}, P_{i + 1})\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\).\n\nYou can perform the following operation any number of times, possibly zero: Choose an integer pair \\((i, j)\\) satisfying \\(1 \\leq i < j \\leq N\\), and replace \\(A_i\\) with \\(A_i + 1\\) and \\(A_j\\) with \\(A_j - 1\\).\n\nDetermine whether it is possible to make \\( A \\) a non-decreasing sequence through the operations.\n\nYou are given \\( T \\) test cases. Solve each of them.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format. Here, \\( \\mathrm{case}_i \\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\nFor each test case, if it is possible to make \\( A \\) a non-decreasing sequence through the operations, print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n\n```\n3\n3\n1 7 5\n2\n9 0\n10\n607 495 419 894 610 636 465 331 925 724\n```\n\n**Sample Output 1**\n\n```\nYes\nNo\nYes\n```\n\nIn the first test case, you can make \\( A \\) into a non-decreasing sequence by performing the following operations:\n1. Choose \\((i, j) = (1, 2)\\). After the operation, \\( A \\) is \\( (2, 6, 5) \\).\n2. Choose \\((i, j) = (1, 2)\\). After the operation, \\( A \\) is \\( (3, 5, 5) \\).\n\nIn the second test case, you cannot make \\( A \\) into a non-decreasing sequence no matter how you perform the operations.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - AtCoder Regular Contest 185\n\nB - +1 and -1 Editorial by evima\n\nIt is possible to turn \\(A\\) into a non-decreasing sequence if and only if the following condition is satisfied: A non-decreasing sequence where the difference between the maximum and minimum values is at most \\(1\\) is called a good sequence. It is possible to turn \\(A\\) into a good sequence through operations.\n\nProof: If we can make \\(A\\) into a good sequence, then \\(A\\) can be made into a non-decreasing sequence. Suppose we transform \\(A\\) into a non-decreasing sequence. After that, we can perform operations to transform \\(A\\) into a good sequence:\n\nInvariant: Initially, the sequence \\((A_1)\\) is a good sequence, and \\(A\\) is non-decreasing. For \\(i = 2, 3, \\dots, N\\), do the following:\n\nInvariant: \\((A_1, A_2, \\dots, A_{i-1})\\) is a good sequence. While \\((A_1, A_2, \\dots, A_i)\\) is not a good sequence, find exactly one position \\(j\\) \\((1 \\leq j \\leq i-1)\\) where adding \\(1\\) to \\(A_j\\) maintains \\((A_1, A_2, \\dots, A_{i-1})\\) as a good sequence. Perform the operation on \\((j, i)\\).\n\nRepeat the operation until \\((A_1, A_2, \\dots, A_i)\\) becomes a good sequence. \\((A_1, A_2, \\dots, A_i)\\) becomes a good sequence if \\(A_{i-1}\\) and \\(A_i\\) coincide, reducing the difference by \\(1\\) or \\(2\\). If it is not obtained, choosing \\(j = i - 1\\) when the difference is \\(1\\) results in \\((A_1, A_2, \\dots, A_{i-1}, A_i) = (x, x, \\dots, x, x+1)\\), which is a good sequence, so no operation is performed.\n\nAfter the operation, \\((A_1, A_2, \\dots, A_i)\\) is a good sequence, and \\(A_i \\leq A_{i+1}\\), so \\(A\\) remains non-decreasing.\n\nThus, the two propositions are equivalent. We can determine if \\(A\\) can become a good sequence in \\(\\mathrm{O}(N)\\) time using cumulative sums, solving this problem in \\(\\mathrm{O}(N)\\) per test case.\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 500 points\n\n### Problem Statement\n\nHow many integers \\( x \\) between 1 and \\( N \\), inclusive, can be expressed as \\( x = a^b \\) using some positive integer \\( a \\) and a positive integer \\( b \\) not less than 2?\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 10^{18} \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\n```\n\n### Output\n\nPrint the answer as an integer.\n\n### Sample Input 1\n\n```\n99\n```\n\n### Sample Output 1\n\n```\n12\n```\n\nThe integers that satisfy the conditions in the problem statement are: 1, 4, 8, 9, 16, 25, 27, 32, 36, 49, 64, 81. There are 12 of these.\n\n### Sample Input 2\n\n```\n1000000000000000000\n```\n\n### Sample Output 2\n\n```\n1001003332\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Denso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09 Editorial - Problem F: x = a^b\n\nWe introduce a rather brute-force solution. As evident from Sample 2, a total of 1001003332 integers can satisfy the condition. Since \\((10^9)^2 = 10^{18}\\), \\(10^9\\) integers among them can be represented as \\(a^2\\). Therefore, there are only \\(10^6\\) integers that cannot be represented as \\(a^2\\). One can enumerate all of them and then add the number of those represented as \\(a^2\\). This enumeration can be done for \\(b=3,4,\\dots,59\\) and then stopped once \\(a^b > N\\) is satisfied; one can determine if an integer \\(x\\) can be represented as \\(a^2\\) by checking if \\((\\lfloor \\sqrt{x} \\rfloor )^2=x\\).\n\nSample code (Python):\n```python\nimport math\n\ndef safe_pow(a, b):\n    res = 1\n    for _ in range(b):\n        dres = res\n        dres *= a\n        if dres > 2e18:\n            return 2e18\n        res *= a\n    return res\n\ndef sqrt_floor(x):\n    l, r = 0, int(2e9)\n    while l <= r:\n        t = (l + r) // 2\n        if t * t > x:\n            r = t - 1\n        else:\n            l = t + 1\n    return r\n\ndef main():\n    n = int(input().strip())\n    st = set()\n    for b in range(3, 60):\n        a = 2\n        while True:\n            x = safe_pow(a, b)\n            if x > n:\n                break\n            s = sqrt_floor(x)\n            if s * s != x:\n                st.add(x)\n            a += 1\n    res = len(st)\n    res += sqrt_floor(n)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n        [END TEXT]\n \n\n", "problem_ids": ["arc178_a", "arc185_b", "abc361_f"]}, "abc340_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere are three brothers named A, B, and C. The age relationships among them are specified by three characters: \\( S_{\\mathrm{AB}} \\), \\( S_{\\mathrm{AC}} \\), and \\( S_{\\mathrm{BC}} \\). The meanings of these characters are as follows:\n\n- If \\( S_{\\mathrm{AB}} \\) is '<', then A is younger than B; if it is '>', then A is older than B.\n- If \\( S_{\\mathrm{AC}} \\) is '<', then A is younger than C; if it is '>', then A is older than C.\n- If \\( S_{\\mathrm{BC}} \\) is '<', then B is younger than C; if it is '>', then B is older than C.\n\nYou need to determine who the middle brother is, meaning the one who is the second oldest among the three.\n\n**Constraints:**\n\n- Each of \\( S_{\\mathrm{AB}}, S_{\\mathrm{AC}}, S_{\\mathrm{BC}} \\) is either '<' or '>'.\n- The input contains no contradictions, which means there will always be a valid age relationship that satisfies all provided inequalities.\n\n**Input**\n\nThe input is provided from standard input in the following format:\n\n```\nS_{\\mathrm{AB}} S_{\\mathrm{AC}} S_{\\mathrm{BC}}\n```\n\n**Output**\n\nPrint the name of the middle brother, who is the second oldest among the three.\n\n**Sample Input 1**\n```\n< < <\n```\n\n**Sample Output 1**\n```\nB\n```\n\nExplanation: Since A is younger than B, and B is younger than C, we conclude that C is the oldest, B is the middle, and A is the youngest. Hence, the answer is B.\n\n**Sample Input 2**\n```\n< < >\n```\n\n**Sample Output 2**\n```\nC\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial:\n\n---\n\nFor beginners:\n\nIf you are new to programming and do not know where to start, please try Problem A \"Welcome to AtCoder\" from the practice contest. There you can find sample code for each language. If you are not familiar with problems in programming contests, we recommend you try some problems in \"AtCoder Beginners Selection\". There are C++ and Python tutorials for competitive programmers in Japanese.\n\nProblem A Solution:\n\nThis problem has various solutions. One solution is to implement a conditional branch for all the eight possible inputs (among which six are consistent and can actually be the input). This can be done with an if statement, but it\u2019s a bit cumbersome. Here is a bit cleverer solution:\n\nIf \\(S_\\mathrm{AB}\\neq S_\\mathrm{AC}\\): A is the middle son.  \nOtherwise, if \\(S_\\mathrm{AB}= S_\\mathrm{BC}\\): B is the middle son.  \nOtherwise: C is the middle son.\n\nThe following sample code implements the simple casework in Python:\n\n```python\na, b, c = input().strip()\n\nif a != b:\n    print(\"A\")\nelif a == c:\n    print(\"B\")\nelse:\n    print(\"C\")\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 500 points\n\nProblem Statement\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- You are given a positive integer \\( N \\).\n- The judge has a hidden positive integer \\( R \\) and \\( N \\) integers \\( A_1, A_2, \\ldots, A_N \\). It is guaranteed that \\(|A_i| \\le R\\) and \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\).\n- There is a blackboard on which you can write integers with absolute values not exceeding \\( R \\). Initially, the blackboard is empty.\n- The judge has written the values \\( A_1, A_2, \\ldots, A_N \\) on the blackboard in this order. Your task is to make the blackboard contain only one value \\(\\sum_{i=1}^{N} A_i\\).\n- You cannot learn the values of \\( R \\) and \\( A_i \\) directly, but you can interact with the judge up to 25000 times.\n\nFor a positive integer \\( i \\), let \\( X_i \\) be the \\( i \\)-th integer written on the blackboard. Specifically, \\( X_i = A_i \\) for \\( i = 1, 2, \\ldots, N \\).\n\nIn one interaction, you can specify two distinct positive integers \\( i \\) and \\( j \\) and choose one of the following actions:\n\n1. Perform addition. The judge will erase \\( X_i \\) and \\( X_j \\) from the blackboard and write \\( X_i + X_j \\) on the blackboard.\n   - \\(|X_i + X_j| \\leq R\\) must hold.\n\n2. Perform comparison. The judge will tell you whether \\( X_i < X_j \\) is true or false.\n\nNote: At the beginning of each interaction, the \\( i \\)-th and \\( j \\)-th integers written on the blackboard must not have been erased.\n\nPerform the interactions appropriately so that after all interactions, the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\nThe values of \\( R \\) and \\( A_i \\) are determined before the start of the conversation between your program and the judge.\n\nConstraints:\n- \\( 2 \\leq N \\leq 1000 \\)\n- \\( 1 \\leq R \\leq 10^9 \\)\n- \\(|A_i| \\leq R\\)\n- \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\)\n- \\( N, R, \\) and \\( A_i \\) are integers.\n\nInput and Output\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- First, read \\( N \\) from Standard Input.\n\n  ```\n  N\n  ```\n\n- Next, repeat the interactions until the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\n- When performing addition, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  + i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  P\n  ```\n\n  Here, \\( P \\) is an integer:\n\n  - If \\( P \\geq N + 1 \\), it means that the value \\( X_i + X_j \\) has been written on the blackboard, and it is the \\( P \\)-th integer written.\n  - If \\( P = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\n- When performing comparison, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  ? i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  Q\n  ```\n\n  Here, \\( Q \\) is an integer:\n\n  - If \\( Q = 1 \\), it means that \\( X_i < X_j \\) is true.\n  - If \\( Q = 0 \\), it means that \\( X_i < X_j \\) is false.\n  - If \\( Q = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\nFor both types of interactions, if the judge's response is -1, your program is already considered incorrect. In this case, terminate your program immediately.\n\nWhen the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), report this to the judge in the following format. This does not count towards the number of interactions. Then, terminate your program immediately.\n\n  ```\n  !\n  ```\n\nIf you make an output in a format that does not match any of the above, -1 will be given from Standard Input.\n\n  ```\n  -1\n  ```\n\nIn this case, your program is already considered incorrect. Terminate your program immediately.\n\nNotes\n\n- For each output, append a newline at the end and flush Standard Output. Otherwise, the verdict may be TLE.\n- Terminate your program immediately after outputting the result (or receiving -1). Otherwise, the verdict will be indeterminate.\n- Extra newlines will be considered as malformed output.\n\nSample Input and Output\n\nHere is a possible conversation with \\( N=3, R=10, A_1=-1, A_2=10, A_3=1 \\).\n\n**Input:**\n```\n3\n```\n\n**Output:**\n```\n? 1 2\n1\n+ 1 3\n4\n+ 2 4\n5\n!\n```\n\n**Explanation:**\n\n1. First, the integer \\( N \\) is given.\n2. Perform a comparison between \\( X_1 \\) and \\( X_2 \\). The judge returns 1 because \\( X_1 < X_2 \\) (-1 < 10).\n3. Perform an addition of \\( X_1 \\) and \\( X_3 \\). The judge erases \\( X_1 = -1 \\) and \\( X_3 = 1 \\) from the blackboard and writes \\( X_1 + X_3 = 0 \\). This is the fourth integer written.\n4. Perform an addition of \\( X_2 \\) and \\( X_4 \\). The judge erases \\( X_2 = 10 \\) and \\( X_4 = 0 \\) from the blackboard and writes \\( X_2 + X_4 = 10 \\). This is the fifth integer written.\n5. The blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), so report this to the judge.\n\nSolution:\n\nBelow is the editorial as provided, since there's no code to translate to Python3:\n\n```\nAtCoder Regular Contest 179 - C: Beware of Overflow Editorial\n\nTo have only one integer on the blackboard, we need to perform exactly \\(N-1\\) additions. When there are two or more integers left on the blackboard, we should add the maximum and minimum values. The absolute value of their sum does not exceed \\(R\\). Let \\(X\\) be the multiset of integers on the blackboard, with maximum \\(M\\) and minimum \\(m\\). The absolute value of every element in \\(X\\) is at most \\(R\\), and \\(\\displaystyle\\left|\\sum_{x\\in X}x\\right|\\leq R\\).\n\n1. If \\(m \\geq 0\\), all integers are non-negative: \\(0 \\leq m + M \\leq R\\), so \\(|m + M| \\leq R\\).\n2. If \\(M \\leq 0\\), all integers are non-positive: \\(0 \\geq m + M \\geq -R\\), so \\(|m + M| \\leq R\\).\n3. If \\(m \\leq 0\\) and \\(M \\geq 0\\), \\(-R \\leq m \\leq m + M \\leq M \\leq R\\), so \\(|m + M| \\leq R\\).\n\nWe should add the maximum and minimum values. Use merge sort to arrange values in ascending order. Perform addition interactions to add the minimum and maximum values. Remove the first and last elements and insert the sum. Binary search determines the insertion position.\n\nEstimate interactions: Merge sort on a list of length \\(2^n\\) requires at most \\(a_n = n2^n\\) comparisons. Under \\(N \\leq 1000 \\leq 2^{10}\\), at most 10240 comparisons are needed. Finding insertion positions requires at most \\(10 \\times (N-1) \\leq 9990\\) comparisons. In total, at most 20230 comparisons plus \\(N-1 \\leq 999\\) additions remain well within the limit of 25000 interactions.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} (A_i \\oplus A_{i+1} \\oplus \\ldots \\oplus A_j) \\]\n\n**Notes on Bitwise XOR:**\n\nThe bitwise XOR of non-negative integers \\( A \\) and \\( B \\), denoted as \\( A \\oplus B \\), is defined as follows:\n\n- In the binary representation of \\( A \\oplus B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) position is 1 if and only if exactly one of the digits at the \\( 2^k \\) position in the binary representations of \\( A \\) and \\( B \\) is 1; otherwise, it is 0.\n\nFor example, \\( 3 \\oplus 5 = 6 \\) (in binary: \\( 011 \\oplus 101 = 110 \\)).\n\nIn general, the bitwise XOR of \\( k \\) integers \\( p_1, \\dots, p_k \\) is defined as \\( (\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k) \\). It can be proved that this is independent of the order of \\( p_1, \\dots, p_k \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n1 3 2\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n**Explanation:**\n\n\\( A_1 \\oplus A_2 = 2 \\), \\( A_1 \\oplus A_2 \\oplus A_3 = 0 \\), and \\( A_2 \\oplus A_3 = 1 \\), so the answer is \\( 2 + 0 + 1 = 3 \\).\n\n**Sample Input 2:**\n\n```\n7\n2 5 6 5 2 1 7\n```\n\n**Sample Output 2:**\n\n```\n83\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\nE - Xor Sigma Problem Editorial by en_translator\n\nIt is often effective to consider bitwise independently for a problem regarding XOR (exclusive logical sum). For each \\(j=0,1,\\ldots,27\\), define a sequence \\(B\\) of length \\(N\\) such that \\(B_i=1\\) if the \\(j\\)-th bit of \\(A_i\\) is \\(1\\) and \\(B_i=0\\) if it is \\(0\\). Solve the problem against \\(B\\) for each \\(j\\), and the total sum of the answers multiplied by \\(2^j\\) is the solution to the original problem. This simplifies the problem as \\(B\\) takes only zero or one, as opposed to \\(A\\) taking variable values.\n\nNext, the expression \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j)\\) requires the total XOR of a segment. This can be computed fast using cumulative XORs, similar to cumulative sums when computing the total sum on a segment. Define the array of cumulative XORs \\(C\\) by \\(C_0=0\\) and \\(C_i =B_1\\oplus \\ldots \\oplus B_i\\). Then \\(B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j = C_{i-1} \\oplus C_j\\).\n\nThe expression can be rewritten as follows:\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (C_{i-1} \\oplus C_j)  = \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j). \\]\n\nAdjusting the index \\(j\\) to start from \\(i+1\\):\n\\[ \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=0}^{N-1} (C_i\\oplus C_{i+1}) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=1}^{N} B_i. \\]\n\nNow \\(\\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j)\\) is the number of pairs of elements in \\(C\\) with different values, which equals the product of the number of occurrences of \\(0\\) and \\(1\\) in \\(C\\). Thus, the sought value can be evaluated with the total sum of \\(B\\) and the number of occurrences of \\(0\\) and \\(1\\) in the cumulative XORs. The problem is solved in \\(\\mathrm{O}(N \\log {\\mathrm{MAX_A}})\\) time.\n```\n \n\n", "problem_ids": ["abc371_a", "arc179_c", "abc365_e"]}, "abc340_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 500 points\n\nProblem Statement\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- You are given a positive integer \\( N \\).\n- The judge has a hidden positive integer \\( R \\) and \\( N \\) integers \\( A_1, A_2, \\ldots, A_N \\). It is guaranteed that \\(|A_i| \\le R\\) and \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\).\n- There is a blackboard on which you can write integers with absolute values not exceeding \\( R \\). Initially, the blackboard is empty.\n- The judge has written the values \\( A_1, A_2, \\ldots, A_N \\) on the blackboard in this order. Your task is to make the blackboard contain only one value \\(\\sum_{i=1}^{N} A_i\\).\n- You cannot learn the values of \\( R \\) and \\( A_i \\) directly, but you can interact with the judge up to 25000 times.\n\nFor a positive integer \\( i \\), let \\( X_i \\) be the \\( i \\)-th integer written on the blackboard. Specifically, \\( X_i = A_i \\) for \\( i = 1, 2, \\ldots, N \\).\n\nIn one interaction, you can specify two distinct positive integers \\( i \\) and \\( j \\) and choose one of the following actions:\n\n1. Perform addition. The judge will erase \\( X_i \\) and \\( X_j \\) from the blackboard and write \\( X_i + X_j \\) on the blackboard.\n   - \\(|X_i + X_j| \\leq R\\) must hold.\n\n2. Perform comparison. The judge will tell you whether \\( X_i < X_j \\) is true or false.\n\nNote: At the beginning of each interaction, the \\( i \\)-th and \\( j \\)-th integers written on the blackboard must not have been erased.\n\nPerform the interactions appropriately so that after all interactions, the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\nThe values of \\( R \\) and \\( A_i \\) are determined before the start of the conversation between your program and the judge.\n\nConstraints:\n- \\( 2 \\leq N \\leq 1000 \\)\n- \\( 1 \\leq R \\leq 10^9 \\)\n- \\(|A_i| \\leq R\\)\n- \\(\\left|\\sum_{i=1}^{N} A_i\\right| \\le R\\)\n- \\( N, R, \\) and \\( A_i \\) are integers.\n\nInput and Output\n\nThis is an interactive problem (where your program interacts with the judge via input and output).\n\n- First, read \\( N \\) from Standard Input.\n\n  ```\n  N\n  ```\n\n- Next, repeat the interactions until the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\).\n\n- When performing addition, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  + i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  P\n  ```\n\n  Here, \\( P \\) is an integer:\n\n  - If \\( P \\geq N + 1 \\), it means that the value \\( X_i + X_j \\) has been written on the blackboard, and it is the \\( P \\)-th integer written.\n  - If \\( P = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\n- When performing comparison, make an output in the following format to Standard Output. Append a newline at the end. Here, \\( i \\) and \\( j \\) are distinct positive integers.\n\n  ```\n  ? i j\n  ```\n\n- The response from the judge will be given from Standard Input in the following format:\n\n  ```\n  Q\n  ```\n\n  Here, \\( Q \\) is an integer:\n\n  - If \\( Q = 1 \\), it means that \\( X_i < X_j \\) is true.\n  - If \\( Q = 0 \\), it means that \\( X_i < X_j \\) is false.\n  - If \\( Q = -1 \\), it means that \\( i \\) and \\( j \\) do not satisfy the constraints, or the number of interactions has exceeded 25000.\n\nFor both types of interactions, if the judge's response is -1, your program is already considered incorrect. In this case, terminate your program immediately.\n\nWhen the blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), report this to the judge in the following format. This does not count towards the number of interactions. Then, terminate your program immediately.\n\n  ```\n  !\n  ```\n\nIf you make an output in a format that does not match any of the above, -1 will be given from Standard Input.\n\n  ```\n  -1\n  ```\n\nIn this case, your program is already considered incorrect. Terminate your program immediately.\n\nNotes\n\n- For each output, append a newline at the end and flush Standard Output. Otherwise, the verdict may be TLE.\n- Terminate your program immediately after outputting the result (or receiving -1). Otherwise, the verdict will be indeterminate.\n- Extra newlines will be considered as malformed output.\n\nSample Input and Output\n\nHere is a possible conversation with \\( N=3, R=10, A_1=-1, A_2=10, A_3=1 \\).\n\n**Input:**\n```\n3\n```\n\n**Output:**\n```\n? 1 2\n1\n+ 1 3\n4\n+ 2 4\n5\n!\n```\n\n**Explanation:**\n\n1. First, the integer \\( N \\) is given.\n2. Perform a comparison between \\( X_1 \\) and \\( X_2 \\). The judge returns 1 because \\( X_1 < X_2 \\) (-1 < 10).\n3. Perform an addition of \\( X_1 \\) and \\( X_3 \\). The judge erases \\( X_1 = -1 \\) and \\( X_3 = 1 \\) from the blackboard and writes \\( X_1 + X_3 = 0 \\). This is the fourth integer written.\n4. Perform an addition of \\( X_2 \\) and \\( X_4 \\). The judge erases \\( X_2 = 10 \\) and \\( X_4 = 0 \\) from the blackboard and writes \\( X_2 + X_4 = 10 \\). This is the fifth integer written.\n5. The blackboard contains only one value \\(\\sum_{i=1}^{N} A_i\\), so report this to the judge.\n\nSolution:\n\nBelow is the editorial as provided, since there's no code to translate to Python3:\n\n```\nAtCoder Regular Contest 179 - C: Beware of Overflow Editorial\n\nTo have only one integer on the blackboard, we need to perform exactly \\(N-1\\) additions. When there are two or more integers left on the blackboard, we should add the maximum and minimum values. The absolute value of their sum does not exceed \\(R\\). Let \\(X\\) be the multiset of integers on the blackboard, with maximum \\(M\\) and minimum \\(m\\). The absolute value of every element in \\(X\\) is at most \\(R\\), and \\(\\displaystyle\\left|\\sum_{x\\in X}x\\right|\\leq R\\).\n\n1. If \\(m \\geq 0\\), all integers are non-negative: \\(0 \\leq m + M \\leq R\\), so \\(|m + M| \\leq R\\).\n2. If \\(M \\leq 0\\), all integers are non-positive: \\(0 \\geq m + M \\geq -R\\), so \\(|m + M| \\leq R\\).\n3. If \\(m \\leq 0\\) and \\(M \\geq 0\\), \\(-R \\leq m \\leq m + M \\leq M \\leq R\\), so \\(|m + M| \\leq R\\).\n\nWe should add the maximum and minimum values. Use merge sort to arrange values in ascending order. Perform addition interactions to add the minimum and maximum values. Remove the first and last elements and insert the sum. Binary search determines the insertion position.\n\nEstimate interactions: Merge sort on a list of length \\(2^n\\) requires at most \\(a_n = n2^n\\) comparisons. Under \\(N \\leq 1000 \\leq 2^{10}\\), at most 10240 comparisons are needed. Finding insertion positions requires at most \\(10 \\times (N-1) \\leq 9990\\) comparisons. In total, at most 20230 comparisons plus \\(N-1 \\leq 999\\) additions remain well within the limit of 25000 interactions.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAt the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes \\( A \\) seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.\n\nCurrently, there is no one in line at the ticket booth, and \\( N \\) people will come to buy tickets one after another. Specifically, the \\( i \\)-th person will arrive at the ticket booth \\( T_i \\) seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately. Here, \\( T_1 < T_2 < \\dots < T_N \\).\n\nFor each \\( i\\ (1 \\leq i \\leq N) \\), determine how many seconds from now the \\( i \\)-th person will finish purchasing their ticket.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 0 \\leq T_1 < T_2 < \\dots < T_N \\leq 10^6 \\)\n- \\( 1 \\leq A \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\nT_1 T_2 \\dots T_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the number of seconds from now that the \\( i \\)-th person will finish purchasing their ticket.\n\n**Sample Input 1:**\n\n```\n3 4\n0 2 10\n```\n\n**Sample Output 1:**\n\n```\n4\n8\n14\n```\n\nThe events proceed in the following order:\n\n- At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.\n- At 8 seconds: The 2nd person finishes purchasing their ticket.\n- At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 14 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 2:**\n\n```\n3 3\n1 4 7\n```\n\n**Sample Output 2:**\n\n```\n4\n7\n10\n```\n\nThe events proceed in the following order:\n\n- At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.\n- At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 10 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 3:**\n\n```\n10 50000\n120190 165111 196897 456895 540000 552614 561627 743796 757613 991216\n```\n\n**Sample Output 3:**\n\n```\n170190\n220190\n270190\n506895\n590000\n640000\n690000\n793796\n843796\n1041216\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nB - Ticket Counter Editorial by en_translator\n\nSuppose that the \\(i\\)-th person finishes buying a ticket at time \\(x_i\\). For convenience, let \\(x_0=0\\).\nFor each \\(i\\) (1 \\(\\leq i\\leq N\\)), we determine how to represent the value \\(x_i\\) using \\(x_{i-1}\\).\n\nIf \\(x_{i-1} \\leq T_i\\): there is no queue when the \\(i\\)-th person visits the ticket booth, so they can start purchasing instantly. Thus, \\(x_i=T_i+A\\).\nIf \\(x_{i-1} > T_i\\): someone is still purchasing a ticket when the \\(i\\)-th person visits the booth, so they start the process right after the \\((i-1)\\)-th person finishes. Thus, \\(x_i=x_{i-1}+A\\).\n\nTo summarize, \\(x_i=\\max(x_{i-1},T_i)+A\\). Use this to find \\(x_i\\) for each \\(i=1,2,\\dots,N\\).\n\nSample code (Python):\n```python\nn, a = map(int, input().split())\nt = list(map(int, input().split()))\npre = 0\nfor i in range(n):\n    ans = max(pre, t[i]) + a\n    print(ans)\n    pre = ans\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\nYou can perform the following two types of operations zero or more times in any order:\n\n1. Choose a (contiguous) substring \\( ABA \\) in \\( S \\) and replace it with \\( A \\).\n2. Choose a (contiguous) substring \\( BAB \\) in \\( S \\) and replace it with \\( B \\).\n\nFind, modulo \\( 10^9+7 \\), the number of possible strings \\( S \\) after performing the operations.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 250000 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of characters \\( A \\) and \\( B \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n4\nABAB\n```\n\n**Sample Output 1**\n\n```\n2\n```\n\nThe two possible strings \\( S \\) after the operations are as follows:\n- \\( ABAB \\): This string can be obtained by performing zero operations.\n- \\( AB \\): The 1st to 3rd characters of \\( S=ABAB \\) are \\( ABA \\). Replacing them with \\( A \\) results in \\( S=AB \\).\n\nHere, the 2nd to 4th characters of \\( S=ABAB \\) are \\( BAB \\), so you can also replace them with \\( B \\). Note, however, that the resulting \\( AB \\) does not count multiple times.\n\n**Sample Input 2**\n\n```\n1\nA\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\nNo operations can be performed.\n\n**Sample Input 3**\n\n```\n17\nBBABABAABABAAAABA\n```\n\n**Sample Output 3**\n\n```\n18\n```\n\n**Sample Input 4**\n\n```\n100\nABAABAABABBABAABAABAABABBABBABBABBABBABBABBABBABBABBABBABBABBABAABABAABABBABBABABBABAABAABAABAABA\n```\n\n**Sample Output 4**\n\n```\n415919090\n```\n\nRemember to take the result modulo \\( 10^9+7 \\).\n\nSolution:\n\n```\nIn competitive programming, a well-known technique is using parity to perform inversions. Let\u2019s apply it to this problem. Specifically, let\u2019s invert the characters A and B only at even positions in the input string. Then, the two available operations become:\n\nAAA \u2192 A  \nBBB \u2192 B  \n\nWith this transformation, the solution becomes straightforward. For a contiguous segment of A or B, as long as its length does not become zero, we can reduce the length by 2 each time. For example, if there is a segment AAAAA, the possible final states are AAAAA, AAA, and A: there are three. Therefore, if the length of a segment of consecutive identical characters is L, the number of possible final states for that segment is floor((L+1)/2). For all segments of consecutive identical characters, the final states can be chosen independently. Thus, the product of the above values for all such segments is the answer to this problem.\n```\n \n\n", "problem_ids": ["arc179_c", "abc358_b", "arc180_a"]}, "abc340_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( N \\) and a sequence of \\( M \\) non-negative integers \\( A = (A_1, A_2, \\dots, A_M) \\).\n\nHere, all elements of \\( A \\) are distinct integers between \\( 0 \\) and \\( N-1 \\), inclusive.\n\nFind the number, modulo \\( 998244353 \\), of permutations \\( P \\) of \\( (0, 1, \\dots, N-1) \\) that satisfy the following condition:\n\nAfter initializing a sequence \\( B = (B_1, B_2, \\dots, B_N) \\) to \\( P \\), it is possible to make \\( B = A \\) by repeating the following operation some number of times:\n- Choose \\( l \\) and \\( r \\) such that \\( 1 \\leq l \\leq r \\leq |B| \\), and if \\( \\mathrm{mex}(\\{B_l, B_{l+1}, \\dots, B_r\\}) \\) is contained in \\( B \\), remove it from \\( B \\).\n\n**What is \\( \\mathrm{mex}(X) \\)?**\n\nFor a finite set \\( X \\) of non-negative integers, \\( \\mathrm{mex}(X) \\) is defined as the smallest non-negative integer that is not in \\( X \\).\n\n**Constraints:**\n- \\( 1 \\leq M \\leq N \\leq 500 \\)\n- \\( 0 \\leq A_i < N \\)\n- All elements of \\( A \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_1 A_2 \\cdots A_M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n4 2\n1 3\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\nAfter initializing \\( B = (2, 1, 0, 3) \\), it is possible to make \\( B = A \\) using the following steps:\n- Choose \\( (l, r) = (2, 4) \\), remove \\( \\mathrm{mex}(\\{1, 0, 3\\}) = 2 \\) from \\( B \\), making \\( B = (1, 0, 3) \\).\n- Choose \\( (l, r) = (3, 3) \\), remove \\( \\mathrm{mex}(\\{3\\}) = 0 \\) from \\( B \\), making \\( B = (1, 3) \\).\n\nThus, \\( P = (2, 1, 0, 3) \\) satisfies the condition. There are eight permutations \\( P \\) that satisfy the condition, including the above, so print \\( 8 \\).\n\n**Sample Input 2**\n\n```\n4 4\n0 3 2 1\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\nOnly \\( P = (0, 3, 2, 1) \\) satisfies the condition.\n\n**Sample Input 3**\n\n```\n16 7\n9 2 4 0 1 6 7\n```\n\n**Sample Output 3**\n\n```\n3520\n```\n\n**Sample Input 4**\n\n```\n92 4\n1 67 16 7\n```\n\n**Sample Output 4**\n\n```\n726870122\n```\n\nFind the count modulo \\( 998244353 \\).\n\nSolution:\n\n```python\nMOD = 998244353\n\n# input etc\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = [-1] * N\nfor i in range(M):\n    B[A[i]] = i\n\n# init\ndp = [[0 for j in range(M + 1)] for i in range(M + 1)]\nn_dp = [[0 for j in range(M + 1)] for i in range(M + 1)]\n\n# 0 in A\nif B[0] != -1:\n    dp[B[0]][M - 1 - B[0]] = 1\n\n# 0 not in A\nelse:\n    for i in range(M + 1):\n        dp[i][M - i] = 1\n\n# dp\nfor i in range(1, N):\n    # i in A\n    if B[i] != -1:\n        for l in range(M + 1):\n            for r in range(M + 1 - l):\n                a = min(l, B[i])\n                b = min(r, M - 1 - B[i])\n                if a != l or b != r:\n                    dp[a][b] = (dp[a][b] + dp[l][r]) % MOD\n                    dp[l][r] = 0\n    \n    # i not in A\n    else:\n        # copy dp\n        for l in range(M + 1):\n            for r in range(M + 1 - l):\n                n_dp[l][r] = dp[l][r]\n        for l in range(M, -1, -1):\n            for r in range(M - l, -1, -1):\n                if l != M:\n                    dp[l][r] = (dp[l][r] + dp[l + 1][r]) % MOD\n                if r != M:\n                    n_dp[l][r] = (n_dp[l][r] + n_dp[l][r + 1]) % MOD\n\n        # add\n        for l in range(M + 1):\n            for r in range(M + 1 - l):\n                dp[l][r] = (dp[l][r] + n_dp[l][r]) % MOD\n\n# output\nprint(dp[0][0])\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere are \\( N \\) people, numbered from 1 to \\( N \\). A competition was held among these \\( N \\) people, and they were ranked accordingly. The following information is given about their ranks:\n\n1. Each person has a unique rank.\n2. For each \\( 1 \\leq i \\leq M \\), if person \\( A_i \\) is ranked \\( x \\)-th and person \\( B_i \\) is ranked \\( y \\)-th, then \\( x - y = C_i \\).\n\nThe given input guarantees that there is at least one possible ranking that does not contradict the given information.\n\nYou need to answer \\( N \\) queries. The answer to the \\( i \\)-th query is determined as follows:\n- If the rank of person \\( i \\) can be uniquely determined, return that rank.\n- Otherwise, return \\(-1\\).\n\n### Constraints\n- \\( 2 \\leq N \\leq 16 \\)\n- \\( 0 \\leq M \\leq \\frac{N(N - 1)}{2} \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq N - 1 \\)\n- \\( (A_i, B_i) \\neq (A_j, B_j) \\) if \\( i \\neq j \\)\n- All input values are integers\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n### Output\nPrint the answers to the \\( 1 \\)-st, \\( 2 \\)-nd, ..., \\( N \\)-th queries in this order, separated by spaces.\n\n### Sample Input 1\n```\n5 2\n2 3 3\n5 4 3\n```\n\n### Sample Output 1\n```\n3 -1 -1 -1 -1\n```\n\nExplanation: Let \\( X_i \\) be the rank of person \\( i \\). The possible rankings could be \\( (3, 4, 1, 2, 5) \\) or \\( (3, 5, 2, 1, 4) \\). Therefore, only the rank of person 1 is uniquely determined as 3.\n\n### Sample Input 2\n```\n3 0\n```\n\n### Sample Output 2\n```\n-1 -1 -1\n```\n\n### Sample Input 3\n```\n8 5\n6 7 3\n8 1 7\n4 5 1\n7 2 1\n6 2 4\n```\n\n### Sample Output 3\n```\n1 -1 -1 -1 -1 -1 -1 8\n```\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 352\n\nConsider a \\(N\\)-vertex \\(M\\)-edge graph whose \\(i\\)-th edge connects vertex \\(A_i\\) and vertex \\(B_i\\). By the constraints, we can take an integer sequence \\(D = (D_1, D_2, \\ldots, D_N)\\) such that \\(D_{A_i} - D_{B_i} = C_i\\) for each \\(i\\). This sequence can be obtained by appropriately performing DFS (Depth-First Search) or BFS (Breadth-First Search) on the graph defined above. The sequence of person \\(i\\)\u2019s rank \\(X_i\\), collectively written as \\(X = (X_1, X_2, \\ldots, X_N)\\), is limited to permutations of \\((1,2,\\ldots, N)\\) such that:\n\n\\(X_i = D_i + v\\), where \\(v\\) is an arbitrary integer taken for each connected component and \\(i\\) is any of the vertices in it.\n\nWe try to respond to the query per connected component. When finding the answer to the \\(i\\)-th query, we perform a bit DP (Dynamic Programming) that places connected components not containing vertex \\(i\\). Specifically, maintain boolean values \\(dp_{x,y}\\) that represent whether the vertices in the first \\(x\\) connected components may correspond to the set of ranks \\(y\\). Since there are \\(O(N)\\) pairs of possible tuples of rank for each connected component, the DP above costs \\(O(N^2 2^N)\\) time naively, or \\(O(N 2^N)\\) time if you use the property that the value of \\(x\\) uniquely determines the popcount of \\(y\\). Therefore, the problem has been solved in a total of \\(O(N^2 2^N)\\) time.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 100 points\n\n## Problem Statement\n\nTakahashi came to a store to buy a pen. There are three types of pens available:\n- A red pen costs `R` yen.\n- A green pen costs `G` yen.\n- A blue pen costs `B` yen.\n\nHowever, Takahashi dislikes the color `C`. This means:\n- If `C` is `Red`, he cannot buy a red pen.\n- If `C` is `Green`, he cannot buy a green pen.\n- If `C` is `Blue`, he cannot buy a blue pen.\n\nDetermine the minimum amount of money he needs to spend to buy one pen.\n\n## Constraints\n\n- \\(1 \\leq R, G, B \\leq 100\\)\n- `R`, `G`, and `B` are integers.\n- `C` is either `Red`, `Green`, or `Blue`.\n\n## Input\n\nThe input is given in the following format:\n\n```\nR G B\nC\n```\n\n## Output\n\nIf the minimum amount of money Takahashi needs to buy one pen is `X` yen, print `X`.\n\n## Sample Input 1\n\n```\n20 30 10\nBlue\n```\n\n## Sample Output 1\n\n```\n20\n```\n\nA red pen costs 20 yen, a green pen costs 30 yen, and a blue pen costs 10 yen. Takahashi cannot buy a blue pen, but he can buy a red pen for 20 yen.\n\n## Sample Input 2\n\n```\n100 100 100\nRed\n```\n\n## Sample Output 2\n\n```\n100\n```\n\n## Sample Input 3\n\n```\n37 39 93\nBlue\n```\n\n## Sample Output 3\n\n```\n37\n```\n\nSolution:\n\n```python\nR, G, B = map(int, input().split())\nC = input()\nif C == \"Red\":\n    print(min(G, B))\nif C == \"Green\":\n    print(min(B, R))\nif C == \"Blue\":\n    print(min(R, G))\n```\n \n\n", "problem_ids": ["arc178_d", "abc352_f", "abc362_a"]}, "abc341_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given two integers \\( N \\) and \\( M \\). An integer sequence of length between 1 and \\( N \\) (inclusive), where each element is between 1 and \\( M \\) (inclusive), is called a *good sequence*.\n\nThe *score* of a good sequence is defined as the number of positive divisors of \\( X \\), where \\( X \\) is the product of the elements in the sequence.\n\nThere are \\(\\displaystyle \\sum_{k=1}^{N}M^k\\) good sequences. Your task is to find the sum of the scores of all those sequences modulo 998244353.\n\n**Constraints:**\n\n- \\(1 \\leq N \\leq 10^{18}\\)\n- \\(1 \\leq M \\leq 16\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is provided in the following format:\n\n```\nN M\n```\n\n**Output:**\n\nOutput the answer as an integer.\n\n**Examples:**\n\n- **Input:**\n  ```\n  1 7\n  ```\n\n  **Output:**\n  ```\n  16\n  ```\n  *Explanation:* \n  There are seven good sequences: (1), (2), (3), (4), (5), (6), (7). Their scores are 1, 2, 2, 3, 2, 4, 2, respectively, so the answer is 1 + 2 + 2 + 3 + 2 + 4 + 2 = 16.\n\n- **Input:**\n  ```\n  3 11\n  ```\n\n  **Output:**\n  ```\n  16095\n  ```\n  *Explanation:*\n  For example, (8, 11) and (1, 8, 2) are good sequences.\n  \n  - The product of the elements in (8, 11) is \\(8 \\times 11 = 88\\). 88 has eight positive divisors: 1, 2, 4, 8, 11, 22, 44, 88, so the score of (8, 11) is 8.\n  - The product of the elements in (1, 8, 2) is \\(1 \\times 8 \\times 2 = 16\\). 16 has five positive divisors: 1, 2, 4, 8, 16, so the score of (1, 8, 2) is 5.\n\n- **Input:**\n  ```\n  81131 14\n  ```\n\n  **Output:**\n  ```\n  182955659\n  ```\n  *Note:* Remember to take the result modulo 998244353.\n\nSolution:\n\n```python\nfrom collections import defaultdict\n\nMOD = 998244353\nMAX_PRIME = 6\nPRIMES = [2, 3, 5, 7, 11, 13]\n\ndef matrix_pow(a, x):\n    mat_size = len(a)\n    ret = [[0]*mat_size for _ in range(mat_size)]\n    for i in range(mat_size):\n        ret[i][i] = 1\n    while x > 0:\n        if x & 1:\n            nret = [[0]*mat_size for _ in range(mat_size)]\n            for i in range(mat_size):\n                for k in range(mat_size):\n                    for j in range(mat_size):\n                        nret[i][j] += ret[i][k] * a[k][j]\n                        nret[i][j] %= MOD\n            ret = nret\n        na = [[0]*mat_size for _ in range(mat_size)]\n        for i in range(mat_size):\n            for k in range(mat_size):\n                for j in range(mat_size):\n                    na[i][j] += a[i][k] * a[k][j]\n                    na[i][j] %= MOD\n        a = na\n        x >>= 1\n    return ret\n\nN, M = map(int, input().split())\nmat = [[0]*((1 << MAX_PRIME) + 1) for _ in range((1 << MAX_PRIME) + 1)]\nnxt = defaultdict(int)\nfor i in range(1 << MAX_PRIME):\n    for j in range(1, M + 1):\n        add = 1\n        for k in range(MAX_PRIME):\n            if not (i >> k) & 1:\n                continue\n            cnt = 0\n            while j % PRIMES[k] == 0:\n                cnt += 1\n                j //= PRIMES[k]\n            add *= cnt\n        nxt[i] += add\nfor i in range(1 << MAX_PRIME):\n    for j in nxt:\n        if (i & j) == 0:\n            mat[i][i | j] += nxt[j]\nmat[(1 << MAX_PRIME) - 1][1 << MAX_PRIME] = 1\nmat[1 << MAX_PRIME][1 << MAX_PRIME] = 1\nmat = matrix_pow(mat, N + 1)\nans = 0\nfor i in range(1 << MAX_PRIME):\n    ans += mat[i][1 << MAX_PRIME]\nprint((ans - 1) % MOD)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( L \\), and \\( R \\). For a sequence \\( A = (1, 2, \\dots, N) \\) of length \\( N \\), an operation of reversing the \\( L \\)-th through \\( R \\)-th elements was performed once. Print the sequence after this operation.\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\leq L \\leq R \\leq N \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN L R\n```\n\n**Output**\n\nLet \\( A' = (A'_1, A'_2, \\dots, A'_N) \\) be the sequence after the operation. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n5 2 3\n```\n\n**Sample Output 1**\n```\n1 3 2 4 5\n```\n\nExplanation: Initially, \\( A = (1, 2, 3, 4, 5) \\). After reversing the second through third elements, the sequence becomes \\( (1, 3, 2, 4, 5) \\), which should be printed.\n\n**Sample Input 2**\n```\n7 1 1\n```\n\n**Sample Output 2**\n```\n1 2 3 4 5 6 7\n```\n\nExplanation: It is possible that \\( L = R \\).\n\n**Sample Input 3**\n```\n10 1 10\n```\n\n**Sample Output 3**\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nExplanation: It is possible that \\( L = 1 \\) or \\( R = N \\).\n\nSolution:\n\nHere is the cleaned version of the editorial text:\n\nApproach 1: Actually construct an array and apply reversion. Solve the problem by constructing the sequence \\(A=(1,2,\\dots,N)\\) as an array, reverse the \\(L\\)-th through \\(R\\)-th elements, and print the result. First, let \\(l=L\\) and \\(r=R\\). While \\(l<r\\), swap the \\(l\\)-th and \\(r\\)-th element, add \\(1\\) to \\(l\\), and subtract \\(1\\) from \\(r\\). Note that the first element might be treated as the \\(0\\)-th one depending on array usage.\n\nSample code 1 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nwhile L < R:\n    A[L], A[R] = A[R], A[L]\n    L += 1\n    R -= 1\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nSample code 2 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nA[L:R + 1] = reversed(A[L:R + 1])\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nApproach 2: Directly construct the sought sequence. The structure is as follows: arrange \\(1,2,\\dots,L-1\\), then \\(R,R-1,\\dots,L\\), and finally \\(R+1,R+2,\\dots,N\\).\n\nSample code (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nres = []\n\nfor i in range(1, L):\n    res.append(i)\nfor i in range(R, L - 1, -1):\n    res.append(i)\nfor i in range(R + 1, N + 1):\n    res.append(i)\n\nfor i in range(N):\n    if i:\n        print(\" \", end=\"\")\n    print(res[i], end=\"\")\nprint()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere is a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i,j)\\) denote the cell at the \\(i\\)-th row from the top and \\(j\\)-th column from the left. There are \\(N\\) coins on this grid, and the \\(i\\)-th coin can be picked up by passing through the cell \\((R_i,C_i)\\).\n\nYour goal is to start from cell \\((1,1)\\), repeatedly move either down or right by one cell, and reach cell \\((H,W)\\) while picking up as many coins as possible.\n\nFind the maximum number of coins you can pick up and one of the paths that achieves this maximum.\n\nConstraints:\n- \\(2 \\leq H, W \\leq 2 \\times 10^5\\)\n- \\(1 \\leq N \\leq \\min(HW-2, 2 \\times 10^5)\\)\n- \\(1 \\leq R_i \\leq H\\)\n- \\(1 \\leq C_i \\leq W\\)\n- \\((R_i, C_i) \\neq (1,1)\\)\n- \\((R_i, C_i) \\neq (H,W)\\)\n- \\((R_i, C_i)\\) are pairwise distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format: \n```\nH W N\nR_1 C_1\nR_2 C_2\n\u22ee\nR_N C_N\n```\n\nOutput:\nPrint two lines.\n- The first line should contain the maximum number of coins you can pick up.\n- The second line should contain one of the paths that achieves this maximum as a string of length \\(H+W-2\\). The \\(i\\)-th character of this string should be `D` if the \\(i\\)-th move is downward, and `R` if it is rightward.\n\nIf there are multiple paths that maximize the number of coins picked up, you may print any of them.\n\nSample Input 1:\n```\n3 4 4\n3 3\n2 1\n2 3\n1 4\n```\n\nSample Output 1:\n```\n3\nDRRDR\n```\nAs shown in the figure above, by moving \\((1,1)\\rightarrow (2,1)\\rightarrow (2,2)\\rightarrow (2,3)\\rightarrow (3,3)\\rightarrow (3,4)\\), you can pick up three coins at \\((2,1),(2,3),(3,3)\\).\n\nSample Input 2:\n```\n2 2 2\n2 1\n1 2\n```\n\nSample Output 2:\n```\n1\nDR\n```\nThe path `RD` is also acceptable.\n\nSample Input 3:\n```\n10 15 8\n2 7\n2 9\n7 9\n10 3\n7 11\n8 12\n9 6\n8 1\n```\n\nSample Output 3:\n```\n5\nDRRRRRRRRDDDDDRRDRDDRRR\n```\n\nSolution:\n\n```\nHere is the cleaned editorial without excess content unrelated to the solution:\n\n---\n\nLet us call the coin that can be collected by passing through square \\((r,c)\\) simply coin \\((r,c)\\). Given \\(k\\) coins \\((r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)\\), one can determine if there is a path that can collect all the coins as follows:\n\nSort the coins in ascending order of \\((r,c)\\). Here, \\((r_i, c_i) < (r_j, c_j) \\Leftrightarrow (r_i < r_j) \\lor (r_i = r_j \\land c_i < c_j)\\). Let \\(((r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k))\\) be the resulting sequence. There exists a path that can collect all the given \\(k\\) coins if and only if \\(c'_1 \\leq c'_2 \\leq \\dots \\leq c'_k\\).\n\nProof: If two coins $i$ and $j$ with $(r_i, c_i) < (r_j, c_j)$ are to be collected, coin $i$ has to be collected first. Thus, the $k$ coins $(r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)$ can be all collected if and only if the $k$ coins $(r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k)$ can be collected **in this order**. Given $(r_i, c_i) < (r_j, c_j)$, we have $(r_i \\leq r_j \\land c_i \\leq c_j) \\Leftrightarrow c_i \\leq c_j$, so the claim above has been shown.\n\nSuppose that the given \\(N\\) coins are sorted in ascending order of \\((r,c)\\). Then, by the fact above, this problem is boiled down to finding a longest (weakly) increasing subsequence (LIS). Given positive integer sequence \\(c=(c_1,c_2,\\dots,c_N)\\), one can find the length of a LIS of \\(c\\) (not its length) by the following famous algorithm:\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\). The length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\).\n\nIntuitively, each \\(d_j\\) manages the smallest last element of a length-\\(j\\) (weakly) increasing subsequence of \\(c_1,c_2,\\dots,c_i\\) (or \\(\\infty\\) if there is no such subsequence). To find an example of LIS instead of its length only, let us modify the algorithm as follows.\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Prepare a length-\\(N\\) sequence \\(\\text{id}\\) and \\(\\text{pre}\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\), and replace \\(\\text{id}_j\\) with \\(i\\). If \\(j > 1\\), replace \\(\\text{pre}_i\\) with \\(\\text{id}_{j-1}\\) too.\n\nThe length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\). Let \\(l\\) be the length of a LIS of \\(c\\). Consider a length-\\(l\\) sequence obtained by applying \\((l-1)\\) times the action \\(i\\mapsto \\text{pre}_i\\) to \\(\\text{id}_l\\), namely \\((\\text{id}_l, \\text{pre}_{\\text{id}_l},\\text{pre}_{\\text{pre}_{\\text{id}_l}},\\dots)\\). The reversal of this sequence is an example of a LIS of \\(c\\).\n\nThe fact that an example of LIS can be indeed obtained using this algorithm can be proved inductively. The complexity of this algorithm is \\(O(N\\log N)\\), same as the original algorithm. (To find the minimum \\(j\\) in step \\(3\\), use binary search.) Thus, the problem has been solved.\n\nSample code (Python3):\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    h, w, n = map(int, sys.stdin.readline().strip().split())\n    coins = []\n    for _ in range(n):\n        r, c = map(int, sys.stdin.readline().strip().split())\n        coins.append((r, c))\n    coins.sort()\n    dp = [float('inf')] * n\n    id_list = [-1] * n\n    pre = [0] * n\n    for i in range(n):\n        it = bisect_right(dp, coins[i][1])\n        dp[it] = coins[i][1]\n        id_list[it] = i\n        pre[i] = id_list[it - 1] if it else -1\n    m = n - 1\n    while id_list[m] == -1:\n        m -= 1\n    path = [(h, w)]\n    now = id_list[m]\n    while now != -1:\n        path.append(coins[now])\n        now = pre[now]\n    path.append((1, 1))\n    path.reverse()\n    s = []\n    for i in range(len(path) - 1):\n        d = path[i + 1][0] - path[i][0]\n        r = path[i + 1][1] - path[i][1]\n        s.append('D' * d + 'R' * r)\n    print(m + 1)\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["arc182_c", "abc356_a", "abc369_f"]}, "abc341_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land sells tiles with English letters written on them. Takahashi is thinking of making a nameplate by arranging these tiles in a row.\n\nFind the number, modulo 998244353, of strings consisting of uppercase English letters with a length between 1 and K, inclusive, that satisfy the following conditions:\n\n- For every integer \\(i\\) satisfying \\(1 \\leq i \\leq 26\\), the following holds:\n  - Let \\(a_i\\) be the \\(i\\)-th uppercase English letter in lexicographical order. For example, \\(a_1 = A\\), \\(a_5 = E\\), \\(a_{26} = Z\\).\n  - The number of occurrences of \\(a_i\\) in the string is between 0 and \\(C_i\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq K \\leq 1000\\)\n- \\(0 \\leq C_i \\leq 1000\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nK\nC_1 C_2 \\ldots C_{26}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2\n2 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 1**\n\n```\n10\n```\n\nThe 10 strings that satisfy the conditions are: A, B, C, AA, AB, AC, BA, BC, CA, CB.\n\n**Sample Input 2**\n\n```\n358\n1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 2**\n\n```\n64\n```\n\n**Sample Input 3**\n\n```\n1000\n1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n```\n\n**Sample Output 3**\n\n```\n270274035\n```\n\nSolution:\n\nHere is a concise version of the editorial text:\n\nConsider counting conforming strings for each number of occurrences of z, finding the answer as their sum. Suppose a length-\\(s\\) string has \\(t\\) occurrences of z; there are \\(\\binom{s}{t}\\) ways to determine the positions of z. The other positions form a string of length \\((s-t)\\) without z, where \\(a_i\\) occurs between \\(0\\) and \\(C_i\\) times. Repeat this for letters down to x. Use DP with \\(dp_{i,j}\\) as the number of length-\\(j\\) strings from \\(a_1, a_2, \\ldots, a_i\\) where each \\(a_k\\) occurs between \\(0\\) and \\(C_k\\) times. The formula is \\(dp_{i + 1, j} = \\sum_{k = 0}^{\\min(j, C_{i+1})} dp_{i,j-k} \\binom{j}{k}\\). The answer is \\(\\sum_{j= 1}^{K}dp_{26, j}\\). Precompute binomial coefficients for an \\(O(\\sigma K^2)\\) solution, where \\(\\sigma = 26\\).\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere is a simple directed graph \\(G\\) with \\(N\\) vertices and \\(N+M\\) edges. The vertices are numbered \\(1\\) to \\(N\\), and the edges are numbered \\(1\\) to \\(N+M\\).\n\n- Edge \\(i\\) \\((1 \\leq i \\leq N)\\) goes from vertex \\(i\\) to vertex \\(i+1\\). Here, vertex \\(N+1\\) is considered as vertex \\(1\\).\n- Edge \\(N+i\\) \\((1 \\leq i \\leq M)\\) goes from vertex \\(X_i\\) to vertex \\(Y_i\\).\n\nTakahashi is at vertex \\(1\\). At each vertex, he can move to any vertex to which there is an outgoing edge from the current vertex.\n\nCompute the number of ways he can move exactly \\(K\\) times.\n\nThat is, find the number of integer sequences \\((v_0, v_1, \\dots, v_K)\\) of length \\(K+1\\) satisfying all of the following three conditions:\n- \\(1 \\leq v_i \\leq N\\) for \\(i = 0, 1, \\dots, K\\).\n- \\(v_0 = 1\\).\n- There is a directed edge from vertex \\(v_{i-1}\\) to vertex \\(v_i\\) for \\(i = 1, 2, \\ldots, K\\).\n\nSince this number can be very large, print it modulo \\(998244353\\).\n\n**Constraints**:\n- \\(2 \\leq N \\leq 2 \\times 10^5\\)\n- \\(0 \\leq M \\leq 50\\)\n- \\(1 \\leq K \\leq 2 \\times 10^5\\)\n- \\(1 \\leq X_i, Y_i \\leq N\\), \\(X_i \\neq Y_i\\)\n- All of the \\(N+M\\) directed edges are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M K\nX_1 Y_1\nX_2 Y_2\n\u22ee\nX_M Y_M\n```\n\n**Output**\n\nPrint the count modulo \\(998244353\\).\n\n**Sample Input 1**\n```\n6 2 5\n1 4\n2 5\n```\n\n**Sample Output 1**\n```\n5\n```\n\nThe above figure represents the graph \\(G\\). There are five ways for Takahashi to move:\n- Vertex \\(1 \\to\\) Vertex \\(2 \\to\\) Vertex \\(3 \\to\\) Vertex \\(4 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6\\)\n- Vertex \\(1 \\to\\) Vertex \\(2 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6 \\to\\) Vertex \\(1 \\to\\) Vertex \\(2\\)\n- Vertex \\(1 \\to\\) Vertex \\(2 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6 \\to\\) Vertex \\(1 \\to\\) Vertex \\(4\\)\n- Vertex \\(1 \\to\\) Vertex \\(4 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6 \\to\\) Vertex \\(1 \\to\\) Vertex \\(2\\)\n- Vertex \\(1 \\to\\) Vertex \\(4 \\to\\) Vertex \\(5 \\to\\) Vertex \\(6 \\to\\) Vertex \\(1 \\to\\) Vertex \\(4\\)\n\n**Sample Input 2**\n```\n10 0 200000\n```\n\n**Sample Output 2**\n```\n1\n```\n\n**Sample Input 3**\n```\n199 10 1326\n122 39\n142 49\n164 119\n197 127\n188 145\n69 80\n6 120\n24 160\n18 154\n185 27\n```\n\n**Sample Output 3**\n```\n451022766\n```\n\nSolution:\n\n```python\nn, m, k = map(int, input().split())\nif m == 0:\n    print(1)\n    exit()\nedges = []\ns = set([0])\nfor i in range(m):\n    x, y = map(lambda x: int(x) - 1, input().split())\n    s.add(x)\n    s.add(y)\n    edges.append((x, y))\n\ns = sorted(list(s))\nd = {}\nsz = len(s)\nfor i in range(sz):\n    d[s[i]] = i\nedge = [[] for i in range(sz)]\nfor i in range(sz):\n    edge[i].append(((i + 1) % sz, (s[(i + 1) % sz] - s[i]) % n))\nfor x, y in edges:\n    edge[d[x]].append((d[y], 1))\n\nmod = 998244353\ndp = [[0] * sz for i in range(k)]\ndp[0][0] = 1\nans = 0\nfor i in range(k):\n    for v in range(sz):\n        for to, w in edge[v]:\n            if i + w >= k:\n                ans += dp[i][v]\n                ans %= mod\n            else:\n                dp[i + w][to] += dp[i][v]\n                dp[i + w][to] %= mod\n\nprint(ans)\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) sequences of length \\( M \\), where each element is either 0 or 1. The \\( i \\)-th sequence is \\( A_i = (A_{i, 1}, A_{i, 2}, \\dots, A_{i, M}) \\).\n\nFor integers \\( i, j \\) \\((1 \\leq i, j \\leq N)\\), define \\( f(i, j) \\) as follows: \\( f(i, j) \\) is the smallest non-negative integer \\( x \\) such that \\( A_i \\) and \\( A_j \\) become identical after performing the following operation \\( x \\) times, or \\( 0 \\) if such \\( x \\) does not exist.\n\nOperation: For all integers \\( k \\) \\((1 \\leq k \\leq M)\\) simultaneously, replace \\( A_{i, k} \\) with \\( \\left (\\sum_{l=1}^{k} A_{i, l} \\right ) \\bmod 2 \\).\n\nFind \\( \\sum_{i=1}^{N} \\sum_{j=i}^{N} f(i, j) \\), modulo \\( 998244353 \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\times M \\leq 10^6 \\)\n- \\( A_{i, j} \\in \\{0, 1\\} \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_{1, 1} A_{1, 2} \\cdots A_{1, M}\nA_{2, 1} A_{2, 2} \\cdots A_{2, M}\n\\vdots\nA_{N, 1} A_{N, 2} \\cdots A_{N, M}\n```\n\n**Output**\n\nPrint the answer in one line.\n\n**Sample Input 1**\n\n```\n4 3\n1 0 0\n1 1 0\n1 0 1\n0 1 1\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\nExplanation: \\( f(1, 1) = 0 \\), \\( f(1, 2) = 3 \\), \\( f(1, 3) = 2 \\), \\( f(1, 4) = 0 \\), \\( f(2, 2) = 0 \\), \\( f(2, 3) = 3 \\), \\( f(2, 4) = 0 \\), \\( f(3, 3) = 0 \\), \\( f(3, 4) = 0 \\), \\( f(4, 4) = 0 \\), summing to 8.\n\n**Sample Input 2**\n\n```\n7 6\n1 0 0 0 0 0\n1 1 1 0 0 0\n1 0 1 1 0 0\n1 0 0 0 1 1\n1 0 0 0 0 1\n1 0 0 0 0 0\n1 1 1 1 1 1\n```\n\n**Sample Output 2**\n\n```\n6\n```\n\nSolution:\n\n```plaintext\nEditorial - E - Accumulating Many Times\n\nFirst, treat sequences that differ in the position of their first \\(1\\) as separate problems, since operations do not change this position. Assume \\(A_{i, 1} = 1\\). Define the inverse operation for the problem's operation. The graph formed by length-\\(M\\) binary sequences starting with \\(1\\) has operations as edges and is a collection of cycles. \n\nEvery sequence can be transformed into a \u201cstandard form\u201d where all elements at positions \\((2^x + 1)\\) using non-negative integer \\(x\\) are \\(0\\). This is proven using Lucas\u2019s theorem. Cycle length is \\(2^m\\), where \\(m\\) is the smallest non-negative integer such that \\(2^m + 1 \\leq M\\).\n\nTo solve, first transform sequences to their standard forms and calculate the required operations. For each \\(i = 1, 2, \\dots, N\\), compute the standard form of sequence \\(A_i\\) and the cost to reach it. Transform \\(A_{i, 2^x + 1}\\) into \\(0\\) by performing the operation \\(2^x\\) times if \\(A_{i, 2^x + 1} = 1\\).\n\nNext, solve for each standard form: for integer sequence \\(B\\), compute \\(\\displaystyle \\sum_{i=1}^{m} \\sum_{j=i}^{m} \\left( (B_j - B_i) \\bmod 2^m \\right)\\) using Segment Tree or similar structures.\n\nThe computational bottleneck is computing the standard forms. Multiple operations using FFT help, but we may exceed the time limit if performed every time. Instead, keep track of operations count to determine value at a position in \\(O(M)\\) time. Overall complexity is \\(O(NM \\log NM)\\).\n```\n \n\n", "problem_ids": ["abc358_e", "abc372_f", "arc184_e"]}, "abc341_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement (Score: 650 points)**\n\nWe call a positive integer \\( n \\) a \"good integer\" if and only if the sum of its positive divisors is divisible by 3. You are given two positive integers \\( N \\) and \\( M \\). Find the number, modulo 998244353, of length-\\( M \\) sequences \\( A \\) of positive integers such that the product of the elements in \\( A \\) is a good integer not exceeding \\( N \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^{10} \\)\n- \\( 1 \\leq M \\leq 10^5 \\)\n- \\( N \\) and \\( M \\) are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n10 1\n```\n\n**Sample Output 1**\n\n```\n5\n```\n\nThere are five sequences that satisfy the conditions:\n\n- (2)\n- (5)\n- (6)\n- (8)\n- (10)\n\n**Sample Input 2**\n\n```\n4 2\n```\n\n**Sample Output 2**\n\n```\n2\n```\n\nThere are two sequences that satisfy the conditions:\n\n- (1, 2)\n- (2, 1)\n\n**Sample Input 3**\n\n```\n370 907\n```\n\n**Sample Output 3**\n\n```\n221764640\n```\n\n**Sample Input 4**\n\n```\n10000000000 100000\n```\n\n**Sample Output 4**\n\n```\n447456146\n```\n\nSolution:\n\n```python\n# Here is the rewritten editorial with Python code:\n\n# Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\n# G - Divisible by 3 Editorial\n\n# This problem can be solved by finding a prefix sum of a multiplicative function. \n# A function f(n) is multiplicative if f(ab) = f(a) f(b) for all positive integers gcd(a, b) = 1.\n\n# Given a multiplicative function f(n), evaluate:\n# sum(1 <= n <= N) f(n).\n\n# **Facts and Problem Rephrasing:**\n\n# 1. sigma(n), the sum of the divisors of n, is multiplicative as per the formula:\n#    sigma(n) = prod(i=1 to k) (1 + p_i + ... + p_i^e_i)\n\n# 2. g(n), the number of length-M sequences of positive integers such that their product is M, is multiplicative:\n#    g(n) = prod(i=1 to k) comb(e_i + M - 1, M - 1)\n\n# Original problem:\n# sum(1 <= n <= N, sigma(n) % 3 = 0) g(n)\n\n# Define:\n# h(n) = \n# if sigma(n) % 3 == 0:\n#     0\n# else:\n#     g(n)\n\n# Rephrased Problem:\n# sum(n=1 to N) (g(n) - h(n))\n\n# Final expression:\n# sum(n=1 to N) g(n) - sum(n=1 to N) h(n)\n\n# There are efficient algorithms to compute these prefix sums:\n\n# **Lucy DP:**\n# Define:\n# F(n) = sum(1 <= m <= n) f(m),\n# F_prime(n) = sum(1 <= p <= n, p: prime) f(p),\n\n# Evaluate F_prime(n) for all n in Q_N using a dynamic programming approach, Lucy DP.\n\n# **Black Algorithm and Min_25 sieve:**\n# Evaluate F(N) using F_prime(n) results.\n\n# Black Algorithm: Uses a tree structure to compute F(N) leveraging the multiplicativity of the function.\n\n# Min_25 Sieve: Offers a more efficient approach with complexity O(N^(2/3)).\n\n# By implementing Lucy DP and one of the other methods, the problem is solved efficiently with complexity O(N^(3/4)/log N) or O(N^(1 - epsilon)).\n\n# **Advanced Topics:**\n\n# More efficient algorithms, like those by zhoukangyang (O(sqrt(N))) and Zhenting Zhu (Theta (N^(2/3) / (log N)^(4/3))), exist.\n# Other algorithms like Dujiao sieve or PowerfulNumber sieve can be used under specific conditions.\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 550 points\n\nProblem Statement:\nYou are given a sequence of integers \\( A = (A_1, \\ldots, A_N) \\). For a tree \\( T \\) with \\( N \\) vertices, define \\( f(T) \\) as follows:\n- Let \\( d_i \\) be the degree of vertex \\( i \\) in \\( T \\). Then, \\( f(T) = \\sum_{i=1}^N {d_i}^2 A_i \\).\n\nFind the minimum possible value of \\( f(T) \\).\n\nThe constraints guarantee that the answer will be less than \\( 2^{63} \\).\n\nConstraints:\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n4\n3 2 5 2\n```\n\nSample Output 1:\n```\n24\n```\n\nExplanation for Sample Output 1:\nConsider a tree \\( T \\) with an edge connecting vertices 1 and 2, an edge connecting vertices 2 and 4, and an edge connecting vertices 4 and 3. Then, \\( f(T) = 1^2 \\times 3 + 2^2 \\times 2 + 1^2 \\times 5 + 2^2 \\times 2 = 24 \\). It can be proven that this is the minimum value of \\( f(T) \\).\n\nSample Input 2:\n```\n3\n4 3 2\n```\n\nSample Output 2:\n```\n15\n```\n\nSample Input 3:\n```\n7\n10 5 10 2 10 13 15\n```\n\nSample Output 3:\n```\n128\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        **Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359) - Tree Degree Optimization**\n\nAn integer sequence \\(d=(d_1,\\ldots,d_N)\\) is eligible for a sequence of degrees if and only if:\n\n1. \\(d_i \\geq 1\\)\n2. \\(\\sum_{i=1}^N d_i = 2N-2\\)\n\nAny such sequence can be a sequence of degrees, so it is sufficient to minimize the cost over such sequences. The additional cost when incrementing \\(d_i\\) monotonically increases as \\(d_i\\) increases; thus, the problem can be solved greedily. First, initialize as \\(d_i=1\\) for all \\(i\\), and then repeat \\((N-2)\\) times by incrementing \\(d_i\\) for \\(i\\) with the minimal additional cost. This greedy algorithm can be optimized using a priority_queue, resulting in running in \\(\\mathrm{O}(N\\log N)\\) time.\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( A_1, A_2, A_3 \\). Find the number of tuples of positive integers \\( (X_1, X_2, X_3) \\) that satisfy all of the following conditions, modulo \\( 998244353 \\):\n\n1. \\( X_1 \\) is a positive integer with \\( A_1 \\) digits in decimal notation.\n2. \\( X_2 \\) is a positive integer with \\( A_2 \\) digits in decimal notation.\n3. \\( X_3 \\) is a positive integer with \\( A_3 \\) digits in decimal notation.\n4. \\( X_1 + X_2 = X_3 \\).\n\nYou are given \\( T \\) test cases per input file; solve each of them.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\) for \\( i = 1, 2, 3 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is provided from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach case is given in the following format:\n\n```\nA_1 A_2 A_3\n```\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for \\( case_i \\).\n\n**Sample Input 1**\n\n```\n4\n1 1 1\n1 6 7\n167 167 167\n111 666 777\n```\n\n**Sample Output 1**\n\n```\n36\n45\n731780675\n0\n```\n\n- For the first case, tuples such as \\( (X_1, X_2, X_3) = (1, 6, 7), (2, 1, 3) \\) satisfy the conditions. On the other hand, tuples such as \\( (X_1, X_2, X_3) = (6, 7, 13), (3, 4, 5) \\) do not. There are 36 tuples \\( (X_1, X_2, X_3) \\) that satisfy the conditions, so print 36.\n- For the third case, remember to print the result modulo 998244353.\n- For the fourth case, there may be no tuples \\( (X_1, X_2, X_3) \\) that satisfy the conditions.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nB - 1 + 6 = 7 Editorial by evima\n\nWe aim to find the number of pairs of integers \\((X_{1}, X_{2})\\) satisfying:\n\n\\(10^{A_{1} - 1} \\leq X_{1}\\)\n\n\\(10^{A_{2}-1} \\leq X_{2}\\)\n\n\\(X_{1} + X_{2} < 10^{A_{3}}\\)\n\n\\(10^{A_{1}} \\leq X_{1}\\) does not hold.\n\n\\(10^{A_{2}} \\leq X_{2}\\) does not hold.\n\n\\(X_{1} + X_{2} < 10^{A_{3}-1}\\) does not hold.\n\nUsing the inclusion-exclusion principle, the answer can be expressed as:\n\\[\\sum_{i=0}^{1}\\sum_{j=0}^{1}\\sum_{k=0}^{1}f(A_{1} - i, A_{2} - j, A_{3} - k)(-1)^{i+j+k} \\]\n\nFor \\(f(B_{1}, B_{2}, B_{3})\\):\n\nIf \\(B_{3} \\leq \\max(B_{1}, B_{2})\\), \\(f(B_{1}, B_{2}, B_{3}) = 0\\).\n\nIf \\(B_{3} > \\max(B_{1}, B_{2})\\), \\(f(B_{1}, B_{2}, B_{3}) = \\dfrac{(10^{B_{3}}-10^{B_{1}}-10^{B_{2}})(10^{B_{3}}-10^{B_{1}}-10^{B_{2}} + 1)}{2}\\).\n\nThis computation can be done in \\(O(\\log(A_{3}))\\) time per test case.\n\nPython Implementation Example:\n```python\nMOD = 998244353\n\ndef f(b1, b2, b3):\n    if max(b1, b2) >= b3:\n        return 0\n    tmp = pow(10, b3, MOD) - pow(10, b1, MOD) - pow(10, b2, MOD)\n    return (tmp + 1) * tmp // 2\n\nT = int(input())\nfor _ in range(T):\n    a1, a2, a3 = map(int, input().split())\n    ans = 0\n    pm = 1\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                ans = (ans + f(a1 - i, a2 - j, a3 - k) * pm) % MOD\n                pm *= -1\n            pm *= -1\n        pm *= -1\n    print(ans)\n```\n```\n \n\n", "problem_ids": ["abc370_g", "abc359_f", "arc178_b"]}, "abc341_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} (A_i \\oplus A_{i+1} \\oplus \\ldots \\oplus A_j) \\]\n\n**Notes on Bitwise XOR:**\n\nThe bitwise XOR of non-negative integers \\( A \\) and \\( B \\), denoted as \\( A \\oplus B \\), is defined as follows:\n\n- In the binary representation of \\( A \\oplus B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) position is 1 if and only if exactly one of the digits at the \\( 2^k \\) position in the binary representations of \\( A \\) and \\( B \\) is 1; otherwise, it is 0.\n\nFor example, \\( 3 \\oplus 5 = 6 \\) (in binary: \\( 011 \\oplus 101 = 110 \\)).\n\nIn general, the bitwise XOR of \\( k \\) integers \\( p_1, \\dots, p_k \\) is defined as \\( (\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k) \\). It can be proved that this is independent of the order of \\( p_1, \\dots, p_k \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n1 3 2\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n**Explanation:**\n\n\\( A_1 \\oplus A_2 = 2 \\), \\( A_1 \\oplus A_2 \\oplus A_3 = 0 \\), and \\( A_2 \\oplus A_3 = 1 \\), so the answer is \\( 2 + 0 + 1 = 3 \\).\n\n**Sample Input 2:**\n\n```\n7\n2 5 6 5 2 1 7\n```\n\n**Sample Output 2:**\n\n```\n83\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\nE - Xor Sigma Problem Editorial by en_translator\n\nIt is often effective to consider bitwise independently for a problem regarding XOR (exclusive logical sum). For each \\(j=0,1,\\ldots,27\\), define a sequence \\(B\\) of length \\(N\\) such that \\(B_i=1\\) if the \\(j\\)-th bit of \\(A_i\\) is \\(1\\) and \\(B_i=0\\) if it is \\(0\\). Solve the problem against \\(B\\) for each \\(j\\), and the total sum of the answers multiplied by \\(2^j\\) is the solution to the original problem. This simplifies the problem as \\(B\\) takes only zero or one, as opposed to \\(A\\) taking variable values.\n\nNext, the expression \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j)\\) requires the total XOR of a segment. This can be computed fast using cumulative XORs, similar to cumulative sums when computing the total sum on a segment. Define the array of cumulative XORs \\(C\\) by \\(C_0=0\\) and \\(C_i =B_1\\oplus \\ldots \\oplus B_i\\). Then \\(B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j = C_{i-1} \\oplus C_j\\).\n\nThe expression can be rewritten as follows:\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (C_{i-1} \\oplus C_j)  = \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j). \\]\n\nAdjusting the index \\(j\\) to start from \\(i+1\\):\n\\[ \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=0}^{N-1} (C_i\\oplus C_{i+1}) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=1}^{N} B_i. \\]\n\nNow \\(\\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j)\\) is the number of pairs of elements in \\(C\\) with different values, which equals the product of the number of occurrences of \\(0\\) and \\(1\\) in \\(C\\). Thus, the sought value can be evaluated with the total sum of \\(B\\) and the number of occurrences of \\(0\\) and \\(1\\) in the cumulative XORs. The problem is solved in \\(\\mathrm{O}(N \\log {\\mathrm{MAX_A}})\\) time.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( L \\), and \\( R \\). For a sequence \\( A = (1, 2, \\dots, N) \\) of length \\( N \\), an operation of reversing the \\( L \\)-th through \\( R \\)-th elements was performed once. Print the sequence after this operation.\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\leq L \\leq R \\leq N \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN L R\n```\n\n**Output**\n\nLet \\( A' = (A'_1, A'_2, \\dots, A'_N) \\) be the sequence after the operation. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n5 2 3\n```\n\n**Sample Output 1**\n```\n1 3 2 4 5\n```\n\nExplanation: Initially, \\( A = (1, 2, 3, 4, 5) \\). After reversing the second through third elements, the sequence becomes \\( (1, 3, 2, 4, 5) \\), which should be printed.\n\n**Sample Input 2**\n```\n7 1 1\n```\n\n**Sample Output 2**\n```\n1 2 3 4 5 6 7\n```\n\nExplanation: It is possible that \\( L = R \\).\n\n**Sample Input 3**\n```\n10 1 10\n```\n\n**Sample Output 3**\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nExplanation: It is possible that \\( L = 1 \\) or \\( R = N \\).\n\nSolution:\n\nHere is the cleaned version of the editorial text:\n\nApproach 1: Actually construct an array and apply reversion. Solve the problem by constructing the sequence \\(A=(1,2,\\dots,N)\\) as an array, reverse the \\(L\\)-th through \\(R\\)-th elements, and print the result. First, let \\(l=L\\) and \\(r=R\\). While \\(l<r\\), swap the \\(l\\)-th and \\(r\\)-th element, add \\(1\\) to \\(l\\), and subtract \\(1\\) from \\(r\\). Note that the first element might be treated as the \\(0\\)-th one depending on array usage.\n\nSample code 1 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nwhile L < R:\n    A[L], A[R] = A[R], A[L]\n    L += 1\n    R -= 1\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nSample code 2 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nA[L:R + 1] = reversed(A[L:R + 1])\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nApproach 2: Directly construct the sought sequence. The structure is as follows: arrange \\(1,2,\\dots,L-1\\), then \\(R,R-1,\\dots,L\\), and finally \\(R+1,R+2,\\dots,N\\).\n\nSample code (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nres = []\n\nfor i in range(1, L):\n    res.append(i)\nfor i in range(R, L - 1, -1):\n    res.append(i)\nfor i in range(R + 1, N + 1):\n    res.append(i)\n\nfor i in range(N):\n    if i:\n        print(\" \", end=\"\")\n    print(res[i], end=\"\")\nprint()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAt the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes \\( A \\) seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.\n\nCurrently, there is no one in line at the ticket booth, and \\( N \\) people will come to buy tickets one after another. Specifically, the \\( i \\)-th person will arrive at the ticket booth \\( T_i \\) seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately. Here, \\( T_1 < T_2 < \\dots < T_N \\).\n\nFor each \\( i\\ (1 \\leq i \\leq N) \\), determine how many seconds from now the \\( i \\)-th person will finish purchasing their ticket.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 0 \\leq T_1 < T_2 < \\dots < T_N \\leq 10^6 \\)\n- \\( 1 \\leq A \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\nT_1 T_2 \\dots T_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the number of seconds from now that the \\( i \\)-th person will finish purchasing their ticket.\n\n**Sample Input 1:**\n\n```\n3 4\n0 2 10\n```\n\n**Sample Output 1:**\n\n```\n4\n8\n14\n```\n\nThe events proceed in the following order:\n\n- At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.\n- At 8 seconds: The 2nd person finishes purchasing their ticket.\n- At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 14 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 2:**\n\n```\n3 3\n1 4 7\n```\n\n**Sample Output 2:**\n\n```\n4\n7\n10\n```\n\nThe events proceed in the following order:\n\n- At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.\n- At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 10 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 3:**\n\n```\n10 50000\n120190 165111 196897 456895 540000 552614 561627 743796 757613 991216\n```\n\n**Sample Output 3:**\n\n```\n170190\n220190\n270190\n506895\n590000\n640000\n690000\n793796\n843796\n1041216\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nB - Ticket Counter Editorial by en_translator\n\nSuppose that the \\(i\\)-th person finishes buying a ticket at time \\(x_i\\). For convenience, let \\(x_0=0\\).\nFor each \\(i\\) (1 \\(\\leq i\\leq N\\)), we determine how to represent the value \\(x_i\\) using \\(x_{i-1}\\).\n\nIf \\(x_{i-1} \\leq T_i\\): there is no queue when the \\(i\\)-th person visits the ticket booth, so they can start purchasing instantly. Thus, \\(x_i=T_i+A\\).\nIf \\(x_{i-1} > T_i\\): someone is still purchasing a ticket when the \\(i\\)-th person visits the booth, so they start the process right after the \\((i-1)\\)-th person finishes. Thus, \\(x_i=x_{i-1}+A\\).\n\nTo summarize, \\(x_i=\\max(x_{i-1},T_i)+A\\). Use this to find \\(x_i\\) for each \\(i=1,2,\\dots,N\\).\n\nSample code (Python):\n```python\nn, a = map(int, input().split())\nt = list(map(int, input().split()))\npre = 0\nfor i in range(n):\n    ans = max(pre, t[i]) + a\n    print(ans)\n    pre = ans\n```\n \n\n", "problem_ids": ["abc365_e", "abc356_a", "abc358_b"]}, "abc341_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n### Problem Statement\n\nThere is a keyboard with 26 keys arranged on a number line. The arrangement of this keyboard is represented by a string \\( S \\), which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character \\( S_x \\) is located at coordinate \\( x \\) \\((1 \\leq x \\leq 26)\\). Here, \\( S_x \\) denotes the \\( x \\)-th character of \\( S \\).\n\nYou will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key. Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.\n\n### Constraints\n\n- \\( S \\) is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n### Sample Output 1\n```\n25\n```\n\nFrom pressing the key for `A` to pressing the key for `Z`, you need to move your finger 1 unit at a time in the positive direction, resulting in a total traveled distance of 25. It is impossible to press all keys with a total traveled distance less than 25, so print 25.\n\n### Sample Input 2\n```\nMGJYIZDKSBHPVENFLQURTCWOAX\n```\n\n### Sample Output 2\n```\n223\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        For a character \\(c\\), let \\(X_c\\) be the coordinate of the key corresponding to the character \\(c\\). We need to find \\(|X_A-X_B|+|X_B-X_C|+\\ldots+|X_Y-X_Z|\\). If we can find \\(S\\) from \\(X\\), the sought value can be found using a for loop. An array can correspond the integer \\(0\\) to A, \\(1\\) to B, \\(\\ldots\\), and \\(25\\) to Z, so that \\(X\\) can be managed as an array. Alternatively, an associative array with its key as a character type can be used.\n\nSample code in Python3:\n\n```python\ns = input()\nx = [0] * 26\nfor i in range(26):\n    x[ord(s[i]) - ord(\"A\")] = i\nans = 0\nfor i in range(25):\n    ans += abs(x[i] - x[i + 1])\nprint(ans)\n```\n        [END TEXT]\n        \n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nIn the Kingdom of AtCoder, the eldest son is always given the name Taro. No one else is given the name Taro. The eldest son is the earliest born male child in each family.\n\nThere are \\(N\\) families in the Kingdom, and \\(M\\) babies were born. Before the \\(M\\) babies were born, none of the \\(N\\) families had had any babies.\n\nInformation about the babies is given in chronological order of their birth. The \\(i\\)-th baby born was born in family \\(A_i\\), and the baby is male if \\(B_i\\) is \\(M\\), and female if it is \\(F\\).\n\nDetermine for each of the \\(M\\) babies whether the name given is Taro.\n\nConstraints:\n- \\(1 \\leq N, M \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- \\(B_i\\) is \\(M\\) or \\(F\\).\n- All numbers in the input are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\nOutput:\nPrint \\(M\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq M)\\) should contain `Yes` if the name given to the \\(i\\)-th baby is Taro, and `No` otherwise.\n\nSample Input 1:\n```\n2 4\n1 M\n1 M\n2 F\n2 M\n```\n\nSample Output 1:\n```\nYes\nNo\nNo\nYes\n```\n\nExplanation of Sample Output 1:\n- The first baby is the earliest born boy in family 1, so he is named Taro.\n- The second baby is not the earliest born boy in family 1, so he is not named Taro.\n- The third baby is a girl, so she is not named Taro.\n- The fourth baby is the earliest born **boy** in family 2, so he is named Taro. Note that the third baby is also born in family 2, but it is the earliest born boy who is named Taro.\n\nSample Input 2:\n```\n4 7\n2 M\n3 M\n1 F\n4 F\n4 F\n1 F\n2 M\n```\n\nSample Output 2:\n```\nYes\nYes\nNo\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Beginner Contest 371\n\nB - Taro Editorial by en_translator\n\nMaintain a flag to manage whether each family had had Taro already. The flags are initialized with False. Inspect the babies in order. If the baby is a girl, print No, and nothing more is required. If the baby is a boy, check the flag of his family. If the flag is False, print Yes, and set the flag to True. If the flag is already True, print No. The operations so far can be implemented with for statements, if statements, and arrays.\n\nSample code (Python):\n```python\nn, m = map(int, input().split())\ntaro_exist = [False for i in range(n)]\nfor i in range(m):\n    a, b = input().split()\n    a = int(a) - 1\n    if b == 'F' or taro_exist[a]:\n        print('No')\n    else:\n        taro_exist[a] = True\n        print('Yes')\n```\n\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere is a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i,j)\\) denote the cell at the \\(i\\)-th row from the top and \\(j\\)-th column from the left. There are \\(N\\) coins on this grid, and the \\(i\\)-th coin can be picked up by passing through the cell \\((R_i,C_i)\\).\n\nYour goal is to start from cell \\((1,1)\\), repeatedly move either down or right by one cell, and reach cell \\((H,W)\\) while picking up as many coins as possible.\n\nFind the maximum number of coins you can pick up and one of the paths that achieves this maximum.\n\nConstraints:\n- \\(2 \\leq H, W \\leq 2 \\times 10^5\\)\n- \\(1 \\leq N \\leq \\min(HW-2, 2 \\times 10^5)\\)\n- \\(1 \\leq R_i \\leq H\\)\n- \\(1 \\leq C_i \\leq W\\)\n- \\((R_i, C_i) \\neq (1,1)\\)\n- \\((R_i, C_i) \\neq (H,W)\\)\n- \\((R_i, C_i)\\) are pairwise distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format: \n```\nH W N\nR_1 C_1\nR_2 C_2\n\u22ee\nR_N C_N\n```\n\nOutput:\nPrint two lines.\n- The first line should contain the maximum number of coins you can pick up.\n- The second line should contain one of the paths that achieves this maximum as a string of length \\(H+W-2\\). The \\(i\\)-th character of this string should be `D` if the \\(i\\)-th move is downward, and `R` if it is rightward.\n\nIf there are multiple paths that maximize the number of coins picked up, you may print any of them.\n\nSample Input 1:\n```\n3 4 4\n3 3\n2 1\n2 3\n1 4\n```\n\nSample Output 1:\n```\n3\nDRRDR\n```\nAs shown in the figure above, by moving \\((1,1)\\rightarrow (2,1)\\rightarrow (2,2)\\rightarrow (2,3)\\rightarrow (3,3)\\rightarrow (3,4)\\), you can pick up three coins at \\((2,1),(2,3),(3,3)\\).\n\nSample Input 2:\n```\n2 2 2\n2 1\n1 2\n```\n\nSample Output 2:\n```\n1\nDR\n```\nThe path `RD` is also acceptable.\n\nSample Input 3:\n```\n10 15 8\n2 7\n2 9\n7 9\n10 3\n7 11\n8 12\n9 6\n8 1\n```\n\nSample Output 3:\n```\n5\nDRRRRRRRRDDDDDRRDRDDRRR\n```\n\nSolution:\n\n```\nHere is the cleaned editorial without excess content unrelated to the solution:\n\n---\n\nLet us call the coin that can be collected by passing through square \\((r,c)\\) simply coin \\((r,c)\\). Given \\(k\\) coins \\((r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)\\), one can determine if there is a path that can collect all the coins as follows:\n\nSort the coins in ascending order of \\((r,c)\\). Here, \\((r_i, c_i) < (r_j, c_j) \\Leftrightarrow (r_i < r_j) \\lor (r_i = r_j \\land c_i < c_j)\\). Let \\(((r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k))\\) be the resulting sequence. There exists a path that can collect all the given \\(k\\) coins if and only if \\(c'_1 \\leq c'_2 \\leq \\dots \\leq c'_k\\).\n\nProof: If two coins $i$ and $j$ with $(r_i, c_i) < (r_j, c_j)$ are to be collected, coin $i$ has to be collected first. Thus, the $k$ coins $(r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)$ can be all collected if and only if the $k$ coins $(r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k)$ can be collected **in this order**. Given $(r_i, c_i) < (r_j, c_j)$, we have $(r_i \\leq r_j \\land c_i \\leq c_j) \\Leftrightarrow c_i \\leq c_j$, so the claim above has been shown.\n\nSuppose that the given \\(N\\) coins are sorted in ascending order of \\((r,c)\\). Then, by the fact above, this problem is boiled down to finding a longest (weakly) increasing subsequence (LIS). Given positive integer sequence \\(c=(c_1,c_2,\\dots,c_N)\\), one can find the length of a LIS of \\(c\\) (not its length) by the following famous algorithm:\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\). The length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\).\n\nIntuitively, each \\(d_j\\) manages the smallest last element of a length-\\(j\\) (weakly) increasing subsequence of \\(c_1,c_2,\\dots,c_i\\) (or \\(\\infty\\) if there is no such subsequence). To find an example of LIS instead of its length only, let us modify the algorithm as follows.\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Prepare a length-\\(N\\) sequence \\(\\text{id}\\) and \\(\\text{pre}\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\), and replace \\(\\text{id}_j\\) with \\(i\\). If \\(j > 1\\), replace \\(\\text{pre}_i\\) with \\(\\text{id}_{j-1}\\) too.\n\nThe length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\). Let \\(l\\) be the length of a LIS of \\(c\\). Consider a length-\\(l\\) sequence obtained by applying \\((l-1)\\) times the action \\(i\\mapsto \\text{pre}_i\\) to \\(\\text{id}_l\\), namely \\((\\text{id}_l, \\text{pre}_{\\text{id}_l},\\text{pre}_{\\text{pre}_{\\text{id}_l}},\\dots)\\). The reversal of this sequence is an example of a LIS of \\(c\\).\n\nThe fact that an example of LIS can be indeed obtained using this algorithm can be proved inductively. The complexity of this algorithm is \\(O(N\\log N)\\), same as the original algorithm. (To find the minimum \\(j\\) in step \\(3\\), use binary search.) Thus, the problem has been solved.\n\nSample code (Python3):\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    h, w, n = map(int, sys.stdin.readline().strip().split())\n    coins = []\n    for _ in range(n):\n        r, c = map(int, sys.stdin.readline().strip().split())\n        coins.append((r, c))\n    coins.sort()\n    dp = [float('inf')] * n\n    id_list = [-1] * n\n    pre = [0] * n\n    for i in range(n):\n        it = bisect_right(dp, coins[i][1])\n        dp[it] = coins[i][1]\n        id_list[it] = i\n        pre[i] = id_list[it - 1] if it else -1\n    m = n - 1\n    while id_list[m] == -1:\n        m -= 1\n    path = [(h, w)]\n    now = id_list[m]\n    while now != -1:\n        path.append(coins[now])\n        now = pre[now]\n    path.append((1, 1))\n    path.reverse()\n    s = []\n    for i in range(len(path) - 1):\n        d = path[i + 1][0] - path[i][0]\n        r = path[i + 1][1] - path[i][1]\n        s.append('D' * d + 'R' * r)\n    print(m + 1)\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc373_b", "abc371_b", "abc369_f"]}, "abc341_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a positive integer \\( N \\) and a sequence of \\( M \\) non-negative integers \\( A = (A_1, A_2, \\dots, A_M) \\).\n\nHere, all elements of \\( A \\) are distinct integers between \\( 0 \\) and \\( N-1 \\), inclusive.\n\nFind the number, modulo \\( 998244353 \\), of permutations \\( P \\) of \\( (0, 1, \\dots, N-1) \\) that satisfy the following condition:\n\nAfter initializing a sequence \\( B = (B_1, B_2, \\dots, B_N) \\) to \\( P \\), it is possible to make \\( B = A \\) by repeating the following operation some number of times:\n- Choose \\( l \\) and \\( r \\) such that \\( 1 \\leq l \\leq r \\leq |B| \\), and if \\( \\mathrm{mex}(\\{B_l, B_{l+1}, \\dots, B_r\\}) \\) is contained in \\( B \\), remove it from \\( B \\).\n\n**What is \\( \\mathrm{mex}(X) \\)?**\n\nFor a finite set \\( X \\) of non-negative integers, \\( \\mathrm{mex}(X) \\) is defined as the smallest non-negative integer that is not in \\( X \\).\n\n**Constraints:**\n- \\( 1 \\leq M \\leq N \\leq 500 \\)\n- \\( 0 \\leq A_i < N \\)\n- All elements of \\( A \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_1 A_2 \\cdots A_M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n4 2\n1 3\n```\n\n**Sample Output 1**\n\n```\n8\n```\n\nAfter initializing \\( B = (2, 1, 0, 3) \\), it is possible to make \\( B = A \\) using the following steps:\n- Choose \\( (l, r) = (2, 4) \\), remove \\( \\mathrm{mex}(\\{1, 0, 3\\}) = 2 \\) from \\( B \\), making \\( B = (1, 0, 3) \\).\n- Choose \\( (l, r) = (3, 3) \\), remove \\( \\mathrm{mex}(\\{3\\}) = 0 \\) from \\( B \\), making \\( B = (1, 3) \\).\n\nThus, \\( P = (2, 1, 0, 3) \\) satisfies the condition. There are eight permutations \\( P \\) that satisfy the condition, including the above, so print \\( 8 \\).\n\n**Sample Input 2**\n\n```\n4 4\n0 3 2 1\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\nOnly \\( P = (0, 3, 2, 1) \\) satisfies the condition.\n\n**Sample Input 3**\n\n```\n16 7\n9 2 4 0 1 6 7\n```\n\n**Sample Output 3**\n\n```\n3520\n```\n\n**Sample Input 4**\n\n```\n92 4\n1 67 16 7\n```\n\n**Sample Output 4**\n\n```\n726870122\n```\n\nFind the count modulo \\( 998244353 \\).\n\nSolution:\n\n```python\nMOD = 998244353\n\n# input etc\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = [-1] * N\nfor i in range(M):\n    B[A[i]] = i\n\n# init\ndp = [[0 for j in range(M + 1)] for i in range(M + 1)]\nn_dp = [[0 for j in range(M + 1)] for i in range(M + 1)]\n\n# 0 in A\nif B[0] != -1:\n    dp[B[0]][M - 1 - B[0]] = 1\n\n# 0 not in A\nelse:\n    for i in range(M + 1):\n        dp[i][M - i] = 1\n\n# dp\nfor i in range(1, N):\n    # i in A\n    if B[i] != -1:\n        for l in range(M + 1):\n            for r in range(M + 1 - l):\n                a = min(l, B[i])\n                b = min(r, M - 1 - B[i])\n                if a != l or b != r:\n                    dp[a][b] = (dp[a][b] + dp[l][r]) % MOD\n                    dp[l][r] = 0\n    \n    # i not in A\n    else:\n        # copy dp\n        for l in range(M + 1):\n            for r in range(M + 1 - l):\n                n_dp[l][r] = dp[l][r]\n        for l in range(M, -1, -1):\n            for r in range(M - l, -1, -1):\n                if l != M:\n                    dp[l][r] = (dp[l][r] + dp[l + 1][r]) % MOD\n                if r != M:\n                    n_dp[l][r] = (n_dp[l][r] + n_dp[l][r + 1]) % MOD\n\n        # add\n        for l in range(M + 1):\n            for r in range(M + 1 - l):\n                dp[l][r] = (dp[l][r] + n_dp[l][r]) % MOD\n\n# output\nprint(dp[0][0])\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nTakahashi has various colors of socks in his chest of drawers. The colors of the socks are represented by integers from 1 to N, and there are \\( A_i (\\geq 2) \\) socks of color \\( i \\).\n\nHe is about to choose which socks to wear today by performing the following operation:\n\n- Continue to randomly draw one sock at a time from the chest, with equal probability, until he can make a pair of socks of the same color from those he has already drawn. Once a sock is drawn, it will not be returned to the chest.\n\nFind the expected value, modulo 998244353, of the number of times he has to draw a sock from the chest.\n\nIt can be proved that the sought expected value is always rational. Furthermore, the constraints of this problem guarantee that if the expected value is expressed as an irreducible fraction \\( \\frac{y}{x} \\), then \\( x \\) is not divisible by 998244353. Here, there exists a unique integer \\( z \\) between 0 and 998244352, inclusive, such that \\( xz \\equiv y \\pmod{998244353} \\). Find this \\( z \\).\n\n**Constraints:**\n\n- \\(1 \\leq N \\leq 3 \\times 10^5\\)\n- \\(2 \\leq A_i \\leq 3000\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n```\n2\n2 2\n```\n\n**Sample Output 1:**\n```\n665496238\n```\n\nFor example, the operation could be performed as follows:\n1. Draw a sock of color 1 from the chest. There remains one sock of color 1 and two socks of color 2 in the chest.\n2. Draw a sock of color 2 from the chest. There remains one sock each of colors 1 and 2 in the chest.\n3. Draw a sock of color 1 from the chest. The socks drawn so far are two of color 1 and one of color 2, allowing a pair of color 1 socks to be made, thus ending the operation.\n\nIn this example, Takahashi draws a sock from the chest three times. The expected number of times Takahashi draws a sock from the chest is 3 with probability \\( \\frac{2}{3} \\) and 2 with probability \\( \\frac{1}{3} \\), so the expected value is \\( 3 \\times \\frac{2}{3} + 2 \\times \\frac{1}{3} = \\frac{8}{3} \\equiv 665496238 \\pmod{998244353} \\).\n\n**Sample Input 2:**\n```\n1\n352\n```\n\n**Sample Output 2:**\n```\n2\n```\n\n**Sample Input 3:**\n```\n6\n1796 905 2768 253 2713 1448\n```\n\n**Sample Output 3:**\n```\n887165507\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial content without extraneous information:\n\n---\n\nLet \\(S = A_1 + A_2 + \\dots + A_N\\). By the Pigeonhole Theorem, Takahashi draws a sock at most \\(N+1\\) times. Let \\(P_i\\) be the probability that he draws a sock at least \\(i\\) times. The expected value is \\(P_1 + P_2 + \\dots + P_{N+1}\\).\n\nLet \\(Q_i\\) be the probability that he draws a sock exactly \\(i\\) times. The expected value is \\(1 \\cdot Q_1 + 2 \\cdot Q_2 + \\dots + (N+1) \\cdot Q_{N+1}\\). Using \\(Q_i = P_i - P_{i+1}\\), this can be rewritten as \\(P_1 + P_2 + \\dots + P_{N+1}\\).\n\n\\(P_{i+1}\\) is equivalent to the probability that there is no duplicating color after drawing \\(i\\) socks. Denote \\(f_i\\) as the number of ways to choose \\(i\\) socks with different colors among the \\(S\\) socks: \\(P_{i+1} = \\frac{f_i}{\\binom{S}{i}}\\). Finding \\(\\binom{S}{0}, \\binom{S}{1}, \\dots, \\binom{S}{N}\\) is trivial, so the task is to find \\(f_i\\).\n\nDefine a polynomial \\(F = \\sum_{i=0}^{S} f_i x^i\\). Since \\(f_i = \\sum_{1 \\leq k_1 < k_2 < \\dots < k_i \\leq N} \\prod_{l=1}^{i} A_{k_l}\\), \\(F\\) is the total product of \\(F_1, F_2, \\dots, F_N\\), where \\(F_i = (1 + A_i x)\\). The problem reduces to:\n\nGiven \\(N\\) linear polynomials, find their product.\n\nThis can be solved with a divide-and-conquer algorithm in \\(O(N\\log^2 N)\\) time. Specifically, define \\(f(l,r)\\) as the product of \\(F_l, F_{l+1}, \\dots, F_{r-1}\\), and apply \\(f(l,r) = f(l,m) \\times f(m,r)\\ (m = \\lfloor\\frac{l+r}{2}\\rfloor)\\) to evaluate it recursively. Using the NTT (Number-Theoretic Transform), the complexity is \\(O(N\\log^2 N)\\).\n\nSample code (Python):\n\n```python\nfrom atcoder.convolution import convolution\nfrom atcoder.modint import ModInt998244353 as mint\n\ndef prod(a, l, r):\n    if r - l == 1:\n        return [mint(1), mint(a[l])]\n    m = (l + r) // 2\n    return convolution(prod(a, l, m), prod(a, m, r))\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a)\n    f = prod(a, 0, n)\n    ans = mint(0)\n    sCi = mint(1)\n    for i in range(n + 1):\n        ans += f[i] / sCi\n        sCi *= s - i\n        sCi /= i + 1\n    print(ans.val())\n\nmain()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\).\nAnswer the following \\( Q \\) queries.\n\nFor the \\( i \\)-th query, you are given integers \\( L_i \\) and \\( R_i \\).\nSolve the following problem for \\( B = (A_{L_i}, A_{L_{i}+1}, \\cdots, A_{R_i}) \\).\n\nDivide \\( B \\) into three non-empty contiguous subsequences. For each contiguous subsequence, find the maximum value of its elements. The task is to find the minimum possible sum of these maximum values.\n\nIt is guaranteed that the length of \\( B \\) is at least 3, so there is always at least one way to divide it into three non-empty contiguous subsequences.\n\n### Constraints\n\n- \\( 3 \\leq N \\leq 250000 \\)\n- \\( 1 \\leq Q \\leq 250000 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- \\( 1 \\leq L_i \\leq R_i \\leq N \\)\n- \\( R_i - L_i \\geq 2 \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from standard input in the following format:\n```\nN Q\nA_1 A_2 \\ldots A_N\nL_1 R_1\nL_2 R_2\n\u22ee\nL_Q R_Q\n```\n\n### Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n### Sample Input 1\n```\n7 5\n4 3 1 1 4 5 2\n1 7\n2 4\n3 5\n1 5\n4 7\n```\n\n### Sample Output 1\n```\n10\n5\n6\n9\n8\n```\n\nExplanation for the first query: We have \\( B = (4, 3, 1, 1, 4, 5, 2) \\). If you divide it into \\( (4, 3), (1, 1), (4, 5, 2) \\), the maximum values of the contiguous subsequences are 4, 1, and 5 respectively, and their sum is 10. There is no way to make this sum smaller, so the answer to this query is 10.\n\n### Sample Input 2\n```\n10 15\n8 3 8 10 1 5 3 1 6 4\n4 6\n2 5\n6 9\n8 10\n2 9\n4 10\n1 5\n1 8\n1 3\n4 8\n1 10\n2 10\n6 10\n2 6\n2 6\n```\n\n### Sample Output 2\n```\n16\n14\n12\n11\n17\n17\n19\n14\n19\n14\n17\n17\n12\n16\n16\n```\n\n\nSolution:\n\n        [BEGIN TEXT]\n        First, consider the case with one query. Suppose the input is \\(B=(B_1,\\cdots,B_N)\\). Let \\(B_m=\\max(B)\\). When decomposing \\(B\\) into \\(XYZ\\), consider the scenarios based on where \\(B_m\\) is included among \\(X, Y, Z\\). If \\(B_m\\) is in \\(Y\\), \\(\\max(Y)\\) is \\(B_m\\), so make \\(Y\\) larger: \\(X=(B_1), Y=(B_2,\\cdots,B_{N-1}), Z=(B_N)\\). If \\(B_m\\) is in \\(X\\), assume \\(Y\\) has one element. Try all possible positions for \\(Y\\) to calculate the answer. If \\(B_m\\) is in \\(Z\\), reverse the sequence to solve it similarly. For multiple queries, if \\(B_m\\) is in \\(Y\\), handle it with a simple RMQ. When \\(B_m\\) is in \\(X\\), use two main approaches: manage \\(\\max(Z)\\) for each \\(Y\\) by processing queries in ascending order of \\(R_i\\) with a segment tree for range addition and range minimum query or manage \\(Y\\) for each \\(\\max(Z)\\) with a stack and a segment tree for range minimum query. Using either approach, the time complexity is \\(O((N+Q) \\log N)\\).\n        [END TEXT]\n \n\n", "problem_ids": ["arc178_d", "abc352_g", "arc180_d"]}, "abc342_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 100 points\n\n## Problem Statement\n\nTakahashi came to a store to buy a pen. There are three types of pens available:\n- A red pen costs `R` yen.\n- A green pen costs `G` yen.\n- A blue pen costs `B` yen.\n\nHowever, Takahashi dislikes the color `C`. This means:\n- If `C` is `Red`, he cannot buy a red pen.\n- If `C` is `Green`, he cannot buy a green pen.\n- If `C` is `Blue`, he cannot buy a blue pen.\n\nDetermine the minimum amount of money he needs to spend to buy one pen.\n\n## Constraints\n\n- \\(1 \\leq R, G, B \\leq 100\\)\n- `R`, `G`, and `B` are integers.\n- `C` is either `Red`, `Green`, or `Blue`.\n\n## Input\n\nThe input is given in the following format:\n\n```\nR G B\nC\n```\n\n## Output\n\nIf the minimum amount of money Takahashi needs to buy one pen is `X` yen, print `X`.\n\n## Sample Input 1\n\n```\n20 30 10\nBlue\n```\n\n## Sample Output 1\n\n```\n20\n```\n\nA red pen costs 20 yen, a green pen costs 30 yen, and a blue pen costs 10 yen. Takahashi cannot buy a blue pen, but he can buy a red pen for 20 yen.\n\n## Sample Input 2\n\n```\n100 100 100\nRed\n```\n\n## Sample Output 2\n\n```\n100\n```\n\n## Sample Input 3\n\n```\n37 39 93\nBlue\n```\n\n## Sample Output 3\n\n```\n37\n```\n\nSolution:\n\n```python\nR, G, B = map(int, input().split())\nC = input()\nif C == \"Red\":\n    print(min(G, B))\nif C == \"Green\":\n    print(min(B, R))\nif C == \"Blue\":\n    print(min(R, G))\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a permutation \\( P = (P_1, P_2, \\dots, P_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nA sequence of indices \\((i_1, i_2, \\dots, i_K)\\) of length \\( K \\) is called a **good index sequence** if it satisfies both of the following conditions:\n\n1. \\(1 \\leq i_1 < i_2 < \\dots < i_K \\leq N\\).\n2. The subsequence \\((P_{i_1}, P_{i_2}, \\dots, P_{i_K})\\) can be obtained by rearranging some consecutive \\( K \\) integers. Formally, there exists an integer \\( a \\) such that \\(\\{ P_{i_1}, P_{i_2}, \\dots, P_{i_K} \\} = \\{ a, a+1, \\dots, a+K-1 \\}\\).\n\nFind the minimum value of \\( i_K - i_1 \\) among all good index sequences. It can be shown that at least one good index sequence exists under the constraints of this problem.\n\n**Constraints**\n\n- \\(1 \\leq K \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq P_i \\leq N\\)\n- \\(P_i \\neq P_j\\) if \\(i \\neq j\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n**Output**\n\nPrint the minimum value of \\( i_K - i_1 \\) among all good index sequences.\n\n**Sample Input 1**\n\n```\n4 2\n2 3 1 4\n```\n\n**Sample Output 1**\n\n```\n1\n```\n\nThe good index sequences are \\((1, 2), (1, 3), (2, 4)\\). For example, \\((i_1, i_2) = (1, 3)\\) is a good index sequence because \\(1 \\leq i_1 < i_2 \\leq N\\) and \\((P_{i_1}, P_{i_2}) = (2, 1)\\) is a rearrangement of two consecutive integers 1, 2. Among these good index sequences, the smallest value of \\( i_K - i_1 \\) is for \\((1, 2)\\), which is \\(2-1=1\\).\n\n**Sample Input 2**\n\n```\n4 1\n2 3 1 4\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n\\(i_K - i_1 = i_1 - i_1 = 0\\) in all good index sequences.\n\n**Sample Input 3**\n\n```\n10 5\n10 1 6 8 7 2 5 9 3 4\n```\n\n**Sample Output 3**\n\n```\n5\n```\n\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 352\n\n# D - Permutation Subsequence Editorial, by en_translator\n\n# We will exhaustively enumerate the value \\(a\\) in the problem statement. For each \\(a=1,2,\\dots,N-K+1\\), \n# we will find the minimum \\(i_K-i_1\\) when choosing \\(i_1 < i_2 < \\dots < i_K\\) so that \n# \\(\\{P_{i_1},P_{i_2},\\dots,P_{i_K}\\}=\\{a,a+1,\\dots,a+K-1\\}\\).\n\n# Define \\(Q=(Q_1,Q_2,\\dots,Q_N)\\) by \\(Q_j=(\\) the value \\(i\\) such that \\(P_i=j)\\). \n# When \\(P\\) is a permutation of \\((1,2,\\dots,N)\\), so is \\(Q\\). \n# The objective can be rephrased as the difference between the maximum and minimum values among \\(Q_a,Q_{a+1},\\dots,Q_{a+K-1}\\).\n\n# Evaluate this value while iterating \\(a\\) in ascending order. The set \\(\\{Q_a,Q_{a+1},\\dots,Q_{a+K-1}\\}\\) changes by one element \n# as \\(a\\) increases by one. We need a data structure \\(D\\) that manages a set and supports:\n\n# - Insert one element into \\(D\\).\n# - Remove one element from \\(D\\).\n# - Retrieve the minimum and maximum element of \\(D\\).\n\n# A balanced binary search tree like `std::set` in C++ fulfills these requirements. For implementation using `std::set`,\n# see the sample code below. For other languages, refer to their documentation.\n\n# Sample code (Python3):\nfrom sortedcontainers import SortedSet\n\ndef main():\n    n, k = map(int, input().split())\n    q = [0] * n\n    for i in range(n):\n        p = int(input().strip())\n        p -= 1\n        q[p] = i\n    \n    st = SortedSet()\n    for i in range(k):\n        st.add(q[i])\n    \n    ans = st[-1] - st[0]\n    for i in range(k, n):\n        st.remove(q[i - k])\n        st.add(q[i])\n        ans = min(ans, st[-1] - st[0])\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\n", "problem_ids": ["abc362_a", "abc352_d", "abc368_c"]}, "abc342_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) giants, each identified by an integer from 1 to \\( N \\). For each giant \\( i \\), when they stand on the ground, their shoulder height is \\( A_i \\) and their head height is \\( B_i \\).\n\nYou can arrange all the giants in a permutation \\( (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) and stack them one on top of another according to the following rules:\n\n1. Place giant \\( P_1 \\) on the ground. The shoulder height of giant \\( P_1 \\) from the ground is \\( A_{P_1} \\), and the head height is \\( B_{P_1} \\).\n2. Following this, for \\( i = 1, 2, \\ldots, N - 1 \\), place giant \\( P_{i+1} \\) on the shoulders of giant \\( P_i \\). If the shoulder height of giant \\( P_i \\) from the ground is \\( t \\), then the shoulder height of giant \\( P_{i+1} \\) from the ground is \\( t + A_{P_{i+1}} \\), and the head height is \\( t + B_{P_{i+1}} \\).\n\nThe goal is to determine the maximum possible head height from the ground of the topmost giant \\( P_N \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 200,000 \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq 1,000,000,000 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output:**\n\nPrint the maximum possible height of the head of the topmost giant from the ground.\n\n**Sample Input 1:**\n```\n3\n4 10\n5 8\n2 9\n```\n\n**Sample Output 1:**\n```\n18\n```\n\n*Explanation:* If the permutation \\( (P_1, P_2, P_3) = (2, 1, 3) \\) is chosen, the heights measured from the ground would be as follows:\n\n- Giant 2 will have a shoulder height of 5 and a head height of 8.\n- Giant 1 will be on top, having a shoulder height of 9 and a head height of 15.\n- Giant 3 will be on top, having a shoulder height of 11 and a head height of 18.\n\nThe maximum head height achievable with any arrangement of the giants is 18, and thus, 18 is printed.\n\n**Sample Input 2:**\n```\n5\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\n**Sample Output 2:**\n```\n5\n```\n\n**Sample Input 3:**\n```\n10\n690830957 868532399\n741145463 930111470\n612846445 948344128\n540375785 925723427\n723092548 925021315\n928915367 973970164\n563314352 832796216\n562681294 868338948\n923012648 954764623\n691107436 891127278\n```\n\n**Sample Output 3:**\n```\n7362669937\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\nThe height of the topmost giant\u2019s head when \\(P_N\\), i.e., when giant \\(i\\) is the topmost giant, is \\(B_i + \\sum_{j \\neq i}A_j\\). This can be expressed as \\(B_i - A_i + \\sum_{j = 1}^{N} A_j\\), and the answer is the maximum of this value for \\(i = 1, 2, \\ldots, N\\). Since \\(\\sum_{j = 1}^{N} A_j\\) is independent of \\(i\\), it is sufficient to find \\(\\max (B_i - A_i)\\). This can be computed using a for loop in a total of \\(O(N)\\) time.\n\nSample code:\n```python\nn = int(input())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nm = 0\nfor i in range(n):\n    m = max(m, b[i] - a[i])\nans = m + sum(a)\nprint(ans)\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n## Problem Statement\n\nIn the AtCoder World Tour Finals 2800, `N` contestants participated, and a total of five problems were presented. Each problem is assigned an integer score of at least 1 point, and the problems are numbered so that the scores are non-decreasing from problem 1 to problem 5. There are no partial points. Similar to the usual AtCoder rules, ranking is done as follows: The contestant with the higher total score ranks higher. In case of a tie, the one with the smaller penalty ranks higher. In this problem, we do not consider the situation where multiple contestants have the same total score and penalty.\n\nAoki, a reporter covering the finals, noted the following information:\n1. The number of participants `N`.\n2. Which problems each contestant solved. `A[i, j] = 1` means the `i`-th contestant (1 \u2264 `i` \u2264 `N`) correctly solved problem `j`, and `A[i, j] = 0` means they did not.\n3. The rank of each contestant. The `i`-th contestant (1 \u2264 `i` \u2264 `N`) was ranked `R[i]`-th.\n\nHowever, when he started writing the article, he realized he did not note the scores and penalties. Furthermore, he realized there might be inconsistencies in the information he noted. Now, solve the following problem:\n\nAssume that he correctly noted information 1 and 2. Let `D[i]` be the actual rank of contestant `i` (1 \u2264 `i` \u2264 `N`), and find the minimum possible total squared error `(D[1] - R[1])^2 + (D[2] - R[2])^2 + ... + (D[N] - R[N])^2`.\n\nYou have `T` test cases to process.\n\n## Constraints\n- `1 \u2264 T \u2264 10^5`\n- `2 \u2264 N \u2264 3 \u00d7 10^5`\n- Each `A[i,1], A[i,2], A[i,3], A[i,4], A[i,5]` is 0 or 1 (1 \u2264 `i` \u2264 `N`).\n- The sum of `A[i,1], A[i,2], A[i,3], A[i,4], A[i,5]` is at least 1 (1 \u2264 `i` \u2264 `N`).\n- `1 \u2264 R[i] \u2264 N` (1 \u2264 `i` \u2264 `N`)\n- `R[1], R[2], ..., R[N]` are distinct.\n- The total value of `N` across all test cases is at most 3 \u00d7 10^5.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format. Here `case_i` represents the `i`-th test case (1 \u2264 `i` \u2264 `T`).\n\n```\nT\ncase_1\ncase_2\n...\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA[1,1] A[1,2] A[1,3] A[1,4] A[1,5]\nA[2,1] A[2,2] A[2,3] A[2,4] A[2,5]\n...\nA[N,1] A[N,2] A[N,3] A[N,4] A[N,5]\nR[1] R[2] ... R[N]\n```\n\n## Output\n\nPrint the answers.\n\n## Sample Input 1\n\n```\n6\n4\n0 1 1 0 0\n1 0 0 1 0\n1 1 0 1 0\n1 0 1 0 0\n1 2 3 4\n8\n0 1 0 0 0\n1 1 0 1 0\n0 1 1 0 1\n1 0 0 0 0\n1 1 0 1 0\n0 1 0 0 0\n0 0 0 1 0\n0 1 1 1 1\n7 4 2 8 3 6 5 1\n6\n1 1 0 0 0\n0 0 1 0 0\n1 1 1 0 0\n0 0 0 1 0\n1 1 1 1 0\n0 0 0 0 1\n1 2 3 4 5 6\n6\n1 1 0 0 0\n0 0 1 0 0\n1 1 1 0 0\n0 0 0 1 0\n1 1 1 1 0\n0 0 0 0 1\n6 5 4 3 2 1\n20\n0 0 0 0 1\n0 0 1 0 0\n1 1 0 0 1\n1 0 1 0 1\n0 0 0 1 1\n0 0 1 1 1\n1 1 1 1 0\n1 1 0 1 0\n0 0 1 1 0\n1 0 1 0 0\n0 1 0 0 1\n0 1 1 1 1\n1 1 1 1 1\n0 1 0 1 0\n1 0 0 0 1\n1 1 1 0 0\n0 1 1 1 0\n0 0 0 1 0\n1 1 1 0 1\n1 1 0 1 1\n7 18 3 5 19 11 13 2 4 10 14 15 17 6 16 9 8 12 1 20\n15\n0 0 1 1 0\n0 0 0 1 0\n0 0 0 0 1\n0 0 1 1 1\n1 1 0 0 1\n0 1 1 1 0\n1 1 1 1 1\n0 1 1 0 1\n1 1 0 1 0\n1 0 0 1 1\n1 0 1 0 0\n1 1 0 1 1\n0 1 0 1 0\n1 1 0 0 0\n0 1 0 0 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n```\n\n## Sample Output 1\n\n```\n6\n0\n26\n0\n1054\n428\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - AtCoder Regular Contest 177\n\nSolution to the problem:\nThere are only \\(113\\) scoring distributions for the contest that need to be considered. Once the scoring distribution is determined, arranging the penalties so that the smaller \\(R_i\\) values correspond to smaller penalties (within ties) will always minimize the squared error. Using something like `sorted`, the solution can be obtained in approximately \\(113N \\log N\\) computations.\n\nExample Scoring Distributions:\n- [1, 1, 1, 1, 1]\n- [1, 1, 1, 1, 2]\n... \n- [4, 5, 6, 7, 8]\n\nSteps to the solution:\n1. Consider scoring distributions based on problem-solving instances and ensure scores are non-decreasing.\n2. Extend the approach to contests with 5 problems, considering intersection points of hyperplanes in a 5-dimensional space.\n3. Prune duplicates and non-eligible scoring distributions, reducing the number of distributions to \\(113\\), allowing timely computations for input constraints.\n\nSample Implementation (Python):\n```python\n# Sample scoring distributions candidates\nCandidates = [ /* List of scoring distributions */ ]\n\ndef get_error(N, A, R, Score):\n    Sorted = []\n    for i in range(N):\n        sum_scores = sum(A[i][j] * Score[j] for j in range(5))\n        Sorted.append((sum_scores, -R[i]))\n    Sorted.sort(reverse=True)\n\n    error = 0\n    for i in range(N):\n        idx1 = -Sorted[i][1]\n        idx2 = i + 1\n        error += (idx1 - idx2) * (idx1 - idx2)\n    return error\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = [list(map(int, input().split())) for _ in range(N)]\n        R = list(map(int, input().split()))\n\n        answer = float('inf')\n        for cand in Candidates:\n            result = get_error(N, A, R, cand)\n            answer = min(answer, result)\n        print(answer)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis concise edit provides essential problem-solving steps, example scoring distributions, and the complete Python implementation code without unnecessary information.\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nYou are given a string \\( S \\) consisting of lowercase and uppercase English letters. The length of \\( S \\) is odd. If the number of uppercase letters in \\( S \\) is greater than the number of lowercase letters, convert all lowercase letters in \\( S \\) to uppercase. Otherwise, convert all uppercase letters in \\( S \\) to lowercase.\n\nConstraints:\n- \\( S \\) is a string consisting of lowercase and uppercase English letters.\n- The length of \\( S \\) is an odd number between 1 and 99, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n\\( S \\)\n\nOutput:\nPrint the string \\( S \\) after converting the letters according to the problem statement.\n\nSample Input 1:\n```\nAtCoder\n```\n\nSample Output 1:\n```\natcoder\n```\nThe string `AtCoder` contains five lowercase letters and two uppercase letters. Thus, convert all uppercase letters in `AtCoder` to lowercase, which results in `atcoder`.\n\nSample Input 2:\n```\nSunTORY\n```\n\nSample Output 2:\n```\nSUNTORY\n```\nThe string `SunTORY` contains two lowercase letters and five uppercase letters. Thus, convert all lowercase letters in `SunTORY` to uppercase, which results in `SUNTORY`.\n\nSample Input 3:\n```\na\n```\n\nSample Output 3:\n```\na\n```\n\nSolution:\n\n        Here is the text:\n\n        [BEGIN TEXT]\n        Here is a succinct version of the editorial content relevant to the solution:\n\nThis problem requires processing strings by counting the occurrences of lowercase and uppercase letters in \\(S\\), and comparing them. If the number of lowercase letters is fewer, convert all uppercase letters to lowercase. Otherwise, convert all lowercase letters to uppercase. Most programming languages have functions for handling letter cases, such as:\n\n- `islower(c)`: checks if `c` is lowercase.\n- `isupper(c)`: checks if `c` is uppercase.\n- `tolower(c)`: converts `c` to lowercase.\n- `toupper(c)`: converts `c` to uppercase.\n\nThese functions can be used to implement the solution efficiently with a complexity of \\(\\mathrm{O}(|S|)\\).\n\nSample code (Python 3):\n\n```python\ndef process_string(S):\n    lower = sum(1 for c in S if c.islower())\n    upper = sum(1 for c in S if c.isupper())\n\n    if lower < upper:\n        S = ''.join(c.upper() for c in S)\n    else:\n        S = ''.join(c.lower() for c in S)\n\n    return S\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(process_string(S))\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc352_c", "arc177_e", "abc357_b"]}, "abc342_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\) and a sequence \\( B = (B_1, B_2, \\dots, B_M) \\) of length \\( M \\). Here, all elements of \\( A \\) and \\( B \\) are pairwise distinct. Determine whether the sequence \\( C = (C_1, C_2, \\dots, C_{N+M}) \\) formed by sorting all elements of \\( A \\) and \\( B \\) in ascending order contains two consecutive elements appearing in \\( A \\).\n\n**Constraints**\n\n- \\( 1 \\leq N, M \\leq 100 \\)\n- \\( 1 \\leq A_i, B_j \\leq 200 \\)\n- \\( A_1, A_2, \\dots, A_N, B_1, B_2, \\dots, B_M \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\nA_1 A_2 \\dots A_N\nB_1 B_2 \\dots B_M\n```\n\n**Output**\n\nIf \\( C \\) contains two consecutive elements appearing in \\( A \\), print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n\n```\n3 2\n3 2 5\n4 1\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\n\\( C = (1, 2, 3, 4, 5) \\). Since \\( 2 \\) and \\( 3 \\) from \\( A \\) occur consecutively in \\( C \\), print `Yes`.\n\n**Sample Input 2**\n\n```\n3 2\n3 1 5\n4 2\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\n\\( C = (1, 2, 3, 4, 5) \\). Since no two elements from \\( A \\) occur consecutively in \\( C \\), print `No`.\n\n**Sample Input 3**\n\n```\n1 1\n1\n2\n```\n\n**Sample Output 3**\n\n```\nNo\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 355 (B - Piano 2)\n\nThis problem asks to rearrange elements in a sequence in a specific order, which is called sorting\u2014a standard feature in most languages. For example, Python and C++ both provide a function named sort. To solve the problem, concatenate lists \\(A\\) and \\(B\\) to define \\(C\\), sort \\(C\\), inspect the elements of \\(C\\), and check if adjacent elements are both contained in \\(A\\).\n\nIn Python, use the `in` operator, and in C++, use the set operator to check element containment.\n\nSample code (Python):\n\n```python\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = A + B\nC.sort()\nfor i in range(N + M - 1):\n    if C[i] in A and C[i + 1] in A:\n        print(\"Yes\")\n        exit()\nprint(\"No\")\n```\n\nSample code (C++):\n\n```python\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nC = A[:]\nC.extend(B)\nC.sort()\n\nst = set(A)\n\nfor i in range(N + M - 1):\n    if C[i] in st and C[i + 1] in st:\n        print(\"Yes\")\n        exit()\nprint(\"No\")\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices. The vertices are numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge (\\( 1 \\leq i \\leq N-1 \\)) connects vertices \\( U_i \\) and \\( V_i \\), with a length of \\( L_i \\).\n\nFor each \\( K = 1, 2, \\ldots, N \\), solve the following problem.\n\nTakahashi and Aoki play a game. The game proceeds as follows:\n\n1. First, Aoki specifies \\( K \\) distinct vertices on the tree.\n2. Then, Takahashi constructs a walk that starts and ends at vertex 1, and passes through all the vertices specified by Aoki.\n\nThe score is defined as the length of the walk constructed by Takahashi. Takahashi wants to minimize the score, while Aoki wants to maximize it. Find the score when both players play optimally.\n\n**Definition of a walk:**\nA walk on an undirected graph (possibly a tree) is a sequence of \\( k \\) vertices and \\( k-1 \\) edges \\( v_1, e_1, v_2, \\ldots, v_{k-1}, e_{k-1}, v_k \\) (where \\( k \\) is a positive integer) such that edge \\( e_i \\) connects vertices \\( v_i \\) and \\( v_{i+1} \\). The same vertex or edge can appear multiple times in the sequence. A walk is said to pass through vertex \\( x \\) if there exists at least one \\( i \\) (\\( 1 \\leq i \\leq k \\)) such that \\( v_i = x \\). (There can be multiple such \\( i \\).) The walk is said to start and end at \\( v_1 \\) and \\( v_k \\), respectively, and the length of the walk is the sum of the lengths of \\( e_1, e_2, \\ldots, e_{k-1} \\).\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq L_i \\leq 10^9 \\)\n- All input values are integers.\n- The given graph is a tree.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nU_1 V_1 L_1\nU_2 V_2 L_2\n...\nU_{N-1} V_{N-1} L_{N-1}\n```\n\n**Output:**\nPrint \\( N \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq N \\)) should contain the answer to the problem for \\( K = i \\).\n\n**Sample Input 1:**\n```\n5\n1 2 3\n2 3 5\n2 4 2\n1 5 3\n```\n\n**Sample Output 1:**\n```\n16\n22\n26\n26\n26\n```\n\nFor \\( K=1 \\), Aoki's optimal move is to specify vertex 3, and Takahashi's optimal move is to construct a path vertex 1 \u2192 vertex 2 \u2192 vertex 3 \u2192 vertex 2 \u2192 vertex 1, resulting in a score of 16.\n\nFor \\( K=2 \\), Aoki's optimal move is to specify vertices 3 and 5, and Takahashi's optimal move is to construct a path such as vertex 1 \u2192 vertex 5 \u2192 vertex 1 \u2192 vertex 2 \u2192 vertex 3 \u2192 vertex 2 \u2192 vertex 1, resulting in a score of 22.\n\nFor \\( K \\geq 3 \\), the score when both players play optimally is 26.\n\n**Sample Input 2:**\n```\n3\n1 2 1000000000\n2 3 1000000000\n```\n\n**Sample Output 2:**\n```\n4000000000\n4000000000\n4000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n---\n\nWe will regard the given tree as a rooted tree rooted at \\(1\\). We first consider Takahashi\u2019s strategy. For any edge on the tree, when the tree is split into two parts by the edge, if Aoki has chosen at least one vertex in the part not containing vertex \\(1\\), then Takahashi has to construct a walk that passes through that edge at least twice (back and forth). Conversely, he can construct the shortest such walk, which passes through such edges exactly twice but not the others. It can be constructed as, for example, an Euler tour on the tree obtained by removing unnecessary edges. Based on this fact, we will try to solve the problem with tree DP (Dynamic Programming).\n\nFor each subtree \\(T_v\\) rooted at vertex \\(v\\), let us try to find \\((S_v(1), S_v(2), \\ldots, S_v(T_v))\\), defined as the minimum scores for \\(K=1,2,\\ldots,|T_v|\\) when they play optimally on \\(T_v\\). Here, \\(|T_v|\\) denotes the number of vertices in \\(T_v\\).\n\nIf \\(T_u\\) consist of a single vertex, then \\(|T_u|=1\\) and \\(S_u(1)=0\\). Suppose that vertex \\(u\\) has \\(v_1,v_2,\\ldots,v_c\\) as its direct children, with the lengths of the edge between \\(u\\) and them being \\(d_1,d_2,\\ldots,d_c\\), respectively, and the scores are already known for \\(T_{v_i}\\) \\((1\\leq i\\leq c)\\). Then, noticing it is useless to choose \\(u\\) if \\(K<|T_u|\\), the scores \\(S(u,K)\\) \\((1\\leq K < |T_u|)\\) satisfy:\n\n\\[\nS(u,K)=\\max_{x_1+x_2+x_c=K}\\sum_{i=1}^c\n\\begin{cases}\n0 & (x_i=0) \\\\\n2d_i+S(v_i,x_i) & (1\\leq x_i\\leq |T_i|),\n\\end{cases}\n\\]\n\nwhere each \\(x_i\\) ranges over \\(0\\leq x_i\\leq |T_i|\\). Finally, \\(S(u,|T_u|)=S(u,|T_u|-1)\\).\n\nSince \\(S(v,x)\\leq S(v,x+1)\\) for any \\(v\\), this can be interpreted as the maximum sum of a total of \\(K\\) elements chosen from the leading elements of \\(c\\) sequences \\((2d_i+S(v_i,1),S(v_i,2)-S(v_i,1),\\ldots, S(v_i,|T_i|)-S(v_i,|T_i|-1) )\\). Moreover, assume that they satisfy \\(S(v_i,1)\\geq S(v_i,2)-S(v_i,1)\\) and \\(S(v_i,x)-S(v_i,x-1)\\geq S(v_i,x+1)-S(v_i,x)\\).\n\nIf we define a multiset \\(\\mathcal{S}\\) as:\n\n\\[\n\\mathcal{S}_u= \\left[\\bigcup_{i=1}^c \\{2d_i+S(v_i,1),S(v_i,2)-S(v_i,1),\\ldots, S(v_i,|T_i|)-S(v_i,|T_i|-1) \\}\\right]\\cup\\{0\\},\n\\]\n\nthen the elements sorted in descending order, \\((z_1,z_2,\\ldots,z_{|T_u|})\\), coincide with \\((S(u,1),S(u,2)-S(u,1),\\ldots, S(u,|T_u|)-S(u,|T_u|-1))\\). Then, we have \\(S(u,1)\\geq S(u,2)-S(u,1)\\) and \\(S(u,x)-S(u,x-1)\\geq S(u,x+1)-S(u,x)\\) for \\(u\\) too. Since it automatically holds for \\(|T_u|=1\\), this property inductively holds always, and thus can be computed like this.\n\nBased on this fact, we can compute it as follows: When processing a non-leaf vertex, compute \\(2d_i+S(v_i,1)\\) \\((1\\leq i\\leq c)\\) and store the maximum among them to \\(S(u,1)\\), and store the other \\((c-1)\\) values and one \\(0\\) into a multiset \\(\\mathcal{S}\\). \\(S(1,1)\\) is the last value stored, and \\(S(1,K)\\) is \\(S(1,1)\\) plus the sum of the largest \\((K-1)\\) elements of \\(\\mathcal{S}\\). The complexity is \\(O(N)\\), which is fast enough. Thus, the problem has been solved.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement**\n\nIn Japan, there are six types of coins in circulation: 1 yen, 5 yen, 10 yen, 50 yen, 100 yen, and 500 yen. Answer the following question regarding these coins.\n\nMr. AtCoder's wallet contains:\n- \\( A \\) 1-yen coins,\n- \\( B \\) 5-yen coins,\n- \\( C \\) 10-yen coins,\n- \\( D \\) 50-yen coins,\n- \\( E \\) 100-yen coins,\n- \\( F \\) 500-yen coins.\n\nHe plans to shop at \\( N \\) stores in sequence. Specifically, at the \\( i \\)-th store (\\( 1 \\leq i \\leq N \\)), he plans to buy one item that costs \\( X_i \\) yen (including tax).\n\nGiving and receiving change takes time, so he wants to choose his coins so that he can pay the **exact amount** at each store. Determine if this is possible.\n\n**Constraints**\n- \\( 0 \\leq A \\leq 200 \\)\n- \\( 0 \\leq B \\leq 200 \\)\n- \\( 0 \\leq C \\leq 200 \\)\n- \\( 0 \\leq D \\leq 200 \\)\n- \\( 0 \\leq E \\leq 200 \\)\n- \\( 0 \\leq F \\leq 200 \\)\n- \\( 1 \\leq N \\leq 10 \\)\n- \\( 1 \\leq X_i \\leq 10000 \\) (for each \\( i \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C D E F\nN\nX_1 X_2 ... X_N\n```\n\n**Output**\n\nPrint `Yes` if the objective is achievable, and `No` otherwise.\n\n**Sample Input 1**\n```\n0 0 6 3 4 1\n3\n700 250 160\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*For example, he can make exact payments at all three stores as follows:*\n- At the first store: Use two 100-yen coins and one 500-yen coin.\n- At the second store: Use five 10-yen coins and two 100-yen coins.\n- At the third store: Use one 10-yen coin and three 50-yen coins.\n\n**Sample Input 2**\n```\n0 0 0 2 4 0\n3\n100 200 300\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*The total amount in the wallet is 500 yen, but a total payment of 100+200+300=600 yen is required, making it impossible to purchase all the items.*\n\n**Sample Input 3**\n```\n0 0 0 0 8 8\n1\n250\n```\n\n**Sample Output 3**\n```\nNo\n```\n\n*There are no 50-yen or smaller coins in the wallet, so it's impossible to pay exactly 250 yen.*\n\n**Sample Input 4**\n```\n20 5 9 7 10 6\n5\n177 177 177 177 177\n```\n\n**Sample Output 4**\n```\nYes\n```\n\n**Sample Input 5**\n```\n17 5 9 7 10 6\n5\n177 177 177 177 177\n```\n\n**Sample Output 5**\n```\nNo\n```\n\n\nSolution:\n\n\n        Here's the cleaned version focused on the solution:\n\n---\n\nMr. AtCoder has \\(A\\) 1-yen coins and \\(C\\) 10-yen coins, and must shop at \\(N\\) stores, spending \\(X_1, \\dots, X_N\\) yen. The goal is to determine if it is possible to pay the exact amount at each store.\n\nWhen possible, use 10-yen coins first to conserve 1-yen coins. There's no benefit in saving higher-value coins when purchasing with lower-value coins.\n\nThe same strategy applies when dealing with all coin types: \\(1\\), \\(5\\), \\(10\\), \\(50\\), \\(100\\), and \\(500\\)-yen coins. Pay with higher denominations first, until the amount left can be paid with the smaller denominations available, simulating if exact payment is possible at all stores.\n\nSample Python Implementation:\n\n```python\na, b, c, d, e, f = map(int, input().split())\nn = int(input())\nx = list(map(int, input().split()))\n\nans = True\nfor v in x:\n    while v >= 500 and f >= 1:\n        v -= 500\n        f -= 1\n    while v >= 100 and e >= 1:\n        v -= 100\n        e -= 1\n    while v >= 50 and d >= 1:\n        v -= 50\n        d -= 1\n    while v >= 10 and c >= 1:\n        v -= 10\n        c -= 1\n    while v >= 5 and b >= 1:\n        v -= 5\n        b -= 1\n    while v >= 1 and a >= 1:\n        v -= 1\n        a -= 1\n    if v != 0:\n        ans = False\n        break\n\nprint('Yes' if ans else 'No')\n```\n\n---\n \n\n", "problem_ids": ["abc355_b", "abc369_g", "arc177_a"]}, "abc342_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n---\n\n**Problem Statement**\n\nYou are given permutations \\(P = (P_1, P_2, \\ldots, P_N)\\) and \\(A = (A_1, A_2, \\ldots, A_N)\\) of \\((1, 2, \\ldots, N)\\).\n\nYou can perform the following operation any number of times, possibly zero: replace \\(A_i\\) with \\(A_{P_i}\\) simultaneously for all \\(i = 1, 2, \\ldots, N\\).\n\nPrint the lexicographically smallest \\(A\\) that can be obtained.\n\n---\n\n**What is lexicographical order?**\n\nFor sequences of length \\(N\\), \\(A = (A_1, A_2, \\ldots, A_N)\\) and \\(B = (B_1, B_2, \\ldots, B_N)\\), \\(A\\) is lexicographically smaller than \\(B\\) if and only if there exists an integer \\(i\\) (1 \u2264 i \u2264 N) such that \\(A_i < B_i\\), and \\(A_j = B_j\\) for all \\(1 \\leq j < i\\).\n\n---\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n\n- \\(1 \\leq P_i \\leq N\\) (1 \u2264 i \u2264 N)\n\n- \\(P_i \\neq P_j\\) (1 \u2264 i < j \u2264 N)\n\n- \\(1 \\leq A_i \\leq N\\) (1 \u2264 i \u2264 N)\n\n- \\(A_i \\neq A_j\\) (1 \u2264 i < j \u2264 N)\n\nAll input values are integers.\n\n---\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nP_1 P_2 \\ldots P_N\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet \\( (A_1, A_2, \\ldots, A_N) \\) be the lexicographically smallest \\(A\\) that can be obtained. Print \\(A_1, A_2, \\ldots, A_N\\) in this order, separated by spaces, in one line.\n\n---\n\n**Sample Input 1**\n\n```\n6\n3 1 5 6 2 4\n4 3 1 6 2 5\n```\n\n**Sample Output 1**\n\n```\n1 4 2 5 3 6\n```\n\nInitially, \\(A = (4, 3, 1, 6, 2, 5)\\). Repeating the operation yields the following:\n- \\(A = (1, 4, 2, 5, 3, 6)\\)\n- \\(A = (2, 1, 3, 6, 4, 5)\\)\n- \\(A = (3, 2, 4, 5, 1, 6)\\)\n- \\(A = (4, 3, 1, 6, 2, 5)\\)\n\nAfter this, \\(A\\) will revert to the original state every four operations. Therefore, print the lexicographically smallest among these, which is `1 4 2 5 3 6`.\n\n---\n\n**Sample Input 2**\n\n```\n8\n3 5 8 7 2 6 1 4\n1 2 3 4 5 6 7 8\n```\n\n**Sample Output 2**\n\n```\n1 2 3 4 5 6 7 8\n```\n\nYou may choose to perform no operations.\n\n---\n\n**Sample Input 3**\n\n```\n26\n24 14 4 20 15 19 16 11 23 22 12 18 21 3 6 8 26 2 25 7 13 1 5 9 17 10\n15 3 10 1 13 19 22 24 20 4 14 23 7 26 25 18 11 6 9 12 2 21 5 16 8 17\n```\n\n**Sample Output 3**\n\n```\n4 1 22 18 20 13 14 6 15 11 3 26 2 12 5 23 9 10 25 24 7 17 16 21 19 8\n```\n\n\nSolution:\n\n```\nG - Lexicographically Smallest Permutation Editorial\n\nTo solve this problem, we consider minimizing elements sequentially, starting with the first. The key is to determine cycles in the permutation \\(P\\), and within each cycle, find the lexicographically smallest permutation. For a cycle with length \\(L\\), the number of minimal positions is \\(L / \\gcd(L, \\text{period})\\). We choose the minimal lexicographical arrangement by evaluating potential positions and adjusting the operation count \\(ans\\) accordingly. The process involves updating a result array based on minimized operations for each cycle, taking care of integer operations due to potential size. Here is the sample code:\n\n```python\nfrom math import gcd\n\nN = int(input())\nP = [int(x) - 1 for x in input().split()]\nA = list(map(int, input().split()))\n\nused = [False for i in range(N)]\n\nperiod = 1\nans = 0\n\nresult = [0 for i in range(N)]\n\nfor i in range(N):\n    if not used[i]:\n        cycle = [i]\n        while P[cycle[-1]] != i:\n            used[P[cycle[-1]]] = True\n            cycle.append(P[cycle[-1]])\n            \n        L = len(cycle)\n        choose = L // gcd(L, period)\n        offset = min((A[cycle[(ans + i * period) % L]], i) for i in range(choose))[1]\n        \n        ans += offset * period\n        period *= choose\n        \n        for i in range(L):\n            result[cycle[i]] = A[cycle[(i + ans) % L]]\n\nprint(*result)\n```\nThis effectively computes the lexicographically smallest permutation using the described method.\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nThere are \\(N+2\\) cells arranged in a row. Let cell \\(i\\) denote the \\(i\\)-th cell from the left.\n\nThere is one stone placed in each of the cells from cell \\(1\\) to cell \\(N\\).\n\nFor each \\(1 \\leq i \\leq N\\), the stone in cell \\(i\\) is white if \\(S_i\\) is 'W', and black if \\(S_i\\) is 'B'.\n\nCells \\(N+1\\) and \\(N+2\\) are empty.\n\nYou can perform the following operation any number of times (possibly zero):\n\n- Choose a pair of adjacent cells that both contain stones, and move these two stones to the empty two cells while preserving their order.\n\n  More precisely, choose an integer \\(x\\) such that \\(1 \\leq x \\leq N+1\\) and both cells \\(x\\) and \\(x+1\\) contain stones. Let \\(k\\) and \\(k+1\\) be the empty two cells. Move the stones from cells \\(x\\) and \\(x+1\\) to cells \\(k\\) and \\(k+1\\), respectively.\n\nDetermine if it is possible to achieve the following state, and if so, find the minimum number of operations required:\n\n- Each of the cells from cell \\(1\\) to cell \\(N\\) contains one stone, and for each \\(1 \\leq i \\leq N\\), the stone in cell \\(i\\) is white if \\(T_i\\) is 'W', and black if \\(T_i\\) is 'B'.\n\n**Constraints:**\n- \\(2 \\leq N \\leq 14\\)\n- \\(N\\) is an integer.\n- Each of \\(S\\) and \\(T\\) is a string of length \\(N\\) consisting of 'B' and 'W'.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\nT\n```\n\n**Output:**\n\nIf it is possible to achieve the desired state, print the minimum number of operations required. If it is impossible, print `-1`.\n\n**Sample Input 1:**\n```\n6\nBWBWBW\nWWWBBB\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n**Explanation:**\n\nUsing `.` to represent an empty cell, the desired state can be achieved in four operations as follows, which is the minimum:\n- `BWBWBW..`\n- `BW..BWBW`\n- `BWWBB..W`\n- `..WBBBWW`\n- `WWWBBB..`\n\n**Sample Input 2:**\n```\n6\nBBBBBB\nWWWWWW\n```\n\n**Sample Output 2:**\n```\n-1\n```\n\n**Sample Input 3:**\n```\n14\nBBBWBWWWBBWWBW\nWBWWBBWWWBWBBB\n```\n\n**Sample Output 3:**\n```\n7\n```\n\nSolution:\n\n[BEGIN TEXT]\nD - Go Stone Puzzle Editorial\n\nIf \\(S\\) and \\(T\\) have different numbers of W and B, then the answer is No. Assume they are equal. Let \\(W\\) be the number of W and \\(B\\) be the number of B. Since the empty squares are always adjacent, there are \\(\\frac{(N+1)!}{B!W!}=O(\\sqrt{N}2^N)\\) possible states of the cells. (The analysis is omitted here.) The maximum value \\(51480\\) occurs for \\(N=14\\) and \\(B=W=7\\). For each state, there are \\((N-1)\\) possible moves. Since the number of states and moves are small enough, use BFS to solve the problem. The total complexity is expected \\(O(N^{1.5}2^N)\\) using a hash map. Similar problem: 8 puzzle (AOJ).\n[END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAt the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes \\( A \\) seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.\n\nCurrently, there is no one in line at the ticket booth, and \\( N \\) people will come to buy tickets one after another. Specifically, the \\( i \\)-th person will arrive at the ticket booth \\( T_i \\) seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately. Here, \\( T_1 < T_2 < \\dots < T_N \\).\n\nFor each \\( i\\ (1 \\leq i \\leq N) \\), determine how many seconds from now the \\( i \\)-th person will finish purchasing their ticket.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 0 \\leq T_1 < T_2 < \\dots < T_N \\leq 10^6 \\)\n- \\( 1 \\leq A \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\nT_1 T_2 \\dots T_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the number of seconds from now that the \\( i \\)-th person will finish purchasing their ticket.\n\n**Sample Input 1:**\n\n```\n3 4\n0 2 10\n```\n\n**Sample Output 1:**\n\n```\n4\n8\n14\n```\n\nThe events proceed in the following order:\n\n- At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.\n- At 8 seconds: The 2nd person finishes purchasing their ticket.\n- At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 14 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 2:**\n\n```\n3 3\n1 4 7\n```\n\n**Sample Output 2:**\n\n```\n4\n7\n10\n```\n\nThe events proceed in the following order:\n\n- At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.\n- At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 10 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 3:**\n\n```\n10 50000\n120190 165111 196897 456895 540000 552614 561627 743796 757613 991216\n```\n\n**Sample Output 3:**\n\n```\n170190\n220190\n270190\n506895\n590000\n640000\n690000\n793796\n843796\n1041216\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nB - Ticket Counter Editorial by en_translator\n\nSuppose that the \\(i\\)-th person finishes buying a ticket at time \\(x_i\\). For convenience, let \\(x_0=0\\).\nFor each \\(i\\) (1 \\(\\leq i\\leq N\\)), we determine how to represent the value \\(x_i\\) using \\(x_{i-1}\\).\n\nIf \\(x_{i-1} \\leq T_i\\): there is no queue when the \\(i\\)-th person visits the ticket booth, so they can start purchasing instantly. Thus, \\(x_i=T_i+A\\).\nIf \\(x_{i-1} > T_i\\): someone is still purchasing a ticket when the \\(i\\)-th person visits the booth, so they start the process right after the \\((i-1)\\)-th person finishes. Thus, \\(x_i=x_{i-1}+A\\).\n\nTo summarize, \\(x_i=\\max(x_{i-1},T_i)+A\\). Use this to find \\(x_i\\) for each \\(i=1,2,\\dots,N\\).\n\nSample code (Python):\n```python\nn, a = map(int, input().split())\nt = list(map(int, input().split()))\npre = 0\nfor i in range(n):\n    ans = max(pre, t[i]) + a\n    print(ans)\n    pre = ans\n```\n \n\n", "problem_ids": ["abc371_g", "abc361_d", "abc358_b"]}, "abc342_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( K \\).\n\nThe **cumulative sums** of an integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is defined as a sequence \\( Y = (Y_0, Y_1, \\dots, Y_N) \\) of length \\( N+1 \\) as follows:\n\n- \\( Y_0 = 0 \\)\n- \\( Y_i = \\sum_{j=1}^{i} X_j \\) for \\( i = 1, 2, \\dots, N \\)\n\nAn integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is called a **good sequence** if and only if it satisfies the following condition:\n\n- Any value in the cumulative sums of \\( X \\) that is less than \\( K \\) appears before any value that is not less than \\( K \\).\n  \n  Formally, for the cumulative sums \\( Y \\) of \\( X \\), for any pair of integers \\( (i, j) \\) such that \\( 0 \\le i, j \\le N \\), if \\( (Y_i < K \\) and \\( Y_j \\ge K) \\), then \\( i < j \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). Determine whether the elements of \\( A \\) can be rearranged to form a good sequence. If so, print one such rearrangement.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq K \\leq 10^9 \\)\n- \\( -10^9 \\leq A_i \\leq 10^9 \\)\n\nAll input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nIf the elements of \\( A \\) can be rearranged to a good sequence, print the rearranged sequence \\( (A'_1, A'_2, \\dots, A'_N) \\) in the following format:\n\n```\nYes\nA'_1 A'_2 \\cdots A'_N\n```\n\nIf there are multiple valid rearrangements, any of them is considered correct.\n\nIf a good sequence cannot be obtained, print `No`.\n\n**Sample Input 1**\n```\n4 1\n-1 2 -3 4\n```\n\n**Sample Output 1**\n```\nYes\n-3 -1 2 4\n```\n\nIf you rearrange \\( A \\) to \\((-3, -1, 2, 4)\\), the cumulative sums \\( Y \\) will be \\( (0, -3, -4, -2, 2) \\). In this \\( Y \\), any value less than 1 appears before any value not less than 1.\n\n**Sample Input 2**\n```\n4 -1\n1 -2 3 -4\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n10 1000000000\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\nYes\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 179 - A - Partition Editorial by evima\n\nIf \\(K \\geq 1\\):\nBy sorting \\(A\\) in ascending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in ascending order. Let \\(B\\) be the cumulative sums of \\(A\\). Values in \\(A\\) that are less than \\(0\\) appear before values that are \\(0\\) or greater. Therefore, \\(B\\) can be represented as a concatenation of a strictly decreasing sequence and a non-decreasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 < K\\) and decreasing for a while, it begins to increase from a value less than \\(K\\). Once it becomes \\(K\\) or greater, it remains so thereafter. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i \\geq K\\):\nBy sorting \\(A\\) in descending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in descending order. Let \\(B\\) be the cumulative sum of \\(A\\). Values in \\(A\\) that are \\(0\\) or greater appear before values that are less than \\(0\\). Therefore, \\(B\\) can be represented as a concatenation of a strictly increasing sequence and a non-increasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 \\geq K\\) and increasing for a while, it begins to decrease from a value not less than \\(K\\). Since \\(B_0 \\geq K\\), it is \\(K\\) or greater from the start, and since \\(B_N = \\sum_{i=1}^{N}A_i \\geq K\\), it remains \\(K\\) or greater until the end. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i < K\\):\nNo matter how \\(A\\) is rearranged, it cannot be made into a good sequence. No matter how \\(A\\) is rearranged, the initial and final terms of the cumulative sum \\(B\\) of \\(A\\) are fixed. Since \\(B_0 = 0 \\geq K\\) and \\(B_N = \\sum_{i=1}^{N}A_i < K\\), it does not satisfy the conditions for a good sequence.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nBelow is the cleaned version of the problem statement:\n\n---\n\nThere is a graph with \\(N + Q\\) vertices, numbered \\(1, 2, \\ldots, N + Q\\). Initially, the graph has no edges.\n\nFor this graph, perform the following operation for \\(i = 1, 2, \\ldots, Q\\) in order:\n\n- For each integer \\(j\\) satisfying \\(L_i \\leq j \\leq R_i\\), add an undirected edge with cost \\(C_i\\) between vertices \\(N + i\\) and \\(j\\).\n\nDetermine if the graph is connected after all operations are completed. If it is connected, find the cost of a minimum spanning tree of the graph.\n\nA minimum spanning tree is a spanning tree with the smallest possible cost, and the cost of a spanning tree is the sum of the costs of the edges used in the spanning tree.\n\n### Constraints\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(1 \\leq L_i \\leq R_i \\leq N\\)\n- \\(1 \\leq C_i \\leq 10^9\\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nL_1 R_1 C_1\nL_2 R_2 C_2\n...\nL_Q R_Q C_Q\n```\n\n### Output\n\nIf the graph is connected, print the cost of a minimum spanning tree. Otherwise, print \\(-1\\).\n\n### Sample Input 1\n\n```\n4 3\n1 2 2\n1 3 4\n2 4 5\n```\n\n### Sample Output 1\n\n```\n22\n```\n\nThe following edges form a minimum spanning tree:\n\n- An edge with cost 2 connecting vertices 1 and 5\n- An edge with cost 2 connecting vertices 2 and 5\n- An edge with cost 4 connecting vertices 1 and 6\n- An edge with cost 4 connecting vertices 3 and 6\n- An edge with cost 5 connecting vertices 3 and 7\n- An edge with cost 5 connecting vertices 4 and 7\n\nSince \\(2 + 2 + 4 + 4 + 5 + 5 = 22\\), print 22.\n\n### Sample Input 2\n\n```\n6 2\n1 2 10\n4 6 10\n```\n\n### Sample Output 2\n\n```\n-1\n```\n\nThe graph is disconnected.\n\n### Sample Input 3\n\n```\n200000 4\n1 200000 1000000000\n1 200000 998244353\n1 200000 999999999\n1 200000 999999999\n```\n\n### Sample Output 3\n\n```\n199651870599998\n```\n\n---\n\nSolution:\n\n        [BEGIN TEXT]\n        Since the graph in this problem may have up to \\(NQ\\) edges, one cannot directly apply an algorithm that determines the minimum spanning tree of a general graph. We will try to exploit the special form of the graph to optimize Kruskal\u2019s algorithm against it. We first sort the edges by their costs and appropriately reassign indices so that \\(C_1 \\leq C_2 \\leq \\ldots \\leq C_Q\\). According to Kruskal\u2019s algorithm, one can determine the minimum spanning tree as follows:\n\nPrepare an \\((N + Q)\\)-vertex graph without an edge. For \\(i = 1, 2, \\ldots ,Q\\) in order:\n\nFor each \\(j = L_i, L_i + 1, \\ldots, R_i\\) in order, add an edge between vertices \\((N + i)\\) and \\(j\\) of cost \\(C_i\\) if and only if vertices \\((N + i)\\) and \\(j\\) are not connected.\n\nWhile it is still difficult to handle the conditions, one can notice that vertices \\((N + i)\\) and \\(j\\) are always disconnected if \\(j =L_i\\), and that vertices \\((N + i)\\) and \\((j - 1)\\) are connected if and only if vertices \\((j - 1)\\) and \\(j\\) are, in order to realize that it is sufficient to perform connectivity check for vertices with adjacent indices: \\(j - 1\\) and \\(j\\). Also, the graph is disconnected if and only if there exists an integer \\(j\\) between \\(1\\) and \\((N-1)\\) (inclusive) such that vertices \\((j - 1)\\) and \\(j\\) are disconnected. Naively implementing this still costs \\(\\Theta(NQ + Q\\log Q)\\), but now that the problem is simplified, there are various approaches.\n\n(1) Use a set (or similar data structure) Manage the set of \\(1 \\leq j < N\\) such that vertices \\((j - 1)\\) and \\(j\\) are disconnected in a data structure like the built-in set in Python, and remove those among \\(L_i, L_i + 1, \\ldots, R_i - 1\\) that is not in the set. Naively checking the existence for each element still leads to TLE, but one can use a method such as bisect.bisect_left that retrieves the position of the minimum element greater than or equal to \\(x\\), as removal of an element occurs at most \\((N - 1)\\) times and the complexity is bounded by \\(O((N + Q) \\log N)\\), which is fast enough.\n\n(2) Use a lazy segment tree One can also use a lazy segment tree that supports segment-sum retrieval and segment-filling with \\(0\\). The \\(j\\)-th element of the lazy segment tree should be \\(0\\) if vertices \\(j\\) and \\((j+1)\\) are connected, and \\(1\\) otherwise. Initialize such a segment tree of length \\((N-1)\\) all with \\(1\\); then the number of edges connecting vertex \\(N + i\\) and any of vertices \\(L_i + 1, L_i + 2, \\ldots, R_i\\) can be retrieved as the segment sum of \\([L_i, R_i)\\), and adding an edge is fulfilled by filling \\([L_i, R_i)\\) with \\(0\\).\n\n(3) Use bitwise operations While a naive scan-based algorithm on an array results in TLE (Time Limit Exceeded), one can make use of bitwise operations with almost the same idea. The answer can be found fast enough by managing connectivity for each \\((j, j+1)\\) using the built-in int type in Python and using a function that returns the next position of \\(1\\) in the same way as found in (1), the answer can be found fast enough.\n        [END TEXT]\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAtCoder Street is represented by a straight line on flat ground, with \\(N\\) utility poles of height \\(H\\) standing on it. These poles are numbered \\(1, 2, \\dots, N\\) in chronological order. Each pole \\(i\\) (where \\(1 \\leq i \\leq N\\)) is vertically positioned at coordinate \\(X_i\\), and the base of each pole is fixed to the ground. Assume the poles are sufficiently thin.\n\nThe street will experience \\(N\\) earthquakes. During the \\(i\\)-th earthquake (for \\(1 \\leq i \\leq N\\)), the following events occur:\n1. If pole \\(i\\) has not yet fallen, it falls to the left or the right on the number line, each with a probability of \\(\\frac{1}{2}\\).\n2. If a falling pole collides with another pole that has not yet fallen (including collision at the base), the latter pole will also fall in the same direction. This may trigger a chain reaction.\n\nThe direction in which a pole falls is independent of the direction in which other poles have fallen.\n\nFor earthquake preparedness, for each \\(t = 1, 2, \\dots, N\\), find the probability that all poles have fallen by exactly the \\(t\\)-th earthquake. Multiply it by \\(2^N\\) and print the result modulo \\(998244353\\). It can be proved that the values to be printed are integers.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq H \\leq 10^9\\)\n- \\(0 \\leq X_i \\leq 10^9\\) (for \\(1 \\leq i \\leq N\\))\n- \\(X_1, X_2, \\dots, X_N\\) are all distinct.\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n```\nN H\nX_1 X_2 \\cdots X_N\n```\n\n**Output:**\n\nPrint the answers for \\(t = 1, 2, \\dots, N\\) in this order, separated by spaces.\n\n**Sample Input 1:**\n```\n3 2\n0 3 1\n```\n\n**Sample Output 1:**\n```\n4 2 2\n```\n\n**Sample Input 2:**\n```\n4 10\n10 55 20 45\n```\n\n**Sample Output 2:**\n```\n0 4 4 8\n```\n\n**Sample Input 3:**\n```\n8 1\n5 0 6 3 8 1 7 2\n```\n\n**Sample Output 3:**\n```\n0 64 32 48 24 28 28 32\n```\n\n**Sample Input 4:**\n```\n40 20\n695 793 11 502 114 861 559 4 212 609 894 435 429 94 91 258 161 45 33 605 673 634 629 163 283 826 409 84 507 548 31 248 588 340 357 168 926 949 322 912\n```\n\n**Sample Output 4:**\n```\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41942627 41942627 360709869\n```\n\nSolution:\n\n```python\ndef find_probability_last_pole_falls(m, s):\n    \"\"\"Calculate the probability that the last pole to fall is the i-th pole.\"\"\"\n    # Step 3: Calculate probability\n    a = calculate_a(m, s)\n    b = calculate_b(m, s)\n    probability = (1 / (2 ** a)) * (b / 2)\n    return probability\n\ndef calculate_a(m, s):\n    \"\"\"Calculate the number of earthquakes for condition in Step 2.\"\"\"\n    count = 0\n    for earthquake in s:\n        if some_condition(earthquake):  # Replace with specific condition\n            count += 1\n    return count\n\ndef calculate_b(m, s):\n    \"\"\"Count conditions like p_i > p_{i+1} or i == m.\"\"\"\n    count = 0\n    for i in range(m):\n        if specific_condition(i, s):  # Replace with specific condition\n            count += 1\n    return count\n\ndef use_stack_for_min_updates(array):\n    \"\"\"Use a stack to manage minimum updates.\"\"\"\n    stack = []\n    result = {}\n    for index, value in enumerate(array):\n        while stack and stack[-1] > value:\n            stack.pop()\n        if not stack or stack[-1] != value:\n            result[index] = value\n        stack.append(value)\n    return result\n\nclass SegmentTree:\n    def __init__(self, data):\n        # Initialize the segment tree with the provided data\n        self.data = data\n        # Additional initialization as needed\n\n    def update(self, index, value):\n        # Update the segment tree at index with the new value\n        pass\n    \n    def calculate_modular_inverse(self, s1_times_sK):\n        # Calculate the modular inverse in real-time\n        pass\n\ndef aggregate_results(poles, earthquakes):\n    \"\"\"Aggregate results for problems concerning the poles.\"\"\"\n    last_pole_falls = []\n    for group in range(len(poles)):\n        if last_pole_falls[group] == group:\n            # Calculate probabilities using defined methods or classes\n            pass\n\n# Example on how the functions and classes could be used\nm = 5\ns = [1, 2, 3, 4, 5]  # Example data, replace with actual\nfind_probability_last_pole_falls(m, s)\n```\n \n\n", "problem_ids": ["arc179_a", "abc364_f", "arc177_d"]}, "abc343_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere is a directed graph with \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) and \\( N \\) edges. The out-degree of every vertex is \\( 1 \\), and the edge from vertex \\( i \\) points to vertex \\( a_i \\). Count the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\).\n\nHere, vertex \\( v \\) is reachable from vertex \\( u \\) if there exists a sequence of vertices \\( w_0, w_1, \\ldots, w_K \\) of length \\( K+1 \\) that satisfies the following conditions. In particular, if \\( u = v \\), it is always reachable:\n- \\( w_0 = u \\).\n- \\( w_K = v \\).\n- For every \\( 0 \\leq i < K \\), there is an edge from vertex \\( w_i \\) to vertex \\( w_{i+1} \\).\n\n### Constraints\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n\n```\nN\na_1 a_2 \\ldots a_N\n```\n\n### Output\nPrint the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\).\n\n### Sample Input 1\n```\n4\n2 1 1 4\n```\n\n### Sample Output 1\n```\n8\n```\n\n**Explanation:**\n\n- The vertices reachable from vertex \\( 1 \\) are vertices \\( 1, 2 \\).\n- The vertices reachable from vertex \\( 2 \\) are vertices \\( 1, 2 \\).\n- The vertices reachable from vertex \\( 3 \\) are vertices \\( 1, 2, 3 \\).\n- The vertex reachable from vertex \\( 4 \\) is vertex \\( 4 \\).\n\nTherefore, the number of pairs of vertices \\((u, v)\\) such that vertex \\( v \\) is reachable from vertex \\( u \\) is \\( 8 \\).\n\nNote that the edge from vertex \\( 4 \\) is a self-loop, that is, it points to vertex \\( 4 \\) itself.\n\n### Sample Input 2\n```\n5\n2 4 3 1 2\n```\n\n### Sample Output 2\n```\n14\n```\n\n### Sample Input 3\n```\n10\n6 10 4 1 5 9 8 6 5 1\n```\n\n### Sample Output 3\n```\n41\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial discusses a problem involving a functional graph, a common topic in competitive programming. A functional graph consists of connected components, each having exactly one cycle. The solution involves examining each connected component with a cycle and directed trees attached. For any vertex \\(u\\), all reachable vertices are either ancestors of \\(u\\) within its directed tree or part of the cycle that includes the root of this tree. To compute the reachable vertices, you should determine the depth of \\(u\\) in its directed tree and the number of vertices in the cycle using graph search algorithms like DFS. The algorithm's complexity is \\(\\mathrm{O}(N)\\), or alternatively, the SCC algorithm can be used.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given three sequences of positive integers each of length \\( N \\):  \n\\( A = (A_1, A_2, \\ldots, A_N) \\),  \n\\( B = (B_1, B_2, \\ldots, B_N) \\), and  \n\\( C = (C_1, C_2, \\ldots, C_N) \\).  \n\nFind the number of pairs of positive integers \\( (x, y) \\) that satisfy the following condition for all \\( 1 \\leq i \\leq N \\):  \n\\[ A_i \\times x + B_i \\times y < C_i \\]\n\nIt can be proved that the number of such pairs of positive integers satisfying the condition is finite.\n\nYou are given \\( T \\) test cases, each of which should be solved.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq A_i, B_i, C_i \\leq 10^9 \\)  \n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).  \n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:  \n\\[\n\\begin{align*}\nT & \\\\\n\\mathrm{case}_1 & \\\\\n\\mathrm{case}_2 & \\\\\n\\vdots & \\\\\n\\mathrm{case}_T & \\\\\n\\end{align*}\n\\]\n\nEach test case is given in the following format:  \n\\[\n\\begin{align*}\nN & \\\\\nA_1 & B_1 & C_1 \\\\\nA_2 & B_2 & C_2 \\\\\n\\vdots & \\\\\nA_N & B_N & C_N \\\\\n\\end{align*}\n\\]\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line \\( (1 \\leq i \\leq T) \\) should contain the answer for the \\( i \\)-th test case.\n\n**Sample Input 1**\n\n```\n2\n2\n1 1 4\n1 2 5\n1\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n2\n0\n```\n\nIn the first test case, there are two valid pairs of integers: \\( (x, y) = (1, 1), (2, 1) \\). Thus, the first line should contain 2.  \nIn the second test case, there are no valid pairs of integers. Thus, the second line should contain 0.\n\n**Sample Input 2**\n\n```\n3\n7\n138 16011 918976\n5478 7748 499926\n5234 17727 748589\n1157 10511 643136\n31200 3005 721285\n28839 14469 798851\n1933 5378 864127\n9\n17775 1665 386430\n37001 863 922418\n9756 4182 746671\n12379 9106 807578\n3984 4049 640539\n25333 9869 780810\n20372 7000 688738\n16107 11974 827227\n10779 10531 770510\n5\n4916 14132 460944\n11856 45422 610561\n56014 18216 825793\n10363 6220 945356\n37418 33866 851593\n```\n\n**Sample Output 2**\n\n```\n660\n995\n140\n```\n\nSolution:\n\n```python\n# Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nfrom math import ceil, floor\n\ndef count_lattice_points(N, lines):\n    # Sort the lines in ascending order of their slopes\n    lines.sort(key=lambda line: line[0] / line[1])\n    \n    # Prepare an empty list to manage the lowermost lines\n    L = []\n    \n    # Implement the convex hull algorithm-like approach to filter lines\n    for line in lines:\n        while len(L) >= 2 and is_unnecessary(L[-2], L[-1], line):\n            L.pop()\n        L.append(line)\n    \n    # Adjust N to the number of lines in L\n    N = len(L)\n    \n    # Find X_max\n    X_max = min(ceil(C / A) for A, B, C in L)\n    \n    # Calculate the sum of contributions for each line\n    total = 0\n    for i in range(N):\n        A_i, B_i, C_i = L[i]\n        \n        # Determine x_i\n        x_i = float('inf') if i == N - 1 else ceil((L[i + 1][2] - C_i) / (A_i - L[i + 1][0]))\n        x_prev = -float('inf') if i == 0 else x_i\n        \n        # Sum over the valid x in the range [x_prev, x_i) and [1, X_max)\n        for x in range(max(1, ceil(x_prev)), min(x_i, X_max)):\n            total += floor((C_i - 1 - A_i * x) / B_i)\n    \n    return total\n\ndef is_unnecessary(line1, line2, line3):\n    \"\"\"\n    Determine if the line2 is unnecessary in the convex hull structure. \n    It can be computed by comparing cross products.\n    \"\"\"\n    A1, B1, C1 = line1\n    A2, B2, C2 = line2\n    A3, B3, C3 = line3\n    \n    # Return true if line2 is unnecessary\n    # Cross product comparison: (C2 - C1, A2 - A1) vs (C3 - C1, A3 - A1)\n    return (C2 - C1) * (A3 - A1) <= (C3 - C1) * (A2 - A1)\n```\n\nIn this Python code, we implement the algorithm described in the given editorial. The code converts the explanation into a function that computes the number of lattice points under the given lines, following the steps of sorting the lines, maintaining a valid set using a convex hull-like approach, and then summing contributions using a specified method.\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n### Problem Statement\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\).\n\nYour objective is to transform this permutation into the identity permutation \\( P_i = i \\) for all \\( i = 1, 2, \\ldots, N \\) by performing the following operation zero or more times:\n\n1. Choose an integer \\( k \\) such that \\( 1 \\leq k \\leq N \\).\n2. If \\( k \\geq 2 \\), sort the elements from the 1st to the \\((k-1)\\)-th position of \\( P \\) in ascending order.\n3. Then, if \\( k \\leq N - 1 \\), sort the elements from the \\((k+1)\\)-th to the \\( N \\)-th position of \\( P \\) in ascending order.\n\nIt can be proved that under the constraints of this problem, it is possible to transform any given permutation \\( P \\) into the identity permutation with a finite number of operations. Your task is to find the minimum number of operations required.\n\nYou have \\( T \\) test cases to solve.\n\n### Constraints\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 3 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( P \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n- The sum of \\( N \\) across the test cases in a single input is at most \\( 2 \\times 10^5 \\).\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\n...\ncase_T\n```\n\nEach case is presented as follows:\n\n```\nN\nP_1 P_2 ... P_N\n```\n\n### Output\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\n\n### Sample Input 1\n\n```\n3\n5\n2 1 3 5 4\n3\n1 2 3\n7\n3 2 1 7 5 6 4\n```\n\n### Sample Output 1\n\n```\n1\n0\n2\n```\n\n#### Explanation:\n\n- For the first test case, the operation with \\( k = 3 \\) yields \\( P \\) as \\( (1, 2, 3, 4, 5) \\), requiring 1 operation.\n- The second test case already satisfies \\( P_i = i \\), thus needing 0 operations.\n- For the third test case, perform the operations with \\( k = 4 \\) and then \\( k = 3 \\) successively to achieve the identity permutation \\( (1, 2, 3, 4, 5, 6, 7) \\), requiring 2 operations.\n\nSolution:\n\n---\n\nSince each operation sorts a significant portion of the array, it is expected that the entire array can be sorted with a few operations. In fact:\n\n1. Perform the operation with \\(k=1\\). This sorts the entire array if \\(P_1=1\\) in the initial state. Otherwise, we have \\(P_N \\neq 1\\) after the operation since \\(N \\geq 3\\).\n2. Next, perform the operation with \\(k=N\\). Since \\(P_N \\neq 1\\) before the operation, we have \\(P_1=1\\) after the operation.\n3. Perform the operation with \\(k=1\\). Since \\(P_1=1\\) before the operation, the entire array is certainly sorted after the operation.\n\nBy performing the above, any permutation can be sorted in at most three operations. Therefore, it is sufficient to quickly determine if the array can be sorted in zero, one, or two operations.\n\n- The determination for zero operations is trivial.\n- For one operation, if we fix \\(k\\), it is necessary and sufficient that the minimum and maximum values of \\((P_1, P_2, \\dots, P_{k-1})\\) are \\(1\\) and \\(k-1\\), respectively, and \\(P_k=k\\). This can be checked in \\(O(1)\\) time for each \\(k\\) by taking cumulative \\(\\min\\) and \\(\\max\\), so the overall determination can be done in \\(O(N)\\) time.\n- For two operations, if \\(P_N \\neq 1\\), starting from the second of the three operations, the array can be sorted in two operations. Similarly, if \\(P_1 \\neq N\\), it can be sorted in two operations. Conversely, if \\(P_1=N\\) and \\(P_N=1\\), the relative positions of \\(1\\) and \\(N\\) in \\(P\\) do not change with one operation, leaving them in the order \\(N, 1\\). Therefore, \\(P\\) can be sorted in two or fewer operations \\(\\iff\\) \\(P_1 \\neq N\\) or \\(P_N \\neq 1\\). This can be checked in \\(O(1)\\) time.\n\nFrom the above, the answer for each test case can be found in \\(O(N)\\) time.\n \n\n", "problem_ids": ["abc357_e", "abc372_g", "arc181_a"]}, "abc343_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\(N - 1\\) white balls and one black ball. These \\(N\\) balls are arranged in a row, with the black ball initially at the leftmost position.\n\nTakahashi will perform the following operation exactly \\(K\\) times:\n\n- Choose two distinct integers \\(a\\) and \\(b\\) uniformly at random from the range [1, \\(N\\)]. If \\(a \\neq b\\), swap the \\(a\\)-th and \\(b\\)-th balls from the left.\n\nAfter \\(K\\) operations, let the black ball be at the \\(x\\)-th position from the left. Find the expected value of \\(x\\), modulo \\(998244353\\).\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 998244352\\)\n- \\(1 \\leq K \\leq 10^5\\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n    N K\n\n**Output**\n\nPrint the answer in one line.\n\n**Notes on Computation**\n\nThe expected value modulo \\(998244353\\) is defined as follows:\n\nThe expected value can always be expressed as a rational number \\(\\frac{P}{Q}\\). Under these constraints, it is guaranteed that \\(Q\\) is not divisible by \\(998244353\\), ensuring the existence of a unique integer \\(R\\) such that:\n\\[ \nR \\times Q \\equiv P \\pmod{998244353} \n\\]\nwhere \\(0 \\leq R < 998244353\\). You need to report this \\(R\\).\n\n**Sample Input 1**\n\n    2 1\n\n**Sample Output 1**\n\n    499122178\n\nExplanation: After one operation, the probabilities that the black ball is at the 1st position and the 2nd position from the left are both \\(\\frac{1}{2}\\). Thus, the expected value is \\(\\frac{3}{2}\\).\n\n**Sample Input 2**\n\n    3 2\n\n**Sample Output 2**\n\n    554580198\n\n**Sample Input 3**\n\n    4 4\n\n**Sample Output 3**\n\n    592707587\n\nSolution:\n\n[BEGIN TEXT]\nHere is the cleaned version of the editorial text:\n\n---\n\n**E - Random Swaps of Balls Editorial**\n\nBy the symmetry of the operation, if the probability that a black ball is at the leftmost position is \\(p\\), then that of being each of the other positions is \\(\\displaystyle \\frac{1 - p}{N - 1}\\). Thus, one can solve the problem by finding the probability that \\(K\\) operations make the leftmost ball black. This can be computed with Dynamic Programming (DP). Define\n\n\\(\\mathrm{dp}[i] :=\\) Probability that \\(i\\) operations make the leftmost ball black.\n\nWhat we want is \\(\\mathrm{dp}[K]\\). The transition requires the following two probabilities:\n\n- The probability that an operation moves the leftmost black ball to somewhere else.\n- The probability that an operation moves the black ball elsewhere to the leftmost position.\n\nDenoting them by \\(p, q\\), the transitions are as follows:\n\n\\(\\mathrm{dp}[0] = 1\\)  \n\\(\\mathrm{dp}[i+1] = (1 - p) \\mathrm{dp}[i] + q(1 - \\mathrm{dp}[i])\\)\n\nBy simple combinatorics:\n\n\\(\\displaystyle p = \\frac{2(n - 1)}{n^2}\\)  \n\\(\\displaystyle q = \\frac{2}{n^2}\\)\n\nImplementing it naively yields an \\(\\mathcal{O}(K)\\) solution, but it simplifies to a first-order recurrence relation, which can be efficiently computed, allowing \\(\\mathrm{dp}[K]\\) to be found in \\(\\mathcal{O}(\\log K)\\) time. This transforms the problem into a typical high-school math problem. More generally, algorithms such as the matrix powering algorithm and Fiduccia\u2019s algorithm can find the \\(N\\)-th term of a linear recurrence relation.\n[END TEXT]\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nYou are given an integer sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of length \\(N\\). On this sequence, the following operation can be performed:\n\nChoose \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Replace each of \\(A_{l+1}, A_{l+2}, \\dots, A_{r-1}\\) with \\(A_l\\). The cost of this operation is \\(r-l-1\\).\n\nYou will repeat this operation until there is no \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Find the minimum total cost of such a series of operations.\n\n**Constraints:**\n- \\(3 \\leq N \\leq 5 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq N\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n7\n1 2 3 2 3 2 1\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n_For example, if you perform the operation with \\((l, r) = (3, 5), (2, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,3,3,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\), after which there is no \\(l\\) and \\(r\\) with the said property. The total cost of this series of operations is \\(1+3+5=9\\)._\n\n_On the other hand, if you perform the operation with \\((l, r) = (2, 4), (4, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,2,2,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\). The total cost of this series of operations is \\(1+1+5=7\\)._\n\n**Sample Input 2:**\n```\n5\n1 2 3 4 5\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n40\n1 2 3 4 5 6 7 8 7 6 5 6 7 8 7 6 5 4 3 2 2 1 2 3 4 5 4 5 6 7 8 7 7 6 5 6 6 7 8 8\n```\n\n**Sample Output 3:**\n```\n44\n```\n\nSolution:\n\n```\nHere's a cleaned-up version of the solution:\n\nStarting from a vertex with color \\(A_i\\) and a piece placed on it, create a tree with colored vertices by performing the following steps for \\(i=2,3,\\dots,N\\): Let \\(pos\\) be the current position. If the color of the vertex at \\(pos\\) is \\(A_i\\), do nothing. If there is an adjacent vertex to \\(pos\\) with color \\(A_i\\), move the piece there. If no such vertex exists, create a new adjacent vertex with color \\(A_i\\) and move the piece there. The colors of adjacent vertices are always distinct. \n\nThe state of the sequence corresponds to a walk on this tree, where operations change a walk \\(u\\rightarrow v\\rightarrow v\\rightarrow \\dots \\rightarrow v\\rightarrow u\\) to \\(u\\rightarrow u\\rightarrow u\\rightarrow \\dots \\rightarrow u\\rightarrow u\\). Let \\(start\\) and \\(goal\\) be the start and end points of the walk. The problem is finding the minimum cost to change the walk into a simple path connecting \\(start\\) and \\(goal\\). \n\nCalculate the minimum cost. Consider parts of the walk off the path connecting \\(start\\) and \\(goal\\), like \\(\\dots \\rightarrow a \\rightarrow b \\rightarrow \\dots \\rightarrow b \\rightarrow a \\rightarrow \\dots\\). Convert \\(b \\rightarrow \\dots \\rightarrow b\\) to stay at \\(a\\), with the cost equivalent to the sum of distances to \\(a\\). The problem becomes: \n\nGiven \\(V=(v_1,v_2,\\dots,v_n)\\) with:\n\n\\(v_1=1, v_n=\\max_{1\\leq i \\leq n} v_i\\)\n\\(|v_i-v_{i+1}| \\in \\{0,1\\}\\),\n\nFind the minimum \\(\\sum |v_i-v'_i|\\) for \\(V'=(v'_1,v'_2,\\dots,v'_n)\\) where:\n\n\\(v'_1=v_1, v'_n=v_n\\)\n\\(v'_i \\leq v'_{i+1}\\)\nIf \\(v'_i \\neq v'_{i+1}\\), then \\(v_i=v'_i\\) and \\(v_{i+1}=v'_{i+1}\\).\n\nSolve this using dynamic programming in \\(O(N)\\): \n\nUse \\(dp[k]=\\) the minimum value of \\(\\sum_{k \\leq i} |v_i-v'_i|\\) when \\(v'_k=v_k\\). If \\(v_{k+1}=v_k+1\\), update \\(dp[k] \\leftarrow \\min(dp[k],dp[k+1])\\). Let \\(k'\\) be the smallest \\(i\\ (k < i)\\) such that \\(v_{i}=v_k\\), then update \\(dp[k] \\leftarrow \\min(dp[k],dp[k']+\\sum_{i=k+1}^{k'}|v_k-v_i|)\\).\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\n### Problem Statement\n\nThere is a keyboard with 26 keys arranged on a number line. The arrangement of this keyboard is represented by a string \\( S \\), which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character \\( S_x \\) is located at coordinate \\( x \\) \\((1 \\leq x \\leq 26)\\). Here, \\( S_x \\) denotes the \\( x \\)-th character of \\( S \\).\n\nYou will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key. Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.\n\n### Constraints\n\n- \\( S \\) is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n### Sample Output 1\n```\n25\n```\n\nFrom pressing the key for `A` to pressing the key for `Z`, you need to move your finger 1 unit at a time in the positive direction, resulting in a total traveled distance of 25. It is impossible to press all keys with a total traveled distance less than 25, so print 25.\n\n### Sample Input 2\n```\nMGJYIZDKSBHPVENFLQURTCWOAX\n```\n\n### Sample Output 2\n```\n223\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        For a character \\(c\\), let \\(X_c\\) be the coordinate of the key corresponding to the character \\(c\\). We need to find \\(|X_A-X_B|+|X_B-X_C|+\\ldots+|X_Y-X_Z|\\). If we can find \\(S\\) from \\(X\\), the sought value can be found using a for loop. An array can correspond the integer \\(0\\) to A, \\(1\\) to B, \\(\\ldots\\), and \\(25\\) to Z, so that \\(X\\) can be managed as an array. Alternatively, an associative array with its key as a character type can be used.\n\nSample code in Python3:\n\n```python\ns = input()\nx = [0] * 26\nfor i in range(26):\n    x[ord(s[i]) - ord(\"A\")] = i\nans = 0\nfor i in range(25):\n    ans += abs(x[i] - x[i + 1])\nprint(ans)\n```\n        [END TEXT]\n        \n \n\n", "problem_ids": ["abc360_e", "arc181_f", "abc373_b"]}, "abc343_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a sequence of \\( N \\) positive integers \\( A = (A_1, A_2, \\dots, A_N) \\).\n\nFind the number of pairs of integers \\( (l, r) \\) satisfying \\( 1 \\leq l \\leq r \\leq N \\) such that the subsequence \\( (A_l, A_{l+1}, \\dots, A_r) \\) forms an arithmetic progression.\n\nA sequence \\( (x_1, x_2, \\dots, x_{|x|}) \\) is an arithmetic progression if and only if there exists a \\( d \\) such that \\( x_{i+1} - x_i = d \\) for \\( 1 \\leq i < |x| \\). In particular, a sequence of length \\( 1 \\) is always an arithmetic progression.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n4\n3 6 9 3\n```\n\n**Sample Output 1:**\n\n```\n8\n```\n\nThere are eight pairs of integers \\( (l, r) \\) satisfying the condition: \\( (1,1), (2,2), (3,3), (4,4), (1,2), (2,3), (3,4), (1,3) \\). Indeed, when \\( (l, r) = (1, 3) \\), \\( (A_l, \\dots, A_r) = (3, 6, 9) \\) is an arithmetic progression, so it satisfies the condition. However, when \\( (l, r) = (2, 4) \\), \\( (A_l, \\dots, A_r) = (6, 9, 3) \\) is not an arithmetic progression, so it does not satisfy the condition.\n\n**Sample Input 2:**\n\n```\n5\n1 1 1 1 1\n```\n\n**Sample Output 2:**\n\n```\n15\n```\n\nAll pairs of integers \\( (l, r) \\) satisfying \\( 1 \\leq l \\leq r \\leq 5 \\) satisfy the condition.\n\n**Sample Input 3:**\n\n```\n8\n87 42 64 86 72 58 44 30\n```\n\n**Sample Output 3:**\n\n```\n22\n```\n\nSolution:\n\n```markdown\n[C - Count Arithmetic Subarrays Editorial]\n\nThe condition is always satisfied if \\(l = r\\), so we will add \\(n\\) to the answer finally and consider pairs \\((l, r)\\) such that \\(l < r\\). Let \\(B = (B_1, B_2, \\dots, B_{N-1})\\) be the sequence of differences of \\(A\\); that is, \\(B_i = A_{i+1} - A_i\\). The subarray \\((l, r)\\) satisfies the condition of being an arithmetic progression if and only if \\(B_l = B_{l+1} = \\dots = B_{r-1}\\). Thus, the problem is reduced to finding the number of pairs \\((l, r)\\) such that \\(B_l = B_{l+1} = \\dots = B_r\\).\n\nTo solve this, apply run-length compression to \\(B\\), obtaining a sequence of integer pairs \\((C_1, D_1), (C_2, D_2), \\dots, (C_k, D_k)\\). The sequence \\(B\\) is a concatenation of runs \\(f(i)\\), where each \\(C_i\\) is repeated \\(D_i\\) times. A segment \\([l, r]\\) conforming to the condition is completely contained within a run \\(f(i)\\). The number of such segments in \\(f(i)\\) is \\(\\frac{D_i(D_i+1)}{2}\\). The answer is \\(\\displaystyle \\sum_{i=1}^{k} \\frac{D_i(D_i+1)}{2}\\).\n```\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a circular cake divided into \\(N\\) pieces by cut lines. Each cut line is a line segment connecting the center of the circle to a point on the arc. The pieces and cut lines are numbered \\(1, 2, \\ldots, N\\) in clockwise order, and piece \\(i\\) has a mass of \\(A_i\\). Piece \\(1\\) is also called piece \\(N + 1\\). Cut line \\(i\\) is between pieces \\(i\\) and \\(i + 1\\), and they are arranged clockwise in this order: piece \\(1\\), cut line \\(1\\), piece \\(2\\), cut line \\(2\\), \\(\\ldots\\), piece \\(N\\), cut line \\(N\\).\n\nWe want to divide this cake among \\(K\\) people under the following conditions. Let \\(w_i\\) be the sum of the masses of the pieces received by the \\(i\\)-th person.\n\n- Each person receives one or more **consecutive** pieces.\n- There are no pieces that no one receives.\n- Under the above two conditions, \\(\\min(w_1, w_2, \\ldots, w_K)\\) is maximized.\n\nFind the value of \\(\\min(w_1, w_2, \\ldots, w_K)\\) in a division that satisfies the conditions, and the number of cut lines that are never cut in the divisions that satisfy the conditions. Here, cut line \\(i\\) is considered cut if pieces \\(i\\) and \\(i + 1\\) are given to different people.\n\n**Constraints:**\n\n- \\(2 \\leq K \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq 10^4\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nLet \\(x\\) be the value of \\(\\min(w_1, w_2, \\ldots, w_K)\\) in a division that satisfies the conditions, and \\(y\\) be the number of cut lines that are never cut. Print \\(x\\) and \\(y\\) in this order, separated by a space.\n\n**Sample Input 1:**\n\n```\n5 2\n3 6 8 6 4\n```\n\n**Sample Output 1:**\n\n```\n13 1\n```\n\nThe following divisions satisfy the conditions:\n- Give pieces \\(2, 3\\) to one person and pieces \\(4, 5, 1\\) to the other. Pieces \\(2, 3\\) have a total mass of \\(14\\), and pieces \\(4, 5, 1\\) have a total mass of \\(13\\).\n- Give pieces \\(3, 4\\) to one person and pieces \\(5, 1, 2\\) to the other. Pieces \\(3, 4\\) have a total mass of \\(14\\), and pieces \\(5, 1, 2\\) have a total mass of \\(13\\).\n\nThe value of \\(\\min(w_1, w_2)\\) in divisions satisfying the conditions is \\(13\\), and there is one cut line that is not cut in either division: cut line \\(5\\).\n\n**Sample Input 2:**\n\n```\n6 3\n4 7 11 3 9 2\n```\n\n**Sample Output 2:**\n\n```\n11 1\n```\n\n**Sample Input 3:**\n\n```\n10 3\n2 9 8 1 7 9 1 3 5 8\n```\n\n**Sample Output 3:**\n\n```\n17 4\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\nF - Cake Division Editorial by en_translator\n\nLet us call a contiguous pieces a segment. Using binary search, it is sufficient to solve the following decision problem (fast): Can the \\(N\\) pieces be divided into \\(K\\) segments so that each segment has a mass of at least \\(X\\)? If possible, how many cut lines are never used by any division among such ways?\n\nFor each \\(1 \\leq i \\leq N\\), let us consider whether there exists a conforming division that uses cut line \\(i\\). Let us redefine the sequence \\(A\\) of length \\(2N\\) by letting \\(A_{N + i} \\coloneqq A_i\\) for all \\(i\\) with \\(1 \\leq i \\leq N\\). If there exists \\(j (\\leq 2N + 1)\\) such that \\(A_i + A_{i + 1} + \\ldots + A_{j - 1}  \\geq X\\), let \\(f(i)\\) be the minimum such \\(j\\); otherwise, let \\(f(i) = \\infty\\). Also, let \\(f(\\infty) = \\infty\\). Using the sliding window trick, \\(f\\) can be evaluated for all arguments in a total of \\(O(N)\\) time.\n\nThere exists a conforming division that uses cut line \\(i\\) if and only if \\(f^K(i + 1) \\leq N + i + 1\\). \\(f^K\\) can be evaluated in \\(O(N \\log K)\\) time using the doubling technique based on \\(f^2, f^4, f^8, \\ldots\\). Therefore, the number of \\(i\\) for which there is a division that uses cut line \\(i\\) can be counted in \\(O(N \\log K)\\) time. Noticing that there is at least one \\(i\\) such that cut line \\(i\\) is used by a division if and only if the \\(N\\) pieces can be divided into \\(K\\) segments so that each segment has a mass of at least \\(K\\), this also solves the decision problem.\n\nAlternatively, evaluating \\(f^K\\) can be boiled down to the Level Ancestor Problem in a tree which has an edge between \\(i\\) and \\(f(i)\\) for each \\(i\\) with \\(i \\neq f(i)\\), so the decision problem can be solved in \\(O(N)\\) time too. However, in the writer\u2019s and tester\u2019s solution, it was the solution that used doubling.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nYou are given a sequence of integers \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nDefine \\( f(l, r) \\) as the number of distinct values in the subsequence \\( (A_l, A_{l+1}, \\ldots, A_r) \\).\n\nEvaluate the following sum:\n\n\\[\n\\sum_{i=1}^{N}\\sum_{j=i}^N f(i,j)\n\\]\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\n\nThe input is given in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n3\n1 2 2\n```\n\n### Sample Output 1\n\n```\n8\n```\n\nConsider \\( f(1, 2) \\). The subsequence \\( (A_1, A_2) = (1, 2) \\) contains 2 distinct values, so \\( f(1,2) = 2 \\).\n\nConsider \\( f(2, 3) \\). The subsequence \\( (A_2, A_3) = (2, 2) \\) contains 1 distinct value, so \\( f(2,3) = 1 \\).\n\nThe sum of \\( f \\) is 8.\n\n### Sample Input 2\n\n```\n9\n5 4 2 2 3 2 4 4 1\n```\n\n### Sample Output 2\n\n```\n111\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 371\n\nE - I Hate Sigma Problems Editorial\n\nThe answer is the number of subarrays containing \\(1\\) \\(+\\) the number of subarrays containing \\(2\\) \\(+\\ldots+\\) the number of subarrays containing \\(N\\). We will explain how to count subarrays containing \\(i\\) in \\(\\mathrm{O}(C_i)\\) time (where \\(C_i\\) is the number of occurrences of \\(i\\) in \\(A\\)). Once this is possible, the problem can be solved in a total of \\(\\mathrm{O}(N)\\) time. A common technique of combinatorics is to consider complementary events. Let\u2019s count the number of subarrays not containing \\(i\\), subtracting the sum from the all. For simplicity, let us insert \\(i\\) to both ends of \\(A\\). Then, the indices \\(x\\) with \\(A_x = i\\) arranged in ascending order are represented as \\(x=(x_0=0,x_1,\\ldots,x_{C_i+1} = N+1)\\). The number of subarrays not containing \\(i\\) equals the number of subarrays whose left end is \\(x_0+1\\) or greater, and right end is \\(x_1-1\\) or less, plus subarrays whose left end is \\(x_1+1\\) or greater, and right end is \\(x_2-1\\) or less, and so on. This can be evaluated in \\(\\mathrm{O}(C_i)\\) time. Hence, the problem has been solved.\n```\n \n\n", "problem_ids": ["abc369_c", "abc370_f", "abc371_e"]}, "abc343_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nAlice and Bob are playing a game with two positive integers \\( N \\) and \\( M \\), where \\( N < M \\). Each player has \\( N \\) cards numbered from 1 to \\( N \\). Alice starts the game, and they take turns playing one card from their hand onto the table. If, after a player plays a card, the sum of the numbers on the table is divisible by \\( M \\), the player who played the last card loses, and the other player wins. If all cards are played and the sum is never divisible by \\( M \\), Alice wins. Given \\( T \\) test cases, determine who will win (Alice or Bob) if both play optimally.\n\nConstraints:\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N < M \\leq 10^9 \\)\n\nInput:\n- The input consists of \\( T \\) test cases.\n- Each test case is described by two integers \\( N \\) and \\( M \\).\n\nOutput:\n- For each test case, output \"Alice\" if Alice wins or \"Bob\" if Bob wins when both players play optimally.\n\nSample Input:\n```\n8\n2 3\n3 6\n5 9\n45 58\n39 94\n36 54\n74 80\n61 95\n```\n\nSample Output:\n```\nAlice\nAlice\nBob\nBob\nAlice\nBob\nBob\nAlice\n```\n\nIn the first test case, both Alice and Bob have two cards: a 1 and a 2. Alice plays 1, and the sum is 1, which is not divisible by 3. Bob plays 1, making the sum 2, still not divisible by 3. Alice plays 2, making the sum 4, not divisible by 3. Bob plays 2, making the sum 6, which is divisible by 3, so Bob loses, and Alice wins. Alice wins regardless of Bob's strategy.\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 185\n\ndef mod_m_game(N, M):\n    # Calculate c\n    c = (N * (N + 1)) % M\n\n    # Determine if Alice loses or wins\n    if 1 <= c <= N:\n        return \"Bob wins\"\n    else:\n        return \"Alice wins\"\n\n# Example Usage\nN = 5\nM = 3\nresult = mod_m_game(N, M)\nprint(result)  # Output should be \"Bob wins\" or \"Alice wins\" based on the conditions\n```\n\nEditorial - AtCoder Regular Contest 185\n\nA - mod M Game 2 Editorial by evima\n\nFirst, focus on the moment when Alice plays her last card:\n\n- A player with two or more cards can avoid playing a losing card.\n- If Alice doesn't lose when playing her last card, she will win regardless of Bob's last move.\n\nDetermine if Alice loses with her last card using Bob\u2019s last card \\(b\\). The sum of the numbers on the cards played is \\(N(N+1) - b\\). We check if \\(N(N + 1) - b \\equiv 0 \\pmod{M}\\).\n\n1. If \\(1 \\leq (N(N+1) \\bmod M) \\leq N\\):\n   - Let \\(c = N(N + 1) \\bmod M\\). Bob can make his last card \\(b = c\\) by playing all cards except \\(c\\), leading to Alice's loss. Bob can achieve this by keeping \\(c\\) among his final cards.\n\n2. If \\(N(N + 1) - b\\) cannot be \\(0\\):\n   - Alice will not lose on her last card, leading to her victory.\n\nBob wins if \\(1 \\leq N(N + 1) \\bmod M \\leq N\\), otherwise Alice wins. This can be determined in \\(O(1)\\) time.\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a circular cake divided into \\(N\\) pieces by cut lines. Each cut line is a line segment connecting the center of the circle to a point on the arc. The pieces and cut lines are numbered \\(1, 2, \\ldots, N\\) in clockwise order, and piece \\(i\\) has a mass of \\(A_i\\). Piece \\(1\\) is also called piece \\(N + 1\\). Cut line \\(i\\) is between pieces \\(i\\) and \\(i + 1\\), and they are arranged clockwise in this order: piece \\(1\\), cut line \\(1\\), piece \\(2\\), cut line \\(2\\), \\(\\ldots\\), piece \\(N\\), cut line \\(N\\).\n\nWe want to divide this cake among \\(K\\) people under the following conditions. Let \\(w_i\\) be the sum of the masses of the pieces received by the \\(i\\)-th person.\n\n- Each person receives one or more **consecutive** pieces.\n- There are no pieces that no one receives.\n- Under the above two conditions, \\(\\min(w_1, w_2, \\ldots, w_K)\\) is maximized.\n\nFind the value of \\(\\min(w_1, w_2, \\ldots, w_K)\\) in a division that satisfies the conditions, and the number of cut lines that are never cut in the divisions that satisfy the conditions. Here, cut line \\(i\\) is considered cut if pieces \\(i\\) and \\(i + 1\\) are given to different people.\n\n**Constraints:**\n\n- \\(2 \\leq K \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq 10^4\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nLet \\(x\\) be the value of \\(\\min(w_1, w_2, \\ldots, w_K)\\) in a division that satisfies the conditions, and \\(y\\) be the number of cut lines that are never cut. Print \\(x\\) and \\(y\\) in this order, separated by a space.\n\n**Sample Input 1:**\n\n```\n5 2\n3 6 8 6 4\n```\n\n**Sample Output 1:**\n\n```\n13 1\n```\n\nThe following divisions satisfy the conditions:\n- Give pieces \\(2, 3\\) to one person and pieces \\(4, 5, 1\\) to the other. Pieces \\(2, 3\\) have a total mass of \\(14\\), and pieces \\(4, 5, 1\\) have a total mass of \\(13\\).\n- Give pieces \\(3, 4\\) to one person and pieces \\(5, 1, 2\\) to the other. Pieces \\(3, 4\\) have a total mass of \\(14\\), and pieces \\(5, 1, 2\\) have a total mass of \\(13\\).\n\nThe value of \\(\\min(w_1, w_2)\\) in divisions satisfying the conditions is \\(13\\), and there is one cut line that is not cut in either division: cut line \\(5\\).\n\n**Sample Input 2:**\n\n```\n6 3\n4 7 11 3 9 2\n```\n\n**Sample Output 2:**\n\n```\n11 1\n```\n\n**Sample Input 3:**\n\n```\n10 3\n2 9 8 1 7 9 1 3 5 8\n```\n\n**Sample Output 3:**\n\n```\n17 4\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\nF - Cake Division Editorial by en_translator\n\nLet us call a contiguous pieces a segment. Using binary search, it is sufficient to solve the following decision problem (fast): Can the \\(N\\) pieces be divided into \\(K\\) segments so that each segment has a mass of at least \\(X\\)? If possible, how many cut lines are never used by any division among such ways?\n\nFor each \\(1 \\leq i \\leq N\\), let us consider whether there exists a conforming division that uses cut line \\(i\\). Let us redefine the sequence \\(A\\) of length \\(2N\\) by letting \\(A_{N + i} \\coloneqq A_i\\) for all \\(i\\) with \\(1 \\leq i \\leq N\\). If there exists \\(j (\\leq 2N + 1)\\) such that \\(A_i + A_{i + 1} + \\ldots + A_{j - 1}  \\geq X\\), let \\(f(i)\\) be the minimum such \\(j\\); otherwise, let \\(f(i) = \\infty\\). Also, let \\(f(\\infty) = \\infty\\). Using the sliding window trick, \\(f\\) can be evaluated for all arguments in a total of \\(O(N)\\) time.\n\nThere exists a conforming division that uses cut line \\(i\\) if and only if \\(f^K(i + 1) \\leq N + i + 1\\). \\(f^K\\) can be evaluated in \\(O(N \\log K)\\) time using the doubling technique based on \\(f^2, f^4, f^8, \\ldots\\). Therefore, the number of \\(i\\) for which there is a division that uses cut line \\(i\\) can be counted in \\(O(N \\log K)\\) time. Noticing that there is at least one \\(i\\) such that cut line \\(i\\) is used by a division if and only if the \\(N\\) pieces can be divided into \\(K\\) segments so that each segment has a mass of at least \\(K\\), this also solves the decision problem.\n\nAlternatively, evaluating \\(f^K\\) can be boiled down to the Level Ancestor Problem in a tree which has an edge between \\(i\\) and \\(f(i)\\) for each \\(i\\) with \\(i \\neq f(i)\\), so the decision problem can be solved in \\(O(N)\\) time too. However, in the writer\u2019s and tester\u2019s solution, it was the solution that used doubling.\n```\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nThere are \\(N+Q\\) points \\(A_1, \\dots, A_N, B_1, \\dots, B_Q\\) on a number line, where point \\(A_i\\) has a coordinate \\(a_i\\) and point \\(B_j\\) has a coordinate \\(b_j\\).\n\nFor each \\(j = 1, 2, \\dots, Q\\), answer the following question:\n\nFind the distance between the point \\(X\\), which is the \\(k_j\\)-th closest among \\(A_1, A_2, \\dots, A_N\\) to point \\(B_j\\), and \\(B_j\\).\n\nMore formally, let \\(d_i\\) be the distance between points \\(A_i\\) and \\(B_j\\). Sort \\( (d_1, d_2, \\dots, d_N) \\) in ascending order to get the sequence \\( (d_1', d_2', \\dots, d_N') \\). Find \\( d_{k_j}' \\).\n\n### Constraints\n\n- \\(1 \\leq N, Q \\leq 100,000\\)\n- \\(-10^8 \\leq a_i, b_j \\leq 10^8\\)\n- \\(1 \\leq k_j \\leq N\\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\na_1 a_2 \\dots a_N\nb_1 k_1\nb_2 k_2\n\\vdots\nb_Q k_Q\n```\n\n### Output\n\nPrint \\( Q \\) lines.\nThe \\( l \\)-th line \\( (1 \\leq l \\leq Q) \\) should contain the answer to the question for \\( j = l \\) as an integer.\n\n### Sample Input 1\n\n```\n4 3\n-3 -1 5 6\n-2 3\n2 1\n10 4\n```\n\n### Sample Output 1\n\n```\n7\n3\n13\n```\n\nExplanation for the first query: The distances from points \\( A_1, A_2, A_3, A_4 \\) to point \\( B_1 \\) are \\( 1, 1, 7, 8 \\), respectively, so the 3rd closest to point \\( B_1 \\) is point \\( A_3 \\). Therefore, print the distance between point \\( A_3 \\) and point \\( B_1 \\), which is \\( 7 \\).\n\n### Sample Input 2\n\n```\n2 2\n0 0\n0 1\n0 2\n```\n\n### Sample Output 2\n\n```\n0\n0\n```\n\nThere may be multiple points with the same coordinates.\n\n### Sample Input 3\n\n```\n10 5\n-84 -60 -41 -100 8 -8 -52 -62 -61 -76\n-52 5\n14 4\n-2 6\n46 2\n26 7\n```\n\n### Sample Output 3\n\n```\n11\n66\n59\n54\n88\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe problem requires finding the \\(k\\)-th nearest point to a given point among a set of points. To achieve this, binary search is employed. Define \\(f_j(x)\\) as the number of points within a distance \\(x\\) from a specific point \\(B_j\\). The task is reduced to finding the smallest \\(x\\) for which \\(f_j(x) \\geq k_j\\). Since \\(f_j(x)\\) increases monotonically, binary search is suitable and is applied \\(O(Q\\log A)\\) times. Pre-sorting the points allows efficient range counting with binary search. The overall complexity is \\(O(N\\log N + Q\\log A)\\).\n[END TEXT]\n \n\n", "problem_ids": ["arc185_a", "abc370_f", "abc364_d"]}, "abc343_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAn undirected graph with numbered vertices is called a **good graph** if it has a spanning tree \\( T \\) that satisfies the following condition: For every edge \\( (u, v) \\) (\\( u < v \\)) in the graph, the minimum and maximum vertex numbers on the unique simple path connecting vertices \\( u \\) and \\( v \\) in \\( T \\) are \\( u \\) and \\( v \\), respectively.\n\nYou are given a simple connected undirected graph \\( G \\) with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). The graph \\( G \\) has \\( M \\) edges, and the \\( i \\)-th edge connects vertices \\( A_i \\) and \\( B_i \\) (\\( A_i < B_i \\)).\n\nFor each \\( i = 1, 2, \\dots, M \\), determine whether the graph obtained by removing the \\( i \\)-th edge from \\( G \\) is a **good graph**.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- All input values are integers.\n- The given graph is a simple connected undirected graph.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\n**Output**\n\nPrint \\( M \\) lines. The \\( i \\)-th line should contain `Yes` if the graph obtained by removing the \\( i \\)-th edge from \\( G \\) is a **good graph**, and `No` otherwise.\n\n**Sample Input 1**\n\n```\n6 9\n1 3\n1 5\n2 5\n2 6\n3 4\n3 5\n3 6\n4 6\n5 6\n```\n\n**Sample Output 1**\n\n```\nNo\nNo\nNo\nNo\nYes\nNo\nNo\nYes\nYes\n```\n\nConsider the case where edge \\( (4, 6) \\) is removed. A spanning tree formed by edges \\( (1, 3), (2, 5), (3, 4), (3, 5), (5, 6) \\) satisfies the condition. For example, for edge \\( (3, 6) \\), the simple path connecting vertices \\( 3 \\) and \\( 6 \\) traverses vertices \\( 3, 5, 6 \\) in this order, and the minimum and maximum vertex numbers on the path are \\( 3 \\) and \\( 6 \\), respectively, thus satisfying the condition. By verifying the other edges similarly, it can be seen that this spanning tree satisfies the condition, so the answer is `Yes`.\n\nOn the other hand, consider the case where edge \\( (1, 5) \\) is removed. The same spanning tree does not satisfy the condition. For edge \\( (4, 6) \\), the simple path connecting vertices \\( 4 \\) and \\( 6 \\) traverses vertices \\( 4, 3, 5, 6 \\) in this order, and the minimum and maximum vertex numbers on the path are \\( 3 \\) and \\( 6 \\), respectively, thus not satisfying the condition. It can also be shown that no other spanning tree satisfies the condition, so the answer is `No`.\n\n**Sample Input 2**\n\n```\n5 4\n1 2\n2 3\n3 4\n4 5\n```\n\n**Sample Output 2**\n\n```\nNo\nNo\nNo\nNo\n```\n\nRemoving an edge may disconnect the graph.\n\n**Sample Input 3**\n\n```\n15 20\n12 13\n7 8\n5 7\n8 10\n9 12\n4 5\n11 12\n2 4\n6 8\n4 14\n1 2\n14 15\n2 9\n3 8\n2 15\n10 11\n13 14\n8 9\n7 14\n5 13\n```\n\n**Sample Output 3**\n\n```\nNo\nNo\nNo\nYes\nYes\nNo\nYes\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nYes\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 181\n\nE - Min and Max at the edge Editorial by evima\n\nThe spanning tree that possesses the properties described in the conditions for a good graph will be referred to as a \u201cgood spanning tree.\u201d First, let\u2019s consider how to determine the existence of a good spanning tree for a fixed graph. If a good spanning tree exists, when we define the cost of an edge \\( (u,v) \\) as \\(|X_u - X_v|\\) using a strictly increasing sequence \\(X\\), the good spanning tree will be one of the minimum spanning trees. This follows from Kruskal's algorithm and the fact that for an edge \\( (u,v) \\) not included in the good spanning tree, the cost of the edges on the simple path connecting \\(u\\) and \\(v\\) will be less than \\(|X_u - X_v|\\). Specifically, if we consider setting \\(X_u = 10^u\\) or \\(-10^{N-u}\\), the costs of each edge will be distinct, so the minimum spanning tree will be uniquely determined. The good spanning tree will be equal to both of the following:\n\n1. The minimum spanning tree \\(T_1\\) when the cost of edge \\((u,v)\\) is \\((N+1)v - u\\)\n2. The minimum spanning tree \\(T_2\\) when the cost of edge \\((u,v)\\) is \\((N+1)(N+1-u) - (N+1-v)\\)\n\nTherefore, for a good spanning tree to exist, it is necessary that \\(T_1 = T_2\\). Conversely, in \\(T_1\\), for an edge \\((u,v)\\), the maximum vertex number on the simple path connecting \\(u\\) and \\(v\\) must be \\(v\\). In \\(T_2\\), for an edge \\((u,v)\\), the minimum vertex number on the simple path connecting \\(u\\) and \\(v\\) must be \\(u\\). Thus, the above conditions are also sufficient. From the above, the existence of a good spanning tree can be determined by finding \\(T_1\\) and \\(T_2\\) and checking if they are identical. Then, to determine the existence of a good spanning tree when each edge is removed, we can find the changes in the minimum spanning tree when the edge is removed and check for identicalness.\n\nFor the minimum spanning tree \\(T\\) of graph \\(G\\), the minimum spanning tree \\(T_{u,v}\\) of the graph obtained by removing edge \\((u,v)\\) can be obtained by the following steps:\n- If \\((u,v)\\) is not included in \\(T\\), then \\(T_{u,v} = T\\).\n- Otherwise, remove \\((u,v)\\) from \\(T\\). As a result, \\(T\\) will be divided into two connected components. Among the edges that span the two connected components, add the one with the minimum cost to \\(T\\) to obtain the tree \\(T_{u,v}\\).\n\nTherefore, we need to solve the following problem:\n\n1. For each edge \\(e\\) in the minimum spanning tree \\(T\\) of graph \\(G\\), initialize a variable \\(X_e\\) to \\(\\infty\\).\n2. For each edge \\((u,v)\\) in graph \\(G\\) that is not included in \\(T\\), update \\(X_e \\leftarrow \\min(X_e, C_{u,v})\\) (where \\(C_{u,v}\\) is the cost of edge \\((u,v)\\)) for each edge \\(e\\) included in the simple path connecting \\(u\\) and \\(v\\) in \\(T\\), and find the final values of \\(X_e\\).\n\nThis can be processed in \\(O(M \\log N)\\) time by handling range chmin queries with a segment tree while performing a DFS. Alternatively, by decomposing the tree into heavy and light paths and arranging the heavy paths, it can be converted into \\(O(\\log N)\\) range chmin queries, allowing it to be processed in \\(O(M \\log^2 N)\\) time, which is also sufficient.\n```\n\n \n\nSimilar Problem 2 \n\n Problem Statement:\n\nScore: 600 points\n\nProblem Statement:\nThere are \\(N\\) stones placed on a 2-dimensional plane. The \\(i\\)-th stone is located at coordinates \\((X_i, Y_i)\\). All stones are located at lattice points in the first quadrant (including the axes).\n\nCount the number of lattice points \\((x, y)\\) where no stone is placed and it is **impossible** to reach \\((-1, -1)\\) from \\((x, y)\\) by repeatedly moving up, down, left, or right by 1 without passing through coordinates where a stone is placed.\n\nMore precisely, count the number of lattice points \\((x, y)\\) where no stone is placed, and there does **not** exist a finite sequence of integer pairs \\((x_0, y_0), \\ldots, (x_k, y_k)\\) that satisfies all of the following four conditions:\n1. \\((x_0, y_0) = (x, y)\\).\n2. \\((x_k, y_k) = (-1, -1)\\).\n3. \\(|x_i - x_{i+1}| + |y_i - y_{i+1}| = 1\\) for all \\(0 \\leq i < k\\).\n4. There is no stone at \\((x_i, y_i)\\) for all \\(0 \\leq i \\leq k\\).\n\nConstraints:\n- \\(0 \\leq N \\leq 2 \\times 10^5\\)\n- \\(0 \\leq X_i, Y_i \\leq 2 \\times 10^5\\)\n- The pairs \\((X_i, Y_i)\\) are distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nX_1 Y_1\n\\vdots\nX_N Y_N\n```\n\nOutput:\nPrint the number of lattice points that satisfy the conditions.\n\nSample Input 1:\n```\n5\n1 0\n0 1\n2 3\n1 2\n2 1\n```\n\nSample Output 1:\n```\n1\n```\nIt is impossible to reach \\((-1, -1)\\) from \\((1, 1)\\).\n\nSample Input 2:\n```\n0\n```\n\nSample Output 2:\n```\n0\n```\nThere may be cases where no stones are placed.\n\nSample Input 3:\n```\n22\n0 1\n0 2\n0 3\n1 0\n1 4\n2 0\n2 2\n2 4\n3 0\n3 1\n3 2\n3 4\n5 1\n5 2\n5 3\n6 0\n6 4\n7 0\n7 4\n8 1\n8 2\n8 3\n```\n\nSample Output 3:\n```\n6\n```\nThere are six such points: \\((6, 1), (6, 2), (6, 3), (7, 1), (7, 2), (7, 3)\\).\n\nSolution:\n\n```python\n'''\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nG - Go Territory Editorial by en_translator\n\nWe will consider a grid instead of a coordinate plane. We call those cells reachable to (-1,-1) \u201cinside,\u201d \nand unreachable \u201coutside.\u201d We first consider the case where the stones are connected in eight directions. \nBy enumerating eight cells around each cell beforehand, one can easily determine if these cells are inside or \noutside easily with BFS (Breadth First Search). The top-left cell is always outside; by performing BFS from this cell \nin four directions, one can reach all cells outside.\n\nExample: black cells represent lattice points with stones. Then, inspect each row. If there is a segment with \n\u201coutside stone inside \u2026 inside stone outside,\u201d then that segment can be counted as \u201cinside\u201d to count \u201cinside\u201d points. \nBeware of cases with consecutive stones, or stones between inside cells.\n\nNow we consider disconnected cases. It may seem we can consider each connected component independently, \nbut note that there may be a nested structure. After performing BFS for each connected component and determining whether \neach cell is outside or inside, when scanning the entire row, there may be parts like \n\u201coutside stone inside \u2026\u2026 outside stone inside \u2026\u2026 inside stone outside \u2026\u2026 inside stone outside,\u201d where some cells \ninside are labeled outside.\n\nEvery time you encounter \u201coutside, one or more stones, inside,\u201d the nest increases by one; for \n\u201cinside, one or more stones, outside,\u201d it decreases by one. By using this method to manage how many times the current \nposition is surrounded, one can handle this issue. Also, if there are different connected components sufficiently close \nto each other, the label (outside/inside) might be overwritten. This can be avoided by defining that stones are connected \nif the Chebyshev distance is two or less, instead of being eight-adjacent.\n'''\n```\n\n \n\nSimilar Problem 3 \n\n Problem Statement:\n\nCertainly! Here is a cleaned and structured version of the problem statement:\n\n---\n\n**Score**: 250 points\n\n### Problem Statement\n\nThere are \\( N \\) dishes, and the \\( i \\)-th dish has a **sweetness** of \\( A_i \\) and a **saltiness** of \\( B_i \\).\n\nTakahashi plans to arrange these \\( N \\) dishes in any order he likes and eat them in that order. He will stop eating as soon as the total sweetness of the dishes he has eaten exceeds \\( X \\) or the total saltiness exceeds \\( Y \\).\n\nFind the minimum possible number of dishes that he will end up eating.\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq X, Y \\leq 2 \\times 10^{14} \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN X Y\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n4 7 18\n2 3 5 1\n8 8 1 4\n```\n\n### Sample Output 1\n\n```\n2\n```\n\n**Explanation**\n\nThe \\( i \\)-th dish will be denoted as dish \\( i \\). If he arranges the four dishes in the order \\( 2, 3, 1, 4 \\), as soon as he eats dishes \\( 2 \\) and \\( 3 \\), their total sweetness is 8, which is greater than 7. Therefore, in this case, he will end up eating two dishes. The number of dishes he will eat cannot be 1 or less, so print 2.\n\n### Sample Input 2\n\n```\n5 200000000000000 200000000000000\n1 1 1 1 1\n2 2 2 2 2\n```\n\n### Sample Output 2\n\n```\n5\n```\n\n### Sample Input 3\n\n```\n8 30 30\n1 2 3 4 5 6 7 8\n8 7 6 5 4 3 2 1\n```\n\n### Sample Output 3\n\n```\n6\n```\n\n--- \n\nThis is a structured and detailed explanation capturing the essence and rules of the problem.\n\nSolution:\n\nHere is a clean version of the provided editorial:\n\n**C - Minimum Glutton Editorial**\n\nConsider the following Problem A and Problem B:\n- **Problem A**: Arrange the \\(N\\) dishes and eat them in order until the total sweetness exceeds \\(X\\). What is the minimum number of dishes eaten?\n- **Problem B**: Arrange the \\(N\\) dishes and eat them in order until the total saltiness exceeds \\(Y\\). What is the minimum number of dishes eaten?\n\nFor a fixed arrangement, once the stopping condition in Problem A or Problem B is satisfied, the original problem's condition is satisfied. Thus, the answer to the original problem equals the minimum of the answers to Problems A and B. Sort the dishes in descending order of \\(A_i\\) and \\(B_i\\), respectively, and eat them from the first in order to achieve the minimum value.\n\n**Sample code:**\n```python\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort(reverse=True)\nb.sort(reverse=True)\n\nc1 = 0\nc2 = 0\nsx = 0\nsy = 0\n\nfor ai in a:\n    sx += ai\n    c1 += 1\n    if sx > x:\n        break\n\nfor bi in b:\n    sy += bi\n    c2 += 1\n    if sy > y:\n        break\n\nprint(min(c1, c2))\n```\n \n\n", "problem_ids": ["arc181_e", "abc361_g", "abc364_c"]}}