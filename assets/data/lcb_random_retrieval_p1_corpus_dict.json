{"1873_A": {"text": "", "problem_ids": []}, "1873_B": {"text": "", "problem_ids": []}, "1873_D": {"text": "", "problem_ids": []}, "1883_B": {"text": "", "problem_ids": []}, "1883_C": {"text": "", "problem_ids": []}, "1899_A": {"text": "", "problem_ids": []}, "1899_B": {"text": "", "problem_ids": []}, "1899_C": {"text": "", "problem_ids": []}, "1899_D": {"text": "", "problem_ids": []}, "2727": {"text": "Similar Problem 1 \n\n Problem:\n\nA complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\nDesign an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.\nImplement the CBTInserter class:\n\nCBTInserter(TreeNode root) Initializes the data structure with the root of the complete binary tree.\nint insert(int v) Inserts a TreeNode into the tree with value Node.val == val so that the tree remains complete, and returns the value of the parent of the inserted TreeNode.\nTreeNode get_root() Returns the root node of the tree.\n\n\u00a0\nExample 1:\n\n\nInput\n[\"CBTInserter\", \"insert\", \"insert\", \"get_root\"]\n[[[1, 2]], [3], [4], []]\nOutput\n[null, 1, 2, [1, 2, 3, 4]]\n\nExplanation\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3); // return 1\ncBTInserter.insert(4); // return 2\ncBTInserter.get_root(); // return [1, 2, 3, 4]\n\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree will be in the range [1, 1000].\n0 <= Node.val <= 5000\nroot is a complete binary tree.\n0 <= val <= 5000\nAt most 104 calls will be made to insert and get_root. Explanation:\n\nSolution 1: BFS\nWe can use an array $tree$ to store all nodes of the complete binary tree. During initialization, we use a queue $q$ to perform level-order traversal of the given tree and store all nodes into the array $tree$.\nWhen inserting a node, we can find the parent node $p$ of the new node through the array $tree$. Then we create a new node $node$, insert it into the array $tree$, and make $node$ as the left child or right child of $p$. Finally, we return the value of $p$.\nWhen getting the root node, we directly return the first element of the array $tree$.\nIn terms of time complexity, it takes $O(n)$ time for initialization, and the time complexity for inserting a node and getting the root node are both $O(1)$. The space complexity is $O(n)$, where $n$ is the number of nodes in the tree. \n\n", "problem_ids": ["complete-binary-tree-inserter"]}, "2728": {"text": "Similar Problem 1 \n\n Problem:\n\nYou have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\nFor each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\nGiven an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\n\u00a0\nExample 1:\n\nInput: machines = [1,0,5]\nOutput: 3\nExplanation:\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\nExample 2:\n\nInput: machines = [0,3,0]\nOutput: 2\nExplanation:\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\nExample 3:\n\nInput: machines = [0,2,0]\nOutput: -1\nExplanation:\nIt's impossible to make all three washing machines have the same number of dresses.\n\n\u00a0\nConstraints:\n\nn == machines.length\n1 <= n <= 104\n0 <= machines[i] <= 105 Explanation:\n\nSolution 1: Greedy\nIf the total number of clothes in the washing machines cannot be divided evenly by the number of washing machines, it is impossible to make the number of clothes in each washing machine equal, so we directly return $-1$.\nOtherwise, suppose the total number of clothes in the washing machines is $s$, then the number of clothes in each washing machine will eventually become $k = s / n$.\nWe define $a_i$ as the difference between the number of clothes in the $i$-th washing machine and $k$, that is, $a_i = \\textit{machines}[i] - k$. If $a_i > 0$, it means that the $i$-th washing machine has extra clothes and needs to pass them to the adjacent washing machine; if $a_i < 0$, it means that the $i$-th washing machine lacks clothes and needs to get them from the adjacent washing machine.\nWe define the sum of the differences in the number of clothes in the first $i$ washing machines as $s_i = \\sum_{j=0}^{i-1} a_j$. If we regard the first $i$ washing machines as one group and the remaining washing machines as another group. Then if $s_i$ is a positive number, it means that the first group of washing machines has extra clothes and needs to pass them to the second group of washing machines; if $s_i$ is a negative number, it means that the first group of washing machines lacks clothes and needs to get them from the second group of washing machines.\nThen there are the following two situations:\n\nThe maximum number of times clothes need to be moved between the two groups is $\\max_{i=0}^{n-1} \\lvert s_i \\rvert$;\nA washing machine in the group has too many clothes and needs to move clothes to both sides, the maximum number of times clothes need to be moved is $\\max_{i=0}^{n-1} a_i$.\n\nWe take the maximum of the two.\nThe time complexity is $O(n)$, where $n$ is the number of washing machines. The space complexity is $O(1)$. \n\n", "problem_ids": ["super-washing-machines"]}, "2730": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\n\u00a0\nExample 1:\n\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= n <= 500\n-500 <= Node.val <= 500\n1 <= left <= right <= n\n\n\u00a0\nFollow up: Could you do it in one pass? Explanation:\n\nSolution 1: Simulation\nDefine a dummy head node dummy, pointing to the head node head of the linked list. Then define a pointer pre pointing to dummy. Start traversing the linked list from the dummy head node. When you traverse to the left node, point pre to this node. Then start traversing right - left + 1 times from this node, and insert the nodes you traverse into the back of pre. Finally, return dummy.next.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the linked list. \n\n", "problem_ids": ["reverse-linked-list-ii"]}, "2754": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.\n\u00a0\nExample 1:\n\nInput: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.\n\nExample 2:\n\nInput: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2.\n\n\u00a0\nConstraints:\n\n1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107 Explanation:\n\nSolution 1: Binary Search\nWe notice that if we can complete at least $totalTrips$ trips in $t$ time, then we can also complete at least $totalTrips$ trips in $t' > t$ time. Therefore, we can use the method of binary search to find the smallest $t$.\nWe define the left boundary of the binary search as $l = 1$, and the right boundary as $r = \\min(time) \\times totalTrips$. For each binary search, we calculate the middle value $\\textit{mid} = \\frac{l + r}{2}$, and then calculate the number of trips that can be completed in $\\textit{mid}$ time. If this number is greater than or equal to $totalTrips$, then we reduce the right boundary to $\\textit{mid}$, otherwise we increase the left boundary to $\\textit{mid} + 1$.\nFinally, return the left boundary.\nThe time complexity is $O(n \\times \\log(m \\times k))$, where $n$ and $k$ are the length of the array $time$ and $totalTrips$ respectively, and $m$ is the minimum value in the array $time$. The space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-time-to-complete-trips"]}, "2755": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a number n between 0 and 230 - 1 (both inclusive) that you have to find.\nThere is a pre-defined API int commonBits(int num) that helps you with your mission. But here is the challenge, every time you call this function, n changes in some way. But keep in mind, that you have to find the initial value of n.\ncommonBits(int num) acts as follows:\n\nCalculate count which is the number of bits where both n and num have the same value in that position of their binary representation.\nn = n XOR num\nReturn count.\n\nReturn the number n.\nNote: In this world, all numbers are between 0 and 230 - 1 (both inclusive), thus for counting common bits, we see only the first 30 bits of those numbers.\n\u00a0\nConstraints:\n\n0 <= n <= 230 - 1\n0 <= num <= 230 - 1\nIf you ask for some num out of the given range, the output wouldn't be reliable. Explanation:\n\nSolution 1: Bit Manipulation\nBased on the problem description, we observe that:\n\nIf we call the commonBits function twice with the same number, the value of $n$ will not change.\nIf we call commonBits(1 << i), the $i$-th bit of $n$ will be flipped, i.e., if the $i$-th bit of $n$ is $1$, it will become $0$ after the call, and vice versa.\n\nTherefore, for each bit $i$, we can call commonBits(1 << i) twice, denoted as count1 and count2 respectively. If count1 > count2, it means the $i$-th bit of $n$ is $1$, otherwise it is $0$.\nThe time complexity is $O(\\log n)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["guess-the-number-using-bitwise-questions-ii"]}, "2756": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times:\n\nFind a non-negative integer k < 2maximumBit such that nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to the ith query.\nRemove the last element from the current array nums.\n\nReturn an array answer, where answer[i] is the answer to the ith query.\n\u00a0\nExample 1:\n\nInput: nums = [0,1,1,3], maximumBit = 2\nOutput: [0,3,2,3]\nExplanation: The queries are answered as follows:\n1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.\n4th query: nums = [0], k = 3 since 0 XOR 3 = 3.\n\nExample 2:\n\nInput: nums = [2,3,4,7], maximumBit = 3\nOutput: [5,2,6,5]\nExplanation: The queries are answered as follows:\n1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.\n4th query: nums = [2], k = 5 since 2 XOR 5 = 7.\n\nExample 3:\n\nInput: nums = [0,1,2,2,5,7], maximumBit = 3\nOutput: [4,3,6,4,6,7]\n\n\u00a0\nConstraints:\n\nnums.length == n\n1 <= n <= 105\n1 <= maximumBit <= 20\n0 <= nums[i] < 2maximumBit\nnums\u200b\u200b\u200b is sorted in ascending order. Explanation:\n\nSolution 1: Bitwise Operation + Enumeration\nFirst, we preprocess the XOR sum $xs$ of the array nums, i.e., $xs=nums[0] \\oplus nums[1] \\oplus \\cdots \\oplus nums[n-1]$.\nNext, we enumerate each element $x$ in the array nums from back to front. The current XOR sum is $xs$. We need to find a number $k$ such that the value of $xs \\oplus k$ is as large as possible, and $k \\lt 2^{maximumBit}$.\nThat is to say, we start from the $maximumBit - 1$ bit of $xs$ and enumerate to the lower bit. If a bit of $xs$ is $0$, then we set the corresponding bit of $k$ to $1$. Otherwise, we set the corresponding bit of $k$ to $0$. In this way, the final $k$ is the answer to each query. Then, we update $xs$ to $xs \\oplus x$ and continue to enumerate the next element.\nThe time complexity is $O(n \\times m)$, where $n$ and $m$ are the values of the array nums and maximumBit respectively. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-xor-for-each-query"]}, "2757": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer n and a 2D integer array queries.\nThere are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1.\nqueries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1.\nThere are no two queries such that queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1].\nReturn an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.\n\u00a0\nExample 1:\n\nInput: n = 5, queries = [[2,4],[0,2],[0,4]]\nOutput: [3,2,1]\nExplanation: \n\nAfter the addition of the road from 2 to 4, the length of the shortest path from 0 to 4 is 3.\n\nAfter the addition of the road from 0 to 2, the length of the shortest path from 0 to 4 is 2.\n\nAfter the addition of the road from 0 to 4, the length of the shortest path from 0 to 4 is 1.\n\nExample 2:\n\nInput: n = 4, queries = [[0,3],[0,2]]\nOutput: [1,1]\nExplanation:\n\nAfter the addition of the road from 0 to 3, the length of the shortest path from 0 to 3 is 1.\n\nAfter the addition of the road from 0 to 2, the length of the shortest path remains 1.\n\n\u00a0\nConstraints:\n\n3 <= n <= 105\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= queries[i][0] < queries[i][1] < n\n1 < queries[i][1] - queries[i][0]\nThere are no repeated roads among the queries.\nThere are no two queries such that i != j and queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]. Explanation:\n\nSolution 1: Greedy + Recording Jump Positions\nWe define an array $\\textit{nxt}$ of length $n - 1$, where $\\textit{nxt}[i]$ represents the next city that can be reached from city $i$. Initially, $\\textit{nxt}[i] = i + 1$.\nFor each query $[u, v]$, if $u'$ and $v'$ have already been connected before, and $u' \\leq u < v \\leq v'$, then we can skip this query. Otherwise, we need to set the next city number for cities from $\\textit{nxt}[u]$ to $\\textit{nxt}[v - 1]$ to $0$, and set $\\textit{nxt}[u]$ to $v$.\nDuring this process, we maintain a variable $\\textit{cnt}$, which represents the length of the shortest path from city $0$ to city $n - 1$. Initially, $\\textit{cnt} = n - 1$. Each time we set the next city number for cities in $[\\textit{nxt}[u], \\textit{v})$ to $0$, $\\textit{cnt}$ decreases by $1$.\nTime complexity is $O(n + q)$, and space complexity is $O(n)$. Here, $n$ and $q$ are the number of cities and the number of queries, respectively. \n\n", "problem_ids": ["shortest-distance-after-road-addition-queries-ii"]}, "2777": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: Tweets\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| tweet_id    | int     |\n| tweet_date  | date    |\n| tweet       | varchar |\n+-------------+---------+\ntweet_id is the primary key (column with unique values) for this table.\nEach row of this table contains user_id, tweet_id, tweet_date and tweet.\n\nWrite a solution to find the top 3 trending hashtags in February 2024. Every tweet may contain several hashtags.\nReturn the result table ordered by count of hashtag, hashtag in descending order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput:\nTweets table:\n\n+---------+----------+------------------------------------------------------------+------------+\n| user_id | tweet_id | tweet                                                      | tweet_date |\n+---------+----------+------------------------------------------------------------+------------+\n| 135     | 13       | Enjoying a great start to the day. #HappyDay #MorningVibes | 2024-02-01 |\n| 136     | 14       | Another #HappyDay with good vibes! #FeelGood               | 2024-02-03 |\n| 137     | 15       | Productivity peaks! #WorkLife #ProductiveDay               | 2024-02-04 |\n| 138     | 16       | Exploring new tech frontiers. #TechLife #Innovation        | 2024-02-04 |\n| 139     | 17       | Gratitude for today's moments. #HappyDay #Thankful         | 2024-02-05 |\n| 140     | 18       | Innovation drives us. #TechLife #FutureTech                | 2024-02-07 |\n| 141     | 19       | Connecting with nature's serenity. #Nature #Peaceful       | 2024-02-09 |\n+---------+----------+------------------------------------------------------------+------------+\n \nOutput:\n\n+-----------+-------+\n| hashtag   | count |\n+-----------+-------+\n| #HappyDay | 3     |\n| #TechLife | 2     |\n| #WorkLife | 1     |\n+-----------+-------+\n\n\nExplanation:\n\n#HappyDay: Appeared in tweet IDs 13, 14, and 17, with a total count of 3 mentions.\n#TechLife: Appeared in tweet IDs 16 and 18, with a total count of 2 mentions.\n#WorkLife: Appeared in tweet ID 15, with a total count of 1 mention.\n\nNote: Output table is sorted in descending order by count and hashtag respectively. Explanation:\n\nSolution 1: Regular Expression Matching\nWe can use regular expressions to match all tags in each tweet, and then count the occurrence of each tag. Finally, we can sort the tags in descending order by the number of occurrences. If the number of occurrences is the same, we sort them in descending order by the tag name, and return the top three tags. \n\n", "problem_ids": ["find-trending-hashtags-ii"]}, "2779": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a number n that you have to find.\nThere is also a pre-defined API int commonSetBits(int num), which returns the number of bits where both n and num are 1 in that position of their binary representation. In other words, it returns the number of set bits in n & num, where & is the bitwise AND operator.\nReturn the number n.\n\u00a0\nExample 1: \n\nInput:   n = 31 \nOutput:   31 \nExplanation:  It can be proven that it's possible to find 31 using the provided API.\n\nExample 2: \n\nInput:   n = 33 \nOutput:   33 \nExplanation:  It can be proven that it's possible to find 33 using the provided API.\n\n\u00a0\nConstraints:\n\n1 <= n <= 230 - 1\n0 <= num <= 230 - 1\nIf you ask for some num out of the given range, the output wouldn't be reliable. Explanation:\n\nSolution 1: Enumeration\nWe can enumerate the powers of 2, and then call the commonSetBits method. If the return value is greater than 0, it means that the corresponding bit in the binary representation of n is 1.\nThe time complexity is $O(\\log n)$, where $n \\le 2^{30}$ in this problem. The space complexity is $O(1)$. \n\n", "problem_ids": ["guess-the-number-using-bitwise-questions-i"]}, "2784": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two integers, m and k, and a stream of integers. You are tasked to implement a data structure that calculates the MKAverage for the stream.\nThe MKAverage can be calculated using these steps:\n\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\nRemove the smallest k elements and the largest k elements from the container.\nCalculate the average value for the rest of the elements rounded down to the nearest integer.\n\nImplement the MKAverage class:\n\nMKAverage(int m, int k) Initializes the MKAverage object with an empty stream and the two integers m and k.\nvoid addElement(int num) Inserts a new element num into the stream.\nint calculateMKAverage() Calculates and returns the MKAverage for the current stream rounded down to the nearest integer.\n\n\u00a0\nExample 1:\n\nInput\n[\"MKAverage\", \"addElement\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"addElement\", \"addElement\", \"calculateMKAverage\"]\n[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]\nOutput\n[null, null, null, -1, null, 3, null, null, null, 5]\n\nExplanation\nMKAverage obj = new MKAverage(3, 1); \nobj.addElement(3);        // current elements are [3]\nobj.addElement(1);        // current elements are [3,1]\nobj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist.\nobj.addElement(10);       // current elements are [3,1,10]\nobj.calculateMKAverage(); // The last 3 elements are [3,1,10].\n                          // After removing smallest and largest 1 element the container will be [3].\n                          // The average of [3] equals 3/1 = 3, return 3\nobj.addElement(5);        // current elements are [3,1,10,5]\nobj.addElement(5);        // current elements are [3,1,10,5,5]\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\n                          // After removing smallest and largest 1 element the container will be [5].\n                          // The average of [5] equals 5/1 = 5, return 5\n\n\u00a0\nConstraints:\n\n3 <= m <= 105\n1 <= k*2 < m\n1 <= num <= 105\nAt most 105 calls will be made to addElement and calculateMKAverage. Explanation:\n\nSolution 1: Ordered Set + Queue\nWe can maintain the following data structures or variables:\n\nA queue $q$ of length $m$, where the head of the queue is the earliest added element, and the tail of the queue is the most recently added element;\nThree ordered sets, namely $lo$, $mid$, $hi$, where $lo$ and $hi$ store the smallest $k$ elements and the largest $k$ elements respectively, and $mid$ stores the remaining elements;\nA variable $s$, maintaining the sum of all elements in $mid$;\nSome programming languages (such as Java, Go) additionally maintain two variables $size1$ and $size3$, representing the number of elements in $lo$ and $hi$ respectively.\n\nWhen calling the $addElement(num)$ function, perform the following operations in order:\n\nIf $lo$ is empty, or $num \\leq max(lo)$, then add $num$ to $lo$; otherwise if $hi$ is empty, or $num \\geq min(hi)$, then add $num$ to $hi$; otherwise add $num$ to $mid$, and add the value of $num$ to $s$.\nNext, add $num$ to the queue $q$. If the length of the queue $q$ is greater than $m$ at this time, remove the head element $x$ from the queue $q$, then choose one of $lo$, $mid$ or $hi$ that contains $x$, and remove $x$ from this set. If the set is $mid$, subtract the value of $x$ from $s$.\nIf the length of $lo$ is greater than $k$, then repeatedly remove the maximum value $max(lo)$ from $lo$, add $max(lo)$ to $mid$, and add the value of $max(lo)$ to $s$.\nIf the length of $hi$ is greater than $k$, then repeatedly remove the minimum value $min(hi)$ from $hi$, add $min(hi)$ to $mid$, and add the value of $min(hi)$ to $s$.\nIf the length of $lo$ is less than $k$ and $mid$ is not empty, then repeatedly remove the minimum value $min(mid)$ from $mid$, add $min(mid)$ to $lo$, and subtract the value of $min(mid)$ from $s$.\nIf the length of $hi$ is less than $k$ and $mid$ is not empty, then repeatedly remove the maximum value $max(mid)$ from $mid$, add $max(mid)$ to $hi$, and subtract the value of $max(mid)$ from $s$.\n\nWhen calling the $calculateMKAverage()$ function, if the length of $q$ is less than $m$, return $-1$, otherwise return $\\frac{s}{m - 2k}$.\nIn terms of time complexity, each call to the $addElement(num)$ function has a time complexity of $O(\\log m)$, and each call to the $calculateMKAverage()$ function has a time complexity of $O(1)$. The space complexity is $O(m)$. \n\n", "problem_ids": ["finding-mk-average"]}, "2785": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:\n\nLet i0, i1, ... ,ik be the indices of the heroes in a group. Then, the power of this group is max(nums[i0], nums[i1], ... ,nums[ik])2 * min(nums[i0], nums[i1], ... ,nums[ik]).\n\nReturn the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: nums = [2,1,4]\nOutput: 141\nExplanation: \n1st\u00a0group: [2] has power = 22\u00a0* 2 = 8.\n2nd\u00a0group: [1] has power = 12 * 1 = 1. \n3rd\u00a0group: [4] has power = 42 * 4 = 64. \n4th\u00a0group: [2,1] has power = 22 * 1 = 4. \n5th\u00a0group: [2,4] has power = 42 * 2 = 32. \n6th\u00a0group: [1,4] has power = 42 * 1 = 16. \n\u200b\u200b\u200b\u200b\u200b\u200b\u200b7th\u00a0group: [2,1,4] has power = 42\u200b\u200b\u200b\u200b\u200b\u200b\u200b * 1 = 16. \nThe sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.\n\n\nExample 2:\n\nInput: nums = [1,1,1]\nOutput: 7\nExplanation: A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: Sorting + Mathematics\nWe notice that the problem involves the maximum and minimum values of a subsequence, and the order of elements in the array does not affect the final result. Therefore, we can sort the array first.\nNext, we enumerate each element as the minimum value of the subsequence. Let's denote each element of the array as $a_1, a_2, \\cdots, a_n$. The contribution of the subsequence with $a_i$ as the minimum value is:\n$$\na_i \\times (a_{i}^{2} + a_{i+1}^2 + 2 \\times a_{i+2}^2 + 4 \\times a_{i+3}^2 + \\cdots + 2^{n-i-1} \\times a_n^2)\n$$\nWe notice that each $a_i$ will be multiplied by $a_i^2$, which we can directly add to the answer. For the remaining part, we can maintain it with a variable $p$, initially set to $0$.\nThen, we enumerate $a_i$ from right to left. Each time, we add $a_i \\times p$ to the answer, and then set $p = p \\times 2 + a_i^2$.\nAfter enumerating all $a_i$, return the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["power-of-heroes"]}, "2786": {"text": "Similar Problem 1 \n\n Problem:\n\nA string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.\nFor example, a string such as \"substitution\" could be abbreviated as (but not limited to):\n\n\"s10n\" (\"s ubstitutio n\")\n\"sub4u4\" (\"sub stit u tion\")\n\"12\" (\"substitution\")\n\"su3i1u2on\" (\"su bst i t u ti on\")\n\"substitution\" (no substrings replaced)\n\nThe following are not valid abbreviations:\n\n\"s55n\" (\"s ubsti tutio n\", the replaced substrings are adjacent)\n\"s010n\" (has leading zeros)\n\"s0ubstitution\" (replaces an empty substring)\n\nGiven a string word and an abbreviation abbr, return whether the string matches the given abbreviation.\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nExample 1:\n\nInput: word = \"internationalization\", abbr = \"i12iz4n\"\nOutput: true\nExplanation: The word \"internationalization\" can be abbreviated as \"i12iz4n\" (\"i nternational iz atio n\").\n\nExample 2:\n\nInput: word = \"apple\", abbr = \"a2e\"\nOutput: false\nExplanation: The word \"apple\" cannot be abbreviated as \"a2e\".\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 20\nword consists of only lowercase English letters.\n1 <= abbr.length <= 10\nabbr consists of lowercase English letters and digits.\nAll the integers in abbr will fit in a 32-bit integer. Explanation:\n\nSolution 1: Simulation\nWe can directly simulate character matching and replacement.\nAssume the lengths of the string $word$ and the string $abbr$ are $m$ and $n$ respectively. We use two pointers $i$ and $j$ to point to the initial positions of the string $word$ and the string $abbr$ respectively, and use an integer variable $x$ to record the current matched number in $abbr$.\nLoop to match each character of the string $word$ and the string $abbr$:\nIf the character $abbr[j]$ pointed by the pointer $j$ is a number, if $abbr[j]$ is '0' and $x$ is $0$, it means that the number in $abbr$ has leading zeros, so it is not a valid abbreviation, return false; otherwise, update $x$ to $x \\times 10 + abbr[j] - '0'$.\nIf the character $abbr[j]$ pointed by the pointer $j$ is not a number, then we move the pointer $i$ forward by $x$ positions at this time, and then reset $x$ to $0$. If $i \\geq m$ or $word[i] \\neq abbr[j]$ at this time, it means that the two strings cannot match, return false; otherwise, move the pointer $i$ forward by $1$ position.\nThen we move the pointer $j$ forward by $1$ position, repeat the above process, until $i$ exceeds the length of the string $word$ or $j$ exceeds the length of the string $abbr$.\nFinally, if $i + x$ equals $m$ and $j$ equals $n$, it means that the string $word$ can be abbreviated as the string $abbr$, return true; otherwise return false.\nThe time complexity is $O(m + n)$, where $m$ and $n$ are the lengths of the string $word$ and the string $abbr$ respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["valid-word-abbreviation"]}, "2791": {"text": "Similar Problem 1 \n\n Problem:\n\nThe Tribonacci sequence Tn is defined as follows:\u00a0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.\n\u00a0\nExample 1:\n\n\nInput: n = 4\n\nOutput: 4\n\nExplanation:\n\nT_3 = 0 + 1 + 1 = 2\n\nT_4 = 1 + 1 + 2 = 4\n\n\nExample 2:\n\n\nInput: n = 25\n\nOutput: 1389537\n\n\n\u00a0\nConstraints:\n\n0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1. Explanation:\n\nSolution 1: Dynamic Programming\nAccording to the recurrence relation given in the problem, we can use dynamic programming to solve it.\nWe define three variables $a$, $b$, $c$ to represent $T_{n-3}$, $T_{n-2}$, $T_{n-1}$, respectively, with initial values of $0$, $1$, $1$.\nThen we decrease $n$ to $0$, updating the values of $a$, $b$, $c$ each time, until $n$ is $0$, at which point the answer is $a$.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the given integer. \n\n", "problem_ids": ["n-th-tribonacci-number"]}, "2792": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two integers n and k.\nInitially, you start with an array a of n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you simultaneously update each element to be the sum of all its preceding elements plus the element itself. For example, after one second, a[0] remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2], and so on.\nReturn the value of a[n - 1] after k seconds.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: n = 4, k = 5\nOutput: 56\nExplanation:\n\n\n\nSecond\nState After\n\n\n0\n[1,1,1,1]\n\n\n1\n[1,2,3,4]\n\n\n2\n[1,3,6,10]\n\n\n3\n[1,4,10,20]\n\n\n4\n[1,5,15,35]\n\n\n5\n[1,6,21,56]\n\n\n\n\nExample 2:\n\nInput: n = 5, k = 3\nOutput: 35\nExplanation:\n\n\n\nSecond\nState After\n\n\n0\n[1,1,1,1,1]\n\n\n1\n[1,2,3,4,5]\n\n\n2\n[1,3,6,10,15]\n\n\n3\n[1,4,10,20,35]\n\n\n\n\n\u00a0\nConstraints:\n\n1 <= n, k <= 1000 Explanation:\n\nSolution 1: Simulation\nWe notice that the range of the integer $n$ is $1 \\leq n \\leq 1000$, so we can directly simulate this process.\nWe define an array $a$ of length $n$ and initialize all elements to $1$. Then we simulate the process for $k$ seconds, updating the elements of array $a$ every second until $k$ seconds have passed.\nFinally, we return $a[n - 1]$.\nThe time complexity is $O(n \\times k)$, and the space complexity is $O(n)$. Where $n$ is the length of the array $a$. \n\n", "problem_ids": ["find-the-n-th-value-after-k-seconds"]}, "2800": {"text": "Similar Problem 1 \n\n Problem:\n\nWe are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\u00a0\nExample 1:\n\nInput: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].\n\nExample 2:\n\nInput: hours = [6,6,6]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= hours.length <= 104\n0 <= hours[i] <= 16 Explanation:\n\nSolution 1: Prefix Sum + Hash Table\nWe can use the idea of prefix sum, maintaining a variable $s$, which represents the difference between the number of \"tiring days\" and \"non-tiring days\" from index $0$ to the current index. If $s$ is greater than $0$, it means that the segment from index $0$ to the current index is a \"well-performing time period\". In addition, we use a hash table $pos$ to record the first occurrence index of each $s$.\nNext, we traverse the hours array, for each index $i$:\n\nIf $hours[i] > 8$, we increment $s$ by $1$, otherwise we decrement $s$ by $1$.\nIf $s > 0$, it means that the segment from index $0$ to the current index $i$ is a \"well-performing time period\", we update the result $ans = i + 1$. Otherwise, if $s - 1$ is in the hash table $pos$, let $j = pos[s - 1]$, it means that the segment from index $j + 1$ to the current index $i$ is a \"well-performing time period\", we update the result $ans = \\max(ans, i - j)$.\nThen, if $s$ is not in the hash table $pos$, we record $pos[s] = i$.\n\nAfter the traversal, return the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the hours array. \n\n", "problem_ids": ["longest-well-performing-interval"]}, "2802": {"text": "Similar Problem 1 \n\n Problem:\n\nIn an infinite binary tree where every node has two children, the nodes are labelled in row order.\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\nGiven the label of a node in this tree, return the labels in the path from the root of the tree to the\u00a0node with that label.\n\u00a0\nExample 1:\n\nInput: label = 14\nOutput: [1,3,4,14]\n\nExample 2:\n\nInput: label = 26\nOutput: [1,2,6,10,26]\n\n\u00a0\nConstraints:\n\n1 <= label <= 10^6 Explanation:\n\nSolution 1: Mathematics\nFor a complete binary tree, the number of nodes in the $i$th row is $2^{i-1}$, and the range of node labels in the $i$th row is $[2^{i-1}, 2^i - 1]$. In the problem, for odd-numbered rows, the nodes are labeled from left to right, while for even-numbered rows, the nodes are labeled from right to left. Therefore, for the node $label$ in the $i$th row, its complementary node label is $2^{i-1} + 2^i - 1 - label$. So the actual parent node label of node $label$ is $(2^{i-1} + 2^i - 1 - label) / 2$. We can find the path from the root node to node $label$ by continuously finding the complementary node label and the parent node label until we reach the root node.\nFinally, we need to reverse the path, because the problem requires the path from the root node to node $label$.\nThe time complexity is $O(\\log n)$, where $n$ is the label of the node. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["path-in-zigzag-labelled-binary-tree"]}, "2808": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven three integer arrays arr1, arr2 and arr3\u00a0sorted in strictly increasing order, return a sorted array of only\u00a0the\u00a0integers that appeared in all three arrays.\n\u00a0\nExample 1:\n\nInput: arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8]\nOutput: [1,5]\nExplanation: Only 1 and 5 appeared in the three arrays.\n\nExample 2:\n\nInput: arr1 = [197,418,523,876,1356], arr2 = [501,880,1593,1710,1870], arr3 = [521,682,1337,1395,1764]\nOutput: []\n\n\u00a0\nConstraints:\n\n1 <= arr1.length, arr2.length, arr3.length <= 1000\n1 <= arr1[i], arr2[i], arr3[i] <= 2000 Explanation:\n\nSolution 1: Counting\nTraverse the three arrays, count the occurrence of each number, then traverse any one of the arrays. If the count of a number is $3$, add it to the result array.\nThe time complexity is $O(n)$, and the space complexity is $O(m)$. Here, $n$ and $m$ are the length of the array and the range of numbers in the array, respectively. \n\n", "problem_ids": ["intersection-of-three-sorted-arrays"]}, "2810": {"text": "Similar Problem 1 \n\n Problem:\n\nThere are n windows open numbered from 1 to n, we want to simulate using alt + tab to navigate between the windows.\nYou are given an array windows which contains the initial order of the windows (the first element is at the top and the last one is at the bottom).\nYou are also given an array queries where for each query, the window queries[i] is brought to the top.\nReturn the final state of the array windows.\n\u00a0\nExample 1:\n\nInput: windows = [1,2,3], queries = [3,3,2]\nOutput: [2,3,1]\nExplanation:\nHere is the window array after each query:\n\nInitial order: [1,2,3]\nAfter the first query: [3,1,2]\nAfter the second query: [3,1,2]\nAfter the last query: [2,3,1]\n\n\nExample 2:\n\nInput: windows = [1,4,2,3], queries = [4,1,3]\nOutput: [3,1,4,2]\nExplanation:\nHere is the window array after each query:\n\nInitial order: [1,4,2,3]\nAfter the first query: [4,1,2,3]\nAfter the second query: [1,4,2,3]\nAfter the last query: [3,1,4,2]\n\n\n\u00a0\nConstraints:\n\n1 <= n == windows.length <= 105\nwindows is a permutation of [1, n].\n1 <= queries.length <= 105\n1 <= queries[i] <= n Explanation:\n\nSolution 1: Hash Table + Reverse Traversal\nAccording to the problem description, the later the query, the earlier it appears in the result. Therefore, we can traverse the $\\textit{queries}$ array in reverse order, using a hash table $\\textit{s}$ to record the windows that have already appeared. For each query, if the current window is not in the hash table, we add it to the answer array and also add it to the hash table. Finally, we traverse the $\\textit{windows}$ array again, adding the windows that are not in the hash table to the answer array.\nThe time complexity is $O(n + m)$, and the space complexity is $O(m)$. Here, $n$ and $m$ are the lengths of the $\\textit{windows}$ and $\\textit{queries}$ arrays, respectively. \n\n", "problem_ids": ["alt-and-tab-simulation"]}, "2811": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\u00a0\nExample 1:\n\nInput: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.\n\nExample 2:\n\nInput: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".\n\nExample 3:\n\nInput: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned.\n\n\u00a0\nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters. Explanation:\n\nSolution 1: Simulation\nWe iterate through the array words, for each string w, we determine if it is a palindrome. If it is, then we return w; otherwise, we continue to iterate.\nTo determine if a string is a palindrome, we can use two pointers, one pointing to the start and the other to the end of the string, moving towards the center, and checking if the corresponding characters are equal. If, after traversing the entire string, no unequal characters are found, then the string is a palindrome.\nThe time complexity is $O(L)$, where $L$ is the sum of the lengths of all strings in the array words. The space complexity is $O(1)$. \n\n", "problem_ids": ["find-first-palindromic-string-in-the-array"]}, "2812": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string word and an integer k.\nWe consider word to be k-special if |freq(word[i]) - freq(word[j])| <= k for all indices i and j in the string.\nHere, freq(x) denotes the frequency of the character x in word, and |y| denotes the absolute value of y.\nReturn the minimum number of characters you need to delete to make word k-special.\n\u00a0\nExample 1:\n\nInput: word = \"aabcaba\", k = 0\nOutput: 3\nExplanation: We can make word 0-special by deleting 2 occurrences of \"a\" and 1 occurrence of \"c\". Therefore, word becomes equal to \"baba\" where freq('a') == freq('b') == 2.\n\nExample 2:\n\nInput: word = \"dabdcbdcdcd\", k = 2\nOutput: 2\nExplanation: We can make word 2-special by deleting 1 occurrence of \"a\" and 1 occurrence of \"d\". Therefore, word becomes equal to \"bdcbdcdcd\" where freq('b') == 2, freq('c') == 3, and freq('d') == 4.\n\nExample 3:\n\nInput: word = \"aaabaaa\", k = 2\nOutput: 1\nExplanation: We can make word 2-special by deleting 1 occurrence of \"b\". Therefore, word becomes equal to \"aaaaaa\" where each letter's frequency is now uniformly 6.\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 105\n0 <= k <= 105\nword consists only of lowercase English letters. Explanation:\n\nSolution 1: Counting + Enumeration\nFirst, we can count the occurrence of each character in the string and put all the counts into an array $nums$. Since the string only contains lowercase letters, the length of the array $nums$ will not exceed $26$.\nNext, we can enumerate the minimum frequency $v$ of characters in the $K$ special strings within the range $[0,..n]$, and then use a function $f(v)$ to calculate the minimum number of deletions to adjust the frequency of all characters to $v$. The minimum value of all $f(v)$ is the answer.\nThe calculation method of function $f(v)$ is as follows:\nTraverse each element $x$ in the array $nums$. If $x < v$, it means that we need to delete all characters with a frequency of $x$, and the number of deletions is $x$. If $x > v + k$, it means that we need to adjust all characters with a frequency of $x$ to $v + k$, and the number of deletions is $x - v - k$. The sum of all deletion counts is the value of $f(v)$.\nThe time complexity is $O(n \\times |\\Sigma|)$, and the space complexity is $O(|\\Sigma|)$. Here, $n$ is the length of the string, and $|\\Sigma|$ is the size of the character set. In this problem, $|\\Sigma| = 26$. \n\n", "problem_ids": ["minimum-deletions-to-make-string-k-special"]}, "2816": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array of positive integers nums.\nYou have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.\nFor example, the binary representation of 5, which is \"101\", does not have any trailing zeros, whereas the binary representation of 4, which is \"100\", has two trailing zeros.\nReturn true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation \"110\" with one trailing zero.\n\nExample 2:\n\nInput: nums = [2,4,8,16]\nOutput: true\nExplanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation \"110\" with one trailing zero.\nOther possible ways to select elements to have trailing zeroes in the binary representation of their bitwise OR are: (2, 8), (2, 16), (4, 8), (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), and (2, 4, 8, 16).\n\nExample 3:\n\nInput: nums = [1,3,5,7,9]\nOutput: false\nExplanation: There is no possible way to select two or more elements to have trailing zeros in the binary representation of their bitwise OR.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 100\n1 <= nums[i] <= 100 Explanation:\n\nSolution 1: Counting Even Numbers\nAccording to the problem statement, if there are two or more elements in the array whose bitwise OR operation results in trailing zeros, then there must be at least two even numbers in the array. Therefore, we can count the number of even numbers in the array. If the count of even numbers is greater than or equal to $2$, then return true, otherwise return false.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["check-if-bitwise-or-has-trailing-zeros"]}, "2817": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array nums of even length. You have to split the array into two parts nums1 and nums2 such that:\n\nnums1.length == nums2.length == nums.length / 2.\nnums1 should contain distinct elements.\nnums2 should also contain distinct elements.\n\nReturn true if it is possible to split the array, and false otherwise.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,2,2,3,4]\nOutput: true\nExplanation: One of the possible ways to split nums is nums1 = [1,2,3] and nums2 = [1,2,4].\n\nExample 2:\n\nInput: nums = [1,1,1,1]\nOutput: false\nExplanation: The only possible way to split nums is nums1 = [1,1] and nums2 = [1,1]. Both nums1 and nums2 do not contain distinct elements. Therefore, we return false.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100\nnums.length % 2 == 0 \n1 <= nums[i] <= 100 Explanation:\n\nSolution 1: Counting\nAccording to the problem, we need to divide the array into two parts, and the elements in each part are all distinct. Therefore, we can count the occurrence of each element in the array. If an element appears three or more times, it cannot satisfy the problem's requirements. Otherwise, we can divide the array into two parts.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array. \n\n", "problem_ids": ["split-the-array"]}, "2819": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s consisting only of characters 'a' and 'b'\u200b\u200b\u200b\u200b.\nYou can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.\nReturn the minimum number of deletions needed to make s balanced.\n\u00a0\nExample 1:\n\nInput: s = \"aababbab\"\nOutput: 2\nExplanation: You can either:\nDelete the characters at 0-indexed positions 2 and 6 (\"aababbab\" -> \"aaabbb\"), or\nDelete the characters at 0-indexed positions 3 and 6 (\"aababbab\" -> \"aabbbb\").\n\nExample 2:\n\nInput: s = \"bbaaaaabb\"\nOutput: 2\nExplanation: The only solution is to delete the first two characters.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns[i] is\u00a0'a' or 'b'\u200b\u200b. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i]$ as the minimum number of characters to be deleted in the first $i$ characters to make the string balanced. Initially, $f[0]=0$. The answer is $f[n]$.\nWe traverse the string $s$, maintaining a variable $b$, which represents the number of character 'b' in the characters before the current position.\n\nIf the current character is 'b', it does not affect the balance of the first $i$ characters, so $f[i]=f[i-1]$, then we update $b \\leftarrow b+1$.\nIf the current character is 'a', we can choose to delete the current character, so $f[i]=f[i-1]+1$; or we can choose to delete the previous character 'b', so $f[i]=b$. Therefore, we take the minimum of the two, that is, $f[i]=\\min(f[i-1]+1,b)$.\n\nIn summary, we can get the state transition equation:\n$$\nf[i]=\\begin{cases}\nf[i-1], & s[i-1]='b'\\\n\\min(f[i-1]+1,b), & s[i-1]='a'\n\\end{cases}\n$$\nThe final answer is $f[n]$.\nWe notice that the state transition equation is only related to the previous state and the variable $b$, so we can just use an answer variable $ans$ to maintain the current $f[i]$, and there is no need to allocate an array $f$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-deletions-to-make-string-balanced"]}, "2824": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are painting a fence of n posts with k different colors. You must paint the posts following these rules:\n\nEvery post must be painted exactly one color.\nThere cannot be three or more consecutive posts with the same color.\n\nGiven the two integers n and k, return the number of ways you can paint the fence.\n\u00a0\nExample 1:\n\n\nInput: n = 3, k = 2\nOutput: 6\nExplanation: All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n\nExample 2:\n\nInput: n = 1, k = 1\nOutput: 1\n\nExample 3:\n\nInput: n = 7, k = 2\nOutput: 42\n\n\u00a0\nConstraints:\n\n1 <= n <= 50\n1 <= k <= 105\nThe testcases are generated such that the answer is in the range [0, 231 - 1] for the given n and k. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i]$ to represent the number of ways to paint the fence posts from $[0..i]$ such that the last two posts have different colors, and $g[i]$ to represent the number of ways to paint the fence posts from $[0..i]$ such that the last two posts have the same color. Initially, $f[0] = k$ and $g[0] = 0$.\nWhen $i > 0$, we have the following state transition equations:\n$$\n\\begin{aligned}\nf[i] & = (f[i - 1] + g[i - 1]) \\times (k - 1) \\\ng[i] & = f[i - 1]\n\\end{aligned}\n$$\nThe final answer is $f[n - 1] + g[n - 1]$.\nThe time complexity is $O(n)$ and the space complexity is $O(n)$, where $n$ is the number of fence posts. \n\n", "problem_ids": ["paint-fence"]}, "2825": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array of integers nums (0-indexed) and an integer k.\nThe score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.\nReturn the maximum possible score of a good subarray.\n\u00a0\nExample 1:\n\nInput: nums = [1,4,3,7,4,5], k = 3\nOutput: 15\nExplanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. \n\nExample 2:\n\nInput: nums = [5,5,4,5,4,1,1,1], k = 0\nOutput: 20\nExplanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 2 * 104\n0 <= k < nums.length Explanation:\n\nSolution 1: Monotonic Stack\nWe can enumerate each element $nums[i]$ in $nums$ as the minimum value of the subarray, and use a monotonic stack to find the first position $left[i]$ on the left that is less than $nums[i]$ and the first position $right[i]$ on the right that is less than or equal to $nums[i]$. Then, the score of the subarray with $nums[i]$ as the minimum value is $nums[i] \\times (right[i] - left[i] - 1)$.\nIt should be noted that the answer can only be updated when the left and right boundaries $left[i]$ and $right[i]$ satisfy $left[i]+1 \\leq k \\leq right[i]-1$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["maximum-score-of-a-good-subarray"]}, "2827": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an m x n integer matrix grid where each entry is only 0 or 1, return the number of corner rectangles.\nA corner rectangle is four distinct 1's on the grid that forms an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1's used must be distinct.\n\u00a0\nExample 1:\n\n\nInput: grid = [[1,0,0,1,0],[0,0,1,0,1],[0,0,0,1,0],[1,0,1,0,1]]\nOutput: 1\nExplanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].\n\nExample 2:\n\n\nInput: grid = [[1,1,1],[1,1,1],[1,1,1]]\nOutput: 9\nExplanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.\n\nExample 3:\n\n\nInput: grid = [[1,1,1,1]]\nOutput: 0\nExplanation: Rectangles must have four distinct corners.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\ngrid[i][j] is either 0 or 1.\nThe number of 1's in the grid is in the range [1, 6000]. Explanation:\n\nSolution 1: Hash Table + Enumeration\nWe enumerate each row as the bottom of the rectangle. For the current row, if both column $i$ and column $j$ are $1$, then we use a hash table to find out how many of the previous rows have both columns $i$ and $j$ as $1$. This is the number of rectangles with $(i, j)$ as the bottom right corner, and we add this number to the answer. Then we add $(i, j)$ to the hash table and continue to enumerate the next pair $(i, j)$.\nThe time complexity is $O(m \\times n^2)$, and the space complexity is $O(n^2)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, respectively. \n\n", "problem_ids": ["number-of-corner-rectangles"]}, "2828": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array nums consisting of n elements, and an integer k.\nFind a contiguous subarray whose length is greater than or equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.\n\u00a0\nExample 1:\n\nInput: nums = [1,12,-5,-6,50,3], k = 4\nOutput: 12.75000\nExplanation:\n- When the length is 4, averages are [0.5, 12.75, 10.5] and the maximum average is 12.75\n- When the length is 5, averages are [10.4, 10.8] and the maximum average is 10.8\n- When the length is 6, averages are [9.16667] and the maximum average is 9.16667\nThe maximum average is when we choose a subarray of length 4 (i.e., the sub array [12, -5, -6, 50]) which has the max average 12.75, so we return 12.75\nNote that we do not consider the subarrays of length < 4.\n\nExample 2:\n\nInput: nums = [5], k = 1\nOutput: 5.00000\n\n\u00a0\nConstraints:\n\nn == nums.length\n1 <= k <= n <= 104\n-104 <= nums[i] <= 104 Explanation:\n\nSolution 1: Binary Search\nWe note that if the average value of a subarray with length greater than or equal to $k$ is $v$, then the maximum average number must be greater than or equal to $v$, otherwise the maximum average number must be less than $v$. Therefore, we can use binary search to find the maximum average number.\nWhat are the left and right boundaries of binary search? The left boundary $l$ must be the minimum value in the array, and the right boundary $r$ is the maximum value in the array. Next, we binary search the midpoint $mid$, and judge whether there exists a subarray with length greater than or equal to $k$ whose average value is greater than or equal to $mid$. If it exists, then we update the left boundary $l$ to $mid$, otherwise we update the right boundary $r$ to $mid$. When the difference between the left and right boundaries is less than a very small non-negative number, i.e., $r - l < \\epsilon$, we can get the maximum average number, where $\\epsilon$ represents a very small positive number, which can be $10^{-5}$.\nThe key to the problem is how to judge whether the average value of a subarray with length greater than or equal to $k$ is greater than or equal to $v$.\nWe assume that in the array $nums$, there is a subarray with length $j$, the elements are $a_1, a_2, \\cdots, a_j$, and its average value is greater than or equal to $v$, i.e.,\n$$\n\\frac{a_1 + a_2 + \\cdots + a_j}{j} \\geq v\n$$\nThen,\n$$\na_1 + a_2 + \\cdots + a_j \\geq v \\times j\n$$\nThat is,\n$$\n(a_1 - v) + (a_2 - v) + \\cdots + (a_j - v) \\geq 0\n$$\nWe can find that if we subtract $v$ from each element in the array $nums$, the original problem is transformed into a problem of whether the sum of the elements of a subarray with length greater than or equal to $k$ is greater than or equal to $0$. We can use a sliding window to solve this problem.\nFirst, we calculate the sum $s$ of the differences between the first $k$ elements and $v$. If $s \\geq 0$, it means that there exists a subarray with length greater than or equal to $k$ whose element sum is greater than or equal to $0$.\nOtherwise, we continue to traverse the element $nums[j]$. Suppose the current sum of the differences between the first $j$ elements and $v$ is $s_j$. Then we can maintain the minimum value $mi$ of the sum of the differences between the prefix sum and $v$ in the range $[0,..j-k]$. If $s_j \\geq mi$ exists, it means that there exists a subarray with length greater than or equal to $k$ whose element sum is greater than or equal to $0$, and we return $true$.\nOtherwise, we continue to traverse the element $nums[j]$ until the entire array is traversed.\nThe time complexity is $O(n \\times \\log M)$, where $n$ and $M$ are the length of the array $nums$ and the difference between the maximum and minimum values in the array, respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-average-subarray-ii"]}, "2831": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\n\u00a0\nExample 1:\nInput: words = [\"bella\",\"label\",\"roller\"]\nOutput: [\"e\",\"l\",\"l\"]\n\nExample 2:\nInput: words = [\"cool\",\"lock\",\"cook\"]\nOutput: [\"c\",\"o\"]\n\n\u00a0\nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists of lowercase English letters. Explanation:\n\nSolution 1: Counting\nWe use an array $cnt$ of length $26$ to record the minimum number of times each character appears in all strings. Finally, we traverse the $cnt$ array and add characters with a count greater than $0$ to the answer.\nThe time complexity is $O(n \\sum w_i)$, and the space complexity is $O(|\\Sigma|)$. Here, $n$ is the length of the string array $words$, $w_i$ is the length of the $i$-th string in the array $words$, and $|\\Sigma|$ is the size of the character set, which is $26$ in this problem. \n\n", "problem_ids": ["find-common-characters"]}, "2832": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.\nAn index i is good if the following formula holds:\n\n0 <= i < variables.length\n((aibi % 10)ci) % mi == target\n\nReturn an array consisting of good indices in any order.\n\u00a0\nExample 1:\n\nInput: variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2\nOutput: [0,2]\nExplanation: For each index i in the variables array:\n1) For the index 0, variables[0] = [2,3,3,10], (23 % 10)3 % 10 = 2.\n2) For the index 1, variables[1] = [3,3,3,1], (33 % 10)3 % 1 = 0.\n3) For the index 2, variables[2] = [6,1,1,4], (61 % 10)1 % 4 = 2.\nTherefore we return [0,2] as the answer.\n\nExample 2:\n\nInput: variables = [[39,3,1000,1000]], target = 17\nOutput: []\nExplanation: For each index i in the variables array:\n1) For the index 0, variables[0] = [39,3,1000,1000], (393 % 10)1000 % 1000 = 1.\nTherefore we return [] as the answer.\n\n\u00a0\nConstraints:\n\n1 <= variables.length <= 100\nvariables[i] == [ai, bi, ci, mi]\n1 <= ai, bi, ci, mi <= 103\n0 <= target <= 103 Explanation:\n\nSolution 1: Simulation + Fast Power\nWe can directly simulate according to the problem description. For the power operation modulo, we can use the fast power method to speed up the calculation.\nThe time complexity is $O(n \\times \\log M)$, where $n$ is the length of the array $variables$; and $M$ is the maximum value in $b_i$ and $c_i$, in this problem $M \\le 10^3$. The space complexity is $O(1)$. \n\n", "problem_ids": ["double-modular-exponentiation"]}, "2833": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.\nReturn the number of consistent strings in the array words.\n\u00a0\nExample 1:\n\nInput: allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\nOutput: 2\nExplanation: Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'.\n\nExample 2:\n\nInput: allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\nOutput: 7\nExplanation: All strings are consistent.\n\nExample 3:\n\nInput: allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\nOutput: 4\nExplanation: Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent.\n\n\u00a0\nConstraints:\n\n1 <= words.length <= 104\n1 <= allowed.length <= 26\n1 <= words[i].length <= 10\nThe characters in allowed are distinct.\nwords[i] and allowed contain only lowercase English letters. Explanation:\n\nSolution 1: Hash Table or Array\nA straightforward approach is to use a hash table or array $s$ to record the characters in allowed. Then iterate over the words array, for each string $w$, determine whether it is composed of characters in allowed. If so, increment the answer.\nThe time complexity is $O(m)$, and the space complexity is $O(C)$. Here, $m$ is the total length of all strings, and $C$ is the size of the character set allowed. In this problem, $C \\leq 26$. \n\n", "problem_ids": ["count-the-number-of-consistent-strings"]}, "2834": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the root of a binary tree where every node has a unique value and a target integer k, return the value of the nearest leaf node to the target k in the tree.\nNearest to a leaf means the least number of edges traveled on the binary tree to reach any leaf of the tree. Also, a node is called a leaf if it has no children.\n\u00a0\nExample 1:\n\n\nInput: root = [1,3,2], k = 1\nOutput: 2\nExplanation: Either 2 or 3 is the nearest leaf node to the target of 1.\n\nExample 2:\n\n\nInput: root = [1], k = 1\nOutput: 1\nExplanation: The nearest leaf node is the root node itself.\n\nExample 3:\n\n\nInput: root = [1,2,3,4,null,null,null,5,null,6], k = 2\nOutput: 3\nExplanation: The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 1000].\n1 <= Node.val <= 1000\nAll the values of the tree are unique.\nThere exist some node in the tree where Node.val == k. Explanation:\n\nSolution 1: DFS + BFS\nFirst, we use depth-first search to construct an undirected graph $g$, where $g[node]$ represents the set of nodes adjacent to the node $node$. Then we start a breadth-first search from node $k$ until we find a leaf node, which is the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["closest-leaf-in-a-binary-tree"]}, "2837": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e.,\u00a00-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.\nA route's effort is the maximum absolute difference in heights between two consecutive cells of the route.\nReturn the minimum effort required to travel from the top-left cell to the bottom-right cell.\n\u00a0\nExample 1:\n\n\nInput: heights = [[1,2,2],[3,8,2],[5,3,5]]\nOutput: 2\nExplanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.\nThis is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.\n\nExample 2:\n\n\nInput: heights = [[1,2,3],[3,8,4],[5,3,5]]\nOutput: 1\nExplanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].\n\nExample 3:\n\n\nInput: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\nOutput: 0\nExplanation: This route does not require any effort.\n\n\u00a0\nConstraints:\n\nrows == heights.length\ncolumns == heights[i].length\n1 <= rows, columns <= 100\n1 <= heights[i][j] <= 106 Explanation:\n\nSolution 1: Union-Find\nFor this problem, we can treat each cell as a node in a graph, and the absolute difference in height between two adjacent cells as the weight of the edge. Therefore, this problem is to solve the connectivity problem from the top-left node to the bottom-right node.\nWe first construct a set of edges, then sort them in ascending order of edge weight, and add edges one by one until the top-left node and the bottom-right node are connected. At this point, the weight of the edge is the minimum physical consumption value required by the problem.\nThe time complexity is $O(m \\times n \\times \\log(m \\times n))$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns in the two-dimensional array, respectively. \n\n", "problem_ids": ["path-with-minimum-effort"]}, "2839": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\n\u00a0\nExample 1:\n\n\nInput: root = [10,5,15,3,7,null,18], low = 7, high = 15\nOutput: 32\nExplanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n\nExample 2:\n\n\nInput: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\nOutput: 23\nExplanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 2 * 104].\n1 <= Node.val <= 105\n1 <= low <= high <= 105\nAll Node.val are unique. Explanation:\n\nSolution 1: DFS\nWe design a function $dfs(root)$, which represents the sum of the values of all nodes in the subtree with $root$ as the root, and the values are within the range $[low, high]$. The answer is $dfs(root)$.\nThe execution logic of the function $dfs(root)$ is as follows:\n\nIf $root$ is null, return $0$.\nIf the value $x$ of $root$ is within the range $[low, high]$, then the initial answer of the function $dfs(root)$ is $x$, otherwise it is $0$.\nIf $x > low$, it means that there may be nodes in the left subtree of $root$ with values within the range $[low, high]$, so we need to recursively call $dfs(root.left)$ and add the result to the answer.\nIf $x < high$, it means that there may be nodes in the right subtree of $root$ with values within the range $[low, high]$, so we need to recursively call $dfs(root.right)$ and add the result to the answer.\nFinally, return the answer.\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the binary search tree. \n\n", "problem_ids": ["range-sum-of-bst"]}, "2844": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\u00a0\nExample 1:\n\nInput: x = 123\nOutput: 321\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\nExample 3:\n\nInput: x = 120\nOutput: 21\n\n\u00a0\nConstraints:\n\n-231 <= x <= 231 - 1 Explanation:\n\nSolution 1: Mathematics\nLet's denote $mi$ and $mx$ as $-2^{31}$ and $2^{31} - 1$ respectively, then the reverse result of $x$, $ans$, needs to satisfy $mi \\le ans \\le mx$.\nWe can continuously take the remainder of $x$ to get the last digit $y$ of $x$, and add $y$ to the end of $ans$. Before adding $y$, we need to check if $ans$ overflows. That is, check whether $ans \\times 10 + y$ is within the range $[mi, mx]$.\nIf $x \\gt 0$, it needs to satisfy $ans \\times 10 + y \\leq mx$, that is, $ans \\times 10 + y \\leq \\left \\lfloor \\frac{mx}{10} \\right \\rfloor \\times 10 + 7$. Rearranging gives $(ans - \\left \\lfloor \\frac{mx}{10} \\right \\rfloor) \\times 10 \\leq 7 - y$.\nNext, we discuss the conditions for the inequality to hold:\n\nWhen $ans \\lt \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$, the inequality obviously holds;\nWhen $ans = \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$, the necessary and sufficient condition for the inequality to hold is $y \\leq 7$. If $ans = \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$ and we can still add numbers, it means that the number is at the highest digit, that is, $y$ must not exceed $2$, therefore, the inequality must hold;\nWhen $ans \\gt \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$, the inequality obviously does not hold.\n\nIn summary, when $x \\gt 0$, the necessary and sufficient condition for the inequality to hold is $ans \\leq \\left \\lfloor \\frac{mx}{10} \\right \\rfloor$.\nSimilarly, when $x \\lt 0$, the necessary and sufficient condition for the inequality to hold is $ans \\geq \\left \\lfloor \\frac{mi}{10} \\right \\rfloor$.\nTherefore, we can check whether $ans$ overflows by checking whether $ans$ is within the range $[\\left \\lfloor \\frac{mi}{10} \\right \\rfloor, \\left \\lfloor \\frac{mx}{10} \\right \\rfloor]$. If it overflows, return $0$. Otherwise, add $y$ to the end of $ans$, and then remove the last digit of $x$, that is, $x \\gets \\left \\lfloor \\frac{x}{10} \\right \\rfloor$.\nThe time complexity is $O(\\log |x|)$, where $|x|$ is the absolute value of $x$. The space complexity is $O(1)$. \n\n", "problem_ids": ["reverse-integer"]}, "2845": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two sparse matrices mat1 of size m x k and mat2 of size k x n, return the result of mat1 x mat2. You may assume that multiplication is always possible.\n\u00a0\nExample 1:\n\n\nInput: mat1 = [[1,0,0],[-1,0,3]], mat2 = [[7,0,0],[0,0,0],[0,0,1]]\nOutput: [[7,0,0],[-7,0,3]]\n\nExample 2:\n\nInput: mat1 = [[0]], mat2 = [[0]]\nOutput: [[0]]\n\n\u00a0\nConstraints:\n\nm == mat1.length\nk == mat1[i].length == mat2.length\nn == mat2[i].length\n1 <= m, n, k <= 100\n-100 <= mat1[i][j], mat2[i][j] <= 100 Explanation:\n\nSolution 1: Direct Multiplication\nWe can directly calculate each element in the result matrix according to the definition of matrix multiplication.\nThe time complexity is $O(m \\times n \\times k)$, and the space complexity is $O(m \\times n)$. Where $m$ and $n$ are the number of rows of matrix $mat1$ and the number of columns of matrix $mat2$ respectively, and $k$ is the number of columns of matrix $mat1$ or the number of rows of matrix $mat2$. \n\n", "problem_ids": ["sparse-matrix-multiplication"]}, "2847": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer n, return the number of ways you can write n as the sum of consecutive positive integers.\n\u00a0\nExample 1:\n\nInput: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\n\nExample 2:\n\nInput: n = 9\nOutput: 3\nExplanation: 9 = 4 + 5 = 2 + 3 + 4\n\nExample 3:\n\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n\n\u00a0\nConstraints:\n\n1 <= n <= 109 Explanation:\n\nSolution 1: Mathematical Derivation\nConsecutive positive integers form an arithmetic sequence with a common difference $d = 1$. Let's assume the first term of the sequence is $a$, and the number of terms is $k$. Then, $n = (a + a + k - 1) \\times k / 2$, which simplifies to $n \\times 2 = (a \\times 2 + k - 1) \\times k$. From this, we can deduce that $k$ must divide $n \\times 2$ evenly, and $(n \\times 2) / k - k + 1$ must be an even number.\nGiven that $a \\geq 1$, it follows that $n \\times 2 = (a \\times 2 + k - 1) \\times k \\geq k \\times (k + 1)$.\nIn summary, we can conclude:\n\n$k$ must divide $n \\times 2$ evenly;\n$k \\times (k + 1) \\leq n \\times 2$;\n$(n \\times 2) / k - k + 1$ must be an even number.\n\nWe start enumerating from $k = 1$, and we can stop when $k \\times (k + 1) > n \\times 2$. During the enumeration, we check if $k$ divides $n \\times 2$ evenly, and if $(n \\times 2) / k - k + 1$ is an even number. If both conditions are met, it satisfies the criteria, and we increment the answer by one.\nAfter finishing the enumeration, we return the answer.\nThe time complexity is $O(\\sqrt{n})$, where $n$ is the given positive integer. The space complexity is $O(1)$. \n\n", "problem_ids": ["consecutive-numbers-sum"]}, "2848": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\u00a0\nExample 1:\n\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n\u00a0\nConstraints:\n\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104 Explanation:\n\nSolution 1: DFS\nWe can use the DFS recursive method to solve this problem.\nFirst, determine whether the root nodes of the two binary trees are the same. If both root nodes are null, then the two binary trees are the same. If only one of the root nodes is null, then the two binary trees are definitely different. If both root nodes are not null, then determine whether their values are the same. If they are not the same, then the two binary trees are definitely different. If they are the same, then determine whether the left subtrees of the two binary trees are the same and whether the right subtrees are the same. The two binary trees are the same only when all the above conditions are met.\nThe time complexity is $O(\\min(m, n))$, and the space complexity is $O(\\min(m, n))$. Here, $m$ and $n$ are the number of nodes in the two binary trees, respectively. The space complexity mainly depends on the number of layers of recursive calls, which will not exceed the number of nodes in the smaller binary tree. \n\n", "problem_ids": ["same-tree"]}, "2849": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n\u00a0\nExample 1:\n\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n\nExample 2:\n\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n\nExample 3:\n\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= target <= 109\n1 <= nums.length <= 105\n1 <= nums[i] <= 104\n\n\u00a0\nFollow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)). Explanation:\n\nSolution 1: Prefix Sum + Binary Search\nFirst, we preprocess the prefix sum array $s$ of the array $nums$, where $s[i]$ represents the sum of the first $i$ elements of the array $nums$. Since all elements in the array $nums$ are positive integers, the array $s$ is also monotonically increasing. Also, we initialize the answer $ans = n + 1$, where $n$ is the length of the array $nums$.\nNext, we traverse the prefix sum array $s$. For each element $s[i]$, we can find the smallest index $j$ that satisfies $s[j] \\geq s[i] + target$ by binary search. If $j \\leq n$, it means that there exists a subarray that satisfies the condition, and we can update the answer, i.e., $ans = min(ans, j - i)$.\nFinally, if $ans \\leq n$, it means that there exists a subarray that satisfies the condition, return $ans$, otherwise return $0$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["minimum-size-subarray-sum"]}, "2850": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer n and an integer p representing an array arr of length n where all elements are set to 0's, except position p which is set to 1. You are also given an integer array banned containing restricted positions. Perform the following operation on arr:\n\nReverse a subarray with size k if the single 1 is not set to a position in banned.\n\nReturn an integer array answer with n results where the ith result is the minimum number of operations needed to bring the single 1 to position i in arr, or -1 if it is impossible.\n\u00a0\nExample 1:\n\nInput: n = 4, p = 0, banned = [1,2], k = 4\nOutput: [0,-1,-1,1]\nExplanation:\n\nInitially 1 is placed at position 0 so the number of operations we need for position 0 is 0.\nWe can never place 1 on the banned positions, so the answer for positions 1 and 2 is -1.\nPerform the operation of size 4 to reverse the whole array.\nAfter a single operation 1 is at position 3 so the answer for position 3 is 1.\n\n\nExample 2:\n\nInput: n = 5, p = 0, banned = [2,4], k = 3\nOutput: [0,-1,-1,-1,-1]\nExplanation:\n\nInitially 1 is placed at position 0 so the number of operations we need for position 0 is 0.\nWe cannot perform the operation on the subarray positions [0, 2] because position 2 is in banned.\nBecause 1 cannot be set at position 2, it is impossible to set 1 at other positions in more operations.\n\n\nExample 3:\n\nInput: n = 4, p = 2, banned = [0,1,3], k = 1\nOutput: [-1,-1,0,-1]\nExplanation:\nPerform operations of size 1 and 1 never changes its position.\n\n\u00a0\nConstraints:\n\n1 <= n <= 105\n0 <= p <= n - 1\n0 <= banned.length <= n - 1\n0 <= banned[i] <= n - 1\n1 <= k <= n\u00a0\nbanned[i] != p\nall values in banned\u00a0are unique\u00a0 Explanation:\n\nSolution 1: Ordered Set + BFS\nWe notice that for any index $i$ in the subarray interval $[l,..r]$, the flipped index $j = l + r - i$.\nIf the subarray moves one position to the right, then $j = l + 1 + r + 1 - i = l + r - i + 2$, that is, $j$ will increase by $2$.\nSimilarly, if the subarray moves one position to the left, then $j = l - 1 + r - 1 - i = l + r - i - 2$, that is, $j$ will decrease by $2$.\nTherefore, for a specific index $i$, all its flipped indices form an arithmetic progression with common difference $2$, that is, all the flipped indices have the same parity.\nNext, we consider the range of values \u200b\u200bof the index $i$ after flipping $j$.\n\nIf the boundary is not considered, the range of values \u200b\u200bof $j$ is $[i - k + 1, i + k - 1]$.\nIf the subarray is on the left, then $[l, r] = [0, k - 1]$, so the flipped index $j$ of $i$ is $0 + k - 1 - i$, that is, $j = k - i - 1$, so the left boundary $mi = max(i - k + 1, k - i - 1)$.\nIf the subarray is on the right, then $[l, r] = [n - k, n - 1]$, so the flipped index $j= n - k + n - 1 - i$ is $j = n \\times 2 - k - i - 1$, so the right boundary of $j$ is $mx = min(i + k - 1, n \\times 2 - k - i - 1)$.\n\nWe use two ordered sets to store all the odd indices and even indices to be searched, here we need to exclude the indices in the array $banned$ and the index $p$.\nThen we use BFS to search, each time searching all the flipped indices $j$ of the current index $i$, that is, $j = mi, mi + 2, mi + 4, \\dots, mx$, updating the answer of index $j$ and adding index $j$ to the search queue, and removing index $j$ from the corresponding ordered set.\nWhen the search is over, the answer to all indices can be obtained.\nThe time complexity is $O(n \\times \\log n)$ and the space complexity is $O(n)$. Where $n$ is the given array length in the problem. \n\n", "problem_ids": ["minimum-reverse-operations"]}, "2854": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array nums.\nReturn an integer that is the maximum distance between the indices of two (not necessarily different) prime numbers in nums.\n\u00a0\nExample 1:\n\nInput: nums = [4,2,9,5,3]\nOutput: 3\nExplanation: nums[1], nums[3], and nums[4] are prime. So the answer is |4 - 1| = 3.\n\nExample 2:\n\nInput: nums = [4,8,2,8]\nOutput: 0\nExplanation: nums[2] is prime. Because there is just one prime number, the answer is |2 - 2| = 0.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 3 * 105\n1 <= nums[i] <= 100\nThe input is generated such that the number of prime numbers in the nums is at least one. Explanation:\n\nSolution 1: Traversal\nAccording to the problem description, we need to find the index $i$ of the first prime number, then find the index $j$ of the last prime number, and return $j - i$ as the answer.\nTherefore, we can traverse the array from left to right to find the index $i$ of the first prime number, then traverse the array from right to left to find the index $j$ of the last prime number. The answer is $j - i$.\nThe time complexity is $O(n \\times \\sqrt{M})$, where $n$ and $M$ are the length of the array $nums$ and the maximum value in the array, respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-prime-difference"]}, "2855": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\u00a0\nExample 1:\n\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n\u00a0\nConstraints:\n\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104 Explanation:\n\nSolution 1: DFS\nWe can use the DFS recursive method to solve this problem.\nFirst, determine whether the root nodes of the two binary trees are the same. If both root nodes are null, then the two binary trees are the same. If only one of the root nodes is null, then the two binary trees are definitely different. If both root nodes are not null, then determine whether their values are the same. If they are not the same, then the two binary trees are definitely different. If they are the same, then determine whether the left subtrees of the two binary trees are the same and whether the right subtrees are the same. The two binary trees are the same only when all the above conditions are met.\nThe time complexity is $O(\\min(m, n))$, and the space complexity is $O(\\min(m, n))$. Here, $m$ and $n$ are the number of nodes in the two binary trees, respectively. The space complexity mainly depends on the number of layers of recursive calls, which will not exceed the number of nodes in the smaller binary tree. \n\n", "problem_ids": ["same-tree"]}, "2856": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two strings, word1 and word2. You want to construct a string in the following manner:\n\nChoose some non-empty subsequence subsequence1 from word1.\nChoose some non-empty subsequence subsequence2 from word2.\nConcatenate the subsequences: subsequence1 + subsequence2, to make the string.\n\nReturn the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0.\nA subsequence of a string s is a string that can be made by deleting some (possibly none) characters from s without changing the order of the remaining characters.\nA palindrome is a string that reads the same forward\u00a0as well as backward.\n\u00a0\nExample 1:\n\nInput: word1 = \"cacb\", word2 = \"cbba\"\nOutput: 5\nExplanation: Choose \"ab\" from word1 and \"cba\" from word2 to make \"abcba\", which is a palindrome.\nExample 2:\n\nInput: word1 = \"ab\", word2 = \"ab\"\nOutput: 3\nExplanation: Choose \"ab\" from word1 and \"a\" from word2 to make \"aba\", which is a palindrome.\nExample 3:\n\nInput: word1 = \"aa\", word2 = \"bb\"\nOutput: 0\nExplanation: You cannot construct a palindrome from the described method, so return 0.\n\u00a0\nConstraints:\n\n1 <= word1.length, word2.length <= 1000\nword1 and word2 consist of lowercase English letters. Explanation:\n\nSolution 1: Dynamic Programming\nFirst, we concatenate strings word1 and word2 to get string $s$. Then we can transform the problem into finding the length of the longest palindromic subsequence in string $s$. However, when calculating the final answer, we need to ensure that at least one character in the palindrome string comes from word1 and another character comes from word2.\nWe define $f[i][j]$ as the length of the longest palindromic subsequence in the substring of string $s$ with index range $[i, j]$.\nIf $s[i] = s[j]$, then $s[i]$ and $s[j]$ must be in the longest palindromic subsequence, at this time $f[i][j] = f[i + 1][j - 1] + 2$. At this point, we also need to judge whether $s[i]$ and $s[j]$ come from word1 and word2. If so, we update the maximum value of the answer to $ans=\\max(ans, f[i][j])$.\nIf $s[i] \\neq s[j]$, then $s[i]$ and $s[j]$ will definitely not appear in the longest palindromic subsequence at the same time, at this time $f[i][j] = max(f[i + 1][j], f[i][j - 1])$.\nFinally, we return the answer.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of string $s$. \n\n", "problem_ids": ["maximize-palindrome-length-from-subsequences"]}, "2857": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given n\u200b\u200b\u200b\u200b\u200b\u200b tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b task will be available to process at enqueueTimei and will take processingTimei to finish processing.\nYou have a single-threaded CPU that can process at most one task at a time and will act in the following way:\n\nIf the CPU is idle and there are no available tasks to process, the CPU remains idle.\nIf the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.\nOnce a task is started, the CPU will process the entire task without stopping.\nThe CPU can finish a task then start a new one instantly.\n\nReturn the order in which the CPU will process the tasks.\n\u00a0\nExample 1:\n\nInput: tasks = [[1,2],[2,4],[3,2],[4,1]]\nOutput: [0,2,3,1]\nExplanation: The events go as follows: \n- At time = 1, task 0 is available to process. Available tasks = {0}.\n- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n- At time = 2, task 1 is available to process. Available tasks = {1}.\n- At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n- At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n- At time = 10, the CPU finishes task 1 and becomes idle.\n\nExample 2:\n\nInput: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\nOutput: [4,3,2,0,1]\nExplanation: The events go as follows:\n- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n- At time = 40, the CPU finishes task 1 and becomes idle.\n\n\u00a0\nConstraints:\n\ntasks.length == n\n1 <= n <= 105\n1 <= enqueueTimei, processingTimei <= 109 Explanation:\n\nSolution 1: Sorting + Priority Queue (Min Heap)\nFirst, we sort the tasks by enqueueTime in ascending order. Next, we use a priority queue (min heap) to maintain the currently executable tasks. The elements in the queue are (processingTime, index), which represent the execution time and the index of the task. We also use a variable $t$ to represent the current time, initially set to $0$.\nNext, we simulate the execution process of the tasks.\nIf the current queue is empty, it means there are no executable tasks at the moment. We update $t$ to the larger value between the enqueueTime of the next task and the current time $t$. Then, we add all tasks with enqueueTime less than or equal to $t$ to the queue.\nThen, we take out a task from the queue, add its index to the answer array, and update $t$ to the sum of the current time $t$ and the execution time of the current task.\nWe repeat the above process until the queue is empty and all tasks have been added to the queue.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the number of tasks. \n\n", "problem_ids": ["single-threaded-cpu"]}, "2866": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array nums of positive integers, return the longest possible length of an array prefix of nums, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.\nIf after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).\n\u00a0\nExample 1:\n\nInput: nums = [2,2,1,1,5,3,3,5]\nOutput: 7\nExplanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4] = 5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.\n\nExample 2:\n\nInput: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]\nOutput: 13\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 105\n1 <= nums[i] <= 105 Explanation:\n\nSolution 1: Array or Hash Table\nWe use $cnt$ to record the number of times each element $v$ appears in $nums$, and $ccnt$ to record the number of times each count appears. The maximum number of times an element appears is represented by $mx$.\nWhile traversing $nums$:\n\nIf the maximum count $mx=1$, it means that each number in the current prefix appears $1$ time. If we delete any one of them, the remaining numbers will all have the same count.\nIf all numbers appear $mx$ and $mx-1$ times, and only one number appears $mx$ times, then we can delete one occurrence of the number that appears $mx$ times. The remaining numbers will all have a count of $mx-1$, which meets the condition.\nIf, except for one number, all other numbers appear $mx$ times, then we can delete the number that appears once. The remaining numbers will all have a count of $mx$, which meets the condition.\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the $nums$ array. \n\n", "problem_ids": ["maximum-equal-frequency"]}, "2867": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array of positive integers nums.\nAlice and Bob are playing a game. In the game, Alice can choose either all single-digit numbers or all double-digit numbers from nums, and the rest of the numbers are given to Bob. Alice wins if the sum of her numbers is strictly greater than the sum of Bob's numbers.\nReturn true if Alice can win this game, otherwise, return false.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4,10]\nOutput: false\nExplanation:\nAlice cannot win by choosing either single-digit or double-digit numbers.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5,14]\nOutput: true\nExplanation:\nAlice can win by choosing single-digit numbers which have a sum equal to 15.\n\nExample 3:\n\nInput: nums = [5,5,5,25]\nOutput: true\nExplanation:\nAlice can win by choosing double-digit numbers which have a sum equal to 25.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 99 Explanation:\n\nSolution 1: Summation\nAccording to the problem description, as long as the sum of the units digits is not equal to the sum of the tens digits, Xiaohong can always choose a larger sum to win.\nThe time complexity is $O(n)$, where $n$ is the length of the array $\\textit{nums}$. The space complexity is $O(1)$. \n\n", "problem_ids": ["find-if-digit-game-can-be-won"]}, "2868": {"text": "Similar Problem 1 \n\n Problem:\n\nTwo strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.\n\u00a0\nExample 1:\n\nInput: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.\n\nExample 2:\n\nInput: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.\n\nExample 3:\n\nInput: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.\n\n\u00a0\nConstraints:\n\nn == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters. Explanation:\n\nSolution 1: Counting\nWe can create an array $cnt$ of length $26$ to record the difference in the number of times each letter appears in the two strings. Then we traverse $cnt$, if any letter appears the difference in the number of times greater than $3$, then return false, otherwise return true.\nThe time complexity is $O(n)$ and the space complexity is $O(C)$. Where $n$ is the length of the string, and $C$ is the size of the character set, and in this question $C = 26$. \n\n", "problem_ids": ["check-whether-two-strings-are-almost-equivalent"]}, "2869": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.\nEach minute, a node becomes infected if:\n\nThe node is currently uninfected.\nThe node is adjacent to an infected node.\n\nReturn the number of minutes needed for the entire tree to be infected.\n\u00a0\nExample 1:\n\n\nInput: root = [1,5,3,null,4,10,6,9,2], start = 3\nOutput: 4\nExplanation: The following nodes are infected during:\n- Minute 0: Node 3\n- Minute 1: Nodes 1, 10 and 6\n- Minute 2: Node 5\n- Minute 3: Node 4\n- Minute 4: Nodes 9 and 2\nIt takes 4 minutes for the whole tree to be infected so we return 4.\n\nExample 2:\n\n\nInput: root = [1], start = 1\nOutput: 0\nExplanation: At minute 0, the only node in the tree is infected so we return 0.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 105].\n1 <= Node.val <= 105\nEach node has a unique value.\nA node with a value of start exists in the tree. Explanation:\n\nSolution 1: Two DFS\nFirst, we build a graph through one DFS, and get an adjacency list $g$, where $g[node]$ represents all nodes connected to the node $node$.\nThen, we use $start$ as the starting point, and search the entire tree through DFS to find the farthest distance, which is the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["amount-of-time-for-binary-tree-to-be-infected"]}, "2870": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an m x n integer matrix grid\u200b\u200b\u200b.\nA rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid\u200b\u200b\u200b. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each rhombus sum:\n\nNote that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.\nReturn the biggest three distinct rhombus sums in the grid in descending order. If there are less than three distinct values, return all of them.\n\u00a0\nExample 1:\n\n\nInput: grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]\nOutput: [228,216,211]\nExplanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 20 + 3 + 200 + 5 = 228\n- Red: 200 + 2 + 10 + 4 = 216\n- Green: 5 + 200 + 4 + 2 = 211\n\nExample 2:\n\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [20,9,8]\nExplanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 4 + 2 + 6 + 8 = 20\n- Red: 9 (area 0 rhombus in the bottom right corner)\n- Green: 8 (area 0 rhombus in the bottom middle)\n\nExample 3:\n\nInput: grid = [[7,7,7]]\nOutput: [7]\nExplanation: All three possible rhombus sums are the same, so return [7].\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 105 Explanation:\n\nSolution 1: Enumerate Diamond Center + Prefix Sum + Ordered Set\nWe can preprocess to get two prefix sum arrays $s_1$ and $s_2$, where $s_1[i][j]$ represents the sum of the elements on the upper left diagonal ending at $(i, j)$, and $s_2[i][j]$ represents the sum of the elements on the upper right diagonal ending at $(i, j)$.\nNext, we enumerate each position $(i, j)$, first add $grid[i][j]$ to the ordered set $ss$, and then enumerate the length $k$ of the diamond. The sum of the diamond with $(i, j)$ as the center and a side length of $k$ is:\n$$\n\\begin{aligned}\n&\\quad s_1[i + k][j] - s_1[i][j - k] + s_1[i][j + k] - s_1[i - k][j] \\\n&+ s_2[i][j - k] - s_2[i - k][j] + s_2[i + k][j] - s_2[i][j + k] \\\n&- grid[i + k - 1][j - 1] + grid[i - k - 1][j - 1]\n\\end{aligned}\n$$\nWe add this value to the ordered set $ss$, while ensuring that the size of the ordered set $ss$ does not exceed $3$. Finally, we output the elements in the ordered set $ss$ in reverse order.\nThe time complexity is $O(m \\times n \\times \\min(m, n))$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, respectively. \n\n", "problem_ids": ["get-biggest-three-rhombus-sums-in-a-grid"]}, "2872": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\u00a0\nExample 1:\nInput: s = \"hello\"\nOutput: \"holle\"\n\nExample 2:\nInput: s = \"leetcode\"\nOutput: \"leotcede\"\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consist of printable ASCII characters. Explanation:\n\nSolution 1: Two Pointers\nWe can use two pointers $i$ and $j$, initially pointing to the start and end of the string respectively.\nIn each loop, we check whether the character at $i$ is a vowel. If it's not, we move $i$ forward. Similarly, we check whether the character at $j$ is a vowel. If it's not, we move $j$ backward. If $i < j$ at this point, then both characters at $i$ and $j$ are vowels, so we swap these two characters. Then, we move $i$ forward and $j$ backward. We continue the above operations until $i \\ge j$.\nThe time complexity is $O(n)$, where $n$ is the length of the string. The space complexity is $O(|\\Sigma|)$, where $\\Sigma$ is the size of the character set. \n\n", "problem_ids": ["reverse-vowels-of-a-string"]}, "2873": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a binary array nums of length n, a positive integer k and a non-negative integer maxChanges.\nAlice plays a game, where the goal is for Alice to pick up k ones from nums using the minimum number of moves. When the game starts, Alice picks up any index aliceIndex in the range [0, n - 1] and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice can make any number of moves (including zero) where in each move Alice must perform exactly one of the following actions:\n\nSelect any index j != aliceIndex such that nums[j] == 0 and set nums[j] = 1. This action can be performed at most maxChanges times.\nSelect any two adjacent indices x and y (|x - y| == 1) such that nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move and nums[y] becomes 0.\n\nReturn the minimum number of moves required by Alice to pick exactly k ones.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\nOutput: 3\nExplanation: Alice can pick up 3 ones in 3 moves, if Alice performs the following actions in each move when standing at aliceIndex == 1:\n\nAt the start of the game Alice picks up the one and nums[1] becomes 0. nums becomes [1,0,0,0,0,1,1,0,0,1].\nSelect j == 2 and perform an action of the first type. nums becomes [1,0,1,0,0,1,1,0,0,1]\nSelect x == 2 and y == 1, and perform an action of the second type. nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].\nSelect x == 0 and y == 1, and perform an action of the second type. nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].\n\nNote that it may be possible for Alice to pick up 3 ones using some other sequence of 3 moves.\n\nExample 2:\n\nInput: nums = [0,0,0,0], k = 2, maxChanges = 3\nOutput: 4\nExplanation: Alice can pick up 2 ones in 4 moves, if Alice performs the following actions in each move when standing at aliceIndex == 0:\n\nSelect j == 1 and perform an action of the first type. nums becomes [0,1,0,0].\nSelect x == 1 and y == 0, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\nSelect j == 1 again and perform an action of the first type. nums becomes [0,1,0,0].\nSelect x == 1 and y == 0 again, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\n\n\n\u00a0\nConstraints:\n\n2 <= n <= 105\n0 <= nums[i] <= 1\n1 <= k <= 105\n0 <= maxChanges <= 105\nmaxChanges + sum(nums) >= k Explanation:\n\nSolution 1: Greedy + Prefix Sum + Binary Search\nWe consider enumerating Alice's standing position $i$. For each $i$, we follow the strategy below:\n\nFirst, if the number at position $i$ is $1$, we can directly pick up a $1$ without needing any moves.\nThen, we pick up the number $1$ from both sides of position $i$, which is action $2$, i.e., move the $1$ from position $i-1$ to position $i$, then pick it up; move the $1$ from position $i+1$ to position $i$, then pick it up. Each pick up of a $1$ requires $1$ move.\nNext, we maximize the conversion of $0$s at positions $i-1$ or $i+1$ to $1$s using action $1$, then move them to position $i$ using action $2$ to pick them up. This continues until the number of $1$s picked up reaches $k$ or the number of times action $1$ is used reaches $\\textit{maxChanges}$. Assuming the number of times action $1$ is used is $c$, then a total of $2c$ moves are needed.\nAfter utilizing action $1$, if the number of $1$s picked up has not reached $k$, we need to continue considering moving $1$s to position $i$ from the intervals $[1,..i-2]$ and $[i+2,..n]$ using action $2$ to pick them up. We can use binary search to determine the size of this interval so that the number of $1$s picked up reaches $k$. Specifically, we binary search for an interval size $d$, then within the intervals $[i-d,..i-2]$ and $[i+2,..i+d]$, we perform action $2$ to move $1$s to position $i$ for pickup. If the number of $1$s picked up reaches $k$, we update the answer.\n\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $\\textit{nums}$. \n\n", "problem_ids": ["minimum-moves-to-pick-k-ones"]}, "2876": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of digits which is sorted in non-decreasing order. You can write numbers using each digits[i] as many times as we want. For example, if digits = ['1','3','5'], we may write numbers such as '13', '551', and '1351315'.\nReturn the number of positive integers that can be generated that are less than or equal to a given integer n.\n\u00a0\nExample 1:\n\nInput: digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\nOutput: 20\nExplanation: \nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\nExample 2:\n\nInput: digits = [\"1\",\"4\",\"9\"], n = 1000000000\nOutput: 29523\nExplanation: \nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits array.\n\nExample 3:\n\nInput: digits = [\"7\"], n = 8\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= digits.length <= 9\ndigits[i].length == 1\ndigits[i] is a digit from\u00a0'1'\u00a0to '9'.\nAll the values in\u00a0digits are unique.\ndigits is sorted in\u00a0non-decreasing order.\n1 <= n <= 109 Explanation:\n\nSolution 1: Digit DP\nThis problem is essentially asking for the count of positive integers generated by the numbers in digits within the given range $[l,..r]$. The count is related to the number of digits and the digit at each position. We can use the idea of Digit DP to solve this problem. In Digit DP, the size of the number has a small impact on the complexity.\nFor the range $[l,..r]$, we generally convert it into $[1,..r]$ and then subtract $[1,..l - 1]$, i.e.,\n$$\nans = \\sum_{i=1}^{r} ans_i -  \\sum_{i=1}^{l-1} ans_i\n$$\nHowever, for this problem, we only need to calculate the value of the range $[1,..r]$.\nHere we use memoization search to implement Digit DP. We search from the starting point to the bottom layer to get the number of schemes, return the answer layer by layer and accumulate it, and finally get the final answer from the starting point of the search.\nThe basic steps are as follows:\n\nConvert the number $n$ into an int array $a$, where $a[1]$ is the lowest digit and $a[len]$ is the highest digit;\nDesign the function $dfs()$ based on the problem information. For this problem, we define $dfs(pos, lead, limit)$, and the answer is $dfs(len, 1, true)$.\n\nWhere:\n\npos represents the number of digits in the number, starting from the last digit or the first digit, usually chosen based on the digit construction property of the problem. For this problem, we choose to start from the high digit, so the initial value of pos is len;\nlead indicates whether the current number contains leading zeros. If it does, it is 1, otherwise it is 0. It is initialized to 1;\nlimit represents the restriction on the digits that can be filled. If there is no restriction, you can choose $[0,1,..9]$, otherwise, you can only choose $[0,..a[pos]]$. If limit is true and the maximum value that can be taken has been taken, then the next limit is also true. If limit is true but the maximum value has not been taken, or if limit is false, then the next limit is false.\n\nFor the implementation details of the function, you can refer to the code below.\nThe time complexity is $O(\\log n)$.\nSimilar problems:\n\n233. Number of Digit One\n357. Count Numbers with Unique Digits\n600. Non-negative Integers without Consecutive Ones\n788. Rotated Digits\n1012. Numbers With Repeated Digits\n2376. Count Special Integers \n\n", "problem_ids": ["numbers-at-most-n-given-digit-set"]}, "2877": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths.\nEach video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi.\nWe can cut these clips into segments freely.\n\nFor example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].\n\nReturn the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.\n\u00a0\nExample 1:\n\nInput: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\nOutput: 3\nExplanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut [1,9] into segments [1,2] + [2,8] + [8,9].\nNow we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].\n\nExample 2:\n\nInput: clips = [[0,1],[1,2]], time = 5\nOutput: -1\nExplanation: We cannot cover [0,5] with only [0,1] and [1,2].\n\nExample 3:\n\nInput: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9\nOutput: 3\nExplanation: We can take clips [0,4], [4,7], and [6,9].\n\n\u00a0\nConstraints:\n\n1 <= clips.length <= 100\n0 <= starti <= endi <= 100\n1 <= time <= 100 Explanation:\n\nSolution 1: Greedy\nNote that if there are multiple sub-intervals with the same starting point, it is optimal to choose the one with the largest right endpoint.\nTherefore, we can preprocess all sub-intervals. For each position $i$, calculate the largest right endpoint among all sub-intervals starting at $i$, and record it in the array $last[i]$.\nWe define a variable mx to represent the farthest position that can currently be reached, a variable ans to represent the current minimum number of sub-intervals needed, and a variable pre to represent the right endpoint of the last used sub-interval.\nNext, we start enumerating all positions $i$ from $0$, using $last[i]$ to update mx. If after updating, $mx = i$, it means that the next position cannot be covered, so the task cannot be completed, return $-1$.\nAt the same time, we record the right endpoint pre of the last used sub-interval. If $pre = i$, it means that a new sub-interval needs to be used, so we add $1$ to ans and update pre to mx.\nAfter the traversal is over, return ans.\nThe time complexity is $O(n+m)$, and the space complexity is $O(m)$. Where $n$ and $m$ are the lengths of the clips array and the value of time, respectively.\nSimilar problems:\n\n45. Jump Game II\n55. Jump Game\n1326. Minimum Number of Taps to Open to Water a Garden \n\n", "problem_ids": ["video-stitching"]}, "2878": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\u00a0\nExample 1:\n\n\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\n\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n\n\u00a0\nConstraints:\n\n1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree. Explanation:\n\nSolution 1: Hash Table + Recursion\nThe first node $preorder[0]$ in the pre-order sequence is the root node. We find the position $k$ of the root node in the in-order sequence, which can divide the in-order sequence into the left subtree $inorder[0..k]$ and the right subtree $inorder[k+1..]$.\nThrough the intervals of the left and right subtrees, we can calculate the number of nodes in the left and right subtrees, assumed to be $a$ and $b$. Then in the pre-order nodes, the $a$ nodes after the root node are the left subtree, and the $b$ nodes after that are the right subtree.\nTherefore, we design a function $dfs(i, j, n)$, where $i$ and $j$ represent the starting positions of the pre-order sequence and the in-order sequence, respectively, and $n$ represents the number of nodes. The return value of the function is the binary tree constructed with $preorder[i..i+n-1]$ as the pre-order sequence and $inorder[j..j+n-1]$ as the in-order sequence.\nThe execution process of the function $dfs(i, j, n)$ is as follows:\n\nIf $n \\leq 0$, it means there are no nodes, return a null node.\nTake out the first node $v = preorder[i]$ of the pre-order sequence as the root node, and then use the hash table $d$ to find the position $k$ of the root node in the in-order sequence. Then the number of nodes in the left subtree is $k - j$, and the number of nodes in the right subtree is $n - k + j - 1$.\nRecursively construct the left subtree $l = dfs(i + 1, j, k - j)$ and the right subtree $r = dfs(i + 1 + k - j, k + 1, n - k + j - 1)$.\nFinally, return the binary tree with $v$ as the root node and $l$ and $r$ as the left and right subtrees, respectively.\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["construct-binary-tree-from-preorder-and-inorder-traversal"]}, "2879": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.\nFor each index i, names[i] and heights[i] denote the name and height of the ith person.\nReturn names sorted in descending order by the people's heights.\n\u00a0\nExample 1:\n\nInput: names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170]\nOutput: [\"Mary\",\"Emma\",\"John\"]\nExplanation: Mary is the tallest, followed by Emma and John.\n\nExample 2:\n\nInput: names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150]\nOutput: [\"Bob\",\"Alice\",\"Bob\"]\nExplanation: The first Bob is the tallest, followed by Alice and the second Bob.\n\n\u00a0\nConstraints:\n\nn == names.length == heights.length\n1 <= n <= 103\n1 <= names[i].length <= 20\n1 <= heights[i] <= 105\nnames[i] consists of lower and upper case English letters.\nAll the values of heights are distinct. Explanation:\n\nSolution 1: Sorting\nAccording to the problem description, we can create an index array $idx$ of length $n$, where $idx[i]=i$. Then we sort each index in $idx$ in descending order according to the corresponding height in $heights$. Finally, we traverse each index $i$ in the sorted $idx$ and add $names[i]$ to the answer array.\nWe can also create an array $arr$ of length $n$, where each element is a tuple $(heights[i], i)$. Then we sort $arr$ in descending order by height. Finally, we traverse each element $(heights[i], i)$ in the sorted $arr$ and add $names[i]$ to the answer array.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the arrays $names$ and $heights$. \n\n", "problem_ids": ["sort-the-people"]}, "2881": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string s and an array of strings words, determine whether s is a prefix string of words.\nA string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.\nReturn true if s is a prefix string of words, or false otherwise.\n\u00a0\nExample 1:\n\nInput: s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"]\nOutput: true\nExplanation:\ns can be made by concatenating \"i\", \"love\", and \"leetcode\" together.\n\nExample 2:\n\nInput: s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"]\nOutput: false\nExplanation:\nIt is impossible to make s using a prefix of arr.\n\u00a0\nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 20\n1 <= s.length <= 1000\nwords[i] and s consist of only lowercase English letters. Explanation:\n\nSolution 1: Traversal\nWe traverse the array $words$, using a variable $t$ to record the currently concatenated string. If the length of $t$ is greater than the length of $s$, it means that $s$ is not a prefix string of $words$, so we return $false$; if the length of $t$ is equal to the length of $s$, we return whether $t$ is equal to $s$.\nAt the end of the traversal, if the length of $t$ is less than the length of $s$, it means that $s$ is not a prefix string of $words$, so we return $false$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the string $s$. \n\n", "problem_ids": ["check-if-string-is-a-prefix-of-array"]}, "2882": {"text": "Similar Problem 1 \n\n Problem:\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\nA sudoku solution must satisfy all of the following rules:\n\nEach of the digits 1-9 must occur exactly once in each row.\nEach of the digits 1-9 must occur exactly once in each column.\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n\nThe '.' character indicates empty cells.\n\u00a0\nExample 1:\n\n\nInput: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation:\u00a0The input board is shown above and the only valid solution is shown below:\n\n\n\n\u00a0\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit or '.'.\nIt is guaranteed that the input board has only one solution. Explanation:\n\nSolution 1: Backtracking\nWe use arrays row, col, and box to record whether a number has appeared in each row, each column, and each 3x3 grid respectively. If the number i has appeared in the rth row, the cth column, and the bth 3x3 grid, then row[r][i], col[c][i], and box[b][i] are all true.\nWe traverse each empty space in board, enumerate the numbers v that it can fill in. If v has not appeared in the current row, the current column, and the current 3x3 grid, then we can try to fill in the number v and continue to search for the next empty space. If we search to the end and all spaces are filled, it means that a feasible solution has been found.\nThe time complexity is $O(9^{81})$, and the space complexity is $O(9^2)$. \n\n", "problem_ids": ["sudoku-solver"]}, "2883": {"text": "Similar Problem 1 \n\n Problem:\n\nThe XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.\n\nFor example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.\n\nGiven an array nums, return the sum of all XOR totals for every subset of nums.\u00a0\nNote: Subsets with the same elements should be counted multiple times.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.\n\u00a0\nExample 1:\n\nInput: nums = [1,3]\nOutput: 6\nExplanation: The 4 subsets of [1,3] are:\n- The empty subset has an XOR total of 0.\n- [1] has an XOR total of 1.\n- [3] has an XOR total of 3.\n- [1,3] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6\n\nExample 2:\n\nInput: nums = [5,1,6]\nOutput: 28\nExplanation: The 8 subsets of [5,1,6] are:\n- The empty subset has an XOR total of 0.\n- [5] has an XOR total of 5.\n- [1] has an XOR total of 1.\n- [6] has an XOR total of 6.\n- [5,1] has an XOR total of 5 XOR 1 = 4.\n- [5,6] has an XOR total of 5 XOR 6 = 3.\n- [1,6] has an XOR total of 1 XOR 6 = 7.\n- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n\nExample 3:\n\nInput: nums = [3,4,5,6,7,8]\nOutput: 480\nExplanation: The sum of all XOR totals for every subset is 480.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 12\n1 <= nums[i] <= 20 Explanation:\n\nSolution 1: Binary Enumeration\nWe can use binary enumeration to enumerate all subsets, and then calculate the XOR sum of each subset.\nSpecifically, we enumerate $i$ in the range $[0, 2^n)$, where $n$ is the length of the array $nums$. If the $j$th bit of the binary representation of $i$ is $1$, it means that the $j$th element of $nums$ is in the current subset; if the $j$th bit is $0$, it means that the $j$th element of $nums$ is not in the current subset. We can get the XOR sum of the current subset according to the binary representation of $i$, and add it to the answer.\nThe time complexity is $O(n \\times 2^n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\n", "problem_ids": ["sum-of-all-subset-xor-totals"]}, "2884": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: transactions\n\n+------------------+------+\n| Column Name      | Type | \n+------------------+------+\n| transaction_id   | int  |\n| amount           | int  |\n| transaction_date | date |\n+------------------+------+\nThe transactions_id column uniquely identifies each row in this table.\nEach row of this table contains the transaction id, amount and transaction date.\n\nWrite a solution to find the sum of amounts for odd and even transactions for each day. If there are no odd or even transactions for a specific date, display as 0.\nReturn the result table ordered by transaction_date in ascending order.\nThe result format is in the following example.\n\u00a0\nExample:\n\nInput:\ntransactions table:\n\n+----------------+--------+------------------+\n| transaction_id | amount | transaction_date |\n+----------------+--------+------------------+\n| 1              | 150    | 2024-07-01       |\n| 2              | 200    | 2024-07-01       |\n| 3              | 75     | 2024-07-01       |\n| 4              | 300    | 2024-07-02       |\n| 5              | 50     | 2024-07-02       |\n| 6              | 120    | 2024-07-03       |\n+----------------+--------+------------------+\n  \nOutput:\n\n+------------------+---------+----------+\n| transaction_date | odd_sum | even_sum |\n+------------------+---------+----------+\n| 2024-07-01       | 75      | 350      |\n| 2024-07-02       | 0       | 350      |\n| 2024-07-03       | 0       | 120      |\n+------------------+---------+----------+\n  \nExplanation:\n\nFor transaction dates:\n    \n2024-07-01:\n        \nSum of amounts for odd transactions: 75\nSum of amounts for even transactions: 150 + 200 = 350\n\n\n2024-07-02:\n        \nSum of amounts for odd transactions: 0\nSum of amounts for even transactions: 300 + 50 = 350\n\n\n2024-07-03:\n        \nSum of amounts for odd transactions: 0\nSum of amounts for even transactions: 120\n\n\n\n\n\nNote: The output table is ordered by transaction_date in ascending order. Explanation:\n\nSolution 1: Grouping and Summing\nWe can group the data by transaction_date, and then calculate the sum of transaction amounts for odd and even dates separately. Finally, sort by transaction_date in ascending order.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nSELECT\n    transaction_date,\n    SUM(IF(amount % 2 = 1, amount, 0)) AS odd_sum,\n    SUM(IF(amount % 2 = 0, amount, 0)) AS even_sum\nFROM transactions\nGROUP BY 1\nORDER BY 1;\n```\nPandas\n```python\nimport pandas as pd\ndef sum_daily_odd_even(transactions: pd.DataFrame) -> pd.DataFrame:\n    transactions[\"odd_sum\"] = transactions[\"amount\"].where(\n        transactions[\"amount\"] % 2 == 1, 0\n    )\n    transactions[\"even_sum\"] = transactions[\"amount\"].where(\n        transactions[\"amount\"] % 2 == 0, 0\n    )\nresult = (\n    transactions.groupby(\"transaction_date\")\n    .agg(odd_sum=(\"odd_sum\", \"sum\"), even_sum=(\"even_sum\", \"sum\"))\n    .reset_index()\n)\n\nresult = result.sort_values(\"transaction_date\")\n\nreturn result\n\n``` \n\n", "problem_ids": ["odd-and-even-transactions"]}, "2886": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums, find the subarray with the largest sum, and return its sum.\n\u00a0\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n\u00a0\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i]$ to represent the maximum sum of the continuous subarray ending with the element $nums[i]$. Initially, $f[0] = nums[0]$. The final answer we are looking for is $\\max_{0 \\leq i < n} f[i]$.\nConsider $f[i]$, where $i \\geq 1$, its state transition equation is:\n$$\nf[i] = \\max { f[i - 1] + nums[i], nums[i] }\n$$\nWhich is also:\n$$\nf[i] = \\max { f[i - 1], 0 } + nums[i]\n$$\nSince $f[i]$ is only related to $f[i - 1]$, we can use a single variable $f$ to maintain the current value of $f[i]$, and then perform state transition. The answer is $\\max_{0 \\leq i < n} f$.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. We only need to traverse the array once to get the answer. The space complexity is $O(1)$, we only need constant space to store several variables. \n\n", "problem_ids": ["maximum-subarray"]}, "2887": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array points representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi].\nThe distance between two points is defined as their Manhattan distance.\nReturn the minimum possible value for maximum distance between any two points by removing exactly one point.\n\u00a0\nExample 1:\n\nInput: points = [[3,10],[5,15],[10,2],[4,4]]\nOutput: 12\nExplanation:\nThe maximum distance after removing each point is the following:\n\nAfter removing the 0th point the maximum distance is between points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.\nAfter removing the 1st point the maximum distance is between points (3, 10) and (10, 2), which is |3 - 10| + |10 - 2| = 15.\nAfter removing the 2nd point the maximum distance is between points (5, 15) and (4, 4), which is |5 - 4| + |15 - 4| = 12.\nAfter removing the 3rd point the maximum distance is between points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.\n\n12 is the minimum possible maximum distance between any two points after removing exactly one point.\n\nExample 2:\n\nInput: points = [[1,1],[1,1],[1,1]]\nOutput: 0\nExplanation:\nRemoving any of the points results in the maximum distance between any two points of 0.\n\n\u00a0\nConstraints:\n\n3 <= points.length <= 105\npoints[i].length == 2\n1 <= points[i][0], points[i][1] <= 108 Explanation:\n\nSolution 1: Ordered Set\nFor two points $(x_1, y_1)$ and $(x_2, y_2)$, their Manhattan distance is $|x_1 - x_2| + |y_1 - y_2|$. We can transform it into $\\max(x_1 - x_2, x_2 - x_1) + \\max(y_1 - y_2, y_2 - y_1)$, which is:\n$$\n|x_1 - x_2| + |y_1 - y_2| = \\max \\begin{cases}\nx_1 - x_2 + y_1 - y_2 \\\nx_2 - x_1 + y_2 - y_1 \\\nx_1 - x_2 + y_2 - y_1 \\\nx_2 - x_1 + y_1 - y_2\n\\end{cases}\n$$\nThis can be simplified to:\n$$\n|x_1 - x_2| + |y_1 - y_2| = \\max \\begin{cases}\n(x_1 + y_1) - (x_2 + y_2) \\\n(x_2 + y_2) - (x_1 + y_1) \\\n(x_1 - y_1) - (x_2 - y_2) \\\n(x_2 - y_2) - (x_1 - y_1)\n\\end{cases}\n$$\nHere, the first two cases can be represented as $\\max(\\max(x_1 + y_1, x_2 + y_2) - \\min(x_1 + y_1, x_2 + y_2))$, and the last two cases can be represented as $\\max(\\max(x_1 - y_1, x_2 - y_2) - \\min(x_1 - y_1, x_2 - y_2))$.\nTherefore, we can store all points according to the values of $x + y$ and $x - y$ in two ordered sets, respectively. Then, for each point, we remove it, update the values in the ordered sets, calculate the difference between the maximum and minimum values, and take the minimum value.\nThe time complexity is $O(n \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the number of points. \n\n", "problem_ids": ["minimize-manhattan-distances"]}, "2888": {"text": "Similar Problem 1 \n\n Problem:\n\nThere exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.\n\u00a0\nExample 1:\n\n\nInput: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.\n\nExample 2:\n\n\nInput: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.\n\n\u00a0\nConstraints:\n\n1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1 Explanation:\n\nSolution 1: Enumeration\nWe can enumerate each element $div$ in $divisors$, and calculate how many elements in $nums$ can be divided by $div$, denoted as $cnt$.\n\nIf $cnt$ is greater than the current maximum divisibility score $mx$, then update $mx = cnt$, and update $ans = div$.\nIf $cnt$ equals $mx$ and $div$ is less than $ans$, then update $ans = div$.\n\nFinally, return $ans$.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the lengths of $nums$ and $divisors$ respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["minimize-the-total-price-of-the-trips"]}, "2891": {"text": "Similar Problem 1 \n\n Problem:\n\nA magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\n\u00a0\nExample 1:\n\nInput: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= n <= 105 Explanation:\n\nSolution 1: Simulate the Construction Process\nAccording to the problem, we know that each group of numbers in the string $s$ can be obtained from the digits of the string $s$ itself.\nThe first two groups of numbers in string $s$ are $1$ and $22$, which are obtained from the first and second digits of string $s$, respectively. Moreover, the first group of numbers contains only $1$, the second group contains only $2$, the third group contains only $1$, and so on.\nSince the first two groups of numbers are known, we initialize string $s$ as $122$, and then start constructing from the third group. The third group of numbers is obtained from the third digit of string $s$ (index $i=2$), so at this point, we point the pointer $i$ to the third digit $2$ of string $s$.\n1 2 2\n    ^\n    i\nThe digit pointed by pointer $i$ is $2$, indicating that the third group of numbers will appear twice. Since the previous group of numbers is $2$, and the numbers alternate between groups, the third group of numbers is two $1$s, i.e., $11$. After construction, the pointer $i$ moves to the next position, pointing to the fourth digit $1$ of string $s$.\n1 2 2 1 1\n      ^\n      i\nAt this point, the digit pointed by pointer $i$ is $1$, indicating that the fourth group of numbers will appear once. Since the previous group of numbers is $1$, and the numbers alternate between groups, the fourth group of numbers is one $2$, i.e., $2$. After construction, the pointer $i$ moves to the next position, pointing to the fifth digit $1$ of string $s$.\n1 2 2 1 1 2\n        ^\n        i\nFollowing this rule, we simulate the construction process sequentially until the length of string $s$ is greater than or equal to $n$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. \n\n", "problem_ids": ["magical-string"]}, "2892": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\u00a0\nExample 1:\n\n\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\n\nInput: inorder = [-1], postorder = [-1]\nOutput: [-1]\n\n\u00a0\nConstraints:\n\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree. Explanation:\n\nSolution 1: Hash Table + Recursion\nThe last node in the post-order traversal is the root node. We can find the position of the root node in the in-order traversal, and then recursively construct the left and right subtrees.\nSpecifically, we first use a hash table $d$ to store the position of each node in the in-order traversal. Then we design a recursive function $dfs(i, j, n)$, where $i$ and $j$ represent the starting positions of the in-order and post-order traversals, respectively, and $n$ represents the number of nodes in the subtree. The function logic is as follows:\n\nIf $n \\leq 0$, it means the subtree is empty, return a null node.\nOtherwise, take out the last node $v$ of the post-order traversal, and then find the position $k$ of $v$ in the in-order traversal using the hash table $d$. Then the number of nodes in the left subtree is $k - i$, and the number of nodes in the right subtree is $n - k + i - 1$.\nRecursively construct the left subtree $dfs(i, j, k - i)$ and the right subtree $dfs(k + 1, j + k - i, n - k + i - 1)$, connect them to the root node, and finally return the root node.\n\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["construct-binary-tree-from-inorder-and-postorder-traversal"]}, "2893": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated string because it is not the concatenation of any permutation of words.\n\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\u00a0\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation:\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation:\nThere is no concatenated substring.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation:\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"].\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"].\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"].\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters. Explanation:\n\nSolution 1: Hash Table + Sliding Window\nWe use a hash table $cnt$ to count the number of times each word appears in $words$, and use a hash table $cnt1$ to count the number of times each word appears in the current sliding window. We denote the length of the string $s$ as $m$, the number of words in the string array $words$ as $n$, and the length of each word as $k$.\nWe can enumerate the starting point $i$ of the sliding window, where $0 \\lt i < k$. For each starting point, we maintain a sliding window with the left boundary as $l$, the right boundary as $r$, and the number of words in the sliding window as $t$. Additionally, we use a hash table $cnt1$ to count the number of times each word appears in the sliding window.\nEach time, we extract the string $s[r:r+k]$. If $s[r:r+k]$ is not in the hash table $cnt$, it means that the words in the current sliding window are not valid. We update the left boundary $l$ to $r$, clear the hash table $cnt1$, and reset the word count $t$ to 0. If $s[r:r+k]$ is in the hash table $cnt$, it means that the words in the current sliding window are valid. We increase the word count $t$ by 1, and increase the count of $s[r:r+k]$ in the hash table $cnt1$ by 1. If $cnt1[s[r:r+k]]$ is greater than $cnt[s[r:r+k]]$, it means that $s[r:r+k]$ appears too many times in the current sliding window. We need to move the left boundary $l$ to the right until $cnt1[s[r:r+k]] = cnt[s[r:r+k]]$. If $t = n$, it means that the words in the current sliding window are exactly valid, and we add the left boundary $l$ to the answer array.\nThe time complexity is $O(m \\times k)$, and the space complexity is $O(n \\times k)$. Here, $m$ and $n$ are the lengths of the string $s$ and the string array $words$ respectively, and $k$ is the length of the words in the string array $words$. \n\n", "problem_ids": ["substring-with-concatenation-of-all-words"]}, "2902": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums of even length.\nAs long as nums is not empty, you must repetitively:\n\nFind the minimum number in nums and remove it.\nFind the maximum number in nums and remove it.\nCalculate the average of the two removed numbers.\n\nThe average of two numbers a and b is (a + b) / 2.\n\nFor example, the average of 2 and 3 is (2 + 3) / 2 = 2.5.\n\nReturn the number of distinct averages calculated using the above process.\nNote that when there is a tie for a minimum or maximum number, any can be removed.\n\u00a0\nExample 1:\n\nInput: nums = [4,1,4,0,3,5]\nOutput: 2\nExplanation:\n1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].\n2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].\n3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.\nSince there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.\n\nExample 2:\n\nInput: nums = [1,100]\nOutput: 1\nExplanation:\nThere is only one average to be calculated after removing 1 and 100, so we return 1.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 100\nnums.length is even.\n0 <= nums[i] <= 100 Explanation:\n\nSolution 1: Sorting\nThe problem requires us to find the minimum and maximum values in the array $nums$ each time, delete them, and then calculate the average of the two deleted numbers. Therefore, we can first sort the array $nums$, then take the first and last elements of the array each time, calculate their sum, use a hash table or array $cnt$ to record the number of times each sum appears, and finally count the number of different sums.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["number-of-distinct-averages"]}, "2915": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums, return the number of AND triples.\nAn AND triple is a triple of indices (i, j, k) such that:\n\n0 <= i < nums.length\n0 <= j < nums.length\n0 <= k < nums.length\nnums[i] & nums[j] & nums[k] == 0, where & represents the bitwise-AND operator.\n\n\u00a0\nExample 1:\n\nInput: nums = [2,1,3]\nOutput: 12\nExplanation: We could choose the following i, j, k triples:\n(i=0, j=0, k=1) : 2 & 2 & 1\n(i=0, j=1, k=0) : 2 & 1 & 2\n(i=0, j=1, k=1) : 2 & 1 & 1\n(i=0, j=1, k=2) : 2 & 1 & 3\n(i=0, j=2, k=1) : 2 & 3 & 1\n(i=1, j=0, k=0) : 1 & 2 & 2\n(i=1, j=0, k=1) : 1 & 2 & 1\n(i=1, j=0, k=2) : 1 & 2 & 3\n(i=1, j=1, k=0) : 1 & 1 & 2\n(i=1, j=2, k=0) : 1 & 3 & 2\n(i=2, j=0, k=1) : 3 & 2 & 1\n(i=2, j=1, k=0) : 3 & 1 & 2\n\nExample 2:\n\nInput: nums = [0,0,0]\nOutput: 27\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] < 216 Explanation:\n\nSolution 1: Enumeration + Counting\nFirst, we enumerate any two numbers $x$ and $y$, and use a hash table or array $cnt$ to count the occurrences of their bitwise AND result $x \\& y$.\nThen, we enumerate the bitwise AND result $xy$, and enumerate $z$. If $xy \\& z = 0$, then we add the value of $cnt[xy]$ to the answer.\nFinally, we return the answer.\nThe time complexity is $O(n^2 + n \\times M)$, and the space complexity is $O(M)$, where $n$ is the length of the array $nums$; and $M$ is the maximum value in the array $nums$, with $M \\leq 2^{16}$ in this problem. \n\n", "problem_ids": ["triples-with-bitwise-and-equal-to-zero"]}, "2916": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array nums, where each number in the array appears either once or twice.\nReturn the bitwise XOR of all the numbers that appear twice in the array, or 0 if no number appears twice.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,1,3]\nOutput: 1\nExplanation:\nThe only number that appears twice in\u00a0nums\u00a0is 1.\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: 0\nExplanation:\nNo number appears twice in\u00a0nums.\n\nExample 3:\n\nInput: nums = [1,2,2,1]\nOutput: 3\nExplanation:\nNumbers 1 and 2 appeared twice. 1 XOR 2 == 3.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\nEach number in nums appears either once or twice. Explanation:\n\nSolution 1: Counting\nWe define an array or hash table cnt to record the occurrence of each number.\nNext, we traverse the array nums. When a number appears twice, we perform an XOR operation with the answer.\nFinally, we return the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(M)$. Where $n$ is the length of the array nums, and $M$ is the maximum value in the array nums or the number of distinct numbers in the array nums. \n\n", "problem_ids": ["find-the-xor-of-numbers-which-appear-twice"]}, "2917": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.\nYour task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:\n\nabs(i - j) >= indexDifference, and\nabs(nums[i] - nums[j]) >= valueDifference\n\nReturn an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.\nNote: i and j may be equal.\n\u00a0\nExample 1:\n\nInput: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4\nOutput: [0,3]\nExplanation: In this example, i = 0 and j = 3 can be selected.\nabs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.\nHence, a valid answer is [0,3].\n[3,0] is also a valid answer.\n\nExample 2:\n\nInput: nums = [2,1], indexDifference = 0, valueDifference = 0\nOutput: [0,0]\nExplanation: In this example, i = 0 and j = 0 can be selected.\nabs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.\nHence, a valid answer is [0,0].\nOther valid answers are [0,1], [1,0], and [1,1].\n\nExample 3:\n\nInput: nums = [1,2,3], indexDifference = 2, valueDifference = 4\nOutput: [-1,-1]\nExplanation: In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.\nHence, [-1,-1] is returned.\n\u00a0\nConstraints:\n\n1 <= n == nums.length <= 100\n0 <= nums[i] <= 50\n0 <= indexDifference <= 100\n0 <= valueDifference <= 50 Explanation:\n\nSolution 1: Two Pointers + Maintaining Maximum and Minimum Values\nWe use two pointers $i$ and $j$ to maintain a sliding window with a gap of $indexDifference$, where $j$ and $i$ point to the left and right boundaries of the window, respectively. Initially, $i$ points to $indexDifference$, and $j` points to $0$.\nWe use $mi$ and $mx$ to maintain the indices of the minimum and maximum values to the left of pointer $j$.\nWhen pointer $i$ moves to the right, we need to update $mi$ and $mx$. If $nums[j] \\lt nums[mi]$, then $mi$ is updated to $j$; if $nums[j] \\gt nums[mx]$, then $mx$ is updated to $j$. After updating $mi$ and $mx$, we can determine whether we have found a pair of indices that satisfy the condition. If $nums[i] - nums[mi] \\ge valueDifference$, then we have found a pair of indices $[mi, i]$ that satisfy the condition; if $nums[mx] - nums[i] >= valueDifference$, then we have found a pair of indices $[mx, i]$ that satisfy the condition.\nIf pointer $i$ moves to the end of the array and we have not found a pair of indices that satisfy the condition, we return $[-1, -1]$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["find-indices-with-index-and-value-difference-i"]}, "2919": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n\u00a0\nExample 1:\nInput: s = \"abc\", t = \"ahbgdc\"\nOutput: true\n\nExample 2:\nInput: s = \"axc\", t = \"ahbgdc\"\nOutput: false\n\n\u00a0\nConstraints:\n\n0 <= s.length <= 100\n0 <= t.length <= 104\ns and t consist only of lowercase English letters.\n\n\u00a0\nFollow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where k >= 109, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code? Explanation:\n\nSolution 1: Two Pointers\nWe define two pointers $i$ and $j$ to point to the initial position of the string $s$ and $t$ respectively. Each time we compare the two characters pointed to by the two pointers, if they are the same, both pointers move right at the same time; if they are not the same, only $j$ moves right. When the pointer $i$ moves to the end of the string $s$, it means that $s$ is the subsequence of $t$.\nThe time complexity is $O(m + n)$, where $m$ and $n$ are the lengths of the strings $s$ and $t$ respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["is-subsequence"]}, "2920": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.\n\u00a0\nExample 1:\n\n\nInput: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]\n\nExample 2:\n\n\nInput: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]\n\n\u00a0\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 104\n1 <= m * n <= 104\nmat[i][j] is either 0 or 1.\nThere is at least one 0 in mat. Explanation:\n\nSolution 1: BFS\nWe create a matrix $\\textit{ans}$ of the same size as $\\textit{mat}$ and initialize all elements to $-1$.\nThen, we traverse $\\textit{mat}$, adding the coordinates $(i, j)$ of all $0$ elements to the queue $\\textit{q}$, and setting $\\textit{ans}[i][j]$ to $0$.\nNext, we use Breadth-First Search (BFS), removing an element $(i, j)$ from the queue and traversing its four directions. If the element in that direction $(x, y)$ satisfies $0 \\leq x < m$, $0 \\leq y < n$ and $\\textit{ans}[x][y] = -1$, then we set $\\textit{ans}[x][y]$ to $\\textit{ans}[i][j] + 1$ and add $(x, y)$ to the queue $\\textit{q}$.\nFinally, we return $\\textit{ans}$.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns in the matrix $\\textit{mat}$, respectively. \n\n", "problem_ids": ["01-matrix"]}, "2921": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a hotel with n rooms. The rooms are represented by a 2D integer array rooms where rooms[i] = [roomIdi, sizei] denotes that there is a room with room number roomIdi and size equal to sizei. Each roomIdi is guaranteed to be unique.\nYou are also given k queries in a 2D array queries where queries[j] = [preferredj, minSizej]. The answer to the jth query is the room number id of a room such that:\n\nThe room has a size of at least minSizej, and\nabs(id - preferredj) is minimized, where abs(x) is the absolute value of x.\n\nIf there is a tie in the absolute difference, then use the room with the smallest such id. If there is no such room, the answer is -1.\nReturn an array answer of length k where answer[j] contains the answer to the jth query.\n\u00a0\nExample 1:\n\nInput: rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]\nOutput: [3,-1,3]\nExplanation: The answers to the queries are as follows:\nQuery = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.\nQuery = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.\nQuery = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.\nExample 2:\n\nInput: rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]\nOutput: [2,1,3]\nExplanation: The answers to the queries are as follows:\nQuery = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.\nQuery = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.\nQuery = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3.\n\u00a0\nConstraints:\n\nn == rooms.length\n1 <= n <= 105\nk == queries.length\n1 <= k <= 104\n1 <= roomIdi, preferredj <= 107\n1 <= sizei, minSizej <= 107 Explanation:\n\nSolution 1: Offline Query + Ordered Set + Binary Search\nWe notice that the order of queries does not affect the answer, and the problem involves the size relationship of room areas. Therefore, we can sort the queries in ascending order of minimum area, so that we can process each query from small to large. Also, we sort the rooms in ascending order of area.\nNext, we create an ordered list and add all room numbers to the ordered list.\nThen, we process each query from small to large. For each query, we first remove all rooms with an area less than or equal to the current query's minimum area from the ordered list. Then, in the remaining rooms, we use binary search to find the room number closest to the current query. If there is no such room, we return $-1$.\nThe time complexity is $O(n \\times \\log n + k \\times \\log k)$, and the space complexity is $O(n + k)$. Where $n$ and $k$ are the number of rooms and queries, respectively. \n\n", "problem_ids": ["closest-room"]}, "2952": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array digits, where each element is a digit. The array may contain duplicates.\nYou need to find all the unique integers that follow the given requirements:\n\nThe integer consists of the concatenation of three elements from digits in any arbitrary order.\nThe integer does not have leading zeros.\nThe integer is even.\n\nFor example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.\nReturn a sorted array of the unique integers.\n\u00a0\nExample 1:\n\nInput: digits = [2,1,3,0]\nOutput: [102,120,130,132,210,230,302,310,312,320]\nExplanation: All the possible integers that follow the requirements are in the output array. \nNotice that there are no odd integers or integers with leading zeros.\n\nExample 2:\n\nInput: digits = [2,2,8,8,2]\nOutput: [222,228,282,288,822,828,882]\nExplanation: The same digit can be used as many times as it appears in digits. \nIn this example, the digit 8 is used twice each time in 288, 828, and 882. \n\nExample 3:\n\nInput: digits = [3,7,5]\nOutput: []\nExplanation: No even integers can be formed using the given digits.\n\n\u00a0\nConstraints:\n\n3 <= digits.length <= 100\n0 <= digits[i] <= 9 Explanation:\n\nSolution 1: Counting + Enumeration\nFirst, we count the occurrence of each digit in $\\textit{digits}$, recording it in an array or hash table $\\textit{cnt}$.\nThen, we enumerate all even numbers in the range $[100, 1000)$, checking if each digit of the even number does not exceed the corresponding digit's count in $\\textit{cnt}$. If so, we add this even number to the answer array.\nFinally, we return the answer array.\nThe time complexity is $O(k \\times 10^k)$, where $k$ is the number of digits of the target even number, which is $3$ in this problem. Ignoring the space consumed by the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["finding-3-digit-even-numbers"]}, "2953": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\n\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order. Explanation:\n\nSolution 1: Single Pass\nWe use a variable $k$ to record the current length of the processed array. Initially, $k=0$ represents an empty array.\nThen we traverse the array from left to right. For each element $x$ we encounter, if $k=0$ or $x \\neq nums[k-1]$, we place $x$ in the position of $nums[k]$, and then increment $k$ by $1$. Otherwise, $x$ is the same as $nums[k-1]$, so we skip this element. Continue to traverse until the entire array is traversed.\nIn this way, when the traversal ends, the first $k$ elements in $nums$ are the answer we are looking for, and $k$ is the length of the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array.\nSupplement:\nThe original problem requires that the same number appear at most once. We can extend it to keep at most $k$ identical numbers.\n\nSince the same number can be kept at most $k$ times, we can directly keep the first $k$ elements of the original array;\nFor the following numbers, the premise of being able to keep them is: the current number $x$ is compared with the last $k$th element of the previously retained numbers. If they are different, keep them, otherwise skip them.\n\nSimilar problems:\n\n80. Remove Duplicates from Sorted Array II \n\n", "problem_ids": ["remove-duplicates-from-sorted-array"]}, "2954": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array nums and a 0-indexed array queries.\nYou can do the following operation at the beginning at most once:\n\nReplace nums with a subsequence of nums.\n\nWe start processing queries in the given order; for each query, we do the following:\n\nIf the first and the last element of nums is less than queries[i], the processing of queries ends.\nOtherwise, we choose either the first or the last element of nums if it is greater than or equal to queries[i], and we remove the chosen element from nums.\n\nReturn the maximum number of queries that can be processed by doing the operation optimally.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4,5], queries = [1,2,3,4,6]\nOutput: 4\nExplanation: We don't do any operation and process the queries as follows:\n1- We choose and remove nums[0] since 1 <= 1, then nums becomes [2,3,4,5].\n2- We choose and remove nums[0] since 2 <= 2, then nums becomes [3,4,5].\n3- We choose and remove nums[0] since 3 <= 3, then nums becomes [4,5].\n4- We choose and remove nums[0] since 4 <= 4, then nums becomes [5].\n5- We can not choose any elements from nums since they are not greater than or equal to 5.\nHence, the answer is 4.\nIt can be shown that we can't process more than 4 queries.\n\nExample 2:\n\nInput: nums = [2,3,2], queries = [2,2,3]\nOutput: 3\nExplanation: We don't do any operation and process the queries as follows:\n1- We choose and remove nums[0] since 2 <= 2, then nums becomes [3,2].\n2- We choose and remove nums[1] since 2 <= 2, then nums becomes [3].\n3- We choose and remove nums[0] since 3 <= 3, then nums becomes [].\nHence, the answer is 3.\nIt can be shown that we can't process more than 3 queries.\n\nExample 3:\n\nInput: nums = [3,4,3], queries = [4,3,2]\nOutput: 2\nExplanation: First we replace nums with the subsequence of nums [4,3].\nThen we can process the queries as follows:\n1- We choose and remove nums[0] since 4 <= 4, then nums becomes [3].\n2- We choose and remove nums[0] since 3 <= 3, then nums becomes [].\n3- We can not process any more queries since nums is empty.\nHence, the answer is 2.\nIt can be shown that we can't process more than 2 queries.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= queries.length <= 1000\n1 <= nums[i], queries[i] <= 109 Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i][j]$ as the maximum number of queries we can handle when the numbers in the interval $[i, j]$ have not been deleted yet.\nConsider $f[i][j]$:\n\nIf $i > 0$, the value of $f[i][j]$ can be transferred from $f[i - 1][j]$. If $nums[i - 1] \\ge queries[f[i - 1][j]]$, we can choose to delete $nums[i - 1]$. Therefore, we have $f[i][j] = f[i - 1][j] + (nums[i - 1] \\ge queries[f[i - 1][j]])$.\nIf $j + 1 < n$, the value of $f[i][j]$ can be transferred from $f[i][j + 1]$. If $nums[j + 1] \\ge queries[f[i][j + 1]]$, we can choose to delete $nums[j + 1]$. Therefore, we have $f[i][j] = f[i][j + 1] + (nums[j + 1] \\ge queries[f[i][j + 1]])$.\nIf $f[i][j] = m$, we can directly return $m$.\n\nThe final answer is $\\max\\limits_{0 \\le i < n} f[i][i] + (nums[i] \\ge queries[f[i][i]])$.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["maximum-number-of-removal-queries-that-can-be-processed-i"]}, "2955": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string.\nAn English letter b is greater than another letter a if b appears after a in the English alphabet.\n\u00a0\nExample 1:\n\nInput: s = \"lEeTcOdE\"\nOutput: \"E\"\nExplanation:\nThe letter 'E' is the only letter to appear in both lower and upper case.\n\nExample 2:\n\nInput: s = \"arRAzFif\"\nOutput: \"R\"\nExplanation:\nThe letter 'R' is the greatest letter to appear in both lower and upper case.\nNote that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'.\n\nExample 3:\n\nInput: s = \"AbCdEfGhIjK\"\nOutput: \"\"\nExplanation:\nThere is no letter that appears in both lower and upper case.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 1000\ns consists of lowercase and uppercase English letters. Explanation:\n\nSolution 1: Hash Table + Enumeration\nFirst, we use a hash table $ss$ to record all the letters that appear in the string $s$. Then we start enumerating from the last letter of the uppercase alphabet. If both the uppercase and lowercase forms of the current letter are in $ss$, we return that letter.\nAt the end of the enumeration, if no letter that meets the conditions is found, we return an empty string.\nThe time complexity is $O(n)$, and the space complexity is $O(C)$. Here, $n$ and $C$ are the length of the string $s$ and the size of the character set, respectively. \n\n", "problem_ids": ["greatest-english-letter-in-upper-and-lower-case"]}, "2977": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.\n\u00a0\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\n\u00a0\nConstraints:\n\n0 <= nums.length <= 105\n-109\u00a0<= nums[i]\u00a0<= 109\nnums is a non-decreasing array.\n-109\u00a0<= target\u00a0<= 109 Explanation:\n\nSolution 1: Binary Search\nWe can perform binary search twice to find the left and right boundaries respectively.\nThe time complexity is $O(\\log n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array $nums$.\nBelow are two general templates for binary search:\nTemplate 1:\n```java\nboolean check(int x) {\n}\nint search(int left, int right) {\n    while (left < right) {\n        int mid = (left + right) >> 1;\n        if (check(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\nTemplate 2:\n```java\nboolean check(int x) {\n}\nint search(int left, int right) {\n    while (left < right) {\n        int mid = (left + right + 1) >> 1;\n        if (check(mid)) {\n            left = mid;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n}\n```\nWhen doing binary search problems, you can follow the following routine:\n\nWrite out the loop condition $left < right$;\nInside the loop, you might as well write $mid = \\lfloor \\frac{left + right}{2} \\rfloor$ first;\nAccording to the specific problem, implement the $check()$ function (sometimes the logic is very simple, you can not define $check$), think about whether to use $right = mid$ (Template $1$) or $left = mid$ (Template $2$);\nIf $right = mid$, then write the else statement $left = mid + 1$, and there is no need to change the calculation of $mid$, that is, keep $mid = \\lfloor \\frac{left + right}{2} \\rfloor$;\nIf $left = mid$, then write the else statement $right = mid - 1$, and add +1 when calculating $mid$, that is, $mid = \\lfloor \\frac{left + right + 1}{2} \\rfloor$;\n\n\nWhen the loop ends, $left$ equals $right$.\n\nNote that the advantage of these two templates is that they always keep the answer within the binary search interval, and the value corresponding to the end condition of the binary search is exactly at the position of the answer. For the case that may have no solution, just check whether the $left$ or $right$ after the binary search ends satisfies the problem. \n\n", "problem_ids": ["find-first-and-last-position-of-element-in-sorted-array"]}, "2979": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\n\u00a0\nExample 1:\n\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\nOutput: 2\nExplanation: \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\n\nExample 2:\n\nInput: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\nOutput: 2\n\nExample 3:\n\nInput: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= arr1.length, arr2.length <= 500\n-1000 <= arr1[i], arr2[j] <= 1000\n0 <= d <= 100 Explanation:\n\nSolution 1: Sorting + Binary Search\nWe can first sort the array $arr2$, then for each element $a$ in array $arr1$, use binary search to find the first element in array $arr2$ that is greater than or equal to $a-d$. If such an element exists and is less than or equal to $a+d$, it means that it does not meet the distance requirement. Otherwise, it meets the distance requirement. We accumulate the number of elements that meet the distance requirement, which is the answer.\nThe time complexity is $O((m + n) \\times \\log n)$, and the space complexity is $O(\\log n)$. Where $m$ and $n$ are the lengths of arrays $arr1$ and $arr2$, respectively. \n\n", "problem_ids": ["find-the-distance-value-between-two-arrays"]}, "2998": {"text": "Similar Problem 1 \n\n Problem:\n\nWrite an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\n\nIntegers in each row are sorted in ascending from left to right.\nIntegers in each column are sorted in ascending from top to bottom.\n\n\u00a0\nExample 1:\n\n\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\nOutput: true\n\nExample 2:\n\n\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\nOutput: false\n\n\u00a0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= n, m <= 300\n-109 <= matrix[i][j] <= 109\nAll the integers in each row are sorted in ascending order.\nAll the integers in each column are sorted in ascending order.\n-109 <= target <= 109 Explanation:\n\nSolution 1: Binary Search\nSince all elements in each row are sorted in ascending order, we can use binary search to find the first element that is greater than or equal to target for each row, and then check if this element is equal to target. If it equals target, it means the target value has been found, and we directly return true. If it does not equal target, it means all elements in this row are less than target, and we should continue to search the next row.\nIf all rows have been searched and the target value has not been found, it means the target value does not exist, so we return false.\nThe time complexity is $O(m \\times \\log n)$, where $m$ and $n$ are the number of rows and columns in the matrix, respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["search-a-2d-matrix-ii"]}, "2999": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\n\u00a0\nExample 1:\n\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is sz.\n1 <= sz <= 30\n0 <= Node.val <= 100\n1 <= n <= sz\n\n\u00a0\nFollow up: Could you do this in one pass? Explanation:\n\nSolution 1: Fast and Slow Pointers\nWe define two pointers fast and slow, both initially pointing to the dummy head node of the linked list.\nNext, the fast pointer moves forward $n$ steps first, then fast and slow pointers move forward together until the fast pointer reaches the end of the linked list. At this point, the node pointed to by slow.next is the predecessor of the $n$-th node from the end, and we can delete it.\nThe time complexity is $O(n)$, where $n$ is the length of the linked list. The space complexity is $O(1)$. \n\n", "problem_ids": ["remove-nth-node-from-end-of-list"]}, "3000": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a regular convex polygon with n vertices. The vertices are labeled from 0 to n - 1 in a clockwise direction, and each vertex has exactly one monkey. The following figure shows a convex polygon of 6 vertices.\n\nSimultaneously, each monkey moves to a neighboring vertex. A collision happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge.\nReturn the number of ways the monkeys can move so that at least one collision happens. Since the answer may be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: n = 3\nOutput: 6\nExplanation:\nThere are 8 total possible movements.\nTwo ways such that they collide at some point are:\n\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.\nMonkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.\n\n\nExample 2:\n\nInput: n = 4\nOutput: 14\n\n\u00a0\nConstraints:\n\n3 <= n <= 109 Explanation:\n\nSolution 1: Mathematics (Fast Power)\nAccording to the problem description, each monkey has two ways of moving, either clockwise or counterclockwise. Therefore, there are a total of $2^n$ ways to move. The non-collision ways of moving are only two, that is, all monkeys move clockwise or all monkeys move counterclockwise. Therefore, the number of collision ways of moving is $2^n - 2$.\nWe can use fast power to calculate the value of $2^n$, then use $2^n - 2$ to calculate the number of collision ways of moving, and finally take the remainder of $10^9 + 7$.\nThe time complexity is $O(\\log n)$, where $n$ is the number of monkeys. The space complexity is $O(1)$. \n\n", "problem_ids": ["count-collisions-of-monkeys-on-a-polygon"]}, "3017": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.\n\u00a0\nExample 1:\n\nInput: nums = [1,3,6,10,12,15]\nOutput: 9\nExplanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.\n\nExample 2:\n\nInput: nums = [1,2,4,7,10]\nOutput: 0\nExplanation: There is no single number that satisfies the requirement, so return 0.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000 Explanation:\n\nSolution 1: Simulation\nWe notice that an even number divisible by $3$ must be a multiple of $6$. Therefore, we only need to traverse the array, count the sum and the number of all multiples of $6$, and then calculate the average.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["average-value-of-even-numbers-that-are-divisible-by-three"]}, "3018": {"text": "Similar Problem 1 \n\n Problem:\n\nA binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.\n\u00a0\nExample 1:\n\nInput: s = \"00110\"\nOutput: 1\nExplanation: We flip the last digit to get 00111.\n\nExample 2:\n\nInput: s = \"010110\"\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.\n\nExample 3:\n\nInput: s = \"00011000\"\nOutput: 2\nExplanation: We flip to get 00000000.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns[i] is either '0' or '1'. Explanation:\n\nSolution 1: Prefix Sum + Enumeration\nFirst, we count the number of '0's in string $s$, denoted as $tot$. We define a variable $ans$ for the answer, initially set $ans = tot$, which represents the number of flips to change all '0's to '1's.\nThen, we can enumerate each position $i$, change all '1's to the left of position $i$ (including $i$) to '0', and change all '0's to the right of position $i$ to '1'. We calculate the number of flips in this case, which is $i + 1 - cur + tot - cur$, where $cur$ represents the number of '0's to the left of position $i$ (including $i$). We update the answer $ans = \\min(ans, i + 1 - cur + tot - cur)$.\nFinally, return the answer $ans$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["flip-string-to-monotone-increasing"]}, "3019": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.\n\u00a0\nExample 1:\n\nInput: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.\n\nExample 2:\n\nInput: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.\n\nExample 3:\n\nInput: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.\n\n\u00a0\nConstraints:\n\n1 <= n <= 109\n\n\u00a0 Explanation:\n\nSolution 1: Simulation\nWe can directly simulate the process as described in the problem.\nWe define an initial symbol $sign=1$. Starting from the most significant digit, we take out one digit $x$ each time, multiply it by $sign$, add the result to the answer, then negate $sign$, and continue to process the next digit until all digits are processed.\nThe time complexity is $O(\\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the given number. \n\n", "problem_ids": ["alternating-digit-sum"]}, "3024": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a binary string s, and a 2D integer array queries where queries[i] = [firsti, secondi].\nFor the ith query, find the shortest substring of s whose decimal value, val, yields secondi when bitwise XORed with firsti. In other words, val ^ firsti == secondi.\nThe answer to the ith query is the endpoints (0-indexed) of the substring [lefti, righti] or [-1, -1] if no such substring exists. If there are multiple answers, choose the one with the minimum lefti.\nReturn an array ans where ans[i] = [lefti, righti] is the answer to the ith query.\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nExample 1:\n\nInput: s = \"101101\", queries = [[0,5],[1,2]]\nOutput: [[0,2],[2,3]]\nExplanation: For the first query the substring in range [0,2] is \"101\" which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the first query is [0,2]. In the second query, the substring in range [2,3] is \"11\", and has a decimal value of 3, and 3 ^ 1 = 2.\u00a0So, [2,3] is returned for the second query. \n\n\nExample 2:\n\nInput: s = \"0101\", queries = [[12,8]]\nOutput: [[-1,-1]]\nExplanation: In this example there is no substring that answers the query, hence [-1,-1] is returned.\n\nExample 3:\n\nInput: s = \"1\", queries = [[4,5]]\nOutput: [[0,0]]\nExplanation: For this example, the substring in range [0,0] has a decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 104\ns[i] is either '0' or '1'.\n1 <= queries.length <= 105\n0 <= firsti, secondi <= 109 Explanation:\n\nSolution 1: Preprocessing + Enumeration\nWe can first preprocess all substrings of length $1$ to $32$ into their corresponding decimal values, find the minimum index and the corresponding right endpoint index for each value, and store them in the hash table $d$.\nThen we enumerate each query. For each query $[first, second]$, we only need to check in the hash table $d$ whether there exists a key-value pair with the key as $first \\oplus second$. If it exists, add the corresponding minimum index and right endpoint index to the answer array. Otherwise, add $[-1, -1]$.\nThe time complexity is $O(n \\times \\log M + m)$, and the space complexity is $O(n \\times \\log M)$. Where $n$ and $m$ are the lengths of the string $s$ and the query array $queries$ respectively, and $M$ can take the maximum value of an integer $2^{31} - 1$. \n\n", "problem_ids": ["substring-xor-queries"]}, "3025": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array nums of distinct integers.\nLet us define a 0-indexed array ans of the same length as nums in the following way:\n\nans[i] is the maximum length of a subarray nums[l..r], such that the maximum element in that subarray is equal to nums[i].\n\nReturn the array ans.\nNote that a subarray is a contiguous part of the array.\n\u00a0\nExample 1:\n\nInput: nums = [1,5,4,3,6]\nOutput: [1,4,2,1,5]\nExplanation: For nums[0] the longest subarray in which 1 is the maximum is nums[0..0] so ans[0] = 1.\nFor nums[1] the longest subarray in which 5 is the maximum is nums[0..3] so ans[1] = 4.\nFor nums[2] the longest subarray in which 4 is the maximum is nums[2..3] so ans[2] = 2.\nFor nums[3] the longest subarray in which 3 is the maximum is nums[3..3] so ans[3] = 1.\nFor nums[4] the longest subarray in which 6 is the maximum is nums[0..4] so ans[4] = 5.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: [1,2,3,4,5]\nExplanation: For nums[i] the longest subarray in which it's the maximum is nums[0..i] so ans[i] = i + 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\nAll elements in nums are distinct. Explanation:\n\nSolution 1: Monotonic Stack\nThis problem is a template for monotonic stack. We only need to use the monotonic stack to find the position of the first element larger than $nums[i]$ on the left and right, denoted as $left[i]$ and $right[i]$. Then, the interval length with $nums[i]$ as the maximum value is $right[i] - left[i] - 1$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["maximal-range-that-each-element-is-maximum-in-it"]}, "3031": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array of positive integers nums of length n.\nWe call a pair of non-negative integer arrays (arr1, arr2) monotonic if:\n\nThe lengths of both arrays are n.\narr1 is monotonically non-decreasing, in other words, arr1[0] <= arr1[1] <= ... <= arr1[n - 1].\narr2 is monotonically non-increasing, in other words, arr2[0] >= arr2[1] >= ... >= arr2[n - 1].\narr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.\n\nReturn the count of monotonic pairs.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,2]\nOutput: 4\nExplanation:\nThe good pairs are:\n\n([0, 1, 1], [2, 2, 1])\n([0, 1, 2], [2, 2, 0])\n([0, 2, 2], [2, 1, 0])\n([1, 2, 2], [1, 1, 0])\n\n\nExample 2:\n\nInput: nums = [5,5,5,5]\nOutput: 126\n\n\u00a0\nConstraints:\n\n1 <= n == nums.length <= 2000\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Dynamic Programming + Prefix Sum Optimization\nWe define $f[i][j]$ to represent the number of monotonic array pairs for the subarray $[0, \\ldots, i]$ where $arr1[i] = j$. Initially, $f[i][j] = 0$, and the answer is $\\sum_{j=0}^{\\textit{nums}[n-1]} f[n-1][j]$.\nWhen $i = 0$, we have $f[0][j] = 1$ for $0 \\leq j \\leq \\textit{nums}[0]$.\nWhen $i > 0$, we can calculate $f[i][j]$ based on $f[i-1][j']$. Since $\\textit{arr1}$ is non-decreasing, $j' \\leq j$. Additionally, since $\\textit{arr2}$ is non-increasing, $\\textit{nums}[i] - j \\leq \\textit{nums}[i - 1] - j'$. Thus, $j' \\leq \\min(j, j + \\textit{nums}[i - 1] - \\textit{nums}[i])$.\nThe answer is $\\sum_{j=0}^{\\textit{nums}[n-1]} f[n-1][j]$.\nThe time complexity is $O(n \\times m)$, and the space complexity is $O(n \\times m)$. Here, $n$ represents the length of the array $\\textit{nums}$, and $m$ represents the maximum value in the array $\\textit{nums}$. \n\n", "problem_ids": ["find-the-count-of-monotonic-pairs-i"]}, "3032": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i\u200b\u200b\u200b\u200b\u200b\u200b and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\n\u00a0\nExample 1:\n\nInput: gain = [-5,1,5,0,-7]\nOutput: 1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n\nExample 2:\n\nInput: gain = [-4,-3,-2,-1,4,3,2]\nOutput: 0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n\n\u00a0\nConstraints:\n\nn == gain.length\n1 <= n <= 100\n-100 <= gain[i] <= 100 Explanation:\n\nSolution 1: Prefix Sum (Difference Array)\nWe assume the altitude of each point is $h_i$. Since $gain[i]$ represents the altitude difference between the $i$th point and the $(i + 1)$th point, we have $gain[i] = h_{i + 1} - h_i$. Therefore:\n$$\n\\sum_{i = 0}^{n-1} gain[i] = h_1 - h_0 + h_2 - h_1 + \\cdots + h_n - h_{n - 1} = h_n - h_0 = h_n\n$$\nwhich implies:\n$$\nh_{i+1} = \\sum_{j = 0}^{i} gain[j]\n$$\nWe can see that the altitude of each point can be calculated through the prefix sum. Therefore, we only need to traverse the array once, find the maximum value of the prefix sum, which is the highest altitude.\n\nIn fact, the $gain$ array in the problem is a difference array. The prefix sum of the difference array gives the original altitude array. Then find the maximum value of the original altitude array.\n\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array gain. \n\n", "problem_ids": ["find-the-highest-altitude"]}, "3033": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of integers nums, half of the integers in nums are odd, and the other half are even.\nSort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\nReturn any answer array that satisfies this condition.\n\u00a0\nExample 1:\n\nInput: nums = [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n\nExample 2:\n\nInput: nums = [2,3]\nOutput: [2,3]\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 2 * 104\nnums.length is even.\nHalf of the integers in nums are even.\n0 <= nums[i] <= 1000\n\n\u00a0\nFollow Up: Could you solve it in-place? Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers $i$ and $j$ to point to even and odd indices respectively.\nWhen $i$ points to an even index, if $nums[i]$ is odd, then we need to find an odd index $j$ such that $nums[j]$ is even, and then swap $nums[i]$ and $nums[j]$. Continue to iterate until $i$ points to the end of the array.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["sort-array-by-parity-ii"]}, "3034": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer n indicating the number of people in a network. Each person is labeled from 0 to n - 1.\nYou are also given a 0-indexed 2D integer array restrictions, where restrictions[i] = [xi, yi] means that person xi and person yi cannot become friends, either directly or indirectly through other people.\nInitially, no one is friends with each other. You are given a list of friend requests as a 0-indexed 2D integer array requests, where requests[j] = [uj, vj] is a friend request between person uj and person vj.\nA friend request is successful if uj and vj can be friends. Each friend request is processed in the given order (i.e., requests[j] occurs before requests[j + 1]), and upon a successful request, uj and vj become direct friends for all future friend requests.\nReturn a boolean array result, where each result[j] is true if the jth friend request is successful or false if it is not.\nNote: If uj and vj are already direct friends, the request is still successful.\n\u00a0\nExample 1:\n\nInput: n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\nOutput: [true,false]\nExplanation:\nRequest 0: Person 0 and person 2 can be friends, so they become direct friends. \nRequest 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).\n\nExample 2:\n\nInput: n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\nOutput: [true,false]\nExplanation:\nRequest 0: Person 1 and person 2 can be friends, so they become direct friends.\nRequest 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).\n\nExample 3:\n\nInput: n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\nOutput: [true,false,true,false]\nExplanation:\nRequest 0: Person 0 and person 4 can be friends, so they become direct friends.\nRequest 1: Person 1 and person 2 cannot be friends since they are directly restricted.\nRequest 2: Person 3 and person 1 can be friends, so they become direct friends.\nRequest 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).\n\n\u00a0\nConstraints:\n\n2 <= n <= 1000\n0 <= restrictions.length <= 1000\nrestrictions[i].length == 2\n0 <= xi, yi <= n - 1\nxi != yi\n1 <= requests.length <= 1000\nrequests[j].length == 2\n0 <= uj, vj <= n - 1\nuj != vj Explanation:\n\nSolution 1: Union-Find\nWe can use a union-find set to maintain the friend relationships, and then for each request, we determine whether it meets the restriction conditions.\nFor the two people $(u, v)$ in the current request, if they are already friends, then the request can be directly accepted; otherwise, we traverse the restriction conditions. If there exists a restriction condition $(x, y)$ such that $u$ and $x$ are friends and $v$ and $y$ are friends, or $u$ and $y$ are friends and $v$ and $x$ are friends, then the request cannot be accepted.\nThe time complexity is $O(q \\times m \\times \\log(n))$, and the space complexity is $O(n)$. Where $q$ and $m$ are the number of requests and the number of restriction conditions respectively. \n\n", "problem_ids": ["process-restricted-friend-requests"]}, "3044": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an m x n binary matrix grid.\nA row or column is considered palindromic if its values read the same forward and backward.\nYou can flip any number of cells in grid from 0 to 1, or from 1 to 0.\nReturn the minimum number of cells that need to be flipped to make either all rows palindromic or all columns palindromic.\n\u00a0\nExample 1:\n\nInput: grid = [[1,0,0],[0,0,0],[0,0,1]]\nOutput: 2\nExplanation:\n\nFlipping the highlighted cells makes all the rows palindromic.\n\nExample 2:\n\nInput: grid = [[0,1],[0,1],[0,0]]\nOutput: 1\nExplanation:\n\nFlipping the highlighted cell makes all the columns palindromic.\n\nExample 3:\n\nInput: grid = [[1],[0]]\nOutput: 0\nExplanation:\nAll rows are already palindromic.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m * n <= 2 * 105\n0 <= grid[i][j] <= 1 Explanation:\n\nSolution 1: Counting\nWe separately count the number of flips for rows and columns, denoted as $\\textit{cnt1}$ and $\\textit{cnt2}$, respectively. Finally, we take the minimum of the two.\nThe time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the matrix $\\textit{grid}$, respectively. \n\n", "problem_ids": ["minimum-number-of-flips-to-make-binary-grid-palindromic-i"]}, "3045": {"text": "Similar Problem 1 \n\n Problem:\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n\u00a0\nExample 1:\n\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n\nExample 2:\n\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\n\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 1000\ns consists of English letters (lower-case and upper-case), ',' and '.'.\n1 <= numRows <= 1000 Explanation:\n\nSolution 1: Simulation\nWe use a two-dimensional array $g$ to simulate the process of the $Z$-shape arrangement, where $g[i][j]$ represents the character at the $i$-th row and the $j$-th column. Initially, $i=0$, and we define a direction variable $k$, initially $k=-1$, indicating moving upwards.\nWe traverse the string $s$ from left to right. Each time we traverse to a character $c$, we append it to $g[i]$. If $i=0$ or $i=numRows-1$ at this time, it means that the current character is at the turning point of the $Z$-shape arrangement, and we reverse the value of $k$, i.e., $k=-k$. Next, we update the value of $i$ to $i+k$, i.e., move up or down one row. Continue to traverse the next character until we have traversed the string $s$, and we return the string concatenated by all rows in $g$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string $s$. \n\n", "problem_ids": ["zigzag-conversion"]}, "3046": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\n\u00a0\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\n\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = []\nOutput: []\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100 Explanation:\n\nSolution 1: BFS\nTo implement zigzag level order traversal, we need to add a flag left on the basis of level order traversal. This flag is used to mark the order of the node values in the current level. If left is true, the node values of the current level are stored in the result array ans from left to right. If left is false, the node values of the current level are stored in the result array ans from right to left.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. \n\n", "problem_ids": ["binary-tree-zigzag-level-order-traversal"]}, "3047": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.\n\nFor example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].\n\nReturn the minimum number of operations needed to make nums strictly increasing.\nAn array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.\n\u00a0\nExample 1:\n\n\nInput: nums = [1,1,1]\n\nOutput: 3\n\nExplanation: You can do the following operations:\n\n1) Increment nums[2], so nums becomes [1,1,2].\n\n2) Increment nums[1], so nums becomes [1,2,2].\n\n3) Increment nums[2], so nums becomes [1,2,3].\n\n\nExample 2:\n\n\nInput: nums = [1,5,2,4,1]\n\nOutput: 14\n\n\nExample 3:\n\n\nInput: nums = [8]\n\nOutput: 0\n\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 5000\n1 <= nums[i] <= 104 Explanation:\n\nSolution 1: Single Pass\nWe use a variable $mx$ to record the maximum value of the current strictly increasing array, initially $mx = 0$.\nTraverse the array nums from left to right. For the current element $v$, if $v \\lt mx + 1$, we need to increase it to $mx + 1$ to ensure the array is strictly increasing. Therefore, the number of operations we need to perform this time is $max(0, mx + 1 - v)$, which is added to the answer, and then we update $mx=max(mx + 1, v)$. Continue to traverse the next element until the entire array is traversed.\nThe time complexity is $O(n)$, where $n$ is the length of the array nums. The space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-operations-to-make-the-array-increasing"]}, "3055": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\n\u00a0\nExample 1:\n\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\nExample 2:\n\nInput: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n\nExample 3:\n\nInput: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\n\n\u00a0\nConstraints:\n\n1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself. Explanation:\n\nSolution 1: Greedy Algorithm \n\n", "problem_ids": ["remove-k-digits"]}, "3080": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given three positive integers:\u00a0n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:\n\nnums.length == n\nnums[i] is a positive integer where 0 <= i < n.\nabs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.\nThe sum of all the elements of nums does not exceed maxSum.\nnums[index] is maximized.\n\nReturn nums[index] of the constructed array.\nNote that abs(x) equals x if x >= 0, and -x otherwise.\n\u00a0\nExample 1:\n\nInput: n = 4, index = 2,  maxSum = 6\nOutput: 2\nExplanation: nums = [1,2,2,1] is one array that satisfies all the conditions.\nThere are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].\n\nExample 2:\n\nInput: n = 6, index = 1,  maxSum = 10\nOutput: 3\n\n\u00a0\nConstraints:\n\n1 <= n <= maxSum <= 109\n0 <= index < n Explanation:\n\nSolution 1: Binary Search\nAccording to the problem description, if we determine the value of $nums[index]$ as $x$, we can find a minimum array sum. That is, the elements on the left side of $index$ in the array decrease from $x-1$ to $1$, and if there are remaining elements, the remaining elements are all $1$; similarly, the elements at $index$ and on the right side of the array decrease from $x$ to $1$, and if there are remaining elements, the remaining elements are all $1$.\nIn this way, we can calculate the sum of the array. If the sum is less than or equal to $maxSum$, then the current $x$ is valid. As $x$ increases, the sum of the array will also increase, so we can use the binary search method to find the maximum $x$ that meets the conditions.\nTo facilitate the calculation of the sum of the elements on the left and right sides of the array, we define a function $sum(x, cnt)$, which represents the sum of an array with $cnt$ elements and a maximum value of $x$. The function $sum(x, cnt)$ can be divided into two cases:\n\nIf $x \\geq cnt$, then the sum of the array is $\\frac{(x + x - cnt + 1) \\times cnt}{2}$\nIf $x \\lt cnt$, then the sum of the array is $\\frac{(x + 1) \\times x}{2} + cnt - x$\n\nNext, define the left boundary of the binary search as $left = 1$, the right boundary as $right = maxSum$, and then binary search for the value $mid$ of $nums[index]$. If $sum(mid - 1, index) + sum(mid, n - index) \\leq maxSum$, then the current $mid$ is valid, we can update $left$ to $mid$, otherwise we update $right$ to $mid - 1$.\nFinally, return $left$ as the answer.\nThe time complexity is $O(\\log M)$, where $M=maxSum$. The space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-value-at-a-given-index-in-a-bounded-array"]}, "3081": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\u00a0\nExample 1:\n\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order. Explanation:\n\nSolution 1: Single Pass\nWe use a variable $k$ to record the current length of the array that has been processed. Initially, $k=0$, representing an empty array.\nThen we traverse the array from left to right. For each element $x$ we traverse, if $k < 2$ or $x \\neq nums[k-2]$, we put $x$ in the position of $nums[k]$, and then increment $k$ by $1$. Otherwise, $x$ is the same as $nums[k-2]$, we directly skip this element. Continue to traverse until the entire array is traversed.\nIn this way, when the traversal ends, the first $k$ elements in $nums$ are the answer we want, and $k$ is the length of the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array.\nSupplement:\nThe original problem requires that the same number appears at most $2$ times. We can extend it to keep at most $k$ identical numbers.\n\nSince the same number can be kept at most $k$ times, we can directly keep the first $k$ elements of the original array;\nFor the later numbers, the premise of being able to keep them is: the current number $x$ compares with the $k$th element from the end of the previously kept numbers. If they are different, keep it, otherwise skip it.\n\nSimilar problems:\n\n26. Remove Duplicates from Sorted Array \n\n", "problem_ids": ["remove-duplicates-from-sorted-array-ii"]}, "3091": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a binary string s \u200b\u200b\u200b\u200b\u200bwithout leading zeros, return true\u200b\u200b\u200b if s contains at most one contiguous segment of ones. Otherwise, return false.\n\u00a0\nExample 1:\n\nInput: s = \"1001\"\nOutput: false\nExplanation: The ones do not form a contiguous segment.\n\nExample 2:\n\nInput: s = \"110\"\nOutput: true\n\u00a0\nConstraints:\n\n1 <= s.length <= 100\ns[i]\u200b\u200b\u200b\u200b is either '0' or '1'.\ns[0] is\u00a0'1'. Explanation:\n\nSolution 1: No '1' After '0'\nNotice that the string $s$ does not contain leading zeros, which means $s$ starts with '1'.\nIf the string $s$ contains the substring \"01\", then $s$ must be a string like \"1...01...\", in which case $s$ has at least two consecutive '1' segments, which does not satisfy the problem condition, so we return false.\nIf the string $s$ does not contain the substring \"01\", then $s$ can only be a string like \"1..1000...\", in which case $s$ has only one consecutive '1' segment, which satisfies the problem condition, so we return true.\nTherefore, we only need to judge whether the string $s$ contains the substring \"01\".\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["check-if-binary-string-has-at-most-one-segment-of-ones"]}, "3093": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array nums of integers.\nA triplet of indices (i, j, k) is a mountain if:\n\ni < j < k\nnums[i] < nums[j] and nums[k] < nums[j]\n\nReturn the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.\n\u00a0\nExample 1:\n\nInput: nums = [8,6,1,5,3]\nOutput: 9\nExplanation: Triplet (2, 3, 4) is a mountain triplet of sum 9 since: \n- 2 < 3 < 4\n- nums[2] < nums[3] and nums[4] < nums[3]\nAnd the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.\n\nExample 2:\n\nInput: nums = [5,4,8,7,10,2]\nOutput: 13\nExplanation: Triplet (1, 3, 5) is a mountain triplet of sum 13 since: \n- 1 < 3 < 5\n- nums[1] < nums[3] and nums[5] < nums[3]\nAnd the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.\n\nExample 3:\n\nInput: nums = [6,5,4,3,4,5]\nOutput: -1\nExplanation: It can be shown that there are no mountain triplets in nums.\n\n\u00a0\nConstraints:\n\n3 <= nums.length <= 50\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Preprocessing + Enumeration\nWe can preprocess the minimum value on the right side of each position and record it in the array $right[i]$, where $right[i]$ represents the minimum value in $nums[i+1..n-1]$.\nNext, we enumerate the middle element $nums[i]$ of the mountain triplet from left to right, and use a variable $left$ to represent the minimum value in $ums[0..i-1]$, and a variable $ans$ to represent the current minimum element sum found. For each $i$, we need to find the element $nums[i]$ that satisfies $left < nums[i]$ and $right[i+1] < nums[i]$, and update $ans$.\nFinally, if $ans$ is still the initial value, it means that there is no mountain triplet, and we return $-1$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["minimum-sum-of-mountain-triplets-i"]}, "3094": {"text": "Similar Problem 1 \n\n Problem:\n\nWrite a program to count the number of days between two dates.\nThe two dates are given as strings, their format is YYYY-MM-DD\u00a0as shown in the examples.\n\u00a0\nExample 1:\nInput: date1 = \"2019-06-29\", date2 = \"2019-06-30\"\nOutput: 1\n\nExample 2:\nInput: date1 = \"2020-01-15\", date2 = \"2019-12-31\"\nOutput: 15\n\n\u00a0\nConstraints:\n\nThe given dates are valid\u00a0dates between the years 1971 and 2100. Explanation:\n\nSolution 1: Mathematics\nFirst, we define a function isLeapYear(year) to determine whether the given year year is a leap year. If it is a leap year, return true, otherwise return false.\nNext, we define another function daysInMonth(year, month) to calculate the total number of days in the given year year and month month. We can use an array days to store the number of days in each month, where days[1] represents the number of days in February. If it is a leap year, it is $29$ days, otherwise it is $28$ days.\nThen, we define another function calcDays(date) to calculate the number of days from the given date date to 1971-01-01. We can use date.split(\"-\") to split the date date into year year, month month, and day day by -. Then we can use a loop to calculate the total number of days from 1971 to year, then calculate the total number of days from January to month, and finally add day days.\nFinally, we only need to return the absolute value of calcDays(date1) - calcDays(date2).\nThe time complexity is $O(y + m)$, where $y$ represents the number of years from the given date to 1971-01-01, and $m$ represents the number of months of the given date. The space complexity is $O(1)$. \n\n", "problem_ids": ["number-of-days-between-two-dates"]}, "3104": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two 0-indexed binary strings s and target of the same length n. You can do the following operation on s any number of times:\n\nChoose two different indices i and j where 0 <= i, j < n.\nSimultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR s[j]).\n\nFor example, if s = \"0110\", you can choose i = 0 and j = 2, then simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = \"1110\".\nReturn true if you can make the string s equal to target, or false otherwise.\n\u00a0\nExample 1:\n\nInput: s = \"1010\", target = \"0110\"\nOutput: true\nExplanation: We can do the following operations:\n- Choose i = 2 and j = 0. We have now s = \"0010\".\n- Choose i = 2 and j = 1. We have now s = \"0110\".\nSince we can make s equal to target, we return true.\n\nExample 2:\n\nInput: s = \"11\", target = \"00\"\nOutput: false\nExplanation: It is not possible to make s equal to target with any number of operations.\n\n\u00a0\nConstraints:\n\nn == s.length == target.length\n2 <= n <= 105\ns and target consist of only the digits 0 and 1. Explanation:\n\nSolution 1: Lateral Thinking\nWe notice that $1$ is actually a \"tool\" for number conversion. Therefore, as long as both strings either have $1$ or neither have $1$, we can make the two strings equal through operations.\nThe time complexity is $O(n)$, where $n$ is the length of the string. The space complexity is $O(1)$. \n\n", "problem_ids": ["apply-bitwise-operations-to-make-strings-equal"]}, "3106": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the head of a linked list containing k distinct elements, return the head to a linked list of length k containing the frequency of each distinct element in the given linked list in any order.\n\u00a0\nExample 1: \n\nInput:   head = [1,1,2,1,2,3] \nOutput:   [3,2,1] \nExplanation:  There are 3 distinct elements in the list. The frequency of 1 is 3, the frequency of 2 is 2 and the frequency of 3 is 1. Hence, we return 3 -> 2 -> 1.\nNote that 1 -> 2 -> 3, 1 -> 3 -> 2, 2 -> 1 -> 3, 2 -> 3 -> 1, and 3 -> 1 -> 2 are also valid answers.\n\nExample 2: \n\nInput:   head = [1,1,2,2,2] \nOutput:   [2,3] \nExplanation:  There are 2 distinct elements in the list. The frequency of 1 is 2 and the frequency of 2 is 3. Hence, we return 2 -> 3.\n\nExample 3: \n\nInput:   head = [6,5,4,3,2,1] \nOutput:   [1,1,1,1,1,1] \nExplanation:  There are 6 distinct elements in the list. The frequency of each of them is 1. Hence, we return 1 -> 1 -> 1 -> 1 -> 1 -> 1.\n\n\u00a0\nConstraints:\n\nThe number of nodes in the list is in the range [1, 105].\n1 <= Node.val <= 105 Explanation:\n\nSolution 1: Hash Table\nWe use a hash table cnt to record the occurrence times of each element value in the linked list, then traverse the values of the hash table to construct a new linked list.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the linked list. \n\n", "problem_ids": ["linked-list-frequency"]}, "3114": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array cost of length n, where cost[i] is the cost assigned to the ith node.\nYou need to place some coins on every node of the tree. The number of coins to be placed at node i can be calculated as:\n\nIf size of the subtree of node i is less than 3, place 1 coin.\nOtherwise, place an amount of coins equal to the maximum product of cost values assigned to 3 distinct nodes in the subtree of node i. If this product is negative, place 0 coins.\n\nReturn an array coin of size n such that coin[i] is the number of coins placed at node i.\n\u00a0\nExample 1:\n\n\nInput: edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]\nOutput: [120,1,1,1,1,1]\nExplanation: For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n\nExample 2:\n\n\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]\nOutput: [280,140,32,1,1,1,1,1,1]\nExplanation: The coins placed on each node are:\n- Place 8 * 7 * 5 = 280 coins on node 0.\n- Place 7 * 5 * 4 = 140 coins on node 1.\n- Place 8 * 2 * 2 = 32 coins on node 2.\n- All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n\nExample 3:\n\n\nInput: edges = [[0,1],[0,2]], cost = [1,2,-2]\nOutput: [0,1,1]\nExplanation: Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.\n\n\u00a0\nConstraints:\n\n2 <= n <= 2 * 104\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\ncost.length == n\n1 <= |cost[i]| <= 104\nThe input is generated such that edges represents a valid tree. Explanation:\n\nSolution 1: DFS + Sorting\nAccording to the problem description, there are two situations for the number of coins placed at each node $a$:\n\nIf the number of nodes in the subtree corresponding to node $a$ is less than $3$, then place $1$ coin;\nIf the number of nodes in the subtree corresponding to node $a$ is greater than or equal to $3$, then we need to take out $3$ different nodes from the subtree, calculate the maximum value of their cost product, and then place the corresponding number of coins at node $a$. If the maximum product is negative, place $0$ coins.\n\nThe first situation is relatively simple, we just need to count the number of nodes in the subtree of each node during the traversal.\nFor the second situation, if all costs are positive, we should take the $3$ nodes with the largest costs; if there are negative costs, we should take the $2$ nodes with the smallest costs and the $1$ node with the largest cost. Therefore, we need to maintain the smallest $2$ costs and the largest $3$ costs in each subtree.\nWe first construct the adjacency list $g$ based on the given two-dimensional array $edges$, where $g[a]$ represents all neighbor nodes of node $a$.\nNext, we design a function $dfs(a, fa)$, which returns an array $res$, which stores the smallest $2$ costs and the largest $3$ costs in the subtree of node $a$ (may not be $5$).\nIn the function $dfs(a, fa)$, we add the cost $cost[a]$ of node $a$ to the array $res$, and then traverse all neighbor nodes $b$ of node $a$. If $b$ is not the parent node $fa$ of node $a$, then we add the result of $dfs(b, a)$ to the array $res$.\nThen, we sort the array $res$, and then calculate the number of coins placed at node $a$ based on the length $m$ of the array $res$, and update $ans[a]$:\n\nIf $m \\ge 3$, then the number of coins placed at node $a$ is $\\max(0, res[m - 1] \\times res[m - 2] \\times res[m - 3], res[0] \\times res[1] \\times res[m - 1])$, otherwise the number of coins placed at node $a$ is $1$;\nIf $m > 5$, then we only need to keep the first $2$ elements and the last $3$ elements of the array $res$.\n\nFinally, we call the function $dfs(0, -1)$, and return the answer array $ans$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes. \n\n", "problem_ids": ["find-number-of-coins-to-place-in-tree-nodes"]}, "3141": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n\u00a0\nExample 1:\nInput: s = \"abc\", t = \"ahbgdc\"\nOutput: true\n\nExample 2:\nInput: s = \"axc\", t = \"ahbgdc\"\nOutput: false\n\n\u00a0\nConstraints:\n\n0 <= s.length <= 100\n0 <= t.length <= 104\ns and t consist only of lowercase English letters.\n\n\u00a0\nFollow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where k >= 109, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code? Explanation:\n\nSolution 1: Two Pointers\nWe define two pointers $i$ and $j$ to point to the initial position of the string $s$ and $t$ respectively. Each time we compare the two characters pointed to by the two pointers, if they are the same, both pointers move right at the same time; if they are not the same, only $j$ moves right. When the pointer $i$ moves to the end of the string $s$, it means that $s$ is the subsequence of $t$.\nThe time complexity is $O(m + n)$, where $m$ and $n$ are the lengths of the strings $s$ and $t$ respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["is-subsequence"]}, "3150": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: Sessions\n\n+---------------+----------+\n| Column Name   | Type     |\n+---------------+----------+\n| user_id       | int      |\n| session_start | datetime |\n| session_end   | datetime |\n| session_id    | int      |\n| session_type  | enum     |\n+---------------+----------+\nsession_id is column of unique values for this table.\nsession_type is an ENUM (category) type of (Viewer, Streamer).\nThis table contains user id, session start, session end, session id and session type.\n\nWrite a solution to find the the users who have had at least one consecutive session of the same type (either 'Viewer' or 'Streamer') with a maximum gap of 12 hours between sessions.\nReturn the result table ordered by user_id in ascending order.\nThe result format is in the following example.\n\u00a0\nExample:\n\nInput: \nSessions table:\n+---------+---------------------+---------------------+------------+--------------+\n| user_id | session_start       | session_end         | session_id | session_type | \n+---------+---------------------+---------------------+------------+--------------+\n| 101     | 2023-11-01 08:00:00 | 2023-11-01 09:00:00 | 1          | Viewer       |  \n| 101     | 2023-11-01 10:00:00 | 2023-11-01 11:00:00 | 2          | Streamer     |   \n| 102     | 2023-11-01 13:00:00 | 2023-11-01 14:00:00 | 3          | Viewer       | \n| 102     | 2023-11-01 15:00:00 | 2023-11-01 16:00:00 | 4          | Viewer       | \n| 101     | 2023-11-02 09:00:00 | 2023-11-02 10:00:00 | 5          | Viewer       | \n| 102     | 2023-11-02 12:00:00 | 2023-11-02 13:00:00 | 6          | Streamer     | \n| 101     | 2023-11-02 13:00:00 | 2023-11-02 14:00:00 | 7          | Streamer     | \n| 102     | 2023-11-02 16:00:00 | 2023-11-02 17:00:00 | 8          | Viewer       | \n| 103     | 2023-11-01 08:00:00 | 2023-11-01 09:00:00 | 9          | Viewer       | \n| 103     | 2023-11-02 20:00:00 | 2023-11-02 23:00:00 | 10         | Viewer       | \n| 103     | 2023-11-03 09:00:00 | 2023-11-03 10:00:00 | 11         | Viewer       | \n+---------+---------------------+---------------------+------------+--------------+\nOutput: \n+---------+\n| user_id |\n+---------+\n| 102     |\n| 103     |\n+---------+\nExplanation:\n- User ID 101 will not be included in the final output as they do not have any consecutive sessions of the same session type.\n- User ID 102 will be included in the final output as they had two viewer sessions with session IDs 3 and 4, respectively, and the time gap between them was less than 12 hours.\n- User ID 103 participated in two viewer sessions with a gap of less than 12 hours between them, identified by session IDs 10 and 11. Therefore, user 103 will be included in the final output.\nOutput table is ordered by user_id in increasing order. Explanation:\n\nSolution 1: Window Function + Time Function\nFirst, we use the LAG window function to find the end time of the previous session of the same type for each user, denoted as prev_session_end. Then we use the TIMESTAMPDIFF function to calculate the time difference between the start time of the current session and the end time of the previous session. If the time difference is less than or equal to 12 hours, then this user meets the requirements of the problem.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nWITH\n    T AS (\n        SELECT\n            user_id,\n            session_start,\n            LAG(session_end) OVER (\n                PARTITION BY user_id, session_type\n                ORDER BY session_end\n            ) AS prev_session_end\n        FROM Sessions\n    )\nSELECT DISTINCT\n    user_id\nFROM T\nWHERE TIMESTAMPDIFF(HOUR, prev_session_end, session_start) <= 12;\n``` \n\n", "problem_ids": ["user-activities-within-time-bounds"]}, "3151": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\u00a0\nExample 1:\n\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n\u00a0\nConstraints:\n\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104 Explanation:\n\nSolution 1: DFS\nWe can use the DFS recursive method to solve this problem.\nFirst, determine whether the root nodes of the two binary trees are the same. If both root nodes are null, then the two binary trees are the same. If only one of the root nodes is null, then the two binary trees are definitely different. If both root nodes are not null, then determine whether their values are the same. If they are not the same, then the two binary trees are definitely different. If they are the same, then determine whether the left subtrees of the two binary trees are the same and whether the right subtrees are the same. The two binary trees are the same only when all the above conditions are met.\nThe time complexity is $O(\\min(m, n))$, and the space complexity is $O(\\min(m, n))$. Here, $m$ and $n$ are the number of nodes in the two binary trees, respectively. The space complexity mainly depends on the number of layers of recursive calls, which will not exceed the number of nodes in the smaller binary tree. \n\n", "problem_ids": ["same-tree"]}, "3153": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array nums of length n containing distinct positive integers. Return the minimum number of right shifts required to sort nums and -1 if this is not possible.\nA right shift is defined as shifting the element at index i to index (i + 1) % n, for all indices.\n\u00a0\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: 2\nExplanation: \nAfter the first right shift, nums = [2,3,4,5,1].\nAfter the second right shift, nums = [1,2,3,4,5].\nNow nums is sorted; therefore the answer is 2.\n\nExample 2:\n\nInput: nums = [1,3,5]\nOutput: 0\nExplanation: nums is already sorted therefore, the answer is 0.\nExample 3:\n\nInput: nums = [2,1,4]\nOutput: -1\nExplanation: It's impossible to sort the array using right shifts.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\nnums contains distinct integers. Explanation:\n\nSolution 1: Direct Traversal\nFirst, we use a pointer $i$ to traverse the array $nums$ from left to right, finding a continuous increasing sequence until $i$ reaches the end of the array or $nums[i - 1] > nums[i]$. Next, we use another pointer $k$ to traverse the array $nums$ from $i + 1$, finding a continuous increasing sequence until $k$ reaches the end of the array or $nums[k - 1] > nums[k]$ and $nums[k] > nums[0]$. If $k$ reaches the end of the array, it means the array is already increasing, so we return $n - i$; otherwise, we return $-1$.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array $nums$. \n\n", "problem_ids": ["minimum-right-shifts-to-sort-the-array"]}, "3154": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array nums. In one operation, you can add or subtract 1 from any element of nums.\nReturn the minimum number of operations to make all elements of nums divisible by 3.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation:\nAll array elements can be made divisible by 3 using 3 operations:\n\nSubtract 1 from 1.\nAdd 1 to 2.\nSubtract 1 from 4.\n\n\nExample 2:\n\nInput: nums = [3,6,9]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 50 Explanation:\n\nSolution 1: Mathematics\nWe directly iterate through the array $\\textit{nums}$. For each element $x$, we calculate the remainder of $x$ divided by 3, $x \\bmod 3$. If the remainder is not 0, we need to make $x$ divisible by 3 with the minimum number of operations. Therefore, we can choose to either decrease $x$ by $x \\bmod 3$ or increase $x$ by $3 - x \\bmod 3$, and we accumulate the minimum of these two values to the answer.\nThe time complexity is $O(n)$, where $n$ is the length of the array $\\textit{nums}$. The space complexity is $O(1)$. \n\n", "problem_ids": ["find-minimum-operations-to-make-all-elements-divisible-by-three"]}, "3163": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.\nAn alphanumeric string is a string consisting of lowercase English letters and digits.\n\u00a0\nExample 1:\n\nInput: s = \"dfa12321afd\"\nOutput: 2\nExplanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.\n\nExample 2:\n\nInput: s = \"abc1111\"\nOutput: -1\nExplanation: The digits that appear in s are [1]. There is no second largest digit. \n\n\u00a0\nConstraints:\n\n1 <= s.length <= 500\ns consists of only lowercase English letters and digits. Explanation:\n\nSolution 1: One Pass\nWe define $a$ and $b$ to represent the largest and second largest numbers in the string, initially $a = b = -1$.\nWe traverse the string $s$. If the current character is a digit, we convert it to a number $v$. If $v > a$, it means that $v$ is the largest number currently appearing, we update $b$ to $a$, and update $a$ to $v$; if $v < a$, it means that $v$ is the second largest number currently appearing, we update $b$ to $v$.\nAfter the traversal, we return $b$.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)$. \n\n", "problem_ids": ["second-largest-digit-in-a-string"]}, "3164": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.\n\nFor example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.\n\nReturn the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\n\nInput: nums = [2,1,3]\nOutput: 1\nExplanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n\nExample 2:\n\n\nInput: nums = [3,4,5,1,2]\nOutput: 5\nExplanation: The following 5 arrays will yield the same BST: \n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n\nExample 3:\n\n\nInput: nums = [1,2,3]\nOutput: 0\nExplanation: There are no other orderings of nums that will yield the same BST.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= nums.length\nAll integers in nums are distinct. Explanation:\n\nSolution 1: Combination Counting + Recursion\nWe design a function $dfs(nums)$, which is used to calculate the number of solutions of the binary search tree with $nums$ as nodes. Then the answer is $dfs(nums)-1$, because $dfs(nums)$ calculates the number of solutions of the binary search tree with $nums$ as nodes, while the problem requires the number of solutions of the binary search tree with $nums$ as nodes after reordering, so the answer needs to be subtracted by one.\nNext, let's take a look at how $dfs(nums)$ is calculated.\nFor an array $nums$, its first element is the root node, so its left subtree elements are smaller than it, and its right subtree elements are larger than it. So we can divide the array into three parts, the first part is the root node, the second part is the elements of the left subtree, denoted as $left$, and the third part is the elements of the right subtree, denoted as $right$. Then, the number of elements in the left subtree is $m$, and the number of elements in the right subtree is $n$, so the number of solutions for $left$ and $right$ are $dfs(left)$ and $dfs(right)$ respectively. We can choose $m$ positions from $m + n$ positions in array $nums$ to place the elements of the left subtree, and the remaining $n$ positions to place the elements of the right subtree, so that we can ensure that the reordered binary search tree is the same as the original array $nums$. Therefore, the calculation method of $dfs(nums)$ is:\n$$\ndfs(nums) = C_{m+n}^m \\times dfs(left) \\times dfs(right)\n$$\nwhere $C_{m+n}^m$ represents the number of schemes to select $m$ positions from $m + n$ positions, which we can get through preprocessing.\nNote the modulo operation of the answer, because the value of $dfs(nums)$ may be very large, so we need to take the modulo of each step in the calculation process, and finally take the modulo of the entire result.\nThe time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Where $n$ is the length of array $nums$. \n\n", "problem_ids": ["number-of-ways-to-reorder-array-to-get-same-bst"]}, "3166": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed 2D integer array grid of size m x n which represents a field. Each cell has one of three values:\n\n0 represents grass,\n1 represents fire,\n2 represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, (0, 0), and you want to travel to the safehouse at the bottom-right cell, (m - 1, n - 1). Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.\nReturn the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse. If this is impossible, return -1. If you can always reach the safehouse regardless of the minutes stayed, return 109.\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\nA cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\u00a0\nExample 1:\n\n\nInput: grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\nOutput: 3\nExplanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\nExample 2:\n\n\nInput: grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\nOutput: -1\nExplanation: The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\nExample 3:\n\n\nInput: grid = [[0,0,0],[2,2,0],[1,2,0]]\nOutput: 1000000000\nExplanation: The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 300\n4 <= m * n <= 2 * 104\ngrid[i][j] is either 0, 1, or 2.\ngrid[0][0] == grid[m - 1][n - 1] == 0 Explanation:\n\nSolution 1: Binary Search + BFS\nWe notice that if a stay time $t$ satisfies the condition, then all stay times less than $t$ also satisfy the condition. Therefore, we can consider using binary search to find the maximum stay time that satisfies the condition.\nWe define the left boundary of binary search as $l=-1$ and the right boundary as $r=m \\times n$. In each iteration of binary search, we take the midpoint $mid$ of $l$ and $r$ as the current stay time and check if it satisfies the condition. If it does, we update $l$ to $mid$, otherwise we update $r$ to $mid-1$. Finally, if $l=m \\times n$, it means there is no stay time that satisfies the condition, so we return $10^9$, otherwise we return $l$.\nThe key problem is how to determine whether a stay time $t$ satisfies the condition. We can use breadth-first search to simulate the spread of fire within $t$ time. If the fire spreads to the starting position after staying for $t$ time, it means the condition is not satisfied and we return early. Otherwise, we use breadth-first search again, searching in four directions from the current position each time, and after each round, we need to spread the fire in four directions. If we find a path from the starting position to the ending position during this process, it means the condition is satisfied.\nThe time complexity is $O(m \\times n \\times \\log (m \\times n))$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns in the grid, respectively. \n\n", "problem_ids": ["escape-the-spreading-fire"]}, "3171": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a positive integer array nums.\n\nThe element sum is the sum of all the elements in nums.\nThe digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.\n\nReturn the absolute difference between the element sum and digit sum of nums.\nNote that the absolute difference between two integers x and y is defined as |x - y|.\n\u00a0\nExample 1:\n\nInput: nums = [1,15,6,3]\nOutput: 9\nExplanation: \nThe element sum of nums is 1 + 15 + 6 + 3 = 25.\nThe digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.\nThe absolute difference between the element sum and digit sum is |25 - 16| = 9.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: 0\nExplanation:\nThe element sum of nums is 1 + 2 + 3 + 4 = 10.\nThe digit sum of nums is 1 + 2 + 3 + 4 = 10.\nThe absolute difference between the element sum and digit sum is |10 - 10| = 0.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 2000\n1 <= nums[i] <= 2000 Explanation:\n\nSolution 1: Simulation\nWe traverse the array $nums$, calculate the sum of elements $a$ and the sum of digits $b$, and finally return $|a - b|$.\nThe time complexity is $O(n)$, where $n$ is the length of the array $nums$. The space complexity is $O(1)$. \n\n", "problem_ids": ["difference-between-element-sum-and-digit-sum-of-an-array"]}, "3172": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given three positive integers:\u00a0n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:\n\nnums.length == n\nnums[i] is a positive integer where 0 <= i < n.\nabs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.\nThe sum of all the elements of nums does not exceed maxSum.\nnums[index] is maximized.\n\nReturn nums[index] of the constructed array.\nNote that abs(x) equals x if x >= 0, and -x otherwise.\n\u00a0\nExample 1:\n\nInput: n = 4, index = 2,  maxSum = 6\nOutput: 2\nExplanation: nums = [1,2,2,1] is one array that satisfies all the conditions.\nThere are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].\n\nExample 2:\n\nInput: n = 6, index = 1,  maxSum = 10\nOutput: 3\n\n\u00a0\nConstraints:\n\n1 <= n <= maxSum <= 109\n0 <= index < n Explanation:\n\nSolution 1: Binary Search\nAccording to the problem description, if we determine the value of $nums[index]$ as $x$, we can find a minimum array sum. That is, the elements on the left side of $index$ in the array decrease from $x-1$ to $1$, and if there are remaining elements, the remaining elements are all $1$; similarly, the elements at $index$ and on the right side of the array decrease from $x$ to $1$, and if there are remaining elements, the remaining elements are all $1$.\nIn this way, we can calculate the sum of the array. If the sum is less than or equal to $maxSum$, then the current $x$ is valid. As $x$ increases, the sum of the array will also increase, so we can use the binary search method to find the maximum $x$ that meets the conditions.\nTo facilitate the calculation of the sum of the elements on the left and right sides of the array, we define a function $sum(x, cnt)$, which represents the sum of an array with $cnt$ elements and a maximum value of $x$. The function $sum(x, cnt)$ can be divided into two cases:\n\nIf $x \\geq cnt$, then the sum of the array is $\\frac{(x + x - cnt + 1) \\times cnt}{2}$\nIf $x \\lt cnt$, then the sum of the array is $\\frac{(x + 1) \\times x}{2} + cnt - x$\n\nNext, define the left boundary of the binary search as $left = 1$, the right boundary as $right = maxSum$, and then binary search for the value $mid$ of $nums[index]$. If $sum(mid - 1, index) + sum(mid, n - index) \\leq maxSum$, then the current $mid$ is valid, we can update $left$ to $mid$, otherwise we update $right$ to $mid - 1$.\nFinally, return $left$ as the answer.\nThe time complexity is $O(\\log M)$, where $M=maxSum$. The space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-value-at-a-given-index-in-a-bounded-array"]}, "3174": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a binary array nums containing only the integers 0 and 1. Return the number of subarrays in nums that have more 1's than 0's. Since the answer may be very large, return it modulo 109 + 7.\nA subarray is a contiguous sequence of elements within an array.\n\u00a0\nExample 1:\n\nInput: nums = [0,1,1,0,1]\nOutput: 9\nExplanation:\nThe subarrays of size 1 that have more ones than zeros are: [1], [1], [1]\nThe subarrays of size 2 that have more ones than zeros are: [1,1]\nThe subarrays of size 3 that have more ones than zeros are: [0,1,1], [1,1,0], [1,0,1]\nThe subarrays of size 4 that have more ones than zeros are: [1,1,0,1]\nThe subarrays of size 5 that have more ones than zeros are: [0,1,1,0,1]\n\nExample 2:\n\nInput: nums = [0]\nOutput: 0\nExplanation:\nNo subarrays have more ones than zeros.\n\nExample 3:\n\nInput: nums = [1]\nOutput: 1\nExplanation:\nThe subarrays of size 1 that have more ones than zeros are: [1]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 1 Explanation:\n\nSolution 1: Prefix Sum + Binary Indexed Tree\nThe problem requires us to count the number of subarrays where the count of $1$ is greater than the count of $0$. If we treat $0$ in the array as $-1$, then the problem becomes counting the number of subarrays where the sum of elements is greater than $0$.\nTo calculate the sum of elements in a subarray, we can use the prefix sum. To count the number of subarrays where the sum of elements is greater than $0$, we can use a binary indexed tree to maintain the occurrence count of each prefix sum. Initially, the occurrence count of the prefix sum $0$ is $1$.\nNext, we traverse the array $nums$, use variable $s$ to record the current prefix sum, and use variable $ans$ to record the answer. For each position $i$, we update the prefix sum $s$, then query the occurrence count of the prefix sum in the range $[0, s)$ in the binary indexed tree, add it to $ans$, and then update the occurrence count of $s$ in the binary indexed tree.\nFinally, return $ans$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["count-subarrays-with-more-ones-than-zeros"]}, "3176": {"text": "Similar Problem 1 \n\n Problem:\n\nYour country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake.\nGiven an integer array rains where:\n\nrains[i] > 0 means there will be rains over the rains[i] lake.\nrains[i] == 0 means there are no rains this day and you can choose one lake this day and dry it.\n\nReturn an array ans where:\n\nans.length == rains.length\nans[i] == -1 if rains[i] > 0.\nans[i] is the lake you choose to dry in the ith day if rains[i] == 0.\n\nIf there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array.\nNotice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.\n\u00a0\nExample 1:\n\nInput: rains = [1,2,3,4]\nOutput: [-1,-1,-1,-1]\nExplanation: After the first day full lakes are [1]\nAfter the second day full lakes are [1,2]\nAfter the third day full lakes are [1,2,3]\nAfter the fourth day full lakes are [1,2,3,4]\nThere's no day to dry any lake and there is no flood in any lake.\n\nExample 2:\n\nInput: rains = [1,2,0,0,2,1]\nOutput: [-1,-1,2,1,-1,-1]\nExplanation: After the first day full lakes are [1]\nAfter the second day full lakes are [1,2]\nAfter the third day, we dry lake 2. Full lakes are [1]\nAfter the fourth day, we dry lake 1. There is no full lakes.\nAfter the fifth day, full lakes are [2].\nAfter the sixth day, full lakes are [1,2].\nIt is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario.\n\nExample 3:\n\nInput: rains = [1,2,0,1,2]\nOutput: []\nExplanation: After the second day, full lakes are  [1,2]. We have to dry one lake in the third day.\nAfter that, it will rain over lakes [1,2]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.\n\n\u00a0\nConstraints:\n\n1 <= rains.length <= 105\n0 <= rains[i] <= 109 Explanation:\n\nSolution 1: Greedy + Binary Search\nWe store all sunny days in the $sunny$ array or a sorted set, and use the hash table $rainy$ to record the last rainy day for each lake. We initialize the answer array $ans$ with each element set to $-1$.\nNext, we traverse the $rains$ array. For each rainy day $i$, if $rainy[rains[i]]$ exists, it means that the lake has rained before, so we need to find the first date in the $sunny$ array that is greater than $rainy[rains[i]]$, and replace it with the rainy day. Otherwise, it means that the flood cannot be prevented, and we return an empty array. For each non-rainy day $i$, we store $i$ in the $sunny$ array and set $ans[i]$ to $1$.\nAfter the traversal, we return the answer array.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the $rains$ array. \n\n", "problem_ids": ["avoid-flood-in-the-city"]}, "3183": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.\nNote that:\n\nA number greater than 1 is called prime if it is divisible by only 1 and itself.\nAn integer val1 is a factor of another integer val2 if val2 / val1 is an integer.\n\n\u00a0\nExample 1:\n\nInput: nums = [2,4,3,7,10,6]\nOutput: 4\nExplanation:\nThe product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7.\nThere are 4 distinct prime factors so we return 4.\n\nExample 2:\n\nInput: nums = [2,4,8,16]\nOutput: 1\nExplanation:\nThe product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210.\nThere is 1 distinct prime factor so we return 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n2 <= nums[i] <= 1000 Explanation:\n\nSolution 1: Hash Table + Prime Factorization\nFor each element in the array, first perform prime factorization on it, and then add the decomposed prime factors to the hash table. Finally, return the size of the hash table.\nThe time complexity is $O(n \\times \\sqrt{m})$, and the space complexity is $O(\\frac{m}{\\log m})$. Where $n$ and $m$ are the length of the array and the maximum value in the array, respectively. \n\n", "problem_ids": ["distinct-prime-factors-of-product-of-array"]}, "3184": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a garden of n flowers, and each flower has an integer beauty value. The flowers are arranged in a line. You are given an integer array flowers of size n and each flowers[i] represents the beauty of the ith flower.\nA garden is valid if it meets these conditions:\n\nThe garden has at least two flowers.\nThe first and the last flower of the garden have the same beauty value.\n\nAs the appointed gardener, you have the ability to remove any (possibly none) flowers from the garden. You want to remove flowers in a way that makes the remaining garden valid. The beauty of the garden is the sum of the beauty of all the remaining flowers.\nReturn the maximum possible beauty of some valid garden after you have removed any (possibly none) flowers.\n\u00a0\nExample 1:\n\n\nInput: flowers = [1,2,3,1,2]\n\nOutput: 8\n\nExplanation: You can produce the valid garden [2,3,1,2] to have a total beauty of 2 + 3 + 1 + 2 = 8.\nExample 2:\n\n\nInput: flowers = [100,1,1,-3,1]\n\nOutput: 3\n\nExplanation: You can produce the valid garden [1,1,1] to have a total beauty of 1 + 1 + 1 = 3.\n\n\nExample 3:\n\n\nInput: flowers = [-1,-2,0,-1]\n\nOutput: -2\n\nExplanation: You can produce the valid garden [-1,-1] to have a total beauty of -1 + -1 = -2.\n\n\n\u00a0\nConstraints:\n\n2 <= flowers.length <= 105\n-104 <= flowers[i] <= 104\nIt is possible to create a valid garden by removing some (possibly none) flowers. Explanation:\n\nSolution 1: Hash Table + Prefix Sum\nWe use a hash table $d$ to record the first occurrence of each aesthetic value, and a prefix sum array $s$ to record the sum of the aesthetic values before the current position. If an aesthetic value $v$ appears at positions $i$ and $j$ (where $i \\lt j$), then we can get a valid garden $[i+1,j]$, whose aesthetic value is $s[i] - s[j + 1] + v \\times 2$. We use this value to update the answer. Otherwise, we record the current position $i$ of the aesthetic value in the hash table $d$. Next, we update the prefix sum. If the aesthetic value $v$ is negative, we treat it as $0$.\nAfter traversing all the aesthetic values, we can get the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of flowers. \n\n", "problem_ids": ["maximize-the-beauty-of-the-garden"]}, "3188": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an integer array nums, you need to find one continuous subarray such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.\nReturn the shortest such subarray and output its length.\n\u00a0\nExample 1:\n\nInput: nums = [2,6,4,8,10,9,15]\nOutput: 5\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: 0\n\nExample 3:\n\nInput: nums = [1]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 104\n-105 <= nums[i] <= 105\n\n\u00a0\nFollow up: Can you solve it in O(n) time complexity? Explanation:\n\nSolution 1: Sorting\nWe can first sort the array, and then compare the sorted array with the original array to find the leftmost and rightmost positions where they differ. The length between them is the length of the shortest unsorted continuous subarray.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["shortest-unsorted-continuous-subarray"]}, "3190": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string s and an integer k, return the number of substrings in s of length k with no repeated characters.\n\u00a0\nExample 1:\n\nInput: s = \"havefunonleetcode\", k = 5\nOutput: 6\nExplanation: There are 6 substrings they are: 'havef','avefu','vefun','efuno','etcod','tcode'.\n\nExample 2:\n\nInput: s = \"home\", k = 5\nOutput: 0\nExplanation: Notice k can be larger than the length of s. In this case, it is not possible to find any substring.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 104\ns consists of lowercase English letters.\n1 <= k <= 104 Explanation:\n\nSolution 1: Sliding Window + Hash Table\nWe maintain a sliding window of length $k$, and use a hash table $cnt$ to count the occurrences of each character in the window.\nFirst, we add the first $k$ characters of the string $s$ to the hash table $cnt$, and check whether the size of $cnt$ is equal to $k$. If it is, it means that all characters in the window are different, and the answer $ans$ is incremented by one.\nNext, we start to traverse the string $s$ from $k$. Each time we add $s[i]$ to the hash table $cnt$, and at the same time subtract $s[i-k]$ from the hash table $cnt$ by one. If $cnt[s[i-k]]$ is equal to $0$ after subtraction, we remove $s[i-k]$ from the hash table $cnt$. If the size of the hash table $cnt$ is equal to $k$ at this time, it means that all characters in the window are different, and the answer $ans$ is incremented by one.\nFinally, return the answer $ans$.\nThe time complexity is $O(n)$, and the space complexity is $O(\\min(k, |\\Sigma|))$, where $n$ is the length of the string $s$; and $\\Sigma$ is the character set, in this problem the character set is lowercase English letters, so $|\\Sigma| = 26$. \n\n", "problem_ids": ["find-k-length-substrings-with-no-repeated-characters"]}, "3192": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a year year and a month month, return the number of days of that month.\n\u00a0\nExample 1:\nInput: year = 1992, month = 7\nOutput: 31\n\nExample 2:\nInput: year = 2000, month = 2\nOutput: 29\n\nExample 3:\nInput: year = 1900, month = 2\nOutput: 28\n\n\u00a0\nConstraints:\n\n1583 <= year <= 2100\n1 <= month <= 12 Explanation:\n\nSolution 1: Determine Leap Year\nWe can first determine whether the given year is a leap year. If the year can be divided by $4$ but not by $100$, or can be divided by $400$, then this year is a leap year.\nFebruary has $29$ days in a leap year and $28$ days in a common year.\nWe can use an array $days$ to store the number of days in each month of the current year, where $days[0]=0$, $days[i]$ represents the number of days in the $i$th month of the current year. Then the answer is $days[month]$.\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["number-of-days-in-a-month"]}, "3193": {"text": "Similar Problem 1 \n\n Problem:\n\nThere is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i\u200b\u200b\u200b\u200b\u200b\u200b and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\n\u00a0\nExample 1:\n\nInput: gain = [-5,1,5,0,-7]\nOutput: 1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n\nExample 2:\n\nInput: gain = [-4,-3,-2,-1,4,3,2]\nOutput: 0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n\n\u00a0\nConstraints:\n\nn == gain.length\n1 <= n <= 100\n-100 <= gain[i] <= 100 Explanation:\n\nSolution 1: Prefix Sum (Difference Array)\nWe assume the altitude of each point is $h_i$. Since $gain[i]$ represents the altitude difference between the $i$th point and the $(i + 1)$th point, we have $gain[i] = h_{i + 1} - h_i$. Therefore:\n$$\n\\sum_{i = 0}^{n-1} gain[i] = h_1 - h_0 + h_2 - h_1 + \\cdots + h_n - h_{n - 1} = h_n - h_0 = h_n\n$$\nwhich implies:\n$$\nh_{i+1} = \\sum_{j = 0}^{i} gain[j]\n$$\nWe can see that the altitude of each point can be calculated through the prefix sum. Therefore, we only need to traverse the array once, find the maximum value of the prefix sum, which is the highest altitude.\n\nIn fact, the $gain$ array in the problem is a difference array. The prefix sum of the difference array gives the original altitude array. Then find the maximum value of the original altitude array.\n\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array gain. \n\n", "problem_ids": ["find-the-highest-altitude"]}, "3194": {"text": "Similar Problem 1 \n\n Problem:\n\nWrite a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\n\u00a0\nExample 1:\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nExample 2:\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns[i] is a printable ascii character. Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers $i$ and $j$, initially pointing to the start and end of the array respectively. Each time, we swap the elements at $i$ and $j$, then move $i$ forward and $j$ backward, until $i$ and $j$ meet.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["reverse-string"]}, "3195": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal.\nReturn true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise.\nNote:\n\nThe frequency of a letter x is the number of times it occurs in the string.\nYou must remove exactly one letter and cannot choose to do nothing.\n\n\u00a0\nExample 1:\n\nInput: word = \"abcc\"\nOutput: true\nExplanation: Select index 3 and delete it: word becomes \"abc\" and each character has a frequency of 1.\n\nExample 2:\n\nInput: word = \"aazz\"\nOutput: false\nExplanation: We must delete a character, so either the frequency of \"a\" is 1 and the frequency of \"z\" is 2, or vice versa. It is impossible to make all present letters have equal frequency.\n\n\u00a0\nConstraints:\n\n2 <= word.length <= 100\nword consists of lowercase English letters only. Explanation:\n\nSolution 1: Counting + Enumeration\nFirst, we use a hash table or an array of length $26$ named $cnt$ to count the number of occurrences of each letter in the string.\nNext, we enumerate the $26$ letters. If letter $c$ appears in the string, we decrement its count by one, then check whether the counts of the remaining letters are the same. If they are, return true. Otherwise, increment the count of $c$ by one and continue to enumerate the next letter.\nIf the enumeration ends, it means that it is impossible to make the counts of the remaining letters the same by deleting one letter, so return false.\nThe time complexity is $O(n + C^2)$, and the space complexity is $O(C)$. Here, $n$ is the length of the string $word$, and $C$ is the size of the character set. In this problem, $C = 26$. \n\n", "problem_ids": ["remove-letter-to-equalize-frequency"]}, "3196": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer.\nThe ith player can match with the jth trainer if the player's ability is less than or equal to the trainer's training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player.\nReturn the maximum number of matchings between players and trainers that satisfy these conditions.\n\u00a0\nExample 1:\n\nInput: players = [4,7,9], trainers = [8,2,5,8]\nOutput: 2\nExplanation:\nOne of the ways we can form two matchings is as follows:\n- players[0] can be matched with trainers[0] since 4 <= 8.\n- players[1] can be matched with trainers[3] since 7 <= 8.\nIt can be proven that 2 is the maximum number of matchings that can be formed.\n\nExample 2:\n\nInput: players = [1,1,1], trainers = [10]\nOutput: 1\nExplanation:\nThe trainer can be matched with any of the 3 players.\nEach player can only be matched with one trainer, so the maximum answer is 1.\n\n\u00a0\nConstraints:\n\n1 <= players.length, trainers.length <= 105\n1 <= players[i], trainers[j] <= 109\n\n\u00a0\nNote: This question is the same as  445: Assign Cookies. Explanation:\n\nSolution 1: Greedy + Two Pointers\nSort the athletes by their abilities in ascending order, and select the trainer with the smallest ability that is greater than or equal to the athlete's ability.\nThe time complexity is $O(n \\times \\log n + m \\times \\log m)$, and the space complexity is $O(\\log n + \\log m)$. Here, $n$ and $m$ are the number of athletes and trainers, respectively. \n\n", "problem_ids": ["maximum-matching-of-players-with-trainers"]}, "3199": {"text": "Similar Problem 1 \n\n Problem:\n\nTable: Tweets\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| tweet_id    | int     |\n| tweet_date  | date    |\n| tweet       | varchar |\n+-------------+---------+\ntweet_id is the primary key (column with unique values) for this table.\nEach row of this table contains user_id, tweet_id, tweet_date and tweet.\n\nWrite a solution to find the top 3 trending hashtags\u00a0in\u00a0February 2024. Each tweet only contains one hashtag.\nReturn the result table orderd by count of hashtag, hashtag in descending order.\nThe result format is in the following example.\n\u00a0\nExample 1:\n\nInput:\nTweets table:\n\n+---------+----------+----------------------------------------------+------------+\n| user_id | tweet_id | tweet                                        | tweet_date |\n+---------+----------+----------------------------------------------+------------+\n| 135     | 13       | Enjoying a great start to the day! #HappyDay | 2024-02-01 |\n| 136     | 14       | Another #HappyDay with good vibes!           | 2024-02-03 |\n| 137     | 15       | Productivity peaks! #WorkLife                | 2024-02-04 |\n| 138     | 16       | Exploring new tech frontiers. #TechLife      | 2024-02-04 |\n| 139     | 17       | Gratitude for today's moments. #HappyDay     | 2024-02-05 |\n| 140     | 18       | Innovation drives us. #TechLife              | 2024-02-07 |\n| 141     | 19       | Connecting with nature's serenity. #Nature   | 2024-02-09 |\n+---------+----------+----------------------------------------------+------------+\n \nOutput:\n\n+-----------+--------------+\n| hashtag   | hashtag_count|\n+-----------+--------------+\n| #HappyDay | 3            |\n| #TechLife | 2            |\n| #WorkLife | 1            |\n+-----------+--------------+\n\n\nExplanation:\n\n#HappyDay: Appeared in tweet IDs 13, 14, and 17, with a total count of 3 mentions.\n#TechLife: Appeared in tweet IDs 16 and 18, with a total count of 2 mentions.\n#WorkLife: Appeared in tweet ID 15, with a total count of 1 mention.\n\nNote: Output table is sorted in descending order by hashtag_count and hashtag respectively. Explanation:\n\nSolution 1: Extract Substring + Grouping\nWe can query all tweets from February 2024, use the SUBSTRING_INDEX function to extract Hashtags, then use the GROUP BY and COUNT functions to count the occurrences of each Hashtag. Finally, we sort by the number of occurrences in descending order and by Hashtag in descending order, and take the top three popular Hashtags.\n\nMySQL\n```sql\nWrite your MySQL query statement below\nSELECT\n    CONCAT('#', SUBSTRING_INDEX(SUBSTRING_INDEX(tweet, '#', -1), ' ', 1)) AS hashtag,\n    COUNT(1) AS hashtag_count\nFROM Tweets\nWHERE DATE_FORMAT(tweet_date, '%Y%m') = '202402'\nGROUP BY 1\nORDER BY 2 DESC, 1 DESC\nLIMIT 3;\n``` \n\n", "problem_ids": ["find-trending-hashtags"]}, "3200": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an m x n matrix, return all elements of the matrix in spiral order.\n\u00a0\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\n\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\u00a0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 10\n-100 <= matrix[i][j] <= 100 Explanation:\n\nSolution 1: Simulation\nWe use $i$ and $j$ to represent the row and column of the current element, use $k$ to represent the current direction, and use an array or hash table $vis$ to record whether each element has been visited. Each time we visit an element, we mark it as visited, then move forward in the current direction. If we find that it is out of bounds or has been visited after moving forward, we change the direction and continue to move forward until the entire matrix is traversed.\nThe time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, respectively.\nFor visited elements, we can also add a constant $300$ to their values, so we don't need an extra $vis$ array or hash table to record whether they have been visited, thereby reducing the space complexity to $O(1)$. \n\n", "problem_ids": ["spiral-matrix"]}, "3203": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed permutation of n integers nums.\nA permutation is called semi-ordered if the first number equals 1 and the last number equals n. You can perform the below operation as many times as you want until you make nums a semi-ordered permutation:\n\nPick two adjacent elements in nums, then swap them.\n\nReturn the minimum number of operations to make nums a semi-ordered permutation.\nA permutation is a sequence of integers from 1 to n of length n containing each number exactly once.\n\u00a0\nExample 1:\n\nInput: nums = [2,1,4,3]\nOutput: 2\nExplanation: We can make the permutation semi-ordered using these sequence of operations: \n1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. \n\nExample 2:\n\nInput: nums = [2,4,1,3]\nOutput: 3\nExplanation: We can make the permutation semi-ordered using these sequence of operations:\n1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].\n2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.\n\nExample 3:\n\nInput: nums = [1,3,4,2,5]\nOutput: 0\nExplanation: The permutation is already a semi-ordered permutation.\n\n\u00a0\nConstraints:\n\n2 <= nums.length == n <= 50\n1 <= nums[i]\u00a0<= 50\nnums is a permutation. Explanation:\n\nSolution 1: Find the Positions of 1 and n\nWe can first find the indices $i$ and $j$ of $1$ and $n$, respectively. Then, based on the relative positions of $i$ and $j$, we can determine the number of swaps required.\nIf $i < j$, the number of swaps required is $i + n - j - 1$. If $i > j$, the number of swaps required is $i + n - j - 2$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["semi-ordered-permutation"]}, "3206": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of integers nums, half of the integers in nums are odd, and the other half are even.\nSort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\nReturn any answer array that satisfies this condition.\n\u00a0\nExample 1:\n\nInput: nums = [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n\nExample 2:\n\nInput: nums = [2,3]\nOutput: [2,3]\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 2 * 104\nnums.length is even.\nHalf of the integers in nums are even.\n0 <= nums[i] <= 1000\n\n\u00a0\nFollow Up: Could you solve it in-place? Explanation:\n\nSolution 1: Two Pointers\nWe use two pointers $i$ and $j$ to point to even and odd indices respectively.\nWhen $i$ points to an even index, if $nums[i]$ is odd, then we need to find an odd index $j$ such that $nums[j]$ is even, and then swap $nums[i]$ and $nums[j]$. Continue to iterate until $i$ points to the end of the array.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["sort-array-by-parity-ii"]}, "3207": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\n\u00a0\nExample 1:\n\nInput: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n\nExample 2:\n\nInput: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\nnums[i] is either 0 or 1. Explanation:\n\nSolution 1: Prefix Sum + Hash Table\nAccording to the problem description, we can treat $0$s in the array as $-1$. In this way, when encountering a $0$, the prefix sum $s$ will decrease by one, and when encountering a $1$, the prefix sum $s$ will increase by one. Therefore, suppose the prefix sum $s$ is equal at indices $j$ and $i$, where $j < i$, then the subarray from index $j + 1$ to $i$ has an equal number of $0$s and $1$s.\nWe use a hash table to store all prefix sums and their first occurrence indices. Initially, we map the prefix sum of $0$ to $-1$.\nAs we iterate through the array, we calculate the prefix sum $s$. If $s$ is already in the hash table, then we have found a subarray with a sum of $0$, and its length is $i - d[s]$, where $d[s]$ is the index where $s$ first appeared in the hash table. If $s$ is not in the hash table, we store $s$ and its index $i$ in the hash table.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array. \n\n", "problem_ids": ["contiguous-array"]}, "3209": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a binary string s, return true if the longest contiguous segment of 1's is strictly longer than the longest contiguous segment of 0's in s, or return false otherwise.\n\nFor example, in s = \"110100010\" the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3.\n\nNote that if there are no 0's, then the longest continuous segment of 0's is considered to have a length 0. The same applies if there is no 1's.\n\u00a0\nExample 1:\n\nInput: s = \"1101\"\nOutput: true\nExplanation:\nThe longest contiguous segment of 1s has length 2: \"1101\"\nThe longest contiguous segment of 0s has length 1: \"1101\"\nThe segment of 1s is longer, so return true.\n\nExample 2:\n\nInput: s = \"111000\"\nOutput: false\nExplanation:\nThe longest contiguous segment of 1s has length 3: \"111000\"\nThe longest contiguous segment of 0s has length 3: \"111000\"\nThe segment of 1s is not longer, so return false.\n\nExample 3:\n\nInput: s = \"110100010\"\nOutput: false\nExplanation:\nThe longest contiguous segment of 1s has length 2: \"110100010\"\nThe longest contiguous segment of 0s has length 3: \"110100010\"\nThe segment of 1s is not longer, so return false.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 100\ns[i] is either '0' or '1'. Explanation:\n\nSolution 1: Two Passes\nWe design a function $f(x)$, which represents the length of the longest consecutive substring in string $s$ composed of $x$. If $f(1) > f(0)$, then return true, otherwise return false.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. The space complexity is $O(1)`. \n\n", "problem_ids": ["longer-contiguous-segments-of-ones-than-zeros"]}, "3210": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s.\nConsider performing the following operation until s becomes empty:\n\nFor every alphabet character from 'a' to 'z', remove the first occurrence of that character in s (if it exists).\n\nFor example, let initially s = \"aabcbbca\". We do the following operations:\n\nRemove the underlined characters s = \"aabcbbca\". The resulting string is s = \"abbca\".\nRemove the underlined characters s = \"abbca\". The resulting string is s = \"ba\".\nRemove the underlined characters s = \"ba\". The resulting string is s = \"\".\n\nReturn the value of the string s right before applying the last operation. In the example above, answer is \"ba\".\n\u00a0\nExample 1:\n\nInput: s = \"aabcbbca\"\nOutput: \"ba\"\nExplanation: Explained in the statement.\n\nExample 2:\n\nInput: s = \"abcd\"\nOutput: \"abcd\"\nExplanation: We do the following operation:\n- Remove the underlined characters s = \"abcd\". The resulting string is s = \"\".\nThe string just before the last operation is \"abcd\".\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 5 * 105\ns consists only of lowercase English letters. Explanation:\n\nSolution 1: Hash Table or Array\nWe use a hash table or array $cnt$ to record the occurrence times of each character in string $s$, and use another hash table or array $last$ to record the last occurrence position of each character in string $s$. The maximum occurrence times of characters in string $s$ is denoted as $mx$.\nThen we traverse the string $s$. If the occurrence times of the current character equals $mx$ and the position of the current character equals the last occurrence position of this character, then we add the current character to the answer.\nAfter the traversal, we return the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(|\\Sigma|)$, where $n$ is the length of string $s$, and $\\Sigma$ is the character set. In this problem, $\\Sigma$ is the set of lowercase English letters. \n\n", "problem_ids": ["apply-operations-to-make-string-empty"]}, "3211": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s. It may contain any number of '*' characters. Your task is to remove all '*' characters.\nWhile there is a '*', do the following operation:\n\nDelete the leftmost '*' and the smallest non-'*' character to its left. If there are several smallest characters, you can delete any of them.\n\nReturn the lexicographically smallest resulting string after removing all '*' characters.\n\u00a0\nExample 1:\n\nInput: s = \"aaba*\"\nOutput: \"aab\"\nExplanation:\nWe should delete one of the 'a' characters with '*'. If we choose s[3], s becomes the lexicographically smallest.\n\nExample 2:\n\nInput: s = \"abc\"\nOutput: \"abc\"\nExplanation:\nThere is no '*' in the string.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists only of lowercase English letters and '*'.\nThe input is generated such that it is possible to delete all '*' characters. Explanation:\n\nSolution 1: Record Indices by Character\nWe define an array $g$ to record the index list of each character, and a boolean array $rem$ of length $n$ to record whether each character needs to be deleted.\nWe traverse the string $s$:\nIf the current character is an asterisk, we need to delete it, so we mark $rem[i]$ as deleted. At the same time, we need to delete the character with the smallest lexicographical order and the largest index at this time. We traverse the 26 lowercase letters in ascending order. If $g[a]$ is not empty, we delete the last index in $g[a]$ and set the corresponding index in $rem$ as deleted.\nIf the current character is not an asterisk, we add the index of the current character to $g$.\nFinally, we traverse $s$ and concatenate the undeleted characters.\nThe time complexity is $O(n \\times |\\Sigma|)$, and the space complexity is $O(n)$. Where $n$ is the length of the string $s$, and $|\\Sigma|$ is the size of the character set. In this problem, $|\\Sigma| = 26$. \n\n", "problem_ids": ["lexicographically-minimum-string-after-removing-stars"]}, "3212": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array nums, an integer array queries, and an integer x.\nFor each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query.\nReturn an integer array answer containing the answers to all queries.\n\u00a0\nExample 1:\n\nInput: nums = [1,3,1,7], queries = [1,3,2,4], x = 1\nOutput: [0,-1,2,-1]\nExplanation:\n\nFor the 1st query, the first occurrence of 1 is at index 0.\nFor the 2nd query, there are only two occurrences of 1 in nums, so the answer is -1.\nFor the 3rd query, the second occurrence of 1 is at index 2.\nFor the 4th query, there are only two occurrences of 1 in nums, so the answer is -1.\n\n\nExample 2:\n\nInput: nums = [1,2,3], queries = [10], x = 5\nOutput: [-1]\nExplanation:\n\nFor the 1st query, 5 doesn't exist in nums, so the answer is -1.\n\n\n\u00a0\nConstraints:\n\n1 <= nums.length, queries.length <= 105\n1 <= queries[i] <= 105\n1 <= nums[i], x <= 104 Explanation:\n\nSolution 1: Simulation\nAccording to the problem description, we can first traverse the array nums to find the indices of all elements with a value of $x$, and record them in the array ids.\nNext, we traverse the array queries. For each query $i$, if $i - 1$ is less than the length of ids, then the answer is ids[i - 1], otherwise, the answer is $-1$.\nThe time complexity is $O(n + m)$, and the space complexity is $O(n + m)$. Where $n$ and $m$ are the lengths of the arrays nums and queries respectively. \n\n", "problem_ids": ["find-occurrences-of-an-element-in-an-array"]}, "3213": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed array words consisting of distinct strings.\nThe string words[i] can be paired with the string words[j] if:\n\nThe string words[i] is equal to the reversed string of words[j].\n0 <= i < j < words.length.\n\nReturn the maximum number of pairs that can be formed from the array words.\nNote that\u00a0each string can belong in\u00a0at most one pair.\n\u00a0\nExample 1:\n\nInput: words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\nOutput: 2\nExplanation: In this example, we can form 2 pair of strings in the following way:\n- We pair the 0th string with the 2nd string, as the reversed string of word[0] is \"dc\" and is equal to words[2].\n- We pair the 1st string with the 3rd string, as the reversed string of word[1] is \"ca\" and is equal to words[3].\nIt can be proven that 2 is the maximum number of pairs that can be formed.\nExample 2:\n\nInput: words = [\"ab\",\"ba\",\"cc\"]\nOutput: 1\nExplanation: In this example, we can form 1 pair of strings in the following way:\n- We pair the 0th string with the 1st string, as the reversed string of words[1] is \"ab\" and is equal to words[0].\nIt can be proven that 1 is the maximum number of pairs that can be formed.\n\nExample 3:\n\nInput: words = [\"aa\",\"ab\"]\nOutput: 0\nExplanation: In this example, we are unable to form any pair of strings.\n\n\u00a0\nConstraints:\n\n1 <= words.length <= 50\nwords[i].length == 2\nwords\u00a0consists of distinct strings.\nwords[i]\u00a0contains only lowercase English letters. Explanation:\n\nSolution 1: Hash Table\nWe can use a hash table $cnt$ to store the number of occurrences of each reversed string in the array $words$.\nWe iterate through the array $words$. For each string $w$, we add the number of occurrences of its reversed string to the answer, then increment the count of $w$ by $1$.\nFinally, we return the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $words$. \n\n", "problem_ids": ["find-maximum-number-of-string-pairs"]}, "3219": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying\u00a0the constraint.\n\u00a0\nExample 1:\n\nInput: n = 7\nOutput: 21\nExplanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21.\n\nExample 2:\n\nInput: n = 10\nOutput: 40\nExplanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40.\n\nExample 3:\n\nInput: n = 9\nOutput: 30\nExplanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30.\n\n\u00a0\nConstraints:\n\n1 <= n <= 103 Explanation:\n\nSolution 1: Enumeration\nWe directly enumerate every number $x$ in $[1,..n]$, and if $x$ is divisible by $3$, $5$, and $7$, we add $x$ to the answer.\nAfter the enumeration, we return the answer.\nThe time complexity is $O(n)$, where $n$ is the given integer. The space complexity is $O(1)$. \n\n", "problem_ids": ["sum-multiples"]}, "3220": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of integers\u00a0arr\u00a0and an integer k.\u00a0Find the least number of unique integers\u00a0after removing exactly k elements.\n\n\n\u00a0\nExample 1:\n\n\nInput: arr = [5,5,4], k = 1\n\nOutput: 1\n\nExplanation: Remove the single 4, only 5 is left.\n\n\nExample 2:\n\n\nInput: arr = [4,3,1,1,3,3,2], k = 3\n\nOutput: 2\n\nExplanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n\u00a0\nConstraints:\n\n1 <= arr.length\u00a0<= 10^5\n1 <= arr[i] <= 10^9\n0 <= k\u00a0<= arr.length Explanation:\n\nSolution 1: Hash Table + Sorting\nWe use the hash table $cnt$ to count the number of times each integer in the array $arr$ appears, and then sort the values in $cnt$ in ascending order, and record them in the array $nums$.\nNext, we traverse the array $nums$. For the current value that we traverse to $nums[i]$, we subtract $k$ by $nums[i]$. If $k \\lt 0$, it means that we have removed $k$ elements, and the minimum number of different integers in the array is the length of $nums$ minus the index $i$ that we traverse to at the current time. Return directly.\nIf we traverse to the end, it means that we have removed all the elements, and the minimum number of different integers in the array is $0$.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $arr$. \n\n", "problem_ids": ["least-number-of-unique-integers-after-k-removals"]}, "3221": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given n\u200b\u200b\u200b\u200b\u200b\u200b tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b task will be available to process at enqueueTimei and will take processingTimei to finish processing.\nYou have a single-threaded CPU that can process at most one task at a time and will act in the following way:\n\nIf the CPU is idle and there are no available tasks to process, the CPU remains idle.\nIf the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.\nOnce a task is started, the CPU will process the entire task without stopping.\nThe CPU can finish a task then start a new one instantly.\n\nReturn the order in which the CPU will process the tasks.\n\u00a0\nExample 1:\n\nInput: tasks = [[1,2],[2,4],[3,2],[4,1]]\nOutput: [0,2,3,1]\nExplanation: The events go as follows: \n- At time = 1, task 0 is available to process. Available tasks = {0}.\n- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n- At time = 2, task 1 is available to process. Available tasks = {1}.\n- At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n- At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n- At time = 10, the CPU finishes task 1 and becomes idle.\n\nExample 2:\n\nInput: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\nOutput: [4,3,2,0,1]\nExplanation: The events go as follows:\n- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n- At time = 40, the CPU finishes task 1 and becomes idle.\n\n\u00a0\nConstraints:\n\ntasks.length == n\n1 <= n <= 105\n1 <= enqueueTimei, processingTimei <= 109 Explanation:\n\nSolution 1: Sorting + Priority Queue (Min Heap)\nFirst, we sort the tasks by enqueueTime in ascending order. Next, we use a priority queue (min heap) to maintain the currently executable tasks. The elements in the queue are (processingTime, index), which represent the execution time and the index of the task. We also use a variable $t$ to represent the current time, initially set to $0$.\nNext, we simulate the execution process of the tasks.\nIf the current queue is empty, it means there are no executable tasks at the moment. We update $t$ to the larger value between the enqueueTime of the next task and the current time $t$. Then, we add all tasks with enqueueTime less than or equal to $t$ to the queue.\nThen, we take out a task from the queue, add its index to the answer array, and update $t$ to the sum of the current time $t$ and the execution time of the current task.\nWe repeat the above process until the queue is empty and all tasks have been added to the queue.\nThe time complexity is $O(n \\times \\log n)$, where $n$ is the number of tasks. \n\n", "problem_ids": ["single-threaded-cpu"]}, "3223": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a positive integer n.\nWe call an integer k fair if the number of even digits in k is equal to the number of odd digits in it.\nReturn the smallest fair integer that is greater than or equal to n.\n\u00a0\nExample 1:\n\nInput: n = 2\nOutput: 10\nExplanation: The smallest fair integer that is greater than or equal to 2 is 10.\n10 is fair because it has an equal number of even and odd digits (one odd digit and one even digit).\nExample 2:\n\nInput: n = 403\nOutput: 1001\nExplanation: The smallest fair integer that is greater than or equal to 403 is 1001.\n1001 is fair because it has an equal number of even and odd digits (two odd digits and two even digits).\n\n\u00a0\nConstraints:\n\n1 <= n <= 109 Explanation:\n\nSolution 1: Case Discussion\nWe denote the number of digits of $n$ as $k$, and the number of odd and even digits as $a$ and $b$ respectively.\n\nIf $a = b$, then $n$ itself is fair, and we can directly return $n$;\nOtherwise, if $k$ is odd, we can find the smallest fair number with $k+1$ digits, in the form of 10000111. If $k$ is even, we can directly brute force closestFair(n+1).\n\nThe time complexity is $O(\\sqrt{n} \\times \\log_{10} n)$. \n\n", "problem_ids": ["closest-fair-integer"]}, "3224": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a binary array nums, return the maximum number of consecutive 1's in the array if you can flip at most one 0.\n\u00a0\nExample 1:\n\nInput: nums = [1,0,1,1,0]\nOutput: 4\nExplanation: \n- If we flip the first zero, nums becomes [1,1,1,1,0] and we have 4 consecutive ones.\n- If we flip the second zero, nums becomes [1,0,1,1,1] and we have 3 consecutive ones.\nThe max number of consecutive ones is 4.\n\nExample 2:\n\nInput: nums = [1,0,1,1,0,1]\nOutput: 4\nExplanation: \n- If we flip the first zero, nums becomes [1,1,1,1,0,1] and we have 4 consecutive ones.\n- If we flip the second zero, nums becomes [1,0,1,1,1,1] and we have 4 consecutive ones.\nThe max number of consecutive ones is 4.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\nnums[i] is either 0 or 1.\n\n\u00a0\nFollow up: What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently? Explanation:\n\nSolution 1: Sliding Window\nWe can iterate through the array, using a variable $\\textit{cnt}$ to record the current number of 0s in the window. When $\\textit{cnt} > 1$, we move the left boundary of the window to the right by one position.\nAfter the iteration ends, the length of the window is the maximum number of consecutive 1s.\nNote that in the process above, we do not need to loop to move the left boundary of the window to the right. Instead, we directly move the left boundary to the right by one position. This is because the problem asks for the maximum number of consecutive 1s, so the length of the window will only increase, not decrease. Therefore, we do not need to loop to move the left boundary to the right.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["max-consecutive-ones-ii"]}, "3225": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a circular linked list list of positive integers, your task is to split it into 2 circular linked lists so that the first one contains the first half of the nodes in list (exactly ceil(list.length / 2) nodes) in the same order they appeared in list, and the second one contains the rest of the nodes in list in the same order they appeared in list.\nReturn an array answer of length 2 in which the first element is a circular linked list representing the first half and the second element is a circular linked list representing the second half.\nA circular linked list is a normal linked list with the only difference being that the last node's next node, is the first node.\n\u00a0\nExample 1:\n\nInput: nums = [1,5,7]\nOutput: [[1,5],[7]]\nExplanation: The initial list has 3 nodes so the first half would be the first 2 elements since ceil(3 / 2) = 2 and the rest which is 1 node is in the second half.\n\nExample 2:\n\nInput: nums = [2,6,1,5]\nOutput: [[2,6],[1,5]]\nExplanation: The initial list has 4 nodes so the first half would be the first 2 elements since ceil(4 / 2) = 2 and the rest which is 2 nodes are in the second half.\n\n\u00a0\nConstraints:\n\nThe number of nodes in list\u00a0is in the range [2, 105]\n0 <= Node.val <= 109\nLastNode.next = FirstNode where LastNode is the last node of the list and FirstNode is the first one Explanation:\n\nSolution 1: Fast and Slow Pointers\nWe define two pointers $a$ and $b$, both initially pointing to the head of the linked list. Each iteration, pointer $a$ moves forward one step, and pointer $b$ moves forward two steps, until pointer $b$ reaches the end of the linked list. At this point, pointer $a$ points to half of the linked list nodes, and we break the linked list from pointer $a$, thus obtaining the head nodes of the two linked lists.\nThe time complexity is $O(n)$, where $n$ is the length of the linked list. It requires one traversal of the linked list. The space complexity is $O(1)$. \n\n", "problem_ids": ["split-a-circular-linked-list"]}, "3226": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array nums\u200b\u200b\u200b and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.\nA subset's incompatibility is the difference between the maximum and minimum elements in that array.\nReturn the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.\nA subset is a group integers that appear in the array with no particular order.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,1,4], k = 2\nOutput: 4\nExplanation: The optimal distribution of subsets is [1,2] and [1,4].\nThe incompatibility is (2-1) + (4-1) = 4.\nNote that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.\nExample 2:\n\nInput: nums = [6,3,8,1,3,1,2,2], k = 4\nOutput: 6\nExplanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].\nThe incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.\n\nExample 3:\n\nInput: nums = [5,3,3,6,3,3], k = 3\nOutput: -1\nExplanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.\n\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 16\nnums.length is divisible by k\n1 <= nums[i] <= nums.length Explanation:\n\nSolution 1: Preprocessing + State Compression + Dynamic Programming\nLet's assume that the size of each subset after partitioning is $m$, so $m=\\frac{n}{k}$, where $n$ is the length of the array.\nWe can enumerate all subsets $i$, where $i \\in [0, 2^n)$, if the binary representation of subset $i$ has $m$ ones, and the elements in subset $i$ are not repeated, then we can calculate the incompatibility of subset $i$, denoted as $g[i]$, i.e., $g[i]=\\max_{j \\in i} {nums[j]} - \\min_{j \\in i} {nums[j]}$.\nNext, we can use dynamic programming to solve.\nWe define $f[i]$ as the minimum sum of incompatibilities when the current partitioned subset state is $i$. Initially, $f[0]=0$, which means no elements are partitioned into the subset, and the rest $f[i]=+\\infty$.\nFor state $i$, we find all undivided and non-repeated elements, represented by a state $mask$. If the number of elements in state $mask$ is greater than or equal to $m$, then we enumerate all subsets $j$ of $mask$, and satisfy $j \\subset mask$, then $f[i \\cup j]=\\min {f[i \\cup j], f[i]+g[j]}$.\nFinally, if $f[2^n-1]=+\\infty$, it means that it cannot be partitioned into $k$ subsets, return $-1$, otherwise return $f[2^n-1]$.\nThe time complexity is $O(3^n)$, and the space complexity is $O(2^n)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["minimum-incompatibility"]}, "3227": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.\nReturn the minimum possible value of nums[n - 1].\n\u00a0\nExample 1:\n\nInput: n = 3, x = 4\nOutput: 6\nExplanation:\nnums can be [4,5,6] and its last element is 6.\n\nExample 2:\n\nInput: n = 2, x = 7\nOutput: 15\nExplanation:\nnums can be [7,15] and its last element is 15.\n\n\u00a0\nConstraints:\n\n1 <= n, x <= 108 Explanation:\n\nSolution 1: Greedy + Bit Manipulation\nAccording to the problem description, to make the last element of the array as small as possible and the bitwise AND result of the elements in the array is $x$, the first element of the array must be $x$.\nAssume the binary representation of $x$ is $\\underline{1}00\\underline{1}00$, then the array sequence is $\\underline{1}00\\underline{1}00$, $\\underline{1}00\\underline{1}01$, $\\underline{1}00\\underline{1}10$, $\\underline{1}00\\underline{1}11$...\nIf we ignore the underlined part, then the array sequence is $0000$, $0001$, $0010$, $0011$..., the first item is $0$, then the $n$-th item is $n-1$.\nTherefore, the answer is to fill each bit of the binary of $n-1$ into the $0$ bit of the binary of $x$ based on $x$.\nThe time complexity is $O(\\log x)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["minimum-array-end"]}, "3228": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array nums consisting of positive integers.\nYou are also given an integer array queries of size m. For the ith query, you want to make all of the elements of nums equal to queries[i]. You can perform the following operation on the array any number of times:\n\nIncrease or decrease an element of the array by 1.\n\nReturn an array answer of size m where answer[i] is the minimum number of operations to make all elements of nums equal to queries[i].\nNote that after each query the array is reset to its original state.\n\u00a0\nExample 1:\n\nInput: nums = [3,1,6,8], queries = [1,5]\nOutput: [14,10]\nExplanation: For the first query we can do the following operations:\n- Decrease nums[0] 2 times, so that nums = [1,1,6,8].\n- Decrease nums[2] 5 times, so that nums = [1,1,1,8].\n- Decrease nums[3] 7 times, so that nums = [1,1,1,1].\nSo the total number of operations for the first query is 2 + 5 + 7 = 14.\nFor the second query we can do the following operations:\n- Increase nums[0] 2 times, so that nums = [5,1,6,8].\n- Increase nums[1] 4 times, so that nums = [5,5,6,8].\n- Decrease nums[2] 1 time, so that nums = [5,5,5,8].\n- Decrease nums[3] 3 times, so that nums = [5,5,5,5].\nSo the total number of operations for the second query is 2 + 4 + 1 + 3 = 10.\n\nExample 2:\n\nInput: nums = [2,9,6,3], queries = [10]\nOutput: [20]\nExplanation: We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20.\n\n\u00a0\nConstraints:\n\nn == nums.length\nm == queries.length\n1 <= n, m <= 105\n1 <= nums[i], queries[i] <= 109 Explanation:\n\nSolution 1: sort + prefix sum + binary search\nFirst, we sort the array $nums$ and calculate the prefix sum array $s$ with a length of $n+1$, where $s[i]$ represents the sum of the first $i$ elements in the array $nums$.\nThen, we traverse each query $queries[i]$, we need to reduce all elements greater than $queries[i]$ to $queries[i]$, and increase all elements less than $queries[i]$ to $queries[i]$.\nWe can use binary search to find the index $i$ of the first element in the array $nums$ that is greater than $queries[i]$. There are $n-i$ elements that need to be reduced to $queries[i]$, and the sum of these elements is $s[n]-s[i]$. These elements need to be reduced by $n-i$ $queries[i]$, so the total number of operations to reduce these elements to $queries[i]$ is $s[n]-s[i]-(n-i)\\times queries[i]$.\nSimilarly, we can find the index $i$ of the first element in the array $nums$ that is greater than or equal to $queries[i]$. There are $i$ elements that need to be increased to $queries[i]$, and the sum of these elements is $s[i]$. Therefore, the total number of operations to increase these elements to $queries[i]$ is $queries[i]\\times i-s[i]$.\nFinally, add these two total operation counts together to get the minimum number of operations to change all elements in the array $nums$ to $queries[i]$, that is, $ans[i]=s[n]-s[i]-(n-i)\\times queries[i]+queries[i]\\times i-s[i]$.\nTime complexity $O(n \\times \\log n)$, space complexity $O(n)$, where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["minimum-operations-to-make-all-array-elements-equal"]}, "3229": {"text": "Similar Problem 1 \n\n Problem:\n\nIn a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].\nRearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.\n\u00a0\nExample 1:\nInput: barcodes = [1,1,1,2,2,2]\nOutput: [2,1,2,1,2,1]\n\nExample 2:\nInput: barcodes = [1,1,1,1,2,2,3,3]\nOutput: [1,3,1,3,1,2,1,2]\n\n\u00a0\nConstraints:\n\n1 <= barcodes.length <= 10000\n1 <= barcodes[i] <= 10000 Explanation:\n\nSolution 1: Counting + Sorting\nFirst, we use a hash table or array $cnt$ to count the number of occurrences of each number in the array $barcodes$. Then, we sort the numbers in $barcodes$ according to their occurrence times in $cnt$ from large to small. If the occurrence times are the same, we sort them from small to large (to ensure the same numbers are adjacent).\nNext, we create an answer array $ans$ of length $n$. We traverse the sorted $barcodes$, and sequentially fill the elements into the even index positions $0, 2, 4, \\cdots$ of the answer array. Then, we fill the remaining elements into the odd index positions $1, 3, 5, \\cdots$ of the answer array.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(M)$. Where $n$ and $M$ are the length of the array $barcodes$ and the maximum value in the array $barcodes$, respectively. \n\n", "problem_ids": ["distant-barcodes"]}, "3230": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed integer array nums.\nReturn the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.\nThe value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].\n\u00a0\nExample 1:\n\nInput: nums = [12,6,1,2,7]\nOutput: 77\nExplanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77. \n\nExample 2:\n\nInput: nums = [1,10,3,4,19]\nOutput: 133\nExplanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 0\nExplanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.\n\n\u00a0\nConstraints:\n\n3 <= nums.length <= 105\n1 <= nums[i] <= 106 Explanation:\n\nSolution 1: Maintain Maximum Prefix Value and Maximum Difference\nWe can use two variables $mx$ and $mx_diff$ to maintain the maximum prefix value and maximum difference, respectively. When traversing the array, we update these two variables, and the answer is the maximum value of all $mx_diff \\times nums[i]$.\nThe time complexity is $O(n)$, where $n$ is the length of the array. The space complexity is $O(1)$. \n\n", "problem_ids": ["maximum-value-of-an-ordered-triplet-ii"]}, "3231": {"text": "Similar Problem 1 \n\n Problem:\n\nYou have a 1-indexed binary string of length n where all the bits are 0 initially. We will flip all the bits of this binary string (i.e., change them from 0 to 1) one by one. You are given a 1-indexed integer array flips where flips[i] indicates that the bit at index i will be flipped in the ith step.\nA binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros.\nReturn the number of times the binary string is prefix-aligned during the flipping process.\n\u00a0\nExample 1:\n\nInput: flips = [3,2,4,1,5]\nOutput: 2\nExplanation: The binary string is initially \"00000\".\nAfter applying step 1: The string becomes \"00100\", which is not prefix-aligned.\nAfter applying step 2: The string becomes \"01100\", which is not prefix-aligned.\nAfter applying step 3: The string becomes \"01110\", which is not prefix-aligned.\nAfter applying step 4: The string becomes \"11110\", which is prefix-aligned.\nAfter applying step 5: The string becomes \"11111\", which is prefix-aligned.\nWe can see that the string was prefix-aligned 2 times, so we return 2.\n\nExample 2:\n\nInput: flips = [4,1,2,3]\nOutput: 1\nExplanation: The binary string is initially \"0000\".\nAfter applying step 1: The string becomes \"0001\", which is not prefix-aligned.\nAfter applying step 2: The string becomes \"1001\", which is not prefix-aligned.\nAfter applying step 3: The string becomes \"1101\", which is not prefix-aligned.\nAfter applying step 4: The string becomes \"1111\", which is prefix-aligned.\nWe can see that the string was prefix-aligned 1 time, so we return 1.\n\n\u00a0\nConstraints:\n\nn == flips.length\n1 <= n <= 5 * 104\nflips is a permutation of the integers in the range [1, n]. Explanation:\n\nSolution 1: Direct Traversal\nWe can traverse the array $flips$, keeping track of the maximum value $mx$ of the elements we have traversed so far. If $mx$ equals the current index $i$ we are traversing, it means that the first $i$ elements have all been flipped, i.e., the prefix is consistent, and we increment the answer.\nAfter the traversal is finished, we return the answer.\nThe time complexity is $O(n)$, where $n$ is the length of the array $flips$. The space complexity is $O(1)$. \n\n", "problem_ids": ["number-of-times-binary-string-is-prefix-aligned"]}, "3233": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two positive integers x and y, denoting the number of coins with values 75 and 10 respectively.\nAlice and Bob are playing a game. Each turn, starting with Alice, the player must pick up coins with a total value 115. If the player is unable to do so, they lose the game.\nReturn the name of the player who wins the game if both players play optimally.\n\u00a0\nExample 1:\n\nInput: x = 2, y = 7\nOutput: \"Alice\"\nExplanation:\nThe game ends in a single turn:\n\nAlice picks 1 coin with a value of 75 and 4 coins with a value of 10.\n\n\nExample 2:\n\nInput: x = 4, y = 11\nOutput: \"Bob\"\nExplanation:\nThe game ends in 2 turns:\n\nAlice picks 1 coin with a value of 75 and 4 coins with a value of 10.\nBob picks 1 coin with a value of 75 and 4 coins with a value of 10.\n\n\n\u00a0\nConstraints:\n\n1 <= x, y <= 100 Explanation:\n\nSolution 1: Mathematics\nSince each round of operation consumes $2$ coins valued at $75$ and $8$ coins valued at $10$, we can calculate the number of rounds $k = \\min(x / 2, y / 8)$, and then update the values of $x$ and $y$, where $x$ and $y$ are the remaining number of coins after $k$ rounds of operations.\nIf $x > 0$ and $y \\geq 4$, then Alice can continue the operation, and Bob loses, return \"Alice\"; otherwise, return \"Bob\".\nThe time complexity is $O(1)$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["find-the-winning-player-in-coin-game"]}, "3234": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 1-indexed array of distinct integers nums of length n.\nYou need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:\n\nIf the last element of arr1 is greater than the last element of arr2, append nums[i] to arr1. Otherwise, append nums[i] to arr2.\n\nThe array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].\nReturn the array result.\n\u00a0\nExample 1:\n\nInput: nums = [2,1,3]\nOutput: [2,3,1]\nExplanation: After the first 2 operations, arr1 = [2] and arr2 = [1].\nIn the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (2 > 1), append nums[3] to arr1.\nAfter 3 operations, arr1 = [2,3] and arr2 = [1].\nHence, the array result formed by concatenation is [2,3,1].\n\nExample 2:\n\nInput: nums = [5,4,3,8]\nOutput: [5,3,4,8]\nExplanation: After the first 2 operations, arr1 = [5] and arr2 = [4].\nIn the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (5 > 4), append nums[3] to arr1, hence arr1 becomes [5,3].\nIn the 4th operation, as the last element of arr2 is greater than the last element of arr1 (4 > 3), append nums[4] to arr2, hence arr2 becomes [4,8].\nAfter 4 operations, arr1 = [5,3] and arr2 = [4,8].\nHence, the array result formed by concatenation is [5,3,4,8].\n\n\u00a0\nConstraints:\n\n3 <= n <= 50\n1 <= nums[i] <= 100\nAll elements in nums are distinct. Explanation:\n\nSolution 1: Simulation\nWe create two arrays arr1 and arr2, which store the elements in nums. Initially, arr1 only contains nums[0], and arr2 only contains nums[1].\nThen we traverse the elements of nums starting from index 2. If the last element of arr1 is greater than the last element of arr2, we append the current element to arr1, otherwise we append it to arr2.\nFinally, we append the elements in arr2 to arr1 and return arr1.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array nums. \n\n", "problem_ids": ["distribute-elements-into-two-arrays-i"]}, "3235": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven an array of integers nums\u00a0and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n\u00a0\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n\n\u00a0\nFollow-up:\u00a0Can you come up with an algorithm that is less than O(n2)\u00a0time complexity? Explanation:\n\nSolution 1: Hash Table\nWe can use a hash table $\\textit{d}$ to store each element and its corresponding index.\nTraverse the array $\\textit{nums}$, for the current element $\\textit{nums}[i]$, we first check if $\\textit{target} - \\textit{nums}[i]$ is in the hash table $\\textit{d}$. If it is in $\\textit{d}$, it means the $\\textit{target}$ value has been found, and we return the indices of $\\textit{target} - \\textit{nums}[i]$ and $i$.\nTime complexity is $O(n)$, and space complexity is $O(n)$, where $n$ is the length of the array $\\textit{nums}$. \n\n", "problem_ids": ["two-sum"]}, "3236": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string road, consisting only of characters \"x\" and \".\", where each \"x\" denotes a pothole and each \".\" denotes a smooth road, and an integer budget.\nIn one repair operation, you can repair n consecutive potholes for a price of n + 1.\nReturn the maximum number of potholes that can be fixed such that the sum of the prices of all of the fixes doesn't go over the given budget.\n\u00a0\nExample 1:\n\nInput: road = \"..\", budget = 5\nOutput: 0\nExplanation:\nThere are no potholes to be fixed.\n\nExample 2:\n\nInput: road = \"..xxxxx\", budget = 4\nOutput: 3\nExplanation:\nWe fix the first three potholes (they are consecutive). The budget needed for this task is 3 + 1 = 4.\n\nExample 3:\n\nInput: road = \"x.x.xxx...x\", budget = 14\nOutput: 6\nExplanation:\nWe can fix all the potholes. The total cost would be (1 + 1) + (1 + 1) + (3 + 1) + (1 + 1) = 10 which is within our budget of 14.\n\n\u00a0\nConstraints:\n\n1 <= road.length <= 105\n1 <= budget <= 105 + 1\nroad consists only of characters '.' and 'x'. Explanation:\n\nSolution 1: Counting + Greedy\nFirst, we count the number of each continuous pothole, recorded in the array $cnt$, i.e., $cnt[k]$ represents there are $cnt[k]$ continuous potholes of length $k$.\nSince we want to repair as many potholes as possible, and for a continuous pothole of length $k$, we need to spend a cost of $k + 1$, we should prioritize repairing longer potholes to minimize the cost.\nTherefore, we start repairing from the longest pothole. For a pothole of length $k$, the maximum number we can repair is $t = \\min(\\textit{budget} / (k + 1), \\textit{cnt}[k])$. We add the number of repairs multiplied by the length $k$ to the answer, then update the remaining budget. For the remaining $cnt[k] - t$ potholes of length $k$, we merge them into the potholes of length $k - 1$. Continue this process until all potholes are traversed.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string $road$. \n\n", "problem_ids": ["maximum-number-of-potholes-that-can-be-fixed"]}, "3239": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given 3 positive integers zero, one, and limit.\nA binary array arr is called stable if:\n\nThe number of occurrences of 0 in arr is exactly zero.\nThe number of occurrences of 1 in arr is exactly one.\nEach subarray of arr with a size greater than limit must contain both 0 and 1.\n\nReturn the total number of stable binary arrays.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\nInput: zero = 1, one = 1, limit = 2\nOutput: 2\nExplanation:\nThe two possible stable binary arrays are [1,0] and [0,1], as both arrays have a single 0 and a single 1, and no subarray has a length greater than 2.\n\nExample 2:\n\nInput: zero = 1, one = 2, limit = 1\nOutput: 1\nExplanation:\nThe only possible stable binary array is [1,0,1].\nNote that the binary arrays [1,1,0] and [0,1,1] have subarrays of length 2 with identical elements, hence, they are not stable.\n\nExample 3:\n\nInput: zero = 3, one = 3, limit = 2\nOutput: 14\nExplanation:\nAll the possible stable binary arrays are [0,0,1,0,1,1], [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0], [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0], [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and [1,1,0,1,0,0].\n\n\u00a0\nConstraints:\n\n1 <= zero, one, limit <= 200 Explanation:\n\nSolution 1: Memoization Search\nWe design a function $dfs(i, j, k)$ to represent the number of stable binary arrays that satisfy the problem conditions when there are $i$ $0$s and $j$ $1$s left, and the next number to be filled is $k$. The answer is $dfs(zero, one, 0) + dfs(zero, one, 1)$.\nThe calculation process of the function $dfs(i, j, k)$ is as follows:\n\nIf $i < 0$ or $j < 0$, return $0$.\nIf $i = 0$, return $1$ when $k = 1$ and $j \\leq \\textit{limit}$, otherwise return $0$.\nIf $j = 0$, return $1$ when $k = 0$ and $i \\leq \\textit{limit}$, otherwise return $0$.\nIf $k = 0$, we consider the case where the previous number is $0$, $dfs(i - 1, j, 0)$, and the case where the previous number is $1$, $dfs(i - 1, j, 1)$. If the previous number is $0$, it may cause more than $\\textit{limit}$ $0$s in the subarray, i.e., the situation where the $\\textit{limit} + 1$ \n\n", "problem_ids": ["find-all-possible-stable-binary-arrays-i"]}, "3240": {"text": "Similar Problem 1 \n\n Problem:\n\nA string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.\nFor example, a string such as \"substitution\" could be abbreviated as (but not limited to):\n\n\"s10n\" (\"s ubstitutio n\")\n\"sub4u4\" (\"sub stit u tion\")\n\"12\" (\"substitution\")\n\"su3i1u2on\" (\"su bst i t u ti on\")\n\"substitution\" (no substrings replaced)\n\nThe following are not valid abbreviations:\n\n\"s55n\" (\"s ubsti tutio n\", the replaced substrings are adjacent)\n\"s010n\" (has leading zeros)\n\"s0ubstitution\" (replaces an empty substring)\n\nGiven a string word and an abbreviation abbr, return whether the string matches the given abbreviation.\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nExample 1:\n\nInput: word = \"internationalization\", abbr = \"i12iz4n\"\nOutput: true\nExplanation: The word \"internationalization\" can be abbreviated as \"i12iz4n\" (\"i nternational iz atio n\").\n\nExample 2:\n\nInput: word = \"apple\", abbr = \"a2e\"\nOutput: false\nExplanation: The word \"apple\" cannot be abbreviated as \"a2e\".\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 20\nword consists of only lowercase English letters.\n1 <= abbr.length <= 10\nabbr consists of lowercase English letters and digits.\nAll the integers in abbr will fit in a 32-bit integer. Explanation:\n\nSolution 1: Simulation\nWe can directly simulate character matching and replacement.\nAssume the lengths of the string $word$ and the string $abbr$ are $m$ and $n$ respectively. We use two pointers $i$ and $j$ to point to the initial positions of the string $word$ and the string $abbr$ respectively, and use an integer variable $x$ to record the current matched number in $abbr$.\nLoop to match each character of the string $word$ and the string $abbr$:\nIf the character $abbr[j]$ pointed by the pointer $j$ is a number, if $abbr[j]$ is '0' and $x$ is $0$, it means that the number in $abbr$ has leading zeros, so it is not a valid abbreviation, return false; otherwise, update $x$ to $x \\times 10 + abbr[j] - '0'$.\nIf the character $abbr[j]$ pointed by the pointer $j$ is not a number, then we move the pointer $i$ forward by $x$ positions at this time, and then reset $x$ to $0$. If $i \\geq m$ or $word[i] \\neq abbr[j]$ at this time, it means that the two strings cannot match, return false; otherwise, move the pointer $i$ forward by $1$ position.\nThen we move the pointer $j$ forward by $1$ position, repeat the above process, until $i$ exceeds the length of the string $word$ or $j$ exceeds the length of the string $abbr$.\nFinally, if $i + x$ equals $m$ and $j$ equals $n$, it means that the string $word$ can be abbreviated as the string $abbr$, return true; otherwise return false.\nThe time complexity is $O(m + n)$, where $m$ and $n$ are the lengths of the string $word$ and the string $abbr$ respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["valid-word-abbreviation"]}, "3242": {"text": "Similar Problem 1 \n\n Problem:\n\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\u00a0\nExample 1:\n\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\u00a0\nConstraints:\n\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put. Explanation:\n\nSolution 1: Hash Table + Doubly Linked List\nWe can implement an LRU (Least Recently Used) cache using a \"hash table\" and a \"doubly linked list\".\n\nHash Table: Used to store the key and its corresponding node location.\nDoubly Linked List: Used to store node data, sorted by access time.\n\nWhen accessing a node, if the node exists, we delete it from its original position and reinsert it at the head of the list. This ensures that the node stored at the tail of the list is the least recently used node. When the number of nodes exceeds the maximum cache space, we eliminate the node at the tail of the list.\nWhen inserting a node, if the node exists, we delete it from its original position and reinsert it at the head of the list. If it does not exist, we first check if the cache is full. If it is full, we delete the node at the tail of the list and insert the new node at the head of the list.\nThe time complexity is $O(1)$, and the space complexity is $O(\\textit{capacity})$. \n\n", "problem_ids": ["lru-cache"]}, "3243": {"text": "Similar Problem 1 \n\n Problem:\n\nYou have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\nGiven n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 109 + 7.\n\u00a0\nExample 1:\n\n\nInput: n = 1\nOutput: 12\nExplanation: There are 12 possible way to paint the grid as shown.\n\nExample 2:\n\nInput: n = 5000\nOutput: 30228214\n\n\u00a0\nConstraints:\n\nn == grid.length\n1 <= n <= 5000 Explanation:\n\nSolution 1: Recursion\nWe classify all possible states for each row. According to the principle of symmetry, when a row only has $3$ elements, all legal states are classified as: $010$ type, $012$ type.\n\nWhen the state is $010$ type: The possible states for the next row are: $101$, $102$, $121$, $201$, $202$. These $5$ states can be summarized as $3$ $010$ types and $2$ $012$ types.\nWhen the state is $012$ type: The possible states for the next row are: $101$, $120$, $121$, $201$. These $4$ states can be summarized as $2$ $010$ types and $2$ $012$ types.\n\nIn summary, we can get: $newf0 = 3 \\times f0 + 2 \\times f1$, $newf1 = 2 \\times f0 + 2 \\times f1$.\nThe time complexity is $O(n)$, where $n$ is the number of rows in the grid. The space complexity is $O(1)$. \n\n", "problem_ids": ["number-of-ways-to-paint-n-\u00d7-3-grid"]}, "3244": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.\nReturn the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\n\nInput: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\nOutput: 2\nExplanation: There are two paths where the sum of the elements on the path is divisible by k.\nThe first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.\nThe second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.\n\nExample 2:\n\n\nInput: grid = [[0,0]], k = 5\nOutput: 1\nExplanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.\n\nExample 3:\n\n\nInput: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\nOutput: 10\nExplanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 5 * 104\n1 <= m * n <= 5 * 104\n0 <= grid[i][j] <= 100\n1 <= k <= 50 Explanation:\n\nSolution 1: Memoization Search\nWe design a function dfs(i, j, s) to represent the number of paths starting from (i, j) with an initial path sum modulo $k$ equal to $s$.\nFor each position $(i, j)$, we can choose to move right or down, so we have:\n$$\ndfs(i, j, s) = dfs(i + 1, j, (s + grid[i][j]) \\bmod k) + dfs(i, j + 1, (s + grid[i][j]) \\bmod k)\n$$\nThe answer is dfs(0, 0, 0). We can use memoization search.\nThe time complexity is $O(m \\times n \\times k)$, and the space complexity is $O(m \\times n \\times k)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, and $k$ is the given integer. \n\n", "problem_ids": ["paths-in-matrix-whose-sum-is-divisible-by-k"]}, "3245": {"text": "Similar Problem 1 \n\n Problem:\n\nThere are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\nRoads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.\nThis year, there will be a big event in the capital (city 0), and many people want to travel to this city.\nYour task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.\nIt's guaranteed that each city can reach city 0 after reorder.\n\u00a0\nExample 1:\n\n\nInput: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\nOutput: 3\nExplanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\nExample 2:\n\n\nInput: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\nOutput: 2\nExplanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\nExample 3:\n\nInput: n = 3, connections = [[1,0],[2,0]]\nOutput: 0\n\n\u00a0\nConstraints:\n\n2 <= n <= 5 * 104\nconnections.length == n - 1\nconnections[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi Explanation:\n\nSolution 1: DFS\nThe route map given in the problem has $n$ nodes and $n-1$ edges. If we ignore the direction of the edges, then these $n$ nodes form a tree. The problem requires us to change the direction of some edges so that each node can reach node $0$.\nWe might as well consider starting from node $0$ and reaching all other nodes. The direction is opposite to the problem description, which means that when we build the graph, for the directed edge $[a, b]$, we should regard it as the directed edge $[b, a]$. That is to say, if it is from $a$ to $b$, we need to change the direction once; if it is from $b$ to $a$, no direction change is needed.\nNext, we only need to start from node $0$, search all other nodes, and during the process, if we encounter an edge that needs to change direction, we accumulate the number of direction changes once.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the problem. \n\n", "problem_ids": ["reorder-routes-to-make-all-paths-lead-to-the-city-zero"]}, "3246": {"text": "Similar Problem 1 \n\n Problem:\n\nThe complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.\n\u00a0\nExample 1:\n\nInput: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n\nExample 2:\n\nInput: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n\n\u00a0\nConstraints:\n\n1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/ Explanation:\n\nSolution 1: Bit Manipulation\nAccording to the problem description, we can use XOR operation to implement the flipping operation, the steps are as follows:\nFirst, we find the highest bit of $1$ in the binary representation of $\\textit{num}$, and the position is denoted as $k$.\nThen, we construct a binary number, where the $k$-th bit is $0$ and the rest of the lower bits are $1$, which is $2^k - 1$;\nFinally, we perform XOR operation on $\\textit{num}$ and the constructed binary number to get the answer.\nThe time complexity is $O(\\log \\textit{num})$, where $\\textit{num}$ is the input integer. The space complexity is $O(1)$. \n\n", "problem_ids": ["number-complement"]}, "3249": {"text": "Similar Problem 1 \n\n Problem:\n\nA decimal number can be converted to its Hexspeak representation by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit '0' with the letter 'O', and the digit '1' with the letter 'I'. Such a representation is valid if and only if it consists only of the letters in the set {'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}.\nGiven a string num representing a decimal integer n, return the Hexspeak representation of n if it is valid, otherwise return \"ERROR\".\n\u00a0\nExample 1:\n\nInput: num = \"257\"\nOutput: \"IOI\"\nExplanation: 257 is 101 in hexadecimal.\n\nExample 2:\n\nInput: num = \"3\"\nOutput: \"ERROR\"\n\n\u00a0\nConstraints:\n\n1 <= num.length <= 12\nnum does not contain leading zeros.\nnum represents an integer in the range [1, 1012]. Explanation:\n\nSolution 1: Simulation\nConvert the number to a hexadecimal string, then traverse the string, convert the number $0$ to the letter $O$, and the number $1$ to the letter $I$. Finally, check whether the converted string is valid.\nThe time complexity is $O(\\log n)$, where $n$ is the size of the decimal number represented by $num$. \n\n", "problem_ids": ["hexspeak"]}, "3251": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string s of lowercase English letters and an integer array shifts of the same length.\nCall the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').\n\nFor example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.\n\nNow for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.\nReturn the final string after all such shifts to s are applied.\n\u00a0\nExample 1:\n\nInput: s = \"abc\", shifts = [3,5,9]\nOutput: \"rpl\"\nExplanation: We start with \"abc\".\nAfter shifting the first 1 letters of s by 3, we have \"dbc\".\nAfter shifting the first 2 letters of s by 5, we have \"igc\".\nAfter shifting the first 3 letters of s by 9, we have \"rpl\", the answer.\n\nExample 2:\n\nInput: s = \"aaa\", shifts = [1,2,3]\nOutput: \"gfd\"\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists of lowercase English letters.\nshifts.length == s.length\n0 <= shifts[i] <= 109 Explanation:\n\nSolution 1: Suffix Sum\nFor each character in the string $s$, we need to calculate its final shift amount, which is the sum of $\\textit{shifts}[i]$, $\\textit{shifts}[i + 1]$, $\\textit{shifts}[i + 2]$, and so on. We can use the concept of suffix sum, traversing $\\textit{shifts}$ from back to front, calculating the final shift amount for each character, and then taking modulo $26$ to get the final character.\nThe time complexity is $O(n)$, where $n$ is the length of the string $s$. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["shifting-letters"]}, "3252": {"text": "Similar Problem 1 \n\n Problem:\n\nA magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\n\u00a0\nExample 1:\n\nInput: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= n <= 105 Explanation:\n\nSolution 1: Simulate the Construction Process\nAccording to the problem, we know that each group of numbers in the string $s$ can be obtained from the digits of the string $s$ itself.\nThe first two groups of numbers in string $s$ are $1$ and $22$, which are obtained from the first and second digits of string $s$, respectively. Moreover, the first group of numbers contains only $1$, the second group contains only $2$, the third group contains only $1$, and so on.\nSince the first two groups of numbers are known, we initialize string $s$ as $122$, and then start constructing from the third group. The third group of numbers is obtained from the third digit of string $s$ (index $i=2$), so at this point, we point the pointer $i$ to the third digit $2$ of string $s$.\n1 2 2\n    ^\n    i\nThe digit pointed by pointer $i$ is $2$, indicating that the third group of numbers will appear twice. Since the previous group of numbers is $2$, and the numbers alternate between groups, the third group of numbers is two $1$s, i.e., $11$. After construction, the pointer $i$ moves to the next position, pointing to the fourth digit $1$ of string $s$.\n1 2 2 1 1\n      ^\n      i\nAt this point, the digit pointed by pointer $i$ is $1$, indicating that the fourth group of numbers will appear once. Since the previous group of numbers is $1$, and the numbers alternate between groups, the fourth group of numbers is one $2$, i.e., $2$. After construction, the pointer $i$ moves to the next position, pointing to the fifth digit $1$ of string $s$.\n1 2 2 1 1 2\n        ^\n        i\nFollowing this rule, we simulate the construction process sequentially until the length of string $s$ is greater than or equal to $n$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. \n\n", "problem_ids": ["magical-string"]}, "3261": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven two positive integers a and b, return the number of common factors of a and b.\nAn integer x is a common factor of a and b if x divides both a and b.\n\u00a0\nExample 1:\n\nInput: a = 12, b = 6\nOutput: 4\nExplanation: The common factors of 12 and 6 are 1, 2, 3, 6.\n\nExample 2:\n\nInput: a = 25, b = 30\nOutput: 2\nExplanation: The common factors of 25 and 30 are 1, 5.\n\n\u00a0\nConstraints:\n\n1 <= a, b <= 1000 Explanation:\n\nSolution 1: Enumeration\nWe can first calculate the greatest common divisor $g$ of $a$ and $b$, then enumerate each number in $[1,..g]$, check whether it is a factor of $g$, if it is, then increment the answer by one.\nThe time complexity is $O(\\min(a, b))$, and the space complexity is $O(1)$. \n\n", "problem_ids": ["number-of-common-factors"]}, "3262": {"text": "Similar Problem 1 \n\n Problem:\n\nGiven a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\n\u00a0\nExample 1:\n\n\nInput: text = \"nlaebolko\"\nOutput: 1\n\nExample 2:\n\n\nInput: text = \"loonbalxballpoon\"\nOutput: 2\n\nExample 3:\n\nInput: text = \"leetcode\"\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= text.length <= 104\ntext consists of lower case English letters only. Explanation:\n\nSolution 1: Counting\nWe count the frequency of each letter in the string text, and then divide the frequency of the letters 'o' and 'l' by 2, because the word balloon contains the letters 'o' and 'l' twice.\nNext, we traverse each letter in the word balon, and find the minimum frequency of each letter in the string text. This minimum frequency is the maximum number of times the word balloon can appear in the string text.\nThe time complexity is $O(n)$, and the space complexity is $O(C)$. Here, $n$ is the length of the string text, and $C$ is the size of the character set. In this problem, $C = 26$. \n\n", "problem_ids": ["maximum-number-of-balloons"]}, "3263": {"text": "Similar Problem 1 \n\n Problem:\n\nYou have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code\u00a0of length of n\u00a0and a key k.\nTo decrypt the code, you must replace every number. All the numbers are replaced simultaneously.\n\nIf k > 0, replace the ith number with the sum of the next k numbers.\nIf k < 0, replace the ith number with the sum of the previous k numbers.\nIf k == 0, replace the ith number with 0.\n\nAs code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].\nGiven the circular array code and an integer key k, return the decrypted code to defuse the bomb!\n\u00a0\nExample 1:\n\nInput: code = [5,7,1,4], k = 3\nOutput: [12,10,16,13]\nExplanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.\n\nExample 2:\n\nInput: code = [1,2,3,4], k = 0\nOutput: [0,0,0,0]\nExplanation: When k is zero, the numbers are replaced by 0. \n\nExample 3:\n\nInput: code = [2,4,9,3], k = -2\nOutput: [12,5,6,13]\nExplanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.\n\n\u00a0\nConstraints:\n\nn == code.length\n1 <= n\u00a0<= 100\n1 <= code[i] <= 100\n-(n - 1) <= k <= n - 1 Explanation:\n\nSolution 1: Simulation\nWe define an answer array ans of length n, initially all elements are 0. According to the problem, if k is 0, return ans directly.\nOtherwise, we traverse each position i:\n\nIf k is a positive number, then the value at position i is the sum of the values at the k positions after position i, that is:\n\n$$\nans[i] = \\sum_{j=i+1}^{i+k} code[j \\bmod n]\n$$\n\nIf k is a negative number, then the value at position i is the sum of the values at the |k| positions before position i, that is:\n\n$$\nans[i] = \\sum_{j=i+k}^{i-1} code[(j+n) \\bmod n]\n$$\nThe time complexity is $O(n \\times |k|)$, ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["defuse-the-bomb"]}, "3265": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a string word. A letter\u00a0c is called special if it appears both in lowercase and uppercase in word, and every lowercase occurrence of c appears before the first uppercase occurrence of c.\nReturn the number of special letters in word.\n\u00a0\nExample 1:\n\nInput: word = \"aaAbcBC\"\nOutput: 3\nExplanation:\nThe special characters are 'a', 'b', and 'c'.\n\nExample 2:\n\nInput: word = \"abc\"\nOutput: 0\nExplanation:\nThere are no special characters in word.\n\nExample 3:\n\nInput: word = \"AbBCab\"\nOutput: 0\nExplanation:\nThere are no special characters in word.\n\n\u00a0\nConstraints:\n\n1 <= word.length <= 2 * 105\nword consists of only lowercase and uppercase English letters. Explanation:\n\nSolution 1: Hash Table or Array\nWe define two hash tables or arrays first and last to store the positions where each letter first appears and last appears respectively.\nThen we traverse the string word, updating first and last.\nFinally, we traverse all lowercase and uppercase letters. If last[a] exists and first[b] exists and last[a] < first[b], it means that the letter a is a special letter, and we increment the answer by one.\nThe time complexity is $O(n + |\\Sigma|)$, and the space complexity is $O(|\\Sigma|)$. Where $n$ is the length of the string word, and $|\\Sigma|$ is the size of the character set. In this problem, $|\\Sigma| \\leq 128$. \n\n", "problem_ids": ["count-the-number-of-special-characters-ii"]}, "3267": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\n\u00a0\nExample 1:\n\nInput: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\n\nExample 2:\n\nInput: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\n\nExample 3:\n\nInput: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)\n\n\u00a0\nConstraints:\n\n1 <= people.length <= 5 * 104\n1 <= people[i] <= limit <= 3 * 104 Explanation:\n\nSolution 1: Greedy + Two Pointers\nAfter sorting, use two pointers to point to the beginning and end of the array respectively. Each time, compare the sum of the elements pointed to by the two pointers with limit. If it is less than or equal to limit, then both pointers move one step towards the middle. Otherwise, only the right pointer moves. Accumulate the answer.\nThe time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of the array people. \n\n", "problem_ids": ["boats-to-save-people"]}, "3269": {"text": "Similar Problem 1 \n\n Problem:\n\nThe min-product of an array is equal to the minimum value in the array multiplied by the array's sum.\n\nFor example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20.\n\nGiven an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 109 + 7.\nNote that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.\nA subarray is a contiguous part of an array.\n\u00a0\nExample 1:\n\nInput: nums = [1,2,3,2]\nOutput: 14\nExplanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).\n2 * (2+3+2) = 2 * 7 = 14.\n\nExample 2:\n\nInput: nums = [2,3,3,1,2]\nOutput: 18\nExplanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).\n3 * (3+3) = 3 * 6 = 18.\n\nExample 3:\n\nInput: nums = [3,1,5,6,4,2]\nOutput: 60\nExplanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).\n4 * (5+6+4) = 4 * 15 = 60.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 107 Explanation:\n\nSolution 1: Monotonic Stack + Prefix Sum\nWe can enumerate each element $nums[i]$ as the minimum value of the subarray, and find the left and right boundaries $left[i]$ and $right[i]$ of the subarray. Where $left[i]$ represents the first position strictly less than $nums[i]$ on the left side of $i$, and $right[i]$ represents the first position less than or equal to $nums[i]$ on the right side of $i$.\nTo conveniently calculate the sum of the subarray, we can preprocess the prefix sum array $s$, where $s[i]$ represents the sum of the first $i$ elements of $nums$.\nThen the minimum product with $nums[i]$ as the minimum value of the subarray is $nums[i] \\times (s[right[i]] - s[left[i] + 1])$. We can enumerate each element $nums[i]$, find the minimum product with $nums[i]$ as the minimum value of the subarray, and then take the maximum value.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the array $nums$. \n\n", "problem_ids": ["maximum-subarray-min-product"]}, "3279": {"text": "Similar Problem 1 \n\n Problem:\n\nDesign a text editor with a cursor that can do the following:\n\nAdd text to where the cursor is.\nDelete text from where the cursor is (simulating the backspace key).\nMove the cursor either left or right.\n\nWhen deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.\nImplement the TextEditor class:\n\nTextEditor() Initializes the object with empty text.\nvoid addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.\nint deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.\nstring cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\nstring cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\n\n\u00a0\nExample 1:\n\nInput\n[\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"]\n[[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]]\nOutput\n[null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"]\n\nExplanation\nTextEditor textEditor = new TextEditor(); // The current text is \"|\". (The '|' character represents the cursor)\ntextEditor.addText(\"leetcode\"); // The current text is \"leetcode|\".\ntextEditor.deleteText(4); // return 4\n                          // The current text is \"leet|\". \n                          // 4 characters were deleted.\ntextEditor.addText(\"practice\"); // The current text is \"leetpractice|\". \ntextEditor.cursorRight(3); // return \"etpractice\"\n                           // The current text is \"leetpractice|\". \n                           // The cursor cannot be moved beyond the actual text and thus did not move.\n                           // \"etpractice\" is the last 10 characters to the left of the cursor.\ntextEditor.cursorLeft(8); // return \"leet\"\n                          // The current text is \"leet|practice\".\n                          // \"leet\" is the last min(10, 4) = 4 characters to the left of the cursor.\ntextEditor.deleteText(10); // return 4\n                           // The current text is \"|practice\".\n                           // Only 4 characters were deleted.\ntextEditor.cursorLeft(2); // return \"\"\n                          // The current text is \"|practice\".\n                          // The cursor cannot be moved beyond the actual text and thus did not move. \n                          // \"\" is the last min(10, 0) = 0 characters to the left of the cursor.\ntextEditor.cursorRight(6); // return \"practi\"\n                           // The current text is \"practi|ce\".\n                           // \"practi\" is the last min(10, 6) = 6 characters to the left of the cursor.\n\n\u00a0\nConstraints:\n\n1 <= text.length, k <= 40\ntext consists of lowercase English letters.\nAt most 2 * 104 calls in total will be made to addText, deleteText, cursorLeft and cursorRight.\n\n\u00a0\nFollow-up: Could you find a solution with time complexity of O(k) per call? Explanation:\n\nSolution 1: Left and Right Stacks\nWe can use two stacks, left and right, where the left stack stores the characters to the left of the cursor, and the right stack stores the characters to the right of the cursor.\n\nWhen the addText method is called, we push the characters from text onto the left stack one by one. The time complexity is $O(|\\textit{text}|)$.\nWhen the deleteText method is called, we pop characters from the left stack up to $k$ times. The time complexity is $O(k)$.\nWhen the cursorLeft method is called, we pop characters from the left stack up to $k$ times, then push the popped characters onto the right stack, and finally return up to $10$ characters from the left stack. The time complexity is $O(k)$.\nWhen the cursorRight method is called, we pop characters from the right stack up to $k$ times, then push the popped characters onto the left stack, and finally return up to $10$ characters from the left stack. The time complexity is $O(k)$. \n\n", "problem_ids": ["design-a-text-editor"]}, "3291": {"text": "Similar Problem 1 \n\n Problem:\n\nThere are n unique candies (labeled 1 through n) and k bags. You are asked to distribute all the candies into the bags such that every bag has at least one candy.\nThere can be multiple ways to distribute the candies. Two ways are considered different if the candies in one bag in the first way are not all in the same bag in the second way. The order of the bags and the order of the candies within each bag do not matter.\nFor example, (1), (2,3) and (2), (1,3) are considered different because candies 2 and 3 in the bag (2,3) in the first way are not in the same bag in the second way (they are split between the bags (2) and (1,3)). However, (1), (2,3) and (3,2), (1) are considered the same because the candies in each bag are all in the same bags in both ways.\nGiven two integers, n and k, return the number of different ways to distribute the candies. As the answer may be too large, return it modulo 109 + 7.\n\u00a0\nExample 1:\n\n\nInput: n = 3, k = 2\nOutput: 3\nExplanation: You can distribute 3 candies into 2 bags in 3 ways:\n(1), (2,3)\n(1,2), (3)\n(1,3), (2)\n\nExample 2:\n\nInput: n = 4, k = 2\nOutput: 7\nExplanation: You can distribute 4 candies into 2 bags in 7 ways:\n(1), (2,3,4)\n(1,2), (3,4)\n(1,3), (2,4)\n(1,4), (2,3)\n(1,2,3), (4)\n(1,2,4), (3)\n(1,3,4), (2)\n\nExample 3:\n\nInput: n = 20, k = 5\nOutput: 206085257\nExplanation: You can distribute 20 candies into 5 bags in 1881780996 ways. 1881780996 modulo 109 + 7 = 206085257.\n\n\u00a0\nConstraints:\n\n1 <= k <= n <= 1000 Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i][j]$ as the number of different ways to distribute $i$ candies to $j$ bags. Initially, $f[0][0]=1$, and the answer is $f[n][k]$.\nWe consider how to distribute the $i$-th candy. If the $i$-th candy is distributed to a new bag, then $f[i][j]=f[i-1][j-1]$. If the $i$-th candy is distributed to an existing bag, then $f[i][j]=f[i-1][j]\\times j$. Therefore, the state transition equation is:\n$$\nf[i][j]=f[i-1][j-1]+f[i-1][j]\\times j\n$$\nThe final answer is $f[n][k]$.\nThe time complexity is $O(n \\times k)$, and the space complexity is $O(n \\times k)$. Here, $n$ and $k$ are the number of candies and bags, respectively. \n\n", "problem_ids": ["count-ways-to-distribute-candies"]}, "3292": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\npref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\nIt can be proven that the answer is unique.\n\u00a0\nExample 1:\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\nExample 2:\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\u00a0\nConstraints:\n\n1 <= pref.length <= 105\n0 <= pref[i] <= 106 Explanation:\n\nSolution 1: Bit Manipulation\nAccording to the problem statement, we have equation one:\n$$\npref[i]=arr[0] \\oplus arr[1] \\oplus \\cdots \\oplus arr[i]\n$$\nSo, we also have equation two:\n$$\npref[i-1]=arr[0] \\oplus arr[1] \\oplus \\cdots \\oplus arr[i-1]\n$$\nWe perform a bitwise XOR operation on equations one and two, and get:\n$$\npref[i] \\oplus pref[i-1]=arr[i]\n$$\nThat is, each item in the answer array is obtained by performing a bitwise XOR operation on the adjacent two items in the prefix XOR array.\nThe time complexity is $O(n)$, where $n$ is the length of the prefix XOR array. Ignoring the space consumption of the answer, the space complexity is $O(1)$. \n\n", "problem_ids": ["find-the-original-array-of-prefix-xor"]}, "3297": {"text": "Similar Problem 1 \n\n Problem:\n\nThe Tribonacci sequence Tn is defined as follows:\u00a0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.\n\u00a0\nExample 1:\n\n\nInput: n = 4\n\nOutput: 4\n\nExplanation:\n\nT_3 = 0 + 1 + 1 = 2\n\nT_4 = 1 + 1 + 2 = 4\n\n\nExample 2:\n\n\nInput: n = 25\n\nOutput: 1389537\n\n\n\u00a0\nConstraints:\n\n0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1. Explanation:\n\nSolution 1: Dynamic Programming\nAccording to the recurrence relation given in the problem, we can use dynamic programming to solve it.\nWe define three variables $a$, $b$, $c$ to represent $T_{n-3}$, $T_{n-2}$, $T_{n-1}$, respectively, with initial values of $0$, $1$, $1$.\nThen we decrease $n$ to $0$, updating the values of $a$, $b$, $c$ each time, until $n$ is $0$, at which point the answer is $a$.\nThe time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the given integer. \n\n", "problem_ids": ["n-th-tribonacci-number"]}, "3298": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two 2D integer arrays nums1 and nums2.\n\nnums1[i] = [idi, vali]\u00a0indicate that the number with the id idi has a value equal to vali.\nnums2[i] = [idi, vali]\u00a0indicate that the number with the id idi has a value equal to vali.\n\nEach array contains unique ids and is sorted in ascending order by id.\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\n\nOnly ids that appear in at least one of the two arrays should be included in the resulting array.\nEach id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.\n\nReturn the resulting array. The returned array must be sorted in ascending order by id.\n\u00a0\nExample 1:\n\nInput: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\nOutput: [[1,6],[2,3],[3,2],[4,6]]\nExplanation: The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.\n\nExample 2:\n\nInput: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\nOutput: [[1,3],[2,4],[3,6],[4,3],[5,5]]\nExplanation: There are no common ids, so we just include each id with its value in the resulting list.\n\n\u00a0\nConstraints:\n\n1 <= nums1.length, nums2.length <= 200\nnums1[i].length == nums2[j].length == 2\n1 <= idi, vali <= 1000\nBoth arrays contain unique ids.\nBoth arrays are in\u00a0strictly ascending order by id. Explanation:\n\nSolution 1: Counting + Enumeration\nWe can use a hash table or an array cnt to count the frequency of each number in the two arrays.\nThen we enumerate each number in cnt from small to large. If the frequency of a number is greater than $0$, we add it to the answer array.\nThe time complexity is $O(n + m)$, and the space complexity is $O(M)$. Where $n$ and $m$ are the lengths of the two arrays respectively; and $M$ is the maximum value in the two arrays, in this problem, $M = 1000$. \n\n", "problem_ids": ["merge-two-2d-arrays-by-summing-values"]}, "3299": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a\u00a00-indexed\u00a0integer array\u00a0nums\u00a0containing\u00a0n\u00a0distinct positive integers. A permutation of\u00a0nums\u00a0is called special if:\n\nFor all indexes\u00a00 <= i < n - 1, either\u00a0nums[i] % nums[i+1] == 0\u00a0or\u00a0nums[i+1] % nums[i] == 0.\n\nReturn\u00a0the total number of special permutations.\u00a0As the answer could be large, return it\u00a0modulo\u00a0109\u00a0+ 7.\n\u00a0\nExample 1:\n\nInput: nums = [2,3,6]\nOutput: 2\nExplanation: [3,6,2] and [2,6,3] are the two special permutations of nums.\n\nExample 2:\n\nInput: nums = [1,4,3]\nOutput: 2\nExplanation: [3,1,4] and [4,1,3] are the two special permutations of nums.\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 14\n1 <= nums[i] <= 109 Explanation:\n\nSolution 1: State Compression Dynamic Programming\nWe notice that the maximum length of the array in the problem does not exceed $14$. Therefore, we can use an integer to represent the current state, where the $i$-th bit is $1$ if the $i$-th number in the array has been selected, and $0$ if it has not been selected.\nWe define $f[i][j]$ as the number of schemes where the current selected integer state is $i$, and the index of the last selected integer is $j$. Initially, $f[0][0]=0$, and the answer is $\\sum_{j=0}^{n-1}f[2^n-1][j]$.\nConsidering $f[i][j]$, if only one number is currently selected, then $f[i][j]=1$. Otherwise, we can enumerate the index $k$ of the last selected number. If the numbers corresponding to $k$ and $j$ meet the requirements of the problem, then $f[i][j]$ can be transferred from $f[i \\oplus 2^j][k]$. That is:\n$$\nf[i][j]=\n\\begin{cases}\n1, & i=2^j\\\n\\sum_{k=0}^{n-1}f[i \\oplus 2^j][k], & i \\neq 2^j \\textit{ and nums}[j] \\textit{ and nums}[k] \\textit{ meet the requirements of the problem}\\\n\\end{cases}\n$$\nThe final answer is $\\sum_{j=0}^{n-1}f[2^n-1][j]$. Note that the answer may be very large, so we need to take the modulus of $10^9+7$.\nThe time complexity is $O(n^2 \\times 2^n)$, and the space complexity is $O(n \\times 2^n)$. Here, $n$ is the length of the array. \n\n", "problem_ids": ["special-permutations"]}, "3308": {"text": "Similar Problem 1 \n\n Problem:\n\nOn a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\nA stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\nGiven an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\n\u00a0\nExample 1:\n\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\nOutput: 5\nExplanation: One way to remove 5 stones is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,1].\n2. Remove stone [2,1] because it shares the same column as [0,1].\n3. Remove stone [1,2] because it shares the same row as [1,0].\n4. Remove stone [1,0] because it shares the same column as [0,0].\n5. Remove stone [0,1] because it shares the same row as [0,0].\nStone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.\n\nExample 2:\n\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\nOutput: 3\nExplanation: One way to make 3 moves is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,0].\n2. Remove stone [2,0] because it shares the same column as [0,0].\n3. Remove stone [0,2] because it shares the same row as [0,0].\nStones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.\n\nExample 3:\n\nInput: stones = [[0,0]]\nOutput: 0\nExplanation: [0,0] is the only stone on the plane, so you cannot remove it.\n\n\u00a0\nConstraints:\n\n1 <= stones.length <= 1000\n0 <= xi, yi <= 104\nNo two stones are at the same coordinate point. Explanation:\n\nSolution 1: Union-Find\nWe can use a union-find data structure to maintain the relationships between stones. If two stones are in the same row or column, we consider them to be connected and use the union-find to link them together. In the end, we count how many connected components there are in the union-find, which corresponds to the number of stones that can remain. Therefore, the total number of stones that can be removed is the total number of stones minus the number of stones that can remain. We can also record the number of successful unions during the merge process, which equals the number of stones that can be removed.\nThe time complexity is $O(n^2 \\times \\alpha(n))$, and the space complexity is $O(n)$. Here, $n$ is the number of stones. \n\n", "problem_ids": ["most-stones-removed-with-same-row-or-column"]}, "3309": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads, where roads[i] = [ai, bi, costi] indicates that there is a bidirectional road between cities ai and bi with a cost of traveling equal to costi.\nYou can buy apples in any city you want, but some cities have different costs to buy apples. You are given the 1-based array appleCost where appleCost[i] is the cost of buying one apple from city i.\nYou start at some city, traverse through various roads, and eventually buy exactly one apple from any city. After you buy that apple, you have to return back to the city you started at, but now the cost of all the roads will be multiplied by a given factor k.\nGiven the integer k, return a 1-based array answer of size n where answer[i] is the minimum total cost to buy an apple if you start at city i.\n\u00a0\nExample 1:\n\n\nInput: n = 4, roads = [[1,2,4],[2,3,2],[2,4,5],[3,4,1],[1,3,4]], appleCost = [56,42,102,301], k = 2\nOutput: [54,42,48,51]\nExplanation: The minimum cost for each starting city is the following:\n- Starting at city 1: You take the path 1 -> 2, buy an apple at city 2, and finally take the path 2 -> 1. The total cost is 4 + 42 + 4 * 2 = 54.\n- Starting at city 2: You directly buy an apple at city 2. The total cost is 42.\n- Starting at city 3: You take the path 3 -> 2, buy an apple at city 2, and finally take the path 2 -> 3. The total cost is 2 + 42 + 2 * 2 = 48.\n- Starting at city 4: You take the path 4 -> 3 -> 2 then you buy at city 2, and finally take the path 2 -> 3 -> 4. The total cost is 1 + 2 + 42 + 1 * 2 + 2 * 2 = 51.\n\nExample 2:\n\n\nInput: n = 3, roads = [[1,2,5],[2,3,1],[3,1,2]], appleCost = [2,3,1], k = 3\nOutput: [2,3,1]\nExplanation: It is always optimal to buy the apple in the starting city.\n\n\u00a0\nConstraints:\n\n2 <= n <= 1000\n1 <= roads.length <= 2000\n1 <= ai, bi <= n\nai != bi\n1 <= costi <= 105\nappleCost.length == n\n1 <= appleCost[i] <= 105\n1 <= k <= 100\nThere are no repeated edges. Explanation:\n\nSolution 1: Heap-optimized Dijkstra's Algorithm\nWe enumerate the starting point, and for each starting point, we use Dijkstra's algorithm to find the shortest distance to all other points, and update the minimum value accordingly.\nThe time complexity is $O(n \\times m \\times \\log m)$, where $n$ and $m$ are the number of cities and roads, respectively. \n\n", "problem_ids": ["minimum-cost-to-buy-apples"]}, "3311": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are painting a fence of n posts with k different colors. You must paint the posts following these rules:\n\nEvery post must be painted exactly one color.\nThere cannot be three or more consecutive posts with the same color.\n\nGiven the two integers n and k, return the number of ways you can paint the fence.\n\u00a0\nExample 1:\n\n\nInput: n = 3, k = 2\nOutput: 6\nExplanation: All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n\nExample 2:\n\nInput: n = 1, k = 1\nOutput: 1\n\nExample 3:\n\nInput: n = 7, k = 2\nOutput: 42\n\n\u00a0\nConstraints:\n\n1 <= n <= 50\n1 <= k <= 105\nThe testcases are generated such that the answer is in the range [0, 231 - 1] for the given n and k. Explanation:\n\nSolution 1: Dynamic Programming\nWe define $f[i]$ to represent the number of ways to paint the fence posts from $[0..i]$ such that the last two posts have different colors, and $g[i]$ to represent the number of ways to paint the fence posts from $[0..i]$ such that the last two posts have the same color. Initially, $f[0] = k$ and $g[0] = 0$.\nWhen $i > 0$, we have the following state transition equations:\n$$\n\\begin{aligned}\nf[i] & = (f[i - 1] + g[i - 1]) \\times (k - 1) \\\ng[i] & = f[i - 1]\n\\end{aligned}\n$$\nThe final answer is $f[n - 1] + g[n - 1]$.\nThe time complexity is $O(n)$ and the space complexity is $O(n)$, where $n$ is the number of fence posts. \n\n", "problem_ids": ["paint-fence"]}, "3312": {"text": "Similar Problem 1 \n\n Problem:\n\nAlice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\nThe doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\nGiven the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.\n\u00a0\nExample 1:\n\nInput: candyType = [1,1,2,2,3,3]\nOutput: 3\nExplanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n\nExample 2:\n\nInput: candyType = [1,1,2,3]\nOutput: 2\nExplanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.\n\nExample 3:\n\nInput: candyType = [6,6,6,6]\nOutput: 1\nExplanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.\n\n\u00a0\nConstraints:\n\nn == candyType.length\n2 <= n <= 104\nn\u00a0is even.\n-105 <= candyType[i] <= 105 Explanation:\n\nSolution 1: Hash Table\nWe use a hash table to store the types of candies. If the number of candy types is less than $n / 2$, then the maximum number of candy types that Alice can eat is the number of candy types. Otherwise, the maximum number of candy types that Alice can eat is $n / 2$.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of candies. \n\n", "problem_ids": ["distribute-candies"]}, "3317": {"text": "Similar Problem 1 \n\n Problem:\n\nYou have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\nYou are given an integer array nums representing the data status of this set after the error.\nFind the number that occurs twice and the number that is missing and return them in the form of an array.\n\u00a0\nExample 1:\nInput: nums = [1,2,2,4]\nOutput: [2,3]\n\nExample 2:\nInput: nums = [1,1]\nOutput: [1,2]\n\n\u00a0\nConstraints:\n\n2 <= nums.length <= 104\n1 <= nums[i] <= 104 Explanation:\n\nSolution 1: Mathematics\nWe denote $s_1$ as the sum of all numbers from $[1,..n]$, $s_2$ as the sum of the numbers in the array $nums$ after removing duplicates, and $s$ as the sum of the numbers in the array $nums$.\nThen $s - s_2$ is the duplicate number, and $s_1 - s_2$ is the missing number.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the array $nums$. Extra space is needed to store the array after de-duplication. \n\n", "problem_ids": ["set-mismatch"]}, "3320": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given an integer array ribbons, where ribbons[i] represents the length of the ith ribbon, and an integer k. You may cut any of the ribbons into any number of segments of positive integer lengths, or perform no cuts at all.\n\nFor example, if you have a ribbon of length 4, you can:\n\n    \nKeep the ribbon of length 4,\nCut it into one ribbon of length 3 and one ribbon of length 1,\nCut it into two ribbons of length 2,\nCut it into one ribbon of length 2 and two ribbons of length 1, or\nCut it into four ribbons of length 1.\n\n\n\nYour goal is to obtain k ribbons of all the same positive integer length. You are allowed to throw away any excess ribbon as a result of cutting.\nReturn the maximum possible positive integer length that you can obtain k ribbons of, or 0 if you cannot obtain k ribbons of the same length.\n\u00a0\nExample 1:\n\nInput: ribbons = [9,7,5], k = 3\nOutput: 5\nExplanation:\n- Cut the first ribbon to two ribbons, one of length 5 and one of length 4.\n- Cut the second ribbon to two ribbons, one of length 5 and one of length 2.\n- Keep the third ribbon as it is.\nNow you have 3 ribbons of length 5.\nExample 2:\n\nInput: ribbons = [7,5,9], k = 4\nOutput: 4\nExplanation:\n- Cut the first ribbon to two ribbons, one of length 4 and one of length 3.\n- Cut the second ribbon to two ribbons, one of length 4 and one of length 1.\n- Cut the third ribbon to three ribbons, two of length 4 and one of length 1.\nNow you have 4 ribbons of length 4.\n\nExample 3:\n\nInput: ribbons = [5,7,9], k = 22\nOutput: 0\nExplanation: You cannot obtain k ribbons of the same positive integer length.\n\n\u00a0\nConstraints:\n\n1 <= ribbons.length <= 105\n1 <= ribbons[i] <= 105\n1 <= k <= 109 Explanation:\n\nSolution 1: Binary Search\nWe observe that if we can obtain $k$ ropes of length $x$, then we can also obtain $k$ ropes of length $x-1$. This implies that there is a monotonicity property, and we can use binary search to find the maximum length $x$ such that we can obtain $k$ ropes of length $x$.\nWe define the left boundary of the binary search as $left=0$, the right boundary as $right=\\max(ribbons)$, and the middle value as $mid=(left+right+1)/2$. We then calculate the number of ropes we can obtain with length $mid$, denoted as $cnt$. If $cnt \\geq k$, it means we can obtain $k$ ropes of length $mid$, so we update $left$ to $mid$. Otherwise, we update $right$ to $mid-1$.\nFinally, we return $left$ as the maximum length of the ropes we can obtain.\nThe time complexity is $O(n \\times \\log M)$, where $n$ and $M$ are the number of ropes and the maximum length of the ropes, respectively. The space complexity is $O(1)$. \n\n", "problem_ids": ["cutting-ribbons"]}, "3324": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given a 0-indexed m x n binary matrix grid.\nLet us call a non-empty subset of rows good if the sum of each column of the subset is at most half of the length of the subset.\nMore formally, if the length of the chosen subset of rows is k, then the sum of each column should be at most floor(k / 2).\nReturn an integer array that contains row indices of a good subset sorted in ascending order.\nIf there are multiple good subsets, you can return any of them. If there are no good subsets, return an empty array.\nA subset of rows of the matrix grid is any matrix that can be obtained by deleting some (possibly none or all) rows from grid.\n\u00a0\nExample 1:\n\nInput: grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]\nOutput: [0,1]\nExplanation: We can choose the 0th and 1st rows to create a good subset of rows.\nThe length of the chosen subset is 2.\n- The sum of the 0th\u00a0column is 0 + 0 = 0, which is at most half of the length of the subset.\n- The sum of the 1st\u00a0column is 1 + 0 = 1, which is at most half of the length of the subset.\n- The sum of the 2nd\u00a0column is 1 + 0 = 1, which is at most half of the length of the subset.\n- The sum of the 3rd\u00a0column is 0 + 1 = 1, which is at most half of the length of the subset.\n\nExample 2:\n\nInput: grid = [[0]]\nOutput: [0]\nExplanation: We can choose the 0th row to create a good subset of rows.\nThe length of the chosen subset is 1.\n- The sum of the 0th\u00a0column is 0, which is at most half of the length of the subset.\n\nExample 3:\n\nInput: grid = [[1,1,1],[1,1,1]]\nOutput: []\nExplanation: It is impossible to choose any subset of rows to create a good subset.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m <= 104\n1 <= n <= 5\ngrid[i][j] is either 0 or 1. Explanation:\n\nSolution 1: Case Analysis\nWe can consider the number of rows $k$ chosen for the answer from smallest to largest.\n\nIf $k = 1$, the maximum sum of each column is $0$. Therefore, there must be a row where all elements are $0$, otherwise, the condition cannot be met.\nIf $k = 2$, the maximum sum of each column is $1$. There must exist two rows, and the bitwise AND result of these two rows' elements is $0$, otherwise, the condition cannot be met.\nIf $k = 3$, the maximum sum of each column is also $1$. If the condition for $k = 2$ is not met, then the condition for $k = 3$ will definitely not be met either. Therefore, we do not need to consider any case where $k > 2$ and $k$ is odd.\nIf $k = 4$, the maximum sum of each column is $2$. This situation definitely occurs when the condition for $k = 2$ is not met, meaning that for any two selected rows, there exists at least one column with a sum of $2$. When choosing any 2 rows out of 4, there are a total of $C_4^2 = 6$ ways to choose, so there are at least $6$ columns with a sum of $2$. Since the number of columns $n \\le 5$, there must be at least one column with a sum greater than $2$, so the condition for $k = 4$ is also not met.\nFor $k > 4$ and $k$ being even, we can draw the same conclusion, that $k$ definitely does not meet the condition.\n\nIn summary, we only need to consider the cases of $k = 1$ and $k = 2$. That is, to check whether there is a row entirely composed of $0$s, or whether there exist two rows whose bitwise AND result is $0$.\nThe time complexity is $O(m \\times n + 4^n)$, and the space complexity is $O(2^n)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, respectively. \n\n", "problem_ids": ["find-a-good-subset-of-the-matrix"]}, "3329": {"text": "Similar Problem 1 \n\n Problem:\n\nA dieter consumes\u00a0calories[i]\u00a0calories on the i-th day.\u00a0\nGiven an integer k, for every consecutive sequence of k days (calories[i], calories[i+1], ..., calories[i+k-1]\u00a0for all 0 <= i <= n-k), they look at T, the total calories consumed during that sequence of k days (calories[i] + calories[i+1] + ... + calories[i+k-1]):\n\nIf T < lower, they performed poorly on their diet and lose 1 point;\u00a0\nIf T > upper, they performed well on their diet and gain 1 point;\nOtherwise, they performed normally and there is no change in points.\n\nInitially, the dieter has zero points. Return the total number of points the dieter has after dieting for calories.length\u00a0days.\nNote that the total points can be negative.\n\u00a0\nExample 1:\n\nInput: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3\nOutput: 0\nExplanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.\ncalories[0] and calories[1] are less than lower so 2 points are lost.\ncalories[3] and calories[4] are greater than upper so 2 points are gained.\n\nExample 2:\n\nInput: calories = [3,2], k = 2, lower = 0, upper = 1\nOutput: 1\nExplanation: Since k = 2, we consider subarrays of length 2.\ncalories[0] + calories[1] > upper so 1 point is gained.\n\nExample 3:\n\nInput: calories = [6,5,0,0], k = 2, lower = 1, upper = 5\nOutput: 0\nExplanation:\ncalories[0] + calories[1] > upper so 1 point is gained.\nlower <= calories[1] + calories[2] <= upper so no change in points.\ncalories[2] + calories[3] < lower so 1 point is lost.\n\n\u00a0\nConstraints:\n\n1 <= k <= calories.length <= 10^5\n0 <= calories[i] <= 20000\n0 <= lower <= upper Explanation:\n\nSolution 1: Prefix Sum\nFirst, we preprocess a prefix sum array $s$ of length $n+1$, where $s[i]$ represents the total calories of the first $i$ days.\nThen we traverse the prefix sum array $s$. For each position $i$, we calculate $s[i+k]-s[i]$, which is the total calories for the consecutive $k$ days starting from the $i$th day. According to the problem description, for each $s[i+k]-s[i]$, we judge its value with $lower$ and $upper$, and update the answer accordingly.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the calories array. \n\n", "problem_ids": ["diet-plan-performance"]}, "3331": {"text": "Similar Problem 1 \n\n Problem:\n\nYou are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].\nYou start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\n\u00a0\nExample 1:\n\nInput: source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\nOutput: 28\nExplanation: To convert the string \"abcd\" to string \"acbe\":\n- Change value at index 1 from 'b' to 'c' at a cost of 5.\n- Change value at index 2 from 'c' to 'e' at a cost of 1.\n- Change value at index 2 from 'e' to 'b' at a cost of 2.\n- Change value at index 3 from 'd' to 'e' at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28.\nIt can be shown that this is the minimum possible cost.\n\nExample 2:\n\nInput: source = \"aaaa\", target = \"bbbb\", original = [\"a\",\"c\"], changed = [\"c\",\"b\"], cost = [1,2]\nOutput: 12\nExplanation: To change the character 'a' to 'b' change the character 'a' to 'c' at a cost of 1, followed by changing the character 'c' to 'b' at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of 'a' to 'b', a total cost of 3 * 4 = 12 is incurred.\n\nExample 3:\n\nInput: source = \"abcd\", target = \"abce\", original = [\"a\"], changed = [\"e\"], cost = [10000]\nOutput: -1\nExplanation: It is impossible to convert source to target because the value at index 3 cannot be changed from 'd' to 'e'.\n\n\u00a0\nConstraints:\n\n1 <= source.length == target.length <= 105\nsource, target consist of lowercase English letters.\n1 <= cost.length == original.length == changed.length <= 2000\noriginal[i], changed[i] are lowercase English letters.\n1 <= cost[i] <= 106\noriginal[i] != changed[i] Explanation:\n\nSolution 1: Floyd Algorithm\nAccording to the problem description, we can consider each letter as a node, and the conversion cost between each pair of letters as a directed edge. We first initialize a $26 \\times 26$ two-dimensional array $g$, where $g[i][j]$ represents the minimum cost of converting letter $i$ to letter $j$. Initially, $g[i][j] = \\infty$, and if $i = j$, then $g[i][j] = 0$.\nNext, we traverse the arrays $original$, $changed$, and $cost$. For each index $i$, we update the cost $cost[i]$ of converting $original[i]$ to $changed[i]$ to $g[original[i]][changed[i]]$, taking the minimum value.\nThen, we use the Floyd algorithm to calculate the minimum cost between any two nodes in $g$. Finally, we traverse the strings $source$ and $target$. If $source[i] \\neq target[i]$ and $g[source[i]][target[i]] \\geq \\infty$, it means that the conversion cannot be completed, so we return $-1$. Otherwise, we add $g[source[i]][target[i]]$ to the answer.\nAfter the traversal ends, we return the answer.\nThe time complexity is $O(m + n + |\\Sigma|^3)$, and the space complexity is $O(|\\Sigma|^2)$. Where $m$ and $n$ are the lengths of the arrays $original$ and $source$ respectively; and $|\\Sigma|$ is the size of the alphabet, that is, $|\\Sigma| = 26$. \n\n", "problem_ids": ["minimum-cost-to-convert-string-i"]}, "3347": {"text": "Similar Problem 1 \n\n Problem:\n\nLet's define a function countUniqueChars(s) that returns the number of unique characters in\u00a0s.\n\nFor example, calling countUniqueChars(s) if s = \"LEETCODE\" then \"L\", \"T\", \"C\", \"O\", \"D\" are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5.\n\nGiven a string s, return the sum of countUniqueChars(t) where t is a substring of s. The test cases are generated such that the answer fits in a 32-bit integer.\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too.\n\u00a0\nExample 1:\n\nInput: s = \"ABC\"\nOutput: 10\nExplanation: All possible substrings are: \"A\",\"B\",\"C\",\"AB\",\"BC\" and \"ABC\".\nEvery substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n\nExample 2:\n\nInput: s = \"ABA\"\nOutput: 8\nExplanation: The same as example 1, except countUniqueChars(\"ABA\") = 1.\n\nExample 3:\n\nInput: s = \"LEETCODE\"\nOutput: 92\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 105\ns consists of uppercase English letters only. Explanation:\n\nSolution 1: Calculate the Contribution of Each Character\nFor each character $c_i$ in the string $s$, when it appears only once in a substring, it contributes to the count of unique characters in that substring.\nTherefore, we only need to calculate for each character $c_i$, how many substrings contain this character only once.\nWe use a hash table or an array $d$ of length $26$, to store the positions of each character in $s$ in order of index.\nFor each character $c_i$, we iterate through each position $p$ in $d[c_i]$, find the adjacent positions $l$ on the left and $r$ on the right, then the number of substrings that meet the requirements by expanding from position $p$ to both sides is $(p - l) \\times (r - p)$. We perform this operation for each character, add up the contributions of all characters, and get the answer.\nThe time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string $s$. \n\n", "problem_ids": ["count-unique-characters-of-all-substrings-of-a-given-string"]}, "abc301_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere are \\(N+2\\) cells arranged in a row. Let cell \\(i\\) denote the \\(i\\)-th cell from the left.\n\nThere is one stone placed in each of the cells from cell \\(1\\) to cell \\(N\\).\n\nFor each \\(1 \\leq i \\leq N\\), the stone in cell \\(i\\) is white if \\(S_i\\) is 'W', and black if \\(S_i\\) is 'B'.\n\nCells \\(N+1\\) and \\(N+2\\) are empty.\n\nYou can perform the following operation any number of times (possibly zero):\n\n- Choose a pair of adjacent cells that both contain stones, and move these two stones to the empty two cells while preserving their order.\n\n  More precisely, choose an integer \\(x\\) such that \\(1 \\leq x \\leq N+1\\) and both cells \\(x\\) and \\(x+1\\) contain stones. Let \\(k\\) and \\(k+1\\) be the empty two cells. Move the stones from cells \\(x\\) and \\(x+1\\) to cells \\(k\\) and \\(k+1\\), respectively.\n\nDetermine if it is possible to achieve the following state, and if so, find the minimum number of operations required:\n\n- Each of the cells from cell \\(1\\) to cell \\(N\\) contains one stone, and for each \\(1 \\leq i \\leq N\\), the stone in cell \\(i\\) is white if \\(T_i\\) is 'W', and black if \\(T_i\\) is 'B'.\n\n**Constraints:**\n- \\(2 \\leq N \\leq 14\\)\n- \\(N\\) is an integer.\n- Each of \\(S\\) and \\(T\\) is a string of length \\(N\\) consisting of 'B' and 'W'.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS\nT\n```\n\n**Output:**\n\nIf it is possible to achieve the desired state, print the minimum number of operations required. If it is impossible, print `-1`.\n\n**Sample Input 1:**\n```\n6\nBWBWBW\nWWWBBB\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n**Explanation:**\n\nUsing `.` to represent an empty cell, the desired state can be achieved in four operations as follows, which is the minimum:\n- `BWBWBW..`\n- `BW..BWBW`\n- `BWWBB..W`\n- `..WBBBWW`\n- `WWWBBB..`\n\n**Sample Input 2:**\n```\n6\nBBBBBB\nWWWWWW\n```\n\n**Sample Output 2:**\n```\n-1\n```\n\n**Sample Input 3:**\n```\n14\nBBBWBWWWBBWWBW\nWBWWBBWWWBWBBB\n```\n\n**Sample Output 3:**\n```\n7\n```\n\nSolution:\n\n[BEGIN TEXT]\nD - Go Stone Puzzle Editorial\n\nIf \\(S\\) and \\(T\\) have different numbers of W and B, then the answer is No. Assume they are equal. Let \\(W\\) be the number of W and \\(B\\) be the number of B. Since the empty squares are always adjacent, there are \\(\\frac{(N+1)!}{B!W!}=O(\\sqrt{N}2^N)\\) possible states of the cells. (The analysis is omitted here.) The maximum value \\(51480\\) occurs for \\(N=14\\) and \\(B=W=7\\). For each state, there are \\((N-1)\\) possible moves. Since the number of states and moves are small enough, use BFS to solve the problem. The total complexity is expected \\(O(N^{1.5}2^N)\\) using a hash map. Similar problem: 8 puzzle (AOJ).\n[END TEXT]\n \n\n", "problem_ids": ["abc361_d"]}, "abc301_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere is a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i,j)\\) denote the cell at the \\(i\\)-th row from the top and \\(j\\)-th column from the left. There are \\(N\\) coins on this grid, and the \\(i\\)-th coin can be picked up by passing through the cell \\((R_i,C_i)\\).\n\nYour goal is to start from cell \\((1,1)\\), repeatedly move either down or right by one cell, and reach cell \\((H,W)\\) while picking up as many coins as possible.\n\nFind the maximum number of coins you can pick up and one of the paths that achieves this maximum.\n\nConstraints:\n- \\(2 \\leq H, W \\leq 2 \\times 10^5\\)\n- \\(1 \\leq N \\leq \\min(HW-2, 2 \\times 10^5)\\)\n- \\(1 \\leq R_i \\leq H\\)\n- \\(1 \\leq C_i \\leq W\\)\n- \\((R_i, C_i) \\neq (1,1)\\)\n- \\((R_i, C_i) \\neq (H,W)\\)\n- \\((R_i, C_i)\\) are pairwise distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format: \n```\nH W N\nR_1 C_1\nR_2 C_2\n\u22ee\nR_N C_N\n```\n\nOutput:\nPrint two lines.\n- The first line should contain the maximum number of coins you can pick up.\n- The second line should contain one of the paths that achieves this maximum as a string of length \\(H+W-2\\). The \\(i\\)-th character of this string should be `D` if the \\(i\\)-th move is downward, and `R` if it is rightward.\n\nIf there are multiple paths that maximize the number of coins picked up, you may print any of them.\n\nSample Input 1:\n```\n3 4 4\n3 3\n2 1\n2 3\n1 4\n```\n\nSample Output 1:\n```\n3\nDRRDR\n```\nAs shown in the figure above, by moving \\((1,1)\\rightarrow (2,1)\\rightarrow (2,2)\\rightarrow (2,3)\\rightarrow (3,3)\\rightarrow (3,4)\\), you can pick up three coins at \\((2,1),(2,3),(3,3)\\).\n\nSample Input 2:\n```\n2 2 2\n2 1\n1 2\n```\n\nSample Output 2:\n```\n1\nDR\n```\nThe path `RD` is also acceptable.\n\nSample Input 3:\n```\n10 15 8\n2 7\n2 9\n7 9\n10 3\n7 11\n8 12\n9 6\n8 1\n```\n\nSample Output 3:\n```\n5\nDRRRRRRRRDDDDDRRDRDDRRR\n```\n\nSolution:\n\n```\nHere is the cleaned editorial without excess content unrelated to the solution:\n\n---\n\nLet us call the coin that can be collected by passing through square \\((r,c)\\) simply coin \\((r,c)\\). Given \\(k\\) coins \\((r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)\\), one can determine if there is a path that can collect all the coins as follows:\n\nSort the coins in ascending order of \\((r,c)\\). Here, \\((r_i, c_i) < (r_j, c_j) \\Leftrightarrow (r_i < r_j) \\lor (r_i = r_j \\land c_i < c_j)\\). Let \\(((r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k))\\) be the resulting sequence. There exists a path that can collect all the given \\(k\\) coins if and only if \\(c'_1 \\leq c'_2 \\leq \\dots \\leq c'_k\\).\n\nProof: If two coins $i$ and $j$ with $(r_i, c_i) < (r_j, c_j)$ are to be collected, coin $i$ has to be collected first. Thus, the $k$ coins $(r_1,c_1),(r_2,c_2),\\dots,(r_k,c_k)$ can be all collected if and only if the $k$ coins $(r'_1,c'_1),(r'_2,c'_2),\\dots,(r'_k,c'_k)$ can be collected **in this order**. Given $(r_i, c_i) < (r_j, c_j)$, we have $(r_i \\leq r_j \\land c_i \\leq c_j) \\Leftrightarrow c_i \\leq c_j$, so the claim above has been shown.\n\nSuppose that the given \\(N\\) coins are sorted in ascending order of \\((r,c)\\). Then, by the fact above, this problem is boiled down to finding a longest (weakly) increasing subsequence (LIS). Given positive integer sequence \\(c=(c_1,c_2,\\dots,c_N)\\), one can find the length of a LIS of \\(c\\) (not its length) by the following famous algorithm:\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\). The length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\).\n\nIntuitively, each \\(d_j\\) manages the smallest last element of a length-\\(j\\) (weakly) increasing subsequence of \\(c_1,c_2,\\dots,c_i\\) (or \\(\\infty\\) if there is no such subsequence). To find an example of LIS instead of its length only, let us modify the algorithm as follows.\n\nPrepare a length-\\(N\\) sequence \\(d\\) initialized with \\(\\infty\\). Prepare a length-\\(N\\) sequence \\(\\text{id}\\) and \\(\\text{pre}\\). Do the following for \\(i=1,2,\\dots,N\\).\n\nFor the minimum \\(j\\) with \\(d_j > c_i\\), replace \\(d_j\\) with \\(c_i\\), and replace \\(\\text{id}_j\\) with \\(i\\). If \\(j > 1\\), replace \\(\\text{pre}_i\\) with \\(\\text{id}_{j-1}\\) too.\n\nThe length of a LIS of \\(c\\) is the maximum \\(j\\) with \\(d_j < \\infty\\). Let \\(l\\) be the length of a LIS of \\(c\\). Consider a length-\\(l\\) sequence obtained by applying \\((l-1)\\) times the action \\(i\\mapsto \\text{pre}_i\\) to \\(\\text{id}_l\\), namely \\((\\text{id}_l, \\text{pre}_{\\text{id}_l},\\text{pre}_{\\text{pre}_{\\text{id}_l}},\\dots)\\). The reversal of this sequence is an example of a LIS of \\(c\\).\n\nThe fact that an example of LIS can be indeed obtained using this algorithm can be proved inductively. The complexity of this algorithm is \\(O(N\\log N)\\), same as the original algorithm. (To find the minimum \\(j\\) in step \\(3\\), use binary search.) Thus, the problem has been solved.\n\nSample code (Python3):\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    h, w, n = map(int, sys.stdin.readline().strip().split())\n    coins = []\n    for _ in range(n):\n        r, c = map(int, sys.stdin.readline().strip().split())\n        coins.append((r, c))\n    coins.sort()\n    dp = [float('inf')] * n\n    id_list = [-1] * n\n    pre = [0] * n\n    for i in range(n):\n        it = bisect_right(dp, coins[i][1])\n        dp[it] = coins[i][1]\n        id_list[it] = i\n        pre[i] = id_list[it - 1] if it else -1\n    m = n - 1\n    while id_list[m] == -1:\n        m -= 1\n    path = [(h, w)]\n    now = id_list[m]\n    while now != -1:\n        path.append(coins[now])\n        now = pre[now]\n    path.append((1, 1))\n    path.reverse()\n    s = []\n    for i in range(len(path) - 1):\n        d = path[i + 1][0] - path[i][0]\n        r = path[i + 1][1] - path[i][1]\n        s.append('D' * d + 'R' * r)\n    print(m + 1)\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc369_f"]}, "abc301_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\n", "problem_ids": ["abc355_g"]}, "abc301_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nFor positive integers \\( x \\) and \\( y \\), define \\( f(x, y) \\) as follows:\n- Interpret the decimal representations of \\( x \\) and \\( y \\) as strings and concatenate them in this order to obtain a string \\( z \\). The value of \\( f(x, y) \\) is the value of \\( z \\) when interpreted as a decimal integer.\n\nFor example, \\( f(3, 14) = 314 \\) and \\( f(100, 1) = 1001 \\).\n\nYou are given a sequence of positive integers \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression modulo \\( 998244353 \\):\n\n\\[\n\\sum_{i=1}^{N-1} \\sum_{j=i+1}^N f(A_i, A_j)\n\\]\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n3\n3 14 15\n```\n\n**Sample Output 1:**\n```\n2044\n```\n\n- \\( f(A_1, A_2) = 314 \\)\n- \\( f(A_1, A_3) = 315 \\)\n- \\( f(A_2, A_3) = 1415 \\)\n\nThus, the answer is \\( f(A_1, A_2) + f(A_1, A_3) + f(A_2, A_3) = 2044 \\).\n\n**Sample Input 2:**\n```\n5\n1001 5 1000000 1000000000 100000\n```\n\n**Sample Output 2:**\n```\n625549048\n```\n\nBe sure to calculate the value modulo \\( 998244353 \\).\n\nSolution:\n\n        Here is the cleaned version of the text, focusing solely on the solution content:\n\n---\n\nWe reinterpret \\(f(x,y)\\) in a more useful form: \\(f(x,y) = 10^{\\mathrm{len}(y)} x + y\\), where \\(\\mathrm{len}(y)\\) is the length of \\(y\\) interpreted as a string. For each \\(i\\), let us find the contributions of \\(A_i\\) in the form of \\(f(*,A_i)\\) and of \\(f(A_i, *)\\). The former is easy; \\(f(*,A_i)\\) has the term \\(A_i\\) itself, so the contribution to the answer is \\((i-1)A_i\\). We consider the latter. The contribution is \\(\\sum_{k=1}^{10} d_k 10^{k} A_i\\), where \\(d_k\\) is the number of \\(j\\) such that \\(i < j\\) and \\(\\mathrm{len}(A_j) = k\\). \\(d_k\\) can be updated in a constant time for each \\(i\\), so the latter contribution can be computed in \\(\\mathrm{O}(\\log M)\\) for each \\(i\\), where \\(M\\) is the maximum value in \\(A\\). Therefore, the answer has been found in a total of \\(\\mathrm{O}(N\\log M)\\) time.\n\nSample code (Python 3):\n\n```python\nimport sys\nfrom atcoder.modint import ModInt998244353\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    d = [0] * 11\n    for v in a:\n        d[len(str(v))] += 1\n    res = ModInt998244353(0)\n    p10 = [ModInt998244353(1)] * 11\n    for i in range(1, 11):\n        p10[i] = p10[i - 1] * 10\n    for i in range(n):\n        res += ModInt998244353(a[i]) * i\n        d[len(str(a[i]))] -= 1\n        for j in range(1, 11):\n            res += p10[j] * a[i] * d[j]\n    print(res.val())\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n \n\n", "problem_ids": ["abc353_d"]}, "abc301_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Score:** 900 points\n\n**Problem Statement:**  \nThere is a circle with circumference \\( L \\), and \\( L \\) people are standing equally spaced along the circumference. They are labeled as person \\( 0, 1, \\cdots, L-1 \\) in clockwise order. Consider choosing \\( N \\) from these \\( L \\) people. The **cost** of a choice is defined as follows:\n\n- For every pair of persons among the \\( N \\) chosen people, find the minimum distance one person has to move along the circumference to reach the other person's position. The maximum value among these distances is the cost.\n\nFind the sum of costs over all possible choices, modulo \\( 998244353 \\).\n\n**Constraints:**\n- \\( 2 \\leq N \\leq L \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**  \nThe input is given from Standard Input in the following format:\n```\nL N\n```\n\n**Output:**  \nPrint the answer.\n\n**Sample Input 1:**  \n```\n4 2\n```\n\n**Sample Output 1:**  \n```\n8\n```\n\nExplanation for Sample Input 1:  \nThe choices of \\( N \\) people and their corresponding costs are as follows:\n- \\( (0,1) \\): cost \\( 1 \\)\n- \\( (0,2) \\): cost \\( 2 \\)\n- \\( (0,3) \\): cost \\( 1 \\)\n- \\( (1,2) \\): cost \\( 1 \\)\n- \\( (1,3) \\): cost \\( 2 \\)\n- \\( (2,3) \\): cost \\( 1 \\)\n\nThe sum of these costs, \\( 8 \\), is the answer.\n\n**Sample Input 2:**  \n```\n5 5\n```\n\n**Sample Output 2:**  \n```\n2\n```\n\nExplanation for Sample Input 2:  \nWe can only choose all of them. In this case, the cost is \\( 2 \\).\n\n**Sample Input 3:**  \n```\n13 5\n```\n\n**Sample Output 3:**  \n```\n7618\n```\n\n**Sample Input 4:**  \n```\n1000000 100000\n```\n\n**Sample Output 4:**  \n```\n664396470\n```\n\nSolution:\n\n```python\nIf we know the answer when person 0 is always chosen, we can multiply it by L / N to get the original answer. Let\u2019s assume that person 0 is always chosen. For each D = 1, 2, ..., it suffices to find the number of ways to choose people so that the cost is less than D. First, people D, ..., L - D cannot be chosen. Next, consider whom to choose among people 1, 2, ..., D - 1. They can be chosen freely without interfering with each other. Finally, consider whom to choose among people L - D + 1, ..., L - 1. The condition for choosing person i is that none of the people in [i - L + D, i - D] have been chosen so far. Here, this interval is basically included within [1, D - 1]. If 2 * D <= i, this interval extends beyond that range, but the exceeding part is included in [D, L - D], from which we already know we are not choosing anyone, so we don\u2019t need to consider it specially. Let W = L - 2 * D + 1. We can regard the operation of choosing people from L - D + 1, ..., L - 1 as the operation of choosing intervals of length W among people 1, ..., D - 1. Then, what we need to consider is selecting people and intervals from people 1, ..., D - 1 so that they do not overlap (it\u2019s acceptable for intervals themselves to overlap). We will call a person chosen in the people selection as a red person. Also, in the interval selection, we will call the starting person of the interval as a blue person. If we fix the number of times red and blue alternate, the total number of ways to choose can be expressed using binomial coefficients. Also, the number of alternations is at most N // W. Therefore, if we perform this calculation for all D, the total computational complexity is O(N + N // 2 + N // 3 + ...) = O(N log N), so it runs sufficiently fast.\n```\n \n\n", "problem_ids": ["agc068_a"]}, "abc301_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Your task is to find the value of:\n\n\\[\n\\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} \\left\\lfloor \\frac{\\max(A_i, A_j)}{\\min(A_i, A_j)} \\right\\rfloor\n\\]\n\nHere, \\(\\lfloor x \\rfloor\\) represents the greatest integer not greater than \\( x \\). For example, \\(\\lfloor 3.14 \\rfloor = 3\\) and \\(\\lfloor 2 \\rfloor = 2\\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n3 1 4\n```\n\n**Sample Output 1:**\n\n```\n8\n```\n\n*Explanation:* The sought value is:\n\n\\[\n\\left\\lfloor \\frac{\\max(3, 1)}{\\min(3, 1)} \\right\\rfloor + \\left\\lfloor \\frac{\\max(3, 4)}{\\min(3, 4)} \\right\\rfloor + \\left\\lfloor \\frac{\\max(1, 4)}{\\min(1, 4)} \\right\\rfloor = \\left\\lfloor \\frac{3}{1} \\right\\rfloor + \\left\\lfloor \\frac{4}{3} \\right\\rfloor + \\left\\lfloor \\frac{4}{1} \\right\\rfloor = 3 + 1 + 4 = 8\n\\]\n\n**Sample Input 2:**\n\n```\n6\n2 7 1 8 2 8\n```\n\n**Sample Output 2:**\n\n```\n53\n```\n\n**Sample Input 3:**\n\n```\n12\n3 31 314 3141 31415 314159 2 27 271 2718 27182 271828\n```\n\n**Sample Output 3:**\n\n```\n592622\n```\n\nSolution:\n\n```python\ndef calculate_max_min_sum(N, M, A):\n    # A should be sorted in ascending order\n    A.sort()\n    \n    # Pre-calculate the cumulative sum of C\n    C = [0] * (M + 1)\n    \n    # Count frequency of each element in A\n    for a in A:\n        C[a] += 1\n    \n    # Convert frequency to cumulative\n    for i in range(1, M + 1):\n        C[i] += C[i - 1]\n    \n    # Calculate the sum\n    max_min_sum = 0\n    for i in range(N - 1):\n        for n in range(1, M // A[i] + 1):\n            # Get count of j where floor(A_j/A[i]) = n\n            j_count = C[min(M, n * A[i])] - C[n * A[i] - 1]\n            max_min_sum += n * j_count\n    \n    return max_min_sum\n```\n \n\n", "problem_ids": ["abc356_e"]}, "abc302_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nBelow is the cleaned version of the problem statement:\n\n---\n\nThere is a graph with \\(N + Q\\) vertices, numbered \\(1, 2, \\ldots, N + Q\\). Initially, the graph has no edges.\n\nFor this graph, perform the following operation for \\(i = 1, 2, \\ldots, Q\\) in order:\n\n- For each integer \\(j\\) satisfying \\(L_i \\leq j \\leq R_i\\), add an undirected edge with cost \\(C_i\\) between vertices \\(N + i\\) and \\(j\\).\n\nDetermine if the graph is connected after all operations are completed. If it is connected, find the cost of a minimum spanning tree of the graph.\n\nA minimum spanning tree is a spanning tree with the smallest possible cost, and the cost of a spanning tree is the sum of the costs of the edges used in the spanning tree.\n\n### Constraints\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(1 \\leq L_i \\leq R_i \\leq N\\)\n- \\(1 \\leq C_i \\leq 10^9\\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nL_1 R_1 C_1\nL_2 R_2 C_2\n...\nL_Q R_Q C_Q\n```\n\n### Output\n\nIf the graph is connected, print the cost of a minimum spanning tree. Otherwise, print \\(-1\\).\n\n### Sample Input 1\n\n```\n4 3\n1 2 2\n1 3 4\n2 4 5\n```\n\n### Sample Output 1\n\n```\n22\n```\n\nThe following edges form a minimum spanning tree:\n\n- An edge with cost 2 connecting vertices 1 and 5\n- An edge with cost 2 connecting vertices 2 and 5\n- An edge with cost 4 connecting vertices 1 and 6\n- An edge with cost 4 connecting vertices 3 and 6\n- An edge with cost 5 connecting vertices 3 and 7\n- An edge with cost 5 connecting vertices 4 and 7\n\nSince \\(2 + 2 + 4 + 4 + 5 + 5 = 22\\), print 22.\n\n### Sample Input 2\n\n```\n6 2\n1 2 10\n4 6 10\n```\n\n### Sample Output 2\n\n```\n-1\n```\n\nThe graph is disconnected.\n\n### Sample Input 3\n\n```\n200000 4\n1 200000 1000000000\n1 200000 998244353\n1 200000 999999999\n1 200000 999999999\n```\n\n### Sample Output 3\n\n```\n199651870599998\n```\n\n---\n\nSolution:\n\n        [BEGIN TEXT]\n        Since the graph in this problem may have up to \\(NQ\\) edges, one cannot directly apply an algorithm that determines the minimum spanning tree of a general graph. We will try to exploit the special form of the graph to optimize Kruskal\u2019s algorithm against it. We first sort the edges by their costs and appropriately reassign indices so that \\(C_1 \\leq C_2 \\leq \\ldots \\leq C_Q\\). According to Kruskal\u2019s algorithm, one can determine the minimum spanning tree as follows:\n\nPrepare an \\((N + Q)\\)-vertex graph without an edge. For \\(i = 1, 2, \\ldots ,Q\\) in order:\n\nFor each \\(j = L_i, L_i + 1, \\ldots, R_i\\) in order, add an edge between vertices \\((N + i)\\) and \\(j\\) of cost \\(C_i\\) if and only if vertices \\((N + i)\\) and \\(j\\) are not connected.\n\nWhile it is still difficult to handle the conditions, one can notice that vertices \\((N + i)\\) and \\(j\\) are always disconnected if \\(j =L_i\\), and that vertices \\((N + i)\\) and \\((j - 1)\\) are connected if and only if vertices \\((j - 1)\\) and \\(j\\) are, in order to realize that it is sufficient to perform connectivity check for vertices with adjacent indices: \\(j - 1\\) and \\(j\\). Also, the graph is disconnected if and only if there exists an integer \\(j\\) between \\(1\\) and \\((N-1)\\) (inclusive) such that vertices \\((j - 1)\\) and \\(j\\) are disconnected. Naively implementing this still costs \\(\\Theta(NQ + Q\\log Q)\\), but now that the problem is simplified, there are various approaches.\n\n(1) Use a set (or similar data structure) Manage the set of \\(1 \\leq j < N\\) such that vertices \\((j - 1)\\) and \\(j\\) are disconnected in a data structure like the built-in set in Python, and remove those among \\(L_i, L_i + 1, \\ldots, R_i - 1\\) that is not in the set. Naively checking the existence for each element still leads to TLE, but one can use a method such as bisect.bisect_left that retrieves the position of the minimum element greater than or equal to \\(x\\), as removal of an element occurs at most \\((N - 1)\\) times and the complexity is bounded by \\(O((N + Q) \\log N)\\), which is fast enough.\n\n(2) Use a lazy segment tree One can also use a lazy segment tree that supports segment-sum retrieval and segment-filling with \\(0\\). The \\(j\\)-th element of the lazy segment tree should be \\(0\\) if vertices \\(j\\) and \\((j+1)\\) are connected, and \\(1\\) otherwise. Initialize such a segment tree of length \\((N-1)\\) all with \\(1\\); then the number of edges connecting vertex \\(N + i\\) and any of vertices \\(L_i + 1, L_i + 2, \\ldots, R_i\\) can be retrieved as the segment sum of \\([L_i, R_i)\\), and adding an edge is fulfilled by filling \\([L_i, R_i)\\) with \\(0\\).\n\n(3) Use bitwise operations While a naive scan-based algorithm on an array results in TLE (Time Limit Exceeded), one can make use of bitwise operations with almost the same idea. The answer can be found fast enough by managing connectivity for each \\((j, j+1)\\) using the built-in int type in Python and using a function that returns the next position of \\(1\\) in the same way as found in (1), the answer can be found fast enough.\n        [END TEXT]\n \n\n", "problem_ids": ["abc364_f"]}, "abc302_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n### Problem Statement\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\).\n\nYour objective is to transform this permutation into the identity permutation \\( P_i = i \\) for all \\( i = 1, 2, \\ldots, N \\) by performing the following operation zero or more times:\n\n1. Choose an integer \\( k \\) such that \\( 1 \\leq k \\leq N \\).\n2. If \\( k \\geq 2 \\), sort the elements from the 1st to the \\((k-1)\\)-th position of \\( P \\) in ascending order.\n3. Then, if \\( k \\leq N - 1 \\), sort the elements from the \\((k+1)\\)-th to the \\( N \\)-th position of \\( P \\) in ascending order.\n\nIt can be proved that under the constraints of this problem, it is possible to transform any given permutation \\( P \\) into the identity permutation with a finite number of operations. Your task is to find the minimum number of operations required.\n\nYou have \\( T \\) test cases to solve.\n\n### Constraints\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 3 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( P \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n- The sum of \\( N \\) across the test cases in a single input is at most \\( 2 \\times 10^5 \\).\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\n...\ncase_T\n```\n\nEach case is presented as follows:\n\n```\nN\nP_1 P_2 ... P_N\n```\n\n### Output\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\n\n### Sample Input 1\n\n```\n3\n5\n2 1 3 5 4\n3\n1 2 3\n7\n3 2 1 7 5 6 4\n```\n\n### Sample Output 1\n\n```\n1\n0\n2\n```\n\n#### Explanation:\n\n- For the first test case, the operation with \\( k = 3 \\) yields \\( P \\) as \\( (1, 2, 3, 4, 5) \\), requiring 1 operation.\n- The second test case already satisfies \\( P_i = i \\), thus needing 0 operations.\n- For the third test case, perform the operations with \\( k = 4 \\) and then \\( k = 3 \\) successively to achieve the identity permutation \\( (1, 2, 3, 4, 5, 6, 7) \\), requiring 2 operations.\n\nSolution:\n\n---\n\nSince each operation sorts a significant portion of the array, it is expected that the entire array can be sorted with a few operations. In fact:\n\n1. Perform the operation with \\(k=1\\). This sorts the entire array if \\(P_1=1\\) in the initial state. Otherwise, we have \\(P_N \\neq 1\\) after the operation since \\(N \\geq 3\\).\n2. Next, perform the operation with \\(k=N\\). Since \\(P_N \\neq 1\\) before the operation, we have \\(P_1=1\\) after the operation.\n3. Perform the operation with \\(k=1\\). Since \\(P_1=1\\) before the operation, the entire array is certainly sorted after the operation.\n\nBy performing the above, any permutation can be sorted in at most three operations. Therefore, it is sufficient to quickly determine if the array can be sorted in zero, one, or two operations.\n\n- The determination for zero operations is trivial.\n- For one operation, if we fix \\(k\\), it is necessary and sufficient that the minimum and maximum values of \\((P_1, P_2, \\dots, P_{k-1})\\) are \\(1\\) and \\(k-1\\), respectively, and \\(P_k=k\\). This can be checked in \\(O(1)\\) time for each \\(k\\) by taking cumulative \\(\\min\\) and \\(\\max\\), so the overall determination can be done in \\(O(N)\\) time.\n- For two operations, if \\(P_N \\neq 1\\), starting from the second of the three operations, the array can be sorted in two operations. Similarly, if \\(P_1 \\neq N\\), it can be sorted in two operations. Conversely, if \\(P_1=N\\) and \\(P_N=1\\), the relative positions of \\(1\\) and \\(N\\) in \\(P\\) do not change with one operation, leaving them in the order \\(N, 1\\). Therefore, \\(P\\) can be sorted in two or fewer operations \\(\\iff\\) \\(P_1 \\neq N\\) or \\(P_N \\neq 1\\). This can be checked in \\(O(1)\\) time.\n\nFrom the above, the answer for each test case can be found in \\(O(N)\\) time.\n \n\n", "problem_ids": ["arc181_a"]}, "abc302_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given \\(N\\) strings \\(S_1, S_2, \\ldots, S_N\\) consisting of lowercase English letters and \\(N\\) positive integers \\(A_1, A_2, \\ldots, A_N\\).\n\nA subset \\(T\\) of \\(\\{1, 2, \\ldots, N\\}\\) is called a **good set** if there is no pair \\(i, j \\in T\\) (\\(i \\neq j\\)) such that \\(S_i\\) is a substring of \\(S_j\\).\n\nFind the maximum possible value of \\(\\sum_{i \\in T} A_i\\) for a good set \\(T\\).\n\n### What is a substring?\n\nA **substring** of a string \\(S\\) is a string obtained by deleting zero or more characters from the beginning and zero or more characters from the end of \\(S\\). For example, `ab` is a substring of `abc`, but `ac` is not a substring of `abc`.\n\n### Constraints\n\n- \\(1 \\leq N \\leq 100\\)\n- \\(S_i\\) is a string consisting of lowercase English letters.\n- \\(1 \\leq |S_i|\\)\n- \\(|S_1| + |S_2| + \\ldots + |S_N| \\leq 5000\\)\n- \\(1 \\leq A_i \\leq 10^9\\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1\nS_2\n.\n.\n.\nS_N\nA_1 A_2 ... A_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n4\natcoder\nat\ncoder\ncode\n5 2 3 4\n```\n\n### Sample Output 1\n\n```\n6\n```\n\nThe possible good sets \\(T\\) and their corresponding \\(\\sum_{i \\in T} A_i\\) are as follows:\n\n- \\(T = \\{1\\}\\): \\(\\sum_{i \\in T} A_i = 5\\)\n- \\(T = \\{2\\}\\): \\(\\sum_{i \\in T} A_i = 2\\)\n- \\(T = \\{3\\}\\): \\(\\sum_{i \\in T} A_i = 3\\)\n- \\(T = \\{4\\}\\): \\(\\sum_{i \\in T} A_i = 4\\)\n- \\(T = \\{2, 3\\}\\): \\(\\sum_{i \\in T} A_i = 5\\)\n- \\(T = \\{2, 4\\}\\): \\(\\sum_{i \\in T} A_i = 6\\)\n\nThe maximum among them is 6, so print 6.\n\n### Sample Input 2\n\n```\n10\nabcd\nabc\nab\na\nb\nc\nd\nab\nbc\ncd\n100 10 50 30 60 90 80 70 40 20\n```\n\n### Sample Output 2\n\n```\n260\n```\n\nSolution:\n\n        Editorial - Panasonic Programming Contest 2024 (AtCoder Beginner Contest 354)\n\nFor simplicity, assume \\(S_i \\neq S_j (i \\neq j)\\). Consider an \\(N\\)-vertex graph \\(G\\) with a directed edge from vertex \\(i\\) to vertex \\(j\\) if \\(S_i\\) is a substring of \\(S_j\\) for given \\(S_1, S_2, \\ldots, S_N\\). Then, \\(G\\) forms a DAG (Directed Acyclic Graph). Suppose each vertex has a weight of \\(A_1, A_2, \\ldots, A_n\\). The problem can be rephrased as follows: You are given a vertex-weighted \\(N\\)-vertex DAG \\(G\\). Choose some vertices without including a pair that has a path between them and find the maximum total weight of the chosen vertices.\n\nIgnoring weights, maximize the number of chosen vertices. If \\(G\\) has edges from vertex \\(i\\) \\(\\to\\) vertex \\(j\\) and vertex \\(j\\) \\(\\to\\) vertex \\(k\\), then it also has an edge from vertex \\(i\\) \\(\\to\\) vertex \\(k\\). Use Dilworth\u2019s theorem, which states that the size of a minimum path cover equals the size of a maximum independent set in such a DAG.\n\nFor an unweighted graph, find the size of a maximum independent set or a minimum path cover. The minimum path cover can be reduced to the maximum matching of a bipartite graph. Consider the \\(N\\)-vertex DAG \\(G\\) as a bipartite graph \\(H\\) with left vertices \\(1, 2, \\ldots, N\\) and right vertices \\(1', 2', \\ldots, N'\\). Then, \\(N - (\\text{maximum matching of }H) = (\\text{size of a minimum path cover of }G)\\). Thus, minimize the size of a path cover by maximizing the number of edges in it, corresponding to a maximum matching problem on the bipartite graph.\n\nFor the weighted problem, where we need the maximum total weight of the chosen vertices, set the maximum capacity of each edge \\(S \\to v\\) and \\(v' \\to T\\) to \\(A_v\\) and of \\(i \\to j'\\) to \\(\\infty\\). The solution is \\((\\sum A_i - (\\text{maximum flow of }S \\to T))\\). In implementation, handle edges between vertices \\(i\\) and \\(j\\) with identical strings by adding edges \\(i \\to j\\) if \\(S_i = S_j\\) and \\(i < j\\).\n\nTime complexity: Determine if \\(S_i\\) is a substring of \\(S_j\\) for all pairs \\(i, j\\) in \\(O(N^{2} + (\\sum |S_i|)^{2})\\), and find the maximum flow for a bipartite graph with \\(O(N)\\) vertices and \\(O(N^{2})\\) edges in \\(O(N^{4})\\), resulting in a total time complexity of \\(O(N^{4} + (\\sum |S_i|)^{2})\\).\n \n\n", "problem_ids": ["abc354_g"]}, "abc302_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Score:** 475 points\n\n**Problem Statement**\n\nIn the nation of Atcoder, there are \\( N \\) cities numbered from 1 to \\( N \\), and \\( M \\) trains numbered from 1 to \\( M \\). Train \\( i \\) departs from city \\( A_i \\) at time \\( S_i \\) and arrives at city \\( B_i \\) at time \\( T_i \\).\n\nGiven a positive integer \\( X_1 \\), find a way to determine non-negative integers \\( X_2, \\ldots, X_M \\) that satisfy the following condition while minimizing the value of \\( X_2 + \\ldots + X_M \\).\n\n**Condition:**\n\nFor all pairs \\( (i, j) \\) satisfying \\( 1 \\leq i, j \\leq M \\), if \\( B_i = A_j \\) and \\( T_i \\leq S_j \\), then \\( T_i + X_i \\leq S_j + X_j \\).\n\nIn other words, for any pair of trains that were originally possible to transfer between, it must still be possible to transfer even after delaying the departure and arrival times of each train \\( i \\) by \\( X_i \\).\n\nIt can be proved that there is a unique way to set \\( X_2, \\ldots, X_M \\) with the minimum possible value of \\( X_2 + \\ldots + X_M \\).\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( A_i \\neq B_i \\)\n- \\( 0 \\leq S_i < T_i \\leq 10^9 \\)\n- \\( 1 \\leq X_1 \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M X_1\nA_1 B_1 S_1 T_1\n\u22ee\nA_M B_M S_M T_M\n```\n\n**Output**\n\nPrint \\( X_2, \\ldots, X_M \\) that satisfy the condition with the minimum possible sum, in that order, separated by spaces.\n\n**Sample Input 1**\n\n```\n3 6 15\n1 2 10 20\n1 2 20 30\n2 3 25 40\n2 3 35 50\n3 1 15 30\n3 1 45 60\n```\n\n**Sample Output 1**\n\n```\n0 10 0 0 5\n```\n\n**Explanation**\n\nThe arrival of train 1 from city 1 to 2 is delayed by 15 and becomes time 35. To allow transfer from train 1 to 3 in city 2, the departure of train 3 is delayed by 10, making it depart at time 35 and arrive at time 50. Further, to allow transfer from train 3 to 6 in city 3, the departure of train 6 is delayed by 5, making it depart at time 50. Other trains can operate without delay while still allowing transfers between originally transferable trains, so \\( (X_2, X_3, X_4, X_5, X_6) = (0, 10, 0, 0, 5) \\) satisfies the condition. Moreover, there is no solution with a smaller sum that satisfies the condition, so this is the answer.\n\n**Sample Input 2**\n\n```\n10 9 100\n1 10 0 1\n10 2 1 100\n10 3 1 100\n10 4 1 100\n10 5 1 100\n10 6 1 100\n10 7 1 100\n10 8 1 100\n10 9 1 100\n```\n\n**Sample Output 2**\n\n```\n100 100 100 100 100 100 100 100\n```\n\n**Sample Input 3**\n\n```\n4 4 10\n1 2 0 1\n1 2 0 10\n2 3 100 200\n2 4 100 200\n```\n\n**Sample Output 3**\n\n```\n0 0 0\n```\n\nSolution:\n\nHere's the trimmed version focusing on the solution:\n\n---\n\n**E - Train Delay Editorial**\n\nLet us call \\(S_i\\) and \\(T_i\\) the scheduled departure and arrival, respectively, and \\(S_i+X_i\\) and \\(T_i+X_i\\) the actual departure and arrival. If you let a train depart later, you cannot make another depart earlier, so assume every train departs as early as possible. Whether a train \\(i\\) can depart is affected by trains whose scheduled arrival is prior to the departure of train \\(i\\). Therefore, processing trains in order of their scheduled times is effective.\n\nSort the \\(2M\\) departure/arrival events in ascending order:\n\n- When train \\(i\\) departs, find \\(X_i\\) based on the actual arrivals to station \\(A_i\\) for trains processed so far.\n- When train \\(i\\) arrives, record the actual arrival to station \\(B_i\\) based on \\(X_i\\).\n\nThese steps can be done in \\(O(1)\\) time by managing for each station the latest actual arrival of the trains processed so far. If departure and arrival occur simultaneously, process arrivals first.\n\n```python\nN, M, X = map(int, input().split())\nA, B, S, T = zip(*[tuple(map(int, input().split())) for _ in range(M)])\n\nevent = sorted([(S[i], 1, i) for i in range(M)] + [(T[i], 0, i) for i in range(M)])\n\nans = [0] * M\nans[0] = X\n\nstation = [0] * (N + 1)\nfor t, f, i in event:\n  if f:\n    if i:\n      ans[i] = max(0, station[A[i]] - t)\n  else:\n    station[B[i]] = max(station[B[i]], t + ans[i])\n\nprint(*ans[1:])\n```\n\n---\n \n\n", "problem_ids": ["abc368_e"]}, "abc302_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\) and a prime \\( P \\).\n\nCount the number, modulo \\( P \\), of undirected connected graphs \\( G \\) of \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) that satisfy the following conditions:\n\n1. There are no self-loops in \\( G \\). Note that multiple edges are allowed.\n2. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) remains connected. In other words, \\( G \\) is edge-biconnected.\n3. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) is no longer edge-biconnected.\n\nTwo graphs are considered different if and only if there exists a pair of distinct vertices \\( (u,v) \\) such that the numbers of edges connecting \\( u \\) and \\( v \\) in the two graphs are different.\n\n**Constraints**\n\n- \\( 2 \\le N \\le 50 \\)\n- \\( 10^9 < P < 1.01 \\times 10^9 \\)\n- \\( P \\) is prime.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**  \n```\n2 1005976817\n```\n\n**Sample Output 1**  \n```\n1\n```\n\n**Sample Input 2**  \n```\n5 1000837403\n```\n\n**Sample Output 2**  \n```\n372\n```\n\n**Sample Input 3**  \n```\n10 1001160547\n```\n\n**Sample Output 3**  \n```\n789846604\n```\n\n**Sample Input 4**  \n```\n20 1006779551\n```\n\n**Sample Output 4**  \n```\n888612770\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Grand Contest 067 - E: Biconnected Graph Editorial by Kubic\n\nIf an edge is deleted, the remaining graph will form a chain after shrinking biconnected components; it will become a cycle if the edge is added back. Solve the problem for each biconnected component and multiply the answers. In the subproblem, there's an additional edge connecting two vertices, allowing them to reach each other through the cycle. Repeat this method by taking an edge connected to vertex \\(1\\), leading to subproblems formatted as:\n\nCount good graphs of \\(n\\) vertices with the first \\(k\\) vertices able to reach each other externally.\n\nConsider the distribution of the first \\(k\\) vertices:\n\n\\(\\forall 1\\le u,v\\le k\\), \\(C(u),C(v)\\) are not adjacent in the cycle, where \\(C(u)\\) is the biconnected component containing \\(u\\).\n\nDP through the cycle without constraining the edge choice so every good graph is counted \\(\\deg(1)\\) times. Store \\(\\deg(1)\\) in the DP state and divide the final answer by it.\n\nTime complexity: \\(O(n^5)\\). Some \\(O(n^6)\\) solutions with small constants may pass.\n        [END TEXT]\n \n\n", "problem_ids": ["agc067_e"]}, "abc302_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). Each edge \\( i \\) in the tree connects two vertices \\( A_i \\) and \\( B_i \\).\n\nConsider a subtree that can be obtained by removing some (possibly zero) edges and vertices from this tree. Your task is to find the minimum number of vertices required in such a subtree that includes all of \\( K \\) specified vertices \\( V_1, V_2, \\ldots, V_K \\).\n\n**Constraints**\n- \\( 1 \\leq K \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq V_1 < V_2 < \\ldots < V_K \\leq N \\)\n- The given graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN K\nA_1 B_1\nA_2 B_2\n...\nA_{N-1} B_{N-1}\nV_1 V_2 ... V_K\n```\n\n**Output**\n\nPrint the minimum number of vertices in the subtree that includes the desired vertices.\n\n**Sample Input 1**\n```\n7 3\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n1 3 5\n```\n\n**Sample Output 1**\n```\n4\n```\n\nThe given tree is shown on the left below. The subtree with the minimum number of vertices that includes vertices \\( 1, 3, 5 \\) is shown on the right.\n\n**Sample Input 2**\n```\n4 4\n3 1\n1 4\n2 1\n1 2 3 4\n```\n\n**Sample Output 2**\n```\n4\n```\n\n**Sample Input 3**\n```\n5 1\n1 4\n2 3\n5 2\n1 2\n1\n```\n\n**Sample Output 3**\n```\n1\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Hitachi Vantara Programming Contest 2024 (AtCoder Beginner Contest 368)\n\nD - Minimum Steiner Tree Editorial by en_translator\n\nIf \\(K=1\\), the answer is obviously \\(1\\). For other cases, define a tree as applicable if it is obtained by removing zero or more edges and vertices from the original graph and contains all vertices \\(V_1, \\ldots, V_K\\). A vertex is bad if its degree is \\(1\\) and it is not one of \\(V_1,\\ldots,V_K\\). The sought tree is obtained by repeatedly removing a bad vertex and its adjacent edge from the original tree as many times as possible.\n\nProof:\n\n1. An applicable tree with the minimum number of vertices does not have a bad vertex. If it has a bad vertex, the tree remains applicable even after removing that vertex. Hence, a minimal applicable tree does not have a bad vertex.\n\n2. An applicable tree without a bad vertex is minimal. For any applicable tree \\(T\\) without a bad vertex, and any minimal tree \\(T'\\), consider their intersection as subgraphs. If it forms a tree or is empty, the tree \\(T''\\) obtained by contracting the vertices in \\(T \\cap T'\\) must be a single vertex, implying \\(T \\subseteq T'\\). By minimality of \\(T'\\), we conclude \\(T = T'\\).\n\nThis operation can be efficiently performed by managing the vertices directly connected by an edge for each vertex.\n\nWriter\u2019s solution (Python):\n```python\nN, K = map(int, input().split())\nedge = [set() for _ in range(N)]\n\nfor _ in range(N-1):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  edge[a].add(b)\n  edge[b].add(a)\n\nV = set(map(int, input().split()))\nV = {x - 1 for x in V}\n\ndeg = [len(s) for s in edge]\nq = [i for i, d in enumerate(deg) if d == 1]\n\nans = N\nfor v in q:\n  if v in V: continue\n  vv = edge[v].pop()\n  edge[vv].discard(v)\n  ans -= 1\n  if len(edge[vv]) == 1: q.append(vv)\n\nprint(ans)\n```\n\n        [END TEXT]\n \n\n", "problem_ids": ["abc368_d"]}, "abc303_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). For each \\( t = 1, 2, \\dots, N \\), determine whether \\( A_t \\) is included in a longest increasing subsequence of \\( A \\).\n\nHere, \\( A_t \\) is included in a longest increasing subsequence of \\( A \\) if and only if the following holds:\n- Let \\( L \\) be the length of a longest increasing subsequence of \\( A \\). There exists a strictly increasing integer sequence \\( i = (i_1, i_2, \\dots, i_L) \\ (i_1 < i_2 < \\dots < i_L) \\), where each element is between \\( 1 \\) and \\( N \\), inclusive, that satisfies all of the following conditions:\n  - \\( A_{i_1} < A_{i_2} < \\dots < A_{i_L} \\).\n  - \\( i_k = t \\) for some \\( k \\ (1 \\leq k \\leq L) \\).\n\nYou are given \\( T \\) test cases; solve each of them.\n\n**What is a longest increasing subsequence?**\n- A subsequence of a sequence \\( A \\) is a sequence that can be derived by extracting some elements from \\( A \\) without changing the order.\n- A longest increasing subsequence of a sequence \\( A \\) is a subsequence of \\( A \\) that is strictly increasing with the greatest possible length.\n\n**Constraints**\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) across all test cases is at most \\( 2 \\times 10^5 \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\nHere, \\(\\mathrm{case}_i\\) represents the input for the \\(i\\)-th case. Each case is given in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\nPrint the answers in the following format:\n```\n\\mathrm{answer}_1\n\\mathrm{answer}_2\n\\vdots\n\\mathrm{answer}_T\n```\nHere, \\(\\mathrm{answer}_i\\) represents the output for the \\(i\\)-th case. For each case, let there be \\( m \\) indices \\( t \\) such that \\( A_t \\) is included in a longest increasing subsequence of \\( A \\), which are \\( i_1, i_2, \\dots, i_m \\) in ascending order. Print these in the following format:\n```\nm\ni_1 i_2 \\cdots i_m\n```\n\n**Sample Input 1**\n```\n1\n5\n2 1 4 5 3\n```\n\n**Sample Output 1**\n```\n4\n1 2 3 4\n```\nOne of the longest increasing subsequences is \\( (2, 4, 5) \\), with a length of 3. Another longest increasing subsequence is \\( (1, 4, 5) \\). However, no longest increasing subsequence includes \\( A_5 \\). Therefore, print \\( 1, 2, 3, 4 \\).\n\n**Sample Input 2**\n```\n2\n6\n2 5 3 4 3 4\n5\n10000 1000 100 1 10\n```\n\n**Sample Output 2**\n```\n5\n1 3 4 5 6\n2\n4 5\n```\n\nSolution:\n\n```\nEditorial - Useless for LIS\n\nGiven a sequence \\( A \\), its Longest Increasing Sequence (LIS) can be found as follows: Apply coordinate compression to assume \\( 1 \\leq A_i \\leq N \\). Use Dynamic Programming (DP) with `dp[i][j]` representing the length of a LIS chosen from the first \\( i \\) elements with the last element \\( j \\). Initialize `dp[0][0] = 0` and `dp[0][1] = dp[0][2] = ... = dp[0][N] = -float('inf')`. The transitions for \\( i = 1, 2, ..., N \\) are:\n\n1. `dp[i][j] = max(dp[i - 1][k] + 1 for k in range(j))` for `j = A[i]`.\n2. `dp[i][j] = dp[i - 1][j]` for `j != A[i]`.\n\nThe length of a LIS is `max(dp[N][k] for k in range(N + 1))`. It is possible to reconstruct a LIS. The complexity can be reduced to \\(O(N \\log N)\\) using a segment tree.\n\nThe DP can be efficiently implemented using pseudocode and a segment tree for segment-max retrieval, which allows LIS length to be obtained in \\(O(N \\log N)\\). Furthermore, by considering constrained LIS lengths `l_i` and `r_i`, and checking if `l_i + r_i - 1 = L`, where `L` is the LIS length, we can address this problem. `l` is found by memorizing DP results, and `r` by reversing the array and applying the same algorithm.\n```\n \n\n", "problem_ids": ["abc354_f"]}, "abc303_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Country of AtCoder consists of \\( N \\) cities and \\( M \\) roads connecting them. One can travel between any two cities by traversing some roads. The cities are numbered from 1 to \\( N \\), and the roads are numbered from 1 to \\( M \\). Road \\( i \\) connects cities \\( A_i \\) and \\( B_i \\) bidirectionally.\n\nDue to increasing traffic in the country, there is a plan to expand some roads. Currently, no roads have been expanded, and the cost to expand road \\( i \\) is \\( C_i \\).\n\nSince it is difficult to expand all roads at once, the plan is to first designate \\( K \\) out of the \\( N \\) cities as **major cities** and perform the minimum necessary expansion work, so that one can travel between any two major cities using only expanded roads. It has already been decided that cities \\( 1, 2, \\ldots, K-1 \\) will be major cities, but the last major city has not yet been decided.\n\nFor each \\( i = K, K+1, \\ldots, N \\), answer the following question: If city \\( i \\) is designated as the last major city, what is the minimum total cost of the expansion work required to ensure that one can travel between any two major cities using only expanded roads?\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 4000 \\)\n- \\( N-1 \\leq M \\leq 8000 \\)\n- \\( 2 \\leq K \\leq \\min(N, 10) \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- One can travel between any two cities by traversing some roads.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n**Output**\n\nPrint \\( N-K+1 \\) lines. The \\( l \\)-th line \\( (1 \\leq l \\leq N-K+1) \\) should contain the answer to the question for \\( i = l+K-1 \\), as an integer.\n\n**Sample Input 1**\n```\n4 5 3\n1 4 3\n3 4 4\n1 2 4\n2 3 2\n1 3 1\n```\n\n**Sample Output 1**\n```\n3\n6\n```\n\nIn the above figure, circles with numbers represent cities with those numbers, and lines with numbers represent roads with the cost of expansion being that number. The left and right figures correspond to the cases \\( i=3 \\) and \\( i=4 \\), respectively. The colored circles represent the major cities, and the colored thick lines represent the roads that are expanded in an optimal solution. For \\( i=3 \\), expanding roads 4 and 5 results in a total cost of \\( 2+1=3 \\), which is the minimum. For \\( i=4 \\), expanding roads 1, 4, and 5 results in a total cost of \\( 3+2+1=6 \\), which is the minimum.\n\n**Sample Input 2**\n```\n4 3 2\n2 4 28\n1 4 56\n1 3 82\n```\n\n**Sample Output 2**\n```\n84\n82\n56\n```\n\n**Sample Input 3**\n```\n6 12 4\n2 6 68\n2 5 93\n4 6 28\n2 4 89\n3 6 31\n1 3 10\n1 2 53\n3 5 1\n3 5 74\n3 4 22\n4 5 80\n3 4 35\n```\n\n**Sample Output 3**\n```\n85\n64\n94\n```\n\nThere may be multiple roads connecting the same pair of cities.\n\nSolution:\n\nHere is the editorial with the C++ code translated to Python3:\n\n```\nJapan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nOfficial\n\nG - Last Major City Editorial\n\nThis problem is an extension of the minimum Steiner tree problem. We referred to an editorial slide by Yoichi Iwata. A city, road, and cost are simply a vertex, edge, and weight. In an optimal solution, the graph defined by the set of edges to be extended as well as their adjacent vertices forms a tree. For a subset of the vertex set \\(\\{1,2,\\dots,K-1\\}\\) and vertex \\(v\\), \\(f(S,v)\\) is the minimum total weight of the edges of a tree containing vertex \\(v\\) and all vertices in \\(S\\). We seek \\(f(\\{1,2,\\dots,K-1\\}, v)\\) for each \\(K\\leq v\\leq N\\).\n\nThe function \\(f(S,v)\\) can be calculated with Dynamic Programming (DP), using initial values \\(f(\\{i\\}, i)=0\\ (1 \\leq i \\leq K-1)\\). There are two transitions: \n\n1. \\(f(S,v) \\leftarrow \\min(f(S,v),f(S,u) + w)\\) if an edge of weight \\(w\\) connects vertices \\(u\\) and \\(v\\).\n2. \\(f(S,v) \\leftarrow \\min(f(S,v),f(T,v)+f(S\\setminus T,v))\\ (T\\subsetneq S, T\\neq \\emptyset)\\).\n\nThe transitions ensure efficient processing by filling the DP table in ascending order of the size of \\(S\\). The circular dependency in the former transition is managed by determining \\(f(S,v)\\) in ascending order of its value using Dijkstra\u2019s algorithm. The overall complexity is \\(O(3^KN+2^KM\\log M)\\).\n\nSample code (Python3):\n\n```python\nimport sys\nimport heapq\n\ndef chmin(a, b):\n    return b < a\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2]) - 1\n    \n    G = [[] for _ in range(n)]\n\n    index = 3\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        index += 3\n        G[a].append((b, c))\n        G[b].append((a, c))\n\n    dp = [[float('inf')] * n for _ in range(1 << k)]\n    for i in range(k):\n        dp[1 << i][i] = 0\n\n    for bit in range(1, 1 << k):\n        sub = bit\n        while sub > 0:\n            for i in range(n):\n                dp[bit][i] = min(dp[bit][i], dp[sub][i] + dp[bit - sub][i])\n            sub = (sub - 1) & bit\n\n        pq = [(dp[bit][i], i) for i in range(n)]\n        heapq.heapify(pq)\n\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dp[bit][u]:\n                continue\n            for v, l in G[u]:\n                if chmin(dp[bit][v], d + l):\n                    dp[bit][v] = d + l\n                    heapq.heappush(pq, (d + l, v))\n\n    for i in range(k, n):\n        print(dp[-1][i])\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc364_g"]}, "abc303_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) types of elements numbered \\( 1, 2, \\ldots, N \\). Elements can be combined with each other. When elements \\( i \\) and \\( j \\) are combined, they transform into element \\( A_{i, j} \\) if \\( i \\geq j \\), and into element \\( A_{j, i} \\) if \\( i < j \\).\n\nStarting with element \\( 1 \\), combine it with elements \\( 1, 2, \\ldots, N \\) in this order. Find the final element obtained.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_{i, j} \\leq N \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_{1, 1}\nA_{2, 1} A_{2, 2}\n\\vdots\nA_{N, 1} A_{N, 2} \\ldots A_{N, N}\n```\n\n**Output:**\n\nPrint the number representing the final element obtained.\n\n**Sample Input 1:**\n\n```\n4\n3\n2 4\n3 1 2\n2 1 2 4\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- Combining element 1 with element 1 results in element 3.\n- Combining element 3 with element 2 results in element 1.\n- Combining element 1 with element 3 results in element 3.\n- Combining element 3 with element 4 results in element 2.\n\nTherefore, the value to be printed is 2.\n\n**Sample Input 2:**\n\n```\n5\n5\n5 5\n5 5 5\n5 5 5 5\n5 5 5 5 5\n```\n\n**Sample Output 2:**\n\n```\n5\n```\n\n**Sample Input 3:**\n\n```\n6\n2\n1 5\n1 6 3\n2 6 1 4\n2 1 1 1 6\n5 6 1 2 2 5\n```\n\n**Sample Output 3:**\n\n```\n5\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\n**B - Binary Alchemy Editorial**\n\nSimulate the process of successively synthesizing elements \\(1, 2, \\ldots, N\\) into element \\(1\\) while managing the current index of the element.\n\n```python\ndef main():\n    n = int(input())\n    a = [list(map(lambda x: int(x) - 1, input().split())) + [0] * (n - i - 1) for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if ans >= i:\n            ans = a[ans][i]\n        else:\n            ans = a[i][ans]\n    ans += 1\n    print(ans)\n\nmain()\n```\n\n---\n \n\n", "problem_ids": ["abc370_b"]}, "abc303_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a string \\( S \\) of length \\( N \\) consisting of the characters 'A' and 'B'. For a string \\( X \\) of length \\( N \\) consisting of the characters '1', '2', and '3', the score is determined by the following procedure:\n\n1. Initialize the variables \\( h_1, h_2, h_3, P \\) to 0.\n\n2. For \\( i = 1, 2, \\dots, N \\) in this order, perform the following operations:\n   - If the \\( i \\)-th character of \\( S \\) is 'A', perform operation A; if it is 'B', perform operation B. Let \\( d \\) be the number represented by the \\( i \\)-th character of \\( X \\).\n   - **Operation A:** Add 2 to \\( h_d \\).\n   - **Operation B:** If \\( d = 2 \\) or \\( h_d \\neq h_2 \\), set \\( P \\) to \\(-10^{100}\\). Otherwise, add 1 to both \\( h_d \\) and \\( h_2 \\).\n\n3. If \\( h_1 = h_2 = h_3 \\), add 1 to \\( P \\).\n\nThe final value of \\( P \\) is the score.\n\nPrint one string \\( X \\) that maximizes the score. You have \\( T \\) test cases to solve.\n\n**Constraints:**\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N \\leq 10^6 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of 'A' and 'B'.\n- \\( T \\) and \\( N \\) are integers.\n- The sum of \\( N \\) across all test cases is at most \\( 10^6 \\).\n\n**Input:**\nThe input is given from Standard Input in the following format. Here, \\(\\mathrm{test}_i\\) denotes the \\( i \\)-th test case.\n\n```\nT\n\\mathrm{test}_1\n\\mathrm{test}_2\n\\vdots\n\\mathrm{test}_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nS\n```\n\n**Output:**\nPrint \\( T \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq T \\)) should contain a string \\( X \\) that maximizes the score for the \\( i \\)-th test case. If multiple strings \\( X \\) maximize the score, any of them is considered correct.\n\n**Sample Input 1:**\n```\n5\n4\nABBA\n5\nAAAAA\n6\nBBBBBB\n7\nABABABA\n20\nAAABBBBBBBBAAABBBABA\n```\n\n**Sample Output 1:**\n```\n1333\n12321\n333333\n1313212\n33311111133121111311\n```\n\nLet us describe the changes in \\((h_1, h_2, h_3, P)\\) as we proceed with \\( i = 1, 2, \\dots, N \\).\n\n- For the first test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,1,1,0) \\rightarrow (2,2,2,1) \\rightarrow (2,2,4,1)\\). The maximum score is 1.\n- For the second test case, \\((0,0,0,0) \\rightarrow (2,0,0,0) \\rightarrow (2,2,0,0) \\rightarrow (2,2,2,1) \\rightarrow (2,4,2,1) \\rightarrow (4,4,2,1)\\). The maximum score is 1.\n\nFor the third, fourth, and fifth test cases, the maximum scores are 0, 0, and 2, respectively. There may be multiple strings \\( X \\) that maximize the score, but you only need to print one of them.\n\nSolution:\n\n[BEGIN TEXT]\nHere is a concise version of the provided text:\n\n---\n\n**F - All the Same Editorial by evima**\n\n**Observations on the Problem:**  \nThe problem can be visualized as a Tetris game with dominoes on a field width of 3, where dominoes cannot be rotated and there must be no gaps below horizontally placed dominoes. The score increases when all pieces are cleared. Flattening occurs when \\( h_1 = h_2 = h_3 \\).\n\n**Characteristics of \\( S \\):**  \nFor \\( i=0,1,\\ldots,N \\), let \\( a_i \\) be the number of As and \\( b_i \\) the number of Bs. The sequence can be flattened under the following conditions:\n- \\( a_i + b_i \\equiv 0 \\mod 3 \\)\n- \\( b_i \\equiv 0 \\mod 2 \\)\n- \\( b_i \\le 2a_i \\)\n\nDefining \\( V_i = 2a_i - b_i \\) gives:\n\\[ V_i \\ge 0, \\ V_i \\equiv 0 \\mod 6 \\]\nThese conditions are both necessary and sufficient for flattening.\n\n**Maximizing the Score:**  \nFind the longest non-decreasing subsequence \\( (V_{i_0}, V_{i_1}, \\ldots, V_{i_k}) \\) with:\n- \\( i_0 = 0 \\)\n- \\( V_{i_j} \\equiv 0 \\mod 6 \\)\n- \\( V_{i_j} \\le V_{i_{j+1}} \\)\n\nThis can be solved in \\( O(N \\log N) \\) time. \n\n**Constructing the Operation Sequence:**  \nDefine \\( T_j \\) as the substring of \\( S \\) from \\( (V_{i_j}+1) \\)-th to \\( V_{i_{j+1}} \\)-th character. Construct an operation sequence \\( X \\) for \\( S \\):\n- \\( A \\to 1 \\) (vertical domino)\n- \\( B \\to 3 \\) (horizontal domino)\n\nAdjust for \\( V_N \\ge 6 \\) by aligning extra vertical dominoes. Execute the basic idea when \\( V_N = 0 \\). Handle \\( V_i \\) conditions to reduce \\( V_N \\).\n\n**Summary:**  \n1. Compute \\( V \\) and solve the longest non-decreasing subsequence problem.\n2. For divided substrings, use the basic idea and reductions.\n\nThe solution operates in \\( O(|S|\\log |S|) \\) time per test case.\n[END TEXT]\n \n\n", "problem_ids": ["arc179_f"]}, "abc303_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given positive integers \\( N \\) and \\( L \\), and a sequence of positive integers \\( A = (A_{1}, A_{2}, \\dots, A_{N}) \\) of length \\( N \\).\n\nFor each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nDetermine if there exists a sequence of \\( L \\) non-negative integers \\( B = (B_{1}, B_{2}, \\dots, B_{L}) \\) such that:\n\n\\[\n\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = A_{i}\n\\]\n\nIf it exists, find the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^{5} \\)\n- \\( 2 \\leq L \\leq 2 \\times 10^{5} \\)\n- \\( 1 \\leq A_{i} \\leq 2 \\times 10^{5} \\)\n\nAll input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN L\nA_{1} A_{2} \\cdots A_{N}\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain \\(-1\\) if no sequence \\( B \\) satisfies the condition for \\( i = k \\); otherwise, it should contain the minimum value of \\( \\max(B) \\) for such a sequence \\( B \\).\n\n**Sample Input 1:**\n\n```\n2 4\n10 5\n```\n\n**Sample Output 1:**\n\n```\n3\n-1\n```\n\n*Explanation*:\n- For \\( A_{1} = 10 \\), if we take \\( B = (1, 0, 2, 3) \\), then \\(\\sum_{j = 1}^{L - 1} \\sum_{k = j + 1}^{L} |B_{j} - B_{k}| = 10\\), where \\( \\max(B) = 3 \\). No non-negative integer sequence \\( B \\) satisfies the condition with \\( \\max(B) < 3 \\), so print 3 in the first line.\n- For \\( A_{2} = 5 \\), there is no non-negative integer sequence \\( B \\) that satisfies the condition, so print -1 in the second line.\n\n**Sample Input 2:**\n\n```\n6 8\n167 924 167167 167924 116677 154308\n```\n\n**Sample Output 2:**\n\n```\n11\n58\n10448\n10496\n7293\n9645\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Regular Contest 178\n\nC - Sum of Abs 2 Editorial by evima\n\nIn this explanation, the \u201csum of abs\u201d refers to the following formula: \n\\[\\sum_{j=1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}|\\]\n\nWhen \\(B\\) exists, one \\(B\\) that minimizes \\(\\max(B)\\) satisfies the following two conditions:\n- \\(B\\) is sorted in ascending order.\n- \\(B_{1} = 0\\).\n\nThe sum of abs does not depend on the order of \\(B\\). If all elements of \\(B\\) are positive, subtracting \\(1\\) from all elements can reduce \\(\\max(B)\\) without changing the sum of abs. When \\(B\\) is sorted in ascending order, the sum of abs can be expressed as follows: \n\\[\\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} |B_{j} - B_{k}| = \\sum_{j = 1}^{L - 1}\\sum_{k = j + 1} ^ {L} (B_{k} - B_{j}) =\\sum_{k = 1} ^ {L - 1} k(L - k)(B_{k + 1} - B_{k})\\]\n\nThis transformation is correct because \\(B_{a}-B_{b}=(B_{a}-B_{a-1}) + (B_{a-1}+B_{a-2}) + \\cdots +(B_{b+1}-B_{b})\\) for integers \\(a, b\\) satisfying \\(1\\leq b<a\\leq L\\), and the number of pairs \\((a, b)\\) satisfying \\(b\\leq k\\) and \\(k+1\\leq a\\) is \\(k(L-k)\\).\n\nIf we let \\(C_{k} = B_{k + 1} - B_{k}\\), then when \\(B\\) is sorted in ascending order and \\(B_{1} = 0\\), the following holds:\n- \\(0 \\leq C_{k}\\).\n- The sum of abs is equal to \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}\\).\n- \\(\\displaystyle\\max(B) = B_{L} = \\sum_{k = 1} ^ {L - 1} C_{k}\\).\n\nTherefore, we need to solve the following problem: Determine if there exists a sequence of non-negative integers \\(C\\) of length \\(L - 1\\) such that \\(\\displaystyle \\sum_{k = 1} ^ {L - 1} k(L - k)C_{k}  = A_{i}\\), and if it exists, find the minimum sum of such \\(C\\).\n\nThis can be solved using dynamic programming in the same manner as the knapsack problem, and it can be computed simultaneously for all \\(i\\). Since \\(C_{k} = 0\\) always holds for \\(k\\) satisfying \\(\\max(A)<k(L-k)\\), our solution has a space complexity of \\(O(\\max(A))\\) and a time complexity of \\(O(N + \\max(A)\\sqrt{\\max(A)})\\).\n\nPython implementation example:\n\n```python\nN, L = map(int, input().split())\nA = list(map(int, input().split()))\n\nM = 2 * 10 ** 5\nINF = 10 ** 9\ndp = [INF] * (M + 1)\ndp[0] = 0\nk = 1\n\nwhile k * (L - k) <= M and k * 2 <= L:\n    w = k * (L - k)\n    for i in range(w, M + 1):\n        dp[i] = min(dp[i], dp[i - w] + 1)\n    k += 1\n\nfor a in A:\n    print(-1 if dp[a] == INF else dp[a])\n``` \n```\n \n\n", "problem_ids": ["arc178_c"]}, "abc304_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\n", "problem_ids": ["abc361_a"]}, "abc304_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(N\\) where all elements are between \\(1\\) and \\(2^K - 1\\), inclusive, is called a **good sequence**.\n\nThe **score** of a good sequence \\(A = (A_1, A_2, \\ldots, A_N)\\) is defined as follows:\n- The number of distinct integers that can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) using an integer \\(i\\) between \\(1\\) and \\(N\\), inclusive, and a non-negative integer \\(k\\).\n\nFor example, for \\(A = (3, 5)\\), five integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3,\\) and \\(5\\), so the score is \\(5\\).\n\nFind one good sequence with the maximum score.\n\nFor each input file, you are given \\(T\\) test cases to solve.\n\n### Constraints\n- \\(1 \\leq T \\leq 10^5\\)\n- \\(1 \\leq N \\leq 10^5\\)\n- \\(1 \\leq K \\leq 30\\)\n- The sum of \\(N\\) across the test cases in a single input file is at most \\(2 \\times 10^5\\).\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format. Here, \\(\\text{case}_i\\) denotes the \\(i\\)-th test case.\n\n```\nT\n\\text{case}_1\n\\text{case}_2\n\\vdots\n\\text{case}_T\n```\n\nEach test case is given in the following format:\n```\nN K\n```\n\n### Output\nPrint \\(T\\) lines.\n\nThe \\(i\\)-th line should contain the answer for \\(\\text{case}_i\\).\n\nIf there are multiple good sequences with the maximum score, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n3 3\n7 2\n8 20\n```\n\n### Sample Output 1\n```\n5 6 7\n2 2 3 3 1 3 3\n662933 967505 876482 840117 1035841 651549 543175 781219\n```\n\n**Explanation for the first test case:**\nFor \\(A = (5, 6, 7)\\), seven integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3, 5, 6,\\) and \\(7\\), so its score is \\(7\\). Outputs such as \\(A = (7, 4, 5)\\) and \\(A = (6, 5, 4)\\) would also be accepted.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nB - |{floor(A_i/2^k)}| Editorial by evima\n\nIn this explanation, we assume that indices start from \\(0\\). First, it is unnecessary to include elements less than \\(2^{K-1}\\) in \\(A\\). This is because replacing elements less than \\(2^{K-1}\\) with their double will result in the same or a higher score. Therefore, we can limit the elements of \\(A\\) to be between \\(2^{K-1}\\) and \\(2^K-1\\).\n\n1. When \\(N \\geq 2^{K-1}\\): We can include all elements between \\(2^{K-1}\\) and \\(2^K-1\\) in \\(A\\) and set \\(A_i = \\max(1, 2^K - 1 - i)\\) \\((0 \\le i < N)\\).\n\n2. When \\(N < 2^{K-1}\\): Consider an upper bound of the score. For \\(0 \\le x < K\\), consider the number of elements that appear as \\(\\displaystyle \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) between \\(2^x\\) and \\(2^{x+1}-1\\). For each \\(A_i\\), there is at most one \\(k\\) that satisfies \\(\\displaystyle 2^x \\le \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor < 2^{x+1}\\), so the number of such elements is at most \\(N\\). On the other hand, there are only \\(2^x\\) integers between \\(2^x\\) and \\(2^{x+1}\\), so the number of elements that appear in this range is at most \\(\\min(N, 2^x)\\). Therefore, by summing over all \\(x\\), the score has an upper bound of \\(\\displaystyle 1 + \\sum_{x=0}^{K-1}\\min(N, 2^x)\\).\n\nThis upper bound can always be achieved. Specifically, construct \\(A\\) as follows: Set \\(A_i\\) to the sum of \\(2^{K-1}\\) and the bit-reversal of \\(i\\). \u201cThe bit-reversal of \\(i\\)\u201d means the value obtained by reversing the \\((K-1)\\)-bit binary representation of \\(i\\).\n\nBy implementing the above, we can solve this problem. The time complexity is \\(O(NK)\\) due to the bit-reversal calculation being the bottleneck.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n\n    def bit_reversal(x):\n        return int(bin(x)[2:].zfill(K - 1)[::-1], 2)\n\n    if N >= 2 ** (K - 1):\n        print(*[max(1, 2**K - i - 1) for i in range(N)])\n    else:\n        print(*[2 ** (K - 1) + bit_reversal(i) for i in range(N)])\n```\n\nAdditionally, you can also solve it by constructing from the highest bit downwards.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n    C = [1]\n    for _ in range(1, K):\n        D = [2 * c for c in C] + [2 * c + 1 for c in C]\n        C = D[:N]\n    while len(C) < N:\n        C.append(1)\n    print(*C)\n```\n```\n \n\n", "problem_ids": ["arc182_b"]}, "abc304_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nIn the Kingdom of AtCoder, the eldest son is always given the name Taro. No one else is given the name Taro. The eldest son is the earliest born male child in each family.\n\nThere are \\(N\\) families in the Kingdom, and \\(M\\) babies were born. Before the \\(M\\) babies were born, none of the \\(N\\) families had had any babies.\n\nInformation about the babies is given in chronological order of their birth. The \\(i\\)-th baby born was born in family \\(A_i\\), and the baby is male if \\(B_i\\) is \\(M\\), and female if it is \\(F\\).\n\nDetermine for each of the \\(M\\) babies whether the name given is Taro.\n\nConstraints:\n- \\(1 \\leq N, M \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- \\(B_i\\) is \\(M\\) or \\(F\\).\n- All numbers in the input are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\nOutput:\nPrint \\(M\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq M)\\) should contain `Yes` if the name given to the \\(i\\)-th baby is Taro, and `No` otherwise.\n\nSample Input 1:\n```\n2 4\n1 M\n1 M\n2 F\n2 M\n```\n\nSample Output 1:\n```\nYes\nNo\nNo\nYes\n```\n\nExplanation of Sample Output 1:\n- The first baby is the earliest born boy in family 1, so he is named Taro.\n- The second baby is not the earliest born boy in family 1, so he is not named Taro.\n- The third baby is a girl, so she is not named Taro.\n- The fourth baby is the earliest born **boy** in family 2, so he is named Taro. Note that the third baby is also born in family 2, but it is the earliest born boy who is named Taro.\n\nSample Input 2:\n```\n4 7\n2 M\n3 M\n1 F\n4 F\n4 F\n1 F\n2 M\n```\n\nSample Output 2:\n```\nYes\nYes\nNo\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Beginner Contest 371\n\nB - Taro Editorial by en_translator\n\nMaintain a flag to manage whether each family had had Taro already. The flags are initialized with False. Inspect the babies in order. If the baby is a girl, print No, and nothing more is required. If the baby is a boy, check the flag of his family. If the flag is False, print Yes, and set the flag to True. If the flag is already True, print No. The operations so far can be implemented with for statements, if statements, and arrays.\n\nSample code (Python):\n```python\nn, m = map(int, input().split())\ntaro_exist = [False for i in range(n)]\nfor i in range(m):\n    a, b = input().split()\n    a = int(a) - 1\n    if b == 'F' or taro_exist[a]:\n        print('No')\n    else:\n        taro_exist[a] = True\n        print('Yes')\n```\n\n[END TEXT]\n \n\n", "problem_ids": ["abc371_b"]}, "abc304_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi is heading to AtCoder Land. There is a signboard in front of him, and he wants to determine whether it says \"AtCoder Land.\"\n\nYou are given two strings \\( S \\) and \\( T \\) separated by a space. Determine whether \\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\).\n\n**Constraints**\n\n- \\( S \\) and \\( T \\) are strings consisting of uppercase and lowercase English letters, with lengths between 1 and 10, inclusive.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nS T\n```\n\n**Output**\n\nIf \\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\), print \"Yes\"; otherwise, print \"No\".\n\n**Sample Input 1**\n```\nAtCoder Land\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n\\( S = \\text{\"AtCoder\"} \\) and \\( T = \\text{\"Land\"} \\).\n\n**Sample Input 2**\n```\nCodeQUEEN Land\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n\\( S \\) is not \"AtCoder\".\n\n**Sample Input 3**\n```\naTcodeR lANd\n```\n\n**Sample Output 3**\n```\nNo\n```\n\nUppercase and lowercase letters are distinguished.\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nIf you are new to learning programming, try Problem A \u201cWelcome to AtCoder\u201d from the practice contest, which provides sample code for each language. Also, explore the \u201cAtCoder Beginners Selection\u201d for more practice problems.\n\nReceive two strings as input, and implement a conditional branch to print the answer. In the conditional expression, compare strings and evaluate the logical sum of two conditions. Refer to the sample code below.\n\nSample code (Python):\n```python\ns, t = input().split()\nif s == \"AtCoder\" and t == \"Land\":\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\n", "problem_ids": ["abc358_a"]}, "abc304_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\nYou are given a horizontally written text. Convert it to vertical writing, filling spaces with `*`.\n\nYou are given \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\) consisting of lowercase English letters. Let \\( M \\) be the maximum length of these strings.\n\nPrint \\( M \\) strings \\( T_1, T_2, \\dots, T_M \\) that satisfy the following conditions:\n\n1. Each \\( T_i \\) consists of lowercase English letters and `*`.\n2. Each \\( T_i \\) does not end with `*`.\n3. For each \\( 1 \\leq i \\leq N \\), the following holds:\n    - For each \\( 1 \\leq j \\leq |S_i| \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) exists, and the concatenation of the \\( (N-i+1) \\)-th characters of \\( T_1, T_2, \\dots, T_{|S_i|} \\) in this order equals \\( S_i \\).\n    - For each \\( |S_i| + 1 \\leq j \\leq M \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) either does not exist or is `*`.\n\nHere, \\( |S_i| \\) denotes the length of the string \\( S_i \\).\n\nConstraints:\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is a string of lowercase English letters with length between 1 and 100, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\nOutput:\nPrint the answer in the following format:\n```\nT_1\nT_2\n\u22ee\nT_M\n```\n\nSample Input 1:\n```\n3\nabc\nde\nfghi\n```\n\nSample Output 1:\n```\nfda\ngeb\nh*c\ni\n```\n\nSample Input 2:\n```\n3\natcoder\nbeginner\ncontest\n```\n\nSample Output 2:\n```\ncba\noet\nngc\ntio\nend\nsne\nter\n*r\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        First, ignore the condition that \\(T_i\\) does not end with *. Initialize \\(T_1,T_2,\\dots,T_M\\) with a length-\\(N\\) string of *. For each \\(i\\) and \\(j\\), assign the \\(j\\)-th character of \\(S_i\\) to the \\((N-i+1)\\)-th character of \\(T_j\\). To satisfy the second condition, for each \\(T_i\\), remove the last character while it ends with *. \n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(map(len, S))\nT = [[\"*\"] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i][-1] == \"*\":\n        T[i].pop()\n    print(\"\".join(T[i]))\n```\n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(len(s) for s in S)\nT = [['*'] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i] and T[i][-1] == '*':\n        T[i].pop()\n    print(''.join(T[i]))\n}\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc366_b"]}, "abc305_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\nYou are given a horizontally written text. Convert it to vertical writing, filling spaces with `*`.\n\nYou are given \\( N \\) strings \\( S_1, S_2, \\dots, S_N \\) consisting of lowercase English letters. Let \\( M \\) be the maximum length of these strings.\n\nPrint \\( M \\) strings \\( T_1, T_2, \\dots, T_M \\) that satisfy the following conditions:\n\n1. Each \\( T_i \\) consists of lowercase English letters and `*`.\n2. Each \\( T_i \\) does not end with `*`.\n3. For each \\( 1 \\leq i \\leq N \\), the following holds:\n    - For each \\( 1 \\leq j \\leq |S_i| \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) exists, and the concatenation of the \\( (N-i+1) \\)-th characters of \\( T_1, T_2, \\dots, T_{|S_i|} \\) in this order equals \\( S_i \\).\n    - For each \\( |S_i| + 1 \\leq j \\leq M \\), the \\( (N-i+1) \\)-th character of \\( T_j \\) either does not exist or is `*`.\n\nHere, \\( |S_i| \\) denotes the length of the string \\( S_i \\).\n\nConstraints:\n- \\( N \\) is an integer between 1 and 100, inclusive.\n- Each \\( S_i \\) is a string of lowercase English letters with length between 1 and 100, inclusive.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\nOutput:\nPrint the answer in the following format:\n```\nT_1\nT_2\n\u22ee\nT_M\n```\n\nSample Input 1:\n```\n3\nabc\nde\nfghi\n```\n\nSample Output 1:\n```\nfda\ngeb\nh*c\ni\n```\n\nSample Input 2:\n```\n3\natcoder\nbeginner\ncontest\n```\n\nSample Output 2:\n```\ncba\noet\nngc\ntio\nend\nsne\nter\n*r\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        First, ignore the condition that \\(T_i\\) does not end with *. Initialize \\(T_1,T_2,\\dots,T_M\\) with a length-\\(N\\) string of *. For each \\(i\\) and \\(j\\), assign the \\(j\\)-th character of \\(S_i\\) to the \\((N-i+1)\\)-th character of \\(T_j\\). To satisfy the second condition, for each \\(T_i\\), remove the last character while it ends with *. \n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(map(len, S))\nT = [[\"*\"] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i][-1] == \"*\":\n        T[i].pop()\n    print(\"\".join(T[i]))\n```\n\nSample code (Python):\n```python\nN = int(input())\nS = [input() for _ in range(N)]\nM = max(len(s) for s in S)\nT = [['*'] * N for _ in range(M)]\nfor i in range(N):\n    for j in range(len(S[i])):\n        T[j][N - i - 1] = S[i][j]\nfor i in range(M):\n    while T[i] and T[i][-1] == '*':\n        T[i].pop()\n    print(''.join(T[i]))\n}\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc366_b"]}, "abc305_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nDefine the **score** of a sequence of positive integers \\( B = (B_1, B_2, \\dots, B_k) \\) as:\n\n\\[\n\\sum_{i=1}^{k-1} \\gcd(B_i, B_{i+1})\n\\]\n\nGiven a sequence of positive integers \\( A = (A_1, A_2, \\dots, A_N) \\), solve the following problem for \\( m = 1, 2, \\dots, N \\):\n\n- Find the sum of the scores of all non-empty subsequences of the sequence \\( (A_1, A_2, \\dots, A_m) \\), modulo 998244353. There are \\( 2^m - 1 \\) such subsequences. Two subsequences are distinguished if they are taken from different positions in the sequence, even if they coincide as sequences.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^5 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the answer for \\( m = i \\).\n\n**Sample Input 1**\n\n```\n3\n9 6 4\n```\n\n**Sample Output 1**\n\n```\n0\n3\n11\n```\n\n*Explanation*: \n\nConsider the case \\( m = 3 \\). Here are the non-empty subsequences of \\( (A_1, A_2, A_3) = (9, 6, 4) \\) and their scores:\n\n- \\( (9) \\): Score is 0.\n- \\( (6) \\): Score is 0.\n- \\( (4) \\): Score is 0.\n- \\( (9, 6) \\): Score is \\( \\gcd(9, 6) = 3 \\).\n- \\( (9, 4) \\): Score is \\( \\gcd(9, 4) = 1 \\).\n- \\( (6, 4) \\): Score is \\( \\gcd(6, 4) = 2 \\).\n- \\( (9, 6, 4) \\): Score is \\( \\gcd(9, 6) + \\gcd(6, 4) = 3 + 2 = 5 \\).\n\nTherefore, the answer for \\( m = 3 \\) is \\( 0 + 0 + 0 + 3 + 1 + 2 + 5 = 11 \\).\n\n**Sample Input 2**\n\n```\n5\n3 8 12 6 9\n```\n\n**Sample Output 2**\n\n```\n0\n1\n13\n57\n155\n```\n\n**Sample Input 3**\n\n```\n10\n47718 21994 74148 76721 98917 73766 29598 59035 69293 29127\n```\n\n**Sample Output 3**\n\n```\n0\n2\n14\n35\n97\n372\n866\n1859\n4273\n43287\n```\n\nSolution:\n\nHere is the translated editorial with all non-Python code converted to Python3:\n\n```python\ndef gcd(n, m):\n    while m:\n        n, m = m, n % m\n    return n\n\ndef euler_totient_function(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef compute_R(A):\n    max_A = max(A)\n    N = len(A)\n    \n    # Precompute divisors and Euler's totient function values\n    phi = [euler_totient_function(i) for i in range(max_A + 1)]\n    \n    s = [0] * (max_A + 1)\n    R = [0] * (N + 1)  # R_0 is already 0\n    \n    for i in range(1, N + 1):\n        a_i = A[i - 1]\n        # Computing R_i\n        R[i] = 2 * R[i - 1]\n        d = 1\n        while d * d <= a_i:\n            if a_i % d == 0:\n                # For divisor d\n                R[i] += phi[d] * s[d]\n                if d != a_i // d:\n                    # For divisor a_i // d\n                    R[i] += phi[a_i // d] * s[a_i // d]\n            d += 1\n\n        # Update s values for current a_i\n        d = 1\n        while d * d <= a_i:\n            if a_i % d == 0:\n                s[d] += 2 ** i\n                if d != a_i // d:\n                    s[a_i // d] += 2 ** i\n            d += 1\n\n    return R[1:]  # Return R_1 to R_N\n\n# Example usage with an array A\nA = [your_array_values_here]\nR_values = compute_R(A)\nprint(R_values)\n```\n\n\n \n\n", "problem_ids": ["arc185_e"]}, "abc305_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nAlice and Bob are playing a game with two positive integers \\( N \\) and \\( M \\), where \\( N < M \\). Each player has \\( N \\) cards numbered from 1 to \\( N \\). Alice starts the game, and they take turns playing one card from their hand onto the table. If, after a player plays a card, the sum of the numbers on the table is divisible by \\( M \\), the player who played the last card loses, and the other player wins. If all cards are played and the sum is never divisible by \\( M \\), Alice wins. Given \\( T \\) test cases, determine who will win (Alice or Bob) if both play optimally.\n\nConstraints:\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N < M \\leq 10^9 \\)\n\nInput:\n- The input consists of \\( T \\) test cases.\n- Each test case is described by two integers \\( N \\) and \\( M \\).\n\nOutput:\n- For each test case, output \"Alice\" if Alice wins or \"Bob\" if Bob wins when both players play optimally.\n\nSample Input:\n```\n8\n2 3\n3 6\n5 9\n45 58\n39 94\n36 54\n74 80\n61 95\n```\n\nSample Output:\n```\nAlice\nAlice\nBob\nBob\nAlice\nBob\nBob\nAlice\n```\n\nIn the first test case, both Alice and Bob have two cards: a 1 and a 2. Alice plays 1, and the sum is 1, which is not divisible by 3. Bob plays 1, making the sum 2, still not divisible by 3. Alice plays 2, making the sum 4, not divisible by 3. Bob plays 2, making the sum 6, which is divisible by 3, so Bob loses, and Alice wins. Alice wins regardless of Bob's strategy.\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 185\n\ndef mod_m_game(N, M):\n    # Calculate c\n    c = (N * (N + 1)) % M\n\n    # Determine if Alice loses or wins\n    if 1 <= c <= N:\n        return \"Bob wins\"\n    else:\n        return \"Alice wins\"\n\n# Example Usage\nN = 5\nM = 3\nresult = mod_m_game(N, M)\nprint(result)  # Output should be \"Bob wins\" or \"Alice wins\" based on the conditions\n```\n\nEditorial - AtCoder Regular Contest 185\n\nA - mod M Game 2 Editorial by evima\n\nFirst, focus on the moment when Alice plays her last card:\n\n- A player with two or more cards can avoid playing a losing card.\n- If Alice doesn't lose when playing her last card, she will win regardless of Bob's last move.\n\nDetermine if Alice loses with her last card using Bob\u2019s last card \\(b\\). The sum of the numbers on the cards played is \\(N(N+1) - b\\). We check if \\(N(N + 1) - b \\equiv 0 \\pmod{M}\\).\n\n1. If \\(1 \\leq (N(N+1) \\bmod M) \\leq N\\):\n   - Let \\(c = N(N + 1) \\bmod M\\). Bob can make his last card \\(b = c\\) by playing all cards except \\(c\\), leading to Alice's loss. Bob can achieve this by keeping \\(c\\) among his final cards.\n\n2. If \\(N(N + 1) - b\\) cannot be \\(0\\):\n   - Alice will not lose on her last card, leading to her victory.\n\nBob wins if \\(1 \\leq N(N + 1) \\bmod M \\leq N\\), otherwise Alice wins. This can be determined in \\(O(1)\\) time.\n \n\n", "problem_ids": ["arc185_a"]}, "abc305_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nAn election is being held with \\( N \\) candidates numbered \\( 1, 2, \\ldots, N \\). There are \\( K \\) votes, some of which have been counted so far. Up until now, candidate \\( i \\) has received \\( A_i \\) votes.\n\nAfter all ballots are counted, candidate \\( i \\) (\\( 1 \\leq i \\leq N \\)) will be elected if and only if the number of candidates who have received more votes than them is less than \\( M \\). There may be multiple candidates elected.\n\nFor each candidate, find the minimum number of additional votes they need from the remaining ballots to guarantee their victory regardless of how the other candidates receive votes. Formally, solve the following problem for each \\( i = 1,2,\\ldots,N \\).\n\nDetermine if there is a non-negative integer \\( X \\) not exceeding \\( K - \\displaystyle{\\sum_{i=1}^{N}} A_i \\) satisfying the following condition. If it exists, find the minimum possible such integer.\n\n- If candidate \\( i \\) receives \\( X \\) additional votes, then candidate \\( i \\) will always be elected.\n\n### Constraints\n\n- \\( 1 \\leq M \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq K \\leq 10^{12} \\)\n- \\( 0 \\leq A_i \\leq 10^{12} \\)\n- \\( \\displaystyle{\\sum_{i=1}^{N} A_i} \\leq K \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\n\nLet \\( C_i \\) be the minimum number of additional votes candidate \\( i \\) needs from the remaining ballots to guarantee their victory regardless of how other candidates receive votes. Print \\( C_1, C_2, \\ldots, C_N \\) separated by spaces.\n\nIf candidate \\( i \\) has already secured their victory, then let \\( C_i = 0 \\). If candidate \\( i \\) cannot secure their victory under any circumstances, then let \\( C_i = -1 \\).\n\n### Sample Input 1\n\n```\n5 2 16\n3 1 4 1 5\n```\n\n### Sample Output 1\n\n```\n2 -1 1 -1 0\n```\n\n14 votes have been counted so far, and 2 votes are left. The \\( C \\) to output is \\((2, -1, 1, -1, 0)\\). For example:\n- Candidate 1 can secure their victory by obtaining 2 more votes, while not by obtaining 1 more vote. Thus, \\( C_1 = 2 \\).\n- Candidate 2 can never (even if they obtain 2 more votes) secure their victory, so \\( C_2 = -1 \\).\n\n### Sample Input 2\n\n```\n12 1 570\n81 62 17 5 5 86 15 7 79 26 6 28\n```\n\n### Sample Output 2\n\n```\n79 89 111 117 117 74 112 116 80 107 117 106\n```\n\nSolution:\n\n```python\nfrom itertools import accumulate\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    rem = k - sum(a)\n\n    if n == m:\n        print(' '.join(['0'] * n))\n        return\n\n    ord = list(range(n))\n    ord.sort(key=lambda i: a[i])\n    b = sorted(a)\n    sumb = [0] + list(accumulate(b))\n\n    ans = [-1] * n\n    for i in range(n):\n        l, r = -1, rem + 1\n        while r - l > 1:\n            mid = (l + r) // 2\n            rid = next((idx for idx, val in enumerate(b) if val >= b[i] + mid + 1), n)\n            lid = n - m - (1 if i >= n - m else 0)\n            cnt = 0\n            if rid > lid:\n                cnt += (rid - lid) * (b[i] + mid + 1) - (sumb[rid] - sumb[lid])\n            if lid <= i < rid:\n                cnt -= 1\n            else:\n                cnt += mid\n            if cnt > rem:\n                r = mid\n            else:\n                l = mid\n        ans[ord[i]] = -1 if l == rem else r\n\n    print(' '.join(map(str, ans)))\n\nmain()\n```\n \n\n", "problem_ids": ["abc373_e"]}, "abc305_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\(N\\) boxes numbered from 1 to \\(N\\), and \\(N\\) balls numbered from 1 to \\(N\\).\n\nYou have assigned Snuke the following procedure as homework:\n\n1. Put each ball into any box he likes. Multiple balls can be placed in the same box, and there can be boxes without balls.\n\n2. For \\(i = 1, 2, \\ldots, N\\) in this order, perform the following operations:\n   - If box \\(i\\) contains no balls, do nothing.\n   - If box \\(i\\) contains balls, take all of them out and arrange them in a line in any order he likes. Let \\(k\\) be the number of balls taken out, and \\((x_1, x_2, \\ldots, x_k)\\) be the ball numbers in the line. For each \\(1 \\leq j \\leq k\\), put ball \\(x_j\\) into box \\(x_{j+1}\\). Here, \\(x_{k+1}\\) means \\(x_1\\). All these operations of putting balls into boxes happen simultaneously.\n\nHe claims that he has completed the homework and reports the final state to you. Specifically, he says that ball \\(i\\) is in box \\(A_i\\) after the procedure.\n\nYou doubt whether he has correctly performed the procedure. Determine whether the state he reported is a possible result of the procedure.\n\nThere are \\(T\\) test cases for each input.\n\n**Constraints**\n\n- \\(1 \\leq T \\leq 250000\\)\n- \\(1 \\leq N \\leq 250000\\)\n- \\(1 \\leq A_i \\leq N\\)\n- The sum of \\(N\\) over all test cases in each input is at most 250000.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA_1 A_2 \u22ef A_N\n```\n\n**Output**\n\nFor each test case, print \"Yes\" if the state Snuke reported is a possible result of the procedure, and \"No\" otherwise.\n\n**Sample Input**\n\n```\n5\n3\n1 1 1\n3\n2 2 2\n5\n1 2 3 4 5\n10\n8 3 8 10 1 5 3 1 6 4\n10\n1 5 1 2 4 8 8 6 7 3\n```\n\n**Sample Output**\n\n```\nYes\nNo\nYes\nNo\nYes\n```\n\nConsider the first test case: \nThe following steps yield the state Snuke reported, so the answer is \"Yes\".\n\n- Put balls 1, 2, 3 into boxes 1, 1, 2, respectively.\n- Take out the balls from box 1 and arrange them as (2, 1).\n  - Put ball 2 into box 1.\n  - Put ball 1 into box 2.\n- Take out the balls from box 2 and arrange them as (1, 3).\n  - Put ball 1 into box 3.\n  - Put ball 3 into box 1.\n- Take out the balls from box 3 and arrange them as (1).\n  - Put ball 1 into box 1.\n- Now, balls 1, 2, 3 are all in box 1.\n\nSolution:\n\n```\nEditorial - AtCoder Grand Contest 068\n\nC - Ball Redistribution Editorial by evima\n\nLet\u2019s consider the operations in reverse order. Consider a graph where we draw an edge from \\(i\\) to \\(A_i\\). Focus on vertex \\(N\\). First, consider whether vertex \\(N\\) is included in a cycle. \n\nIf vertex \\(N\\) is included in a cycle: The balls in this cycle correspond to those that were in box \\(N\\) before the operation. We break this cycle and add edges from the vertices on the cycle to vertex \\(N\\).\n\nIf vertex \\(N\\) is not included in a cycle: Some cycle corresponds to the balls that were in box \\(N\\) before the operation. We break this cycle and add edges from the vertices on the cycle to vertex \\(N\\). Here, it\u2019s also permissible to assume that box \\(N\\) was empty and change nothing.\n\nIn either case, if there exists a \u201cchild\u201d of vertex \\(N\\) (a vertex that extends an edge to vertex \\(N\\) and is not included in a cycle), it\u2019s impossible to reverse the operation, and we can conclude that the answer is No. When vertex \\(N\\) is not included in a cycle, there is freedom in choosing which cycle to break, but here, let\u2019s suppose we use the cycle in the connected component that includes vertex \\(N\\).\n\nLet\u2019s consider the conditions under which we can complete the reversal for \\(i = N, N-1, \\cdots, 1\\) when the operation can only be reversed in this form. Then, as a sufficient condition, we obtain that the following property holds for each vertex \\(v\\):\n\nLet \\(u_1, \\cdots, u_k\\) be the children of \\(v\\). Let \\(w_i\\) be the largest numbered vertex in the subtree rooted at \\(u_i\\). Then, \\(v < w_i\\).\n\nIn fact, this condition is also a necessary condition in the original problem (without limiting the form of the reversal operation). Therefore, by simply checking this condition, we can solve the problem. We will show that this condition is necessary. Take a vertex \\(v\\) that does not satisfy the condition and its child \\(u\\). No matter how we reverse the operations for \\(i = N, N-1, \\cdots, v + 1\\), they will not affect the subtree rooted at vertex \\(u\\). Then, consider \\(i = v\\), and \\(v\\) will have a child \\(u\\), so the reversal fails. This shows the necessity. The condition can be checked in \\(O(N)\\) time. Sample Solution (Python) Bonus: The number of valid \\(A\\) is \\((2N - 1)!!\\). Try proving it.\n```\n\nTranslated Sample Solution from C++ to Python3:\n\n```python\ndef is_valid_configuration(n, a):\n    # a is the array A with n elements\n    import sys\n    sys.setrecursionlimit(200000)\n    \n    # Graph will store the graph of connections\n    graph = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        graph[a[i - 1]].append(i)\n    \n    def dfs(v):\n        if dp[v] != -1:\n            return dp[v]\n        res = v\n        for u in graph[v]:\n            res = max(res, dfs(u))\n        dp[v] = res\n        return res\n\n    dp = [-1] * (n + 1)\n    # Try to validate the condition for every vertex\n    for v in range(1, n + 1):\n        for u in graph[v]:\n            if dfs(u) <= v:\n                return False\n    return True\n\n# Example usage\nn = 5\na = [2, 3, 4, 5, 2]\nprint(is_valid_configuration(n, a))  # Change this input to test different cases\n```\n\n \n\n", "problem_ids": ["agc068_c"]}, "abc306_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) rest areas around a lake. The rest areas are numbered \\( 1, 2, \\ldots, N \\) in clockwise order. It takes \\( A_i \\) steps to walk clockwise from rest area \\( i \\) to rest area \\( i+1 \\) (where rest area \\( N+1 \\) refers to rest area \\( 1 \\)).\n\nThe minimum number of steps required to walk clockwise from rest area \\( s \\) to rest area \\( t \\) (\\( s \\neq t \\)) must be a multiple of \\( M \\).\n\nDetermine the number of possible pairs \\((s, t)\\).\n\n**Constraints**\n\n- All input values are integers\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 10^6 \\)\n\n**Input Format**\n\nThe input is given from the standard input in the following format:\n\n```\nN M\nA_1 A_2 \\ldots A_N\n```\n\n**Output Format**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n4 3\n2 1 4 3\n```\n\n**Sample Output 1**\n```\n4\n```\n\n**Explanation**\n\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 2 is 2, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 3 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 4 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 3 is 1, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 4 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 1 is 8, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 4 is 4, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 1 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 2 is 9, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 1 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 2 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 3 is 6, which is a multiple of 3.\n\nThus, there are four possible pairs \\( (s, t) \\).\n\n**Sample Input 2**\n```\n2 1000000\n1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n9 5\n9 9 8 2 4 4 3 5 3\n```\n\n**Sample Output 3**\n```\n11\n```\n\nSolution:\n\n```python\n# Here is the cleaned version of the editorial:\n\n# For convenience, reassign the index \\((k-1)\\) to rest area \\(k\\) to treat indices from \\(0\\) through \\((N-1)\\). Consider the following array. Let \\(R_i\\) be the number of steps, modulo \\(M\\), required to travel from rest area \\(0\\) to rest area \\(i \\% N\\) as the \\(i\\)-th rest area to encounter. Precalculate these values for \\(i\\) from \\(0\\) through \\(2N-1\\). For example, if \\(A=(1,2,3,4)\\) and \\(M=6\\)...ultiple of \\(M\\)?\n\n# If \\(s<t\\), it holds when \\(R_s = R_t\\). This is equivalent to \\(R_{N+s}=R_{N+t}\\). If \\(s>t\\), it holds when \\(R_s = R_{N+t}\\).\n\n# Therefore, it is sufficient to solve the following problem:\n\n# Find the sum of the following value for \\(i=N,N+1,\\dots,2N-1\\). How many elements among \\(R_{i-N+1},R_{i-N+2},\\dots,R_{i-1}\\) are equal to \\(R_i\\)?\n\n# Intuitively, we are summing up the number of rest areas \\(i \\% N\\) to which the minimum steps required is a multiple of \\(M\\), over \\(i=N,N+1,\\dots,2N-1\\). This problem can be solved as follows:\n\n# First, let \\(B=(B[0],B[1],\\dots,B[M-1])\\) be the array of occurrences of \\(k\\) between \\(0\\) and \\(M-1\\) in \\(R_0\\) through \\(R_{N-1}\\). For \\(i = N,N+1,\\dots,2N-1\\), repeat the following:\n\n# Decrease \\(B[R_{i-N}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i-1\\).\n\n# Add \\(B[R_{i}]\\) Increase \\(B[R_{i}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i\\).\n\n# Translated sample code (Python 3):\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    r = [0]\n    for i in range(2 * n):\n        r.append((r[-1] + a[i % n]) % m)\n    b = [0] * m\n    for i in range(n):\n        b[r[i]] += 1\n    res = 0\n    for i in range(n, 2 * n):\n        b[r[i - n]] -= 1\n        res += b[r[i]]\n        b[r[i]] += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc367_d"]}, "abc306_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 350 points\n\nProblem Statement:\n\nThe coordinate plane is covered with 2\u00d71 tiles. The tiles are laid out according to the following rules:\n\n- For an integer pair (i, j), the square \\(A_{i,j} = \\{(x, y) \\mid i \\leq x \\leq i+1 \\wedge j \\leq y \\leq j+1\\}\\) is contained in one tile.\n- When i + j is even, \\(A_{i,j}\\) and \\(A_{i+1,j}\\) are contained in the same tile.\n\nTiles include their boundaries, and no two different tiles share a positive area.\n\nNear the origin, the tiles are laid out as follows:\n\n![Tile Layout Image](https://img.atcoder.jp/abc359/7ab121cd550fa78b43845d4ffd7f74b3.png)\n\nTakahashi starts at the point (S_x + 0.5, S_y + 0.5) on the coordinate plane. He can repeat the following move as many times as he likes:\n\n- Choose a direction (up, down, left, or right) and a positive integer n. Move n units in that direction.\n\nEach time he enters a tile, he pays a toll of 1.\n\nFind the minimum toll he must pay to reach the point (T_x + 0.5, T_y + 0.5).\n\nConstraints:\n- 0 \u2264 S_x \u2264 2 \u00d7 10^16\n- 0 \u2264 S_y \u2264 2 \u00d7 10^16\n- 0 \u2264 T_x \u2264 2 \u00d7 10^16\n- 0 \u2264 T_y \u2264 2 \u00d7 10^16\n- All input values are integers.\n\nInput:\n\nThe input is given from Standard Input in the following format:\n```\nS_x S_y\nT_x T_y\n```\n\nOutput:\n\nPrint the minimum toll Takahashi must pay.\n\nSample Input 1:\n```\n5 0\n2 5\n```\n\nSample Output 1:\n```\n5\n```\n\nFor example, Takahashi can pay a toll of 5 by moving as follows:\n\n![Movement Image](https://img.atcoder.jp/abc359/187d19c48a9a0fcedb2602063689ee77.png)\n\n- Move left by 1. Pay a toll of 0.\n- Move up by 1. Pay a toll of 1.\n- Move left by 1. Pay a toll of 0.\n- Move up by 3. Pay a toll of 3.\n- Move left by 1. Pay a toll of 0.\n- Move up by 1. Pay a toll of 1.\n\nIt is impossible to reduce the toll to 4 or less, so print 5.\n\nSample Input 2:\n```\n3 1\n4 1\n```\n\nSample Output 2:\n```\n0\n```\n\nThere are cases where no toll needs to be paid.\n\nSample Input 3:\n```\n2552608206527595 5411232866732612\n771856005518028 7206210729152763\n```\n\nSample Output 3:\n```\n1794977862420151\n```\n\nNote that the value to be output may exceed the range of a 32-bit integer.\n\nSolution:\n\n```\nHere is the cleaned-up version of the editorial:\n\n---\n\nFor simplicity, we may assume that the start and goal are in the left half of a tile. If \\(S_x + S_y\\) is odd, subtract \\(1\\) from \\(S_x\\). One can travel freely between the left and right halves, so traveling from the left half of one tile to another is a complete move. By paying a toll of \\(1\\), one can make either of these two moves:\n\n1. Move by \\(1\\) vertically and by \\(1\\) horizontally.\n2. Move by \\(2\\) horizontally.\n\nSuppose one could travel from \\((S_x, S_y)\\) to \\((T_x, T_y)\\) by making the first move \\(a\\) times and the second \\(b\\) times. The following conditions must hold:\n\n\\(\\lvert S_y - T_y \\rvert \\leq a\\)\n\n\\(\\lvert S_x - T_x \\rvert \\leq a + 2b\\)\n\n\\(a > 0\\) or \\(S_x - T_x \\equiv 2b \\pmod{4}\\)\n\nConversely, if a pair of non-negative integers \\((a, b)\\) satisfies these conditions, then one can make the specified moves to travel from \\((S_x, S_y)\\) to \\((T_x, T_y)\\).\n\nWe aim to minimize the toll \\(a + b\\) while respecting \\((0 \\leq a, 0 \\leq b)\\) and the above conditions. With \\(0 \\leq b\\) and \\(\\lvert S_y - T_y \\rvert \\leq a\\), it is necessary that \\(\\lvert S_y - T_y \\rvert \\leq a + b\\). \n\nAdditionally, \\(\\frac{\\lvert S_x - T_x \\rvert + \\lvert S_y - T_y \\rvert}{2} \\leq a + b\\).\n\nConversely, \\((a, b) = \\left( \\lvert S_y - T_y \\rvert, \\max\\left\\lbrace 0, \\frac{\\lvert S_x - T_x \\rvert - \\lvert S_y - T_y \\rvert}{2} \\right\\rbrace \\right)\\) always satisfies all the conditions, thus ensuring one or both equations hold as an equality.\n\nHence, the minimum toll is:\n\n\\[\\max\\left\\lbrace \\lvert S_y - T_y \\rvert, \\frac{\\lvert S_x - T_x \\rvert + \\lvert S_y - T_y \\rvert}{2} \\right\\rbrace = \\frac{\\lvert S_y - T_y \\rvert + \\max \\lbrace \\lvert S_x - T_x \\rvert, \\lvert S_y - T_y \\rvert \\rbrace}{2}\\].\n\nBelow is the sample code:\n\n```python\nSx, Sy = map(int, input().split())\nTx, Ty = map(int, input().split())\n\nif (Sx + Sy) % 2 == 1:\n    Sx -= 1\nif (Tx + Ty) % 2 == 1:\n    Tx -= 1\n\nDx = abs(Sx - Tx)\nDy = abs(Sy - Ty)\n\nprint((Dy + max(Dx, Dy)) // 2)\n```\n\n---\n```\n \n\n", "problem_ids": ["abc359_c"]}, "abc306_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given two sequences of length \\( N \\): \\( D = (D_1, D_2, \\dots, D_N) \\) and \\( P = (P_1, P_2, \\dots, P_N) \\).\n\nProcess \\( Q \\) queries in the order they are given. Each query is given in the following format:\n\n- \\( c \\, x \\, y \\): Change \\( D_c \\) to \\( x \\) and \\( P_c \\) to \\( y \\). Then, solve the following problem and print the answer.\n\nThere are \\( N \\) jobs numbered \\( 1 \\) to \\( N \\).\nStarting from today (consider this as day \\( 1 \\)), you will choose and complete one job per day for \\( N \\) days.\nIf you complete job \\( i \\) on or before day \\( D_i \\), you will receive a reward of \\( P_i \\). (If you do not complete it by day \\( D_i \\), you get nothing.)\nFind the maximum total reward you can achieve by choosing the optimal order of completing the jobs.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq Q \\leq 10^5 \\)\n- \\( 1 \\leq D_i \\leq N \\)\n- \\( 1 \\leq P_i \\leq 10^9 \\)\n- \\( 1 \\leq c \\leq N \\)\n- \\( 1 \\leq x \\leq N \\)\n- \\( 1 \\leq y \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format. Here, \\( \\mathrm{query}_i \\) denotes the \\( i \\)-th query.\n\n```\nN Q\nD_1 D_2 \\dots D_N\nP_1 P_2 \\dots P_N\n\\mathrm{query}_1\n\\mathrm{query}_2\n\\vdots\n\\mathrm{query}_Q\n```\n\nEach query is given in the following format.\n\n```\nc x y\n```\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n\n```\n3 2\n1 2 3\n3 6 3\n3 1 4\n2 3 9\n```\n\n**Sample Output 1**\n\n```\n10\n13\n```\n\nThe first query is as follows:\n\n- Update \\( D_3 \\) to \\( 1 \\) and \\( P_3 \\) to \\( 4 \\). Now, \\( D = (1, 2, 1) \\) and \\( P = (3, 6, 4) \\).\n- In the subproblem, one optimal procedure is to complete job \\( 3 \\) on day \\( 1 \\), job \\( 2 \\) on day \\( 2 \\), and job \\( 1 \\) on day \\( 3 \\). The total reward is \\( 10 \\), so print \\( 10 \\).\n\nThe second query is as follows:\n\n- Update \\( D_2 \\) to \\( 3 \\) and \\( P_2 \\) to \\( 9 \\). Now, \\( D = (1, 3, 1) \\) and \\( P = (3, 9, 4) \\).\n- In the subproblem, one optimal procedure is to complete job \\( 3 \\) on day \\( 1 \\), job \\( 1 \\) on day \\( 2 \\), and job \\( 2 \\) on day \\( 3 \\). The total reward is \\( 13 \\), so print \\( 13 \\).\n\n**Sample Input 2**\n\n```\n5 1\n1 2 3 4 5\n1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1000000000\n```\n\n**Sample Output 2**\n\n```\n5000000000\n```\n\n**Sample Input 3**\n\n```\n10 10\n6 2 4 1 5 1 6 6 5 3\n45 65 71 52 86 52 48 60 40 98\n5 6 5\n8 4 34\n6 7 83\n1 3 21\n7 5 85\n7 4 51\n8 2 81\n2 7 54\n6 1 5\n8 6 30\n```\n\n**Sample Output 3**\n\n```\n394\n379\n462\n457\n459\n414\n443\n479\n401\n396\n```\n\nSolution:\n\nHere is the cleaned-up version of the coding problem editorial:\n\n---\n\nThere are various solutions for this problem, including one that utilizes properties of a matroid. In this editorial, we introduce an approach that formalizes the problem as a cost-flow problem.\n\nThe problem involves preprocessing using segment-tree divide-and-conquer. For offline queries, you can simplify them using segment-tree divide-and-conquer. Queries consist of inserting tasks into a set and removing the last task inserted. Segment-tree divide-and-conquer helps manage these queries efficiently by converting removal queries to undo queries, maintaining computational efficiency.\n\nA segment tree is prepared to manage the timeline of queries. Each node of the segment tree stores a vector that manages elements. After preprocessing, elements are inserted into the segment tree nodes, and a DFS is performed to process these nodes. The complexity is \\(\\mathrm{O}(Q \\log T f(n))\\), with \\(Q\\) as the number of queries, \\(T\\) as the maximum time, and \\(\\mathrm{O}(f(n))\\) as the complexity of insertion and undo queries.\n\nFormalizing the problem as a cost-flow problem, insertions are represented as cost-flow in a graph. The problem is simplified to one kind of query: inserting a new task and printing the answer to the subproblem. If a negative cycle exists when an edge is added, remove the negative cycle with the smallest cost to maintain optimal flow in the graph.\n\nThis cost-flow problem can be rephrased using operations on task sets, representing graph flows with task insertions. Tasks inserted into the set \\(X\\) can potentially fulfill the deadlines. Operations for updating task sets are derived from negative cycle removal in the cost-flow graph.\n\nUsing Hall\u2019s marriage theorem and segment trees, a data structure is constructed to manage task sets efficiently, supporting task insertion and validity checks. The problem solution operates within \\(\\mathrm{O}((N + Q) \\log Q \\log N)\\) time, which is efficient.\n\nBonus: There\u2019s an alternative \\(\\mathrm{O}((N + Q) \\log N)\\) solution the author holds but hasn\u2019t fully proven, left as an exercise to the reader.\n\n---\n \n\n", "problem_ids": ["abc363_g"]}, "abc306_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\n", "problem_ids": ["abc368_c"]}, "abc306_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nThere is a grid with \\( N \\) rows and \\( N \\) columns. Let \\( (i, j) \\) \\((1 \\leq i \\leq N, 1 \\leq j \\leq N)\\) denote the cell at the \\( i \\)-th row from the top and the \\( j \\)-th column from the left. Each cell is initially painted red or blue, with cell \\( (i, j) \\) being red if \\( c_{i,j} = R \\) and blue if \\( c_{i,j} = B \\). You want to change the colors of some cells to purple so that the following two conditions are simultaneously satisfied:\n\n- **Condition 1:** You can move from cell \\( (1, 1) \\) to cell \\( (N, N) \\) by only passing through cells that are red or purple.\n- **Condition 2:** You can move from cell \\( (1, N) \\) to cell \\( (N, 1) \\) by only passing through cells that are blue or purple.\n\nHere, \"You can move\" means that you can reach the destination from the starting point by repeatedly moving to a horizontally or vertically adjacent cell of the relevant colors.\n\nWhat is the minimum number of cells that must be changed to purple to satisfy these conditions?\n\n## Constraints\n\n- \\( 3 \\leq N \\leq 500 \\)\n- Each \\( c_{i,j} \\) is \\( R \\) or \\( B \\).\n- \\( c_{1,1} \\) and \\( c_{N,N} \\) are \\( R \\).\n- \\( c_{1,N} \\) and \\( c_{N,1} \\) are \\( B \\).\n- \\( N \\) is an integer.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nc_{1,1}c_{1,2}\\cdots c_{1,N}\nc_{2,1}c_{2,2}\\cdots c_{2,N}\n\u22ee\nc_{N,1}c_{N,2}\\cdots c_{N,N}\n```\n\n## Output\n\nPrint the answer.\n\n## Sample Input 1\n\n```\n5\nRBRBB\nRBRRR\nRRRBR\nRBBRB\nBBRBR\n```\n\n## Sample Output 1\n\n```\n3\n```\n\nAs shown in the figure below, changing cells \\( (1, 3) \\), \\( (3, 2) \\), \\( (4, 5) \\) to purple satisfies the conditions.\n\n## Sample Input 2\n\n```\n5\nRBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBR\n```\n\n## Sample Output 2\n\n```\n7\n```\n\nAs shown in the figure below, changing cells \\( (1, 2) \\), \\( (2, 2) \\), \\( (2, 3) \\), \\( (3, 3) \\), \\( (3, 4) \\), \\( (4, 4) \\), \\( (4, 5) \\) to purple satisfies the conditions.\n\n## Sample Input 3\n\n```\n10\nRRBBBBBBBB\nBRRBBBBBBB\nBBRRBBBBBB\nBBBRRBBBBB\nBBBBRRBBBB\nBBBBBRRBBB\nBBBBBBRRBB\nBBBBBBBRRB\nBBBBBBBBRR\nBBBBBBBBBR\n```\n\n## Sample Output 3\n\n```\n2\n```\n\n## Sample Input 4\n\n```\n17\nRBBRRBRRRRRBBBBBB\nBBRBRBRRBRRBRRBBR\nBRBRBBBRBBRBBRBBB\nRBRRBBBBBBRRBRRRR\nRRRRRBRBRRRBBRBBR\nRRRRRBRRBRBBRRRBB\nBBBRRRBRBRBBRRRBB\nBBRRRBRBBBRBRRRBR\nRRBBBBBBBBBBBRBRR\nRRRBRRBRBRBRBRBBB\nRRBRRRRBRBRRBRBBR\nRRRBBRBRBBBRBBRBR\nBBRBBRRBRRRBBRBBB\nBBBRBRRRRRRRBBRBB\nRRRRRBRBRBBRRBRRR\nBRRRRBBBRRRBRRBBB\nBBRRBBRRRBBBRBBBR\n```\n\n## Sample Output 4\n\n```\n8\n```\n\nSolution:\n\n```python\n[BEGIN TEXT]\n**Editorial - AtCoder Regular Contest 177**\n\n**C - Routing Editorial by evima**\n\n**Step 1:** Consider solving the Sample Input 1 manually:  \nGrid:  \n5  \nRBRBB  \nRBRRR  \nRRRBR  \nRBBRB  \nBBRBR  \n\nThe problem involves these conditions:  \n1. Move from top-left to bottom-right only through red or purple cells.  \n2. Move from top-right to bottom-left only through blue or purple cells.  \n\nDivide the grid; red cells represent only the left side painted, and blue cells represent only the right side painted. Purple cells are where both sides are painted.\n\n**Operations:**  \n- Blue \u2192 Purple: Paint an unpainted cell in the left grid.  \n- Red \u2192 Purple: Paint an unpainted cell in the right grid.\n\n**Satisfying Conditions:**  \n- Condition 1 requires one \"Blue \u2192 Purple\" operation.  \n- Condition 2 requires two \"Red \u2192 Purple\" operations.  \n\nThe answer is \\(1+2=3\\).\n\n**Step 2:** For the general case, divide the grid and consider red and blue independently. Solve for red, then add results.  \n\n**Properties:**  \n- Minimum cells to repaint red = minimum white cells passed from top-left to bottom-right.  \nLet \\(a\\) be cells repainted red, and \\(b\\) be white cells passed.  \n- \\(b \\geq a\\): A path through \\(b\\) white cells can be repainted to move.  \n- \\(b \\leq a\\): A method with \\(a\\) repaintings moves without more than \\(a\\) white cells.  \nThus, \\(a = b\\).\n\n**Find Minimum White Cells Passed:**  \nReduce to shortest path problem:  \n- Each cell is a vertex; cost is 1 for white and 0 otherwise.  \n- Use Dijkstra\u2019s algorithm (\\(O(N^2 \\log N)\\) time). Constraint \\(N \\leq 500\\).\n\n**Sample Implementation (Python 3):**\n```python\nimport heapq\n\nN = int(input())\nC = [input().strip() for _ in range(N)]\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ndef solve(sx, sy, gx, gy, target):\n    dist = [[float('inf')] * N for _ in range(N)]\n    dist[sx][sy] = 0\n    used = [[False] * N for _ in range(N)]\n    queue = [(0, sx, sy)]\n\n    while queue:\n        cost, ax, ay = heapq.heappop(queue)\n        if used[ax][ay]:\n            continue\n        used[ax][ay] = True\n        for i in range(4):\n            bx = ax + dx[i]\n            by = ay + dy[i]\n            if 0 <= bx < N and 0 <= by < N:\n                new_cost = cost + (0 if C[bx][by] == target else 1)\n                if dist[bx][by] > new_cost:\n                    dist[bx][by] = new_cost\n                    heapq.heappush(queue, (new_cost, bx, by))\n\n    return dist[gx][gy]\n\ndist1 = solve(0, 0, N-1, N-1, 'R')\ndist2 = solve(0, N-1, N-1, 0, 'B')\nprint(dist1 + dist2)\n```\n[END TEXT]\n```\n \n\n", "problem_ids": ["arc177_c"]}, "abc307_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is an \\( N \\times N \\) grid, where the cell at the \\( i \\)-th row from the top and the \\( j \\)-th column from the left contains the integer \\( N \\times (i-1) + j \\).\n\nOver \\( T \\) turns, integers will be announced. On Turn \\( i \\), the integer \\( A_i \\) is announced, and the cell containing \\( A_i \\) is marked. Determine the turn on which Bingo is achieved for the first time. If Bingo is not achieved within \\( T \\) turns, print \\(-1\\).\n\nHere, achieving Bingo means satisfying at least one of the following conditions:\n- There exists a row in which all \\( N \\) cells are marked.\n- There exists a column in which all \\( N \\) cells are marked.\n- There exists a diagonal line (from top-left to bottom-right or from top-right to bottom-left) in which all \\( N \\) cells are marked.\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2000 \\)\n- \\( 1 \\leq T \\leq \\min(N^2, 200000) \\)\n- \\( 1 \\leq A_i \\leq N^2 \\)\n- \\( A_i \\neq A_j \\) if \\( i \\neq j \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN T\nA_1 A_2 \\ldots A_T\n```\n\n**Output:**\n\nIf Bingo is achieved within \\( T \\) turns, print the turn number on which Bingo is achieved for the first time; otherwise, print \\(-1\\).\n\n**Sample Input 1:**\n\n```\n3 5\n5 1 8 9 7\n```\n\n**Sample Output 1:**\n\n```\n4\n```\n\n*Explanation:*\n\nThe state of the grid changes as follows. Bingo is achieved for the first time on Turn 4.\n\n**Sample Input 2:**\n\n```\n3 5\n4 2 9 7 5\n```\n\n**Sample Output 2:**\n\n```\n-1\n```\n\n*Explanation:*\n\nBingo is not achieved within five turns, so print -1.\n\n**Sample Input 3:**\n\n```\n4 12\n13 9 6 5 2 7 16 14 8 3 10 11\n```\n\n**Sample Output 3:**\n\n```\n9\n```\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 355: C - Bingo 2\n\nFor each row, column, or (anti)diagonal line, count the number of marked squares. Update only the counts for lines containing the current square. Check these lines to see if Bingo is achieved. With at most four lines per square, this is done in \\(O(1)\\) time. The overall time complexity is \\(O(N+T)\\).\n\nSample code:\n\n```python\nN, T = map(int, input().split())\nA = list(map(lambda x: int(x) - 1, input().split()))\nrow = [0] * N\ncol = [0] * N\ndiag = [0] * 2\n\nfor i in range(T):\n    x = A[i] // N\n    y = A[i] % N\n\n    # row\n    row[x] += 1\n    if row[x] == N:\n        print(i + 1)\n        exit()\n\n    # column\n    col[y] += 1\n    if col[y] == N:\n        print(i + 1)\n        exit()\n\n    # diagonal\n    if x == y:\n        diag[0] += 1\n        if diag[0] == N:\n            print(i + 1)\n            exit()\n\n    # anti-diagonal\n    if x + y == N - 1:\n        diag[1] += 1\n        if diag[1] == N:\n            print(i + 1)\n            exit()\n\nprint(-1)\n```\n```\n \n\n", "problem_ids": ["abc355_c"]}, "abc307_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 350 points\n\n**Problem Statement**\n\nYou are given a string \\( S \\) of length \\( N \\). You are also given \\( Q \\) queries, which you should process in order.\n\nThe \\( i \\)-th query is as follows:\n- Given an integer \\( X_i \\) and a character \\( C_i \\), replace the \\( X_i \\)-th character of \\( S \\) with \\( C_i \\). Then, print the number of times the string \"ABC\" appears as a substring in \\( S \\).\n\nHere, a **substring** of \\( S \\) is a string obtained by deleting zero or more characters from the beginning and zero or more characters from the end of \\( S \\). For example, \"ab\" is a substring of \"abc\", but \"ac\" is not a substring of \"abc\".\n\n**Constraints**\n\n- \\( 3 \\le N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le Q \\le 2 \\times 10^5 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of uppercase English letters.\n- \\( 1 \\le X_i \\le N \\)\n- \\( C_i \\) is an uppercase English letter.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN Q\nS\nX_1 C_1\nX_2 C_2\n\\vdots\nX_Q C_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (1 \u2264 \\( i \\) \u2264 \\( Q \\)) should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n```\n7 4\nABCDABC\n4 B\n3 A\n5 C\n4 G\n```\n\n**Sample Output 1**\n```\n2\n1\n1\n0\n```\n\nAfter processing each query, \\( S \\) becomes as follows:\n- After the first query: \\( S = \\) \"ABCBABC\". In this string, \"ABC\" appears twice as a substring.\n- After the second query: \\( S = \\) \"ABABABC\". In this string, \"ABC\" appears once as a substring.\n- After the third query: \\( S = \\) \"ABABCBC\". In this string, \"ABC\" appears once as a substring.\n- After the fourth query: \\( S = \\) \"ABAGCBC\". In this string, \"ABC\" appears zero times as a substring.\n\n**Sample Input 2**\n```\n3 3\nABC\n1 A\n2 B\n3 C\n```\n\n**Sample Output 2**\n```\n1\n1\n1\n```\n\nThere are cases where \\( S \\) does not change through processing a query.\n\n**Sample Input 3**\n```\n15 10\nBBCCBCACCBACACA\n9 C\n11 B\n5 B\n11 B\n4 A\n8 C\n8 B\n5 B\n7 B\n14 B\n```\n\n**Sample Output 3**\n```\n0\n0\n0\n0\n1\n1\n2\n2\n1\n1\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nC - Count ABC Again Editorial by en_translator\n\nIf you ignore the constraints, the following solution is valid:\n\nModify the \\(X_i\\)-th character of \\(S\\) to \\(C_i\\). Inspect the \\((N-2)\\) length-\\(3\\) substrings of \\(S\\), check if each coincides with ABC, and print the number of such substrings.\n\nHowever, \\(N\\) and \\(Q\\) can become as large as \\(2\\times 10^5\\), so this solution would result in TLE (Time Limit Exceeded). Now notice that modifying one character of \\(S\\) changes at most three length-\\(3\\) substrings of \\(S\\). For example, suppose that \\(S=\\) ABCDEFGHI has become \\(S=\\) ABCZEFGI. Before the modification, the length-\\(3\\) substrings of \\(S\\) were:\n\nABC, BCD, CDE, DEF, EFG, FGH, GHI.\n\nAfter the modification, it has become:\n\nABC, BCZ, CZE, ZEF, EFG, FGH, GHI.\n\nAmong them, only three substrings have changed. In general, at most three length-\\(3\\) substrings will change. Therefore, it is sufficient to inspect only three substrings that possibly changes, count the number of ABC before and after modifications, and find the answer after the modification based on the difference and the count before the modification. The complexity is \\(O(N+Q)\\).\n\nSample code (Python3)\n```python\nN, Q = map(int, input().split())\nS = list(input())\nans = 0\nfor i in range(N - 2):\n    if S[i] == \"A\" and S[i + 1] == \"B\" and S[i + 2] == \"C\":\n        ans += 1\nfor _ in range(Q):\n    t, c = input().split()\n    t = int(t) - 1\n    for k in range(3):\n        idx = t - k\n        if 0 <= idx and idx + 2 < N:\n            if S[idx] == \"A\" and S[idx + 1] == \"B\" and S[idx + 2] == \"C\":\n                ans -= 1\n    S[t] = c\n    for k in range(3):\n        idx = t - k\n        if 0 <= idx and idx + 2 < N:\n            if S[idx] == \"A\" and S[idx + 1] == \"B\" and S[idx + 2] == \"C\":\n                ans += 1\n    print(ans)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc372_c"]}, "abc307_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) boxes numbered from 1 to \\( N \\) and \\( N \\) items also numbered from 1 to \\( N \\). Item \\( i \\) (\\( 1 \\leq i \\leq N \\)) is located in box \\( A_i \\) and has a weight of \\( W_i \\).\n\nYou can repeatedly perform the operation of selecting an item and moving it to another box. The cost of moving an item with weight \\( w \\) is \\( w \\).\n\nFind the minimum total cost required to ensure that each box contains exactly one item.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\) (\\( 1 \\leq i \\leq N \\))\n- \\( 1 \\leq W_i \\leq 10^4 \\) (\\( 1 \\leq i \\leq N \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given in the following format from Standard Input:\n```\nN\nA_1 A_2 \\ldots A_N\nW_1 W_2 \\ldots W_N\n```\n\n**Output**\n\nPrint the minimum total cost required to make each box contain exactly one item.\n\n**Sample Input 1**\n```\n5\n2 2 3 3 5\n33 40 2 12 16\n```\n\n**Sample Output 1**\n```\n35\n```\n\n*Explanation*: With the following two moves, you can make each box contain exactly one item:\n1. Move item 1 from box 2 to box 1. The cost is 33.\n2. Move item 3 from box 3 to box 4. The cost is 2.\n\nThe total cost of these two moves is 35. It is impossible to make each box contain exactly one item with a cost less than 35, so print 35.\n\n**Sample Input 2**\n```\n12\n3 6 7 4 12 4 8 11 11 1 8 11\n3925 9785 9752 3587 4013 1117 3937 7045 6437 6208 3391 6309\n```\n\n**Sample Output 2**\n```\n17254\n```\n\n\nSolution:\n\n```python\n# Python3 translation of the given C++ code\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n\n    max_weight = [0] * n\n    for i in range(n):\n        a[i] -= 1\n        max_weight[a[i]] = max(max_weight[a[i]], w[i])\n\n    sum_w = sum(w)\n    sum_max = sum(max_weight)\n    print(sum_w - sum_max)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc360_c"]}, "abc307_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Your task is to find the value of:\n\n\\[\n\\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} \\left\\lfloor \\frac{\\max(A_i, A_j)}{\\min(A_i, A_j)} \\right\\rfloor\n\\]\n\nHere, \\(\\lfloor x \\rfloor\\) represents the greatest integer not greater than \\( x \\). For example, \\(\\lfloor 3.14 \\rfloor = 3\\) and \\(\\lfloor 2 \\rfloor = 2\\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n3 1 4\n```\n\n**Sample Output 1:**\n\n```\n8\n```\n\n*Explanation:* The sought value is:\n\n\\[\n\\left\\lfloor \\frac{\\max(3, 1)}{\\min(3, 1)} \\right\\rfloor + \\left\\lfloor \\frac{\\max(3, 4)}{\\min(3, 4)} \\right\\rfloor + \\left\\lfloor \\frac{\\max(1, 4)}{\\min(1, 4)} \\right\\rfloor = \\left\\lfloor \\frac{3}{1} \\right\\rfloor + \\left\\lfloor \\frac{4}{3} \\right\\rfloor + \\left\\lfloor \\frac{4}{1} \\right\\rfloor = 3 + 1 + 4 = 8\n\\]\n\n**Sample Input 2:**\n\n```\n6\n2 7 1 8 2 8\n```\n\n**Sample Output 2:**\n\n```\n53\n```\n\n**Sample Input 3:**\n\n```\n12\n3 31 314 3141 31415 314159 2 27 271 2718 27182 271828\n```\n\n**Sample Output 3:**\n\n```\n592622\n```\n\nSolution:\n\n```python\ndef calculate_max_min_sum(N, M, A):\n    # A should be sorted in ascending order\n    A.sort()\n    \n    # Pre-calculate the cumulative sum of C\n    C = [0] * (M + 1)\n    \n    # Count frequency of each element in A\n    for a in A:\n        C[a] += 1\n    \n    # Convert frequency to cumulative\n    for i in range(1, M + 1):\n        C[i] += C[i - 1]\n    \n    # Calculate the sum\n    max_min_sum = 0\n    for i in range(N - 1):\n        for n in range(1, M // A[i] + 1):\n            # Get count of j where floor(A_j/A[i]) = n\n            j_count = C[min(M, n * A[i])] - C[n * A[i] - 1]\n            max_min_sum += n * j_count\n    \n    return max_min_sum\n```\n \n\n", "problem_ids": ["abc356_e"]}, "abc307_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 450 points\n\n## Problem Statement\n\nThere are \\( N \\) islands and \\( M \\) bidirectional bridges connecting two islands. The islands and bridges are numbered \\( 1, 2, \\ldots, N \\) and \\( 1, 2, \\ldots, M \\), respectively. Bridge \\( i \\) connects islands \\( U_i \\) and \\( V_i \\), and the time it takes to cross it in either direction is \\( T_i \\). No bridge connects an island to itself, but it is possible for two islands to be directly connected by more than one bridge. One can travel between any two islands using some bridges.\n\nYou are given \\( Q \\) queries, so answer each of them. The \\( i \\)-th query is as follows:\n\n- You are given \\( K_i \\) distinct bridges: bridges \\( B_{i,1}, B_{i,2}, \\ldots, B_{i,K_i} \\).\n- Find the minimum time required to travel from island \\( 1 \\) to island \\( N \\) using each of these bridges at least once.\n- Only consider the time spent crossing bridges.\n- You can cross the given bridges in any order and in any direction.\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 400 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq T_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 3000 \\)\n- \\( 1 \\leq K_i \\leq 5 \\)\n- \\( 1 \\leq B_{i,1} < B_{i,2} < \\cdots < B_{i,K_i} \\leq M \\)\n- All input values are integers.\n- It is possible to travel between any two islands using some bridges.\n\n## Input\n\nThe input is given in the following format:\n```\nN M\nU_1 V_1 T_1\nU_2 V_2 T_2\n\u22ee\nU_M V_M T_M\nQ\nK_1\nB_{1,1} B_{1,2} \u22ef B_{1,{K_1}}\nK_2\nB_{2,1} B_{2,2} \u22ef B_{2,{K_2}}\n\u22ee\nK_Q\nB_{Q,1} B_{Q,2} \u22ef B_{Q,{K_Q}}\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq Q \\)) should contain the answer to the \\( i \\)-th query as an integer.\n\n## Sample Input 1\n\n```\n3 5\n1 2 10\n1 3 20\n1 3 30\n2 3 15\n2 3 25\n2\n1\n1\n2\n3 5\n```\n\n## Sample Output 1\n\n```\n25\n70\n```\n\nExplanation:\n- For the first query, the minimum time to travel from island 1 to island 3 using bridge 1 is achieved by using bridge 1 to move from island 1 to island 2, then bridge 4 to move from island 2 to island 3. The time taken is 10 + 15 = 25.\n- For the second query, the minimum time to travel from island 1 to island 3 using both bridges 3 and 5 is achieved by using bridge 3 to move from island 1 to island 3, then using bridge 5 to move to island 2, and finally bridge 4 to return to island 3. The time taken is 30 + 25 + 15 = 70.\n\n## Sample Input 2\n\n```\n6 6\n1 5 1\n2 5 1\n2 4 1\n3 4 1\n3 6 1\n1 6 1\n2\n5\n1 2 3 4 5\n1\n5\n```\n\n## Sample Output 2\n\n```\n5\n3\n```\n\nRemarks: You can cross the specified bridges in either direction.\n\n## Sample Input 3\n\n```\n5 5\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4 5 1000000000\n1 5 1000000000\n1\n1\n3\n```\n\n## Sample Output 3\n\n```\n4000000000\n```\n\nNote: The answer may not fit in a 32-bit integer.\n\nSolution:\n\n```python\nimport itertools\n\nN = 400\nM = int(2e5)\nINF = int(1e15)\n\nn = 0\nu = [0] * M\nv = [0] * M\nt = [0] * M\nd = [[0 if i == j else INF for j in range(N)] for i in range(N)]\nk = 0\na = []\n\ndef solve():\n    ans = INF\n    dp = [[0] * 2 for _ in range(5)]\n    b = list(range(k))\n    for perm in itertools.permutations(b):\n        dp[0][0] = d[0][v[a[perm[0]]]] + t[a[perm[0]]]\n        dp[0][1] = d[0][u[a[perm[0]]]] + t[a[perm[0]]]\n        for i in range(k - 1):\n            dp[i + 1][0] = min(dp[i][0] + d[u[a[perm[i]]]][v[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][v[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n            dp[i + 1][1] = min(dp[i][0] + d[u[a[perm[i]]]][u[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][u[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n        ans = min(ans, dp[k-1][0] + d[u[a[perm[k-1]]]][n-1])\n        ans = min(ans, dp[k-1][1] + d[v[a[perm[k-1]]]][n-1])\n    return ans\n\ndef main():\n    global n, k\n    m, q = map(int, input().split())\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d[i][j] = INF\n\n    for i in range(m):\n        u[i], v[i], t[i] = map(int, input().split())\n        u[i] -= 1\n        v[i] -= 1\n        d[u[i]][v[i]] = min(d[u[i]][v[i]], t[i])\n        d[v[i]][u[i]] = min(d[v[i]][u[i]], t[i])\n\n    for i1 in range(n):\n        for i0 in range(n):\n            for i2 in range(n):\n                d[i0][i2] = min(d[i0][i2], d[i0][i1] + d[i1][i2])\n    \n    for _ in range(q):\n        k = int(input())\n        a.clear()\n        for _ in range(k):\n            x = int(input())\n            a.append(x-1)\n        print(solve())\n\nif __name__ == '__main__':\n    main()\n```\n\n \n\n", "problem_ids": ["abc369_e"]}, "abc308_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nMr. AtCoder has created a device consisting of \\(N\\) small light bulbs arranged in a row from left to right, and two switches A and B. Each light bulb can be in one of two states: 0 (OFF) and 1 (ON). Pressing each switch causes the following:\n\n- Pressing switch A turns the leftmost light bulb in the 0 state into 1.\n- Pressing switch B turns the leftmost light bulb in the 1 state into 0.\n\nIf there is no applicable light bulb, you cannot press the switch.\n\nInitially, all light bulbs are in the 0 state. He wants the states of the light bulbs to be \\(S_1, S_2, \\dots, S_N\\) from left to right. Determine the order and number of times the switches should be pressed to achieve this. It is not necessary to minimize the number of presses, but it should be at most \\(10^6\\) so that the operations can finish in a realistic time. It can be proved that a solution exists under the constraints of this problem.\n\n**Constraints:**\n\n- \\(1 \\leq N \\leq 30\\)\n- Each of \\(S_1, S_2, \\dots, S_N\\) is 0 or 1.\n- Not all of \\(S_1, S_2, \\dots, S_N\\) are 0.\n- \\(N\\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1 S_2 \\dots S_N\n```\n\nNote that the second line is given as a string of length \\(N\\).\n\n**Output:**\n\nIf your solution presses the switches \\(m\\) times \\((1 \\leq m \\leq 10^6)\\) in the order \\(t_1, t_2, \\dots, t_m\\) (each being A or B), print these in the following format:\n\n```\nm\nt_1 t_2 \\dots t_m\n```\n\nThe second line should be printed as a string of length \\(m\\).\n\n**Sample Input 1:**\n\n```\n5\n01100\n```\n\n**Sample Output 1:**\n\n```\n4\nAAAB\n```\n\nThis sample output presents a solution that presses the switches in the order A, A, A, B. This sets the light bulbs to the desired states, as shown in the figure below:\n\nAlternatively, pressing switches in the order A, A, B, A, A, B also sets the light bulbs to the desired states. The following output corresponding to this solution would also be accepted:\n\n```\n6\nAABAAB\n```\n\nSolution:\n\n```\n        Editorial - B - Puzzle of Lamps\n\nFinding hints for the solution by trial and error:\nIn competitive programming, experimenting with cases like sample inputs can lead to clues for the solution. \n\nFor example, to change the state from 00000 to 01010:\n\n1. First, turn the fourth character into 1. Press A four times and B three times in order to change from 00000 to 00010.\n\n2. Next, turn the second character into 1. Press A twice and then B, which changes 00010 to 01010.\n\nSolution Strategy:\nTo turn only the \\(k\\)-th character into 1 from 000...0, press switch A \\(k\\) times in a row, then press switch B \\(k-1\\) times in a row. For multiple characters:\n- For \\(x_k\\)-th character, press A \\(x_k\\) times and B \\(x_k-1\\) times.\n- Repeat onwards for each \\(x_2, x_1,\\) etc.\n\nSample Python Implementation:\n```python\n# Input\nn = int(input())\ns = input()\n\n# Find the solution\nans = ''\nfor i in range(n-1, -1, -1):\n    if s[i] == '1':\n        ans += 'A' * (i+1) + 'B' * i\n\n# Output\nprint(len(ans))\nprint(ans)\n```\n```\n \n\n", "problem_ids": ["arc177_b"]}, "abc308_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nA real number \\( X \\) is given to the third decimal place. Print the real number \\( X \\) under the following conditions:\n\n- The decimal part must not have trailing zeros.\n- There must not be an unnecessary trailing decimal point.\n\n**Constraints**\n\n- \\( 0 \\le X < 100 \\)\n- \\( X \\) is given to the third decimal place.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nX\n```\n\n**Output**\n\nOutput the answer.\n\n**Sample Input 1**\n```\n1.012\n```\n\n**Sample Output 1**\n```\n1.012\n```\n\nExplanation: `1.012` can be printed as it is.\n\n**Sample Input 2**\n```\n12.340\n```\n\n**Sample Output 2**\n```\n12.34\n```\n\nExplanation: Printing `12.340` without the trailing zero results in `12.34`.\n\n**Sample Input 3**\n```\n99.900\n```\n\n**Sample Output 3**\n```\n99.9\n```\n\nExplanation: Printing `99.900` without the trailing zeros results in `99.9`.\n\n**Sample Input 4**\n```\n0.000\n```\n\n**Sample Output 4**\n```\n0\n```\n\nExplanation: Printing `0.000` without trailing zeros or an unnecessary decimal point results in `0`.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 367\n\nB - Cut .0 Editorial\n\nSolution 1: In C++, receive \\(X\\) as a double and print it. This avoids trailing zeros without specifying a format. Other languages might share this feature.\n\nSample code (Python3):\n```python\nx = float(input())\nprint(x)\n```\n\nSolution 2: Treat as a string problem. Receive \\(X\\) as a string, remove trailing zeros, and then remove a trailing '.' if present. The input ensures a decimal point, so trailing zeros are in the decimal part.\n\nSample code (Python3):\n```python\nx = input()\nwhile x[-1] == '0':\n    x = x[:-1]\nif x[-1] == '.':\n    x = x[:-1]\nprint(x)\n```\n```\n \n\n", "problem_ids": ["abc367_b"]}, "abc308_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nIn AtCoder, a user's rating is represented as a positive integer. Based on the rating value, a certain number of `^` symbols are displayed. Specifically, here are the display rules for different rating ranges:\n\n- If the rating is between 1 and 99, inclusive, `^` is displayed once.\n- If the rating is between 100 and 199, inclusive, `^` is displayed twice.\n- If the rating is between 200 and 299, inclusive, `^` is displayed three times.\n- If the rating is between 300 and 399, inclusive, `^` is displayed four times.\n\nCurrently, Takahashi's rating is \\( R \\). It is guaranteed that \\( R \\) is an integer between 1 and 299, inclusive.\n\nFind the minimum increase in rating required for Takahashi to increase the number of displayed `^`.\n\nIt is guaranteed that under the constraints of this problem, it is possible for Takahashi to increase the number of `^` without his rating reaching 400 or above.\n\n**Constraints**\n\n- \\( 1 \\leq R \\leq 299 \\)\n- \\( R \\) is an integer.\n\n**Input**\n\nThe input is given from standard input as follows:\n```\nR\n```\n\n**Output**\n\nPrint, as an integer, the minimum increase in rating required for Takahashi to increase the number of displayed `^`.\n\n**Sample Input 1**\n```\n123\n```\n\n**Sample Output 1**\n```\n77\n```\n\nTakahashi's current rating is 123, and `^` is displayed twice. By increasing his rating by 77, his rating will become 200, and `^` will be displayed three times. When the rating is 199 or below, `^` is displayed not more than twice, so we print 77.\n\n**Sample Input 2**\n```\n250\n```\n\n**Sample Output 2**\n```\n50\n```\n\nSolution:\n\n        Here is the cleaned-up version of the coding problem editorial:\n\n---\n\n**Official A - Piling Up Editorial**\n\nTo determine the increase in rating required, we denote the current rating by \\(R\\):\n\n- \\((100-R)\\) if \\(1 \\leq R \\leq 99\\)\n- \\((200-R)\\) if \\(100 \\leq R \\leq 199\\)\n- \\((300-R)\\) if \\(200 \\leq R \\leq 299\\)\n\nThis value can be printed using an if statement. Alternatively, using the remainder when \\(R\\) is divided by \\(100\\), one can implement the solution without a conditional branch.\n\n**Sample code in C++:**\n\n```python\nr = int(input())\nif r < 100:\n    print(100 - r)\nelif r < 200:\n    print(200 - r)\nelse:\n    print(300 - r)\n```\n\n**Sample code in Python:**\n\n```python\nr = int(input())\nif r < 100:\n    print(100 - r)\nelif r < 200:\n    print(200 - r)\nelse:\n    print(300 - r)\n```\n\n**Sample code in C++ (alternate solution):**\n\n```python\nr = int(input())\nprint(100 - (r % 100))\n```\n \n\n", "problem_ids": ["abc363_a"]}, "abc308_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nYou are given \\( N \\) intervals numbered from 1 to \\( N \\). Interval \\( i \\) is \\([L_i, R_i]\\).\n\nTwo intervals \\([l_a, r_a]\\) and \\([l_b, r_b]\\) are said to **intersect** if and only if they satisfy either \\((l_a < l_b < r_a < r_b)\\) or \\((l_b < l_a < r_b < r_a)\\).\n\nDefine \\( f(l, r) \\) as the number of intervals \\( i \\) \\((1 \\leq i \\leq N)\\) that intersect with the interval \\([l, r]\\).\n\nAmong all pairs of **integers** \\((l, r)\\) satisfying \\( 0 \\leq l < r \\leq 10^9 \\), find the pair \\((l, r)\\) that maximizes \\( f(l, r) \\). If there are multiple such pairs, choose the one with the smallest \\( l \\). If there are still multiple pairs, choose the one with the smallest \\( r \\) among them. (Since \\( 0 \\leq l < r \\), the pair \\((l, r)\\) to be answered is uniquely determined.)\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 0 \\leq L_i < R_i \\leq 10^9 \\) for \\( 1 \\leq i \\leq N \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nL_1 R_1\nL_2 R_2\n\u22ee\nL_N R_N\n```\n\n### Output\n\nPrint the sought pair \\((l, r)\\) in the following format:\n\n```\nl r\n```\n\n### Sample Input 1\n\n```\n5\n1 7\n3 9\n7 18\n10 14\n15 20\n```\n\n### Sample Output 1\n\n```\n4 11\n```\n\nThe maximum value of \\( f(l, r) \\) is \\( 4 \\), and among the pairs \\((l, r)\\) that achieve \\( f(l, r) = 4 \\), the smallest \\( l \\) is 4. The pairs \\((l, r)\\) that satisfy \\( f(l, r) = 4 \\) and \\( l = 4 \\) are the following five: \n\n- \\((l, r) = (4, 11)\\)\n- \\((l, r) = (4, 12)\\)\n- \\((l, r) = (4, 13)\\)\n- \\((l, r) = (4, 16)\\)\n- \\((l, r) = (4, 17)\\)\n\nAmong these, the smallest \\( r \\) is 11, so print 4 and 11.\n\n### Sample Input 2\n\n```\n11\n856977192 996441446\n298251737 935869360\n396653206 658841528\n710569907 929136831\n325371222 425309117\n379628374 697340458\n835681913 939343451\n140179224 887672320\n375607390 611397526\n93530028 581033295\n249611310 775998537\n```\n\n### Sample Output 2\n\n```\n396653207 887672321\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 360\n\n# We consider the problem by mapping segments [l,r] onto the two-dimensional plane.\n# Segments (l,r) that intersect with segment i satisfy L_i < l < R_i < r or l < L_i < r < R_i,\n# forming disjoint rectangular regions. Thus, it is sufficient to find the region of (l,r)\n# that intersects with each segment and find the place covered by the most number of regions.\n\n# Given N tuples of integers (x_i,y_i,z_i,w_i), find (L,R) that maximizes the number of indices i\n# with x_i <= L <= y_i, z_i <= R <= w_i.\n\n# This can be solved with a search line algorithm as follows:\n\n# You are given an array C whose elements are initially 0. Initialize the maximum value with 0.\n# Given N tuples of integers (x_i,y_i,z_i,w_i), perform the following procedure for l=0,...,10**9 in order:\n\n# 1. For each tuple (x_j,y_j,z_j,w_j) with x_j=l, for each r with z_j <= r <= w_j, increment C[r] by 1.\n# 2. Retrieve the maximum value of C. If the maximum value should be updated, record the current l and r\n#    that achieves the maximum.\n# 3. For each tuple (x_j,y_j,z_j,w_j) with y_j=l, for each r with z_j <= r <= w_j, increment C[r] by -1.\n\n# By applying coordinate compression, this can be reduced to O(N). Specifically, l can take L_i+1 or R_i-1.\n# Also, r can take L_i+1, R_i-1, or R_i+1. A segment-add segment-max lazy segment tree reduces the complexity\n# to O(N log N). If the maximum value of f(l,r) is 0, the answer is always l=0, r=1. For more details, refer to\n# the sample code.\n```\n \n\n", "problem_ids": ["abc360_f"]}, "abc308_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nIn the nation of AtCoder, there are \\( N \\) cities numbered from 1 to \\( N \\) and \\( N-1 \\) roads. Each road \\( i \\) connects cities \\( A_i \\) and \\( B_i \\) bidirectionally, with a length of \\( C_i \\). Every city can be reached from any other city by traveling through some roads.\n\nThe task is to find the minimum travel distance required to start from a city and visit all cities at least once using the roads.\n\n### Constraints\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- All input values are integers.\n- Any pair of cities can be reached from each other by traveling through some roads.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_{N-1} B_{N-1} C_{N-1}\n```\n\n### Output\nPrint the minimum travel distance required.\n\n### Sample Input 1\n```\n4\n1 2 2\n1 3 3\n1 4 4\n```\n\n### Sample Output 1\n```\n11\n```\n\n*Explanation*: If you travel as 4 \u2192 1 \u2192 2 \u2192 1 \u2192 3, the total travel distance is 11, which is the minimum. You do not need to return to the starting city.\n\n### Sample Input 2\n```\n10\n10 9 1000000000\n9 8 1000000000\n8 7 1000000000\n7 6 1000000000\n6 5 1000000000\n5 4 1000000000\n4 3 1000000000\n3 2 1000000000\n2 1 1000000000\n```\n\n### Sample Output 2\n```\n9000000000\n```\n\n*Note*: Beware of overflow.\n\nSolution:\n\n```\nConsider a graph with the vertices representing cities and the edges representing roads. This graph is a tree. Let \\(D\\) be the diameter of this tree. The solution is \\(2\\sum C_i - D\\). The diameter of the tree can be found in \\(O(N)\\) time using the following steps: From an arbitrary vertex \\(v\\), find the furthest vertex \\(u\\). From \\(u\\), find the furthest vertex \\(s\\). \\(u\\) and \\(v\\) are the endpoints of a diameter.\n\nWe won't explain why the diameter can be found this way. The original problem's answer is \\(2\\sum C_i - D\\). Consider the minimum travel distance for visiting all vertices and returning to the start. For each edge, consider the two components obtained by removing the edge; every edge must be passed at least twice. By performing a DFS from an arbitrary vertex and visiting all vertices, you can return to the start after passing each edge twice. Thus, the answer is \\(2\\sum C_i\\).\n\nReturn to the original problem. A tour visiting every vertex once can be extended to return to the start. The minimum for this is \\(2\\sum C_i\\), while the maximum distance from end to start equals the tree's diameter. So, the minimum tour distance visiting all vertices at least once is \\(2\\sum C_i-D\\). \n\nChoose a diameter with endpoints \\(x\\) and \\(y\\). By performing DFS such that the next vertex doesn't move closer to \\(y\\), each edge on the shortest path between \\(x\\) and \\(y\\) is passed once. This tour visits each vertex once with travel distance \\(2\\sum C_i-D\\). Therefore, the sought minimum value is \\(2\\sum C_i-D\\).\n```\n \n\n", "problem_ids": ["abc361_e"]}, "abc308_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence of \\( N \\) positive integers \\( A = (A_1, A_2, \\dots, A_N) \\), where each element is at least \\( 2 \\). Anna and Bruno play a game using these integers. They take turns, with Anna going first, performing the following operation:\n\n- Choose an integer \\( i \\) \\((1 \\leq i \\leq N)\\) freely. Then, freely choose a positive divisor \\( x \\) of \\( A_i \\) that is not \\( A_i \\) itself, and replace \\( A_i \\) with \\( x \\).\n\nThe player who cannot perform the operation loses, and the other player wins. Determine who wins assuming both players play optimally for victory.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 2 \\leq A_i \\leq 10^5 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nPrint `Anna` if Anna wins the game, and `Bruno` if Bruno wins.\n\n**Sample Input 1**\n```\n3\n2 3 4\n```\n\n**Sample Output 1**\n```\nAnna\n```\n\nFor example, the game might proceed as follows. Note that this example may not necessarily represent optimal play by both players:\n- Anna changes \\( A_3 \\) to \\( 2 \\).\n- Bruno changes \\( A_1 \\) to \\( 1 \\).\n- Anna changes \\( A_2 \\) to \\( 1 \\).\n- Bruno changes \\( A_3 \\) to \\( 1 \\).\n\nAnna cannot operate on her turn, so Bruno wins. Actually, for this sample, Anna always wins if she plays optimally.\n\n**Sample Input 2**\n```\n4\n2 3 4 6\n```\n\n**Sample Output 2**\n```\nBruno\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere is the cleaned version of the editorial text:\n\nThis algorithm requires the knowledge of the Grundy number. If you are unfamiliar with it, refer to the editorial for ABC255-G or online articles. To find the Grundy number for each \\(i\\), observe the operation where \\(A_i\\) is replaced with a positive divisor other than itself, reducing one or more prime factors including duplicates. Let \\(x_i\\) represent the number of prime factors of \\(A_i\\), counting duplicates. The game in this problem involves \\(x_i\\) stones in the \\(i\\)-th pile, where players take turns removing stones until one cannot make a move and loses. This is equivalent to Nim, where the Grundy number of \\(A_i\\) is \\(x_i\\). Using the Sieve of Eratosthenes provides an algorithm that runs in \\(O(N + T \\log \\log T)\\) time, with \\(T\\) as the maximum value of \\(A\\). The \\(O(N \\sqrt T)\\) algorithm for naive prime factorization is also sufficiently fast.\n[END TEXT]\n \n\n", "problem_ids": ["abc368_f"]}, "abc309_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\n", "problem_ids": ["abc368_c"]}, "abc309_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n### Problem Statement\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\).\n\nYour objective is to transform this permutation into the identity permutation \\( P_i = i \\) for all \\( i = 1, 2, \\ldots, N \\) by performing the following operation zero or more times:\n\n1. Choose an integer \\( k \\) such that \\( 1 \\leq k \\leq N \\).\n2. If \\( k \\geq 2 \\), sort the elements from the 1st to the \\((k-1)\\)-th position of \\( P \\) in ascending order.\n3. Then, if \\( k \\leq N - 1 \\), sort the elements from the \\((k+1)\\)-th to the \\( N \\)-th position of \\( P \\) in ascending order.\n\nIt can be proved that under the constraints of this problem, it is possible to transform any given permutation \\( P \\) into the identity permutation with a finite number of operations. Your task is to find the minimum number of operations required.\n\nYou have \\( T \\) test cases to solve.\n\n### Constraints\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 3 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( P \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n- The sum of \\( N \\) across the test cases in a single input is at most \\( 2 \\times 10^5 \\).\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\n...\ncase_T\n```\n\nEach case is presented as follows:\n\n```\nN\nP_1 P_2 ... P_N\n```\n\n### Output\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\n\n### Sample Input 1\n\n```\n3\n5\n2 1 3 5 4\n3\n1 2 3\n7\n3 2 1 7 5 6 4\n```\n\n### Sample Output 1\n\n```\n1\n0\n2\n```\n\n#### Explanation:\n\n- For the first test case, the operation with \\( k = 3 \\) yields \\( P \\) as \\( (1, 2, 3, 4, 5) \\), requiring 1 operation.\n- The second test case already satisfies \\( P_i = i \\), thus needing 0 operations.\n- For the third test case, perform the operations with \\( k = 4 \\) and then \\( k = 3 \\) successively to achieve the identity permutation \\( (1, 2, 3, 4, 5, 6, 7) \\), requiring 2 operations.\n\nSolution:\n\n---\n\nSince each operation sorts a significant portion of the array, it is expected that the entire array can be sorted with a few operations. In fact:\n\n1. Perform the operation with \\(k=1\\). This sorts the entire array if \\(P_1=1\\) in the initial state. Otherwise, we have \\(P_N \\neq 1\\) after the operation since \\(N \\geq 3\\).\n2. Next, perform the operation with \\(k=N\\). Since \\(P_N \\neq 1\\) before the operation, we have \\(P_1=1\\) after the operation.\n3. Perform the operation with \\(k=1\\). Since \\(P_1=1\\) before the operation, the entire array is certainly sorted after the operation.\n\nBy performing the above, any permutation can be sorted in at most three operations. Therefore, it is sufficient to quickly determine if the array can be sorted in zero, one, or two operations.\n\n- The determination for zero operations is trivial.\n- For one operation, if we fix \\(k\\), it is necessary and sufficient that the minimum and maximum values of \\((P_1, P_2, \\dots, P_{k-1})\\) are \\(1\\) and \\(k-1\\), respectively, and \\(P_k=k\\). This can be checked in \\(O(1)\\) time for each \\(k\\) by taking cumulative \\(\\min\\) and \\(\\max\\), so the overall determination can be done in \\(O(N)\\) time.\n- For two operations, if \\(P_N \\neq 1\\), starting from the second of the three operations, the array can be sorted in two operations. Similarly, if \\(P_1 \\neq N\\), it can be sorted in two operations. Conversely, if \\(P_1=N\\) and \\(P_N=1\\), the relative positions of \\(1\\) and \\(N\\) in \\(P\\) do not change with one operation, leaving them in the order \\(N, 1\\). Therefore, \\(P\\) can be sorted in two or fewer operations \\(\\iff\\) \\(P_1 \\neq N\\) or \\(P_N \\neq 1\\). This can be checked in \\(O(1)\\) time.\n\nFrom the above, the answer for each test case can be found in \\(O(N)\\) time.\n \n\n", "problem_ids": ["arc181_a"]}, "abc309_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer \\( Y \\) between 1583 and 2023. Find the number of days in the year \\( Y \\) of the Gregorian calendar.\n\nWithin the given range, the year \\( Y \\) has the following number of days:\n\n- If \\( Y \\) is not a multiple of 4, then 365 days.\n- If \\( Y \\) is a multiple of 4 but not a multiple of 100, then 366 days.\n- If \\( Y \\) is a multiple of 100 but not a multiple of 400, then 365 days.\n- If \\( Y \\) is a multiple of 400, then 366 days.\n\n**Constraints:**\n\n- \\( Y \\) is an integer between 1583 and 2023, inclusive.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nY\n```\n\n**Output:**\n\nPrint the number of days in the year \\( Y \\) as an integer.\n\n**Sample Input 1:**\n\n```\n2023\n```\n\n**Sample Output 1:**\n\n```\n365\n```\n\n2023 is not a multiple of 4, so it has 365 days.\n\n**Sample Input 2:**\n\n```\n1992\n```\n\n**Sample Output 2:**\n\n```\n366\n```\n\n1992 is a multiple of 4 but not a multiple of 100, so it has 366 days.\n\n**Sample Input 3:**\n\n```\n1800\n```\n\n**Sample Output 3:**\n\n```\n365\n```\n\n1800 is a multiple of 100 but not a multiple of 400, so it has 365 days.\n\n**Sample Input 4:**\n\n```\n1600\n```\n\n**Sample Output 4:**\n\n```\n366\n```\n\n1600 is a multiple of 400, so it has 366 days.\n\nSolution:\n\n        Here is the cleaned version of the text, focusing only on the solution:\n\n---\n\nLet us use an if statement to implement the casework in the problem statement. To determine if \\(x\\) is divisible by \\(y\\), one can check if x % y == 0. Here, x % y denotes the remainder when \\(x\\) is divided by \\(y\\). When \\(x\\) is divisible by \\(y\\), the remainder when \\(x\\) is divided by \\(y\\) is \\(0\\), so the code above determines the divisibility. In our case, there are multiple if statements, possibly making the code deeply nested. In such a case, one can immediately print the result and return once a condition is met to avoid deep nests.\n\nSample code (Python3):\n```python\ny = int(input())\nif y % 4 != 0:\n    print(365)\nelif y % 100 != 0:\n    print(366)\nelif y % 400 != 0:\n    print(365)\nelse:\n    print(366)\n```\n \n\n", "problem_ids": ["abc365_a"]}, "abc309_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement (Score: 650 points)**\n\nWe call a positive integer \\( n \\) a \"good integer\" if and only if the sum of its positive divisors is divisible by 3. You are given two positive integers \\( N \\) and \\( M \\). Find the number, modulo 998244353, of length-\\( M \\) sequences \\( A \\) of positive integers such that the product of the elements in \\( A \\) is a good integer not exceeding \\( N \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^{10} \\)\n- \\( 1 \\leq M \\leq 10^5 \\)\n- \\( N \\) and \\( M \\) are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n10 1\n```\n\n**Sample Output 1**\n\n```\n5\n```\n\nThere are five sequences that satisfy the conditions:\n\n- (2)\n- (5)\n- (6)\n- (8)\n- (10)\n\n**Sample Input 2**\n\n```\n4 2\n```\n\n**Sample Output 2**\n\n```\n2\n```\n\nThere are two sequences that satisfy the conditions:\n\n- (1, 2)\n- (2, 1)\n\n**Sample Input 3**\n\n```\n370 907\n```\n\n**Sample Output 3**\n\n```\n221764640\n```\n\n**Sample Input 4**\n\n```\n10000000000 100000\n```\n\n**Sample Output 4**\n\n```\n447456146\n```\n\nSolution:\n\n```python\n# Here is the rewritten editorial with Python code:\n\n# Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\n# G - Divisible by 3 Editorial\n\n# This problem can be solved by finding a prefix sum of a multiplicative function. \n# A function f(n) is multiplicative if f(ab) = f(a) f(b) for all positive integers gcd(a, b) = 1.\n\n# Given a multiplicative function f(n), evaluate:\n# sum(1 <= n <= N) f(n).\n\n# **Facts and Problem Rephrasing:**\n\n# 1. sigma(n), the sum of the divisors of n, is multiplicative as per the formula:\n#    sigma(n) = prod(i=1 to k) (1 + p_i + ... + p_i^e_i)\n\n# 2. g(n), the number of length-M sequences of positive integers such that their product is M, is multiplicative:\n#    g(n) = prod(i=1 to k) comb(e_i + M - 1, M - 1)\n\n# Original problem:\n# sum(1 <= n <= N, sigma(n) % 3 = 0) g(n)\n\n# Define:\n# h(n) = \n# if sigma(n) % 3 == 0:\n#     0\n# else:\n#     g(n)\n\n# Rephrased Problem:\n# sum(n=1 to N) (g(n) - h(n))\n\n# Final expression:\n# sum(n=1 to N) g(n) - sum(n=1 to N) h(n)\n\n# There are efficient algorithms to compute these prefix sums:\n\n# **Lucy DP:**\n# Define:\n# F(n) = sum(1 <= m <= n) f(m),\n# F_prime(n) = sum(1 <= p <= n, p: prime) f(p),\n\n# Evaluate F_prime(n) for all n in Q_N using a dynamic programming approach, Lucy DP.\n\n# **Black Algorithm and Min_25 sieve:**\n# Evaluate F(N) using F_prime(n) results.\n\n# Black Algorithm: Uses a tree structure to compute F(N) leveraging the multiplicativity of the function.\n\n# Min_25 Sieve: Offers a more efficient approach with complexity O(N^(2/3)).\n\n# By implementing Lucy DP and one of the other methods, the problem is solved efficiently with complexity O(N^(3/4)/log N) or O(N^(1 - epsilon)).\n\n# **Advanced Topics:**\n\n# More efficient algorithms, like those by zhoukangyang (O(sqrt(N))) and Zhenting Zhu (Theta (N^(2/3) / (log N)^(4/3))), exist.\n# Other algorithms like Dujiao sieve or PowerfulNumber sieve can be used under specific conditions.\n```\n\n \n\n", "problem_ids": ["abc370_g"]}, "abc309_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi has prepared \\(N\\) dishes for Snuke. The dishes are numbered from 1 to \\(N\\), and dish \\(i\\) has a sweetness of \\(A_i\\) and a saltiness of \\(B_i\\).\n\nTakahashi can arrange these dishes in any order he likes. Snuke will eat the dishes in the order they are arranged, but if at any point the total sweetness of the dishes he has eaten so far exceeds \\(X\\) or the total saltiness exceeds \\(Y\\), he will not eat any further dishes.\n\nTakahashi wants Snuke to eat as many dishes as possible. Find the maximum number of dishes Snuke will eat if Takahashi arranges the dishes optimally.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 80\\)\n- \\(1 \\leq A_i, B_i \\leq 10000\\)\n- \\(1 \\leq X, Y \\leq 10000\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN X Y\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\n```\n\n**Output:**\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 8 4\n1 5\n3 2\n4 1\n5 3\n```\n\n**Sample Output 1:**\n```\n3\n```\n\n*Explanation:*\nConsider the scenario where Takahashi arranges the dishes in the order 2, 3, 1, 4.\n- First, Snuke eats dish 2. The total sweetness so far is 3, and the total saltiness is 2.\n- Next, Snuke eats dish 3. The total sweetness so far is 7, and the total saltiness is 3.\n- Next, Snuke eats dish 1. The total sweetness so far is 8, and the total saltiness is 8.\n- The total saltiness has exceeded \\(Y=4\\), so Snuke will not eat any further dishes.\n\nThus, in this arrangement, Snuke will eat three dishes. No matter how Takahashi arranges the dishes, Snuke will not eat all four dishes, so the answer is 3.\n\n**Sample Input 2:**\n```\n2 1 1\n3 2\n3 2\n```\n\n**Sample Output 2:**\n```\n1\n```\n\n**Sample Input 3:**\n```\n2 100 100\n3 2\n3 2\n```\n\n**Sample Output 3:**\n```\n2\n```\n\n**Sample Input 4:**\n```\n6 364 463\n230 381\n154 200\n328 407\n339 94\n193 10\n115 309\n```\n\n**Sample Output 4:**\n```\n3\n```\n\nSolution:\n\n```python\nEditorial - Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nE - Maximum Glutton Editorial by en_translator\n\nNotice that the total sweetness and saltiness of all but last dishes that he eats do not exceed \\(X\\) and \\(Y\\), respectively. Let \\(x\\) be the maximum size of a set of dishes \\(S\\) such that the total sweetness does not exceed \\(X\\) and the total saltiness does not exceed \\(Y\\). Then, the answer to the original problem can be represented as \\(\\min(x+1, N)\\). If \\(x<N\\), he can eat at least \\((x+1)\\) dishes by eating those in \\(S\\) first. Thus, he can eat at most \\((x+1)\\) dishes.\n\nTo find the maximum number of dishes that can be chosen such that the total sweetness and saltiness do not exceed \\(X\\) and \\(Y\\), respectively, define a Dynamic Programming (DP) table:\n\n\\(dp_{i,j,k}\\) = (the minimum total saltiness when choosing exactly \\(k\\) dishes from dishes \\(1,2,\\dots,i\\) so that the total sweetness is exactly \\(j\\)).\n\nThis fills the DP table in \\(O(N^2X)\\) time. Find the maximum \\(k\\) such that there exists \\(j\\) with \\(dp'_{N,j,k} \\leq Y\\).\n\nSample code (Python3):\n```python\ndef chmin(a, b):\n    return min(a, b)\n\ndef main():\n    n, x, y = map(int, input().split())\n    a = []\n    b = []\n    for _ in range(n):\n        ai, bi = map(int, input().split())\n        a.append(ai)\n        b.append(bi)\n    \n    dp = [[[float('inf')] * (x + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 0\n    \n    for i in range(n):\n        for j in range(i + 1):\n            for k in range(x + 1):\n                dp[i + 1][j][k] = chmin(dp[i + 1][j][k], dp[i][j][k])\n                if k + a[i] <= x:\n                    dp[i + 1][j + 1][k + a[i]] = chmin(dp[i + 1][j + 1][k + a[i]], dp[i][j][k] + b[i])\n    \n    for i in range(n, -1, -1):\n        for j in range(x + 1):\n            if dp[n][i][j] <= y:\n                print(min(i + 1, n))\n                return\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc364_e"]}, "abc310_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer \\( K \\). For a set \\( S \\) that is initially empty, you need to process \\( Q \\) queries of the following two types in order:\n\n1. `1 x`: An integer \\( x \\) is given. If \\( x \\) is in \\( S \\), remove \\( x \\) from \\( S \\). Otherwise, add \\( x \\) to \\( S \\).\n2. `2 x`: An integer \\( x \\) that is in \\( S \\) is given. Consider a graph where the vertices are the numbers in \\( S \\), and there is an edge between two numbers if and only if the absolute difference between them is at most \\( K \\). Print the count of vertices in the connected component that contains \\( x \\).\n\n**Constraints:**\n\n- \\( 1 \\leq Q \\leq 200,000 \\)\n- \\( 0 \\leq K \\leq 10^{18} \\)\n- For each query, \\( 1 \\leq x \\leq 10^{18} \\).\n- For each query of the second type, the given \\( x \\) is in \\( S \\) at that point.\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nQ K\nquery_1\n...\nquery_Q\n```\nEach query is given in the following format:\n- For type 1 query: `1 x`\n- For type 2 query: `2 x`\n\n**Output:**\n\nProcess the queries and for each query of type 2, output the size of the connected component containing \\( x \\).\n\n**Sample Input 1:**\n```\n7 5\n1 3\n1 10\n2 3\n1 7\n2 3\n1 10\n2 3\n```\n\n**Sample Output 1:**\n```\n1\n3\n2\n```\n\n**Explanation:**\n\n- In the first query, \\( 3 \\) is added to \\( S \\), resulting in \\( S=\\{3\\} \\).\n- In the second query, \\( 10 \\) is added to \\( S \\), resulting in \\( S=\\{3, 10\\} \\).\n- In the third query, consider a graph with vertices \\( 3 \\) and \\( 10 \\) and no edges. The connected component containing \\( 3 \\) has a size of 1, so print 1.\n- In the fourth query, \\( 7 \\) is added to \\( S \\), resulting in \\( S=\\{3, 7, 10\\} \\).\n- In the fifth query, consider a graph with vertices \\( 3, 7, \\) and \\( 10 \\), with edges between \\( 3 \\) and \\( 7 \\), and \\( 7 \\) and \\( 10 \\). The connected component containing \\( 3 \\) has a size of 3, so print 3.\n- In the sixth query, \\( 10 \\) is removed from \\( S \\), resulting in \\( S=\\{3, 7\\} \\).\n- In the seventh query, consider a graph with vertices \\( 3 \\) and \\( 7 \\), with an edge between them. The connected component containing \\( 3 \\) has a size of 2, so print 2.\n\n**Sample Input 2:**\n```\n11 1000000000000000000\n1 1\n1 100\n1 10000\n1 1000000\n1 100000000\n1 10000000000\n1 1000000000000\n1 100000000000000\n1 10000000000000000\n1 1000000000000000000\n2 1\n```\n\n**Sample Output 2:**\n```\n10\n```\n\n**Sample Input 3:**\n```\n8 0\n1 1\n1 2\n2 1\n1 1\n1 2\n1 1\n1 2\n2 1\n```\n\n**Sample Output 3:**\n```\n1\n1\n```\n\nSolution:\n\n```python\nclass SegmentTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (2 * size)\n\n    def update(self, pos, value):\n        pos += self.size\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left, right):\n        result = 0\n        left += self.size\n        right += self.size\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef add_or_remove_edge(segments, A, x):\n    A[x] = 1 - A[x]\n    segments.update(x, A[x])\n\ndef find_connected_component_size(segments, start_x, size):\n    left = start_x\n    right = start_x\n\n    # Extend to the right\n    while right < size - 1 and segments.query(start_x, right + 1) == right + 1 - start_x:\n        right += 1\n\n    # Extend to the left\n    while left > 0 and segments.query(left - 1, start_x) == start_x - left + 1:\n        left -= 1\n\n    return right - left + 1\n\n# Assuming the segment size is known and is sufficient\nsize = 10000\nsegments = SegmentTree(size)\nA = [0] * size\n\n# Example usage\nadd_or_remove_edge(segments, A, 5)\ncomponent_size = find_connected_component_size(segments, 5, size)\nprint(\"Component size:\", component_size)\n```\n\nFor three numbers \\(a < b < c\\) and any \\(K\\), if \\(c-a \\leq K\\), then \\(b-a \\leq K\\) and \\(c-b \\leq K\\). Consequently, if there is an edge between \\(a\\) and \\(c\\), then there are also edges between \\(a\\) and \\(b\\), and \\(b\\) and \\(c\\). Thus, one can only add edges between adjacent elements in the sorted \\(S\\) without changing connectivity.\n\nFirst, consider a graph with \\(N\\) vertices and \\(0\\) edges. Two types of queries are:\n\n1. Given \\(x\\), add an edge between vertices \\(x\\) and \\(x+1\\) if absent, or remove it if present.\n2. Find the size of the connected component containing vertex \\(x\\).\n\nLet \\(A_i\\) be \\(1\\) if there is an edge between \\(i\\) and \\(i+1\\), and \\(0\\) otherwise. The two queries can be processed as follows:\n\n- Addition and deletion of an edge are done by updating \\(A_i\\).\n- To find how far the connected component containing \\(x\\) extends to the right, \\(y > x\\) is connected to \\(x\\) if and only if \\(A[x] + \\ldots + A[y-1] = y-x\\). The maximum such \\(y\\) can be quickly found with binary search by finding the segment sum of \\(A\\). The same applies to the left.\n\nThe altered question can be solved by managing the array \\(A\\) in a segment tree. The original problem asks to add or remove vertices by maintaining the following two arrays \\(A\\) and \\(B\\) as segment trees to manage the existence of vertices and edges:\n\n- \\(A_i = 1\\) if \\(x\\) is contained in \\(S\\), and \\(A_i = 0\\) otherwise.\n- \\(B_i = 1\\) if there is an edge between \\(x\\) and \u201cthe next vertex to the right,\u201d and \\(B_i = 0\\) otherwise.\n\nCoordinate compression or a dynamic segment tree can keep the number of nodes small, making the complexity \\(O(Q\\log Q)\\) or \\(O(Q\\log\\max x_i)\\).\n \n\n", "problem_ids": ["abc356_f"]}, "abc310_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n---\n**Problem Statement**\n\nYou are given a directed graph with \\( N \\) vertices and \\( M \\) edges. The \\( j \\)-th directed edge goes from vertex \\( u_j \\) to vertex \\( v_j \\) and has a weight of \\( w_j \\).\n\nFind one way to assign an integer between \\(-10^{18}\\) and \\(10^{18}\\), inclusive, to each vertex such that the following condition is satisfied:\n\n- Let \\( x_i \\) be the value assigned to vertex \\( i \\). For all edges \\( j = 1, 2, \\dots, M \\), it holds that \\( x_{v_j} - x_{u_j} = w_j \\).\n\nIt is guaranteed that at least one such assignment exists for the given input.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq \\min\\{2 \\times 10^5, \\frac{N(N-1)}{2}\\} \\)\n- \\( 1 \\leq u_j, v_j \\leq N \\)\n- \\( u_j \\neq v_j \\)\n- If \\( i \\neq j \\), then \\( (u_i, v_i) \\neq (u_j, v_j) \\) and \\( (u_i, v_i) \\neq (v_j, u_j) \\)\n- \\( |w_j| \\leq 10^9 \\)\n- All input values are integers.\n- There exists at least one assignment satisfying the conditions.\n\n**Input**\n\nThe input is given in the following format:\n\n```\nN M\nu_1 v_1 w_1\nu_2 v_2 w_2\n\u22ee\nu_M v_M w_M\n```\n\n**Output**\n\nLet \\( x_i \\) be the integer written on vertex \\( i \\). Print \\( x_1, x_2, \\dots, x_N \\) in this order, separated by spaces, on a single line. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n\n```\n3 3\n1 2 2\n3 2 3\n1 3 -1\n```\n\n**Sample Output 1**\n\n```\n3 5 2\n```\n\nBy setting \\( x = (3, 5, 2) \\), we have \\( x_2 - x_1 = w_1 = 2 \\), \\( x_2 - x_3 = w_2 = 3 \\), \\( x_3 - x_1 = w_3 = -1 \\), satisfying the conditions. For example, \\( x = (-1, 1, -2) \\) is also a valid answer.\n\n**Sample Input 2**\n\n```\n4 2\n2 1 5\n3 4 -3\n```\n\n**Sample Output 2**\n\n```\n5 0 6 3\n```\n\nFor example, \\( x = (0, -5, 4, 1) \\) and \\( x = (5, 0, 4, 1) \\) are also valid answers.\n\n**Sample Input 3**\n\n```\n5 7\n2 1 18169343\n3 1 307110901\n4 1 130955934\n2 3 -288941558\n2 5 96267410\n5 3 -385208968\n4 3 -176154967\n```\n\n**Sample Output 3**\n\n```\n200401298 182231955 -106709603 69445364 278499365\n```\n\nSolution:\n\n```python\n        For each connected component of the graph, once the value to be written on any vertex in it is fixed, all the values to be written are uniquely determined. This is because, once you determine the value for a vertex, the value for adjacent vertices is also determined in a chain. Thus, the problem can be solved by inspecting vertices one by one, and if the current vertex does not have a value assigned, set an arbitrary value (like 0) to it and determine the values for all the other connected vertices. This kind of process can be implemented as a Depth-First Search (DFS) or Breadth-First Search (BFS). The time complexity is \\(O(N+M)\\).\n\n```python\n# Read the input\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, w))\n    G[v].append((u, -w))\n\nvisited = [False] * N  # Whether the values are determined\nans = [0] * N  # The values to write\nfor i in range(N):\n    # Skip if the value is already determined\n    if visited[i]:\n        continue\n    # Set the value for vertex i to 0, and start searching\n    st = [i]\n    visited[i] = True\n    while st:\n        # Currently at vertex u\n        u = st.pop()\n        # Inspect vertex v adjacent to vertex u\n        for v, w in G[u]:\n            if not visited[v]:\n                # If the value for vertex v is undetermined, determine the value so that it is consistent with that for vertex u\n                visited[v] = True\n                ans[v] = ans[u] + w\n                st.append(v)\nprint(*ans)\n```\n```\n \n\n", "problem_ids": ["abc373_d"]}, "abc310_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a grid with \\( H \\) rows and \\( W \\) columns. Let \\( (i, j) \\) denote the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left. Initially, there is one wall in each cell. After processing \\( Q \\) queries as explained below, determine the number of remaining walls.\n\nIn the \\( q \\)-th query, you are given two integers \\( R_q \\) and \\( C_q \\). A bomb is placed at \\( (R_q, C_q) \\) to destroy walls. The following process occurs:\n\n- If there is a wall at \\( (R_q, C_q) \\), destroy that wall and end the process.\n- If there is no wall at \\( (R_q, C_q) \\), destroy the first walls that appear when looking up, down, left, and right from \\( (R_q, C_q) \\). Specifically, the following four processes occur simultaneously:\n  - If there exists an \\( i < R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( i < k < R_q \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists an \\( i > R_q \\) such that a wall exists at \\( (i, C_q) \\) and no wall exists at \\( (k, C_q) \\) for all \\( R_q < k < i \\), destroy the wall at \\( (i, C_q) \\).\n  - If there exists a \\( j < C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( j < k < C_q \\), destroy the wall at \\( (R_q, j) \\).\n  - If there exists a \\( j > C_q \\) such that a wall exists at \\( (R_q, j) \\) and no wall exists at \\( (R_q, k) \\) for all \\( C_q < k < j \\), destroy the wall at \\( (R_q, j) \\).\n\n**Constraints:**\n\n- \\( 1 \\leq H, W \\)\n- \\( H \\times W \\leq 4 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq R_q \\leq H \\)\n- \\( 1 \\leq C_q \\leq W \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nH W Q\nR_1 C_1\nR_2 C_2\n...\nR_Q C_Q\n```\n\n**Output:**\n\nPrint the number of remaining walls after processing all queries.\n\n**Sample Input 1:**\n\n```\n2 4 3\n1 2\n1 2\n1 3\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- In the 1st query, \\( (R_1, C_1) = (1, 2) \\). There is a wall at \\( (1, 2) \\), so it is destroyed.\n- In the 2nd query, \\( (R_2, C_2) = (1, 2) \\). No wall at \\( (1, 2) \\), so destroy the nearest walls at \\( (2,2) \\), \\( (1,1) \\), and \\( (1,3) \\).\n- In the 3rd query, \\( (R_3, C_3) = (1, 3) \\). No wall at \\( (1, 3) \\), so destroy the nearest walls at \\( (2,3) \\) and \\( (1,4) \\).\n\nAfter all queries, two walls remain, at \\( (2, 1) \\) and \\( (2, 4) \\).\n\nSolution:\n\n        Here is a cleaned version of the text focusing on the solution:\n\n---\n\nTo solve the problem efficiently, manage the remaining walls using data structures. Use two ordered sets (such as `std::set` in C++):\n\n1. `g1`: An array where each element is an ordered set maintaining column indices of the remaining walls in each row.\n2. `g2`: An array where each element is an ordered set maintaining row indices of the remaining walls in each column.\n\nBy utilizing binary search in these ordered sets (using `set::lower_bound`), each query can be processed in \\(\\mathrm{O}(\\log H + \\log W)\\) time. The overall time complexity for solving the problem is \\(\\mathrm{O}((HW + Q)(\\log H + \\log W))\\).\n\nSample Python3 code demonstrates this approach:\n\n```python\nimport sys\nfrom sortedcontainers import SortedSet\n\ninput = sys.stdin.read\ndata = input().split()\n\nH = int(data[0])\nW = int(data[1])\nQ = int(data[2])\nindex = 3\n\ng1 = [SortedSet() for _ in range(H)]\ng2 = [SortedSet() for _ in range(W)]\n\nfor i in range(H):\n    for j in range(W):\n        g1[i].add(j)\n        g2[j].add(i)\n\ndef erase(i, j):\n    g1[i].discard(j)\n    g2[j].discard(i)\n\nfor _ in range(Q):\n    R = int(data[index]) - 1\n    C = int(data[index + 1]) - 1\n    index += 2\n\n    if C in g1[R]:\n        erase(R, C)\n        continue\n\n    # up\n    it = g2[C].bisect_left(R)\n    if it > 0:\n        erase(g2[C][it - 1], C)\n    # down\n    if it < len(g2[C]):\n        erase(g2[C][it], C)\n    # left\n    it = g1[R].bisect_left(C)\n    if it > 0:\n        erase(R, g1[R][it - 1])\n    # right\n    if it < len(g1[R]):\n        erase(R, g1[R][it])\n\nans = sum(len(row) for row in g1)\nprint(ans)\n```\n\n---\n \n\n", "problem_ids": ["abc370_d"]}, "abc310_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nFor positive integers \\( x \\) and \\( y \\), define \\( f(x, y) \\) as the remainder of \\( (x + y) \\) divided by \\( 10^8 \\).\n\nYou are given a sequence of positive integers \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i, A_j) \\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 3 \\times 10^5 \\)\n- \\( 1 \\leq A_i < 10^8 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n3\n3 50000001 50000002\n```\n\n**Sample Output 1**\n\n```\n100000012\n```\n\n\\( f(A_1, A_2) = 50000004 \\), \\( f(A_1, A_3) = 50000005 \\), and \\( f(A_2, A_3) = 3 \\). Thus, the answer is \\( f(A_1, A_2) + f(A_1, A_3) + f(A_2, A_3) = 100000012 \\).\n\nNote that you are not asked to compute the remainder of the sum divided by \\( 10^8 \\).\n\n**Sample Input 2**\n\n```\n5\n1 3 99999999 99999994 1000000\n```\n\n**Sample Output 2**\n\n```\n303999988\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere is the clean version of the provided coding problem editorial:\n\n---\n\nWe reinterpret \\(f(x,y)\\) in a more useful form. In the constraints of this problem, \\(f(x,y)\\) is \\(x+y\\) if \\(x+y < 10^8\\) and \\(x+y-10^8\\) if \\(x+y\\geq 10^8\\). Thus, the answer can be found by evaluating \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N A_i + A_j\\), and then subtracting from it \\(10^8 \\times\\) the number of pairs \\((i,j)\\ (1\\leq i <j\\leq N)\\) such that \\(A_i + A_j\\) is greater than or equal to \\(10^8\\).\n\nRegarding \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N A_i + A_j\\), each term is added \\((N-1)\\) times, so it can be rewritten as \\((N-1)\\sum_{i=1}^{N} A_i\\), which can be found in \\(\\mathrm{O}(N)\\) time. Next, let us count the integer pairs \\((i,j)\\ (1\\leq i <j\\leq N)\\) such that \\(A_i + A_j\\) is greater than or equal to \\(10^8\\). The answer does not change by sorting \\(A\\) in ascending order, so we do so. Then, the minimum \\(j\\) with \\(A_i + A_j\\geq 10^8\\) monotonically decreases as \\(i\\) increases. Thus, the number of conforming integer pairs can be counted with the sliding window trick. Be careful not to count too much when \\(A_i = 5\\times 10^7\\).\n[END TEXT]\n \n\n", "problem_ids": ["abc353_c"]}, "abc310_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nAlice and Bob are playing a game with two positive integers \\( N \\) and \\( M \\), where \\( N < M \\). Each player has \\( N \\) cards numbered from 1 to \\( N \\). Alice starts the game, and they take turns playing one card from their hand onto the table. If, after a player plays a card, the sum of the numbers on the table is divisible by \\( M \\), the player who played the last card loses, and the other player wins. If all cards are played and the sum is never divisible by \\( M \\), Alice wins. Given \\( T \\) test cases, determine who will win (Alice or Bob) if both play optimally.\n\nConstraints:\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N < M \\leq 10^9 \\)\n\nInput:\n- The input consists of \\( T \\) test cases.\n- Each test case is described by two integers \\( N \\) and \\( M \\).\n\nOutput:\n- For each test case, output \"Alice\" if Alice wins or \"Bob\" if Bob wins when both players play optimally.\n\nSample Input:\n```\n8\n2 3\n3 6\n5 9\n45 58\n39 94\n36 54\n74 80\n61 95\n```\n\nSample Output:\n```\nAlice\nAlice\nBob\nBob\nAlice\nBob\nBob\nAlice\n```\n\nIn the first test case, both Alice and Bob have two cards: a 1 and a 2. Alice plays 1, and the sum is 1, which is not divisible by 3. Bob plays 1, making the sum 2, still not divisible by 3. Alice plays 2, making the sum 4, not divisible by 3. Bob plays 2, making the sum 6, which is divisible by 3, so Bob loses, and Alice wins. Alice wins regardless of Bob's strategy.\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 185\n\ndef mod_m_game(N, M):\n    # Calculate c\n    c = (N * (N + 1)) % M\n\n    # Determine if Alice loses or wins\n    if 1 <= c <= N:\n        return \"Bob wins\"\n    else:\n        return \"Alice wins\"\n\n# Example Usage\nN = 5\nM = 3\nresult = mod_m_game(N, M)\nprint(result)  # Output should be \"Bob wins\" or \"Alice wins\" based on the conditions\n```\n\nEditorial - AtCoder Regular Contest 185\n\nA - mod M Game 2 Editorial by evima\n\nFirst, focus on the moment when Alice plays her last card:\n\n- A player with two or more cards can avoid playing a losing card.\n- If Alice doesn't lose when playing her last card, she will win regardless of Bob's last move.\n\nDetermine if Alice loses with her last card using Bob\u2019s last card \\(b\\). The sum of the numbers on the cards played is \\(N(N+1) - b\\). We check if \\(N(N + 1) - b \\equiv 0 \\pmod{M}\\).\n\n1. If \\(1 \\leq (N(N+1) \\bmod M) \\leq N\\):\n   - Let \\(c = N(N + 1) \\bmod M\\). Bob can make his last card \\(b = c\\) by playing all cards except \\(c\\), leading to Alice's loss. Bob can achieve this by keeping \\(c\\) among his final cards.\n\n2. If \\(N(N + 1) - b\\) cannot be \\(0\\):\n   - Alice will not lose on her last card, leading to her victory.\n\nBob wins if \\(1 \\leq N(N + 1) \\bmod M \\leq N\\), otherwise Alice wins. This can be determined in \\(O(1)\\) time.\n \n\n", "problem_ids": ["arc185_a"]}, "abc310_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( L \\), and \\( R \\). For a sequence \\( A = (1, 2, \\dots, N) \\) of length \\( N \\), an operation of reversing the \\( L \\)-th through \\( R \\)-th elements was performed once. Print the sequence after this operation.\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\leq L \\leq R \\leq N \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN L R\n```\n\n**Output**\n\nLet \\( A' = (A'_1, A'_2, \\dots, A'_N) \\) be the sequence after the operation. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n5 2 3\n```\n\n**Sample Output 1**\n```\n1 3 2 4 5\n```\n\nExplanation: Initially, \\( A = (1, 2, 3, 4, 5) \\). After reversing the second through third elements, the sequence becomes \\( (1, 3, 2, 4, 5) \\), which should be printed.\n\n**Sample Input 2**\n```\n7 1 1\n```\n\n**Sample Output 2**\n```\n1 2 3 4 5 6 7\n```\n\nExplanation: It is possible that \\( L = R \\).\n\n**Sample Input 3**\n```\n10 1 10\n```\n\n**Sample Output 3**\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nExplanation: It is possible that \\( L = 1 \\) or \\( R = N \\).\n\nSolution:\n\nHere is the cleaned version of the editorial text:\n\nApproach 1: Actually construct an array and apply reversion. Solve the problem by constructing the sequence \\(A=(1,2,\\dots,N)\\) as an array, reverse the \\(L\\)-th through \\(R\\)-th elements, and print the result. First, let \\(l=L\\) and \\(r=R\\). While \\(l<r\\), swap the \\(l\\)-th and \\(r\\)-th element, add \\(1\\) to \\(l\\), and subtract \\(1\\) from \\(r\\). Note that the first element might be treated as the \\(0\\)-th one depending on array usage.\n\nSample code 1 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nwhile L < R:\n    A[L], A[R] = A[R], A[L]\n    L += 1\n    R -= 1\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nSample code 2 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nA[L:R + 1] = reversed(A[L:R + 1])\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nApproach 2: Directly construct the sought sequence. The structure is as follows: arrange \\(1,2,\\dots,L-1\\), then \\(R,R-1,\\dots,L\\), and finally \\(R+1,R+2,\\dots,N\\).\n\nSample code (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nres = []\n\nfor i in range(1, L):\n    res.append(i)\nfor i in range(R, L - 1, -1):\n    res.append(i)\nfor i in range(R + 1, N + 1):\n    res.append(i)\n\nfor i in range(N):\n    if i:\n        print(\" \", end=\"\")\n    print(res[i], end=\"\")\nprint()\n```\n \n\n", "problem_ids": ["abc356_a"]}, "abc311_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement (Score: 650 points)**\n\nWe call a positive integer \\( n \\) a \"good integer\" if and only if the sum of its positive divisors is divisible by 3. You are given two positive integers \\( N \\) and \\( M \\). Find the number, modulo 998244353, of length-\\( M \\) sequences \\( A \\) of positive integers such that the product of the elements in \\( A \\) is a good integer not exceeding \\( N \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^{10} \\)\n- \\( 1 \\leq M \\leq 10^5 \\)\n- \\( N \\) and \\( M \\) are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN M\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n10 1\n```\n\n**Sample Output 1**\n\n```\n5\n```\n\nThere are five sequences that satisfy the conditions:\n\n- (2)\n- (5)\n- (6)\n- (8)\n- (10)\n\n**Sample Input 2**\n\n```\n4 2\n```\n\n**Sample Output 2**\n\n```\n2\n```\n\nThere are two sequences that satisfy the conditions:\n\n- (1, 2)\n- (2, 1)\n\n**Sample Input 3**\n\n```\n370 907\n```\n\n**Sample Output 3**\n\n```\n221764640\n```\n\n**Sample Input 4**\n\n```\n10000000000 100000\n```\n\n**Sample Output 4**\n\n```\n447456146\n```\n\nSolution:\n\n```python\n# Here is the rewritten editorial with Python code:\n\n# Toyota Programming Contest 2024#9 (AtCoder Beginner Contest 370)\n\n# G - Divisible by 3 Editorial\n\n# This problem can be solved by finding a prefix sum of a multiplicative function. \n# A function f(n) is multiplicative if f(ab) = f(a) f(b) for all positive integers gcd(a, b) = 1.\n\n# Given a multiplicative function f(n), evaluate:\n# sum(1 <= n <= N) f(n).\n\n# **Facts and Problem Rephrasing:**\n\n# 1. sigma(n), the sum of the divisors of n, is multiplicative as per the formula:\n#    sigma(n) = prod(i=1 to k) (1 + p_i + ... + p_i^e_i)\n\n# 2. g(n), the number of length-M sequences of positive integers such that their product is M, is multiplicative:\n#    g(n) = prod(i=1 to k) comb(e_i + M - 1, M - 1)\n\n# Original problem:\n# sum(1 <= n <= N, sigma(n) % 3 = 0) g(n)\n\n# Define:\n# h(n) = \n# if sigma(n) % 3 == 0:\n#     0\n# else:\n#     g(n)\n\n# Rephrased Problem:\n# sum(n=1 to N) (g(n) - h(n))\n\n# Final expression:\n# sum(n=1 to N) g(n) - sum(n=1 to N) h(n)\n\n# There are efficient algorithms to compute these prefix sums:\n\n# **Lucy DP:**\n# Define:\n# F(n) = sum(1 <= m <= n) f(m),\n# F_prime(n) = sum(1 <= p <= n, p: prime) f(p),\n\n# Evaluate F_prime(n) for all n in Q_N using a dynamic programming approach, Lucy DP.\n\n# **Black Algorithm and Min_25 sieve:**\n# Evaluate F(N) using F_prime(n) results.\n\n# Black Algorithm: Uses a tree structure to compute F(N) leveraging the multiplicativity of the function.\n\n# Min_25 Sieve: Offers a more efficient approach with complexity O(N^(2/3)).\n\n# By implementing Lucy DP and one of the other methods, the problem is solved efficiently with complexity O(N^(3/4)/log N) or O(N^(1 - epsilon)).\n\n# **Advanced Topics:**\n\n# More efficient algorithms, like those by zhoukangyang (O(sqrt(N))) and Zhenting Zhu (Theta (N^(2/3) / (log N)^(4/3))), exist.\n# Other algorithms like Dujiao sieve or PowerfulNumber sieve can be used under specific conditions.\n```\n\n \n\n", "problem_ids": ["abc370_g"]}, "abc311_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given two permutations \\( P = (P_1, P_2, \\dots, P_N) \\) and \\( Q = (Q_1, Q_2, \\dots, Q_N) \\) of \\( (1, 2, \\dots, N) \\).\n\nWrite one of the characters '0' and '1' in each cell of an \\( N \\)-by-\\( N \\) grid so that all of the following conditions are satisfied:\n\n1. Let \\( S_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th row from the 1st to the \\( N \\)-th column. Then, \\( S_{P_1} < S_{P_2} < \\dots < S_{P_N} \\) in lexicographical order.\n\n2. Let \\( T_i \\) be the string obtained by concatenating the characters in the \\( i \\)-th column from the 1st to the \\( N \\)-th row. Then, \\( T_{Q_1} < T_{Q_2} < \\dots < T_{Q_N} \\) in lexicographical order.\n\nIt can be proved that for any \\( P \\) and \\( Q \\), there is at least one way to write the characters that satisfies all the conditions.\n\n**Lexicographical Order Explanation:**\n\nFor strings \\( X = X_1 X_2 \\dots X_{|X|} \\) and \\( Y = Y_1 Y_2 \\dots Y_{|Y|} \\), \" \\( X < Y \\) in lexicographical order\" means that condition 1 or 2 below holds:\n\n1. \\( |X| < |Y| \\) and \\( X_1 X_2 \\ldots X_{|X|} = Y_1 Y_2 \\ldots Y_{|X|} \\).\n\n2. There exists an integer \\( 1 \\leq i \\leq \\min\\lbrace |X|, |Y| \\rbrace \\) such that both of the following are true:\n   - \\( X_1 X_2 \\ldots X_{i-1} = Y_1 Y_2 \\ldots Y_{i-1} \\)\n   - \\( X_i \\) is less than \\( Y_i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 500 \\)\n- \\( P \\) and \\( Q \\) are permutations of \\( (1, 2, \\dots, N) \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from standard input in the following format:\n\n```\nN\nP_1 P_2 \\dots P_N\nQ_1 Q_2 \\dots Q_N\n```\n\n**Output:**\n\nPrint a way to fill the grid that satisfies the conditions in the following format, where \\( A_{ij} \\) is the character written at the \\( i \\)-th row and \\( j \\)-th column:\n\n```\nA_{11} A_{12} \\dots A_{1N}\n...\nA_{N1} A_{N2} \\dots A_{NN}\n```\n\nIf there are multiple ways to satisfy the conditions, any of them will be accepted.\n\n**Sample Input 1:**\n\n```\n3\n1 2 3\n2 1 3\n```\n\n**Sample Output 1:**\n\n```\n001\n101\n110\n```\n\nIn this sample, \\( S_1 = \\) \"001\", \\( S_2 = \\) \"101\", \\( S_3 = \\) \"110\", and \\( T_1 = \\) \"011\", \\( T_2 = \\) \"001\", \\( T_3 = \\) \"110\". Therefore, \\( S_1 < S_2 < S_3 \\) and \\( T_2 < T_1 < T_3 \\) hold, satisfying the conditions.\n\n**Sample Input 2:**\n\n```\n15\n8 15 10 2 4 3 1 13 5 12 9 6 14 11 7\n4 1 5 14 3 12 13 7 11 8 6 2 9 15 10\n```\n\n**Sample Output 2:**\n\n```\n010001111110101\n001000000101001\n010001001100010\n010000011110010\n010011101101101\n100101110100000\n111100011001000\n000001001100000\n100011011000101\n000111101011110\n101010101010101\n011010101011110\n010011000010011\n100110010110101\n000101101100100\n```\n\nSolution:\n\n```python\ndef fill_grid(N, P, Q):\n    grid = [[None] * N for _ in range(N)]\n\n    # Step 1: Write 0 in all cells of row P_1\n    for j in range(N):\n        grid[P[0]][j] = 0\n\n    # Step 2: Write 1 in all cells of column Q_N that are still empty\n    for i in range(N):\n        if grid[i][Q[N-1]] is None:\n            grid[i][Q[N-1]] = 1\n\n    # Recursive filling for remaining (N-1) x (N-1) cells\n    def fill_recursive(start, end, P, Q):\n        if start >= end:\n            return\n        # Write in row P[start]\n        for j in range(N):\n            if grid[P[start]][j] is None:\n                grid[P[start]][j] = 0\n        # Write in column Q[end]\n        for i in range(N):\n            if grid[i][Q[end]] is None:\n                grid[i][Q[end]] = 1\n        # Recurse on remaining subproblem\n        fill_recursive(start + 1, end - 1, P, Q)\n\n    fill_recursive(1, N-1, P, Q)\n\n    return grid\n\n# Example usage\nN = 3\nP = [0, 1, 2]  # Row order\nQ = [2, 1, 0]  # Column order\ngrid = fill_grid(N, P, Q)\nfor row in grid:\n    print(row)\n```\n\n**C - Row and Column Order Editorial by evima**\n\n**Solution**\n\n1. Write 0 in all cells of row \\(P_1\\).\n2. Write 1 in all cells of column \\(Q_N\\) that are still empty.\n3. For the remaining \\((N-1) \\times (N-1)\\) cells, let \\(S'_i\\) be the string obtained by concatenating row \\(i\\) excluding column \\(Q_N\\), and \\(T'_j\\) be the string obtained by concatenating column \\(j\\) excluding row \\(P_1\\). Then, recursively write in the same way so that \\(S'_{P_2} < S'_{P_3} < \\dots < S'_{P_N}\\) and \\(T'_{Q_2} < T'_{Q_3} < \\dots < T'_{Q_N}\\) hold.\n\nThe grid filled by this algorithm will satisfy the problem's conditions. Additionally, each column will contain at least one cell with 0, as 0 is always written in row \\(P_1\\). The lexicographical order of \\(S_{P_i}\\) and \\(T_{Q_i}\\) is maintained through recursive writing. The order of writing is \\(i=1,2,\\dots,N\\): first, write 0 in row \\(P_i\\) cells not yet written, then write 1 in column \\(Q_{N+1-i}\\) cells still empty.\n\n \n\n", "problem_ids": ["arc181_c"]}, "abc311_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThis problem is interactive, and the judge is adaptive. See the notes for details. Also, the parameters in the problem statement are fixed at \\( N = 1000 \\), \\( M = 10 \\), \\( Q = 950 \\).\n\nThere are \\( N \\) coins numbered \\( 1, 2, \\dots, N \\). Exactly \\( M \\) of these coins are counterfeit. An appraiser can, in one appraisal, determine whether two coins are of the same type or different types. Specifically:\n- If the two coins are both genuine or both counterfeit, they are judged to be of the same type.\n- Otherwise, they are judged to be of different types.\n\nIdentify all the counterfeit coins using at most \\( Q \\) appraisals.\n\n**Constraints**\n- \\( N = 1000 \\)\n- \\( M = 10 \\)\n- \\( Q = 950 \\)\n\n**Interaction**\n\nThis is an interactive problem. Initially, receive \\( N \\), \\( M \\), and \\( Q \\) from Standard Input:\n\n```\nN M Q\n```\n\nNext, you can perform appraisals between 0 and \\( Q \\) times, inclusive, as follows.\n\nFirst, by outputting to Standard Output in the following format, you indicate that you are appraising coins \\( x \\) and \\( y \\). (Include a newline at the end.)\n\n```\n? x y\n```\n\nHere, \\( x \\) and \\( y \\) must be distinct integers between 1 and \\( N \\), inclusive.\n\nIn response, the judge system will reply with one of the following three responses.\n\n- `0`: If the response is `0`, it means that coins \\( x \\) and \\( y \\) are of the same type.\n- `1`: If the response is `1`, it means that coins \\( x \\) and \\( y \\) are of different types.\n- `-1`: If the response is `-1`, it means that the appraisal is invalid. Specifically, this response is given when at least one of the following conditions is met:\n  - The outputted \\( x \\) and \\( y \\) do not satisfy the constraints.\n  - The number of appraisals exceeds \\( Q \\).\n\nIf you receive this response, your program is considered incorrect. Terminate your program immediately.\n\nFinally, by outputting to Standard Output in the following format, you answer that coins \\( A_1, A_2, \\ldots, A_M \\) are counterfeit. (Include a newline at the end.)\n\n```\n! A_1 A_2 \\dots A_M\n```\n\nHere, \\( A_i \\) must be distinct integers between 1 and \\( N \\), inclusive. After this output, terminate your program immediately.\n\nIf any of your outputs do not meet the specified format, your program will be considered incorrect. The judge will then respond with `-1`, so in that case, terminate your program immediately.\n\n**Notes**\n- Every time you output, include a newline at the end and flush Standard Output. Failure to do so may result in a verdict of Time Limit Exceeded (TLE) or Wrong Answer (WA).\n- After outputting your answer (or receiving `-1`), terminate your program immediately. Otherwise, the verdict is indeterminate.\n- Beware that unnecessary newlines are considered malformed.\n- The judge for this problem is adaptive. That is, at any point, as long as consistency can be maintained, the judge may change which coins are counterfeit. See the sample interaction for details.\n\n**Sample Interaction**\n\nIn this interaction, \\( N = 5 \\), \\( M = 2 \\), \\( Q = 10 \\), and the judge initially considers coins 1 and 2 to be counterfeit.\n\n*Note*: This example does not meet the constraints and is not included in the judge.\n\n**Input**\n```\n5 2 10\n```\n**Output**\n```\n? 1 2\n```\n**Explanation**: You appraise coins 1 and 2.\n\n**Input**\n```\n0\n```\n**Explanation**: Coins 1 and 2 are judged to be of the same type.\n\n**Output**\n```\n? 1 3\n```\n**Explanation**: You appraise coins 1 and 3.\n\n**Input**\n```\n1\n```\n**Explanation**: Coins 1 and 3 are judged to be of different types.\n\n**Output**\n```\n? 1 4\n```\n**Explanation**: You appraise coins 1 and 4.\n\n**Input**\n```\n1\n```\n**Explanation**: Coins 1 and 4 are judged to be of different types.\n\n**Output**\n```\n! 1 2\n```\n**Explanation**: You answer that coins 1 and 2 are counterfeit.\n\nIndeed, coins 1 and 2 are considered counterfeit, but it is also possible to consider coins 3 and 4 as counterfeit while maintaining consistency. Therefore, the judge may change the counterfeit coins to 3 and 4. As a result, the judge may judge this answer as incorrect.\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 184\n\nA - Appraiser Editorial by evima\n\nThe key point of this problem is that there are more genuine coins than counterfeit coins. Since there are \\(10\\) counterfeit coins, any group of \\(11\\) or more coins of the same type must be genuine.\n\nConsider dividing the \\(1000\\) coins into groups of \\(11\\). There will be \\(90\\) groups of \\(11\\) coins and a remainder of \\(10\\) coins. Among these \\(90\\) groups, at most \\(10\\) groups may contain counterfeit coins, so we can obtain at least \\(80\\) groups of \\(11\\) coins that are all of the same type. Also, we need \\(10\\) inspections to divide a group of \\(11\\) coins into two types (without knowing which is genuine).\n\nFirst, use \\(900\\) inspections to divide all the \\(11\\)-coin groups into two types. Next, exclude the coins that have been identified as genuine (where all \\(11\\) coins are of the same type). Record one coin number \\(x\\) identified as genuine. We have up to \\(20\\) groups of coins whose type is undetermined, and the \\(10\\) leftover coins. Using up to an additional \\(30\\) inspections, determine whether each remaining coin is of the same type as \\(x\\) to identify all counterfeit coins. This solution can identify all counterfeit coins using a maximum of \\(930\\) inspections.\n\nSample Implementation (Python 3):\n```python\ndef ask(x, y):\n    print(f\"? {x} {y}\")\n    # Assume here that we get a response from the interaction\n    res = int(input().strip())\n    return res\n\ndef ans(a):\n    print(\"!\", \" \".join(map(str, a)))\n\ndef main():\n    n, m, q = map(int, input().split())  # dummy input\n    ok = None\n    unknown = []\n    for i in range(90):\n        up = i * 11 + 1\n        g1 = [up]\n        g2 = []\n        for j in range(i * 11 + 2, i * 11 + 12):\n            if ask(up, j) == 0:\n                g1.append(j)\n            else:\n                g2.append(j)\n        if not g2:\n            ok = up\n        else:\n            unknown.append(g1)\n            unknown.append(g2)\n    for i in range(991, 1001):\n        unknown.append([i])\n    res = []\n    for nx in unknown:\n        if ask(nx[0], ok) == 1:\n            res.extend(nx)\n    ans(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["arc184_a"]}, "abc311_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( A_1, A_2, A_3 \\). Find the number of tuples of positive integers \\( (X_1, X_2, X_3) \\) that satisfy all of the following conditions, modulo \\( 998244353 \\):\n\n1. \\( X_1 \\) is a positive integer with \\( A_1 \\) digits in decimal notation.\n2. \\( X_2 \\) is a positive integer with \\( A_2 \\) digits in decimal notation.\n3. \\( X_3 \\) is a positive integer with \\( A_3 \\) digits in decimal notation.\n4. \\( X_1 + X_2 = X_3 \\).\n\nYou are given \\( T \\) test cases per input file; solve each of them.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\) for \\( i = 1, 2, 3 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is provided from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\u22ee\ncase_T\n```\n\nEach case is given in the following format:\n\n```\nA_1 A_2 A_3\n```\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for \\( case_i \\).\n\n**Sample Input 1**\n\n```\n4\n1 1 1\n1 6 7\n167 167 167\n111 666 777\n```\n\n**Sample Output 1**\n\n```\n36\n45\n731780675\n0\n```\n\n- For the first case, tuples such as \\( (X_1, X_2, X_3) = (1, 6, 7), (2, 1, 3) \\) satisfy the conditions. On the other hand, tuples such as \\( (X_1, X_2, X_3) = (6, 7, 13), (3, 4, 5) \\) do not. There are 36 tuples \\( (X_1, X_2, X_3) \\) that satisfy the conditions, so print 36.\n- For the third case, remember to print the result modulo 998244353.\n- For the fourth case, there may be no tuples \\( (X_1, X_2, X_3) \\) that satisfy the conditions.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 178\n\nB - 1 + 6 = 7 Editorial by evima\n\nWe aim to find the number of pairs of integers \\((X_{1}, X_{2})\\) satisfying:\n\n\\(10^{A_{1} - 1} \\leq X_{1}\\)\n\n\\(10^{A_{2}-1} \\leq X_{2}\\)\n\n\\(X_{1} + X_{2} < 10^{A_{3}}\\)\n\n\\(10^{A_{1}} \\leq X_{1}\\) does not hold.\n\n\\(10^{A_{2}} \\leq X_{2}\\) does not hold.\n\n\\(X_{1} + X_{2} < 10^{A_{3}-1}\\) does not hold.\n\nUsing the inclusion-exclusion principle, the answer can be expressed as:\n\\[\\sum_{i=0}^{1}\\sum_{j=0}^{1}\\sum_{k=0}^{1}f(A_{1} - i, A_{2} - j, A_{3} - k)(-1)^{i+j+k} \\]\n\nFor \\(f(B_{1}, B_{2}, B_{3})\\):\n\nIf \\(B_{3} \\leq \\max(B_{1}, B_{2})\\), \\(f(B_{1}, B_{2}, B_{3}) = 0\\).\n\nIf \\(B_{3} > \\max(B_{1}, B_{2})\\), \\(f(B_{1}, B_{2}, B_{3}) = \\dfrac{(10^{B_{3}}-10^{B_{1}}-10^{B_{2}})(10^{B_{3}}-10^{B_{1}}-10^{B_{2}} + 1)}{2}\\).\n\nThis computation can be done in \\(O(\\log(A_{3}))\\) time per test case.\n\nPython Implementation Example:\n```python\nMOD = 998244353\n\ndef f(b1, b2, b3):\n    if max(b1, b2) >= b3:\n        return 0\n    tmp = pow(10, b3, MOD) - pow(10, b1, MOD) - pow(10, b2, MOD)\n    return (tmp + 1) * tmp // 2\n\nT = int(input())\nfor _ in range(T):\n    a1, a2, a3 = map(int, input().split())\n    ans = 0\n    pm = 1\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                ans = (ans + f(a1 - i, a2 - j, a3 - k) * pm) % MOD\n                pm *= -1\n            pm *= -1\n        pm *= -1\n    print(ans)\n```\n```\n \n\n", "problem_ids": ["arc178_b"]}, "abc311_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given two strings \\( S \\) and \\( T \\) consisting of lowercase English letters. Here, \\( S \\) and \\( T \\) have equal lengths.\n\nLet \\( X \\) be an empty array, and repeat the following operation until \\( S \\) equals \\( T \\):\n\n- Change one character in \\( S \\), and append \\( S \\) to the end of \\( X \\).\n\nFind the array of strings \\( X \\) with the minimum number of elements obtained in this way. If there are multiple such arrays with the minimum number of elements, find the lexicographically smallest one among them.\n\n**Lexicographical order on arrays of strings:**\n\nA string \\( S = S_1 S_2 \\ldots S_N \\) of length \\( N \\) is lexicographically smaller than a string \\( T = T_1 T_2 \\ldots T_N \\) of length \\( N \\) if there exists an integer \\( 1 \\leq i \\leq N \\) such that both of the following are satisfied:\n\n1. \\( S_1 S_2 \\ldots S_{i-1} = T_1 T_2 \\ldots T_{i-1} \\)\n2. \\( S_i \\) comes earlier than \\( T_i \\) in alphabetical order.\n\nAn array of strings \\( X = (X_1, X_2, \\ldots, X_M) \\) with \\( M \\) elements is lexicographically smaller than an array of strings \\( Y = (Y_1, Y_2, \\ldots, Y_M) \\) with \\( M \\) elements if there exists an integer \\( 1 \\leq j \\leq M \\) such that both of the following are satisfied:\n\n1. \\( (X_1, X_2, \\ldots, X_{j-1}) = (Y_1, Y_2, \\ldots, Y_{j-1}) \\)\n2. \\( X_j \\) is lexicographically smaller than \\( Y_j \\).\n\n**Constraints:**\n- \\( S \\) and \\( T \\) are strings consisting of lowercase English letters with lengths between 1 and 100, inclusive.\n- The lengths of \\( S \\) and \\( T \\) are equal.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n- Line 1: String \\( S \\)\n- Line 2: String \\( T \\)\n\n**Output:**\nLet \\( M \\) be the number of elements in the desired array. Print \\( M + 1 \\) lines:\n- The first line should contain the value of \\( M \\).\n- The \\( i + 1 \\)-th line (for \\( 1 \\leq i \\leq M \\)) should contain the \\( i \\)-th element of the array.\n\n**Sample Input 1:**\n```\nadbe\nbcbc\n```\n\n**Sample Output 1:**\n```\n3\nacbe\nacbc\nbcbc\n```\n\n**Explanation:**\nInitially, \\( S = \\) `adbe`. We can obtain \\( X = ( \\) `acbe`, `acbc`, `bcbc` \\( ) \\) by performing the following operations:\n1. Change \\( S \\) to `acbe` and append `acbe` to the end of \\( X \\).\n2. Change \\( S \\) to `acbc` and append `acbc` to the end of \\( X \\).\n3. Change \\( S \\) to `bcbc` and append `bcbc` to the end of \\( X \\).\n\n**Sample Input 2:**\n```\nabcde\nabcde\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\nafwgebrw\noarbrenq\n```\n\n**Sample Output 3:**\n```\n8\naawgebrw\naargebrw\naarbebrw\naarbebnw\naarbebnq\naarbeenq\naarbrenq\noarbrenq\n```\n\nSolution:\n\n        Here is a cleaned-up version of the text:\n\n---\n\nLet \\(N\\) be the length of the string, and \\(x\\) be the number of \\(i\\) with \\(S_i \\neq T_i\\). The minimum possible number of operations is \\(x\\), and each operation replaces \\(S_i\\) with \\(T_i\\) for some \\(i\\) where \\(S_i \\neq T_i\\).\n\nThe order of these operations can vary, and to achieve a lexicographically minimum string, we can consider doing the operation that results in the minimal string. This brute-force approach can be accomplished in \\(O(N^3)\\) time. It can be further optimized: when \\(S_i\\) is replaced with \\(T_i\\), the string becomes larger if \\(S_i < T_i\\) and smaller if \\(S_i > T_i\\). Therefore, it's optimal to apply operations on the minimum \\(i\\) with \\(S_i > T_i\\). If there\u2019s no such \\(i\\), apply the operation against the maximum \\(i\\) with \\(S_i < T_i\\). This approach runs in \\(O(N^2)\\) time.\n\nSample code (\\(O(N^3)\\)):\n\n```python\ndef main():\n    s = input()\n    t = input()\n    ans = []\n    n = len(s)\n    while s != t:\n        nxt = 'z' * n\n        for i in range(n):\n            if s[i] != t[i]:\n                tmp = list(s)\n                tmp[i] = t[i]\n                s_tmp = ''.join(tmp)\n                nxt = min(nxt, s_tmp)\n        ans.append(nxt)\n        s = nxt\n    sz = len(ans)\n    print(sz)\n    for e in ans:\n        print(e)\n\nmain()\n```\n\nSample code (\\(O(N^2)\\)):\n\n```python\ndef main():\n    s = input()\n    t = input()\n    ans = []\n    v = []\n    n = len(s)\n    for i in range(n):\n        if s[i] > t[i]:\n            v.append(i)\n    for i in range(n - 1, -1, -1):\n        if s[i] < t[i]:\n            v.append(i)\n    sz = len(v)\n    for i in range(sz):\n        s = list(s)\n        s[v[i]] = t[v[i]]\n        ans.append(''.join(s))\n        s = ''.join(s)\n    print(sz)\n    for e in ans:\n        print(e)\n\nmain()\n```\n\n---\n \n\n", "problem_ids": ["abc370_c"]}, "abc312_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of length \\(N\\). On this sequence, the following operation can be performed:\n\nChoose \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Replace each of \\(A_{l+1}, A_{l+2}, \\dots, A_{r-1}\\) with \\(A_l\\). The cost of this operation is \\(r-l-1\\).\n\nYou will repeat this operation until there is no \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Find the minimum total cost of such a series of operations.\n\n**Constraints:**\n- \\(3 \\leq N \\leq 5 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq N\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n7\n1 2 3 2 3 2 1\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n_For example, if you perform the operation with \\((l, r) = (3, 5), (2, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,3,3,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\), after which there is no \\(l\\) and \\(r\\) with the said property. The total cost of this series of operations is \\(1+3+5=9\\)._\n\n_On the other hand, if you perform the operation with \\((l, r) = (2, 4), (4, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,2,2,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\). The total cost of this series of operations is \\(1+1+5=7\\)._\n\n**Sample Input 2:**\n```\n5\n1 2 3 4 5\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n40\n1 2 3 4 5 6 7 8 7 6 5 6 7 8 7 6 5 4 3 2 2 1 2 3 4 5 4 5 6 7 8 7 7 6 5 6 6 7 8 8\n```\n\n**Sample Output 3:**\n```\n44\n```\n\nSolution:\n\n```\nHere's a cleaned-up version of the solution:\n\nStarting from a vertex with color \\(A_i\\) and a piece placed on it, create a tree with colored vertices by performing the following steps for \\(i=2,3,\\dots,N\\): Let \\(pos\\) be the current position. If the color of the vertex at \\(pos\\) is \\(A_i\\), do nothing. If there is an adjacent vertex to \\(pos\\) with color \\(A_i\\), move the piece there. If no such vertex exists, create a new adjacent vertex with color \\(A_i\\) and move the piece there. The colors of adjacent vertices are always distinct. \n\nThe state of the sequence corresponds to a walk on this tree, where operations change a walk \\(u\\rightarrow v\\rightarrow v\\rightarrow \\dots \\rightarrow v\\rightarrow u\\) to \\(u\\rightarrow u\\rightarrow u\\rightarrow \\dots \\rightarrow u\\rightarrow u\\). Let \\(start\\) and \\(goal\\) be the start and end points of the walk. The problem is finding the minimum cost to change the walk into a simple path connecting \\(start\\) and \\(goal\\). \n\nCalculate the minimum cost. Consider parts of the walk off the path connecting \\(start\\) and \\(goal\\), like \\(\\dots \\rightarrow a \\rightarrow b \\rightarrow \\dots \\rightarrow b \\rightarrow a \\rightarrow \\dots\\). Convert \\(b \\rightarrow \\dots \\rightarrow b\\) to stay at \\(a\\), with the cost equivalent to the sum of distances to \\(a\\). The problem becomes: \n\nGiven \\(V=(v_1,v_2,\\dots,v_n)\\) with:\n\n\\(v_1=1, v_n=\\max_{1\\leq i \\leq n} v_i\\)\n\\(|v_i-v_{i+1}| \\in \\{0,1\\}\\),\n\nFind the minimum \\(\\sum |v_i-v'_i|\\) for \\(V'=(v'_1,v'_2,\\dots,v'_n)\\) where:\n\n\\(v'_1=v_1, v'_n=v_n\\)\n\\(v'_i \\leq v'_{i+1}\\)\nIf \\(v'_i \\neq v'_{i+1}\\), then \\(v_i=v'_i\\) and \\(v_{i+1}=v'_{i+1}\\).\n\nSolve this using dynamic programming in \\(O(N)\\): \n\nUse \\(dp[k]=\\) the minimum value of \\(\\sum_{k \\leq i} |v_i-v'_i|\\) when \\(v'_k=v_k\\). If \\(v_{k+1}=v_k+1\\), update \\(dp[k] \\leftarrow \\min(dp[k],dp[k+1])\\). Let \\(k'\\) be the smallest \\(i\\ (k < i)\\) such that \\(v_{i}=v_k\\), then update \\(dp[k] \\leftarrow \\min(dp[k],dp[k']+\\sum_{i=k+1}^{k'}|v_k-v_i|)\\).\n```\n \n\n", "problem_ids": ["arc181_f"]}, "abc312_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integer sequences of length \\( N \\): \\( A = (A_1, A_2, \\cdots, A_N) \\) and \\( B = (B_1, B_2, \\cdots, B_N) \\), and an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n- Choose integers \\( i \\) and \\( j \\) (where \\( 1 \\leq i, j \\leq N \\)) such that \\( |i-j| \\leq K \\). Then, change the value of \\( A_i \\) to \\( A_j \\).\n\nDetermine whether it is possible to make \\( A \\) identical to \\( B \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 125000 \\)\n- \\( 1 \\leq K < N \\leq 250000 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- The sum of \\( N \\) across all test cases in each input is at most 250000.\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\nB_1 B_2 \\cdots B_N\n```\n\n**Output Format**\n\nFor each test case, print `Yes` if it is possible to make \\( A \\) identical to \\( B \\), and `No` otherwise.\n\n**Sample Input 1**\n\n```\n4\n3 1\n1 1 2\n1 2 2\n5 4\n2 4 5 1 3\n2 1 3 2 2\n13 1\n3 1 3 3 5 3 3 4 2 2 2 5 1\n5 3 3 3 4 2 2 2 2 5 5 1 3\n20 14\n10 6 6 19 13 16 15 15 2 10 2 16 9 12 2 6 13 5 5 9\n5 9 6 2 10 19 16 15 13 12 10 2 9 6 5 16 19 12 15 13\n```\n\n**Sample Output 1**\n\n```\nYes\nYes\nNo\nYes\n```\n\n**Explanation for Sample Input 1**\n\nConsider the first test case. If we operate with \\( i=2 \\) and \\( j=3 \\), the value of \\( A_2 \\) will be changed to \\( A_3=2 \\), resulting in \\( A=(1,2,2) \\).\n\nSolution:\n\n```\nOfficial\n\nB - Near Assignment Editorial by evima\n\nIf \\(A = B\\), it is clearly possible, so we consider other cases. Consider two cases based on the value of \\(K\\).\n\nCase \\(K = 1\\): Considering the result of run-length encoding of the elements in \\(A\\), it can \u201cdecrease\u201d through operations, but not \u201cincrease.\u201d From this, we can deduce that the result of run-length encoding of \\(B\\) must be a subsequence of the run-length encoded \\(A\\). This condition is also sufficient because we can perform operations that extend the subsequence of \\(A\\) corresponding to \\(B\\). This solves the case where \\(K = 1\\).\n\nCase \\(K \\geq 2\\): Looking at the operations in reverse, they can be seen as follows:\n\nChoose \\(i,j\\) that satisfy \\(|i-j| \\leq K\\) and \\(B_i = B_j\\), then change \\(B_i\\) to any desired value. First, if no operation can be performed on \\(B\\), the answer is No. Also, if there is a value in \\(B\\) that does not appear in \\(A\\), the answer is No. Actually, in all other cases, the answer is Yes. Let\u2019s reinterpret the part where \\(B_i\\) can be changed to any desired value as an operation where \\(B_i\\) is changed to a wildcard \\(*\\). By performing one operation on \\(B\\), we create a state where there is exactly one \\(*\\). The involvement of \\(*\\) enables us to swap adjacent elements in \\(B\\).\n\nIf you want to change \\(*x\\) to \\(x*\\): think of \\(*x\\) as \\(xx\\) and perform the operation to turn it into \\(x*\\). If you want to change \\(*xy\\) to \\(*yx\\): follow the steps \\(*xy \\to yxy \\to yx* \\to y*x \\to *yx\\).\n\nBy combining these operations, you can remove all duplicates in \\(B\\) and arrange them in any desired order. In particular, you can arrange \\(B\\) to match \\(A\\). Therefore, it can be determined that \\(A\\) can be transformed into \\(B\\). Implementing the above operations directly yields an \\(O(N)\\) solution. The sample code below lazily uses sorting and is an \\(O(N\\log N)\\) solution.\n```\n \n\n", "problem_ids": ["arc183_b"]}, "abc312_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 450 points\n\n## Problem Statement\n\nThere are \\( N \\) islands and \\( M \\) bidirectional bridges connecting two islands. The islands and bridges are numbered \\( 1, 2, \\ldots, N \\) and \\( 1, 2, \\ldots, M \\), respectively. Bridge \\( i \\) connects islands \\( U_i \\) and \\( V_i \\), and the time it takes to cross it in either direction is \\( T_i \\). No bridge connects an island to itself, but it is possible for two islands to be directly connected by more than one bridge. One can travel between any two islands using some bridges.\n\nYou are given \\( Q \\) queries, so answer each of them. The \\( i \\)-th query is as follows:\n\n- You are given \\( K_i \\) distinct bridges: bridges \\( B_{i,1}, B_{i,2}, \\ldots, B_{i,K_i} \\).\n- Find the minimum time required to travel from island \\( 1 \\) to island \\( N \\) using each of these bridges at least once.\n- Only consider the time spent crossing bridges.\n- You can cross the given bridges in any order and in any direction.\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 400 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq T_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 3000 \\)\n- \\( 1 \\leq K_i \\leq 5 \\)\n- \\( 1 \\leq B_{i,1} < B_{i,2} < \\cdots < B_{i,K_i} \\leq M \\)\n- All input values are integers.\n- It is possible to travel between any two islands using some bridges.\n\n## Input\n\nThe input is given in the following format:\n```\nN M\nU_1 V_1 T_1\nU_2 V_2 T_2\n\u22ee\nU_M V_M T_M\nQ\nK_1\nB_{1,1} B_{1,2} \u22ef B_{1,{K_1}}\nK_2\nB_{2,1} B_{2,2} \u22ef B_{2,{K_2}}\n\u22ee\nK_Q\nB_{Q,1} B_{Q,2} \u22ef B_{Q,{K_Q}}\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq Q \\)) should contain the answer to the \\( i \\)-th query as an integer.\n\n## Sample Input 1\n\n```\n3 5\n1 2 10\n1 3 20\n1 3 30\n2 3 15\n2 3 25\n2\n1\n1\n2\n3 5\n```\n\n## Sample Output 1\n\n```\n25\n70\n```\n\nExplanation:\n- For the first query, the minimum time to travel from island 1 to island 3 using bridge 1 is achieved by using bridge 1 to move from island 1 to island 2, then bridge 4 to move from island 2 to island 3. The time taken is 10 + 15 = 25.\n- For the second query, the minimum time to travel from island 1 to island 3 using both bridges 3 and 5 is achieved by using bridge 3 to move from island 1 to island 3, then using bridge 5 to move to island 2, and finally bridge 4 to return to island 3. The time taken is 30 + 25 + 15 = 70.\n\n## Sample Input 2\n\n```\n6 6\n1 5 1\n2 5 1\n2 4 1\n3 4 1\n3 6 1\n1 6 1\n2\n5\n1 2 3 4 5\n1\n5\n```\n\n## Sample Output 2\n\n```\n5\n3\n```\n\nRemarks: You can cross the specified bridges in either direction.\n\n## Sample Input 3\n\n```\n5 5\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4 5 1000000000\n1 5 1000000000\n1\n1\n3\n```\n\n## Sample Output 3\n\n```\n4000000000\n```\n\nNote: The answer may not fit in a 32-bit integer.\n\nSolution:\n\n```python\nimport itertools\n\nN = 400\nM = int(2e5)\nINF = int(1e15)\n\nn = 0\nu = [0] * M\nv = [0] * M\nt = [0] * M\nd = [[0 if i == j else INF for j in range(N)] for i in range(N)]\nk = 0\na = []\n\ndef solve():\n    ans = INF\n    dp = [[0] * 2 for _ in range(5)]\n    b = list(range(k))\n    for perm in itertools.permutations(b):\n        dp[0][0] = d[0][v[a[perm[0]]]] + t[a[perm[0]]]\n        dp[0][1] = d[0][u[a[perm[0]]]] + t[a[perm[0]]]\n        for i in range(k - 1):\n            dp[i + 1][0] = min(dp[i][0] + d[u[a[perm[i]]]][v[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][v[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n            dp[i + 1][1] = min(dp[i][0] + d[u[a[perm[i]]]][u[a[perm[i + 1]]]], dp[i][1] + d[v[a[perm[i]]]][u[a[perm[i + 1]]]]) + t[a[perm[i + 1]]]\n        ans = min(ans, dp[k-1][0] + d[u[a[perm[k-1]]]][n-1])\n        ans = min(ans, dp[k-1][1] + d[v[a[perm[k-1]]]][n-1])\n    return ans\n\ndef main():\n    global n, k\n    m, q = map(int, input().split())\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d[i][j] = INF\n\n    for i in range(m):\n        u[i], v[i], t[i] = map(int, input().split())\n        u[i] -= 1\n        v[i] -= 1\n        d[u[i]][v[i]] = min(d[u[i]][v[i]], t[i])\n        d[v[i]][u[i]] = min(d[v[i]][u[i]], t[i])\n\n    for i1 in range(n):\n        for i0 in range(n):\n            for i2 in range(n):\n                d[i0][i2] = min(d[i0][i2], d[i0][i1] + d[i1][i2])\n    \n    for _ in range(q):\n        k = int(input())\n        a.clear()\n        for _ in range(k):\n            x = int(input())\n            a.append(x-1)\n        print(solve())\n\nif __name__ == '__main__':\n    main()\n```\n\n \n\n", "problem_ids": ["abc369_e"]}, "abc312_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou have 12 strings \\( S_1, S_2, \\ldots, S_{12} \\) consisting of lowercase English letters. Determine how many integers \\( i \\) (where \\( 1 \\leq i \\leq 12 \\)) satisfy the condition that the length of the string \\( S_i \\) is exactly \\( i \\).\n\n**Constraints:**\n\n- Each \\( S_i \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters for \\( 1 \\leq i \\leq 12 \\).\n\n**Input:**\n\nThe input consists of 12 lines, where each line contains a single string representing \\( S_1, S_2, \\ldots, S_{12} \\).\n\n**Output:**\n\nPrint the number of integers \\( i \\) (where \\( 1 \\leq i \\leq 12 \\)) such that the length of \\( S_i \\) is \\( i \\).\n\n**Sample Input 1:**\n\n```\njanuary\nfebruary\nmarch\napril\nmay\njune\njuly\naugust\nseptember\noctober\nnovember\ndecember\n```\n\n**Sample Output 1:**\n\n```\n1\n```\n\nExplanation: There is only one integer \\( i \\) such that the length of \\( S_i \\) is \\( i \\): 9. Thus, print 1.\n\n**Sample Input 2:**\n\n```\nve\ninrtfa\nnpccxva\ndjiq\nlmbkktngaovl\nmlfiv\nfmbvcmuxuwggfq\nqgmtwxmb\njii\nts\nbfxrvs\neqvy\n```\n\n**Sample Output 2:**\n\n```\n2\n```\n\nExplanation: There are two integers \\( i \\) such that the length of \\( S_i \\) is \\( i \\): 4 and 8. Thus, print 2.\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 373\n\nThis problem requires the usage of a for statement and the retrieval of the length of a string. Use a for statement to repeat the operation for \\(i=1,2,\\ldots, 12\\):\n\n1. Read a string.\n2. If its length equals \\(i\\), add \\(1\\) to the answer.\n\nTo implement this, use the appropriate function for string length retrieval provided by your programming language. In C++, a string type is represented by `std::string`; for a `std::string s`, its length can be obtained as `s.size()`. In Python, the length of `s` can be obtained as `len(s)`. Here are sample codes:\n\n**Sample code (Python3):**\n```python\nans = 0\n\nfor i in range(1, 12 + 1):\n    s = input()  # Read string s\n    if len(s) == i:  # Check if its length equals i\n        ans += 1  # If so, add 1 to the answer\n\nprint(ans)\n```\n \n\n", "problem_ids": ["abc373_a"]}, "abc312_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThis is an interactive problem where your program interacts with the judge via input and output.\n\nYou are given a positive integer \\(N\\) and integers \\(L\\) and \\(R\\) such that \\(0 \\leq L \\leq R < 2^N\\). The judge has a hidden sequence \\(A = (A_0, A_1, \\dots, A_{2^N-1})\\) consisting of integers between 0 and 99, inclusive.\n\nYour goal is to find the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100. However, you cannot directly know the values of the elements in the sequence \\(A\\). Instead, you can ask the judge the following question:\n\nChoose non-negative integers \\(i\\) and \\(j\\) such that \\(2^i(j+1) \\leq 2^N\\). Let \\(l = 2^i j\\) and \\(r = 2^i (j+1) - 1\\). Ask for the remainder when \\(A_l + A_{l+1} + \\dots + A_r\\) is divided by 100.\n\nLet \\(m\\) be the minimum number of questions required to determine the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100 for any sequence \\(A\\). You need to find this remainder within \\(m\\) questions.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 18\\)\n- \\(0 \\leq L \\leq R \\leq 2^N - 1\\)\n- All input values are integers.\n\n**Input and Output**\n\nThis is an interactive problem.\n\nFirst, read the integers \\(N\\), \\(L\\), and \\(R\\) from Standard Input:\n\n```\nN L R\n```\n\nThen, repeat asking questions until you can determine the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100. Each question should be printed in the following format:\n\n```\n? i j\n```\n\nHere, \\(i\\) and \\(j\\) must satisfy the following constraints:\n\n- \\(i\\) and \\(j\\) are non-negative integers.\n- \\(2^i(j+1) \\leq 2^N\\)\n\nThe response to the question will be given in the following format from Standard Input:\n\n```\nT\n```\n\nHere, \\(T\\) is the answer to the question, which is the remainder when \\(A_l + A_{l+1} + \\dots + A_r\\) is divided by 100, where \\(l = 2^i j\\) and \\(r = 2^i (j+1) - 1\\).\n\nIf \\(i\\) and \\(j\\) do not satisfy the constraints, or if the number of questions exceeds \\(m\\), then \\(T\\) will be -1.\n\nIf the judge returns -1, your program is already considered incorrect. In this case, terminate the program immediately.\n\nOnce you have determined the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100, print the remainder \\(S\\) in the following format and terminate the program immediately:\n\n```\n! S\n```\n\n**Notes**\n\n- At the end of each output, print a newline and flush Standard Output. Otherwise, the verdict may be Time Limit Exceeded (TLE).\n- If your output is malformed or your program exits prematurely, the verdict will be indeterminate.\n- After printing the answer, terminate the program immediately. Otherwise, the verdict will be indeterminate.\n\n**Example**\n\nHere is an example for \\(N=3\\), \\(L=1\\), \\(R=5\\), and \\(A=(31, 41, 59, 26, 53, 58, 97, 93)\\). In this case, \\(m=3\\), so you can ask up to three questions.\n\n**Input**\n```\n3 1 5\n```\n**Output**\n```\n? 0 1\n41\n? 1 1\n85\n? 1 2\n11\n! 37\n```\n\nSolution:\n\n```python\nfrom collections import deque\n\nN, L, R = map(int, input().split())\nn = 1 << N\nedge = [[] for i in range(n + 1)]\nfor i in range(N + 1):\n    for l in range(0, n, 1 << i):\n        r = l + (1 << i)\n        edge[l].append(r)\n        edge[r].append(l)\n\nparent = [None] * (n + 1)\nparent[R + 1] = -1\ndq = deque([R + 1])\nwhile dq:\n    v = dq.popleft()\n    for u in edge[v]:\n        if parent[u] == None:\n            parent[u] = v\n            dq.append(u)\n\nans = 0\nnow = L\nwhile parent[now] != -1:\n    p = parent[now]\n    sgn = 1\n    l, r = now, p\n    if l > r:\n        sgn = -1\n        l, r = r, l\n    i = (r - l).bit_length() - 1\n    j = l >> i\n    print(\"?\", i, j, flush=True)\n    T = int(input())\n    ans += sgn * T\n    now = p\n\nprint(\"!\", ans % 100)\n```\n \n\n", "problem_ids": ["abc355_e"]}, "abc312_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nYou will perform the following operation exactly once:\n\n- Choose a non-empty subsequence of \\( A \\) (not necessarily contiguous) and replace it with its cumulative sums.\nMore precisely, first choose a sequence of indices \\( (i_1, i_2, \\ldots, i_k) \\) such that \\( 1 \\leq i_1 < i_2 < \\cdots < i_k \\leq N \\).\n  The length of the sequence \\( k \\) (\\( 1 \\leq k \\leq N \\)) can be chosen freely.\n  Then, for each \\( j \\) (\\( 1 \\leq j \\leq k \\)), replace the value of \\( A_{i_j} \\) with \\( \\sum_{1 \\leq x \\leq j} A_{i_x} \\).\n  This replacement is done simultaneously for all chosen indices.\n\nFind, modulo \\( 10^9 + 7 \\), the number of possible sequences \\( A \\) after the operation.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\(-10 \\leq A_i \\leq 10 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\[\nN \\\\\nA_1\\ A_2\\ \\cdots\\ A_N\n\\]\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n3\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nThe possible sequences \\( A \\) after the operation are as follows:\n- \\( A = (1, 1, 2) \\): This can be achieved with \\( k = 1 \\) and \\( (i_1) = (1) \\).\n- \\( A = (1, 2, 2) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 2) \\).\n- \\( A = (1, 1, 3) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 3) \\).\n- \\( A = (1, 2, 4) \\): This can be achieved with \\( k = 3 \\) and \\( (i_1, i_2, i_3) = (1, 2, 3) \\).\n\n**Sample Input 2**\n\n```\n4\n1 -1 1 -1\n```\n\n**Sample Output 2**\n\n```\n8\n```\n\n**Sample Input 3**\n\n```\n5\n0 0 0 0 0\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\n**Sample Input 4**\n\n```\n40\n2 -2 1 3 -3 -1 -2 -3 0 -1 -2 0 -3 0 0 2 0 -1 2 -2 -2 -1 3 -2 -2 -2 2 3 2 -3 0 -2 2 1 3 0 -1 0 -2 -3\n```\n\n**Sample Output 4**\n\n```\n420429545\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Regular Contest 180\n\nC - Subsequence and Prefix Sum Editorial by evima\n\nConsider the following DP: \\(dp[i][j]=\\) The number of ways to perform the operation on the first \\(i\\) terms so that \\(A_i\\) changes to \\(A_i+j\\) (\\(j \\neq 0\\)). Because \\(j \\neq 0\\), the operation counted in \\(dp[i][j]\\) always selects \\(A_i\\) for the operation. The next term will increase by \\(A_i+j\\). The transition for \\(A_i+j \\neq 0\\) is straightforward. For \\(A_i+j=0\\), let \\(A_k\\) be the next term to change. To change \\(A_k \\to A_k+v\\), select \\(v\\) from \\(A_{i+1},\\cdots,A_{k-1}\\). Implementing these covers all transitions. This problem can be solved in \\(O(N^3 \\max(|A_i|))\\) time.\n[END TEXT]\n \n\n", "problem_ids": ["arc180_c"]}, "abc313_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 600 points\n\nProblem Statement:\nThere are \\(N\\) stones placed on a 2-dimensional plane. The \\(i\\)-th stone is located at coordinates \\((X_i, Y_i)\\). All stones are located at lattice points in the first quadrant (including the axes).\n\nCount the number of lattice points \\((x, y)\\) where no stone is placed and it is **impossible** to reach \\((-1, -1)\\) from \\((x, y)\\) by repeatedly moving up, down, left, or right by 1 without passing through coordinates where a stone is placed.\n\nMore precisely, count the number of lattice points \\((x, y)\\) where no stone is placed, and there does **not** exist a finite sequence of integer pairs \\((x_0, y_0), \\ldots, (x_k, y_k)\\) that satisfies all of the following four conditions:\n1. \\((x_0, y_0) = (x, y)\\).\n2. \\((x_k, y_k) = (-1, -1)\\).\n3. \\(|x_i - x_{i+1}| + |y_i - y_{i+1}| = 1\\) for all \\(0 \\leq i < k\\).\n4. There is no stone at \\((x_i, y_i)\\) for all \\(0 \\leq i \\leq k\\).\n\nConstraints:\n- \\(0 \\leq N \\leq 2 \\times 10^5\\)\n- \\(0 \\leq X_i, Y_i \\leq 2 \\times 10^5\\)\n- The pairs \\((X_i, Y_i)\\) are distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nX_1 Y_1\n\\vdots\nX_N Y_N\n```\n\nOutput:\nPrint the number of lattice points that satisfy the conditions.\n\nSample Input 1:\n```\n5\n1 0\n0 1\n2 3\n1 2\n2 1\n```\n\nSample Output 1:\n```\n1\n```\nIt is impossible to reach \\((-1, -1)\\) from \\((1, 1)\\).\n\nSample Input 2:\n```\n0\n```\n\nSample Output 2:\n```\n0\n```\nThere may be cases where no stones are placed.\n\nSample Input 3:\n```\n22\n0 1\n0 2\n0 3\n1 0\n1 4\n2 0\n2 2\n2 4\n3 0\n3 1\n3 2\n3 4\n5 1\n5 2\n5 3\n6 0\n6 4\n7 0\n7 4\n8 1\n8 2\n8 3\n```\n\nSample Output 3:\n```\n6\n```\nThere are six such points: \\((6, 1), (6, 2), (6, 3), (7, 1), (7, 2), (7, 3)\\).\n\nSolution:\n\n```python\n'''\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nG - Go Territory Editorial by en_translator\n\nWe will consider a grid instead of a coordinate plane. We call those cells reachable to (-1,-1) \u201cinside,\u201d \nand unreachable \u201coutside.\u201d We first consider the case where the stones are connected in eight directions. \nBy enumerating eight cells around each cell beforehand, one can easily determine if these cells are inside or \noutside easily with BFS (Breadth First Search). The top-left cell is always outside; by performing BFS from this cell \nin four directions, one can reach all cells outside.\n\nExample: black cells represent lattice points with stones. Then, inspect each row. If there is a segment with \n\u201coutside stone inside \u2026 inside stone outside,\u201d then that segment can be counted as \u201cinside\u201d to count \u201cinside\u201d points. \nBeware of cases with consecutive stones, or stones between inside cells.\n\nNow we consider disconnected cases. It may seem we can consider each connected component independently, \nbut note that there may be a nested structure. After performing BFS for each connected component and determining whether \neach cell is outside or inside, when scanning the entire row, there may be parts like \n\u201coutside stone inside \u2026\u2026 outside stone inside \u2026\u2026 inside stone outside \u2026\u2026 inside stone outside,\u201d where some cells \ninside are labeled outside.\n\nEvery time you encounter \u201coutside, one or more stones, inside,\u201d the nest increases by one; for \n\u201cinside, one or more stones, outside,\u201d it decreases by one. By using this method to manage how many times the current \nposition is surrounded, one can handle this issue. Also, if there are different connected components sufficiently close \nto each other, the label (outside/inside) might be overwritten. This can be avoided by defining that stones are connected \nif the Chebyshev distance is two or less, instead of being eight-adjacent.\n'''\n```\n\n \n\n", "problem_ids": ["abc361_g"]}, "abc313_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\ldots, A_N) \\) of length \\( N \\).\n\nYou will perform the following operation exactly once:\n\n- Choose a non-empty subsequence of \\( A \\) (not necessarily contiguous) and replace it with its cumulative sums.\nMore precisely, first choose a sequence of indices \\( (i_1, i_2, \\ldots, i_k) \\) such that \\( 1 \\leq i_1 < i_2 < \\cdots < i_k \\leq N \\).\n  The length of the sequence \\( k \\) (\\( 1 \\leq k \\leq N \\)) can be chosen freely.\n  Then, for each \\( j \\) (\\( 1 \\leq j \\leq k \\)), replace the value of \\( A_{i_j} \\) with \\( \\sum_{1 \\leq x \\leq j} A_{i_x} \\).\n  This replacement is done simultaneously for all chosen indices.\n\nFind, modulo \\( 10^9 + 7 \\), the number of possible sequences \\( A \\) after the operation.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\(-10 \\leq A_i \\leq 10 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n\\[\nN \\\\\nA_1\\ A_2\\ \\cdots\\ A_N\n\\]\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n3\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nThe possible sequences \\( A \\) after the operation are as follows:\n- \\( A = (1, 1, 2) \\): This can be achieved with \\( k = 1 \\) and \\( (i_1) = (1) \\).\n- \\( A = (1, 2, 2) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 2) \\).\n- \\( A = (1, 1, 3) \\): This can be achieved with \\( k = 2 \\) and \\( (i_1, i_2) = (1, 3) \\).\n- \\( A = (1, 2, 4) \\): This can be achieved with \\( k = 3 \\) and \\( (i_1, i_2, i_3) = (1, 2, 3) \\).\n\n**Sample Input 2**\n\n```\n4\n1 -1 1 -1\n```\n\n**Sample Output 2**\n\n```\n8\n```\n\n**Sample Input 3**\n\n```\n5\n0 0 0 0 0\n```\n\n**Sample Output 3**\n\n```\n1\n```\n\n**Sample Input 4**\n\n```\n40\n2 -2 1 3 -3 -1 -2 -3 0 -1 -2 0 -3 0 0 2 0 -1 2 -2 -2 -1 3 -2 -2 -2 2 3 2 -3 0 -2 2 1 3 0 -1 0 -2 -3\n```\n\n**Sample Output 4**\n\n```\n420429545\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Regular Contest 180\n\nC - Subsequence and Prefix Sum Editorial by evima\n\nConsider the following DP: \\(dp[i][j]=\\) The number of ways to perform the operation on the first \\(i\\) terms so that \\(A_i\\) changes to \\(A_i+j\\) (\\(j \\neq 0\\)). Because \\(j \\neq 0\\), the operation counted in \\(dp[i][j]\\) always selects \\(A_i\\) for the operation. The next term will increase by \\(A_i+j\\). The transition for \\(A_i+j \\neq 0\\) is straightforward. For \\(A_i+j=0\\), let \\(A_k\\) be the next term to change. To change \\(A_k \\to A_k+v\\), select \\(v\\) from \\(A_{i+1},\\cdots,A_{k-1}\\). Implementing these covers all transitions. This problem can be solved in \\(O(N^3 \\max(|A_i|))\\) time.\n[END TEXT]\n \n\n", "problem_ids": ["arc180_c"]}, "abc313_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi and Aoki played rock-paper-scissors \\(N\\) times. [Note: In this game, Rock beats Scissors, Scissors beats Paper, and Paper beats Rock.]\n\nAoki's moves are represented by a string \\(S\\) of length \\(N\\) consisting of the characters \\(R\\), \\(P\\), and \\(S\\). The \\(i\\)-th character of \\(S\\) indicates Aoki's move in the \\(i\\)-th game: \\(R\\) for Rock, \\(P\\) for Paper, and \\(S\\) for Scissors.\n\nTakahashi's moves satisfy the following conditions:\n1. Takahashi never lost to Aoki.\n2. For \\(i = 1, 2, \\ldots, N-1\\), Takahashi's move in the \\(i\\)-th game is different from his move in the \\((i+1)\\)-th game.\n\nDetermine the maximum number of games Takahashi could have won.\n\nIt is guaranteed that there exists a sequence of moves for Takahashi that satisfies these conditions.\n\n**Constraints**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(S\\) is a string of length \\(N\\) consisting of \\(R\\), \\(P\\), and \\(S\\).\n- \\(N\\) is an integer.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN\nS\n```\n\n**Output**\nPrint the maximum number of games Takahashi could have won.\n\n**Sample Input 1**\n```\n6\nPRSSRS\n```\n\n**Sample Output 1**\n```\n5\n```\n\n*Explanation:* In the six games of rock-paper-scissors, Aoki played Paper, Rock, Scissors, Scissors, Rock, and Scissors. Takahashi can play Scissors, Paper, Rock, Scissors, Paper, and Rock to win the 1st, 2nd, 3rd, 5th, and 6th games. There is no sequence of moves for Takahashi that satisfies the conditions and wins all six games, so print 5.\n\n**Sample Input 2**\n```\n10\nSSSSSSSSSS\n```\n\n**Sample Output 2**\n```\n5\n```\n\n**Sample Input 3**\n```\n24\nSPRPSRRRRRPPRPRPSSRSPRSS\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Here is the trimmed content containing only the solution to the coding problem:\n\n---\n\nDefine \\(\\operatorname{dp} _ i[H]\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) by:\n\n\\(\\operatorname{dp} _ i[H]\\coloneqq\\) the maximum number of Takahashi\u2019s wins during conforming first \\(i\\) hands of Takahashi such that his \\(i\\)-th hand is \\(H\\).\n\nHere, we define \\(\\operatorname{dp} _ 0[H]=0\\) for convenience. (DP stands for Dynamic Programming.)\n\nTakahashi\u2019s \\(i\\)-th move is solely dependent on Aoki\u2019s \\(i\\)-th hand and Takahashi\u2019s \\(i\\)-th hand. Therefore, \\(\\operatorname{dp} _ i[H]\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) can be found based on \\(\\operatorname{dp} _ {i-1}\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) (and the value \\(S _ i\\)). Specifically, let \\(\\operatorname{rps}(a,b)\\) be \\(1\\) if \\(a\\) wins \\(b\\), \\(-1\\) if it loses, and \\(0\\) if they are draw (here rps stands for rock-scissors-paper), then\n\n\\[\\operatorname{dp} _ i[H]=\\begin{cases}\\displaystyle\\max _ {H^\\prime\\neq H}\\operatorname{dp} _ {i-1}[H^\\prime]&\\ &(\\operatorname{janken}(H,S _ i)=0)\\\\1+\\displaystyle\\max _ {H^\\prime\\neq H}\\operatorname{dp} _ {i-1}[H^\\prime]&&(\\operatorname{janken}(H,S _ i)=1)\\\\0&&(\\operatorname{janken}(H,S _ i)=-1).\\end{cases}\\]\n\nWhile we may set \\(-\\infty\\) to the value of the DP table when losing, one can prove that setting \\(0\\) still yields a correct value.\n\nThe following is sample code.\n\n```python\ndef main():\n    N = int(input().strip())\n    S = input().strip()\n\n    dp = [0, 0, 0]\n    rock, scissors, paper = dp\n\n    for c in S:\n        dp = [max(scissors, paper), max(rock, paper), max(rock, scissors)]\n\n        if c == 'R':\n            scissors = 0\n            paper += 1\n        elif c == 'S':\n            paper = 0\n            rock += 1\n        elif c == 'P':\n            rock = 0\n            scissors += 1\n\n    print(max(dp))\n\nmain()\n```\n \n\n", "problem_ids": ["abc365_d"]}, "abc314_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou have \\( N \\) keys numbered \\( 1, 2, \\dots, N \\). Some of these are real keys, while the others are dummies. There is a door, Door X, into which you can insert any number of keys. Door X will open if and only if at least \\( K \\) real keys are inserted.\n\nYou have conducted \\( M \\) tests on these keys. The \\( i \\)-th test went as follows:\n- You inserted \\( C_i \\) keys \\( A_{i,1}, A_{i,2}, \\dots, A_{i,C_i} \\) into Door X.\n- The test result is represented by a single English letter \\( R_i \\).\n  - \\( R_i = \\text{o} \\) means that Door X opened in the \\( i \\)-th test.\n  - \\( R_i = \\text{x} \\) means that Door X did not open in the \\( i \\)-th test.\n\nThere are \\( 2^N \\) possible combinations of which keys are real and which are dummies. Among these, find the number of combinations that do not contradict any of the test results. It is possible that the given test results are incorrect and no combination satisfies the conditions. In such a case, report \\( 0 \\).\n\n**Constraints**\n- \\( N, M, K, C_i, \\text{ and } A_{i,j} \\) are integers.\n- \\( 1 \\le K \\le N \\le 15 \\)\n- \\( 1 \\le M \\le 100 \\)\n- \\( 1 \\le C_i \\le N \\)\n- \\( 1 \\le A_{i,j} \\le N \\)\n- \\( A_{i,j} \\neq A_{i,k} \\) if \\( j \\neq k \\).\n- \\( R_i \\) is \\( \\text{o} \\) or \\( \\text{x} \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M K\nC_1 A_{1,1} A_{1,2} \\dots A_{1,C_1} R_1\nC_2 A_{2,1} A_{2,2} \\dots A_{2,C_2} R_2\n\\vdots\nC_M A_{M,1} A_{M,2} \\dots A_{M,C_M} R_M\n```\n\n**Output**\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2 2\n3 1 2 3 o\n2 2 3 x\n```\n\n**Sample Output 1**\n```\n2\n```\n\nIn this input, there are three keys and two tests were conducted. Two correct keys are required to open Door X. In the first test, keys 1, 2, 3 were used, and Door X opened. In the second test, keys 2, 3 were used, and Door X did not open. There are two combinations of which keys are real and which are dummies that do not contradict any of the test results: Key 1 is real, key 2 is a dummy, and key 3 is real. Key 1 is real, key 2 is real, and key 3 is a dummy.\n\n**Sample Input 2**\n```\n4 5 3\n3 1 2 3 o\n3 2 3 4 o\n3 3 4 1 o\n3 4 1 2 o\n4 1 2 3 4 x\n```\n\n**Sample Output 2**\n```\n0\n```\n\nAs mentioned in the problem statement, the answer may be 0.\n\n**Sample Input 3**\n```\n11 4 9\n10 1 2 3 4 5 6 7 8 9 10 o\n11 1 2 3 4 5 6 7 8 9 10 11 o\n10 11 10 9 8 7 6 5 4 3 2 x\n10 11 9 1 4 3 7 5 6 2 10 x\n```\n\n**Sample Output 3**\n```\n8\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 356\n\n# C - Keys Editorial by en_translator:\n\n# By the constraints, the number of keys \\(N \\le 15\\), and the tests \\(M \\le 100\\). \n# There are \\(2^N\\) combinations of authenticities of the keys. We may perform the \\(M\\) tests \n# on all \\(2^N\\) combinations and count the number of proper combinations. \n# \\(2^N \\times M \\le 3.3 \\times 10^6\\) tests are required. \n# Even with \\(N\\) operations per test, the total number of operations is \\(5 \\times 10^7\\), which is fast enough. \n# We achieve this through bitwise enumeration by iterating over \\(i=0,1,\\dots,2^N-1\\). \n# The presence of bit \\(2^k\\) in \\(i\\) determines if the \\((k+1)\\)-th key is real or a dummy. \n# For more details, refer to relevant articles on bitwise enumeration.\n\n# Note that operations exceeding \\(N\\) per test might not meet the execution time limit. \n# Managing whether the \\(k\\)-th key was used limits operations per test to \\(N\\).\n\n# Sample code translated to Python:\nn, m, k = map(int, input().split())\nkey = [[0]*n for _ in range(m)]\nr = []\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c + 1):\n        a = data[j]\n        key[i][a-1] = 1\n    r.append(input().strip())\n\nres = 0\n\nfor i in range(1 << n):\n    tf = [0] * n\n    for j in range(n):\n        if i & (1 << j):\n            tf[j] = 1\n        else:\n            tf[j] = 0\n    jud = True\n    for j in range(m):\n        ck = 0\n        for p in range(n):\n            if key[j][p] == 1 and tf[p] == 1:\n                ck += 1\n        if ck >= k and r[j] == \"x\":\n            jud = False\n        if ck < k and r[j] == \"o\":\n            jud = False\n    if jud:\n        res += 1\n\nprint(res)\n\n# A faster approach using bitwise operations translated to Python:\nn, m, k = map(int, input().split())\nks = [0] * m\nr = [0] * m\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c+1):\n        a = data[j] - 1\n        ks[i] |= (1 << a)\n    s = input().strip()\n    if s == \"o\":\n        r[i] = 1\n    else:\n        r[i] = 0\n\nres = 0\n\nfor i in range(1 << n):\n    jud = True\n    for j in range(m):\n        ok = bin(i & ks[j]).count('1')\n        if ok >= k and r[j] == 0:\n            jud = False\n            break\n        if ok < k and r[j] == 1:\n            jud = False\n            break\n    if jud:\n        res += 1\n\nprint(res)\n```\n \n\n", "problem_ids": ["abc356_c"]}, "abc314_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of length \\(N\\). On this sequence, the following operation can be performed:\n\nChoose \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Replace each of \\(A_{l+1}, A_{l+2}, \\dots, A_{r-1}\\) with \\(A_l\\). The cost of this operation is \\(r-l-1\\).\n\nYou will repeat this operation until there is no \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Find the minimum total cost of such a series of operations.\n\n**Constraints:**\n- \\(3 \\leq N \\leq 5 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq N\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n7\n1 2 3 2 3 2 1\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n_For example, if you perform the operation with \\((l, r) = (3, 5), (2, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,3,3,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\), after which there is no \\(l\\) and \\(r\\) with the said property. The total cost of this series of operations is \\(1+3+5=9\\)._\n\n_On the other hand, if you perform the operation with \\((l, r) = (2, 4), (4, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,2,2,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\). The total cost of this series of operations is \\(1+1+5=7\\)._\n\n**Sample Input 2:**\n```\n5\n1 2 3 4 5\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n40\n1 2 3 4 5 6 7 8 7 6 5 6 7 8 7 6 5 4 3 2 2 1 2 3 4 5 4 5 6 7 8 7 7 6 5 6 6 7 8 8\n```\n\n**Sample Output 3:**\n```\n44\n```\n\nSolution:\n\n```\nHere's a cleaned-up version of the solution:\n\nStarting from a vertex with color \\(A_i\\) and a piece placed on it, create a tree with colored vertices by performing the following steps for \\(i=2,3,\\dots,N\\): Let \\(pos\\) be the current position. If the color of the vertex at \\(pos\\) is \\(A_i\\), do nothing. If there is an adjacent vertex to \\(pos\\) with color \\(A_i\\), move the piece there. If no such vertex exists, create a new adjacent vertex with color \\(A_i\\) and move the piece there. The colors of adjacent vertices are always distinct. \n\nThe state of the sequence corresponds to a walk on this tree, where operations change a walk \\(u\\rightarrow v\\rightarrow v\\rightarrow \\dots \\rightarrow v\\rightarrow u\\) to \\(u\\rightarrow u\\rightarrow u\\rightarrow \\dots \\rightarrow u\\rightarrow u\\). Let \\(start\\) and \\(goal\\) be the start and end points of the walk. The problem is finding the minimum cost to change the walk into a simple path connecting \\(start\\) and \\(goal\\). \n\nCalculate the minimum cost. Consider parts of the walk off the path connecting \\(start\\) and \\(goal\\), like \\(\\dots \\rightarrow a \\rightarrow b \\rightarrow \\dots \\rightarrow b \\rightarrow a \\rightarrow \\dots\\). Convert \\(b \\rightarrow \\dots \\rightarrow b\\) to stay at \\(a\\), with the cost equivalent to the sum of distances to \\(a\\). The problem becomes: \n\nGiven \\(V=(v_1,v_2,\\dots,v_n)\\) with:\n\n\\(v_1=1, v_n=\\max_{1\\leq i \\leq n} v_i\\)\n\\(|v_i-v_{i+1}| \\in \\{0,1\\}\\),\n\nFind the minimum \\(\\sum |v_i-v'_i|\\) for \\(V'=(v'_1,v'_2,\\dots,v'_n)\\) where:\n\n\\(v'_1=v_1, v'_n=v_n\\)\n\\(v'_i \\leq v'_{i+1}\\)\nIf \\(v'_i \\neq v'_{i+1}\\), then \\(v_i=v'_i\\) and \\(v_{i+1}=v'_{i+1}\\).\n\nSolve this using dynamic programming in \\(O(N)\\): \n\nUse \\(dp[k]=\\) the minimum value of \\(\\sum_{k \\leq i} |v_i-v'_i|\\) when \\(v'_k=v_k\\). If \\(v_{k+1}=v_k+1\\), update \\(dp[k] \\leftarrow \\min(dp[k],dp[k+1])\\). Let \\(k'\\) be the smallest \\(i\\ (k < i)\\) such that \\(v_{i}=v_k\\), then update \\(dp[k] \\leftarrow \\min(dp[k],dp[k']+\\sum_{i=k+1}^{k'}|v_k-v_i|)\\).\n```\n \n\n", "problem_ids": ["arc181_f"]}, "abc314_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers \\( A \\) and \\( B \\) of length \\( N \\). Process \\( Q \\) queries given in the following forms in the order they are given. Each query is of one of the following three types:\n\n1. **Type 1**: Given in the form `1 i x`. Replace \\( A_i \\) with \\( x \\).\n2. **Type 2**: Given in the form `2 i x`. Replace \\( B_i \\) with \\( x \\).\n3. **Type 3**: Given in the form `3 l r`. Solve the following problem and print the answer:\n   - Initially, set \\( v = 0 \\). For \\( i = l, l+1, \\ldots, r \\) in this order, replace \\( v \\) with either \\( v + A_i \\) or \\( v \\times B_i \\). Find the maximum possible value of \\( v \\) at the end.\n\n**It is guaranteed that the answers to the given type 3 queries are at most \\( 10^{18} \\).**\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 10^5 \\)\n- For type 1 and 2 queries, \\( 1 \\leq i \\leq N \\).\n- For type 1 and 2 queries, \\( 1 \\leq x \\leq 10^9 \\).\n- For type 3 queries, \\( 1 \\leq l \\leq r \\leq N \\).\n- For type 3 queries, the value to be printed is at most \\( 10^{18} \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nQ\nquery_1\nquery_2\n\\vdots\nquery_Q\n```\n\nHere, `query_i` is the \\( i \\)-th query, given in one of the following formats:\n- `1 i x`\n- `2 i x`\n- `3 l r`\n\n**Output**\n\nLet \\( q \\) be the number of type 3 queries. Print \\( q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th type 3 query.\n\n**Sample Input 1**\n```\n3\n3 2 4\n1 2 2\n3\n3 1 3\n1 1 1\n3 1 3\n```\n\n**Sample Output 1**\n```\n12\n7\n```\n\nFor the first query, the answer is \\(((0 + A_1) \\times B_2) \\times B_3 = 12\\).\n\nFor the third query, the answer is \\(((0 + A_1) + A_2) + A_3 = 7\\).\n\n**Sample Input 2**\n```\n6\n65 32 12 5 8 312\n4 1 3 15 16 2\n6\n3 2 6\n3 1 5\n1 5 6\n2 4 9\n3 2 6\n3 3 5\n```\n\n**Sample Output 2**\n```\n46080\n69840\n27648\n1728\n```\n\nSolution:\n\n```\nConsider a type-3 query. Let \\(M\\) be the maximum \\(A\\). First, for \\(i = l\\), set \\(v = 0\\) and replace \\(v\\) with \\(v + A[i]\\). By the constraints, \\(v\\) becomes positive. Replace \\(v\\) with \\(v \\times B[i]\\) at most \\(\\log_2 M (< 60)\\) times, since \\(2^{60} > 10^{18}\\) and the input restricts this operation to under 60 times. Thus, the loop iterates a maximum of 59 times:\n\n```python\nv = A[l]\nwhile True:\n    next_l = min(r, smallest_i_after_l_plus_1_such_that_Bi_geq_2)\n    v += sum_a(l + 1, next_l)\n    v = max(v + A[next_l], v * B[next_l])\n    l = next_l\n    if l == r:\n        break\noutput(v)\n```\n\nBy using a segment tree appropriately, the complexity becomes \\(O(N + Q \\log N \\log M)\\). The algorithm is efficient due to the small constant factor.\n```\n \n\n", "problem_ids": ["abc368_g"]}, "abc314_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere are three brothers named A, B, and C. The age relationships among them are specified by three characters: \\( S_{\\mathrm{AB}} \\), \\( S_{\\mathrm{AC}} \\), and \\( S_{\\mathrm{BC}} \\). The meanings of these characters are as follows:\n\n- If \\( S_{\\mathrm{AB}} \\) is '<', then A is younger than B; if it is '>', then A is older than B.\n- If \\( S_{\\mathrm{AC}} \\) is '<', then A is younger than C; if it is '>', then A is older than C.\n- If \\( S_{\\mathrm{BC}} \\) is '<', then B is younger than C; if it is '>', then B is older than C.\n\nYou need to determine who the middle brother is, meaning the one who is the second oldest among the three.\n\n**Constraints:**\n\n- Each of \\( S_{\\mathrm{AB}}, S_{\\mathrm{AC}}, S_{\\mathrm{BC}} \\) is either '<' or '>'.\n- The input contains no contradictions, which means there will always be a valid age relationship that satisfies all provided inequalities.\n\n**Input**\n\nThe input is provided from standard input in the following format:\n\n```\nS_{\\mathrm{AB}} S_{\\mathrm{AC}} S_{\\mathrm{BC}}\n```\n\n**Output**\n\nPrint the name of the middle brother, who is the second oldest among the three.\n\n**Sample Input 1**\n```\n< < <\n```\n\n**Sample Output 1**\n```\nB\n```\n\nExplanation: Since A is younger than B, and B is younger than C, we conclude that C is the oldest, B is the middle, and A is the youngest. Hence, the answer is B.\n\n**Sample Input 2**\n```\n< < >\n```\n\n**Sample Output 2**\n```\nC\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial:\n\n---\n\nFor beginners:\n\nIf you are new to programming and do not know where to start, please try Problem A \"Welcome to AtCoder\" from the practice contest. There you can find sample code for each language. If you are not familiar with problems in programming contests, we recommend you try some problems in \"AtCoder Beginners Selection\". There are C++ and Python tutorials for competitive programmers in Japanese.\n\nProblem A Solution:\n\nThis problem has various solutions. One solution is to implement a conditional branch for all the eight possible inputs (among which six are consistent and can actually be the input). This can be done with an if statement, but it\u2019s a bit cumbersome. Here is a bit cleverer solution:\n\nIf \\(S_\\mathrm{AB}\\neq S_\\mathrm{AC}\\): A is the middle son.  \nOtherwise, if \\(S_\\mathrm{AB}= S_\\mathrm{BC}\\): B is the middle son.  \nOtherwise: C is the middle son.\n\nThe following sample code implements the simple casework in Python:\n\n```python\na, b, c = input().strip()\n\nif a != b:\n    print(\"A\")\nelif a == c:\n    print(\"B\")\nelse:\n    print(\"C\")\n```\n\n \n\n", "problem_ids": ["abc371_a"]}, "abc314_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a tree with \\(N\\) vertices numbered from 1 to \\(N\\). The \\(i\\)-th edge connects vertices \\(A_i\\) and \\(B_i\\). Here, \\(N\\) is even, and furthermore, this tree has a perfect matching. Specifically, for each \\(i\\) (\\(1 \\leq i \\leq N/2\\)), it is guaranteed that \\(A_i = i \\times 2 - 1\\) and \\(B_i = i \\times 2\\).\n\nYou will perform the following operation \\(N/2\\) times:\n- Choose two leaves (vertices with degree exactly 1) and remove them from the tree. Here, the tree after removal must still have a perfect matching. In this problem, we consider a graph with zero vertices to be a tree as well.\n\nFor each operation, its score is defined as the distance between the two chosen vertices (the number of edges on the simple path connecting the two vertices).\n\nShow one procedure that maximizes the total score. It can be proved that there always exists a procedure to complete \\(N/2\\) operations under the constraints of this problem.\n\n**Constraints**\n- \\(2 \\leq N \\leq 250000\\)\n- \\(N\\) is even.\n- \\(1 \\leq A_i < B_i \\leq N\\) (\\(1 \\leq i \\leq N-1\\))\n- \\(A_i = i \\times 2 - 1\\), \\(B_i = i \\times 2\\) (\\(1 \\leq i \\leq N/2\\))\n- The given graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_{N-1} B_{N-1}\n```\n\n**Output**\n\nPrint a solution in the following format:\n```\nX_1 Y_1\nX_2 Y_2\n...\nX_{N/2} Y_{N/2}\n```\n\nHere, \\(X_i\\) and \\(Y_i\\) are the two vertices chosen in the \\(i\\)-th operation. If there are multiple solutions, you may print any of them.\n\n**Sample Input 1**\n```\n4\n1 2\n3 4\n2 3\n```\n\n**Sample Output 1**\n```\n4 1\n2 3\n```\n\nThe procedure in the sample output is as follows:\n- 1st operation: Remove vertices 4 and 1. The remaining tree has vertices 2 and 3, and a perfect matching. The score of this operation is 3.\n- 2nd operation: Remove vertices 2 and 3. The remaining tree has zero vertices and a perfect matching. The score of this operation is 1.\n- The total score is \\(3 + 1 = 4\\).\n\nIt is impossible to make the total score greater than 4, so this output solves this sample input.\n\n**Sample Input 2**\n```\n8\n1 2\n3 4\n5 6\n7 8\n2 3\n1 5\n1 7\n```\n\n**Sample Output 2**\n```\n4 8\n7 6\n5 3\n2 1\n```\n\n**Sample Input 3**\n```\n14\n1 2\n3 4\n5 6\n7 8\n9 10\n11 12\n13 14\n2 8\n4 11\n5 12\n7 13\n11 14\n9 13\n```\n\n**Sample Output 3**\n```\n1 6\n5 2\n8 12\n3 7\n10 4\n11 9\n13 14\n```\n\n**Sample Input 4**\n```\n20\n1 2\n3 4\n5 6\n7 8\n9 10\n11 12\n13 14\n15 16\n17 18\n19 20\n8 10\n16 18\n16 19\n5 9\n10 17\n2 13\n7 14\n3 7\n3 12\n```\n\n**Sample Output 4**\n```\n6 1\n2 15\n20 13\n14 19\n16 4\n11 18\n17 12\n3 5\n9 7\n8 10\n```\n\nSolution:\n\n```python\n# Problem: Keep Perfectly Matched (Translated to Python3)\n\n# Editorial Explanation:\n# For each edge, consider how many times it contributes to the score. An upper bound is the size\n# of the smaller of the two subtrees created when the edge is cut. This upper bound can be achieved\n# by treating the input tree as a rooted tree with the centroid R as the root. Let v1, v2, ..., vk \n# be the direct children of the root, and T1, T2, ..., Tk be their respective subtrees. Leaves \n# should be chosen from two different subtrees and removed, except for the last operation. Assume \n# the root is initially matched with v1. In the first operation, leaves of T1 and Tj (j != 1) must \n# be chosen. After this operation, the root is matched with vj. Choose Tj next, and so on. By \n# choosing the Tj with the largest size each time, all operations finish successfully. Though this \n# guarantees valid subtree vertex counts, it doesn't ensure proper leaf selection. Leaves can be \n# removed within each subtree by considering vertices top-down from the root. Assume focus is on \n# vertex v. If matched with a child, choose a leaf from that child\u2019s subtree. Otherwise, choose \n# another child and select a leaf from its subtree. This process leads to a leaf that can be \n# removed. The leaf removal procedure has a worst-case total time complexity of O(N^2), but by \n# modifying the procedure slightly, an efficient order to remove each vertex as a leaf can be \n# found. Perform a DFS prioritizing edges used in the matching and use vertices along the postorder \n# traversal. The problem can be solved in O(N log N) time.\n\n# Please note: The editorial does not contain specific code snippets, so this explanation outlines \n# the algorithmic approach described in the original editorial in Pythonic terms.\n```\n\nMarubeni Programming Contest 2024 (AtCoder Regular Contest 183)\n\nD - Keep Perfectly Matched Editorial by evima\n\nFor each edge, consider how many times it contributes to the score. An upper bound is the size of the smaller of the two subtrees created when the edge is cut. This upper bound can be achieved by treating the input tree as a rooted tree with the centroid \\(R\\) as the root. Let \\(v_1, v_2, \\cdots, v_k\\) be the direct children of the root, and \\(T_1, T_2, \\cdots, T_k\\) be their respective subtrees. Leaves should be chosen from two different subtrees and removed, except for the last operation. Assume the root is initially matched with \\(v_1\\). In the first operation, leaves of \\(T_1\\) and \\(T_j\\) (\\(j \\neq 1\\)) must be chosen. After this operation, the root is matched with \\(v_j\\). Choose \\(T_j\\) next, and so on. By choosing the \\(T_j\\) with the largest size each time, all operations finish successfully. Though this guarantees valid subtree vertex counts, it doesn't ensure proper leaf selection. Leaves can be removed within each subtree by considering vertices top-down from the root. Assume focus is on vertex \\(v\\). If matched with a child, choose a leaf from that child\u2019s subtree. Otherwise, choose another child and select a leaf from its subtree. This process leads to a leaf that can be removed. The leaf removal procedure has a worst-case total time complexity of \\(O(N^2)\\), but by modifying the procedure slightly, an efficient order to remove each vertex as a leaf can be found. Perform a DFS prioritizing edges used in the matching and use vertices along the postorder traversal. The problem can be solved in \\(O(N\\log N)\\) time.\n \n\n", "problem_ids": ["arc183_d"]}, "abc314_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nFor positive integers \\( x \\) and \\( y \\), define \\( f(x, y) \\) as the remainder of \\( (x + y) \\) divided by \\( 10^8 \\).\n\nYou are given a sequence of positive integers \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i, A_j) \\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 3 \\times 10^5 \\)\n- \\( 1 \\leq A_i < 10^8 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n3\n3 50000001 50000002\n```\n\n**Sample Output 1**\n\n```\n100000012\n```\n\n\\( f(A_1, A_2) = 50000004 \\), \\( f(A_1, A_3) = 50000005 \\), and \\( f(A_2, A_3) = 3 \\). Thus, the answer is \\( f(A_1, A_2) + f(A_1, A_3) + f(A_2, A_3) = 100000012 \\).\n\nNote that you are not asked to compute the remainder of the sum divided by \\( 10^8 \\).\n\n**Sample Input 2**\n\n```\n5\n1 3 99999999 99999994 1000000\n```\n\n**Sample Output 2**\n\n```\n303999988\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere is the clean version of the provided coding problem editorial:\n\n---\n\nWe reinterpret \\(f(x,y)\\) in a more useful form. In the constraints of this problem, \\(f(x,y)\\) is \\(x+y\\) if \\(x+y < 10^8\\) and \\(x+y-10^8\\) if \\(x+y\\geq 10^8\\). Thus, the answer can be found by evaluating \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N A_i + A_j\\), and then subtracting from it \\(10^8 \\times\\) the number of pairs \\((i,j)\\ (1\\leq i <j\\leq N)\\) such that \\(A_i + A_j\\) is greater than or equal to \\(10^8\\).\n\nRegarding \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N A_i + A_j\\), each term is added \\((N-1)\\) times, so it can be rewritten as \\((N-1)\\sum_{i=1}^{N} A_i\\), which can be found in \\(\\mathrm{O}(N)\\) time. Next, let us count the integer pairs \\((i,j)\\ (1\\leq i <j\\leq N)\\) such that \\(A_i + A_j\\) is greater than or equal to \\(10^8\\). The answer does not change by sorting \\(A\\) in ascending order, so we do so. Then, the minimum \\(j\\) with \\(A_i + A_j\\geq 10^8\\) monotonically decreases as \\(i\\) increases. Thus, the number of conforming integer pairs can be counted with the sliding window trick. Be careful not to count too much when \\(A_i = 5\\times 10^7\\).\n[END TEXT]\n \n\n", "problem_ids": ["abc353_c"]}, "abc315_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nTakahashi has \\( N \\) cards from the card game \"AtCoder Magics.\" Each card \\( i \\) has two parameters: strength \\( A_i \\) and cost \\( C_i \\).\n\nTakahashi does not like weak cards, so he will discard them. He will repeatedly perform the following operation until it can no longer be done:\n\n- Choose two cards \\( x \\) and \\( y \\) such that \\( A_x > A_y \\) and \\( C_x < C_y \\). Discard card \\( y \\).\n\nIt is assured that when these operations can no longer be performed, the set of remaining cards is uniquely determined. Find this set of cards.\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, C_i \\leq 10^9 \\)\n- All the \\( A_1, A_2, \\dots, A_N \\) are distinct.\n- All the \\( C_1, C_2, \\dots, C_N \\) are distinct.\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 C_1\nA_2 C_2\n...\nA_N C_N\n```\n\n**Output:**\n\nSuppose there are \\( m \\) remaining cards, denoted by their indices \\( i_1, i_2, \\dots, i_m \\), in ascending order. Print these indices in the following format:\n\n```\nm\ni_1 i_2 ... i_m\n```\n\n**Sample Input 1:**\n```\n3\n2 4\n1 1\n3 2\n```\n\n**Sample Output 1:**\n```\n2\n2 3\n```\n\n(Focusing on cards 1 and 3, we have \\( A_1 < A_3 \\) and \\( C_1 > C_3 \\), so card 1 can be discarded. No further operations can be performed. At this point, cards 2 and 3 remain, so print them.)\n\n**Sample Input 2:**\n```\n5\n1 1\n10 2\n100 3\n1000 4\n10000 5\n```\n\n**Sample Output 2:**\n```\n5\n1 2 3 4 5\n```\n\n(In this case, no cards can be discarded.)\n\n**Sample Input 3:**\n```\n6\n32 101\n65 78\n2 29\n46 55\n103 130\n52 40\n```\n\n**Sample Output 3:**\n```\n4\n2 3 5 6\n```\n\nSolution:\n\nBelow is the editorial with the C++ code translated to Python3:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nC - AtCoder Magics Editorial by en_translator \n\nYou can intuitively understand the problem by plotting the data on a two-dimensional plane. The following is a visualization of Sample Input/Output 1. For cards \\(x\\) and \\(y\\), we have \\(A_x > A_y\\) and \\(C_x < C_y\\) if and only if the point corresponding to card \\(x\\) is in the lower-right region of that for card \\(y\\). In Sample Input/Output 1, card \\(3\\) is in the lower-right region of card \\(1\\).\n\nConsider the condition of a card that is never discarded. By the discussion above, a card is never removed if there is no point on the lower-right region of the point for itself. Otherwise, the card is always removed. The set of cards that has no point on its lower-right region can be found as follows. Scan the cards in ascending order of their costs, i.e., from lower points to higher, and include those that update the maximum strength so far (the rightmost one) to the answer. (Not being able to update the maximum strength means there is a card with smaller cost and larger strength, i.e., there is a card on its lower-right region.)\n\nSort cards in ascending order of \\(C_i\\). First, let \\(v = 0\\), and let \\(S\\) be an empty set. For \\(i = 1, 2, \\cdots, N\\) in order, if \\(A_i > v\\), then insert the \\(i\\)-th card, and set \\(v\\) to \\(A_i\\). The resulting \\(S\\) is the answer.\n\nFor sample code 1, it runs as follows. The cards are sorted by \\(C_i\\) as cards \\(2, 3, 1\\).\n\n\\(A_2 (= 1) > v (= 0)\\), so insert card \\(2\\) to \\(S\\), and let \\(v = 1\\). \\(A_3 (= 3) > v (= 1)\\), so insert card \\(3\\) to \\(S\\), and let \\(v = 3\\). \\(A_1 (= 2) < v (= 3)\\), so card \\(1\\) is not inserted to \\(S\\).\n\nFinally, \\(S = \\{ 2, 3 \\}\\).\n\nFor example, it can be implemented in Python as follows. The complexity is \\(O(N \\log N)\\), where sorting is the bottleneck.\n\n```python\ndef atcoder_magics():\n    # Input\n    n = int(input())\n    cards = []\n    for i in range(n):\n        a, c = map(int, input().split())\n        cards.append((a, c, i))\n    \n    # Sort in ascending order of C[i]\n    cards.sort(key=lambda x: x[1])\n    \n    # Compute the answer\n    ans = []\n    v = 0\n    for a, c, index in cards:\n        if a > v:\n            v = a\n            ans.append(index)\n    \n    ans.sort()\n    \n    # Print\n    m = len(ans)\n    print(m)\n    print(' '.join(str(x + 1) for x in ans))\n\n# To invoke the function, simply call:\n# atcoder_magics()\n```\n```\n \n\n", "problem_ids": ["abc354_c"]}, "abc315_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nA non-negative integer \\(X\\) is called a palindrome number if its decimal representation (without leading zeros) is a palindrome. For example, \\(363\\), \\(12344321\\), and \\(0\\) are all palindrome numbers. \n\nFind the \\(N\\)-th smallest palindrome number.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 10^{18}\\)\n- \\(N\\) is an integer.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\n```\n\n**Output**\n\nPrint the \\(N\\)-th smallest palindrome number.\n\n**Sample Input 1**\n\n```\n46\n```\n\n**Sample Output 1**\n\n```\n363\n```\n\nThe 46th smallest palindrome number is 363.\n\n**Sample Input 2**\n\n```\n1\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\n**Sample Input 3**\n\n```\n1000000000000000000\n```\n\n**Sample Output 3**\n\n```\n90000000000000000000000000000000009\n```\n\nSolution:\n\n```python\ndef TEN(x):\n    return 1 if x == 0 else 10 ** x\n\ndef find_palindrome(N):\n    if N == 1:\n        print(0)\n        return\n    \n    N -= 1\n    d = 1\n    while True:\n        x = (d + 1) // 2\n        if N < 9 * TEN(x - 1):\n            S = str(TEN(x - 1) + N)\n            S = S.ljust(d, ' ')\n            for i in range(x, d):\n                S = S[:i] + S[d - 1 - i] + S[i + 1:]\n            print(S)\n            return\n        else:\n            N -= 9 * TEN(x - 1)\n        d += 1\n\n# Example usage:\n# N = int(input())\n# find_palindrome(N)\n```\n \n\n", "problem_ids": ["abc363_d"]}, "abc315_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) rest areas around a lake. The rest areas are numbered \\( 1, 2, \\ldots, N \\) in clockwise order. It takes \\( A_i \\) steps to walk clockwise from rest area \\( i \\) to rest area \\( i+1 \\) (where rest area \\( N+1 \\) refers to rest area \\( 1 \\)).\n\nThe minimum number of steps required to walk clockwise from rest area \\( s \\) to rest area \\( t \\) (\\( s \\neq t \\)) must be a multiple of \\( M \\).\n\nDetermine the number of possible pairs \\((s, t)\\).\n\n**Constraints**\n\n- All input values are integers\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 10^6 \\)\n\n**Input Format**\n\nThe input is given from the standard input in the following format:\n\n```\nN M\nA_1 A_2 \\ldots A_N\n```\n\n**Output Format**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n4 3\n2 1 4 3\n```\n\n**Sample Output 1**\n```\n4\n```\n\n**Explanation**\n\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 2 is 2, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 3 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 4 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 3 is 1, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 4 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 1 is 8, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 4 is 4, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 1 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 2 is 9, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 1 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 2 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 3 is 6, which is a multiple of 3.\n\nThus, there are four possible pairs \\( (s, t) \\).\n\n**Sample Input 2**\n```\n2 1000000\n1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n9 5\n9 9 8 2 4 4 3 5 3\n```\n\n**Sample Output 3**\n```\n11\n```\n\nSolution:\n\n```python\n# Here is the cleaned version of the editorial:\n\n# For convenience, reassign the index \\((k-1)\\) to rest area \\(k\\) to treat indices from \\(0\\) through \\((N-1)\\). Consider the following array. Let \\(R_i\\) be the number of steps, modulo \\(M\\), required to travel from rest area \\(0\\) to rest area \\(i \\% N\\) as the \\(i\\)-th rest area to encounter. Precalculate these values for \\(i\\) from \\(0\\) through \\(2N-1\\). For example, if \\(A=(1,2,3,4)\\) and \\(M=6\\)...ultiple of \\(M\\)?\n\n# If \\(s<t\\), it holds when \\(R_s = R_t\\). This is equivalent to \\(R_{N+s}=R_{N+t}\\). If \\(s>t\\), it holds when \\(R_s = R_{N+t}\\).\n\n# Therefore, it is sufficient to solve the following problem:\n\n# Find the sum of the following value for \\(i=N,N+1,\\dots,2N-1\\). How many elements among \\(R_{i-N+1},R_{i-N+2},\\dots,R_{i-1}\\) are equal to \\(R_i\\)?\n\n# Intuitively, we are summing up the number of rest areas \\(i \\% N\\) to which the minimum steps required is a multiple of \\(M\\), over \\(i=N,N+1,\\dots,2N-1\\). This problem can be solved as follows:\n\n# First, let \\(B=(B[0],B[1],\\dots,B[M-1])\\) be the array of occurrences of \\(k\\) between \\(0\\) and \\(M-1\\) in \\(R_0\\) through \\(R_{N-1}\\). For \\(i = N,N+1,\\dots,2N-1\\), repeat the following:\n\n# Decrease \\(B[R_{i-N}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i-1\\).\n\n# Add \\(B[R_{i}]\\) Increase \\(B[R_{i}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i\\).\n\n# Translated sample code (Python 3):\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    r = [0]\n    for i in range(2 * n):\n        r.append((r[-1] + a[i % n]) % m)\n    b = [0] * m\n    for i in range(n):\n        b[r[i]] += 1\n    res = 0\n    for i in range(n, 2 * n):\n        b[r[i - n]] -= 1\n        res += b[r[i]]\n        b[r[i]] += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc367_d"]}, "abc315_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\(N - 1\\) white balls and one black ball. These \\(N\\) balls are arranged in a row, with the black ball initially at the leftmost position.\n\nTakahashi will perform the following operation exactly \\(K\\) times:\n\n- Choose two distinct integers \\(a\\) and \\(b\\) uniformly at random from the range [1, \\(N\\)]. If \\(a \\neq b\\), swap the \\(a\\)-th and \\(b\\)-th balls from the left.\n\nAfter \\(K\\) operations, let the black ball be at the \\(x\\)-th position from the left. Find the expected value of \\(x\\), modulo \\(998244353\\).\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 998244352\\)\n- \\(1 \\leq K \\leq 10^5\\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n    N K\n\n**Output**\n\nPrint the answer in one line.\n\n**Notes on Computation**\n\nThe expected value modulo \\(998244353\\) is defined as follows:\n\nThe expected value can always be expressed as a rational number \\(\\frac{P}{Q}\\). Under these constraints, it is guaranteed that \\(Q\\) is not divisible by \\(998244353\\), ensuring the existence of a unique integer \\(R\\) such that:\n\\[ \nR \\times Q \\equiv P \\pmod{998244353} \n\\]\nwhere \\(0 \\leq R < 998244353\\). You need to report this \\(R\\).\n\n**Sample Input 1**\n\n    2 1\n\n**Sample Output 1**\n\n    499122178\n\nExplanation: After one operation, the probabilities that the black ball is at the 1st position and the 2nd position from the left are both \\(\\frac{1}{2}\\). Thus, the expected value is \\(\\frac{3}{2}\\).\n\n**Sample Input 2**\n\n    3 2\n\n**Sample Output 2**\n\n    554580198\n\n**Sample Input 3**\n\n    4 4\n\n**Sample Output 3**\n\n    592707587\n\nSolution:\n\n[BEGIN TEXT]\nHere is the cleaned version of the editorial text:\n\n---\n\n**E - Random Swaps of Balls Editorial**\n\nBy the symmetry of the operation, if the probability that a black ball is at the leftmost position is \\(p\\), then that of being each of the other positions is \\(\\displaystyle \\frac{1 - p}{N - 1}\\). Thus, one can solve the problem by finding the probability that \\(K\\) operations make the leftmost ball black. This can be computed with Dynamic Programming (DP). Define\n\n\\(\\mathrm{dp}[i] :=\\) Probability that \\(i\\) operations make the leftmost ball black.\n\nWhat we want is \\(\\mathrm{dp}[K]\\). The transition requires the following two probabilities:\n\n- The probability that an operation moves the leftmost black ball to somewhere else.\n- The probability that an operation moves the black ball elsewhere to the leftmost position.\n\nDenoting them by \\(p, q\\), the transitions are as follows:\n\n\\(\\mathrm{dp}[0] = 1\\)  \n\\(\\mathrm{dp}[i+1] = (1 - p) \\mathrm{dp}[i] + q(1 - \\mathrm{dp}[i])\\)\n\nBy simple combinatorics:\n\n\\(\\displaystyle p = \\frac{2(n - 1)}{n^2}\\)  \n\\(\\displaystyle q = \\frac{2}{n^2}\\)\n\nImplementing it naively yields an \\(\\mathcal{O}(K)\\) solution, but it simplifies to a first-order recurrence relation, which can be efficiently computed, allowing \\(\\mathrm{dp}[K]\\) to be found in \\(\\mathcal{O}(\\log K)\\) time. This transforms the problem into a typical high-school math problem. More generally, algorithms such as the matrix powering algorithm and Fiduccia\u2019s algorithm can find the \\(N\\)-th term of a linear recurrence relation.\n[END TEXT]\n \n\n", "problem_ids": ["abc360_e"]}, "abc315_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou have \\( N \\) keys numbered \\( 1, 2, \\dots, N \\). Some of these are real keys, while the others are dummies. There is a door, Door X, into which you can insert any number of keys. Door X will open if and only if at least \\( K \\) real keys are inserted.\n\nYou have conducted \\( M \\) tests on these keys. The \\( i \\)-th test went as follows:\n- You inserted \\( C_i \\) keys \\( A_{i,1}, A_{i,2}, \\dots, A_{i,C_i} \\) into Door X.\n- The test result is represented by a single English letter \\( R_i \\).\n  - \\( R_i = \\text{o} \\) means that Door X opened in the \\( i \\)-th test.\n  - \\( R_i = \\text{x} \\) means that Door X did not open in the \\( i \\)-th test.\n\nThere are \\( 2^N \\) possible combinations of which keys are real and which are dummies. Among these, find the number of combinations that do not contradict any of the test results. It is possible that the given test results are incorrect and no combination satisfies the conditions. In such a case, report \\( 0 \\).\n\n**Constraints**\n- \\( N, M, K, C_i, \\text{ and } A_{i,j} \\) are integers.\n- \\( 1 \\le K \\le N \\le 15 \\)\n- \\( 1 \\le M \\le 100 \\)\n- \\( 1 \\le C_i \\le N \\)\n- \\( 1 \\le A_{i,j} \\le N \\)\n- \\( A_{i,j} \\neq A_{i,k} \\) if \\( j \\neq k \\).\n- \\( R_i \\) is \\( \\text{o} \\) or \\( \\text{x} \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M K\nC_1 A_{1,1} A_{1,2} \\dots A_{1,C_1} R_1\nC_2 A_{2,1} A_{2,2} \\dots A_{2,C_2} R_2\n\\vdots\nC_M A_{M,1} A_{M,2} \\dots A_{M,C_M} R_M\n```\n\n**Output**\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2 2\n3 1 2 3 o\n2 2 3 x\n```\n\n**Sample Output 1**\n```\n2\n```\n\nIn this input, there are three keys and two tests were conducted. Two correct keys are required to open Door X. In the first test, keys 1, 2, 3 were used, and Door X opened. In the second test, keys 2, 3 were used, and Door X did not open. There are two combinations of which keys are real and which are dummies that do not contradict any of the test results: Key 1 is real, key 2 is a dummy, and key 3 is real. Key 1 is real, key 2 is real, and key 3 is a dummy.\n\n**Sample Input 2**\n```\n4 5 3\n3 1 2 3 o\n3 2 3 4 o\n3 3 4 1 o\n3 4 1 2 o\n4 1 2 3 4 x\n```\n\n**Sample Output 2**\n```\n0\n```\n\nAs mentioned in the problem statement, the answer may be 0.\n\n**Sample Input 3**\n```\n11 4 9\n10 1 2 3 4 5 6 7 8 9 10 o\n11 1 2 3 4 5 6 7 8 9 10 11 o\n10 11 10 9 8 7 6 5 4 3 2 x\n10 11 9 1 4 3 7 5 6 2 10 x\n```\n\n**Sample Output 3**\n```\n8\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 356\n\n# C - Keys Editorial by en_translator:\n\n# By the constraints, the number of keys \\(N \\le 15\\), and the tests \\(M \\le 100\\). \n# There are \\(2^N\\) combinations of authenticities of the keys. We may perform the \\(M\\) tests \n# on all \\(2^N\\) combinations and count the number of proper combinations. \n# \\(2^N \\times M \\le 3.3 \\times 10^6\\) tests are required. \n# Even with \\(N\\) operations per test, the total number of operations is \\(5 \\times 10^7\\), which is fast enough. \n# We achieve this through bitwise enumeration by iterating over \\(i=0,1,\\dots,2^N-1\\). \n# The presence of bit \\(2^k\\) in \\(i\\) determines if the \\((k+1)\\)-th key is real or a dummy. \n# For more details, refer to relevant articles on bitwise enumeration.\n\n# Note that operations exceeding \\(N\\) per test might not meet the execution time limit. \n# Managing whether the \\(k\\)-th key was used limits operations per test to \\(N\\).\n\n# Sample code translated to Python:\nn, m, k = map(int, input().split())\nkey = [[0]*n for _ in range(m)]\nr = []\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c + 1):\n        a = data[j]\n        key[i][a-1] = 1\n    r.append(input().strip())\n\nres = 0\n\nfor i in range(1 << n):\n    tf = [0] * n\n    for j in range(n):\n        if i & (1 << j):\n            tf[j] = 1\n        else:\n            tf[j] = 0\n    jud = True\n    for j in range(m):\n        ck = 0\n        for p in range(n):\n            if key[j][p] == 1 and tf[p] == 1:\n                ck += 1\n        if ck >= k and r[j] == \"x\":\n            jud = False\n        if ck < k and r[j] == \"o\":\n            jud = False\n    if jud:\n        res += 1\n\nprint(res)\n\n# A faster approach using bitwise operations translated to Python:\nn, m, k = map(int, input().split())\nks = [0] * m\nr = [0] * m\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c+1):\n        a = data[j] - 1\n        ks[i] |= (1 << a)\n    s = input().strip()\n    if s == \"o\":\n        r[i] = 1\n    else:\n        r[i] = 0\n\nres = 0\n\nfor i in range(1 << n):\n    jud = True\n    for j in range(m):\n        ok = bin(i & ks[j]).count('1')\n        if ok >= k and r[j] == 0:\n            jud = False\n            break\n        if ok < k and r[j] == 1:\n            jud = False\n            break\n    if jud:\n        res += 1\n\nprint(res)\n```\n \n\n", "problem_ids": ["abc356_c"]}, "abc315_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\n", "problem_ids": ["abc361_a"]}, "abc318_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\n", "problem_ids": ["abc368_c"]}, "abc318_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given \\( N \\) pairs of integers \\((L_1, R_1), (L_2, R_2), \\ldots, (L_N, R_N)\\).\n\nDetermine whether there exists a sequence of \\( N \\) integers \\( X = (X_1, X_2, \\ldots, X_N) \\) that satisfies the following conditions, and print one such sequence if it exists:\n\n1. \\( L_i \\leq X_i \\leq R_i \\) for each \\( i = 1, 2, \\ldots, N \\).\n2. \\( \\sum_{i=1}^N X_i = 0 \\).\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq L_i \\leq R_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nL_1 R_1\nL_2 R_2\n\u22ee\nL_N R_N\n```\n\n**Output:**\n\nIf no solution exists, print `No`. Otherwise, print an integer sequence \\( X \\) that satisfies the conditions in the following format:\n\n```\nYes\nX_1 X_2 ... X_N\n```\n\nIf multiple solutions exist, any of them will be considered correct.\n\n**Sample Input 1:**\n\n```\n3\n3 5\n-4 1\n-2 3\n```\n\n**Sample Output 1:**\n\n```\nYes\n4 -3 -1\n```\n\nThe sequence \\( X = (4, -3, -1) \\) satisfies all the conditions. Other valid sequences include \\( (3, -3, 0) \\) and \\( (5, -4, -1) \\).\n\n**Sample Input 2:**\n\n```\n3\n1 2\n1 2\n1 2\n```\n\n**Sample Output 2:**\n\n```\nNo\n```\n\nNo sequence \\( X \\) satisfies the conditions.\n\n**Sample Input 3:**\n\n```\n6\n-87 12\n-60 -54\n2 38\n-76 6\n87 96\n-17 38\n```\n\n**Sample Output 3:**\n\n```\nYes\n-66 -57 31 -6 89 9\n```\n\nSolution:\n\n```\n        Editorial - Toyota Programming Contest 2024#7\uff08AtCoder Beginner Contest 362\uff09\n\nC - Sum = 0 Editorial by en_translator\n\nProblem: Given a sequence of non-negative integers \\(A=(A_1,A_2,\\ldots,A_N)\\) and an integer \\(S\\), determine if there exists a length-\\(N\\) integer sequence \\(X=(X_1,X_2,\\ldots,X_N)\\) satisfying:\n- \\(0 \\leq X_i \\leq A_i\\)\n- \\(\\sum X = S\\)\n\nNecessary and sufficient condition: \\(\\sum A \\geq S\\). Construct \\(X\\) greedily by maximizing each \\(X_i\\) from left to right.\n\nIf \\(\\sum L > 0\\), then \\(\\sum X \\geq \\sum L > 0\\), so no \\(X\\) satisfies. If \\(\\sum R < 0\\), no \\(X\\) satisfies because \\(\\sum X \\leq \\sum R < 0\\). Otherwise, a conforming \\(X\\) exists. Initialize \\(X_i\\) with \\(L_i\\) and adjust as needed.\n\nFor each \\(i=1,2,\\ldots,N\\):\n1. Repeat incrementing \\(X_i\\) by \\(+1\\) while \\(X_i < R_i\\) and \\(\\sum X < 0\\).\n2. Efficiently find increment as \\(D_i=\\min(R_i-L_i,-\\sum X)\\) and update \\(X_i\\) with \\(+D_i\\).\n\nComplexity: \\(O(N)\\).\n\n```python\nN = int(input())\nL, R = [0] * N, [0] * N\nfor i in range(N):\n    L[i], R[i] = map(int, input().split())\n\nif sum(L) > 0 or sum(R) < 0:\n    print(\"No\")\n    exit()\n\nX = L.copy()\nsumX = sum(X)\nfor i in range(N):\n    d = min(R[i] - L[i], -sumX)\n    sumX += d\n    X[i] += d\n\nprint(\"Yes\")\nprint(*X)\n```\n```\n \n\n", "problem_ids": ["abc362_c"]}, "abc318_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\n", "problem_ids": ["abc355_g"]}, "abc318_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\n\nFor a non-negative integer \\( K \\), we define a level-\\( K \\) carpet as follows:\n\n- A level-0 carpet is a \\( 1 \\times 1 \\) grid consisting of a single black cell.\n- For \\( K > 0 \\), a level-\\( K \\) carpet is a \\( 3^K \\times 3^K \\) grid. When this grid is divided into nine \\( 3^{K-1} \\times 3^{K-1} \\) blocks:\n  - The central block consists entirely of white cells.\n  - The other eight blocks are level-\\( (K-1) \\) carpets.\n\nYou are given a non-negative integer \\( N \\). Print a level-\\( N \\) carpet according to the specified format.\n\nConstraints:\n- \\( 0 \\leq N \\leq 6 \\)\n- \\( N \\) is an integer.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\n```\n\nOutput:\nPrint \\( 3^N \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq 3^N \\)) should contain a string \\( S_i \\) of length \\( 3^N \\) consisting of `.` and `#`. The \\( j \\)-th character of \\( S_i \\) (\\( 1 \\leq j \\leq 3^N \\)) should be `#` if the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left of a level-\\( N \\) carpet is black, and `.` if it is white.\n\nSample Input 1:\n```\n1\n```\n\nSample Output 1:\n```\n###\n#.#\n###\n```\n\nA level-1 carpet is a \\( 3 \\times 3 \\) grid as follows. When output according to the specified format, it looks like the sample output.\n\nSample Input 2:\n```\n2\n```\n\nSample Output 2:\n```\n#########\n#.##.##.#\n#########\n###...###\n#.#...#.#\n###...###\n#########\n#.##.##.#\n#########\n```\n\nA level-2 carpet is a \\( 9 \\times 9 \\) grid.\n\nSolution:\n\n```python\ndef main():\n    n = int(input())\n    l = 1\n    a = [['\\0' for _ in range(730)] for _ in range(729)]\n    \n    a[0][0] = '#'\n    for k in range(n):\n        for x in range(3):\n            for y in range(3):\n                if (x == 0) and (y == 0):\n                    continue\n                if (x == 1) and (y == 1):\n                    for i in range(l):\n                        for j in range(l):\n                            a[x * l + i][y * l + j] = '.'\n                else:\n                    for i in range(l):\n                        for j in range(l):\n                            a[x * l + i][y * l + j] = a[i][j]\n        l *= 3\n    \n    for i in range(l):\n        print(''.join(a[i]))\n\nmain()\n```\n \n\n", "problem_ids": ["abc357_c"]}, "abc318_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a simple connected undirected graph with \\( N \\) vertices and \\( M \\) edges. Each vertex \\( i \\,(1 \\leq i \\leq N) \\) has a weight \\( A_i \\). Each edge \\( j \\,(1 \\leq j \\leq M) \\) connects vertices \\( U_j \\) and \\( V_j \\) bidirectionally and has a weight \\( B_j \\).\n\nThe weight of a path in this graph is defined as the sum of the weights of the vertices and edges that appear on the path.\n\nFor each \\( i = 2, 3, \\dots, N \\), solve the following problem:\n- Find the minimum weight of a path from vertex 1 to vertex \\( i \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_j < V_j \\leq N \\)\n- \\( (U_i, V_i) \\neq (U_j, V_j) \\) if \\( i \\neq j \\).\n- The graph is connected.\n- \\( 0 \\leq A_i \\leq 10^9 \\)\n- \\( 0 \\leq B_j \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format: \n\n```\nN M\nA_1 A_2 \\dots A_N\nU_1 V_1 B_1\nU_2 V_2 B_2\n\\vdots\nU_M V_M B_M\n```\n\n**Output:**\n\nPrint the answers for \\( i = 2, 3, \\dots, N \\) in a single line, separated by spaces.\n\n**Sample Input 1:**\n\n```\n3 3\n1 2 3\n1 2 1\n1 3 6\n2 3 2\n```\n\n**Sample Output 1:**\n\n```\n4 9\n```\n\n**Explanation:**\n\nConsider the paths from vertex 1 to vertex 2. The weight of the path \\( 1 \\to 2 \\) is \\( A_1 + B_1 + A_2 = 1 + 1 + 2 = 4 \\), and the weight of the path \\( 1 \\to 3 \\to 2 \\) is \\( A_1 + B_2 + A_3 + B_3 + A_2 = 1 + 6 + 3 + 2 + 2 = 14 \\). The minimum weight is 4.\n\nConsider the paths from vertex 1 to vertex 3. The weight of the path \\( 1 \\to 3 \\) is \\( A_1 + B_2 + A_3 = 1 + 6 + 3 = 10 \\), and the weight of the path \\( 1 \\to 2 \\to 3 \\) is \\( A_1 + B_1 + A_2 + B_3 + A_3 = 1 + 1 + 2 + 2 + 3 = 9 \\). The minimum weight is 9.\n\n**Sample Input 2:**\n\n```\n2 1\n0 1\n1 2 3\n```\n\n**Sample Output 2:**\n\n```\n4\n```\n\n**Sample Input 3:**\n\n```\n5 8\n928448202 994752369 906965437 942744902 907560126\n2 5 975090662\n1 2 908843627\n1 5 969061140\n3 4 964249326\n2 3 957690728\n2 4 942986477\n4 5 948404113\n1 3 988716403\n```\n\n**Sample Output 3:**\n\n```\n2832044198 2824130042 4696218483 2805069468\n```\n\nNote that the answers may not fit in a 32-bit integer.\n\nSolution:\n\n```python\n\"\"\"\nEditorial - Toyota Programming Contest 2024#7 (AtCoder Beginner Contest 362)\n\nD - Shortest Path 3 Editorial\n\nThis is an exercise of an algorithm to find the shortest length of a path on a graph. For a graph with non-negative edge weights, the shortest length of a path can be found fast with Dijkstra\u2019s algorithm. In this problem, vertices have weights too, so we cannot directly apply Dijkstra\u2019s algorithm. Instead, we rephrase it into an edge-weighted problem. When traveling from vertex \\(U_i\\) to vertex \\(V_j\\) only via edge \\(j\\), the cost newly imposed is the cost to use edge \\(j\\) and to visit vertex \\(V_j\\), for a total of \\(B_j + A_{V_j}\\). Conversely, when traveling from vertex \\(V_i\\) to vertex \\(U_j\\) only via edge \\(j\\), the cost newly imposed is the cost to use edge \\(j\\) and to visit vertex \\(U_j\\), for a total of \\(B_j + A_{U_j}\\). Thus, by adding an edge of weight \\(B_j + A_{V_j}\\) in the direction of \\(U_j \\to V_j\\) and an edge of weight \\(B_j + A_{U_j}\\) in the direction of \\(V_j \\to U_j\\), every cost can be represented only with edge weights. By applying Dijkstra\u2019s algorithm on this graph and finally adding the weight of the initial point \\(A_1\\), one can find the answer. The time complexity is \\(O(M \\log N)\\).\n\"\"\"\n```\n \n\n", "problem_ids": ["abc362_d"]}, "abc319_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nAlice and Bob are playing a game with two positive integers \\( N \\) and \\( M \\), where \\( N < M \\). Each player has \\( N \\) cards numbered from 1 to \\( N \\). Alice starts the game, and they take turns playing one card from their hand onto the table. If, after a player plays a card, the sum of the numbers on the table is divisible by \\( M \\), the player who played the last card loses, and the other player wins. If all cards are played and the sum is never divisible by \\( M \\), Alice wins. Given \\( T \\) test cases, determine who will win (Alice or Bob) if both play optimally.\n\nConstraints:\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N < M \\leq 10^9 \\)\n\nInput:\n- The input consists of \\( T \\) test cases.\n- Each test case is described by two integers \\( N \\) and \\( M \\).\n\nOutput:\n- For each test case, output \"Alice\" if Alice wins or \"Bob\" if Bob wins when both players play optimally.\n\nSample Input:\n```\n8\n2 3\n3 6\n5 9\n45 58\n39 94\n36 54\n74 80\n61 95\n```\n\nSample Output:\n```\nAlice\nAlice\nBob\nBob\nAlice\nBob\nBob\nAlice\n```\n\nIn the first test case, both Alice and Bob have two cards: a 1 and a 2. Alice plays 1, and the sum is 1, which is not divisible by 3. Bob plays 1, making the sum 2, still not divisible by 3. Alice plays 2, making the sum 4, not divisible by 3. Bob plays 2, making the sum 6, which is divisible by 3, so Bob loses, and Alice wins. Alice wins regardless of Bob's strategy.\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 185\n\ndef mod_m_game(N, M):\n    # Calculate c\n    c = (N * (N + 1)) % M\n\n    # Determine if Alice loses or wins\n    if 1 <= c <= N:\n        return \"Bob wins\"\n    else:\n        return \"Alice wins\"\n\n# Example Usage\nN = 5\nM = 3\nresult = mod_m_game(N, M)\nprint(result)  # Output should be \"Bob wins\" or \"Alice wins\" based on the conditions\n```\n\nEditorial - AtCoder Regular Contest 185\n\nA - mod M Game 2 Editorial by evima\n\nFirst, focus on the moment when Alice plays her last card:\n\n- A player with two or more cards can avoid playing a losing card.\n- If Alice doesn't lose when playing her last card, she will win regardless of Bob's last move.\n\nDetermine if Alice loses with her last card using Bob\u2019s last card \\(b\\). The sum of the numbers on the cards played is \\(N(N+1) - b\\). We check if \\(N(N + 1) - b \\equiv 0 \\pmod{M}\\).\n\n1. If \\(1 \\leq (N(N+1) \\bmod M) \\leq N\\):\n   - Let \\(c = N(N + 1) \\bmod M\\). Bob can make his last card \\(b = c\\) by playing all cards except \\(c\\), leading to Alice's loss. Bob can achieve this by keeping \\(c\\) among his final cards.\n\n2. If \\(N(N + 1) - b\\) cannot be \\(0\\):\n   - Alice will not lose on her last card, leading to her victory.\n\nBob wins if \\(1 \\leq N(N + 1) \\bmod M \\leq N\\), otherwise Alice wins. This can be determined in \\(O(1)\\) time.\n \n\n", "problem_ids": ["arc185_a"]}, "abc319_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 1100 points\n\nProblem Statement:\nYou have an integer sequence \\(a=(a_1, a_2, \\ldots, a_N)\\) of length \\(N\\). Initially, all elements are 0. You are given an integer \\(C\\) and \\(M\\) intervals \\(([L_1, R_1], [L_2, R_2], \\ldots, [L_M, R_M])\\).\n\nYou will choose a permutation \\(p\\) of \\((1, 2, \\ldots, M)\\) and an integer sequence \\(w=(w_1, w_2, \\ldots, w_M)\\) of length \\(M\\) where \\(1 \\le w_i \\le C\\) must hold.\n\nThen, you will perform \\(M\\) modifications. The \\(i\\)-th modification involves:\n\n- Changing \\(a_{L_{p_i}}, \\ldots, a_{R_{p_i}}\\) to \\(w_i\\).\n\nIt is guaranteed that every position in \\(a\\) is covered by at least one interval. Determine the number of possible sequences \\(a\\) after all modifications. Print the answer modulo \\(998244353\\).\n\nConstraints:\n- \\(1 \\le N \\le 100\\)\n- \\(1 \\le M \\le \\frac{N(N+1)}{2}\\)\n- \\(1 \\le C < 998244353\\)\n- \\(1 \\le L_i \\le R_i \\le N\\)\n- \\((L_i, R_i) \\neq (L_j, R_j)\\) for \\(i \\neq j\\)\n- Every position in \\(a\\) is covered by at least one interval.\n- All input values are integers.\n\nInput:\nInput is given from Standard Input in the following format:\n```\nN M C\nL_1 R_1\nL_2 R_2\n\u22ee\nL_M R_M\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n5 5 2\n1 3\n2 2\n3 3\n1 5\n3 5\n```\n\nSample Output 1:\n```\n16\n```\nThere are 16 sequences that can be achieved. For example, you can achieve \\(a=(2, 1, 1, 1, 1)\\) in the following manner:\n- Choose \\(p=(4, 1, 2, 3, 5)\\) and \\(w=(1, 2, 1, 2, 1)\\).\n- The 1st operation changes \\(a\\) into \\((1, 1, 1, 1, 1)\\).\n- The 2nd operation changes \\(a\\) into \\((2, 2, 2, 1, 1)\\).\n- The 3rd operation changes \\(a\\) into \\((2, 1, 2, 1, 1)\\).\n- The 4th operation changes \\(a\\) into \\((2, 1, 2, 1, 1)\\).\n- The 5th operation changes \\(a\\) into \\((2, 1, 1, 1, 1)\\).\n\nSample Input 2:\n```\n20 30 20\n1 14\n1 7\n1 16\n3 13\n1 17\n4 8\n2 11\n4 12\n9 14\n3 15\n11 19\n1 13\n4 15\n8 19\n3 17\n15 18\n10 18\n1 18\n17 19\n16 20\n1 8\n8 15\n13 17\n1 19\n13 19\n1 20\n6 13\n10 12\n11 20\n17 18\n```\n\nSample Output 2:\n```\n258066445\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Grand Contest 067\n\nB - Modifications Editorial by Kubic\n\nWe consider how to judge whether \\(a\\) can be generated. We reverse the process so that each modification changes an interval to any value, which we denote as this modification \u201ccovers\u201d the interval. We can then build a greedy process: If all uncovered elements in \\([l_i,r_i]\\) have the same value, cover them. The process ends when no more intervals can be selected. Obviously, \\(a\\) can be generated if and only if all elements are covered.\n\nWe solve the problem by an interval DP. To transition, calculate the invalid ones. There will be some elements left uncovered. Find all maximal covered intervals \\([p_1,q_1]\\dots [p_k,q_k]\\), which form \\(k\\) independent subproblems. Ensure that \u201cno more intervals can be selected.\u201d In the DP state, maintain the rightmost uncovered element with a value different from the rightmost uncovered element in the interval. This suffices to judge validity. The time complexity is \\(O(n^4)\\). \\(O(n^5)\\) solutions with a small constant may pass.\n[END TEXT]\n \n\n", "problem_ids": ["agc067_b"]}, "abc319_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nIn the AtCoder World Tour Finals 2800, `N` contestants participated, and a total of five problems were presented. Each problem is assigned an integer score of at least 1 point, and the problems are numbered so that the scores are non-decreasing from problem 1 to problem 5. There are no partial points. Similar to the usual AtCoder rules, ranking is done as follows: The contestant with the higher total score ranks higher. In case of a tie, the one with the smaller penalty ranks higher. In this problem, we do not consider the situation where multiple contestants have the same total score and penalty.\n\nAoki, a reporter covering the finals, noted the following information:\n1. The number of participants `N`.\n2. Which problems each contestant solved. `A[i, j] = 1` means the `i`-th contestant (1 \u2264 `i` \u2264 `N`) correctly solved problem `j`, and `A[i, j] = 0` means they did not.\n3. The rank of each contestant. The `i`-th contestant (1 \u2264 `i` \u2264 `N`) was ranked `R[i]`-th.\n\nHowever, when he started writing the article, he realized he did not note the scores and penalties. Furthermore, he realized there might be inconsistencies in the information he noted. Now, solve the following problem:\n\nAssume that he correctly noted information 1 and 2. Let `D[i]` be the actual rank of contestant `i` (1 \u2264 `i` \u2264 `N`), and find the minimum possible total squared error `(D[1] - R[1])^2 + (D[2] - R[2])^2 + ... + (D[N] - R[N])^2`.\n\nYou have `T` test cases to process.\n\n## Constraints\n- `1 \u2264 T \u2264 10^5`\n- `2 \u2264 N \u2264 3 \u00d7 10^5`\n- Each `A[i,1], A[i,2], A[i,3], A[i,4], A[i,5]` is 0 or 1 (1 \u2264 `i` \u2264 `N`).\n- The sum of `A[i,1], A[i,2], A[i,3], A[i,4], A[i,5]` is at least 1 (1 \u2264 `i` \u2264 `N`).\n- `1 \u2264 R[i] \u2264 N` (1 \u2264 `i` \u2264 `N`)\n- `R[1], R[2], ..., R[N]` are distinct.\n- The total value of `N` across all test cases is at most 3 \u00d7 10^5.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format. Here `case_i` represents the `i`-th test case (1 \u2264 `i` \u2264 `T`).\n\n```\nT\ncase_1\ncase_2\n...\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA[1,1] A[1,2] A[1,3] A[1,4] A[1,5]\nA[2,1] A[2,2] A[2,3] A[2,4] A[2,5]\n...\nA[N,1] A[N,2] A[N,3] A[N,4] A[N,5]\nR[1] R[2] ... R[N]\n```\n\n## Output\n\nPrint the answers.\n\n## Sample Input 1\n\n```\n6\n4\n0 1 1 0 0\n1 0 0 1 0\n1 1 0 1 0\n1 0 1 0 0\n1 2 3 4\n8\n0 1 0 0 0\n1 1 0 1 0\n0 1 1 0 1\n1 0 0 0 0\n1 1 0 1 0\n0 1 0 0 0\n0 0 0 1 0\n0 1 1 1 1\n7 4 2 8 3 6 5 1\n6\n1 1 0 0 0\n0 0 1 0 0\n1 1 1 0 0\n0 0 0 1 0\n1 1 1 1 0\n0 0 0 0 1\n1 2 3 4 5 6\n6\n1 1 0 0 0\n0 0 1 0 0\n1 1 1 0 0\n0 0 0 1 0\n1 1 1 1 0\n0 0 0 0 1\n6 5 4 3 2 1\n20\n0 0 0 0 1\n0 0 1 0 0\n1 1 0 0 1\n1 0 1 0 1\n0 0 0 1 1\n0 0 1 1 1\n1 1 1 1 0\n1 1 0 1 0\n0 0 1 1 0\n1 0 1 0 0\n0 1 0 0 1\n0 1 1 1 1\n1 1 1 1 1\n0 1 0 1 0\n1 0 0 0 1\n1 1 1 0 0\n0 1 1 1 0\n0 0 0 1 0\n1 1 1 0 1\n1 1 0 1 1\n7 18 3 5 19 11 13 2 4 10 14 15 17 6 16 9 8 12 1 20\n15\n0 0 1 1 0\n0 0 0 1 0\n0 0 0 0 1\n0 0 1 1 1\n1 1 0 0 1\n0 1 1 1 0\n1 1 1 1 1\n0 1 1 0 1\n1 1 0 1 0\n1 0 0 1 1\n1 0 1 0 0\n1 1 0 1 1\n0 1 0 1 0\n1 1 0 0 0\n0 1 0 0 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n```\n\n## Sample Output 1\n\n```\n6\n0\n26\n0\n1054\n428\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - AtCoder Regular Contest 177\n\nSolution to the problem:\nThere are only \\(113\\) scoring distributions for the contest that need to be considered. Once the scoring distribution is determined, arranging the penalties so that the smaller \\(R_i\\) values correspond to smaller penalties (within ties) will always minimize the squared error. Using something like `sorted`, the solution can be obtained in approximately \\(113N \\log N\\) computations.\n\nExample Scoring Distributions:\n- [1, 1, 1, 1, 1]\n- [1, 1, 1, 1, 2]\n... \n- [4, 5, 6, 7, 8]\n\nSteps to the solution:\n1. Consider scoring distributions based on problem-solving instances and ensure scores are non-decreasing.\n2. Extend the approach to contests with 5 problems, considering intersection points of hyperplanes in a 5-dimensional space.\n3. Prune duplicates and non-eligible scoring distributions, reducing the number of distributions to \\(113\\), allowing timely computations for input constraints.\n\nSample Implementation (Python):\n```python\n# Sample scoring distributions candidates\nCandidates = [ /* List of scoring distributions */ ]\n\ndef get_error(N, A, R, Score):\n    Sorted = []\n    for i in range(N):\n        sum_scores = sum(A[i][j] * Score[j] for j in range(5))\n        Sorted.append((sum_scores, -R[i]))\n    Sorted.sort(reverse=True)\n\n    error = 0\n    for i in range(N):\n        idx1 = -Sorted[i][1]\n        idx2 = i + 1\n        error += (idx1 - idx2) * (idx1 - idx2)\n    return error\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = [list(map(int, input().split())) for _ in range(N)]\n        R = list(map(int, input().split()))\n\n        answer = float('inf')\n        for cand in Candidates:\n            result = get_error(N, A, R, cand)\n            answer = min(answer, result)\n        print(answer)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis concise edit provides essential problem-solving steps, example scoring distributions, and the complete Python implementation code without unnecessary information.\n        [END TEXT]\n \n\n", "problem_ids": ["arc177_e"]}, "abc319_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nBelow is the cleaned version of the problem statement:\n\n---\n\nThere is a graph with \\(N + Q\\) vertices, numbered \\(1, 2, \\ldots, N + Q\\). Initially, the graph has no edges.\n\nFor this graph, perform the following operation for \\(i = 1, 2, \\ldots, Q\\) in order:\n\n- For each integer \\(j\\) satisfying \\(L_i \\leq j \\leq R_i\\), add an undirected edge with cost \\(C_i\\) between vertices \\(N + i\\) and \\(j\\).\n\nDetermine if the graph is connected after all operations are completed. If it is connected, find the cost of a minimum spanning tree of the graph.\n\nA minimum spanning tree is a spanning tree with the smallest possible cost, and the cost of a spanning tree is the sum of the costs of the edges used in the spanning tree.\n\n### Constraints\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(1 \\leq L_i \\leq R_i \\leq N\\)\n- \\(1 \\leq C_i \\leq 10^9\\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nL_1 R_1 C_1\nL_2 R_2 C_2\n...\nL_Q R_Q C_Q\n```\n\n### Output\n\nIf the graph is connected, print the cost of a minimum spanning tree. Otherwise, print \\(-1\\).\n\n### Sample Input 1\n\n```\n4 3\n1 2 2\n1 3 4\n2 4 5\n```\n\n### Sample Output 1\n\n```\n22\n```\n\nThe following edges form a minimum spanning tree:\n\n- An edge with cost 2 connecting vertices 1 and 5\n- An edge with cost 2 connecting vertices 2 and 5\n- An edge with cost 4 connecting vertices 1 and 6\n- An edge with cost 4 connecting vertices 3 and 6\n- An edge with cost 5 connecting vertices 3 and 7\n- An edge with cost 5 connecting vertices 4 and 7\n\nSince \\(2 + 2 + 4 + 4 + 5 + 5 = 22\\), print 22.\n\n### Sample Input 2\n\n```\n6 2\n1 2 10\n4 6 10\n```\n\n### Sample Output 2\n\n```\n-1\n```\n\nThe graph is disconnected.\n\n### Sample Input 3\n\n```\n200000 4\n1 200000 1000000000\n1 200000 998244353\n1 200000 999999999\n1 200000 999999999\n```\n\n### Sample Output 3\n\n```\n199651870599998\n```\n\n---\n\nSolution:\n\n        [BEGIN TEXT]\n        Since the graph in this problem may have up to \\(NQ\\) edges, one cannot directly apply an algorithm that determines the minimum spanning tree of a general graph. We will try to exploit the special form of the graph to optimize Kruskal\u2019s algorithm against it. We first sort the edges by their costs and appropriately reassign indices so that \\(C_1 \\leq C_2 \\leq \\ldots \\leq C_Q\\). According to Kruskal\u2019s algorithm, one can determine the minimum spanning tree as follows:\n\nPrepare an \\((N + Q)\\)-vertex graph without an edge. For \\(i = 1, 2, \\ldots ,Q\\) in order:\n\nFor each \\(j = L_i, L_i + 1, \\ldots, R_i\\) in order, add an edge between vertices \\((N + i)\\) and \\(j\\) of cost \\(C_i\\) if and only if vertices \\((N + i)\\) and \\(j\\) are not connected.\n\nWhile it is still difficult to handle the conditions, one can notice that vertices \\((N + i)\\) and \\(j\\) are always disconnected if \\(j =L_i\\), and that vertices \\((N + i)\\) and \\((j - 1)\\) are connected if and only if vertices \\((j - 1)\\) and \\(j\\) are, in order to realize that it is sufficient to perform connectivity check for vertices with adjacent indices: \\(j - 1\\) and \\(j\\). Also, the graph is disconnected if and only if there exists an integer \\(j\\) between \\(1\\) and \\((N-1)\\) (inclusive) such that vertices \\((j - 1)\\) and \\(j\\) are disconnected. Naively implementing this still costs \\(\\Theta(NQ + Q\\log Q)\\), but now that the problem is simplified, there are various approaches.\n\n(1) Use a set (or similar data structure) Manage the set of \\(1 \\leq j < N\\) such that vertices \\((j - 1)\\) and \\(j\\) are disconnected in a data structure like the built-in set in Python, and remove those among \\(L_i, L_i + 1, \\ldots, R_i - 1\\) that is not in the set. Naively checking the existence for each element still leads to TLE, but one can use a method such as bisect.bisect_left that retrieves the position of the minimum element greater than or equal to \\(x\\), as removal of an element occurs at most \\((N - 1)\\) times and the complexity is bounded by \\(O((N + Q) \\log N)\\), which is fast enough.\n\n(2) Use a lazy segment tree One can also use a lazy segment tree that supports segment-sum retrieval and segment-filling with \\(0\\). The \\(j\\)-th element of the lazy segment tree should be \\(0\\) if vertices \\(j\\) and \\((j+1)\\) are connected, and \\(1\\) otherwise. Initialize such a segment tree of length \\((N-1)\\) all with \\(1\\); then the number of edges connecting vertex \\(N + i\\) and any of vertices \\(L_i + 1, L_i + 2, \\ldots, R_i\\) can be retrieved as the segment sum of \\([L_i, R_i)\\), and adding an edge is fulfilled by filling \\([L_i, R_i)\\) with \\(0\\).\n\n(3) Use bitwise operations While a naive scan-based algorithm on an array results in TLE (Time Limit Exceeded), one can make use of bitwise operations with almost the same idea. The answer can be found fast enough by managing connectivity for each \\((j, j+1)\\) using the built-in int type in Python and using a function that returns the next position of \\(1\\) in the same way as found in (1), the answer can be found fast enough.\n        [END TEXT]\n \n\n", "problem_ids": ["abc364_f"]}, "abc320_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nAlice and Bob are playing a game with two positive integers \\( N \\) and \\( M \\), where \\( N < M \\). Each player has \\( N \\) cards numbered from 1 to \\( N \\). Alice starts the game, and they take turns playing one card from their hand onto the table. If, after a player plays a card, the sum of the numbers on the table is divisible by \\( M \\), the player who played the last card loses, and the other player wins. If all cards are played and the sum is never divisible by \\( M \\), Alice wins. Given \\( T \\) test cases, determine who will win (Alice or Bob) if both play optimally.\n\nConstraints:\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N < M \\leq 10^9 \\)\n\nInput:\n- The input consists of \\( T \\) test cases.\n- Each test case is described by two integers \\( N \\) and \\( M \\).\n\nOutput:\n- For each test case, output \"Alice\" if Alice wins or \"Bob\" if Bob wins when both players play optimally.\n\nSample Input:\n```\n8\n2 3\n3 6\n5 9\n45 58\n39 94\n36 54\n74 80\n61 95\n```\n\nSample Output:\n```\nAlice\nAlice\nBob\nBob\nAlice\nBob\nBob\nAlice\n```\n\nIn the first test case, both Alice and Bob have two cards: a 1 and a 2. Alice plays 1, and the sum is 1, which is not divisible by 3. Bob plays 1, making the sum 2, still not divisible by 3. Alice plays 2, making the sum 4, not divisible by 3. Bob plays 2, making the sum 6, which is divisible by 3, so Bob loses, and Alice wins. Alice wins regardless of Bob's strategy.\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 185\n\ndef mod_m_game(N, M):\n    # Calculate c\n    c = (N * (N + 1)) % M\n\n    # Determine if Alice loses or wins\n    if 1 <= c <= N:\n        return \"Bob wins\"\n    else:\n        return \"Alice wins\"\n\n# Example Usage\nN = 5\nM = 3\nresult = mod_m_game(N, M)\nprint(result)  # Output should be \"Bob wins\" or \"Alice wins\" based on the conditions\n```\n\nEditorial - AtCoder Regular Contest 185\n\nA - mod M Game 2 Editorial by evima\n\nFirst, focus on the moment when Alice plays her last card:\n\n- A player with two or more cards can avoid playing a losing card.\n- If Alice doesn't lose when playing her last card, she will win regardless of Bob's last move.\n\nDetermine if Alice loses with her last card using Bob\u2019s last card \\(b\\). The sum of the numbers on the cards played is \\(N(N+1) - b\\). We check if \\(N(N + 1) - b \\equiv 0 \\pmod{M}\\).\n\n1. If \\(1 \\leq (N(N+1) \\bmod M) \\leq N\\):\n   - Let \\(c = N(N + 1) \\bmod M\\). Bob can make his last card \\(b = c\\) by playing all cards except \\(c\\), leading to Alice's loss. Bob can achieve this by keeping \\(c\\) among his final cards.\n\n2. If \\(N(N + 1) - b\\) cannot be \\(0\\):\n   - Alice will not lose on her last card, leading to her victory.\n\nBob wins if \\(1 \\leq N(N + 1) \\bmod M \\leq N\\), otherwise Alice wins. This can be determined in \\(O(1)\\) time.\n \n\n", "problem_ids": ["arc185_a"]}, "abc320_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nFor strings \\( S \\) and \\( T \\) consisting of lowercase English letters, and a string \\( X \\) consisting of \\( 0 \\) and \\( 1 \\), define the string \\( f(S,T,X) \\) consisting of lowercase English letters as follows:\n\nStarting with an empty string, for each \\( i = 1, 2, \\dots, |X| \\), append \\( S \\) to the end if the \\( i \\)-th character of \\( X \\) is \\( 0 \\), and append \\( T \\) to the end if it is \\( 1 \\).\n\nYou are given a string \\( S \\) consisting of lowercase English letters, and strings \\( X \\) and \\( Y \\) consisting of \\( 0 \\) and \\( 1 \\).\n\nDetermine if there exists a string \\( T \\) (which can be empty) such that \\( f(S,T,X) = f(S,T,Y) \\).\n\nYou have \\( t \\) test cases to solve.\n\n### Constraints\n- \\( 1 \\leq t \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq |S| \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq |X|, |Y| \\leq 5 \\times 10^5 \\)\n- \\( S \\) is a string consisting of lowercase English letters.\n- \\( X \\) and \\( Y \\) are strings consisting of \\( 0 \\) and \\( 1 \\).\n- The sum of \\( |S| \\) across all test cases in a single input is at most \\( 5 \\times 10^5 \\).\n- The sum of \\( |X| \\) across all test cases in a single input is at most \\( 5 \\times 10^5 \\).\n- The sum of \\( |Y| \\) across all test cases in a single input is at most \\( 5 \\times 10^5 \\).\n\n### Input\nThe input is given from Standard Input in the following format:\n- \\( t \\)\n- \\( \\text{case}_1 \\)\n- \\( \\dots \\)\n- \\( \\text{case}_t \\)\n\nEach case is given in the following format:\n- \\( S \\)\n- \\( X \\)\n- \\( Y \\)\n\n### Output\nPrint \\( t \\) lines. The \\( i \\)-th line should contain `Yes` if there exists a \\( T \\) that satisfies the condition for the \\( i \\)-th test case, and `No` otherwise.\n\n### Sample Input 1\n```\n3\naraara\n01\n111\naraaaa\n100100\n0010111\nabacabac\n0\n1111\n```\n\n### Sample Output 1\n```\nYes\nNo\nNo\n```\n\nBelow, string concatenation is represented using \\( + \\). For the 1st test case, if \\( T = \\text{ara} \\), then \\( f(S,T,X) = S+T = \\text{araaraara} \\) and \\( f(S,T,Y) = T+T+T = \\text{araaraara} \\), so \\( f(S,T,X) = f(S,T,Y) \\). For the 2nd and 3rd test cases, there is no \\( T \\) that satisfies the condition.\n\n### Sample Input 2\n```\n2\nempty\n10101\n00\nempty\n11111\n111\n```\n\n### Sample Output 2\n```\nYes\nYes\n```\n\n\\( T \\) can be empty.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 181\n\nB - Annoying String Problem Editorial\n\nIn most cases, the length of \\(f(S,T,X)\\) and \\(f(S,T,Y)\\) being equal reveals the length of \\(T\\). Let\u2019s consider under what conditions \\(S\\) and \\(T\\) satisfy \\(f(S,T,X)=f(S,T,Y)\\) when the lengths of \\(S\\) and \\(T\\) are known.\n\nFor instance, when \\(|S|=6\\) and \\(|T|=4\\), consider when \\(S+T+T+S+T+S=T+T+T+S+T+T+T\\) holds. \\(T\\) must be a prefix of \\(S\\), and \\(S\\) can be expressed as \\(S=T+S'\\) using \\(S'\\) with \\(|S'|=2\\). Replacing this in the equation, we get:\n\n\\(T+S'+T+T+T+S'+T+T+S' = T+T+T+T+S'+T+T+T\\)\n\nNext, \\(S'\\) must be a prefix of \\(T\\), and \\(T\\) can be expressed as \\(T=S'+T'\\) using \\(T'\\) with \\(|T'|=2\\). In this equation, \\(S'=T'\\) is necessary and sufficient since \\(|S'|\\) and \\(|T'|\\) are equal. Representing \\(S\\) and \\(T\\) using \\(S'=T'=U\\), we get \\(S=U+U+U\\) and \\(T=U+U\\). \n\nGeneralizing this process, we find:\n- If the lengths of two strings \\(A\\) and \\(B\\) are equal, \\(A=B\\).\n- If the equation is not trivial, \\(A\\) and \\(B\\) are repetitions of a common string \\(C\\) of length \\(L\\), where \\(L\\) is found using the Euclidean algorithm, so \\(L=\\mathrm{gcd}(n,m)\\).\n\nIf the number of 1s in \\(X\\) and \\(Y\\) is equal, setting \\(T=S\\) satisfies \\(f(S,T,X)=f(S,T,Y)\\), so the answer is Yes. Otherwise, lengths of \\(f(S,T,X)\\) and \\(f(S,T,Y)\\) cannot be equal, so the answer is No.\n\nWhen \\(X\\neq Y\\):\n- \\(f(S,T,X)=f(S,T,Y) \\iff S\\) and \\(T\\) are repetitions of a string \\(U\\) of length \\(\\mathrm{gcd}(|S|,|T|)\\).\n- \\(T\\) exists if \\(S\\) has a period of \\(\\mathrm{gcd}(|S|,|T|)\\).\n\nThis can be checked in \\(O(|S|)\\) time by verifying if the \\(i\\)-th character of \\(S\\) is equal to the \\((i+\\mathrm{gcd}(|S|,|T|))\\)-th character.\n\nProof is done by induction on \\(||S|-|T||\\), showing necessity and sufficiency.\n```\n \n\n", "problem_ids": ["arc181_b"]}, "abc320_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\n", "problem_ids": ["abc366_e"]}, "abc320_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a sequence of \\( N \\) positive integers \\( A = (A_1, A_2, \\dots, A_N) \\).\n\nFind the number of pairs of integers \\( (l, r) \\) satisfying \\( 1 \\leq l \\leq r \\leq N \\) such that the subsequence \\( (A_l, A_{l+1}, \\dots, A_r) \\) forms an arithmetic progression.\n\nA sequence \\( (x_1, x_2, \\dots, x_{|x|}) \\) is an arithmetic progression if and only if there exists a \\( d \\) such that \\( x_{i+1} - x_i = d \\) for \\( 1 \\leq i < |x| \\). In particular, a sequence of length \\( 1 \\) is always an arithmetic progression.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n4\n3 6 9 3\n```\n\n**Sample Output 1:**\n\n```\n8\n```\n\nThere are eight pairs of integers \\( (l, r) \\) satisfying the condition: \\( (1,1), (2,2), (3,3), (4,4), (1,2), (2,3), (3,4), (1,3) \\). Indeed, when \\( (l, r) = (1, 3) \\), \\( (A_l, \\dots, A_r) = (3, 6, 9) \\) is an arithmetic progression, so it satisfies the condition. However, when \\( (l, r) = (2, 4) \\), \\( (A_l, \\dots, A_r) = (6, 9, 3) \\) is not an arithmetic progression, so it does not satisfy the condition.\n\n**Sample Input 2:**\n\n```\n5\n1 1 1 1 1\n```\n\n**Sample Output 2:**\n\n```\n15\n```\n\nAll pairs of integers \\( (l, r) \\) satisfying \\( 1 \\leq l \\leq r \\leq 5 \\) satisfy the condition.\n\n**Sample Input 3:**\n\n```\n8\n87 42 64 86 72 58 44 30\n```\n\n**Sample Output 3:**\n\n```\n22\n```\n\nSolution:\n\n```markdown\n[C - Count Arithmetic Subarrays Editorial]\n\nThe condition is always satisfied if \\(l = r\\), so we will add \\(n\\) to the answer finally and consider pairs \\((l, r)\\) such that \\(l < r\\). Let \\(B = (B_1, B_2, \\dots, B_{N-1})\\) be the sequence of differences of \\(A\\); that is, \\(B_i = A_{i+1} - A_i\\). The subarray \\((l, r)\\) satisfies the condition of being an arithmetic progression if and only if \\(B_l = B_{l+1} = \\dots = B_{r-1}\\). Thus, the problem is reduced to finding the number of pairs \\((l, r)\\) such that \\(B_l = B_{l+1} = \\dots = B_r\\).\n\nTo solve this, apply run-length compression to \\(B\\), obtaining a sequence of integer pairs \\((C_1, D_1), (C_2, D_2), \\dots, (C_k, D_k)\\). The sequence \\(B\\) is a concatenation of runs \\(f(i)\\), where each \\(C_i\\) is repeated \\(D_i\\) times. A segment \\([l, r]\\) conforming to the condition is completely contained within a run \\(f(i)\\). The number of such segments in \\(f(i)\\) is \\(\\frac{D_i(D_i+1)}{2}\\). The answer is \\(\\displaystyle \\sum_{i=1}^{k} \\frac{D_i(D_i+1)}{2}\\).\n```\n \n\n", "problem_ids": ["abc369_c"]}, "abc320_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nCertainly! Here is a cleaned and structured version of the problem statement:\n\n---\n\n**Score**: 250 points\n\n### Problem Statement\n\nThere are \\( N \\) dishes, and the \\( i \\)-th dish has a **sweetness** of \\( A_i \\) and a **saltiness** of \\( B_i \\).\n\nTakahashi plans to arrange these \\( N \\) dishes in any order he likes and eat them in that order. He will stop eating as soon as the total sweetness of the dishes he has eaten exceeds \\( X \\) or the total saltiness exceeds \\( Y \\).\n\nFind the minimum possible number of dishes that he will end up eating.\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq X, Y \\leq 2 \\times 10^{14} \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN X Y\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n4 7 18\n2 3 5 1\n8 8 1 4\n```\n\n### Sample Output 1\n\n```\n2\n```\n\n**Explanation**\n\nThe \\( i \\)-th dish will be denoted as dish \\( i \\). If he arranges the four dishes in the order \\( 2, 3, 1, 4 \\), as soon as he eats dishes \\( 2 \\) and \\( 3 \\), their total sweetness is 8, which is greater than 7. Therefore, in this case, he will end up eating two dishes. The number of dishes he will eat cannot be 1 or less, so print 2.\n\n### Sample Input 2\n\n```\n5 200000000000000 200000000000000\n1 1 1 1 1\n2 2 2 2 2\n```\n\n### Sample Output 2\n\n```\n5\n```\n\n### Sample Input 3\n\n```\n8 30 30\n1 2 3 4 5 6 7 8\n8 7 6 5 4 3 2 1\n```\n\n### Sample Output 3\n\n```\n6\n```\n\n--- \n\nThis is a structured and detailed explanation capturing the essence and rules of the problem.\n\nSolution:\n\nHere is a clean version of the provided editorial:\n\n**C - Minimum Glutton Editorial**\n\nConsider the following Problem A and Problem B:\n- **Problem A**: Arrange the \\(N\\) dishes and eat them in order until the total sweetness exceeds \\(X\\). What is the minimum number of dishes eaten?\n- **Problem B**: Arrange the \\(N\\) dishes and eat them in order until the total saltiness exceeds \\(Y\\). What is the minimum number of dishes eaten?\n\nFor a fixed arrangement, once the stopping condition in Problem A or Problem B is satisfied, the original problem's condition is satisfied. Thus, the answer to the original problem equals the minimum of the answers to Problems A and B. Sort the dishes in descending order of \\(A_i\\) and \\(B_i\\), respectively, and eat them from the first in order to achieve the minimum value.\n\n**Sample code:**\n```python\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort(reverse=True)\nb.sort(reverse=True)\n\nc1 = 0\nc2 = 0\nsx = 0\nsy = 0\n\nfor ai in a:\n    sx += ai\n    c1 += 1\n    if sx > x:\n        break\n\nfor bi in b:\n    sy += bi\n    c2 += 1\n    if sy > y:\n        break\n\nprint(min(c1, c2))\n```\n \n\n", "problem_ids": ["abc364_c"]}, "abc321_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a permutation \\( P = (P_1, P_2, \\dots, P_N) \\) of \\((1, 2, \\dots, N)\\).\n\nConsider the following operations \\( k \\ (k = 2, 3, \\dots, N) \\) on this permutation.\n\n**Operation \\( k \\):** For \\( i = 1, 2, \\dots, k-1 \\) in this order, if \\( P_i > P_{i+1} \\), swap the values of the \\( i \\)-th and \\( (i+1) \\)-th elements of \\( P \\).\n\nYou are also given a **non-decreasing** sequence \\( A = (A_1, A_2, \\dots, A_M) \\ (2 \\leq A_i \\leq N) \\) of length \\( M \\).\n\nFor each \\( i = 1, 2, \\dots, M \\), find the inversion number of \\( P \\) after applying the operations \\( A_1, A_2, \\dots, A_i \\) in this order.\n\n*What is the inversion number of a sequence?*\n\nThe inversion number of a sequence \\( x = (x_1, x_2, \\dots, x_n) \\) of length \\( n \\) is the number of pairs of integers \\( (i, j) \\ (1 \\leq i < j \\leq n) \\) such that \\( x_i > x_j \\).\n\n---\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2 \\leq A_i \\leq N \\)\n- \\( P \\) is a permutation of \\( (1, 2, \\dots, N) \\).\n- \\( A_i \\leq A_{i+1} \\) for \\( i = 1, 2, \\dots, M-1 \\).\n- All input values are integers.\n\n---\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nP_1 P_2 \\dots P_N\nM\nA_1 A_2 \\dots A_M\n```\n\n**Output**\n\nPrint \\( M \\) lines. The \\( k \\)-th line should contain the answer to the problem for \\( i = k \\).\n\n---\n\n**Sample Input 1**\n\n```\n6\n3 2 4 1 6 5\n2\n4 6\n```\n\n**Sample Output 1**\n\n```\n3\n1\n```\n\nFirst, operation \\( 4 \\) is performed. During this, \\( P \\) changes as follows: \\((3, 2, 4, 1, 6, 5) \\rightarrow (2, 3, 4, 1, 6, 5) \\rightarrow (2, 3, 4, 1, 6, 5) \\rightarrow (2, 3, 1, 4, 6, 5)\\). The inversion number of \\( P \\) afterward is \\( 3 \\).\n\nNext, operation \\( 6 \\) is performed, where \\( P \\) eventually becomes \\((2, 1, 3, 4, 5, 6)\\), whose inversion number is \\( 1 \\).\n\n---\n\n**Sample Input 2**\n\n```\n20\n12 14 16 8 7 15 19 6 18 5 13 9 10 17 4 1 11 20 2 3\n15\n3 4 6 8 8 9 10 12 13 15 18 18 19 19 20\n```\n\n**Sample Output 2**\n\n```\n117\n116\n113\n110\n108\n105\n103\n99\n94\n87\n79\n72\n65\n58\n51\n```\n\nSolution:\n\n```python\n# The editorial content doesn't contain any code that needs translation.\n```\n\n \n\n", "problem_ids": ["arc181_d"]}, "abc321_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) types of elements numbered \\( 1, 2, \\ldots, N \\). Elements can be combined with each other. When elements \\( i \\) and \\( j \\) are combined, they transform into element \\( A_{i, j} \\) if \\( i \\geq j \\), and into element \\( A_{j, i} \\) if \\( i < j \\).\n\nStarting with element \\( 1 \\), combine it with elements \\( 1, 2, \\ldots, N \\) in this order. Find the final element obtained.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_{i, j} \\leq N \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_{1, 1}\nA_{2, 1} A_{2, 2}\n\\vdots\nA_{N, 1} A_{N, 2} \\ldots A_{N, N}\n```\n\n**Output:**\n\nPrint the number representing the final element obtained.\n\n**Sample Input 1:**\n\n```\n4\n3\n2 4\n3 1 2\n2 1 2 4\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- Combining element 1 with element 1 results in element 3.\n- Combining element 3 with element 2 results in element 1.\n- Combining element 1 with element 3 results in element 3.\n- Combining element 3 with element 4 results in element 2.\n\nTherefore, the value to be printed is 2.\n\n**Sample Input 2:**\n\n```\n5\n5\n5 5\n5 5 5\n5 5 5 5\n5 5 5 5 5\n```\n\n**Sample Output 2:**\n\n```\n5\n```\n\n**Sample Input 3:**\n\n```\n6\n2\n1 5\n1 6 3\n2 6 1 4\n2 1 1 1 6\n5 6 1 2 2 5\n```\n\n**Sample Output 3:**\n\n```\n5\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\n**B - Binary Alchemy Editorial**\n\nSimulate the process of successively synthesizing elements \\(1, 2, \\ldots, N\\) into element \\(1\\) while managing the current index of the element.\n\n```python\ndef main():\n    n = int(input())\n    a = [list(map(lambda x: int(x) - 1, input().split())) + [0] * (n - i - 1) for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if ans >= i:\n            ans = a[ans][i]\n        else:\n            ans = a[i][ans]\n    ans += 1\n    print(ans)\n\nmain()\n```\n\n---\n \n\n", "problem_ids": ["abc370_b"]}, "abc321_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi is growing a plant. The height of the plant at the time of germination is \\(0\\,\\mathrm{cm}\\). Each night from the day of germination, considered as day \\(0\\), the height of the plant increases by \\(2^i\\,\\mathrm{cm}\\) on day \\(i\\) (\\(0 \\le i\\)).\n\nTakahashi has a height of \\(H\\,\\mathrm{cm}\\).\n\nEvery morning, Takahashi measures his height against the plant. Find the first day such that the plant's height is strictly greater than Takahashi's height in the morning.\n\n### Constraints\n- \\(1 \\leq H \\leq 10^{9}\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nH\n```\n\n### Output\nPrint an integer representing the first day such that the plant's height is greater than Takahashi's height in the morning.\n\n### Sample Input 1\n```\n54\n```\n\n### Sample Output 1\n```\n6\n```\n**Explanation:** The plant's height in the mornings of days \\(1, 2, 3, 4, 5, 6\\) will be \\(1\\,\\mathrm{cm}, 3\\,\\mathrm{cm}, 7\\,\\mathrm{cm}, 15\\,\\mathrm{cm}, 31\\,\\mathrm{cm}, 63\\,\\mathrm{cm}\\), respectively. The plant becomes taller than Takahashi in the morning of day \\(6\\), so print \\(6\\).\n\n### Sample Input 2\n```\n7\n```\n\n### Sample Output 2\n```\n4\n```\n**Explanation:** The plant's height will be \\(7\\,\\mathrm{cm}\\) in the morning of day \\(3\\) and \\(15\\,\\mathrm{cm}\\) in the morning of day \\(4\\). The plant becomes taller than Takahashi in the morning of day \\(4\\), so print \\(4\\). Note that, in the morning of day \\(3\\), the plant is as tall as Takahashi, but not taller.\n\n### Sample Input 3\n```\n262144\n```\n\n### Sample Output 3\n```\n19\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\n## A - Exponential Plant Editorial\n\nUse a while statement to repeatedly add the delta to the height of the plant until it exceeds Takahashi\u2019s height. This simulation will allow you to solve this problem. Also, the height at day \\(30\\) is \\(1073741823\\, \\mathrm{cm}(> 10^{9}\\, \\mathrm{cm})\\), so just using a while statement to find the daily height is fast enough.\n\n**Sample code (Python):**\n```python\nh=int(input())\nnow=0\nans=0\nwhile now<=h:\n    now+=1<<ans\n    ans+=1\n\nprint(ans)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc354_a"]}, "abc321_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe Country of AtCoder consists of \\( N \\) cities and \\( M \\) roads connecting them. One can travel between any two cities by traversing some roads. The cities are numbered from 1 to \\( N \\), and the roads are numbered from 1 to \\( M \\). Road \\( i \\) connects cities \\( A_i \\) and \\( B_i \\) bidirectionally.\n\nDue to increasing traffic in the country, there is a plan to expand some roads. Currently, no roads have been expanded, and the cost to expand road \\( i \\) is \\( C_i \\).\n\nSince it is difficult to expand all roads at once, the plan is to first designate \\( K \\) out of the \\( N \\) cities as **major cities** and perform the minimum necessary expansion work, so that one can travel between any two major cities using only expanded roads. It has already been decided that cities \\( 1, 2, \\ldots, K-1 \\) will be major cities, but the last major city has not yet been decided.\n\nFor each \\( i = K, K+1, \\ldots, N \\), answer the following question: If city \\( i \\) is designated as the last major city, what is the minimum total cost of the expansion work required to ensure that one can travel between any two major cities using only expanded roads?\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 4000 \\)\n- \\( N-1 \\leq M \\leq 8000 \\)\n- \\( 2 \\leq K \\leq \\min(N, 10) \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq 10^9 \\)\n- One can travel between any two cities by traversing some roads.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n**Output**\n\nPrint \\( N-K+1 \\) lines. The \\( l \\)-th line \\( (1 \\leq l \\leq N-K+1) \\) should contain the answer to the question for \\( i = l+K-1 \\), as an integer.\n\n**Sample Input 1**\n```\n4 5 3\n1 4 3\n3 4 4\n1 2 4\n2 3 2\n1 3 1\n```\n\n**Sample Output 1**\n```\n3\n6\n```\n\nIn the above figure, circles with numbers represent cities with those numbers, and lines with numbers represent roads with the cost of expansion being that number. The left and right figures correspond to the cases \\( i=3 \\) and \\( i=4 \\), respectively. The colored circles represent the major cities, and the colored thick lines represent the roads that are expanded in an optimal solution. For \\( i=3 \\), expanding roads 4 and 5 results in a total cost of \\( 2+1=3 \\), which is the minimum. For \\( i=4 \\), expanding roads 1, 4, and 5 results in a total cost of \\( 3+2+1=6 \\), which is the minimum.\n\n**Sample Input 2**\n```\n4 3 2\n2 4 28\n1 4 56\n1 3 82\n```\n\n**Sample Output 2**\n```\n84\n82\n56\n```\n\n**Sample Input 3**\n```\n6 12 4\n2 6 68\n2 5 93\n4 6 28\n2 4 89\n3 6 31\n1 3 10\n1 2 53\n3 5 1\n3 5 74\n3 4 22\n4 5 80\n3 4 35\n```\n\n**Sample Output 3**\n```\n85\n64\n94\n```\n\nThere may be multiple roads connecting the same pair of cities.\n\nSolution:\n\nHere is the editorial with the C++ code translated to Python3:\n\n```\nJapan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nOfficial\n\nG - Last Major City Editorial\n\nThis problem is an extension of the minimum Steiner tree problem. We referred to an editorial slide by Yoichi Iwata. A city, road, and cost are simply a vertex, edge, and weight. In an optimal solution, the graph defined by the set of edges to be extended as well as their adjacent vertices forms a tree. For a subset of the vertex set \\(\\{1,2,\\dots,K-1\\}\\) and vertex \\(v\\), \\(f(S,v)\\) is the minimum total weight of the edges of a tree containing vertex \\(v\\) and all vertices in \\(S\\). We seek \\(f(\\{1,2,\\dots,K-1\\}, v)\\) for each \\(K\\leq v\\leq N\\).\n\nThe function \\(f(S,v)\\) can be calculated with Dynamic Programming (DP), using initial values \\(f(\\{i\\}, i)=0\\ (1 \\leq i \\leq K-1)\\). There are two transitions: \n\n1. \\(f(S,v) \\leftarrow \\min(f(S,v),f(S,u) + w)\\) if an edge of weight \\(w\\) connects vertices \\(u\\) and \\(v\\).\n2. \\(f(S,v) \\leftarrow \\min(f(S,v),f(T,v)+f(S\\setminus T,v))\\ (T\\subsetneq S, T\\neq \\emptyset)\\).\n\nThe transitions ensure efficient processing by filling the DP table in ascending order of the size of \\(S\\). The circular dependency in the former transition is managed by determining \\(f(S,v)\\) in ascending order of its value using Dijkstra\u2019s algorithm. The overall complexity is \\(O(3^KN+2^KM\\log M)\\).\n\nSample code (Python3):\n\n```python\nimport sys\nimport heapq\n\ndef chmin(a, b):\n    return b < a\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2]) - 1\n    \n    G = [[] for _ in range(n)]\n\n    index = 3\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        index += 3\n        G[a].append((b, c))\n        G[b].append((a, c))\n\n    dp = [[float('inf')] * n for _ in range(1 << k)]\n    for i in range(k):\n        dp[1 << i][i] = 0\n\n    for bit in range(1, 1 << k):\n        sub = bit\n        while sub > 0:\n            for i in range(n):\n                dp[bit][i] = min(dp[bit][i], dp[sub][i] + dp[bit - sub][i])\n            sub = (sub - 1) & bit\n\n        pq = [(dp[bit][i], i) for i in range(n)]\n        heapq.heapify(pq)\n\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dp[bit][u]:\n                continue\n            for v, l in G[u]:\n                if chmin(dp[bit][v], d + l):\n                    dp[bit][v] = d + l\n                    heapq.heappush(pq, (d + l, v))\n\n    for i in range(k, n):\n        print(dp[-1][i])\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc364_g"]}, "abc321_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\( N \\) strings. Each \\( i \\)-th string \\( S_i \\) (\\(1 \\leq i \\leq N\\)) is either \"Takahashi\" or \"Aoki\". Determine how many times \\( S_i \\) is equal to \"Takahashi\".\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( N \\) is an integer.\n- Each \\( S_i \\) is \"Takahashi\" or \"Aoki\". (\\(1 \\leq i \\leq N\\))\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nS_1\nS_2\n\u22ee\nS_N\n```\n\n**Output**\n\nPrint the count of \\( i \\) such that \\( S_i \\) is equal to \"Takahashi\" as an integer in a single line.\n\n**Sample Input 1**\n```\n3\nAoki\nTakahashi\nTakahashi\n```\n\n**Sample Output 1**\n```\n2\n```\n*S_2* and *S_3* are equal to \"Takahashi\", while *S_1* is not. Therefore, print 2.\n\n**Sample Input 2**\n```\n2\nAoki\nAoki\n```\n\n**Sample Output 2**\n```\n0\n```\nIt is possible that no \\( S_i \\) is equal to \"Takahashi\".\n\n**Sample Input 3**\n```\n20\nAoki\nTakahashi\nTakahashi\nAoki\nAoki\nAoki\nAoki\nTakahashi\nAoki\nAoki\nAoki\nTakahashi\nTakahashi\nAoki\nTakahashi\nAoki\nAoki\nAoki\nAoki\nTakahashi\n```\n\n**Sample Output 3**\n```\n7\n```\n\nSolution:\n\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nA - Count Takahashi Editorial\n\n1. A naive solution  \nDefine an integer variable `ans` for the integer, initializing it with `0`.  \nReceive `N` from the standard input.  \nRepeat the following operation `N` times:  \n\n- Receive a string from the standard input.  \n- If the received string equals \"Takahashi\", add `1` to `ans`.  \n\nPrint the value `ans`.  \n\nSample code in Python:\n```python\nans = 0\nN = int(input())\nfor _ in range(N):\n    S = input()\n    if S == 'Takahashi':\n        ans += 1\nprint(ans)\n```\n\n2. A little tricky solution  \nThe answer to this problem equals the number of occurrences of 'T' in the input.  \n\nSample code in Python:\n```python\nprint(open(0).read().count('T'))\n```\n\nSample code in Python (translated from Haskell):\n```python\nprint(len(list(filter(lambda x: x == 'T', open(0).read()))))\n```\n\nSample code in Bash translated to Python:\n```python\nimport sys\nprint(sum(1 for line in sys.stdin if 'T' in line))\n```\n \n\n", "problem_ids": ["abc359_a"]}, "abc322_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). For each \\( t = 1, 2, \\dots, N \\), determine whether \\( A_t \\) is included in a longest increasing subsequence of \\( A \\).\n\nHere, \\( A_t \\) is included in a longest increasing subsequence of \\( A \\) if and only if the following holds:\n- Let \\( L \\) be the length of a longest increasing subsequence of \\( A \\). There exists a strictly increasing integer sequence \\( i = (i_1, i_2, \\dots, i_L) \\ (i_1 < i_2 < \\dots < i_L) \\), where each element is between \\( 1 \\) and \\( N \\), inclusive, that satisfies all of the following conditions:\n  - \\( A_{i_1} < A_{i_2} < \\dots < A_{i_L} \\).\n  - \\( i_k = t \\) for some \\( k \\ (1 \\leq k \\leq L) \\).\n\nYou are given \\( T \\) test cases; solve each of them.\n\n**What is a longest increasing subsequence?**\n- A subsequence of a sequence \\( A \\) is a sequence that can be derived by extracting some elements from \\( A \\) without changing the order.\n- A longest increasing subsequence of a sequence \\( A \\) is a subsequence of \\( A \\) that is strictly increasing with the greatest possible length.\n\n**Constraints**\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) across all test cases is at most \\( 2 \\times 10^5 \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\nHere, \\(\\mathrm{case}_i\\) represents the input for the \\(i\\)-th case. Each case is given in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\nPrint the answers in the following format:\n```\n\\mathrm{answer}_1\n\\mathrm{answer}_2\n\\vdots\n\\mathrm{answer}_T\n```\nHere, \\(\\mathrm{answer}_i\\) represents the output for the \\(i\\)-th case. For each case, let there be \\( m \\) indices \\( t \\) such that \\( A_t \\) is included in a longest increasing subsequence of \\( A \\), which are \\( i_1, i_2, \\dots, i_m \\) in ascending order. Print these in the following format:\n```\nm\ni_1 i_2 \\cdots i_m\n```\n\n**Sample Input 1**\n```\n1\n5\n2 1 4 5 3\n```\n\n**Sample Output 1**\n```\n4\n1 2 3 4\n```\nOne of the longest increasing subsequences is \\( (2, 4, 5) \\), with a length of 3. Another longest increasing subsequence is \\( (1, 4, 5) \\). However, no longest increasing subsequence includes \\( A_5 \\). Therefore, print \\( 1, 2, 3, 4 \\).\n\n**Sample Input 2**\n```\n2\n6\n2 5 3 4 3 4\n5\n10000 1000 100 1 10\n```\n\n**Sample Output 2**\n```\n5\n1 3 4 5 6\n2\n4 5\n```\n\nSolution:\n\n```\nEditorial - Useless for LIS\n\nGiven a sequence \\( A \\), its Longest Increasing Sequence (LIS) can be found as follows: Apply coordinate compression to assume \\( 1 \\leq A_i \\leq N \\). Use Dynamic Programming (DP) with `dp[i][j]` representing the length of a LIS chosen from the first \\( i \\) elements with the last element \\( j \\). Initialize `dp[0][0] = 0` and `dp[0][1] = dp[0][2] = ... = dp[0][N] = -float('inf')`. The transitions for \\( i = 1, 2, ..., N \\) are:\n\n1. `dp[i][j] = max(dp[i - 1][k] + 1 for k in range(j))` for `j = A[i]`.\n2. `dp[i][j] = dp[i - 1][j]` for `j != A[i]`.\n\nThe length of a LIS is `max(dp[N][k] for k in range(N + 1))`. It is possible to reconstruct a LIS. The complexity can be reduced to \\(O(N \\log N)\\) using a segment tree.\n\nThe DP can be efficiently implemented using pseudocode and a segment tree for segment-max retrieval, which allows LIS length to be obtained in \\(O(N \\log N)\\). Furthermore, by considering constrained LIS lengths `l_i` and `r_i`, and checking if `l_i + r_i - 1 = L`, where `L` is the LIS length, we can address this problem. `l` is found by memorizing DP results, and `r` by reversing the array and applying the same algorithm.\n```\n \n\n", "problem_ids": ["abc354_f"]}, "abc322_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nCertainly! Here is a cleaned and structured version of the problem statement:\n\n---\n\n**Score**: 250 points\n\n### Problem Statement\n\nThere are \\( N \\) dishes, and the \\( i \\)-th dish has a **sweetness** of \\( A_i \\) and a **saltiness** of \\( B_i \\).\n\nTakahashi plans to arrange these \\( N \\) dishes in any order he likes and eat them in that order. He will stop eating as soon as the total sweetness of the dishes he has eaten exceeds \\( X \\) or the total saltiness exceeds \\( Y \\).\n\nFind the minimum possible number of dishes that he will end up eating.\n\n### Constraints\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq X, Y \\leq 2 \\times 10^{14} \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN X Y\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n\n```\n4 7 18\n2 3 5 1\n8 8 1 4\n```\n\n### Sample Output 1\n\n```\n2\n```\n\n**Explanation**\n\nThe \\( i \\)-th dish will be denoted as dish \\( i \\). If he arranges the four dishes in the order \\( 2, 3, 1, 4 \\), as soon as he eats dishes \\( 2 \\) and \\( 3 \\), their total sweetness is 8, which is greater than 7. Therefore, in this case, he will end up eating two dishes. The number of dishes he will eat cannot be 1 or less, so print 2.\n\n### Sample Input 2\n\n```\n5 200000000000000 200000000000000\n1 1 1 1 1\n2 2 2 2 2\n```\n\n### Sample Output 2\n\n```\n5\n```\n\n### Sample Input 3\n\n```\n8 30 30\n1 2 3 4 5 6 7 8\n8 7 6 5 4 3 2 1\n```\n\n### Sample Output 3\n\n```\n6\n```\n\n--- \n\nThis is a structured and detailed explanation capturing the essence and rules of the problem.\n\nSolution:\n\nHere is a clean version of the provided editorial:\n\n**C - Minimum Glutton Editorial**\n\nConsider the following Problem A and Problem B:\n- **Problem A**: Arrange the \\(N\\) dishes and eat them in order until the total sweetness exceeds \\(X\\). What is the minimum number of dishes eaten?\n- **Problem B**: Arrange the \\(N\\) dishes and eat them in order until the total saltiness exceeds \\(Y\\). What is the minimum number of dishes eaten?\n\nFor a fixed arrangement, once the stopping condition in Problem A or Problem B is satisfied, the original problem's condition is satisfied. Thus, the answer to the original problem equals the minimum of the answers to Problems A and B. Sort the dishes in descending order of \\(A_i\\) and \\(B_i\\), respectively, and eat them from the first in order to achieve the minimum value.\n\n**Sample code:**\n```python\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort(reverse=True)\nb.sort(reverse=True)\n\nc1 = 0\nc2 = 0\nsx = 0\nsy = 0\n\nfor ai in a:\n    sx += ai\n    c1 += 1\n    if sx > x:\n        break\n\nfor bi in b:\n    sy += bi\n    c2 += 1\n    if sy > y:\n        break\n\nprint(min(c1, c2))\n```\n \n\n", "problem_ids": ["abc364_c"]}, "abc322_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices. The vertices are numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge (\\( 1 \\leq i \\leq N-1 \\)) connects vertices \\( U_i \\) and \\( V_i \\), with a length of \\( L_i \\).\n\nFor each \\( K = 1, 2, \\ldots, N \\), solve the following problem.\n\nTakahashi and Aoki play a game. The game proceeds as follows:\n\n1. First, Aoki specifies \\( K \\) distinct vertices on the tree.\n2. Then, Takahashi constructs a walk that starts and ends at vertex 1, and passes through all the vertices specified by Aoki.\n\nThe score is defined as the length of the walk constructed by Takahashi. Takahashi wants to minimize the score, while Aoki wants to maximize it. Find the score when both players play optimally.\n\n**Definition of a walk:**\nA walk on an undirected graph (possibly a tree) is a sequence of \\( k \\) vertices and \\( k-1 \\) edges \\( v_1, e_1, v_2, \\ldots, v_{k-1}, e_{k-1}, v_k \\) (where \\( k \\) is a positive integer) such that edge \\( e_i \\) connects vertices \\( v_i \\) and \\( v_{i+1} \\). The same vertex or edge can appear multiple times in the sequence. A walk is said to pass through vertex \\( x \\) if there exists at least one \\( i \\) (\\( 1 \\leq i \\leq k \\)) such that \\( v_i = x \\). (There can be multiple such \\( i \\).) The walk is said to start and end at \\( v_1 \\) and \\( v_k \\), respectively, and the length of the walk is the sum of the lengths of \\( e_1, e_2, \\ldots, e_{k-1} \\).\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq U_i < V_i \\leq N \\)\n- \\( 1 \\leq L_i \\leq 10^9 \\)\n- All input values are integers.\n- The given graph is a tree.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nU_1 V_1 L_1\nU_2 V_2 L_2\n...\nU_{N-1} V_{N-1} L_{N-1}\n```\n\n**Output:**\nPrint \\( N \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq N \\)) should contain the answer to the problem for \\( K = i \\).\n\n**Sample Input 1:**\n```\n5\n1 2 3\n2 3 5\n2 4 2\n1 5 3\n```\n\n**Sample Output 1:**\n```\n16\n22\n26\n26\n26\n```\n\nFor \\( K=1 \\), Aoki's optimal move is to specify vertex 3, and Takahashi's optimal move is to construct a path vertex 1 \u2192 vertex 2 \u2192 vertex 3 \u2192 vertex 2 \u2192 vertex 1, resulting in a score of 16.\n\nFor \\( K=2 \\), Aoki's optimal move is to specify vertices 3 and 5, and Takahashi's optimal move is to construct a path such as vertex 1 \u2192 vertex 5 \u2192 vertex 1 \u2192 vertex 2 \u2192 vertex 3 \u2192 vertex 2 \u2192 vertex 1, resulting in a score of 22.\n\nFor \\( K \\geq 3 \\), the score when both players play optimally is 26.\n\n**Sample Input 2:**\n```\n3\n1 2 1000000000\n2 3 1000000000\n```\n\n**Sample Output 2:**\n```\n4000000000\n4000000000\n4000000000\n```\n\nBeware that the answer may not fit in a 32-bit integer.\n\nSolution:\n\n---\n\nWe will regard the given tree as a rooted tree rooted at \\(1\\). We first consider Takahashi\u2019s strategy. For any edge on the tree, when the tree is split into two parts by the edge, if Aoki has chosen at least one vertex in the part not containing vertex \\(1\\), then Takahashi has to construct a walk that passes through that edge at least twice (back and forth). Conversely, he can construct the shortest such walk, which passes through such edges exactly twice but not the others. It can be constructed as, for example, an Euler tour on the tree obtained by removing unnecessary edges. Based on this fact, we will try to solve the problem with tree DP (Dynamic Programming).\n\nFor each subtree \\(T_v\\) rooted at vertex \\(v\\), let us try to find \\((S_v(1), S_v(2), \\ldots, S_v(T_v))\\), defined as the minimum scores for \\(K=1,2,\\ldots,|T_v|\\) when they play optimally on \\(T_v\\). Here, \\(|T_v|\\) denotes the number of vertices in \\(T_v\\).\n\nIf \\(T_u\\) consist of a single vertex, then \\(|T_u|=1\\) and \\(S_u(1)=0\\). Suppose that vertex \\(u\\) has \\(v_1,v_2,\\ldots,v_c\\) as its direct children, with the lengths of the edge between \\(u\\) and them being \\(d_1,d_2,\\ldots,d_c\\), respectively, and the scores are already known for \\(T_{v_i}\\) \\((1\\leq i\\leq c)\\). Then, noticing it is useless to choose \\(u\\) if \\(K<|T_u|\\), the scores \\(S(u,K)\\) \\((1\\leq K < |T_u|)\\) satisfy:\n\n\\[\nS(u,K)=\\max_{x_1+x_2+x_c=K}\\sum_{i=1}^c\n\\begin{cases}\n0 & (x_i=0) \\\\\n2d_i+S(v_i,x_i) & (1\\leq x_i\\leq |T_i|),\n\\end{cases}\n\\]\n\nwhere each \\(x_i\\) ranges over \\(0\\leq x_i\\leq |T_i|\\). Finally, \\(S(u,|T_u|)=S(u,|T_u|-1)\\).\n\nSince \\(S(v,x)\\leq S(v,x+1)\\) for any \\(v\\), this can be interpreted as the maximum sum of a total of \\(K\\) elements chosen from the leading elements of \\(c\\) sequences \\((2d_i+S(v_i,1),S(v_i,2)-S(v_i,1),\\ldots, S(v_i,|T_i|)-S(v_i,|T_i|-1) )\\). Moreover, assume that they satisfy \\(S(v_i,1)\\geq S(v_i,2)-S(v_i,1)\\) and \\(S(v_i,x)-S(v_i,x-1)\\geq S(v_i,x+1)-S(v_i,x)\\).\n\nIf we define a multiset \\(\\mathcal{S}\\) as:\n\n\\[\n\\mathcal{S}_u= \\left[\\bigcup_{i=1}^c \\{2d_i+S(v_i,1),S(v_i,2)-S(v_i,1),\\ldots, S(v_i,|T_i|)-S(v_i,|T_i|-1) \\}\\right]\\cup\\{0\\},\n\\]\n\nthen the elements sorted in descending order, \\((z_1,z_2,\\ldots,z_{|T_u|})\\), coincide with \\((S(u,1),S(u,2)-S(u,1),\\ldots, S(u,|T_u|)-S(u,|T_u|-1))\\). Then, we have \\(S(u,1)\\geq S(u,2)-S(u,1)\\) and \\(S(u,x)-S(u,x-1)\\geq S(u,x+1)-S(u,x)\\) for \\(u\\) too. Since it automatically holds for \\(|T_u|=1\\), this property inductively holds always, and thus can be computed like this.\n\nBased on this fact, we can compute it as follows: When processing a non-leaf vertex, compute \\(2d_i+S(v_i,1)\\) \\((1\\leq i\\leq c)\\) and store the maximum among them to \\(S(u,1)\\), and store the other \\((c-1)\\) values and one \\(0\\) into a multiset \\(\\mathcal{S}\\). \\(S(1,1)\\) is the last value stored, and \\(S(1,K)\\) is \\(S(1,1)\\) plus the sum of the largest \\((K-1)\\) elements of \\(\\mathcal{S}\\). The complexity is \\(O(N)\\), which is fast enough. Thus, the problem has been solved.\n \n\n", "problem_ids": ["abc369_g"]}, "abc322_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi's cake has been eaten by someone. There are three suspects: person 1, person 2, and person 3.\n\nThere are two witnesses, Ringo and Snuke. Ringo remembers that person A is not the culprit, and Snuke remembers that person B is not the culprit.\n\nDetermine if the culprit can be uniquely identified based on the memories of the two witnesses. If the culprit can be identified, print the person's number.\n\n**Constraints**\n\n- 1 \u2264 A, B \u2264 3\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nA B\n```\n\n**Output**\n\nIf the culprit can be uniquely identified based on the memories of the two witnesses, print the person's number; otherwise, print `-1`.\n\n**Sample Input 1**\n\n```\n1 2\n```\n\n**Sample Output 1**\n\n```\n3\n```\n\nFrom the memories of the two witnesses, it can be determined that person 3 is the culprit.\n\n**Sample Input 2**\n\n```\n1 1\n```\n\n**Sample Output 2**\n\n```\n-1\n```\n\nFrom the memories of the two witnesses, it cannot be determined whether person 2 or person 3 is the culprit. Therefore, print `-1`.\n\n**Sample Input 3**\n\n```\n3 1\n```\n\n**Sample Output 3**\n\n```\n2\n```\n\nSolution:\n\n        \n        [BEGIN TEXT]\n        Here is the cleaned version of the relevant solution: \n\nIf \\(A=B\\), the answer is -1. If \\(A\\neq B\\), print the one of \\(1,2,3\\) that is not \\(A\\) nor \\(B\\). There are six possible conditions when \\(A\\neq B\\):\n\n```python\nA, B = map(int, input().split())\nif A == B:\n    print(-1)\nelif A == 1 and B == 2 or A == 2 and B == 1:\n    print(3)\nelif A == 1 and B == 3 or A == 3 and B == 1:\n    print(2)\nelif A == 2 and B == 3 or A == 3 and B == 2:\n    print(1)\n```\n\nAlternatively, use properties of \\(A, B, C\\):\n\n\\(C=6-A-B\\)\n\n```python\nA, B = map(int, input().split())\nif A == B:\n    print(-1)\nelse:\n    print(6 - A - B)\n```\n\n\\(C=A\\oplus B\\) (\\(\\oplus\\) is XOR):\n\n```python\nA, B = map(int, input().split())\nif A == B:\n    print(-1)\nelse:\n    print(A ^ B)\n```\n\nOr use a set to reduce conditional branches:\n\n```python\nA, B = map(int, input().split())\nS = set([1, 2, 3])\nS.discard(A)\nS.discard(B)\n\nif len(S) == 1:\n    print(S.pop())\nelse:\n    print(-1)\n```\n        [END TEXT]\n        \n \n\n", "problem_ids": ["abc355_a"]}, "abc322_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi has a piano with 100 keys arranged in a row. The i-th key from the left is called key i.\n\nHe will play music by pressing N keys one by one. For the i-th press, he will press key \\( A_i \\), using his left hand if \\( S_i = L \\), and his right hand if \\( S_i = R \\).\n\nBefore starting to play, he can place both of his hands on any keys he likes, and his fatigue level at this point is 0. During the performance, if he moves one hand from key x to key y, the fatigue level increases by \\(|y-x|\\) (the fatigue level does not increase for any reason other than moving hands). To press a certain key with a hand, that hand must be placed on that key.\n\nFind the minimum possible fatigue level at the end of the performance.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq 100 \\)\n- \\( N \\) and \\( A_i \\) are integers.\n- \\( S_i \\) is 'L' or 'R'.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 S_1\nA_2 S_2\n...\nA_N S_N\n```\n\n**Output**\n\nPrint the minimum fatigue level at the end of the performance.\n\n**Sample Input 1**\n```\n4\n3 L\n6 R\n9 L\n1 R\n```\n\n**Sample Output 1**\n```\n11\n```\n\nFor example, the performance can be done as follows:\n- Initially, place the left hand on key 3 and the right hand on key 6.\n- Press key 3 with the left hand.\n- Press key 6 with the right hand.\n- Move the left hand from key 3 to key 9. The fatigue level increases by \\(|9-3| = 6\\).\n- Move the right hand from key 6 to key 1. The fatigue level increases by \\(|1-6| = 5\\).\n- Press key 9 with the left hand.\n- Press key 1 with the right hand.\n\nIn this case, the fatigue level at the end of the performance is \\(6 + 5 = 11\\), which is the minimum possible.\n\n**Sample Input 2**\n```\n3\n2 L\n2 L\n100 L\n```\n\n**Sample Output 2**\n```\n98\n```\n\n**Sample Input 3**\n```\n8\n22 L\n75 L\n26 R\n45 R\n72 R\n81 R\n47 L\n29 R\n```\n\n**Sample Output 3**\n```\n188\n```\n\nSolution:\n\n```\nEditorial - B - Piano 3\n\nManage the positions of left and right hands while inspecting the key to press for \\(1,2,\\dots,N\\)-th press, and add the fatigue level of each move required. In the sample code, an array \\(\\text{pos}\\) of length two is prepared, with \\(pos[0]\\) and \\(pos[1]\\) managing the current positions of left and right hands, respectively. Initial positions are set to \\(-1\\), and no fatigue is added when moving a hand from \\(-1\\) to another key. This simulates placing a hand at the first key to be pressed by that hand.\n\nSample code (Python):\n```python\nn = int(input())\npos = [-1, -1]   # 0: left, 1: right\nans = 0\nfor i in range(n):\n    a, s = input().split()\n    a = int(a)\n    hand = (0 if s == 'L' else 1)\n    if pos[hand] != -1:\n        ans += abs(pos[hand] - a)\n    pos[hand] = a\nprint(ans)\n```\n```\n \n\n", "problem_ids": ["abc369_b"]}, "abc323_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nAlice and Bob are playing a game with two positive integers \\( N \\) and \\( M \\), where \\( N < M \\). Each player has \\( N \\) cards numbered from 1 to \\( N \\). Alice starts the game, and they take turns playing one card from their hand onto the table. If, after a player plays a card, the sum of the numbers on the table is divisible by \\( M \\), the player who played the last card loses, and the other player wins. If all cards are played and the sum is never divisible by \\( M \\), Alice wins. Given \\( T \\) test cases, determine who will win (Alice or Bob) if both play optimally.\n\nConstraints:\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 1 \\leq N < M \\leq 10^9 \\)\n\nInput:\n- The input consists of \\( T \\) test cases.\n- Each test case is described by two integers \\( N \\) and \\( M \\).\n\nOutput:\n- For each test case, output \"Alice\" if Alice wins or \"Bob\" if Bob wins when both players play optimally.\n\nSample Input:\n```\n8\n2 3\n3 6\n5 9\n45 58\n39 94\n36 54\n74 80\n61 95\n```\n\nSample Output:\n```\nAlice\nAlice\nBob\nBob\nAlice\nBob\nBob\nAlice\n```\n\nIn the first test case, both Alice and Bob have two cards: a 1 and a 2. Alice plays 1, and the sum is 1, which is not divisible by 3. Bob plays 1, making the sum 2, still not divisible by 3. Alice plays 2, making the sum 4, not divisible by 3. Bob plays 2, making the sum 6, which is divisible by 3, so Bob loses, and Alice wins. Alice wins regardless of Bob's strategy.\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 185\n\ndef mod_m_game(N, M):\n    # Calculate c\n    c = (N * (N + 1)) % M\n\n    # Determine if Alice loses or wins\n    if 1 <= c <= N:\n        return \"Bob wins\"\n    else:\n        return \"Alice wins\"\n\n# Example Usage\nN = 5\nM = 3\nresult = mod_m_game(N, M)\nprint(result)  # Output should be \"Bob wins\" or \"Alice wins\" based on the conditions\n```\n\nEditorial - AtCoder Regular Contest 185\n\nA - mod M Game 2 Editorial by evima\n\nFirst, focus on the moment when Alice plays her last card:\n\n- A player with two or more cards can avoid playing a losing card.\n- If Alice doesn't lose when playing her last card, she will win regardless of Bob's last move.\n\nDetermine if Alice loses with her last card using Bob\u2019s last card \\(b\\). The sum of the numbers on the cards played is \\(N(N+1) - b\\). We check if \\(N(N + 1) - b \\equiv 0 \\pmod{M}\\).\n\n1. If \\(1 \\leq (N(N+1) \\bmod M) \\leq N\\):\n   - Let \\(c = N(N + 1) \\bmod M\\). Bob can make his last card \\(b = c\\) by playing all cards except \\(c\\), leading to Alice's loss. Bob can achieve this by keeping \\(c\\) among his final cards.\n\n2. If \\(N(N + 1) - b\\) cannot be \\(0\\):\n   - Alice will not lose on her last card, leading to her victory.\n\nBob wins if \\(1 \\leq N(N + 1) \\bmod M \\leq N\\), otherwise Alice wins. This can be determined in \\(O(1)\\) time.\n \n\n", "problem_ids": ["arc185_a"]}, "abc323_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 200 points\n\nProblem Statement:\nIn the Kingdom of AtCoder, the eldest son is always given the name Taro. No one else is given the name Taro. The eldest son is the earliest born male child in each family.\n\nThere are \\(N\\) families in the Kingdom, and \\(M\\) babies were born. Before the \\(M\\) babies were born, none of the \\(N\\) families had had any babies.\n\nInformation about the babies is given in chronological order of their birth. The \\(i\\)-th baby born was born in family \\(A_i\\), and the baby is male if \\(B_i\\) is \\(M\\), and female if it is \\(F\\).\n\nDetermine for each of the \\(M\\) babies whether the name given is Taro.\n\nConstraints:\n- \\(1 \\leq N, M \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- \\(B_i\\) is \\(M\\) or \\(F\\).\n- All numbers in the input are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\nOutput:\nPrint \\(M\\) lines. The \\(i\\)-th line \\((1 \\leq i \\leq M)\\) should contain `Yes` if the name given to the \\(i\\)-th baby is Taro, and `No` otherwise.\n\nSample Input 1:\n```\n2 4\n1 M\n1 M\n2 F\n2 M\n```\n\nSample Output 1:\n```\nYes\nNo\nNo\nYes\n```\n\nExplanation of Sample Output 1:\n- The first baby is the earliest born boy in family 1, so he is named Taro.\n- The second baby is not the earliest born boy in family 1, so he is not named Taro.\n- The third baby is a girl, so she is not named Taro.\n- The fourth baby is the earliest born **boy** in family 2, so he is named Taro. Note that the third baby is also born in family 2, but it is the earliest born boy who is named Taro.\n\nSample Input 2:\n```\n4 7\n2 M\n3 M\n1 F\n4 F\n4 F\n1 F\n2 M\n```\n\nSample Output 2:\n```\nYes\nYes\nNo\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Beginner Contest 371\n\nB - Taro Editorial by en_translator\n\nMaintain a flag to manage whether each family had had Taro already. The flags are initialized with False. Inspect the babies in order. If the baby is a girl, print No, and nothing more is required. If the baby is a boy, check the flag of his family. If the flag is False, print Yes, and set the flag to True. If the flag is already True, print No. The operations so far can be implemented with for statements, if statements, and arrays.\n\nSample code (Python):\n```python\nn, m = map(int, input().split())\ntaro_exist = [False for i in range(n)]\nfor i in range(m):\n    a, b = input().split()\n    a = int(a) - 1\n    if b == 'F' or taro_exist[a]:\n        print('No')\n    else:\n        taro_exist[a] = True\n        print('Yes')\n```\n\n[END TEXT]\n \n\n", "problem_ids": ["abc371_b"]}, "abc323_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThe problem statement is as follows:\n\n**Problem Statement:**\n\nThere is a rooted tree with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). The root is vertex \\( 1 \\), and the parent of vertex \\( i \\) (\\( 2 \\leq i \\leq N \\)) is vertex \\( P_i \\) (\\( P_i < i \\)).\n\nThere are also integer sequences of length \\( M \\): \\( A = (A_1, A_2, \\cdots, A_M) \\) and \\( B = (B_1, B_2, \\cdots, B_M) \\), consisting of integers between \\( 1 \\) and \\( N \\), inclusive.\n\nSequence \\( A \\) is said to be **good** if and only if for each \\( i \\), vertex \\( A_i \\) is an ancestor of vertex \\( B_i \\) or \\( A_i = B_i \\). Initially, \\( A \\) is good.\n\nConsider the following operation on \\( A \\):\n\n- Choose an integer \\( i \\) (\\( 1 \\leq i \\leq M-1 \\)) and swap the values of \\( A_i \\) and \\( A_{i+1} \\). Here, \\( A \\) must remain good after the operation.\n\nFind the number, modulo \\( 998244353 \\), of sequences that can result from performing this operation on \\( A \\) zero or more times.\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 250000 \\)\n- \\( 2 \\leq M \\leq 250000 \\)\n- \\( 1 \\leq P_i < i \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq N \\)\n- Vertex \\( A_i \\) is an ancestor of vertex \\( B_i \\) or \\( A_i = B_i \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nP_2 P_3 \\cdots P_N\nA_1 A_2 \\cdots A_M\nB_1 B_2 \\cdots B_M\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n```\n3 3\n1 2\n1 2 1\n1 2 3\n```\n\n**Sample Output 1:**\n```\n2\n```\n\nConsider choosing \\( i = 1 \\). The \\( A = (2, 1, 1) \\) after the operation is not good, so this operation is invalid. Consider choosing \\( i = 2 \\). The \\( A = (1, 1, 2) \\) after the operation is good, so this operation is valid. There are two sequences that can result from performing zero or more operations on \\( A \\): \\( A = (1, 2, 1) \\) and \\( (1, 1, 2) \\).\n\n**Sample Input 2:**\n```\n4 3\n1 1 1\n2 3 4\n2 3 4\n```\n\n**Sample Output 2:**\n```\n1\n```\n\n**Sample Input 3:**\n```\n8 13\n1 2 2 3 4 4 3\n5 3 2 5 4 6 2 8 2 6 7 4 7\n5 5 8 5 6 6 5 8 3 6 7 4 7\n```\n\n**Sample Output 3:**\n```\n8\n```\n\n**Sample Input 4:**\n```\n30 27\n1 2 1 1 5 1 7 1 5 10 1 12 12 13 15 16 12 18 19 18 21 21 23 13 18 18 27 27 13\n1 18 1 5 11 12 1 1 1 12 1 12 1 15 1 1 21 1 12 10 2 8 3 1 1 30 12\n14 27 30 5 11 17 1 18 24 27 29 27 19 15 28 5 21 21 29 11 2 8 3 4 10 30 22\n```\n\n**Sample Output 4:**\n```\n60\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere is the cleaned-up version focusing solely on the solution:\n\nFor each \\(i\\), consider the maximal interval \\([L_i, R_i]\\) that satisfies the conditions: \\(L_i \\leq i \\leq R_i\\), and for each \\(j \\in [L_i, R_i]\\), vertex \\(A_i\\) is an ancestor of vertex \\(B_j\\) (or \\(A_i = B_j\\)). The interval \\([L_i, R_i]\\) represents the range within which \\(A_i\\) can seemingly move. However, some positions within this range may be fixed, meaning \\(A_i\\) actually cannot move there. The set of intervals \\([L_i, R_i]\\) is laminar, forming a tree-like structure without partial overlaps.\n\nWe process in descending order of \\(A_i\\), which equates to ascending order of \\([L_i, R_i]\\) size. Within \\([L_i, R_i]\\), we calculate where \\(A_i\\) can actually move by excluding fixed positions. Suppose there are \\(k\\) intervals in the subtree of \\([L_i, R_i]\\): if \\(R_i - L_i + 1 = k\\), these intervals fill \\([L_i, R_i]\\), fixing those positions. Hence, \\(A_i\\) can move within \\([l, r]\\), excluding fixed positions.\n\nThe actual available positions depend on those not occupied by previously processed values. The count of such positions determines the candidates for placing the current \\(A_i\\). This must be done for all \\(A_i\\), considering duplicate values by dividing by an appropriate factor. \\(L_i\\) and \\(R_i\\) can be found using binary search and interval LCA queries on \\(B\\), processed in \\(O(\\log M + \\log N)\\) time. This leads to a time complexity of \\(O(N + M\\log M(\\log M + \\log N))\\), which can be optimized by handling interval min query and LCA query in \\(O(1)\\) time.\n[END TEXT]\n \n\n", "problem_ids": ["arc183_e"]}, "abc323_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe AtCoder railway line has \\( N \\) stations, numbered \\( 1, 2, \\ldots, N \\).\n\nOn this line, there are **inbound trains** that start at station \\( 1 \\) and stop at the stations \\( 2, 3, \\ldots, N \\) in order, and **outbound trains** that start at station \\( N \\) and stop at the stations \\( N - 1, N - 2, \\ldots, 1 \\) in order.\n\nTakahashi is about to travel from station \\( X \\) to station \\( Y \\) using only one of the inbound and outbound trains.\n\nDetermine whether the train stops at station \\( Z \\) during this travel.\n\n**Constraints**\n- \\( 3 \\leq N \\leq 100 \\)\n- \\( 1 \\leq X, Y, Z \\leq N \\)\n- \\( X \\), \\( Y \\), and \\( Z \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN X Y Z\n```\n\n**Output**\n\nIf the train stops at station \\( Z \\) during the travel from station \\( X \\) to station \\( Y \\), print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n```\n7 6 1 3\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Explanation:* To travel from station 6 to station 1, Takahashi will take an outbound train. After departing from station 6, the train stops at stations 5, 4, 3, 2, 1 in order, which include station 3, so you should print `Yes`.\n\n**Sample Input 2**\n```\n10 3 2 9\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n100 23 67 45\n```\n\n**Sample Output 3**\n```\nYes\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial content: \n\n---\n\nTakahashi takes an inbound train if \\(X < Y\\) and an outbound train if \\(X > Y\\). Takahashi\u2019s train will stop at station \\(Z\\) if and only if \\(X < Z < Y\\) if \\(X < Y\\), and \\(X > Z > Y\\) if \\(X > Y\\).\n\nSample code:\n```python\nn, x, y, z = map(int, input().split())\nif (x < z < y) or (y < z < x):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\n", "problem_ids": ["abc352_a"]}, "abc323_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nFor strings \\( x \\) and \\( y \\), define \\( f(x, y) \\) as follows:  \n\\( f(x, y) \\) is the length of the longest common prefix of \\( x \\) and \\( y \\).\n\nYou are given \\( N \\) strings \\((S_1, S_2, \\ldots, S_N)\\) consisting of lowercase English letters. Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j) \\]\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 3 \\times 10^5 \\)\n- \\( S_i \\) is a string consisting of lowercase English letters.\n- \\( 1 \\leq |S_i| \\) (where \\(|S_i|\\) denotes the length of the string \\( S_i \\))\n- \\( |S_1| + |S_2| + \\ldots + |S_N| \\leq 3 \\times 10^5 \\)\n- All input numbers are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1\nS_2\n...\nS_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\nab\nabc\narc\n```\n\n**Sample Output 1:**\n\n```\n4\n```\n\n**Explanation:**\n\n- \\( f(S_1, S_2) = 2 \\)\n- \\( f(S_1, S_3) = 1 \\)\n- \\( f(S_2, S_3) = 1 \\)\n\nThus, the answer is \\( f(S_1, S_2) + f(S_1, S_3) + f(S_2, S_3) = 4 \\).\n\n**Sample Input 2:**\n\n```\n11\nab\nbb\naaa\nbba\nbaba\nbabb\naaaba\naabbb\na\na\nb\n```\n\n**Sample Output 2:**\n\n```\n32\n```\n\nSolution:\n\n```python\nEditorial - AtCoder Beginner Contest 353\n\nE - Yet Another Sigma Problem Editorial by en_translator\n\nThis problem can be solved with a data structure called Trie. The length of the longest common prefix of \\(S_i\\) and \\(S_j\\) equals the number of common prefixes of \\(S_i\\) and \\(S_j\\). For example, the longest common prefix of \"abc\" and \"abde\" has a length of two, and they have two common prefixes \"a\" and \"ab\". Thus, it is sufficient to enumerate all prefixes \\(T\\) of \\(S_j\\) for all \\(S_j\\), and count the number of \\(S_i\\ (1\\leq i < j)\\) that has \\(T\\) as its suffix. This can be done by inserting \\(S_i\\) in a Trie for each \\(i=1,2,\\ldots,N\\) in order, each of whose node manages the number of strings that has the string represented by the node as a suffix.\n\nSample code (Python 3):\n\n```python\nclass Trie:\n    def __init__(self, len):\n        self.pos = []\n        self.cnt = []\n        self.def_ = [-1] * 26\n        self.now_sz = 0\n        self.ans = 0\n        self.make_node()\n    \n    def make_node(self):\n        self.pos.append(self.def_[:])\n        self.cnt.append(0)\n        self.now_sz += 1\n        return self.now_sz - 1\n    \n    def add(self, s):\n        now = 0\n        for char in s:\n            d = ord(char) - ord('a')\n            nx = self.pos[now][d]\n            if nx == -1:\n                nx = self.make_node()\n                self.pos[now][d] = nx\n            now = nx\n            self.ans += self.cnt[now]\n            self.cnt[now] += 1\n\ndef main():\n    n = int(input())\n    tr = Trie(300000)\n    for _ in range(n):\n        s = input().strip()\n        tr.add(s)\n    print(tr.ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc353_e"]}, "abc324_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nA pair of binary strings \\( (S, T) \\) is called **good** if and only if the following conditions are satisfied:\n\n1. \\( S \\) and \\( T \\) contain the same number of \\( 0 \\)s.\n2. \\( S \\) and \\( T \\) contain the same number of \\( 1 \\)s.\n\nParticularly, for a good string pair \\( (S, T) \\), \\( S \\) and \\( T \\) have the same length.\n\nFor a good string pair \\( (S, T) \\), we define an undirected graph \\( G(S, T) \\) as follows:\n\n- Let \\( L \\) be the length of \\( S \\). Create a graph \\( g \\) with vertices \\( 1, 2, \\cdots, L \\).\n- Let \\( n \\) be the number of \\( 0 \\)s in \\( S \\). Let the indices of \\( 0 \\)s in \\( S \\) be \\( 1 \\leq a_1 < a_2 < \\cdots < a_n \\leq L \\). Let the indices of \\( 0 \\)s in \\( T \\) be \\( 1 \\leq b_1 < b_2 < \\cdots < b_n \\leq L \\). For each \\( 1 \\leq i \\leq n \\), add an edge between vertices \\( a_i \\) and \\( b_i \\) to \\( g \\).\n- Let \\( m \\) be the number of \\( 1 \\)s in \\( S \\). Let the indices of \\( 1 \\)s in \\( S \\) be \\( 1 \\leq c_1 < c_2 < \\cdots < c_m \\leq L \\). Let the indices of \\( 1 \\)s in \\( T \\) be \\( 1 \\leq d_1 < d_2 < \\cdots < d_m \\leq L \\). For each \\( 1 \\leq i \\leq m \\), add an edge between vertices \\( c_i \\) and \\( d_i \\) to \\( g \\).\n\nThe graph \\( g \\) obtained through the above steps is \\( G(S, T) \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\). Find one good string pair \\( (S, T) \\) satisfying all of the following conditions:\n\n- Let \\( L \\) be the length of \\( S \\). It satisfies \\( N \\leq L \\leq 10^5 \\).\n- For each pair \\( 1 \\leq i, j \\leq N \\), vertices \\( i \\) and \\( j \\) belong to the same connected component in \\( G(S, T) \\) if and only if \\( A_i = A_j \\).\n\nIt can be proved that a solution always exists under the constraints of this problem.\n\n### Constraints\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n### Output\nPrint a solution in the following format:\n```\nL\nS\nT\n```\nHere, \\( L \\) is the length of \\( S \\) and \\( T \\).\n\nIf multiple solutions exist, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n1 2 1\n```\n\n### Sample Output 1\n```\n4\n0011\n1100\n```\nFor the \\( S \\) and \\( T \\) in the sample output, we obtain \\( G(S, T) \\) as follows:\n- Prepare a graph \\( g \\) with 4 vertices.\n- The indices of \\( 0 \\)s in \\( S \\) are \\( (1, 2) \\), and the indices of \\( 0 \\)s in \\( T \\) are \\( (3, 4) \\). Add edges \\( (1, 3) \\) and \\( (2, 4) \\) to \\( g \\).\n- The indices of \\( 1 \\)s in \\( S \\) are \\( (3, 4) \\), and the indices of \\( 1 \\)s in \\( T \\) are \\( (1, 2) \\). Add edges \\( (3, 1) \\) and \\( (4, 2) \\) to \\( g \\).\n\n\\( G(S, T) \\) has a connected component with vertices \\( (1, 3) \\) and another with vertices \\( (2, 4) \\). This satisfies all the conditions, so this \\( (S, T) \\) is a valid output.\n\n### Sample Input 2\n```\n5\n1 2 3 4 5\n```\n\n### Sample Output 2\n```\n5\n01010\n01010\n```\n\n### Sample Input 3\n```\n6\n1 1 1 1 1 1\n```\n\n### Sample Output 3\n```\n6\n011111\n111110\n```\n\n### Sample Input 4\n```\n10\n1 2 3 2 4 3 4 4 5 6\n```\n\n### Sample Output 4\n```\n21\n000101010111100011011\n011010000010101111110\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere's the cleaned version of the solution:\n\nFirst, initialize \\(S = 0 \\times N\\) (a string of \\(N\\) 0s), and \\(T = 1 \\times N\\). To satisfy the conditions, perform these operations: \n\n1. Append 0 to the end of \\(S\\), and 0 to the end of \\(T\\).\n2. Append 1 to the end of \\(S\\), and 0 to the end of \\(T\\).\n\nTrack the connected components of unmatched 0s and 1s. Let \\(x_1, x_2, \\cdots, x_k\\) be the components of unmatched 0s in \\(S\\), and \\(y_1, y_2, \\cdots, y_k\\) be for 1s in \\(T\\). Adding 0 to both \\(S\\) and \\(T\\) cyclically shifts \\(x\\) one position left. Adding 1 to \\(S\\) and 0 to \\(T\\) removes \\(x_1\\) and \\(y_1\\) and connects \\(x_1\\) and \\(y_1\\).\n\nTo meet \\(A\\), prepare a permutation \\(P\\) aligning with \\(A\\)'s cycle decomposition and connect \\(x_1\\) and \\(y_1\\) when \\(x_1 = A_{y_1}\\). The operations number is \\(O(N^2)\\).\n[END TEXT]\n \n\n", "problem_ids": ["agc068_b"]}, "abc324_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( A \\). You will perform the following operations:\n\n1. Generate \\( N \\) real numbers uniformly at random between 0 and 1, inclusive. All generations are independent, and the random numbers are uniformly distributed.\n   \n2. Call the generated \\( N \\) real numbers \\( x_1, x_2, \\ldots, x_N \\) in ascending order. That is, \\( 0 \\leq x_1 \\leq x_2 \\leq \\ldots \\leq x_N \\leq 1 \\).\n\n3. Your score is given by the following formula:\n\n   \\[\n   \\prod_{i=1}^{N} \\left(1 + \\sum_{j=i+1}^N x_j^A \\right)\n   \\]\n\nCalculate the expected value, modulo \\( 10^9+7 \\), of the score.\n\n**Definition of expected value modulo \\( 10^9+7 \\)**\n\nIt can be proved that the sought expected value is always rational. Furthermore, under the constraints of this problem, it can be proved that if the expected value is expressed as an irreducible fraction \\(\\frac{P}{Q}\\), then \\( Q \\not\\equiv 0 \\pmod{10^9+7} \\). Therefore, there exists a unique integer \\( R \\) such that \\( R \\times Q \\equiv P \\pmod{10^9+7} \\) and \\( 0 \\leq R < 10^9+7 \\). Report this \\( R \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq A \\leq 5 \\times 10^4 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1\n```\n\n**Sample Output 1**\n\n```\n666666673\n```\n\nThe expected value of the score is \\( \\frac{5}{3} \\).\n\n**Sample Input 2**\n\n```\n1 1\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\n**Sample Input 3**\n\n```\n2 2\n```\n\n**Sample Output 3**\n\n```\n500000005\n```\n\n**Sample Input 4**\n\n```\n3 2\n```\n\n**Sample Output 4**\n\n```\n142857147\n```\n\n**Sample Input 5**\n\n```\n5 3\n```\n\n**Sample Output 5**\n\n```\n758371066\n```\n\n**Sample Input 6**\n\n```\n10000 12345\n```\n\n**Sample Output 6**\n\n```\n32201773\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Let \\(a_n(y)\\) be the expected value for a real number \\(y\\) (\\(0 \\leq y \\leq 1\\)) and a non-negative integer \\(n\\). Generate \\(n\\) real numbers within \\([0,1]\\) as \\(x_1, \\cdots, x_n\\). If \\(x_1 < \\cdots < x_n < y\\) is not satisfied, output \\(0\\). If they are in ascending order, output \\(\\prod_{1 \\leq i \\leq n} (y^A + \\sum_{i < j \\leq n} x_j^A)\\).\n\nDefine \\(f(y,x) = \\sum_{0 \\leq n} a_n(y)x^n\\). \\(a_n(y)\\) is a polynomial in \\(y\\), and \\(f\\) is a formal power series. We aim to find \\(N! [x^N]f(1,x)\\). Consider choosing one term from \\(y^A, x_{i+1}^A, \\cdots x_N^A\\) for each \\(i\\) and calculating their product, forming a tree. We draw arrows based on choices: from \\(i\\) to \\(j\\) for \\(x_j^A\\), and \\(i\\) to * for choosing \\(y^A\\). This setup reveals an equation for \\(f\\), decomposed into subproblems for each subtree. The weight of a subtree rooted at child \\(v\\) is \\(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt\\).\n\nIf * has \\(k\\) children, subtrees are ordered and multiplied by \\(1/k!\\). Thus, \\(f\\) satisfies: \\(f(y,x) = \\exp(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt)\\). \\(a_n(y)\\) is a polynomial and a constant multiple of \\(y^{(A+1)n}\\). Write \\(g(z) = f(x,y)\\) with \\(z = y^{A+1}x\\) using power series \\(g(z) = \\sum_{0 \\leq n} b_n z^n\\). Rewrite \\(f\\) for \\(g\\): \\(g(z) = \\exp(\\sum_{0 \\leq n} \\frac{b_n}{(A+1)n+1} z^{n+1})\\).\n\nLet \\(h(z)\\) be inside \\(\\exp\\). Knowing \\([z^n] g\\) allows calculation of \\([z^{n+1}] h(z)\\) and \\([z^{n+1}] g(z)\\). The coefficients of \\(g\\) can be determined in order. Calculate \\([z^{n+1}] g(z)\\) using \\(\\frac{d}{dz}g = \\frac{d}{dz}\\exp(h) = \\frac{d}{dz}h \\times g\\), achievable in \\(O(n)\\). Solve the problem in \\(O(N^2)\\) time overall.\n        [END TEXT]\n \n\n", "problem_ids": ["arc180_f"]}, "abc324_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a sequence of \\( N \\) positive integers \\( A = (A_1, A_2, \\dots, A_N) \\).\n\nFind the number of pairs of integers \\( (l, r) \\) satisfying \\( 1 \\leq l \\leq r \\leq N \\) such that the subsequence \\( (A_l, A_{l+1}, \\dots, A_r) \\) forms an arithmetic progression.\n\nA sequence \\( (x_1, x_2, \\dots, x_{|x|}) \\) is an arithmetic progression if and only if there exists a \\( d \\) such that \\( x_{i+1} - x_i = d \\) for \\( 1 \\leq i < |x| \\). In particular, a sequence of length \\( 1 \\) is always an arithmetic progression.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n4\n3 6 9 3\n```\n\n**Sample Output 1:**\n\n```\n8\n```\n\nThere are eight pairs of integers \\( (l, r) \\) satisfying the condition: \\( (1,1), (2,2), (3,3), (4,4), (1,2), (2,3), (3,4), (1,3) \\). Indeed, when \\( (l, r) = (1, 3) \\), \\( (A_l, \\dots, A_r) = (3, 6, 9) \\) is an arithmetic progression, so it satisfies the condition. However, when \\( (l, r) = (2, 4) \\), \\( (A_l, \\dots, A_r) = (6, 9, 3) \\) is not an arithmetic progression, so it does not satisfy the condition.\n\n**Sample Input 2:**\n\n```\n5\n1 1 1 1 1\n```\n\n**Sample Output 2:**\n\n```\n15\n```\n\nAll pairs of integers \\( (l, r) \\) satisfying \\( 1 \\leq l \\leq r \\leq 5 \\) satisfy the condition.\n\n**Sample Input 3:**\n\n```\n8\n87 42 64 86 72 58 44 30\n```\n\n**Sample Output 3:**\n\n```\n22\n```\n\nSolution:\n\n```markdown\n[C - Count Arithmetic Subarrays Editorial]\n\nThe condition is always satisfied if \\(l = r\\), so we will add \\(n\\) to the answer finally and consider pairs \\((l, r)\\) such that \\(l < r\\). Let \\(B = (B_1, B_2, \\dots, B_{N-1})\\) be the sequence of differences of \\(A\\); that is, \\(B_i = A_{i+1} - A_i\\). The subarray \\((l, r)\\) satisfies the condition of being an arithmetic progression if and only if \\(B_l = B_{l+1} = \\dots = B_{r-1}\\). Thus, the problem is reduced to finding the number of pairs \\((l, r)\\) such that \\(B_l = B_{l+1} = \\dots = B_r\\).\n\nTo solve this, apply run-length compression to \\(B\\), obtaining a sequence of integer pairs \\((C_1, D_1), (C_2, D_2), \\dots, (C_k, D_k)\\). The sequence \\(B\\) is a concatenation of runs \\(f(i)\\), where each \\(C_i\\) is repeated \\(D_i\\) times. A segment \\([l, r]\\) conforming to the condition is completely contained within a run \\(f(i)\\). The number of such segments in \\(f(i)\\) is \\(\\frac{D_i(D_i+1)}{2}\\). The answer is \\(\\displaystyle \\sum_{i=1}^{k} \\frac{D_i(D_i+1)}{2}\\).\n```\n \n\n", "problem_ids": ["abc369_c"]}, "abc324_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\(N\\) and a prime \\(P\\).\n\nWe call a sequence of \\(N\\) intervals \\(([L_1,R_1],[L_2,R_2], \\ldots, [L_N,R_N])\\) **good** if and only if both of the following conditions are satisfied:\n\n1. \\(1 \\leq L_i \\leq R_i \\leq N\\) holds for all \\(1 \\leq i \\leq N\\).\n2. There exists a **unique** permutation \\(x = (x_1, x_2, \\ldots, x_N)\\) of \\((1, 2, \\ldots, N)\\) such that \\(L_i \\leq x_i \\leq R_i\\) holds for all \\(1 \\leq i \\leq N\\).\n\nCount the number of **good** sequences of intervals, modulo \\(P\\).\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 5000\\)\n- \\(10^9 < P < 1.01 \\times 10^9\\)\n- \\(P\\) is a prime number.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1005488041\n```\n\n**Sample Output 1**\n\n```\n6\n```\n\nThe following 6 sequences are good:\n1. \\(([1,1],[2,2])\\)\n2. \\(([1,2],[2,2])\\)\n3. \\(([1,1],[1,2])\\)\n4. \\(([2,2],[1,1])\\)\n5. \\(([2,2],[1,2])\\)\n6. \\(([1,2],[1,1])\\)\n\n**Sample Input 2**\n\n```\n5 1005488041\n```\n\n**Sample Output 2**\n\n```\n102960\n```\n\n**Sample Input 3**\n\n```\n100 1005488041\n```\n\n**Sample Output 3**\n\n```\n47599495\n```\n\n**Sample Input 4**\n\n```\n1000 1005488041\n```\n\n**Sample Output 4**\n\n```\n632708165\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - AtCoder Grand Contest 067\n\nD - Unique Matching Editorial by Kubic\n\nObviously, the intervals \\([l_i,r_i]\\) are distinct. So we can just let \\(x_i=i\\) and finally multiply the answer by \\(n!\\). Consider the uniqueness of bipartite graph matching. Fix a perfect matching; it is equivalent to not existing augmenting cycles. We claim that \\(l,r\\) is good if and only if there isn\u2019t \\(i,j\\) such that \\(1\\le i<j\\le n,r_i\\ge j,l_j\\le i\\). It means there is no cycle of length \\(2\\). Moreover, it can be proven that there will be no cycle under this condition. View \\(l\\) as constraints on \\(r\\), \\(\\forall l_i\\le j<i\\), then \\(r_j<i\\) must hold. Let \\(a_i=\\min\\limits_{l_j\\le i<j}j\\) (if \\(j\\) doesn\u2019t exist, then \\(a_i=n+1\\)). We need to calculate the sum of \\(\\prod (a_i-i)\\) for all possible sequences of \\(l\\). Fixing \\(a\\), we consider the number of \\(l\\) that generates \\(a\\). The main idea is to consider all maximums of \\(a\\) and divide \\(a\\) into several independent parts. Let \\(f_{i,j}\\) denote the answer when only considering \\([i,j]\\), requiring all \\(a_i\\dots a_j\\le j+1\\), with \\(l_{j+1}\\) determined (\\(l_{j+1}<i\\)). Let \\(g_{i,j}\\) denote the answer when \\(l_{j+1}\\) is undetermined (\\(l_{j+1}\\ge i\\)). Particularly, \\(f_{i+1,i}=g_{i+1,i}=1\\). The final answer is \\(f_{1,n}\\). Find the smallest \\(k\\) such that \\(i\\le k\\le j\\) and \\(a_k=j+1\\) (obviously \\(a_j=j+1\\), then such \\(k\\) exists). Now, \\([i,k-1]\\) and \\([k+1,j]\\) are independent subproblems. Thus, we have:\n\n```python\ndef f_i_j(i, j):\n    return sum((j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n\ndef g_i_j(i, j):\n    return sum((k - i + 1) * (j - k + 1) * g_i_k_1(i, k - 1) * f_k_1_j(k + 1, j) for k in range(i, j + 1))\n```\n\nFurthermore, \\(f_{i,j}\\) is only related to \\(j-i+1\\), thus it can be rewritten as follows:\n\n```python\ndef f_i(i):\n    return sum((i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n\ndef g_i(i):\n    return sum(j * (i - j + 1) * g(j - 1) * f(i - j) for j in range(1, i + 1))\n```\n\nBrute force runs in \\(O(n^2)\\) and is allowed to pass. DC & FFT solution runs in \\(O(n\\log^2 n)\\).\n[END TEXT]\n \n\n", "problem_ids": ["agc067_d"]}, "abc324_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer \\( Y \\) between 1583 and 2023. Find the number of days in the year \\( Y \\) of the Gregorian calendar.\n\nWithin the given range, the year \\( Y \\) has the following number of days:\n\n- If \\( Y \\) is not a multiple of 4, then 365 days.\n- If \\( Y \\) is a multiple of 4 but not a multiple of 100, then 366 days.\n- If \\( Y \\) is a multiple of 100 but not a multiple of 400, then 365 days.\n- If \\( Y \\) is a multiple of 400, then 366 days.\n\n**Constraints:**\n\n- \\( Y \\) is an integer between 1583 and 2023, inclusive.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nY\n```\n\n**Output:**\n\nPrint the number of days in the year \\( Y \\) as an integer.\n\n**Sample Input 1:**\n\n```\n2023\n```\n\n**Sample Output 1:**\n\n```\n365\n```\n\n2023 is not a multiple of 4, so it has 365 days.\n\n**Sample Input 2:**\n\n```\n1992\n```\n\n**Sample Output 2:**\n\n```\n366\n```\n\n1992 is a multiple of 4 but not a multiple of 100, so it has 366 days.\n\n**Sample Input 3:**\n\n```\n1800\n```\n\n**Sample Output 3:**\n\n```\n365\n```\n\n1800 is a multiple of 100 but not a multiple of 400, so it has 365 days.\n\n**Sample Input 4:**\n\n```\n1600\n```\n\n**Sample Output 4:**\n\n```\n366\n```\n\n1600 is a multiple of 400, so it has 366 days.\n\nSolution:\n\n        Here is the cleaned version of the text, focusing only on the solution:\n\n---\n\nLet us use an if statement to implement the casework in the problem statement. To determine if \\(x\\) is divisible by \\(y\\), one can check if x % y == 0. Here, x % y denotes the remainder when \\(x\\) is divided by \\(y\\). When \\(x\\) is divisible by \\(y\\), the remainder when \\(x\\) is divided by \\(y\\) is \\(0\\), so the code above determines the divisibility. In our case, there are multiple if statements, possibly making the code deeply nested. In such a case, one can immediately print the result and return once a condition is met to avoid deep nests.\n\nSample code (Python3):\n```python\ny = int(input())\nif y % 4 != 0:\n    print(365)\nelif y % 100 != 0:\n    print(366)\nelif y % 400 != 0:\n    print(365)\nelse:\n    print(366)\n```\n \n\n", "problem_ids": ["abc365_a"]}, "abc324_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) rest areas around a lake. The rest areas are numbered \\( 1, 2, \\ldots, N \\) in clockwise order. It takes \\( A_i \\) steps to walk clockwise from rest area \\( i \\) to rest area \\( i+1 \\) (where rest area \\( N+1 \\) refers to rest area \\( 1 \\)).\n\nThe minimum number of steps required to walk clockwise from rest area \\( s \\) to rest area \\( t \\) (\\( s \\neq t \\)) must be a multiple of \\( M \\).\n\nDetermine the number of possible pairs \\((s, t)\\).\n\n**Constraints**\n\n- All input values are integers\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq M \\leq 10^6 \\)\n\n**Input Format**\n\nThe input is given from the standard input in the following format:\n\n```\nN M\nA_1 A_2 \\ldots A_N\n```\n\n**Output Format**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n4 3\n2 1 4 3\n```\n\n**Sample Output 1**\n```\n4\n```\n\n**Explanation**\n\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 2 is 2, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 3 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 1 to rest area 4 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 3 is 1, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 4 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 2 to rest area 1 is 8, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 4 is 4, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 1 is 7, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 3 to rest area 2 is 9, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 1 is 3, which is a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 2 is 5, which is not a multiple of 3.\n- The minimum number of steps to walk clockwise from rest area 4 to rest area 3 is 6, which is a multiple of 3.\n\nThus, there are four possible pairs \\( (s, t) \\).\n\n**Sample Input 2**\n```\n2 1000000\n1 1\n```\n\n**Sample Output 2**\n```\n0\n```\n\n**Sample Input 3**\n```\n9 5\n9 9 8 2 4 4 3 5 3\n```\n\n**Sample Output 3**\n```\n11\n```\n\nSolution:\n\n```python\n# Here is the cleaned version of the editorial:\n\n# For convenience, reassign the index \\((k-1)\\) to rest area \\(k\\) to treat indices from \\(0\\) through \\((N-1)\\). Consider the following array. Let \\(R_i\\) be the number of steps, modulo \\(M\\), required to travel from rest area \\(0\\) to rest area \\(i \\% N\\) as the \\(i\\)-th rest area to encounter. Precalculate these values for \\(i\\) from \\(0\\) through \\(2N-1\\). For example, if \\(A=(1,2,3,4)\\) and \\(M=6\\)...ultiple of \\(M\\)?\n\n# If \\(s<t\\), it holds when \\(R_s = R_t\\). This is equivalent to \\(R_{N+s}=R_{N+t}\\). If \\(s>t\\), it holds when \\(R_s = R_{N+t}\\).\n\n# Therefore, it is sufficient to solve the following problem:\n\n# Find the sum of the following value for \\(i=N,N+1,\\dots,2N-1\\). How many elements among \\(R_{i-N+1},R_{i-N+2},\\dots,R_{i-1}\\) are equal to \\(R_i\\)?\n\n# Intuitively, we are summing up the number of rest areas \\(i \\% N\\) to which the minimum steps required is a multiple of \\(M\\), over \\(i=N,N+1,\\dots,2N-1\\). This problem can be solved as follows:\n\n# First, let \\(B=(B[0],B[1],\\dots,B[M-1])\\) be the array of occurrences of \\(k\\) between \\(0\\) and \\(M-1\\) in \\(R_0\\) through \\(R_{N-1}\\). For \\(i = N,N+1,\\dots,2N-1\\), repeat the following:\n\n# Decrease \\(B[R_{i-N}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i-1\\).\n\n# Add \\(B[R_{i}]\\) Increase \\(B[R_{i}]\\) by one. This makes the current \\(B\\) manage the occurrences between \\(i-N+1\\) and \\(i\\).\n\n# Translated sample code (Python 3):\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    r = [0]\n    for i in range(2 * n):\n        r.append((r[-1] + a[i % n]) % m)\n    b = [0] * m\n    for i in range(n):\n        b[r[i]] += 1\n    res = 0\n    for i in range(n, 2 * n):\n        b[r[i - n]] -= 1\n        res += b[r[i]]\n        b[r[i]] += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc367_d"]}, "abc325_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} (A_i \\oplus A_{i+1} \\oplus \\ldots \\oplus A_j) \\]\n\n**Notes on Bitwise XOR:**\n\nThe bitwise XOR of non-negative integers \\( A \\) and \\( B \\), denoted as \\( A \\oplus B \\), is defined as follows:\n\n- In the binary representation of \\( A \\oplus B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) position is 1 if and only if exactly one of the digits at the \\( 2^k \\) position in the binary representations of \\( A \\) and \\( B \\) is 1; otherwise, it is 0.\n\nFor example, \\( 3 \\oplus 5 = 6 \\) (in binary: \\( 011 \\oplus 101 = 110 \\)).\n\nIn general, the bitwise XOR of \\( k \\) integers \\( p_1, \\dots, p_k \\) is defined as \\( (\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k) \\). It can be proved that this is independent of the order of \\( p_1, \\dots, p_k \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^8 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\n1 3 2\n```\n\n**Sample Output 1:**\n\n```\n3\n```\n\n**Explanation:**\n\n\\( A_1 \\oplus A_2 = 2 \\), \\( A_1 \\oplus A_2 \\oplus A_3 = 0 \\), and \\( A_2 \\oplus A_3 = 1 \\), so the answer is \\( 2 + 0 + 1 = 3 \\).\n\n**Sample Input 2:**\n\n```\n7\n2 5 6 5 2 1 7\n```\n\n**Sample Output 2:**\n\n```\n83\n```\n\nSolution:\n\n```\nEditorial - Toyota Programming Contest 2024#8 (AtCoder Beginner Contest 365)\n\nE - Xor Sigma Problem Editorial by en_translator\n\nIt is often effective to consider bitwise independently for a problem regarding XOR (exclusive logical sum). For each \\(j=0,1,\\ldots,27\\), define a sequence \\(B\\) of length \\(N\\) such that \\(B_i=1\\) if the \\(j\\)-th bit of \\(A_i\\) is \\(1\\) and \\(B_i=0\\) if it is \\(0\\). Solve the problem against \\(B\\) for each \\(j\\), and the total sum of the answers multiplied by \\(2^j\\) is the solution to the original problem. This simplifies the problem as \\(B\\) takes only zero or one, as opposed to \\(A\\) taking variable values.\n\nNext, the expression \\(\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j)\\) requires the total XOR of a segment. This can be computed fast using cumulative XORs, similar to cumulative sums when computing the total sum on a segment. Define the array of cumulative XORs \\(C\\) by \\(C_0=0\\) and \\(C_i =B_1\\oplus \\ldots \\oplus B_i\\). Then \\(B_i \\oplus B_{i+1}\\oplus \\ldots \\oplus B_j = C_{i-1} \\oplus C_j\\).\n\nThe expression can be rewritten as follows:\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (C_{i-1} \\oplus C_j)  = \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j). \\]\n\nAdjusting the index \\(j\\) to start from \\(i+1\\):\n\\[ \\sum_{i=0}^{N-2}\\sum_{j=i+2}^N (C_{i} \\oplus C_j) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=0}^{N-1} (C_i\\oplus C_{i+1}) = \\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j) - \\sum_{i=1}^{N} B_i. \\]\n\nNow \\(\\sum_{i=0}^{N-1}\\sum_{j=i+1}^N (C_{i} \\oplus C_j)\\) is the number of pairs of elements in \\(C\\) with different values, which equals the product of the number of occurrences of \\(0\\) and \\(1\\) in \\(C\\). Thus, the sought value can be evaluated with the total sum of \\(B\\) and the number of occurrences of \\(0\\) and \\(1\\) in the cumulative XORs. The problem is solved in \\(\\mathrm{O}(N \\log {\\mathrm{MAX_A}})\\) time.\n```\n \n\n", "problem_ids": ["abc365_e"]}, "abc325_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given three sequences of positive integers each of length \\( N \\):  \n\\( A = (A_1, A_2, \\ldots, A_N) \\),  \n\\( B = (B_1, B_2, \\ldots, B_N) \\), and  \n\\( C = (C_1, C_2, \\ldots, C_N) \\).  \n\nFind the number of pairs of positive integers \\( (x, y) \\) that satisfy the following condition for all \\( 1 \\leq i \\leq N \\):  \n\\[ A_i \\times x + B_i \\times y < C_i \\]\n\nIt can be proved that the number of such pairs of positive integers satisfying the condition is finite.\n\nYou are given \\( T \\) test cases, each of which should be solved.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq A_i, B_i, C_i \\leq 10^9 \\)  \n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).  \n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:  \n\\[\n\\begin{align*}\nT & \\\\\n\\mathrm{case}_1 & \\\\\n\\mathrm{case}_2 & \\\\\n\\vdots & \\\\\n\\mathrm{case}_T & \\\\\n\\end{align*}\n\\]\n\nEach test case is given in the following format:  \n\\[\n\\begin{align*}\nN & \\\\\nA_1 & B_1 & C_1 \\\\\nA_2 & B_2 & C_2 \\\\\n\\vdots & \\\\\nA_N & B_N & C_N \\\\\n\\end{align*}\n\\]\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line \\( (1 \\leq i \\leq T) \\) should contain the answer for the \\( i \\)-th test case.\n\n**Sample Input 1**\n\n```\n2\n2\n1 1 4\n1 2 5\n1\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n2\n0\n```\n\nIn the first test case, there are two valid pairs of integers: \\( (x, y) = (1, 1), (2, 1) \\). Thus, the first line should contain 2.  \nIn the second test case, there are no valid pairs of integers. Thus, the second line should contain 0.\n\n**Sample Input 2**\n\n```\n3\n7\n138 16011 918976\n5478 7748 499926\n5234 17727 748589\n1157 10511 643136\n31200 3005 721285\n28839 14469 798851\n1933 5378 864127\n9\n17775 1665 386430\n37001 863 922418\n9756 4182 746671\n12379 9106 807578\n3984 4049 640539\n25333 9869 780810\n20372 7000 688738\n16107 11974 827227\n10779 10531 770510\n5\n4916 14132 460944\n11856 45422 610561\n56014 18216 825793\n10363 6220 945356\n37418 33866 851593\n```\n\n**Sample Output 2**\n\n```\n660\n995\n140\n```\n\nSolution:\n\n```python\n# Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nfrom math import ceil, floor\n\ndef count_lattice_points(N, lines):\n    # Sort the lines in ascending order of their slopes\n    lines.sort(key=lambda line: line[0] / line[1])\n    \n    # Prepare an empty list to manage the lowermost lines\n    L = []\n    \n    # Implement the convex hull algorithm-like approach to filter lines\n    for line in lines:\n        while len(L) >= 2 and is_unnecessary(L[-2], L[-1], line):\n            L.pop()\n        L.append(line)\n    \n    # Adjust N to the number of lines in L\n    N = len(L)\n    \n    # Find X_max\n    X_max = min(ceil(C / A) for A, B, C in L)\n    \n    # Calculate the sum of contributions for each line\n    total = 0\n    for i in range(N):\n        A_i, B_i, C_i = L[i]\n        \n        # Determine x_i\n        x_i = float('inf') if i == N - 1 else ceil((L[i + 1][2] - C_i) / (A_i - L[i + 1][0]))\n        x_prev = -float('inf') if i == 0 else x_i\n        \n        # Sum over the valid x in the range [x_prev, x_i) and [1, X_max)\n        for x in range(max(1, ceil(x_prev)), min(x_i, X_max)):\n            total += floor((C_i - 1 - A_i * x) / B_i)\n    \n    return total\n\ndef is_unnecessary(line1, line2, line3):\n    \"\"\"\n    Determine if the line2 is unnecessary in the convex hull structure. \n    It can be computed by comparing cross products.\n    \"\"\"\n    A1, B1, C1 = line1\n    A2, B2, C2 = line2\n    A3, B3, C3 = line3\n    \n    # Return true if line2 is unnecessary\n    # Cross product comparison: (C2 - C1, A2 - A1) vs (C3 - C1, A3 - A1)\n    return (C2 - C1) * (A3 - A1) <= (C3 - C1) * (A2 - A1)\n```\n\nIn this Python code, we implement the algorithm described in the given editorial. The code converts the explanation into a function that computes the number of lattice points under the given lines, following the steps of sorting the lines, maintaining a valid set using a convex hull-like approach, and then summing contributions using a specified method.\n \n\n", "problem_ids": ["abc372_g"]}, "abc325_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere are three brothers named A, B, and C. The age relationships among them are specified by three characters: \\( S_{\\mathrm{AB}} \\), \\( S_{\\mathrm{AC}} \\), and \\( S_{\\mathrm{BC}} \\). The meanings of these characters are as follows:\n\n- If \\( S_{\\mathrm{AB}} \\) is '<', then A is younger than B; if it is '>', then A is older than B.\n- If \\( S_{\\mathrm{AC}} \\) is '<', then A is younger than C; if it is '>', then A is older than C.\n- If \\( S_{\\mathrm{BC}} \\) is '<', then B is younger than C; if it is '>', then B is older than C.\n\nYou need to determine who the middle brother is, meaning the one who is the second oldest among the three.\n\n**Constraints:**\n\n- Each of \\( S_{\\mathrm{AB}}, S_{\\mathrm{AC}}, S_{\\mathrm{BC}} \\) is either '<' or '>'.\n- The input contains no contradictions, which means there will always be a valid age relationship that satisfies all provided inequalities.\n\n**Input**\n\nThe input is provided from standard input in the following format:\n\n```\nS_{\\mathrm{AB}} S_{\\mathrm{AC}} S_{\\mathrm{BC}}\n```\n\n**Output**\n\nPrint the name of the middle brother, who is the second oldest among the three.\n\n**Sample Input 1**\n```\n< < <\n```\n\n**Sample Output 1**\n```\nB\n```\n\nExplanation: Since A is younger than B, and B is younger than C, we conclude that C is the oldest, B is the middle, and A is the youngest. Hence, the answer is B.\n\n**Sample Input 2**\n```\n< < >\n```\n\n**Sample Output 2**\n```\nC\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial:\n\n---\n\nFor beginners:\n\nIf you are new to programming and do not know where to start, please try Problem A \"Welcome to AtCoder\" from the practice contest. There you can find sample code for each language. If you are not familiar with problems in programming contests, we recommend you try some problems in \"AtCoder Beginners Selection\". There are C++ and Python tutorials for competitive programmers in Japanese.\n\nProblem A Solution:\n\nThis problem has various solutions. One solution is to implement a conditional branch for all the eight possible inputs (among which six are consistent and can actually be the input). This can be done with an if statement, but it\u2019s a bit cumbersome. Here is a bit cleverer solution:\n\nIf \\(S_\\mathrm{AB}\\neq S_\\mathrm{AC}\\): A is the middle son.  \nOtherwise, if \\(S_\\mathrm{AB}= S_\\mathrm{BC}\\): B is the middle son.  \nOtherwise: C is the middle son.\n\nThe following sample code implements the simple casework in Python:\n\n```python\na, b, c = input().strip()\n\nif a != b:\n    print(\"A\")\nelif a == c:\n    print(\"B\")\nelse:\n    print(\"C\")\n```\n\n \n\n", "problem_ids": ["abc371_a"]}, "abc325_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is a tree with \\(N \\times M + 1\\) vertices numbered \\(0, 1, \\dots, N \\times M\\). The \\(i\\)-th edge (\\(1 \\leq i \\leq N \\times M\\)) connects vertices \\(i\\) and \\(\\max(i - N, 0)\\).\n\nVertex \\(0\\) is painted. The other vertices are unpainted. Takahashi is at vertex \\(0\\). As long as there exists an unpainted vertex, he performs the following operation:\n\n- He chooses one of the vertices adjacent to his current vertex uniformly at random (all choices are independent) and moves to that vertex. Then, if the vertex he is on is unpainted, he paints it.\n\nFind the expected number of times he performs the operation, modulo \\(998244353\\).\n\nWhat is the expected value modulo \\(998244353\\)?\n\nIt can be proved that the sought expected value is always rational. Under the constraints of this problem, when that value is expressed as an irreducible fraction \\(\\frac{P}{Q}\\), it can also be proved that \\(Q \\not\\equiv 0 \\pmod{998244353}\\). Then, there uniquely exists an integer \\(R\\) such that \\(R \\times Q \\equiv P \\pmod{998244353}, 0 \\leq R < 998244353\\). Report this \\(R\\).\n\n**Constraints:**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq M \\leq 2 \\times 10^5\\)\n- \\(N\\) and \\(M\\) are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\n```\n\n**Output:**\n\nPrint the expected number of times he performs the operation, modulo \\(998244353\\).\n\n**Sample Input 1:**\n\n```\n2 2\n```\n\n**Sample Output 1:**\n\n```\n20\n```\n\nFor example, Takahashi could behave as follows.\n- Moves to vertex 1 and paints it. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 0. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 1. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 3 and paints it. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 1. This action is chosen with probability 1.\n- Moves to vertex 0. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 2 and paints it. This action is chosen with probability \\(\\frac{1}{2}\\).\n- Moves to vertex 4 and paints it. This action is chosen with probability \\(\\frac{1}{2}\\).\n\nHe behaves in this way with probability \\(\\frac{1}{128}\\), in which case the number of operations is 8. The expected number of operations is 20.\n\n**Sample Input 2:**\n\n```\n123456 185185\n```\n\n**Sample Output 2:**\n\n```\n69292914\n```\n\nSolution:\n\nHere is the text:\n\n[BEGIN TEXT]\nLet\u2019s consider the answer when \\(M = 1\\). In this case, Takahashi alternates between moving to one of the leaf vertices and returning to vertex \\(0\\). We can consider the operation of going to a leaf and returning to the root as a single unit called a round trip. We consider the expected number of operations needed until all leaves are painted. When \\(i\\) leaves are already painted, the expected number of round trips needed until a new leaf is painted is \\(\\frac{N}{N - i}\\). Thus, the expected number of round trips until all leaves are painted is the sum of \\(\\frac{N}{N - i}\\) over \\(i = 0, 1, \\dots, N - 1\\). Each round trip requires \\(2\\) operations, and it is unnecessary to return to the root after all vertices are painted, so the answer is \\(\\left(\\frac{N}{N} + \\frac{N}{N - 1} + \\dots + \\frac{N}{2} + \\frac{N}{1}\\right) \\times 2 - 1\\). Actually, we can handle a general \\(M\\) in the same way. Through some calculations, we find that the average number of operations per round trip is \\(2M^2\\), and the rest of the argument proceeds similarly. Thus, the answer is \\(M^2\\) times the answer for the case \\(M = 1\\).\n\nThe fact that the expected number of operations per round trip is \\(2M^2\\) can be shown by focusing on the depth of the vertex where he is on. By considering the depth, we essentially solve the problem: \u201cWhen performing a random walk on a path graph consisting of vertices \\(0, 1, \\dots, M\\) connected in this order, what is the expected number of steps needed to reach vertex \\(M\\) from vertex \\(0\\) and then return to vertex \\(0\\)?\u201d The answer to this problem is \\(2M^2\\).\n\nTherefore, we have solved this problem. The computational complexity is about \\(\\mathrm{O}(N)\\), which is sufficiently small.\n[END TEXT]\n \n\n", "problem_ids": ["arc185_d"]}, "abc325_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Here, \\( A_1, A_2, \\ldots, A_N \\) are all distinct. Which element in \\( A \\) is the second largest?\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( A_1, A_2, \\ldots, A_N \\) are all distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{N}\n```\n\n**Output**\n\nPrint the integer \\( X \\) such that the \\( X \\)-th element in \\( A \\) is the second largest.\n\n**Sample Input 1**\n```\n4\n8 2 5 1\n```\n\n**Sample Output 1**\n```\n3\n```\n\nThe second largest element in \\( A \\) is \\( A_3 \\), so print \\( 3 \\).\n\n**Sample Input 2**\n```\n8\n1 2 3 4 5 10 9 11\n```\n\n**Sample Output 2**\n```\n6\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Toyota Programming Contest 2024#8\uff08AtCoder Beginner Contest 365\uff09\n\nThe second largest value can be found in the sequence \\(A'\\) obtained by sorting \\(A\\). When \\(A\\) is sorted in ascending order, the second last value, or \\(A'_{N-1}\\), is the second largest value. Next, find the position of that value in \\(A\\) using for and if statements.\n\nSample code (Python3):\n\n```python\nn = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\ntar = b[n - 2]\nfor i in range(n):\n    if a[i] == tar:\n        print(i + 1)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc365_b"]}, "abc325_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a stack of `N` cards, and the `i-th` card from the top has an integer `A_i` written on it. You take `K` cards from the bottom of the stack and place them on top of the stack, maintaining their order.\n\nPrint the integers written on the cards from top to bottom after the operation.\n\n**Constraints**\n\n- \\(1 \\leq K < N \\leq 100\\)\n- \\(1 \\leq A_i \\leq 100\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet `B_i` be the integer written on the `i-th` card from the top of the stack after the operation. Print `B_1, B_2, \\ldots, B_N` in this order, separated by spaces.\n\n**Sample Input 1**\n\n```\n5 3\n1 2 3 4 5\n```\n\n**Sample Output 1**\n\n```\n3 4 5 1 2\n```\n\nInitially, the integers written on the cards are `1, 2, 3, 4, 5` from top to bottom. After taking three cards from the bottom of the stack and placing them on top, the integers written on the cards become `3, 4, 5, 1, 2` from top to bottom.\n\n**Sample Input 2**\n\n```\n6 2\n1 2 1 2 1 2\n```\n\n**Sample Output 2**\n\n```\n1 2 1 2 1 2\n```\n\nThe integers written on the cards are not necessarily distinct.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Hitachi Vantara Programming Contest 2024 (AtCoder Beginner Contest 368)\n\nThe topmost card after an operation is the \\(K\\)-th card from the bottom in the original pile. The \\(K\\)-th bottommost card is the \\((N-K+1)\\) card from the top, so the cards after the operation have \\(A_{N-K+1},A_{N-K+2},\\ldots,A_{N},A_{1},A_{2},\\ldots\\), and \\(A_{N-K}\\) written on them from the top. You may print these values. In many programming languages, indices start from \\(0\\), so beware of indices.\n\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\nfor i in range(N-K,N): print(A[i])\nfor i in range(N-K): print(A[i])\n```\n\nIn languages like Python, one can easily achieve the operation of splitting a pile into two and move the lower part to the top, as follows:\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\ntop = A[:-K]  # upper\nbottom = A[-K:]  # lower\nB = bottom + top  # put the lower part to the top\nprint(*B)\n```\n\nIn Python, you can also achieve a similar operation using list slicing:\n```python\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA = A[-K:] + A[:-K]\nprint(*A)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc368_a"]}, "abc326_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) types of elements numbered \\( 1, 2, \\ldots, N \\). Elements can be combined with each other. When elements \\( i \\) and \\( j \\) are combined, they transform into element \\( A_{i, j} \\) if \\( i \\geq j \\), and into element \\( A_{j, i} \\) if \\( i < j \\).\n\nStarting with element \\( 1 \\), combine it with elements \\( 1, 2, \\ldots, N \\) in this order. Find the final element obtained.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_{i, j} \\leq N \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nA_{1, 1}\nA_{2, 1} A_{2, 2}\n\\vdots\nA_{N, 1} A_{N, 2} \\ldots A_{N, N}\n```\n\n**Output:**\n\nPrint the number representing the final element obtained.\n\n**Sample Input 1:**\n\n```\n4\n3\n2 4\n3 1 2\n2 1 2 4\n```\n\n**Sample Output 1:**\n\n```\n2\n```\n\n**Explanation for Sample Input 1:**\n\n- Combining element 1 with element 1 results in element 3.\n- Combining element 3 with element 2 results in element 1.\n- Combining element 1 with element 3 results in element 3.\n- Combining element 3 with element 4 results in element 2.\n\nTherefore, the value to be printed is 2.\n\n**Sample Input 2:**\n\n```\n5\n5\n5 5\n5 5 5\n5 5 5 5\n5 5 5 5 5\n```\n\n**Sample Output 2:**\n\n```\n5\n```\n\n**Sample Input 3:**\n\n```\n6\n2\n1 5\n1 6 3\n2 6 1 4\n2 1 1 1 6\n5 6 1 2 2 5\n```\n\n**Sample Output 3:**\n\n```\n5\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\n**B - Binary Alchemy Editorial**\n\nSimulate the process of successively synthesizing elements \\(1, 2, \\ldots, N\\) into element \\(1\\) while managing the current index of the element.\n\n```python\ndef main():\n    n = int(input())\n    a = [list(map(lambda x: int(x) - 1, input().split())) + [0] * (n - i - 1) for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if ans >= i:\n            ans = a[ans][i]\n        else:\n            ans = a[i][ans]\n    ans += 1\n    print(ans)\n\nmain()\n```\n\n---\n \n\n", "problem_ids": ["abc370_b"]}, "abc326_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence \\( (X_1, X_2, \\dots, X_M) \\) of length \\( M \\) consisting of integers between \\( 1 \\) and \\( M \\), inclusive.\n\nFind the number, modulo \\( 998244353 \\), of sequences \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\) consisting of integers between \\( 1 \\) and \\( M \\), inclusive, that satisfy the following condition:\n\nFor each \\( B = 1, 2, \\dots, M \\), the value \\( X_B \\) exists between any two different occurrences of \\( B \\) in \\( A \\) (including both ends).\n\nMore formally, for each \\( B = 1, 2, \\dots, M \\), the following condition must hold:\n\nFor every pair of integers \\( (l, r) \\) such that \\( 1 \\leq l < r \\leq N \\) and \\( A_l = A_r = B \\), there exists an integer \\( m \\) (\\( l \\leq m \\leq r \\)) such that \\( A_m = X_B \\).\n\n**Constraints**\n- \\( 1 \\leq M \\leq 10 \\)\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq X_i \\leq M \\)\n- All input values are integers.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nM N\nX_1 X_2 \\cdots X_M\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n3 4\n2 1 2\n```\n\n**Sample Output 1**\n```\n14\n```\n\nHere are examples of sequences \\( A \\) that satisfy the condition:\n- \\( (1, 3, 2, 3) \\)\n- \\( (2, 1, 2, 1) \\)\n- \\( (3, 2, 1, 3) \\)\n\nHere are non-examples:\n- \\( (1, 3, 1, 3) \\) - There is no \\( X_3 = 2 \\) between the \\( 3 \\)s.\n- \\( (2, 2, 1, 3) \\) - There is no \\( X_2 = 1 \\) between the \\( 2 \\)s.\n\n**Sample Input 2**\n```\n4 8\n1 2 3 4\n```\n\n**Sample Output 2**\n```\n65536\n```\n\nAll sequences of length \\( 8 \\) consisting of integers between \\( 1 \\) and \\( 4 \\) satisfy the condition. Note that when \\( X_B = B \\), there is always a \\( B \\) between two different occurrences of \\( B \\).\n\n**Sample Input 3**\n```\n4 9\n2 3 4 1\n```\n\n**Sample Output 3**\n```\n628\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Regular Contest 179\n\n# B - Between B and B Editorial by evima\n\n# For each B = 1, 2, ..., M, the value X_B exists between any two different occurrences \n# of B in A (including both ends). This condition will be referred to as \u201cthe condition.\u201d \n# Let\u2019s consider determining the elements of A from the beginning. When deciding A_i, \n# we choose A_i such that (A_1, A_2, ..., A_i) satisfies the condition. Therefore, \n# let\u2019s consider the following dynamic programming approach.\n\n# Let dp[c][S] be the number of ways to determine the first c(=0,1,...,N) elements of \n# A such that the set of possible values for A_{c+1} is S (\u2286 {1,2,...,M}).\n\n# First, any of 1, 2, ..., M can be chosen as A_1. Therefore, dp[0][{1,2,...,M}] = 1. \n# Next, let\u2019s consider what happens when c and S are fixed, and we decide A_{c+1} to \n# be a \u2208 S. First, due to the condition that X_a must exist between any two occurrences \n# of a, we remove a from S. This can be interpreted as not being allowed to add a again \n# until X_a is added. Next, we add all b such that X_b = a to S. This can be interpreted \n# as allowing b to be added since X_b has been added. Let the new set obtained in this \n# way be written as S(a). The transition in the dynamic programming can be written as \n# follows:\n\n# dp[c+1][S(a)] += dp[c][S]  (a \u2208 S)\n\n# This is a bitDP. The time complexity is O(NM2^M), which is sufficiently fast under \n# the given constraints.\n```\n\n\n \n\n", "problem_ids": ["arc179_b"]}, "abc326_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 500 points\n\n### Problem Statement\n\nHow many integers \\( x \\) between 1 and \\( N \\), inclusive, can be expressed as \\( x = a^b \\) using some positive integer \\( a \\) and a positive integer \\( b \\) not less than 2?\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 10^{18} \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\n```\n\n### Output\n\nPrint the answer as an integer.\n\n### Sample Input 1\n\n```\n99\n```\n\n### Sample Output 1\n\n```\n12\n```\n\nThe integers that satisfy the conditions in the problem statement are: 1, 4, 8, 9, 16, 25, 27, 32, 36, 49, 64, 81. There are 12 of these.\n\n### Sample Input 2\n\n```\n1000000000000000000\n```\n\n### Sample Output 2\n\n```\n1001003332\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Denso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09 Editorial - Problem F: x = a^b\n\nWe introduce a rather brute-force solution. As evident from Sample 2, a total of 1001003332 integers can satisfy the condition. Since \\((10^9)^2 = 10^{18}\\), \\(10^9\\) integers among them can be represented as \\(a^2\\). Therefore, there are only \\(10^6\\) integers that cannot be represented as \\(a^2\\). One can enumerate all of them and then add the number of those represented as \\(a^2\\). This enumeration can be done for \\(b=3,4,\\dots,59\\) and then stopped once \\(a^b > N\\) is satisfied; one can determine if an integer \\(x\\) can be represented as \\(a^2\\) by checking if \\((\\lfloor \\sqrt{x} \\rfloor )^2=x\\).\n\nSample code (Python):\n```python\nimport math\n\ndef safe_pow(a, b):\n    res = 1\n    for _ in range(b):\n        dres = res\n        dres *= a\n        if dres > 2e18:\n            return 2e18\n        res *= a\n    return res\n\ndef sqrt_floor(x):\n    l, r = 0, int(2e9)\n    while l <= r:\n        t = (l + r) // 2\n        if t * t > x:\n            r = t - 1\n        else:\n            l = t + 1\n    return r\n\ndef main():\n    n = int(input().strip())\n    st = set()\n    for b in range(3, 60):\n        a = 2\n        while True:\n            x = safe_pow(a, b)\n            if x > n:\n                break\n            s = sqrt_floor(x)\n            if s * s != x:\n                st.add(x)\n            a += 1\n    res = len(st)\n    res += sqrt_floor(n)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc361_f"]}, "abc326_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given three sequences of positive integers each of length \\( N \\):  \n\\( A = (A_1, A_2, \\ldots, A_N) \\),  \n\\( B = (B_1, B_2, \\ldots, B_N) \\), and  \n\\( C = (C_1, C_2, \\ldots, C_N) \\).  \n\nFind the number of pairs of positive integers \\( (x, y) \\) that satisfy the following condition for all \\( 1 \\leq i \\leq N \\):  \n\\[ A_i \\times x + B_i \\times y < C_i \\]\n\nIt can be proved that the number of such pairs of positive integers satisfying the condition is finite.\n\nYou are given \\( T \\) test cases, each of which should be solved.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)  \n- \\( 1 \\leq A_i, B_i, C_i \\leq 10^9 \\)  \n- The sum of \\( N \\) over all test cases is at most \\( 2 \\times 10^5 \\).  \n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:  \n\\[\n\\begin{align*}\nT & \\\\\n\\mathrm{case}_1 & \\\\\n\\mathrm{case}_2 & \\\\\n\\vdots & \\\\\n\\mathrm{case}_T & \\\\\n\\end{align*}\n\\]\n\nEach test case is given in the following format:  \n\\[\n\\begin{align*}\nN & \\\\\nA_1 & B_1 & C_1 \\\\\nA_2 & B_2 & C_2 \\\\\n\\vdots & \\\\\nA_N & B_N & C_N \\\\\n\\end{align*}\n\\]\n\n**Output**\n\nPrint \\( T \\) lines. The \\( i \\)-th line \\( (1 \\leq i \\leq T) \\) should contain the answer for the \\( i \\)-th test case.\n\n**Sample Input 1**\n\n```\n2\n2\n1 1 4\n1 2 5\n1\n1 1 2\n```\n\n**Sample Output 1**\n\n```\n2\n0\n```\n\nIn the first test case, there are two valid pairs of integers: \\( (x, y) = (1, 1), (2, 1) \\). Thus, the first line should contain 2.  \nIn the second test case, there are no valid pairs of integers. Thus, the second line should contain 0.\n\n**Sample Input 2**\n\n```\n3\n7\n138 16011 918976\n5478 7748 499926\n5234 17727 748589\n1157 10511 643136\n31200 3005 721285\n28839 14469 798851\n1933 5378 864127\n9\n17775 1665 386430\n37001 863 922418\n9756 4182 746671\n12379 9106 807578\n3984 4049 640539\n25333 9869 780810\n20372 7000 688738\n16107 11974 827227\n10779 10531 770510\n5\n4916 14132 460944\n11856 45422 610561\n56014 18216 825793\n10363 6220 945356\n37418 33866 851593\n```\n\n**Sample Output 2**\n\n```\n660\n995\n140\n```\n\nSolution:\n\n```python\n# Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nfrom math import ceil, floor\n\ndef count_lattice_points(N, lines):\n    # Sort the lines in ascending order of their slopes\n    lines.sort(key=lambda line: line[0] / line[1])\n    \n    # Prepare an empty list to manage the lowermost lines\n    L = []\n    \n    # Implement the convex hull algorithm-like approach to filter lines\n    for line in lines:\n        while len(L) >= 2 and is_unnecessary(L[-2], L[-1], line):\n            L.pop()\n        L.append(line)\n    \n    # Adjust N to the number of lines in L\n    N = len(L)\n    \n    # Find X_max\n    X_max = min(ceil(C / A) for A, B, C in L)\n    \n    # Calculate the sum of contributions for each line\n    total = 0\n    for i in range(N):\n        A_i, B_i, C_i = L[i]\n        \n        # Determine x_i\n        x_i = float('inf') if i == N - 1 else ceil((L[i + 1][2] - C_i) / (A_i - L[i + 1][0]))\n        x_prev = -float('inf') if i == 0 else x_i\n        \n        # Sum over the valid x in the range [x_prev, x_i) and [1, X_max)\n        for x in range(max(1, ceil(x_prev)), min(x_i, X_max)):\n            total += floor((C_i - 1 - A_i * x) / B_i)\n    \n    return total\n\ndef is_unnecessary(line1, line2, line3):\n    \"\"\"\n    Determine if the line2 is unnecessary in the convex hull structure. \n    It can be computed by comparing cross products.\n    \"\"\"\n    A1, B1, C1 = line1\n    A2, B2, C2 = line2\n    A3, B3, C3 = line3\n    \n    # Return true if line2 is unnecessary\n    # Cross product comparison: (C2 - C1, A2 - A1) vs (C3 - C1, A3 - A1)\n    return (C2 - C1) * (A3 - A1) <= (C3 - C1) * (A2 - A1)\n```\n\nIn this Python code, we implement the algorithm described in the given editorial. The code converts the explanation into a function that computes the number of lattice points under the given lines, following the steps of sorting the lines, maintaining a valid set using a convex hull-like approach, and then summing contributions using a specified method.\n \n\n", "problem_ids": ["abc372_g"]}, "abc326_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nTakahashi has \\( N \\) cards from the card game \"AtCoder Magics.\" Each card \\( i \\) has two parameters: strength \\( A_i \\) and cost \\( C_i \\).\n\nTakahashi does not like weak cards, so he will discard them. He will repeatedly perform the following operation until it can no longer be done:\n\n- Choose two cards \\( x \\) and \\( y \\) such that \\( A_x > A_y \\) and \\( C_x < C_y \\). Discard card \\( y \\).\n\nIt is assured that when these operations can no longer be performed, the set of remaining cards is uniquely determined. Find this set of cards.\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, C_i \\leq 10^9 \\)\n- All the \\( A_1, A_2, \\dots, A_N \\) are distinct.\n- All the \\( C_1, C_2, \\dots, C_N \\) are distinct.\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 C_1\nA_2 C_2\n...\nA_N C_N\n```\n\n**Output:**\n\nSuppose there are \\( m \\) remaining cards, denoted by their indices \\( i_1, i_2, \\dots, i_m \\), in ascending order. Print these indices in the following format:\n\n```\nm\ni_1 i_2 ... i_m\n```\n\n**Sample Input 1:**\n```\n3\n2 4\n1 1\n3 2\n```\n\n**Sample Output 1:**\n```\n2\n2 3\n```\n\n(Focusing on cards 1 and 3, we have \\( A_1 < A_3 \\) and \\( C_1 > C_3 \\), so card 1 can be discarded. No further operations can be performed. At this point, cards 2 and 3 remain, so print them.)\n\n**Sample Input 2:**\n```\n5\n1 1\n10 2\n100 3\n1000 4\n10000 5\n```\n\n**Sample Output 2:**\n```\n5\n1 2 3 4 5\n```\n\n(In this case, no cards can be discarded.)\n\n**Sample Input 3:**\n```\n6\n32 101\n65 78\n2 29\n46 55\n103 130\n52 40\n```\n\n**Sample Output 3:**\n```\n4\n2 3 5 6\n```\n\nSolution:\n\nBelow is the editorial with the C++ code translated to Python3:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nC - AtCoder Magics Editorial by en_translator \n\nYou can intuitively understand the problem by plotting the data on a two-dimensional plane. The following is a visualization of Sample Input/Output 1. For cards \\(x\\) and \\(y\\), we have \\(A_x > A_y\\) and \\(C_x < C_y\\) if and only if the point corresponding to card \\(x\\) is in the lower-right region of that for card \\(y\\). In Sample Input/Output 1, card \\(3\\) is in the lower-right region of card \\(1\\).\n\nConsider the condition of a card that is never discarded. By the discussion above, a card is never removed if there is no point on the lower-right region of the point for itself. Otherwise, the card is always removed. The set of cards that has no point on its lower-right region can be found as follows. Scan the cards in ascending order of their costs, i.e., from lower points to higher, and include those that update the maximum strength so far (the rightmost one) to the answer. (Not being able to update the maximum strength means there is a card with smaller cost and larger strength, i.e., there is a card on its lower-right region.)\n\nSort cards in ascending order of \\(C_i\\). First, let \\(v = 0\\), and let \\(S\\) be an empty set. For \\(i = 1, 2, \\cdots, N\\) in order, if \\(A_i > v\\), then insert the \\(i\\)-th card, and set \\(v\\) to \\(A_i\\). The resulting \\(S\\) is the answer.\n\nFor sample code 1, it runs as follows. The cards are sorted by \\(C_i\\) as cards \\(2, 3, 1\\).\n\n\\(A_2 (= 1) > v (= 0)\\), so insert card \\(2\\) to \\(S\\), and let \\(v = 1\\). \\(A_3 (= 3) > v (= 1)\\), so insert card \\(3\\) to \\(S\\), and let \\(v = 3\\). \\(A_1 (= 2) < v (= 3)\\), so card \\(1\\) is not inserted to \\(S\\).\n\nFinally, \\(S = \\{ 2, 3 \\}\\).\n\nFor example, it can be implemented in Python as follows. The complexity is \\(O(N \\log N)\\), where sorting is the bottleneck.\n\n```python\ndef atcoder_magics():\n    # Input\n    n = int(input())\n    cards = []\n    for i in range(n):\n        a, c = map(int, input().split())\n        cards.append((a, c, i))\n    \n    # Sort in ascending order of C[i]\n    cards.sort(key=lambda x: x[1])\n    \n    # Compute the answer\n    ans = []\n    v = 0\n    for a, c, index in cards:\n        if a > v:\n            v = a\n            ans.append(index)\n    \n    ans.sort()\n    \n    # Print\n    m = len(ans)\n    print(m)\n    print(' '.join(str(x + 1) for x in ans))\n\n# To invoke the function, simply call:\n# atcoder_magics()\n```\n```\n \n\n", "problem_ids": ["abc354_c"]}, "abc327_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given positive integers \\( N \\), \\( L \\), and \\( R \\). For a sequence \\( A = (1, 2, \\dots, N) \\) of length \\( N \\), an operation of reversing the \\( L \\)-th through \\( R \\)-th elements was performed once. Print the sequence after this operation.\n\n**Constraints**\n\n- All input values are integers.\n- \\( 1 \\leq L \\leq R \\leq N \\leq 100 \\)\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN L R\n```\n\n**Output**\n\nLet \\( A' = (A'_1, A'_2, \\dots, A'_N) \\) be the sequence after the operation. Print it in the following format:\n```\nA'_1 A'_2 \\dots A'_N\n```\n\n**Sample Input 1**\n```\n5 2 3\n```\n\n**Sample Output 1**\n```\n1 3 2 4 5\n```\n\nExplanation: Initially, \\( A = (1, 2, 3, 4, 5) \\). After reversing the second through third elements, the sequence becomes \\( (1, 3, 2, 4, 5) \\), which should be printed.\n\n**Sample Input 2**\n```\n7 1 1\n```\n\n**Sample Output 2**\n```\n1 2 3 4 5 6 7\n```\n\nExplanation: It is possible that \\( L = R \\).\n\n**Sample Input 3**\n```\n10 1 10\n```\n\n**Sample Output 3**\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nExplanation: It is possible that \\( L = 1 \\) or \\( R = N \\).\n\nSolution:\n\nHere is the cleaned version of the editorial text:\n\nApproach 1: Actually construct an array and apply reversion. Solve the problem by constructing the sequence \\(A=(1,2,\\dots,N)\\) as an array, reverse the \\(L\\)-th through \\(R\\)-th elements, and print the result. First, let \\(l=L\\) and \\(r=R\\). While \\(l<r\\), swap the \\(l\\)-th and \\(r\\)-th element, add \\(1\\) to \\(l\\), and subtract \\(1\\) from \\(r\\). Note that the first element might be treated as the \\(0\\)-th one depending on array usage.\n\nSample code 1 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nwhile L < R:\n    A[L], A[R] = A[R], A[L]\n    L += 1\n    R -= 1\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nSample code 2 (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nA = list(range(N + 5))\nfor i in range(1, N + 1):\n    A[i] = i\nA[L:R + 1] = reversed(A[L:R + 1])\nfor i in range(1, N + 1):\n    if i != 1:\n        print(\" \", end=\"\")\n    print(A[i], end=\"\")\nprint()\n```\n\nApproach 2: Directly construct the sought sequence. The structure is as follows: arrange \\(1,2,\\dots,L-1\\), then \\(R,R-1,\\dots,L\\), and finally \\(R+1,R+2,\\dots,N\\).\n\nSample code (Python):\n```python\nN = int(input())\nL = int(input())\nR = int(input())\nres = []\n\nfor i in range(1, L):\n    res.append(i)\nfor i in range(R, L - 1, -1):\n    res.append(i)\nfor i in range(R + 1, N + 1):\n    res.append(i)\n\nfor i in range(N):\n    if i:\n        print(\" \", end=\"\")\n    print(res[i], end=\"\")\nprint()\n```\n \n\n", "problem_ids": ["abc356_a"]}, "abc327_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land is represented by a grid with \\(H\\) rows and \\(W\\) columns. Let \\((i, j)\\) denote the cell at the \\(i\\)-th row and \\(j\\)-th column.\n\nTakahashi starts at cell \\((S_i, S_j)\\) and repeats the following action \\(K\\) times:\n- He either stays in the current cell or moves to an adjacent cell. After this action, if he is in cell \\((i, j)\\), he gains a fun value of \\(A_{i, j}\\).\n\nFind the maximum total fun value he can gain.\n\nHere, a cell \\((x', y')\\) is considered adjacent to cell \\((x, y)\\) if and only if \\(|x - x'| + |y - y'| = 1\\).\n\n**Constraints**\n\n- \\(1 \\leq H, W \\leq 50\\)\n- \\(1 \\leq K \\leq 10^9\\)\n- \\(1 \\leq S_i \\leq H\\)\n- \\(1 \\leq S_j \\leq W\\)\n- \\(1 \\leq A_{i, j} \\leq 10^9\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nH W K\nS_i S_j\nA_{1, 1} A_{1, 2} \\ldots A_{1, W}\nA_{2, 1} A_{2, 2} \\ldots A_{2, W}\n\\vdots\nA_{H, 1} A_{H, 2} \\ldots A_{H, W}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 3 3\n1 2\n2 1 2\n3 4 5\n```\n\n**Sample Output 1**\n\n```\n14\n```\n\nTakahashi can gain a total fun value of 14 by acting as follows:\n- Initially, he is at \\((1, 2)\\).\n- He moves to cell \\((2, 2)\\). Then, he gains a fun value of \\(A_{2, 2} = 4\\).\n- He moves to cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n- He stays in cell \\((2, 3)\\). Then, he gains a fun value of \\(A_{2, 3} = 5\\).\n\nHe cannot gain a total fun value greater than 14, so print 14.\n\n**Sample Input 2**\n\n```\n2 2 1000000000\n2 1\n100 100\n100 99\n```\n\n**Sample Output 2**\n\n```\n100000000000\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        In an optimal solution, one can assume that Takahashi stays at a cell with the maximum \\(A_{i,j}\\) among those he passes through. This means he can keep staying there indefinitely. Let \\((G_i, G_j)\\) be the final cell. We assume he travels from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) and then stays there zero or more times. In the travel, he never passes through the same cell twice because if he does, he can improve the score by staying more times at \\((G_i, G_j)\\). Paths from \\((S_i, S_j)\\) to \\((G_i, G_j)\\) have a length not greater than \\(HW\\), allowing for a straightforward DP (Dynamic Programming) approach. Specifically, evaluate \\(dp_{i,j,k}\\) as the maximum total fun value after making \\(i\\) moves to end up at \\((j,k)\\). The answer is \\(\\max ((K - i) A_{j,k} + dp_{i,j,k})\\). The DP runs in \\(O((HW)^2)\\) time. Consider cases where \\(K \\leq HW\\).\n        [END TEXT]\n \n\n", "problem_ids": ["abc358_g"]}, "abc327_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\nYou are given positive integers \\( N \\), \\( M \\), and \\( K \\), and a sequence of \\( M \\) non-negative integers \\( A = (A_0, A_1, \\ldots, A_{M-1}) \\). Here, \\( 2^{N-1} \\leq K < 2^N \\).\n\nIn the input, \\( K \\) is given as an \\( N \\)-digit number in binary notation, while the other integers are given in decimal notation.\n\nAdditionally, \\( A \\) is not given directly in the input. Instead, for each \\( i = 0, 1, \\ldots, M-1 \\), you are given a sequence of \\( L_i \\) integers \\( X_i = (X_{i,0}, X_{i,1}, \\ldots, X_{i,L_i-1}) \\) such that \\( A_i = \\sum_{j=0}^{L_i-1} 2^{X_{i,j}} \\). Here, \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\).\n\nFind the inversion number, modulo \\( 998244353 \\), of the sequence \\( B = (B_0, B_1, \\ldots, B_{MK-1}) \\) defined as follows:\n\n- For any integer \\( a \\) such that \\( 0 \\leq a < K \\) and any integer \\( b \\) such that \\( 0 \\leq b < M \\), the following holds:\n  - \\( B_{aM+b} \\) is equal to the remainder when \\( \\text{popcount}(a \\land A_b) \\) is divided by \\( 2 \\).\n\n**What is \\(\\operatorname{AND}\\)?**\nThe bitwise \\(\\operatorname{AND}\\) of integers \\( A \\) and \\( B \\), denoted as \\( A \\land B \\), is defined as follows:\n- In the binary representation of \\( A \\land B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) place is \\( 1 \\) if and only if the digits at the \\( 2^k \\) place in the binary representations of both \\( A \\) and \\( B \\) are \\( 1 \\); otherwise, it is \\( 0 \\).\n\nFor example, \\( 3 \\land 5 = 1 \\) (in binary: \\( 011 \\land 101 = 001 \\)).\n\nGenerally, the bitwise \\(\\operatorname{AND}\\) of \\( k \\) integers \\( p_1, p_2, p_3, \\ldots, p_k \\) is defined as \\(((\\ldots ((p_1 \\land p_2) \\land p_3) \\land \\ldots \\land p_k)\\), and it can be proved that this is independent of the order of \\( p_1, p_2, p_3, \\ldots, p_k \\).\n\n**What is \\(\\operatorname{popcount}\\)?**\nFor a non-negative integer \\( x \\), \\(\\operatorname{popcount}(x)\\) is the number of \\( 1 \\)s in the binary representation of \\( x \\). More precisely, for a non-negative integer \\( x \\) such that \\( x = \\sum_{i=0}^{\\infty} b_i 2^i \\) (\\( b_i \\in \\{0, 1\\} \\)), it holds that \\(\\operatorname{popcount}(x) = \\sum_{i=0}^{\\infty} b_i \\).\n\nFor example, \\( 13 \\) is \\( 1101 \\) in binary, so \\(\\operatorname{popcount}(13) = 3\\).\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2^{N-1} \\leq K < 2^N \\)\n- \\( 0 \\leq L_i \\leq N \\)\n- \\(\\sum L_i \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\)\n- All input values are integers.\n- \\( K \\) is given in binary notation.\n- All numbers except \\( K \\) are given in decimal notation.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M\nK\nL_0 X_{0,0} X_{0,1} \\cdots X_{0,L_0-1}\nL_1 X_{1,0} X_{1,1} \\cdots X_{1,L_1-1}\n\\vdots\nL_{M-1} X_{M-1,0} X_{M-1,1} \\cdots X_{M-1,L_{M-1}-1}\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n2 4\n11\n1 0\n2 0 1\n0\n1 1\n```\n\n**Sample Output 1**\n```\n9\n```\n\n**Explanation of Sample 1**\n\\( A = (1, 3, 0, 2) \\), \\( B = (0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1) \\).\n\n**Sample Input 2**\n```\n3 3\n101\n2 1 2\n2 0 1\n1 0\n```\n\n**Sample Output 2**\n```\n23\n```\n\n**Explanation of Sample 2**\n\\( A = (6, 3, 1) \\), \\( B = (0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0) \\).\n\n**Sample Input 3**\n```\n16 7\n1101010000100110\n11 0 1 2 3 7 10 11 12 13 14 15\n7 4 6 8 10 11 12 13\n6 0 1 6 8 10 12\n8 0 3 5 6 10 11 12 13\n10 0 1 2 3 4 5 6 8 12 13\n9 3 4 5 6 8 9 11 14 15\n8 0 4 7 9 10 11 13 14\n```\n\n**Sample Output 3**\n```\n97754354\n```\n\n**Sample Input 4**\n```\n92 4\n10101100101111111111011101111111101011001011111110011110111111101111111110100111100010111011\n23 1 2 5 13 14 20 28 32 34 39 52 56 59 60 62 64 67 69 71 78 84 87 91\n20 15 17 22 28 36 40 43 47 52 53 57 67 72 77 78 81 87 89 90 91\n23 7 8 9 10 11 13 16 19 22 23 30 33 42 49 51 52 58 64 71 73 76 79 83\n22 1 13 19 26 27 28 29 35 39 40 41 46 55 60 62 64 67 74 79 82 89 90\n```\n\n**Sample Output 4**\n```\n291412708\n```\n\nYou are required to find the number modulo \\( 998244353 \\).\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 178\n\nF - Long Sequence Inversion Editorial by evima\n\nThis explanation generally uses \\(0\\)-based indexing. For the inversion number of a binary sequence \\(Y = (Y_{0}, Y_{1}, \\dots, Y_{|Y|-1})\\), the following holds:\n\nIf there are \\(P\\) indices \\(i\\) where \\(Y_{i} = 0\\), and the sum of such indices is \\(Q\\), then the inversion number of \\(Y\\) is \\(Q - \\frac{P(P-1)}{2}\\).\n\nTherefore, we need to find the number of zeros in \\(B\\) and the sum of their indices. Here, we define a sequence of sequences \\(C = (C_{0}, C_{1}, \\dots, C_{M-1})\\) as follows:\n\n\\(C_{i} = (C_{i,0}, C_{i,1}, \\dots, C_{i,K-1})\\) is a sequence of length \\(K\\), where the \\(j\\)-th element \\(C_{i,j}\\) is equal to \\(\\operatorname{popcount}(j \\operatorname{AND} A_{i})\\).\n\nLet \\(P_{i}\\) be the number of \\(0\\)s in \\(C_{i}\\), and \\(Q_{i}\\) be the sum of indices where \\(C_{i}\\) is \\(0\\). The inversion number of \\(B\\) can be expressed as:\n\\[\n\\text{inversion}(B) = \\sum_{i=0}^{M-1}(Q_{i}M + iP_{i}) - \\frac{(\\sum P)(\\sum P - 1)}{2}\n\\]\nThus, if we know \\(P_{i}\\) and \\(Q_{i}\\) for each integer \\(i\\) from 0 to \\(M-1\\), we can determine the answer. To find \\(P_{i}\\) and \\(Q_{i}\\), we need the difference between the number of \\(0\\)s and \\(1\\)s in \\(C_{i}\\), and the difference between the sum of indices where \\(C_{i}\\) is \\(0\\) and where it is \\(1\\).\n\nHere, we find an integer sequence \\(Z\\) such that \\(K = \\sum 2^{Z_{j}}\\) and \\(0 \\leq Z_{0} < Z_{1} < \\cdots < Z_{L-1} = N-1\\). Using \\(Z\\), we decompose the interval \\([0, K)\\) and consider the contribution of each segment to \\(P_{i}\\) and \\(Q_{i}\\).\n\nFor the numbers of \\(0\\)s and \\(1\\)s in the contiguous subsequence \\((C_{i, K-2^{Z_{0}}}, C_{i, K-2^{Z_{0}+1}}, \\dots, C_{i, K-1})\\) in \\(C_{i}\\):\n- If \\((A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are equal to \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (K - 2^{Z_{0}}))\\).\n\nFor the sums of indices where \\(C_{i}\\) is \\(0\\) or \\(1\\):\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) \\geq 2\\), the difference is 0.\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are \\(0\\) or \\(1\\).\n\nThis gives us the contribution of the interval \\([K - 2^{Z_{0}}, K)\\) to \\(P_{i}\\) and \\(Q_{i}\\). We can similarly find the contributions of other intervals. By dividing the intervals appropriately and performing precomputations such as cumulative sums, we can compute \\(P_{i}\\) and \\(Q_{i}\\) in \\(O(L_{i})\\) time. The answer to this problem can be obtained in linear time relative to the input.\n```\n \n\n", "problem_ids": ["arc178_f"]}, "abc327_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( A \\). You will perform the following operations:\n\n1. Generate \\( N \\) real numbers uniformly at random between 0 and 1, inclusive. All generations are independent, and the random numbers are uniformly distributed.\n   \n2. Call the generated \\( N \\) real numbers \\( x_1, x_2, \\ldots, x_N \\) in ascending order. That is, \\( 0 \\leq x_1 \\leq x_2 \\leq \\ldots \\leq x_N \\leq 1 \\).\n\n3. Your score is given by the following formula:\n\n   \\[\n   \\prod_{i=1}^{N} \\left(1 + \\sum_{j=i+1}^N x_j^A \\right)\n   \\]\n\nCalculate the expected value, modulo \\( 10^9+7 \\), of the score.\n\n**Definition of expected value modulo \\( 10^9+7 \\)**\n\nIt can be proved that the sought expected value is always rational. Furthermore, under the constraints of this problem, it can be proved that if the expected value is expressed as an irreducible fraction \\(\\frac{P}{Q}\\), then \\( Q \\not\\equiv 0 \\pmod{10^9+7} \\). Therefore, there exists a unique integer \\( R \\) such that \\( R \\times Q \\equiv P \\pmod{10^9+7} \\) and \\( 0 \\leq R < 10^9+7 \\). Report this \\( R \\).\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^4 \\)\n- \\( 1 \\leq A \\leq 5 \\times 10^4 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2 1\n```\n\n**Sample Output 1**\n\n```\n666666673\n```\n\nThe expected value of the score is \\( \\frac{5}{3} \\).\n\n**Sample Input 2**\n\n```\n1 1\n```\n\n**Sample Output 2**\n\n```\n1\n```\n\n**Sample Input 3**\n\n```\n2 2\n```\n\n**Sample Output 3**\n\n```\n500000005\n```\n\n**Sample Input 4**\n\n```\n3 2\n```\n\n**Sample Output 4**\n\n```\n142857147\n```\n\n**Sample Input 5**\n\n```\n5 3\n```\n\n**Sample Output 5**\n\n```\n758371066\n```\n\n**Sample Input 6**\n\n```\n10000 12345\n```\n\n**Sample Output 6**\n\n```\n32201773\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Let \\(a_n(y)\\) be the expected value for a real number \\(y\\) (\\(0 \\leq y \\leq 1\\)) and a non-negative integer \\(n\\). Generate \\(n\\) real numbers within \\([0,1]\\) as \\(x_1, \\cdots, x_n\\). If \\(x_1 < \\cdots < x_n < y\\) is not satisfied, output \\(0\\). If they are in ascending order, output \\(\\prod_{1 \\leq i \\leq n} (y^A + \\sum_{i < j \\leq n} x_j^A)\\).\n\nDefine \\(f(y,x) = \\sum_{0 \\leq n} a_n(y)x^n\\). \\(a_n(y)\\) is a polynomial in \\(y\\), and \\(f\\) is a formal power series. We aim to find \\(N! [x^N]f(1,x)\\). Consider choosing one term from \\(y^A, x_{i+1}^A, \\cdots x_N^A\\) for each \\(i\\) and calculating their product, forming a tree. We draw arrows based on choices: from \\(i\\) to \\(j\\) for \\(x_j^A\\), and \\(i\\) to * for choosing \\(y^A\\). This setup reveals an equation for \\(f\\), decomposed into subproblems for each subtree. The weight of a subtree rooted at child \\(v\\) is \\(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt\\).\n\nIf * has \\(k\\) children, subtrees are ordered and multiplied by \\(1/k!\\). Thus, \\(f\\) satisfies: \\(f(y,x) = \\exp(y^A x \\int_{0 \\leq t \\leq y} f(t,x) dt)\\). \\(a_n(y)\\) is a polynomial and a constant multiple of \\(y^{(A+1)n}\\). Write \\(g(z) = f(x,y)\\) with \\(z = y^{A+1}x\\) using power series \\(g(z) = \\sum_{0 \\leq n} b_n z^n\\). Rewrite \\(f\\) for \\(g\\): \\(g(z) = \\exp(\\sum_{0 \\leq n} \\frac{b_n}{(A+1)n+1} z^{n+1})\\).\n\nLet \\(h(z)\\) be inside \\(\\exp\\). Knowing \\([z^n] g\\) allows calculation of \\([z^{n+1}] h(z)\\) and \\([z^{n+1}] g(z)\\). The coefficients of \\(g\\) can be determined in order. Calculate \\([z^{n+1}] g(z)\\) using \\(\\frac{d}{dz}g = \\frac{d}{dz}\\exp(h) = \\frac{d}{dz}h \\times g\\), achievable in \\(O(n)\\). Solve the problem in \\(O(N^2)\\) time overall.\n        [END TEXT]\n \n\n", "problem_ids": ["arc180_f"]}, "abc327_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n### Problem Statement\n\nThere is a keyboard with 26 keys arranged on a number line. The arrangement of this keyboard is represented by a string \\( S \\), which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character \\( S_x \\) is located at coordinate \\( x \\) \\((1 \\leq x \\leq 26)\\). Here, \\( S_x \\) denotes the \\( x \\)-th character of \\( S \\).\n\nYou will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key. Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.\n\n### Constraints\n\n- \\( S \\) is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n### Sample Output 1\n```\n25\n```\n\nFrom pressing the key for `A` to pressing the key for `Z`, you need to move your finger 1 unit at a time in the positive direction, resulting in a total traveled distance of 25. It is impossible to press all keys with a total traveled distance less than 25, so print 25.\n\n### Sample Input 2\n```\nMGJYIZDKSBHPVENFLQURTCWOAX\n```\n\n### Sample Output 2\n```\n223\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        For a character \\(c\\), let \\(X_c\\) be the coordinate of the key corresponding to the character \\(c\\). We need to find \\(|X_A-X_B|+|X_B-X_C|+\\ldots+|X_Y-X_Z|\\). If we can find \\(S\\) from \\(X\\), the sought value can be found using a for loop. An array can correspond the integer \\(0\\) to A, \\(1\\) to B, \\(\\ldots\\), and \\(25\\) to Z, so that \\(X\\) can be managed as an array. Alternatively, an associative array with its key as a character type can be used.\n\nSample code in Python3:\n\n```python\ns = input()\nx = [0] * 26\nfor i in range(26):\n    x[ord(s[i]) - ord(\"A\")] = i\nans = 0\nfor i in range(25):\n    ans += abs(x[i] - x[i + 1])\nprint(ans)\n```\n        [END TEXT]\n        \n \n\n", "problem_ids": ["abc373_b"]}, "abc328_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi eats three plates for breakfast: rice, miso soup, and salad. His table is long and narrow, so he arranged the three plates in a row. The arrangement is given by a string \\( S \\), where the \\( i \\)-th plate from the left is rice if \\( S_i \\) is \\( R \\), miso soup if \\( S_i \\) is \\( M \\), and salad if \\( S_i \\) is \\( S \\).\n\nDetermine whether the plate of rice is to the left of the plate of miso soup.\n\n**Constraints**\n\n- \\(|S| = 3\\)\n- \\( S \\) contains one \\( R \\), one \\( M \\), and one \\( S \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n**Output**\n\nPrint `Yes` if the plate of rice is to the left of the plate of miso soup, and `No` otherwise.\n\n**Sample Input 1**\n\n```\nRSM\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nThe plate of rice is at the 1st position from the left, and the plate of miso soup is at the 3rd position from the left. Since the plate of rice is to the left, print `Yes`.\n\n**Sample Input 2**\n\n```\nSMR\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nThe plates are arranged as salad, miso soup, and rice from left to right.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 360\n\nA - A Healthy Breakfast Editorial by en_translator\n\nFor beginners: If you are new to learning programming, please try \"Welcome to AtCoder\" from the practice contest. There you can find a sample code for each language. If you are not familiar with programming contests, try some problems in \"AtCoder Beginners Selection.\" \"C++\u5165\u9580 AtCoder Programming Guide for beginners (APG4b)\" is a C++ tutorial for competitive programmers (in Japanese).\n\nSolution: Prepare a string variable s. Read input into s. Use a for loop to determine positions of R and M in s. Let pos_r and pos_m be those indices. Use an if statement to print 'Yes' if pos_r < pos_m, otherwise print 'No'. With only six possible strings for \\(S\\), you can manually determine the answer using a conditional branch. Sample code in C++ provided.\n```\n\n \n\n", "problem_ids": ["abc360_a"]}, "abc328_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(N\\) where all elements are between \\(1\\) and \\(2^K - 1\\), inclusive, is called a **good sequence**.\n\nThe **score** of a good sequence \\(A = (A_1, A_2, \\ldots, A_N)\\) is defined as follows:\n- The number of distinct integers that can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) using an integer \\(i\\) between \\(1\\) and \\(N\\), inclusive, and a non-negative integer \\(k\\).\n\nFor example, for \\(A = (3, 5)\\), five integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3,\\) and \\(5\\), so the score is \\(5\\).\n\nFind one good sequence with the maximum score.\n\nFor each input file, you are given \\(T\\) test cases to solve.\n\n### Constraints\n- \\(1 \\leq T \\leq 10^5\\)\n- \\(1 \\leq N \\leq 10^5\\)\n- \\(1 \\leq K \\leq 30\\)\n- The sum of \\(N\\) across the test cases in a single input file is at most \\(2 \\times 10^5\\).\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format. Here, \\(\\text{case}_i\\) denotes the \\(i\\)-th test case.\n\n```\nT\n\\text{case}_1\n\\text{case}_2\n\\vdots\n\\text{case}_T\n```\n\nEach test case is given in the following format:\n```\nN K\n```\n\n### Output\nPrint \\(T\\) lines.\n\nThe \\(i\\)-th line should contain the answer for \\(\\text{case}_i\\).\n\nIf there are multiple good sequences with the maximum score, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n3 3\n7 2\n8 20\n```\n\n### Sample Output 1\n```\n5 6 7\n2 2 3 3 1 3 3\n662933 967505 876482 840117 1035841 651549 543175 781219\n```\n\n**Explanation for the first test case:**\nFor \\(A = (5, 6, 7)\\), seven integers can be expressed as \\(\\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\): \\(0, 1, 2, 3, 5, 6,\\) and \\(7\\), so its score is \\(7\\). Outputs such as \\(A = (7, 4, 5)\\) and \\(A = (6, 5, 4)\\) would also be accepted.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nB - |{floor(A_i/2^k)}| Editorial by evima\n\nIn this explanation, we assume that indices start from \\(0\\). First, it is unnecessary to include elements less than \\(2^{K-1}\\) in \\(A\\). This is because replacing elements less than \\(2^{K-1}\\) with their double will result in the same or a higher score. Therefore, we can limit the elements of \\(A\\) to be between \\(2^{K-1}\\) and \\(2^K-1\\).\n\n1. When \\(N \\geq 2^{K-1}\\): We can include all elements between \\(2^{K-1}\\) and \\(2^K-1\\) in \\(A\\) and set \\(A_i = \\max(1, 2^K - 1 - i)\\) \\((0 \\le i < N)\\).\n\n2. When \\(N < 2^{K-1}\\): Consider an upper bound of the score. For \\(0 \\le x < K\\), consider the number of elements that appear as \\(\\displaystyle \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor\\) between \\(2^x\\) and \\(2^{x+1}-1\\). For each \\(A_i\\), there is at most one \\(k\\) that satisfies \\(\\displaystyle 2^x \\le \\left\\lfloor\\frac{A_i}{2^k} \\right\\rfloor < 2^{x+1}\\), so the number of such elements is at most \\(N\\). On the other hand, there are only \\(2^x\\) integers between \\(2^x\\) and \\(2^{x+1}\\), so the number of elements that appear in this range is at most \\(\\min(N, 2^x)\\). Therefore, by summing over all \\(x\\), the score has an upper bound of \\(\\displaystyle 1 + \\sum_{x=0}^{K-1}\\min(N, 2^x)\\).\n\nThis upper bound can always be achieved. Specifically, construct \\(A\\) as follows: Set \\(A_i\\) to the sum of \\(2^{K-1}\\) and the bit-reversal of \\(i\\). \u201cThe bit-reversal of \\(i\\)\u201d means the value obtained by reversing the \\((K-1)\\)-bit binary representation of \\(i\\).\n\nBy implementing the above, we can solve this problem. The time complexity is \\(O(NK)\\) due to the bit-reversal calculation being the bottleneck.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n\n    def bit_reversal(x):\n        return int(bin(x)[2:].zfill(K - 1)[::-1], 2)\n\n    if N >= 2 ** (K - 1):\n        print(*[max(1, 2**K - i - 1) for i in range(N)])\n    else:\n        print(*[2 ** (K - 1) + bit_reversal(i) for i in range(N)])\n```\n\nAdditionally, you can also solve it by constructing from the highest bit downwards.\n\nSample Implementation (Python3)\n```python\nfor _ in range(int(input())):\n    N, K = map(int, input().split())\n    C = [1]\n    for _ in range(1, K):\n        D = [2 * c for c in C] + [2 * c + 1 for c in C]\n        C = D[:N]\n    while len(C) < N:\n        C.append(1)\n    print(*C)\n```\n```\n \n\n", "problem_ids": ["arc182_b"]}, "abc328_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) giants, each identified by an integer from 1 to \\( N \\). For each giant \\( i \\), when they stand on the ground, their shoulder height is \\( A_i \\) and their head height is \\( B_i \\).\n\nYou can arrange all the giants in a permutation \\( (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\) and stack them one on top of another according to the following rules:\n\n1. Place giant \\( P_1 \\) on the ground. The shoulder height of giant \\( P_1 \\) from the ground is \\( A_{P_1} \\), and the head height is \\( B_{P_1} \\).\n2. Following this, for \\( i = 1, 2, \\ldots, N - 1 \\), place giant \\( P_{i+1} \\) on the shoulders of giant \\( P_i \\). If the shoulder height of giant \\( P_i \\) from the ground is \\( t \\), then the shoulder height of giant \\( P_{i+1} \\) from the ground is \\( t + A_{P_{i+1}} \\), and the head height is \\( t + B_{P_{i+1}} \\).\n\nThe goal is to determine the maximum possible head height from the ground of the topmost giant \\( P_N \\).\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 200,000 \\)\n- \\( 1 \\leq A_i \\leq B_i \\leq 1,000,000,000 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given in the following format:\n\n```\nN\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output:**\n\nPrint the maximum possible height of the head of the topmost giant from the ground.\n\n**Sample Input 1:**\n```\n3\n4 10\n5 8\n2 9\n```\n\n**Sample Output 1:**\n```\n18\n```\n\n*Explanation:* If the permutation \\( (P_1, P_2, P_3) = (2, 1, 3) \\) is chosen, the heights measured from the ground would be as follows:\n\n- Giant 2 will have a shoulder height of 5 and a head height of 8.\n- Giant 1 will be on top, having a shoulder height of 9 and a head height of 15.\n- Giant 3 will be on top, having a shoulder height of 11 and a head height of 18.\n\nThe maximum head height achievable with any arrangement of the giants is 18, and thus, 18 is printed.\n\n**Sample Input 2:**\n```\n5\n1 1\n1 1\n1 1\n1 1\n1 1\n```\n\n**Sample Output 2:**\n```\n5\n```\n\n**Sample Input 3:**\n```\n10\n690830957 868532399\n741145463 930111470\n612846445 948344128\n540375785 925723427\n723092548 925021315\n928915367 973970164\n563314352 832796216\n562681294 868338948\n923012648 954764623\n691107436 891127278\n```\n\n**Sample Output 3:**\n```\n7362669937\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial text:\n\n---\n\nThe height of the topmost giant\u2019s head when \\(P_N\\), i.e., when giant \\(i\\) is the topmost giant, is \\(B_i + \\sum_{j \\neq i}A_j\\). This can be expressed as \\(B_i - A_i + \\sum_{j = 1}^{N} A_j\\), and the answer is the maximum of this value for \\(i = 1, 2, \\ldots, N\\). Since \\(\\sum_{j = 1}^{N} A_j\\) is independent of \\(i\\), it is sufficient to find \\(\\max (B_i - A_i)\\). This can be computed using a for loop in a total of \\(O(N)\\) time.\n\nSample code:\n```python\nn = int(input())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nm = 0\nfor i in range(n):\n    m = max(m, b[i] - a[i])\nans = m + sum(a)\nprint(ans)\n```\n \n\n", "problem_ids": ["abc352_c"]}, "abc328_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n### Problem Statement\n\nThere is a keyboard with 26 keys arranged on a number line. The arrangement of this keyboard is represented by a string \\( S \\), which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character \\( S_x \\) is located at coordinate \\( x \\) \\((1 \\leq x \\leq 26)\\). Here, \\( S_x \\) denotes the \\( x \\)-th character of \\( S \\).\n\nYou will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key. Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.\n\n### Constraints\n\n- \\( S \\) is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n### Sample Output 1\n```\n25\n```\n\nFrom pressing the key for `A` to pressing the key for `Z`, you need to move your finger 1 unit at a time in the positive direction, resulting in a total traveled distance of 25. It is impossible to press all keys with a total traveled distance less than 25, so print 25.\n\n### Sample Input 2\n```\nMGJYIZDKSBHPVENFLQURTCWOAX\n```\n\n### Sample Output 2\n```\n223\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        For a character \\(c\\), let \\(X_c\\) be the coordinate of the key corresponding to the character \\(c\\). We need to find \\(|X_A-X_B|+|X_B-X_C|+\\ldots+|X_Y-X_Z|\\). If we can find \\(S\\) from \\(X\\), the sought value can be found using a for loop. An array can correspond the integer \\(0\\) to A, \\(1\\) to B, \\(\\ldots\\), and \\(25\\) to Z, so that \\(X\\) can be managed as an array. Alternatively, an associative array with its key as a character type can be used.\n\nSample code in Python3:\n\n```python\ns = input()\nx = [0] * 26\nfor i in range(26):\n    x[ord(s[i]) - ord(\"A\")] = i\nans = 0\nfor i in range(25):\n    ans += abs(x[i] - x[i + 1])\nprint(ans)\n```\n        [END TEXT]\n        \n \n\n", "problem_ids": ["abc373_b"]}, "abc328_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi eats three plates for breakfast: rice, miso soup, and salad. His table is long and narrow, so he arranged the three plates in a row. The arrangement is given by a string \\( S \\), where the \\( i \\)-th plate from the left is rice if \\( S_i \\) is \\( R \\), miso soup if \\( S_i \\) is \\( M \\), and salad if \\( S_i \\) is \\( S \\).\n\nDetermine whether the plate of rice is to the left of the plate of miso soup.\n\n**Constraints**\n\n- \\(|S| = 3\\)\n- \\( S \\) contains one \\( R \\), one \\( M \\), and one \\( S \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n**Output**\n\nPrint `Yes` if the plate of rice is to the left of the plate of miso soup, and `No` otherwise.\n\n**Sample Input 1**\n\n```\nRSM\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nThe plate of rice is at the 1st position from the left, and the plate of miso soup is at the 3rd position from the left. Since the plate of rice is to the left, print `Yes`.\n\n**Sample Input 2**\n\n```\nSMR\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nThe plates are arranged as salad, miso soup, and rice from left to right.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 360\n\nA - A Healthy Breakfast Editorial by en_translator\n\nFor beginners: If you are new to learning programming, please try \"Welcome to AtCoder\" from the practice contest. There you can find a sample code for each language. If you are not familiar with programming contests, try some problems in \"AtCoder Beginners Selection.\" \"C++\u5165\u9580 AtCoder Programming Guide for beginners (APG4b)\" is a C++ tutorial for competitive programmers (in Japanese).\n\nSolution: Prepare a string variable s. Read input into s. Use a for loop to determine positions of R and M in s. Let pos_r and pos_m be those indices. Use an if statement to print 'Yes' if pos_r < pos_m, otherwise print 'No'. With only six possible strings for \\(S\\), you can manually determine the answer using a conditional branch. Sample code in C++ provided.\n```\n\n \n\n", "problem_ids": ["abc360_a"]}, "abc329_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 1200 points\n\nProblem Statement:  \nThere is a rooted tree T with N vertices numbered from 1 to N. Vertex 1 is the root, and the parent of vertex i (2 \u2264 i \u2264 N) is P_i (P_i < i).  \n\nA permutation x = (x_1, x_2, ..., x_N) of (1, 2, ..., N) is judged to be a good permutation or not by the following criteria:\n\n1. Consider the following operation on x:\n   - Choose two adjacent elements u and v in x such that u and v are in an ancestor-descendant relationship in T. It does not matter which is the ancestor and which is the descendant. Then, swap u and v.\n\n2. If it is possible to obtain a permutation that is lexicographically strictly smaller than the initial state by performing the above operation zero or more times, x is not a good permutation. If it is impossible to obtain a permutation lexicographically smaller than the initial state by any such operations, x is a good permutation.\n\nYou are given a positive integer B.  \nFor a permutation x, define hash(x) = \u2211(1 \u2264 i \u2264 N) B^(i-1) \u00d7 x_i.  \n\nFind the sum of hash(x) over all good permutations x, modulo 998244353.\n\nWhat is lexicographical order on sequences?  \nA sequence S = (S_1, S_2, ..., S_|S|) is said to be lexicographically smaller than a sequence T = (T_1, T_2, ..., T_|T|) if and only if one of the following conditions holds:\n\n1. |S| < |T| and (S_1, S_2, ..., S_|S|) = (T_1, T_2, ..., T_|S|).\n2. There exists an integer 1 \u2264 i \u2264 min{|S|, |T|} such that:\n   - (S_1, S_2, ..., S_{i-1}) = (T_1, T_2, ..., T_{i-1}).\n   - S_i is smaller than T_i (as a number).\n\nConstraints:\n\n- 2 \u2264 N \u2264 100  \n- 1 \u2264 B < 998244353  \n- 1 \u2264 P_i < i (2 \u2264 i \u2264 N)  \n- All input values are integers.\n\nInput:  \nThe input is given from Standard Input in the following format:  \n\n```\nN B  \nP_2 P_3 ... P_N\n```\n\nOutput:  \nPrint the answer.\n\nSample Input 1:  \n```\n3 100  \n1 1\n```\n\nSample Output 1:  \n```\n50502\n```\n\nFor example, x = (3, 1, 2) is not a good permutation, because by swapping 3 and 1, which are in an ancestor-descendant relationship, we can obtain (1, 3, 2), a lexicographically smaller permutation.  \nIn this sample, the good permutations are x = (1, 2, 3) and x = (1, 3, 2).  \nThus, the answer is hash((1,2,3)) + hash((1,3,2)) = 30201 + 20301 = 50502.\n\nSample Input 2:  \n```\n5 100  \n1 2 3 4\n```\n\nSample Output 2:  \n```\n504030201\n```\n\nIn this sample, any two vertices are in an ancestor-descendant relationship. Therefore, the only good permutation is x = (1, 2, 3, 4, 5).\n\nSample Input 3:  \n```\n10 248730679  \n1 2 1 2 5 6 1 8 1\n```\n\nSample Output 3:  \n```\n856673861\n```\n\nSample Input 4:  \n```\n20 480124393  \n1 2 3 2 3 4 3 8 3 4 11 10 4 14 15 12 17 18 19\n```\n\nSample Output 4:  \n```\n488941820\n```\n\nSolution:\n\n```markdown\n**Editorial for D - Sum of Hash of Lexmin:**\n\nTo determine if a permutation \\(P\\) is \"good,\" check whether there is any ancestor and descendant \\(u < v\\) that appears as an adjacent pair in the order \\(v, u\\). Such a pair is called an \"improvable pair.\" A permutation without any improvable pairs can be shown to be a good permutation. \n\nConsider a permutation \\(P\\) without improvable pairs. If it's possible to obtain a lexicographically smaller permutation \\(Q\\) from \\(P\\), leading to a contradiction, then \\(P\\) must be the lexicographically smallest permutation. For position \\(i\\), where \\(P\\) and \\(Q\\) differ, with \\(Q_i = P_j\\), swap relevant elements \\(P_k\\) and \\(P_j\\) for \\(i \\leq k < j\\), focusing on \\(k = j - 1\\). Since \\(P_{j - 1}\\) is an ancestor of \\(P_j\\), odd arrangements are avoided, solidifying that \\(P\\) leads to \\(Q\\) and supports lexicographic minimality.\n\nTo compute \\(\\operatorname{hash}(P)\\) for all permutations \\(P\\) without any improvable pair, consider counting such \\(P\\) using tree DP. Define \\(dp[v][k]\\) as how many ways you can establish \\(k\\) paths connected by improvable pairs in the subtree rooted at vertex \\(v\\). Arrangements of \\(k\\) paths are \\(k!\\) ways, resolved during DP as subtrees merge, using combinatorics \\({a + b \\choose a}\\).\n\nFor \\(\\operatorname{hash}(P)\\), similar concepts apply. Each element is handled with weights and computed in DP tables, based on paths before and after its position. Each vertex \\(v\\) uses DP tables proportional to the square of its subtree's size. Avoiding possible high complexity, the correct computations achieve a potential \\(O(N^4)\\) efficiency, better than \\(O(N^5)\\), due to optimization techniques reminiscent of reducing some \\(O(N^3)\\) algorithms to \\(O(N^2)\\).\n```\n \n\n", "problem_ids": ["agc068_d"]}, "abc329_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n### Problem Statement\n\nYou are given a permutation \\( P = (P_1, P_2, \\ldots, P_N) \\) of \\( (1, 2, \\ldots, N) \\).\n\nYour objective is to transform this permutation into the identity permutation \\( P_i = i \\) for all \\( i = 1, 2, \\ldots, N \\) by performing the following operation zero or more times:\n\n1. Choose an integer \\( k \\) such that \\( 1 \\leq k \\leq N \\).\n2. If \\( k \\geq 2 \\), sort the elements from the 1st to the \\((k-1)\\)-th position of \\( P \\) in ascending order.\n3. Then, if \\( k \\leq N - 1 \\), sort the elements from the \\((k+1)\\)-th to the \\( N \\)-th position of \\( P \\) in ascending order.\n\nIt can be proved that under the constraints of this problem, it is possible to transform any given permutation \\( P \\) into the identity permutation with a finite number of operations. Your task is to find the minimum number of operations required.\n\nYou have \\( T \\) test cases to solve.\n\n### Constraints\n\n- \\( 1 \\leq T \\leq 10^5 \\)\n- \\( 3 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( P \\) is a permutation of \\( (1, 2, \\ldots, N) \\).\n- All input values are integers.\n- The sum of \\( N \\) across the test cases in a single input is at most \\( 2 \\times 10^5 \\).\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\n...\ncase_T\n```\n\nEach case is presented as follows:\n\n```\nN\nP_1 P_2 ... P_N\n```\n\n### Output\n\nPrint \\( T \\) lines. The \\( i \\)-th line should contain the answer for the \\( i \\)-th test case.\n\n### Sample Input 1\n\n```\n3\n5\n2 1 3 5 4\n3\n1 2 3\n7\n3 2 1 7 5 6 4\n```\n\n### Sample Output 1\n\n```\n1\n0\n2\n```\n\n#### Explanation:\n\n- For the first test case, the operation with \\( k = 3 \\) yields \\( P \\) as \\( (1, 2, 3, 4, 5) \\), requiring 1 operation.\n- The second test case already satisfies \\( P_i = i \\), thus needing 0 operations.\n- For the third test case, perform the operations with \\( k = 4 \\) and then \\( k = 3 \\) successively to achieve the identity permutation \\( (1, 2, 3, 4, 5, 6, 7) \\), requiring 2 operations.\n\nSolution:\n\n---\n\nSince each operation sorts a significant portion of the array, it is expected that the entire array can be sorted with a few operations. In fact:\n\n1. Perform the operation with \\(k=1\\). This sorts the entire array if \\(P_1=1\\) in the initial state. Otherwise, we have \\(P_N \\neq 1\\) after the operation since \\(N \\geq 3\\).\n2. Next, perform the operation with \\(k=N\\). Since \\(P_N \\neq 1\\) before the operation, we have \\(P_1=1\\) after the operation.\n3. Perform the operation with \\(k=1\\). Since \\(P_1=1\\) before the operation, the entire array is certainly sorted after the operation.\n\nBy performing the above, any permutation can be sorted in at most three operations. Therefore, it is sufficient to quickly determine if the array can be sorted in zero, one, or two operations.\n\n- The determination for zero operations is trivial.\n- For one operation, if we fix \\(k\\), it is necessary and sufficient that the minimum and maximum values of \\((P_1, P_2, \\dots, P_{k-1})\\) are \\(1\\) and \\(k-1\\), respectively, and \\(P_k=k\\). This can be checked in \\(O(1)\\) time for each \\(k\\) by taking cumulative \\(\\min\\) and \\(\\max\\), so the overall determination can be done in \\(O(N)\\) time.\n- For two operations, if \\(P_N \\neq 1\\), starting from the second of the three operations, the array can be sorted in two operations. Similarly, if \\(P_1 \\neq N\\), it can be sorted in two operations. Conversely, if \\(P_1=N\\) and \\(P_N=1\\), the relative positions of \\(1\\) and \\(N\\) in \\(P\\) do not change with one operation, leaving them in the order \\(N, 1\\). Therefore, \\(P\\) can be sorted in two or fewer operations \\(\\iff\\) \\(P_1 \\neq N\\) or \\(P_N \\neq 1\\). This can be checked in \\(O(1)\\) time.\n\nFrom the above, the answer for each test case can be found in \\(O(N)\\) time.\n \n\n", "problem_ids": ["arc181_a"]}, "abc329_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 600 points\n\nProblem Statement:\nThere are \\(N\\) stones placed on a 2-dimensional plane. The \\(i\\)-th stone is located at coordinates \\((X_i, Y_i)\\). All stones are located at lattice points in the first quadrant (including the axes).\n\nCount the number of lattice points \\((x, y)\\) where no stone is placed and it is **impossible** to reach \\((-1, -1)\\) from \\((x, y)\\) by repeatedly moving up, down, left, or right by 1 without passing through coordinates where a stone is placed.\n\nMore precisely, count the number of lattice points \\((x, y)\\) where no stone is placed, and there does **not** exist a finite sequence of integer pairs \\((x_0, y_0), \\ldots, (x_k, y_k)\\) that satisfies all of the following four conditions:\n1. \\((x_0, y_0) = (x, y)\\).\n2. \\((x_k, y_k) = (-1, -1)\\).\n3. \\(|x_i - x_{i+1}| + |y_i - y_{i+1}| = 1\\) for all \\(0 \\leq i < k\\).\n4. There is no stone at \\((x_i, y_i)\\) for all \\(0 \\leq i \\leq k\\).\n\nConstraints:\n- \\(0 \\leq N \\leq 2 \\times 10^5\\)\n- \\(0 \\leq X_i, Y_i \\leq 2 \\times 10^5\\)\n- The pairs \\((X_i, Y_i)\\) are distinct.\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nX_1 Y_1\n\\vdots\nX_N Y_N\n```\n\nOutput:\nPrint the number of lattice points that satisfy the conditions.\n\nSample Input 1:\n```\n5\n1 0\n0 1\n2 3\n1 2\n2 1\n```\n\nSample Output 1:\n```\n1\n```\nIt is impossible to reach \\((-1, -1)\\) from \\((1, 1)\\).\n\nSample Input 2:\n```\n0\n```\n\nSample Output 2:\n```\n0\n```\nThere may be cases where no stones are placed.\n\nSample Input 3:\n```\n22\n0 1\n0 2\n0 3\n1 0\n1 4\n2 0\n2 2\n2 4\n3 0\n3 1\n3 2\n3 4\n5 1\n5 2\n5 3\n6 0\n6 4\n7 0\n7 4\n8 1\n8 2\n8 3\n```\n\nSample Output 3:\n```\n6\n```\nThere are six such points: \\((6, 1), (6, 2), (6, 3), (7, 1), (7, 2), (7, 3)\\).\n\nSolution:\n\n```python\n'''\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nG - Go Territory Editorial by en_translator\n\nWe will consider a grid instead of a coordinate plane. We call those cells reachable to (-1,-1) \u201cinside,\u201d \nand unreachable \u201coutside.\u201d We first consider the case where the stones are connected in eight directions. \nBy enumerating eight cells around each cell beforehand, one can easily determine if these cells are inside or \noutside easily with BFS (Breadth First Search). The top-left cell is always outside; by performing BFS from this cell \nin four directions, one can reach all cells outside.\n\nExample: black cells represent lattice points with stones. Then, inspect each row. If there is a segment with \n\u201coutside stone inside \u2026 inside stone outside,\u201d then that segment can be counted as \u201cinside\u201d to count \u201cinside\u201d points. \nBeware of cases with consecutive stones, or stones between inside cells.\n\nNow we consider disconnected cases. It may seem we can consider each connected component independently, \nbut note that there may be a nested structure. After performing BFS for each connected component and determining whether \neach cell is outside or inside, when scanning the entire row, there may be parts like \n\u201coutside stone inside \u2026\u2026 outside stone inside \u2026\u2026 inside stone outside \u2026\u2026 inside stone outside,\u201d where some cells \ninside are labeled outside.\n\nEvery time you encounter \u201coutside, one or more stones, inside,\u201d the nest increases by one; for \n\u201cinside, one or more stones, outside,\u201d it decreases by one. By using this method to manage how many times the current \nposition is surrounded, one can handle this issue. Also, if there are different connected components sufficiently close \nto each other, the label (outside/inside) might be overwritten. This can be avoided by defining that stones are connected \nif the Chebyshev distance is two or less, instead of being eight-adjacent.\n'''\n```\n\n \n\n", "problem_ids": ["abc361_g"]}, "abc329_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere are \\( N \\) servals on a bridge of length \\( L \\). The \\( i \\)-th serval is located at position \\( A_i \\) from the left end of the bridge. Here, \\( 0 < A_1 < A_2 < \\cdots < A_N < L \\) holds. For each \\( i = 1, 2, \\dots, N \\), answer the following question:\n\nThe servals will perform the following three actions in order:\n\n1. **Action 1:** The \\( N - 1 \\) servals other than the \\( i \\)-th serval face left or right.\n2. **Action 2:** The \\( i \\)-th serval faces left or right.\n3. **Action 3:** All servals start moving simultaneously. All servals move at a constant speed of exactly 1 unit distance per unit time. When a serval reaches the end of the bridge, it leaves the bridge. If two servals collide, they both reverse their direction and continue moving.\n\nThe \\( i \\)-th serval is smart and loves this bridge, so when choosing a direction in Action 2, it will observe the directions of the other \\( N-1 \\) servals and choose the direction that allows it to stay on the bridge longer during Action 3. \n\nThere are \\( 2^{N-1} \\) possible combinations of directions for the \\( N-1 \\) servals in Action 1. Find the sum, modulo \\( 998244353 \\), over all these combinations, of the durations the \\( i \\)-th serval can stay on the bridge. It can be proved that the output value is an integer.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 10^{5} \\)\n- \\( 0 < A_1 < A_2 < \\cdots < A_N < L \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN L\nA_1 A_2 \\cdots A_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( k \\)-th line should contain the answer for \\( i = k \\).\n\n**Sample Input 1:**\n\n```\n2 167\n9 24\n```\n\n**Sample Output 1:**\n\n```\n182\n301\n```\n\nFor \\( i = 1 \\), it is always optimal to face right. For \\( i = 2 \\), it is optimal to face the opposite direction from the first serval.\n\n**Sample Input 2:**\n\n```\n1 924\n167\n```\n\n**Sample Output 2:**\n\n```\n757\n```\n\n**Sample Input 3:**\n\n```\n10 924924167\n46001560 235529797 272749755 301863061 359726177 470023587 667800476 696193062 741860924 809211293\n```\n\n**Sample Output 3:**\n\n```\n112048251\n409175578\n167800512\n997730745\n278651538\n581491882\n884751575\n570877705\n747965896\n80750577\n```\n\nSolution:\n\nHere is the cleaned version of the coding problem editorial:\n\n---\n\n**When and where do they leave the bridge?**  \nAfter Action 2, suppose there are \\(l\\) servals facing left: the \\(X_{1}\\)-th, \\(X_{2}\\)-th, \\(\\cdots\\), \\(X_{l}\\)-th servals from left to right. Also, suppose there are \\(r\\) servals facing right: the \\(Y_{1}\\)-th, \\(Y_{2}\\)-th, \\(\\cdots\\), \\(Y_{r}\\)-th servals from left to right.  \n- If \\(i \\leq l\\), the \\(i\\)-th serval will reach the left end, and the time it can stay on the bridge is \\(A_{X_{i}}\\).\n- If \\(l < i\\), the \\(i\\)-th serval will reach the right end, and the time it can stay on the bridge is \\(L - A_{Y_{N-i}}\\).\n\nThis holds because the relative positions of the servals do not change.\n\n**Optimal direction to face:**  \nGiven the properties, if \\((i \\leq l')\\), it is optimal for the \\(i\\)-th serval to face right to reach the left end. If \\((N+1-i \\leq r')\\), it should face left. If \\((l' = i - 1\\) and \\(r' = N - i)\\), evaluate the serval's optimal direction based on comparisons of \\(A_{i}\\) and \\(L - A_{i}\\).\n\n**Considering contributions:**  \nCalculate contributions for:\n\n1. When \\(i \\leq l'\\) and the time \\(i\\) reaches the left end to be \\(A_{j}\\).\n\n2. When \\(N+1-i \\leq r'\\) and the time \\(i\\) reaches the right end to be \\(L - A_{j}\\).\n\n3. When \\((l' = i - 1)\\) and \\((r' = N - i)\\) for the left. Calculate as a polynomial and evaluate using convolution.\n\nBy calculating all of the above and summing contributions, the final result is obtained with a complexity of \\(O(N(\\log{N})^{2})\\).\n\n**C++ Implementation:**  \nIncludes convolution and addition functions, input handling, and binomial calculations for solving the problem effectively.\n \n\n", "problem_ids": ["arc178_e"]}, "abc329_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of length \\(N\\). On this sequence, the following operation can be performed:\n\nChoose \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Replace each of \\(A_{l+1}, A_{l+2}, \\dots, A_{r-1}\\) with \\(A_l\\). The cost of this operation is \\(r-l-1\\).\n\nYou will repeat this operation until there is no \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Find the minimum total cost of such a series of operations.\n\n**Constraints:**\n- \\(3 \\leq N \\leq 5 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq N\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n7\n1 2 3 2 3 2 1\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n_For example, if you perform the operation with \\((l, r) = (3, 5), (2, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,3,3,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\), after which there is no \\(l\\) and \\(r\\) with the said property. The total cost of this series of operations is \\(1+3+5=9\\)._\n\n_On the other hand, if you perform the operation with \\((l, r) = (2, 4), (4, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,2,2,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\). The total cost of this series of operations is \\(1+1+5=7\\)._\n\n**Sample Input 2:**\n```\n5\n1 2 3 4 5\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n40\n1 2 3 4 5 6 7 8 7 6 5 6 7 8 7 6 5 4 3 2 2 1 2 3 4 5 4 5 6 7 8 7 7 6 5 6 6 7 8 8\n```\n\n**Sample Output 3:**\n```\n44\n```\n\nSolution:\n\n```\nHere's a cleaned-up version of the solution:\n\nStarting from a vertex with color \\(A_i\\) and a piece placed on it, create a tree with colored vertices by performing the following steps for \\(i=2,3,\\dots,N\\): Let \\(pos\\) be the current position. If the color of the vertex at \\(pos\\) is \\(A_i\\), do nothing. If there is an adjacent vertex to \\(pos\\) with color \\(A_i\\), move the piece there. If no such vertex exists, create a new adjacent vertex with color \\(A_i\\) and move the piece there. The colors of adjacent vertices are always distinct. \n\nThe state of the sequence corresponds to a walk on this tree, where operations change a walk \\(u\\rightarrow v\\rightarrow v\\rightarrow \\dots \\rightarrow v\\rightarrow u\\) to \\(u\\rightarrow u\\rightarrow u\\rightarrow \\dots \\rightarrow u\\rightarrow u\\). Let \\(start\\) and \\(goal\\) be the start and end points of the walk. The problem is finding the minimum cost to change the walk into a simple path connecting \\(start\\) and \\(goal\\). \n\nCalculate the minimum cost. Consider parts of the walk off the path connecting \\(start\\) and \\(goal\\), like \\(\\dots \\rightarrow a \\rightarrow b \\rightarrow \\dots \\rightarrow b \\rightarrow a \\rightarrow \\dots\\). Convert \\(b \\rightarrow \\dots \\rightarrow b\\) to stay at \\(a\\), with the cost equivalent to the sum of distances to \\(a\\). The problem becomes: \n\nGiven \\(V=(v_1,v_2,\\dots,v_n)\\) with:\n\n\\(v_1=1, v_n=\\max_{1\\leq i \\leq n} v_i\\)\n\\(|v_i-v_{i+1}| \\in \\{0,1\\}\\),\n\nFind the minimum \\(\\sum |v_i-v'_i|\\) for \\(V'=(v'_1,v'_2,\\dots,v'_n)\\) where:\n\n\\(v'_1=v_1, v'_n=v_n\\)\n\\(v'_i \\leq v'_{i+1}\\)\nIf \\(v'_i \\neq v'_{i+1}\\), then \\(v_i=v'_i\\) and \\(v_{i+1}=v'_{i+1}\\).\n\nSolve this using dynamic programming in \\(O(N)\\): \n\nUse \\(dp[k]=\\) the minimum value of \\(\\sum_{k \\leq i} |v_i-v'_i|\\) when \\(v'_k=v_k\\). If \\(v_{k+1}=v_k+1\\), update \\(dp[k] \\leftarrow \\min(dp[k],dp[k+1])\\). Let \\(k'\\) be the smallest \\(i\\ (k < i)\\) such that \\(v_{i}=v_k\\), then update \\(dp[k] \\leftarrow \\min(dp[k],dp[k']+\\sum_{i=k+1}^{k'}|v_k-v_i|)\\).\n```\n \n\n", "problem_ids": ["arc181_f"]}, "abc329_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\nYou are given positive integers \\( N \\), \\( M \\), and \\( K \\), and a sequence of \\( M \\) non-negative integers \\( A = (A_0, A_1, \\ldots, A_{M-1}) \\). Here, \\( 2^{N-1} \\leq K < 2^N \\).\n\nIn the input, \\( K \\) is given as an \\( N \\)-digit number in binary notation, while the other integers are given in decimal notation.\n\nAdditionally, \\( A \\) is not given directly in the input. Instead, for each \\( i = 0, 1, \\ldots, M-1 \\), you are given a sequence of \\( L_i \\) integers \\( X_i = (X_{i,0}, X_{i,1}, \\ldots, X_{i,L_i-1}) \\) such that \\( A_i = \\sum_{j=0}^{L_i-1} 2^{X_{i,j}} \\). Here, \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\).\n\nFind the inversion number, modulo \\( 998244353 \\), of the sequence \\( B = (B_0, B_1, \\ldots, B_{MK-1}) \\) defined as follows:\n\n- For any integer \\( a \\) such that \\( 0 \\leq a < K \\) and any integer \\( b \\) such that \\( 0 \\leq b < M \\), the following holds:\n  - \\( B_{aM+b} \\) is equal to the remainder when \\( \\text{popcount}(a \\land A_b) \\) is divided by \\( 2 \\).\n\n**What is \\(\\operatorname{AND}\\)?**\nThe bitwise \\(\\operatorname{AND}\\) of integers \\( A \\) and \\( B \\), denoted as \\( A \\land B \\), is defined as follows:\n- In the binary representation of \\( A \\land B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) place is \\( 1 \\) if and only if the digits at the \\( 2^k \\) place in the binary representations of both \\( A \\) and \\( B \\) are \\( 1 \\); otherwise, it is \\( 0 \\).\n\nFor example, \\( 3 \\land 5 = 1 \\) (in binary: \\( 011 \\land 101 = 001 \\)).\n\nGenerally, the bitwise \\(\\operatorname{AND}\\) of \\( k \\) integers \\( p_1, p_2, p_3, \\ldots, p_k \\) is defined as \\(((\\ldots ((p_1 \\land p_2) \\land p_3) \\land \\ldots \\land p_k)\\), and it can be proved that this is independent of the order of \\( p_1, p_2, p_3, \\ldots, p_k \\).\n\n**What is \\(\\operatorname{popcount}\\)?**\nFor a non-negative integer \\( x \\), \\(\\operatorname{popcount}(x)\\) is the number of \\( 1 \\)s in the binary representation of \\( x \\). More precisely, for a non-negative integer \\( x \\) such that \\( x = \\sum_{i=0}^{\\infty} b_i 2^i \\) (\\( b_i \\in \\{0, 1\\} \\)), it holds that \\(\\operatorname{popcount}(x) = \\sum_{i=0}^{\\infty} b_i \\).\n\nFor example, \\( 13 \\) is \\( 1101 \\) in binary, so \\(\\operatorname{popcount}(13) = 3\\).\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2^{N-1} \\leq K < 2^N \\)\n- \\( 0 \\leq L_i \\leq N \\)\n- \\(\\sum L_i \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\)\n- All input values are integers.\n- \\( K \\) is given in binary notation.\n- All numbers except \\( K \\) are given in decimal notation.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M\nK\nL_0 X_{0,0} X_{0,1} \\cdots X_{0,L_0-1}\nL_1 X_{1,0} X_{1,1} \\cdots X_{1,L_1-1}\n\\vdots\nL_{M-1} X_{M-1,0} X_{M-1,1} \\cdots X_{M-1,L_{M-1}-1}\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n2 4\n11\n1 0\n2 0 1\n0\n1 1\n```\n\n**Sample Output 1**\n```\n9\n```\n\n**Explanation of Sample 1**\n\\( A = (1, 3, 0, 2) \\), \\( B = (0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1) \\).\n\n**Sample Input 2**\n```\n3 3\n101\n2 1 2\n2 0 1\n1 0\n```\n\n**Sample Output 2**\n```\n23\n```\n\n**Explanation of Sample 2**\n\\( A = (6, 3, 1) \\), \\( B = (0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0) \\).\n\n**Sample Input 3**\n```\n16 7\n1101010000100110\n11 0 1 2 3 7 10 11 12 13 14 15\n7 4 6 8 10 11 12 13\n6 0 1 6 8 10 12\n8 0 3 5 6 10 11 12 13\n10 0 1 2 3 4 5 6 8 12 13\n9 3 4 5 6 8 9 11 14 15\n8 0 4 7 9 10 11 13 14\n```\n\n**Sample Output 3**\n```\n97754354\n```\n\n**Sample Input 4**\n```\n92 4\n10101100101111111111011101111111101011001011111110011110111111101111111110100111100010111011\n23 1 2 5 13 14 20 28 32 34 39 52 56 59 60 62 64 67 69 71 78 84 87 91\n20 15 17 22 28 36 40 43 47 52 53 57 67 72 77 78 81 87 89 90 91\n23 7 8 9 10 11 13 16 19 22 23 30 33 42 49 51 52 58 64 71 73 76 79 83\n22 1 13 19 26 27 28 29 35 39 40 41 46 55 60 62 64 67 74 79 82 89 90\n```\n\n**Sample Output 4**\n```\n291412708\n```\n\nYou are required to find the number modulo \\( 998244353 \\).\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 178\n\nF - Long Sequence Inversion Editorial by evima\n\nThis explanation generally uses \\(0\\)-based indexing. For the inversion number of a binary sequence \\(Y = (Y_{0}, Y_{1}, \\dots, Y_{|Y|-1})\\), the following holds:\n\nIf there are \\(P\\) indices \\(i\\) where \\(Y_{i} = 0\\), and the sum of such indices is \\(Q\\), then the inversion number of \\(Y\\) is \\(Q - \\frac{P(P-1)}{2}\\).\n\nTherefore, we need to find the number of zeros in \\(B\\) and the sum of their indices. Here, we define a sequence of sequences \\(C = (C_{0}, C_{1}, \\dots, C_{M-1})\\) as follows:\n\n\\(C_{i} = (C_{i,0}, C_{i,1}, \\dots, C_{i,K-1})\\) is a sequence of length \\(K\\), where the \\(j\\)-th element \\(C_{i,j}\\) is equal to \\(\\operatorname{popcount}(j \\operatorname{AND} A_{i})\\).\n\nLet \\(P_{i}\\) be the number of \\(0\\)s in \\(C_{i}\\), and \\(Q_{i}\\) be the sum of indices where \\(C_{i}\\) is \\(0\\). The inversion number of \\(B\\) can be expressed as:\n\\[\n\\text{inversion}(B) = \\sum_{i=0}^{M-1}(Q_{i}M + iP_{i}) - \\frac{(\\sum P)(\\sum P - 1)}{2}\n\\]\nThus, if we know \\(P_{i}\\) and \\(Q_{i}\\) for each integer \\(i\\) from 0 to \\(M-1\\), we can determine the answer. To find \\(P_{i}\\) and \\(Q_{i}\\), we need the difference between the number of \\(0\\)s and \\(1\\)s in \\(C_{i}\\), and the difference between the sum of indices where \\(C_{i}\\) is \\(0\\) and where it is \\(1\\).\n\nHere, we find an integer sequence \\(Z\\) such that \\(K = \\sum 2^{Z_{j}}\\) and \\(0 \\leq Z_{0} < Z_{1} < \\cdots < Z_{L-1} = N-1\\). Using \\(Z\\), we decompose the interval \\([0, K)\\) and consider the contribution of each segment to \\(P_{i}\\) and \\(Q_{i}\\).\n\nFor the numbers of \\(0\\)s and \\(1\\)s in the contiguous subsequence \\((C_{i, K-2^{Z_{0}}}, C_{i, K-2^{Z_{0}+1}}, \\dots, C_{i, K-1})\\) in \\(C_{i}\\):\n- If \\((A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are equal to \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (K - 2^{Z_{0}}))\\).\n\nFor the sums of indices where \\(C_{i}\\) is \\(0\\) or \\(1\\):\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) \\geq 2\\), the difference is 0.\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are \\(0\\) or \\(1\\).\n\nThis gives us the contribution of the interval \\([K - 2^{Z_{0}}, K)\\) to \\(P_{i}\\) and \\(Q_{i}\\). We can similarly find the contributions of other intervals. By dividing the intervals appropriately and performing precomputations such as cumulative sums, we can compute \\(P_{i}\\) and \\(Q_{i}\\) in \\(O(L_{i})\\) time. The answer to this problem can be obtained in linear time relative to the input.\n```\n \n\n", "problem_ids": ["arc178_f"]}, "abc330_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi has prepared \\(N\\) dishes for Snuke. The dishes are numbered from 1 to \\(N\\), and dish \\(i\\) has a sweetness of \\(A_i\\) and a saltiness of \\(B_i\\).\n\nTakahashi can arrange these dishes in any order he likes. Snuke will eat the dishes in the order they are arranged, but if at any point the total sweetness of the dishes he has eaten so far exceeds \\(X\\) or the total saltiness exceeds \\(Y\\), he will not eat any further dishes.\n\nTakahashi wants Snuke to eat as many dishes as possible. Find the maximum number of dishes Snuke will eat if Takahashi arranges the dishes optimally.\n\n**Constraints:**\n- \\(1 \\leq N \\leq 80\\)\n- \\(1 \\leq A_i, B_i \\leq 10000\\)\n- \\(1 \\leq X, Y \\leq 10000\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN X Y\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\n```\n\n**Output:**\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 8 4\n1 5\n3 2\n4 1\n5 3\n```\n\n**Sample Output 1:**\n```\n3\n```\n\n*Explanation:*\nConsider the scenario where Takahashi arranges the dishes in the order 2, 3, 1, 4.\n- First, Snuke eats dish 2. The total sweetness so far is 3, and the total saltiness is 2.\n- Next, Snuke eats dish 3. The total sweetness so far is 7, and the total saltiness is 3.\n- Next, Snuke eats dish 1. The total sweetness so far is 8, and the total saltiness is 8.\n- The total saltiness has exceeded \\(Y=4\\), so Snuke will not eat any further dishes.\n\nThus, in this arrangement, Snuke will eat three dishes. No matter how Takahashi arranges the dishes, Snuke will not eat all four dishes, so the answer is 3.\n\n**Sample Input 2:**\n```\n2 1 1\n3 2\n3 2\n```\n\n**Sample Output 2:**\n```\n1\n```\n\n**Sample Input 3:**\n```\n2 100 100\n3 2\n3 2\n```\n\n**Sample Output 3:**\n```\n2\n```\n\n**Sample Input 4:**\n```\n6 364 463\n230 381\n154 200\n328 407\n339 94\n193 10\n115 309\n```\n\n**Sample Output 4:**\n```\n3\n```\n\nSolution:\n\n```python\nEditorial - Japan Registry Services (JPRS) Programming Contest 2024#2 (AtCoder Beginner Contest 364)\n\nE - Maximum Glutton Editorial by en_translator\n\nNotice that the total sweetness and saltiness of all but last dishes that he eats do not exceed \\(X\\) and \\(Y\\), respectively. Let \\(x\\) be the maximum size of a set of dishes \\(S\\) such that the total sweetness does not exceed \\(X\\) and the total saltiness does not exceed \\(Y\\). Then, the answer to the original problem can be represented as \\(\\min(x+1, N)\\). If \\(x<N\\), he can eat at least \\((x+1)\\) dishes by eating those in \\(S\\) first. Thus, he can eat at most \\((x+1)\\) dishes.\n\nTo find the maximum number of dishes that can be chosen such that the total sweetness and saltiness do not exceed \\(X\\) and \\(Y\\), respectively, define a Dynamic Programming (DP) table:\n\n\\(dp_{i,j,k}\\) = (the minimum total saltiness when choosing exactly \\(k\\) dishes from dishes \\(1,2,\\dots,i\\) so that the total sweetness is exactly \\(j\\)).\n\nThis fills the DP table in \\(O(N^2X)\\) time. Find the maximum \\(k\\) such that there exists \\(j\\) with \\(dp'_{N,j,k} \\leq Y\\).\n\nSample code (Python3):\n```python\ndef chmin(a, b):\n    return min(a, b)\n\ndef main():\n    n, x, y = map(int, input().split())\n    a = []\n    b = []\n    for _ in range(n):\n        ai, bi = map(int, input().split())\n        a.append(ai)\n        b.append(bi)\n    \n    dp = [[[float('inf')] * (x + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 0\n    \n    for i in range(n):\n        for j in range(i + 1):\n            for k in range(x + 1):\n                dp[i + 1][j][k] = chmin(dp[i + 1][j][k], dp[i][j][k])\n                if k + a[i] <= x:\n                    dp[i + 1][j + 1][k + a[i]] = chmin(dp[i + 1][j + 1][k + a[i]], dp[i][j][k] + b[i])\n    \n    for i in range(n, -1, -1):\n        for j in range(x + 1):\n            if dp[n][i][j] <= y:\n                print(min(i + 1, n))\n                return\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc364_e"]}, "abc330_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land sells tiles with English letters written on them. Takahashi is thinking of making a nameplate by arranging these tiles in a row.\n\nFind the number, modulo 998244353, of strings consisting of uppercase English letters with a length between 1 and K, inclusive, that satisfy the following conditions:\n\n- For every integer \\(i\\) satisfying \\(1 \\leq i \\leq 26\\), the following holds:\n  - Let \\(a_i\\) be the \\(i\\)-th uppercase English letter in lexicographical order. For example, \\(a_1 = A\\), \\(a_5 = E\\), \\(a_{26} = Z\\).\n  - The number of occurrences of \\(a_i\\) in the string is between 0 and \\(C_i\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq K \\leq 1000\\)\n- \\(0 \\leq C_i \\leq 1000\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nK\nC_1 C_2 \\ldots C_{26}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2\n2 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 1**\n\n```\n10\n```\n\nThe 10 strings that satisfy the conditions are: A, B, C, AA, AB, AC, BA, BC, CA, CB.\n\n**Sample Input 2**\n\n```\n358\n1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 2**\n\n```\n64\n```\n\n**Sample Input 3**\n\n```\n1000\n1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n```\n\n**Sample Output 3**\n\n```\n270274035\n```\n\nSolution:\n\nHere is a concise version of the editorial text:\n\nConsider counting conforming strings for each number of occurrences of z, finding the answer as their sum. Suppose a length-\\(s\\) string has \\(t\\) occurrences of z; there are \\(\\binom{s}{t}\\) ways to determine the positions of z. The other positions form a string of length \\((s-t)\\) without z, where \\(a_i\\) occurs between \\(0\\) and \\(C_i\\) times. Repeat this for letters down to x. Use DP with \\(dp_{i,j}\\) as the number of length-\\(j\\) strings from \\(a_1, a_2, \\ldots, a_i\\) where each \\(a_k\\) occurs between \\(0\\) and \\(C_k\\) times. The formula is \\(dp_{i + 1, j} = \\sum_{k = 0}^{\\min(j, C_{i+1})} dp_{i,j-k} \\binom{j}{k}\\). The answer is \\(\\sum_{j= 1}^{K}dp_{26, j}\\). Precompute binomial coefficients for an \\(O(\\sigma K^2)\\) solution, where \\(\\sigma = 26\\).\n \n\n", "problem_ids": ["abc358_e"]}, "abc330_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n### Problem Statement\n\nThere is a keyboard with 26 keys arranged on a number line. The arrangement of this keyboard is represented by a string \\( S \\), which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character \\( S_x \\) is located at coordinate \\( x \\) \\((1 \\leq x \\leq 26)\\). Here, \\( S_x \\) denotes the \\( x \\)-th character of \\( S \\).\n\nYou will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key. Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.\n\n### Constraints\n\n- \\( S \\) is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n```\nS\n```\n\n### Output\n\nPrint the answer.\n\n### Sample Input 1\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n### Sample Output 1\n```\n25\n```\n\nFrom pressing the key for `A` to pressing the key for `Z`, you need to move your finger 1 unit at a time in the positive direction, resulting in a total traveled distance of 25. It is impossible to press all keys with a total traveled distance less than 25, so print 25.\n\n### Sample Input 2\n```\nMGJYIZDKSBHPVENFLQURTCWOAX\n```\n\n### Sample Output 2\n```\n223\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        For a character \\(c\\), let \\(X_c\\) be the coordinate of the key corresponding to the character \\(c\\). We need to find \\(|X_A-X_B|+|X_B-X_C|+\\ldots+|X_Y-X_Z|\\). If we can find \\(S\\) from \\(X\\), the sought value can be found using a for loop. An array can correspond the integer \\(0\\) to A, \\(1\\) to B, \\(\\ldots\\), and \\(25\\) to Z, so that \\(X\\) can be managed as an array. Alternatively, an associative array with its key as a character type can be used.\n\nSample code in Python3:\n\n```python\ns = input()\nx = [0] * 26\nfor i in range(26):\n    x[ord(s[i]) - ord(\"A\")] = i\nans = 0\nfor i in range(25):\n    ans += abs(x[i] - x[i + 1])\nprint(ans)\n```\n        [END TEXT]\n        \n \n\n", "problem_ids": ["abc373_b"]}, "abc330_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAtCoder Land sells tiles with English letters written on them. Takahashi is thinking of making a nameplate by arranging these tiles in a row.\n\nFind the number, modulo 998244353, of strings consisting of uppercase English letters with a length between 1 and K, inclusive, that satisfy the following conditions:\n\n- For every integer \\(i\\) satisfying \\(1 \\leq i \\leq 26\\), the following holds:\n  - Let \\(a_i\\) be the \\(i\\)-th uppercase English letter in lexicographical order. For example, \\(a_1 = A\\), \\(a_5 = E\\), \\(a_{26} = Z\\).\n  - The number of occurrences of \\(a_i\\) in the string is between 0 and \\(C_i\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq K \\leq 1000\\)\n- \\(0 \\leq C_i \\leq 1000\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nK\nC_1 C_2 \\ldots C_{26}\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n\n```\n2\n2 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 1**\n\n```\n10\n```\n\nThe 10 strings that satisfy the conditions are: A, B, C, AA, AB, AC, BA, BC, CA, CB.\n\n**Sample Input 2**\n\n```\n358\n1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n**Sample Output 2**\n\n```\n64\n```\n\n**Sample Input 3**\n\n```\n1000\n1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n```\n\n**Sample Output 3**\n\n```\n270274035\n```\n\nSolution:\n\nHere is a concise version of the editorial text:\n\nConsider counting conforming strings for each number of occurrences of z, finding the answer as their sum. Suppose a length-\\(s\\) string has \\(t\\) occurrences of z; there are \\(\\binom{s}{t}\\) ways to determine the positions of z. The other positions form a string of length \\((s-t)\\) without z, where \\(a_i\\) occurs between \\(0\\) and \\(C_i\\) times. Repeat this for letters down to x. Use DP with \\(dp_{i,j}\\) as the number of length-\\(j\\) strings from \\(a_1, a_2, \\ldots, a_i\\) where each \\(a_k\\) occurs between \\(0\\) and \\(C_k\\) times. The formula is \\(dp_{i + 1, j} = \\sum_{k = 0}^{\\min(j, C_{i+1})} dp_{i,j-k} \\binom{j}{k}\\). The answer is \\(\\sum_{j= 1}^{K}dp_{26, j}\\). Precompute binomial coefficients for an \\(O(\\sigma K^2)\\) solution, where \\(\\sigma = 26\\).\n \n\n", "problem_ids": ["abc358_e"]}, "abc330_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) villages on a number line. The \\( i \\)-th village is located at coordinate \\( X_i \\), and has \\( P_i \\) villagers.\n\nYou need to answer \\( Q \\) queries. Each query provides two integers, \\( L_i \\) and \\( R_i \\), and asks for the total number of villagers living in villages located between coordinates \\( L_i \\) and \\( R_i \\), inclusive.\n\n**Constraints**\n\n- \\( 1 \\leq N, Q \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq X_1 < X_2 < \\ldots < X_N \\leq 10^9 \\)\n- \\( 1 \\leq P_i \\leq 10^9 \\)\n- \\( -10^9 \\leq L_i \\leq R_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nX_1 X_2 ... X_N\nP_1 P_2 ... P_N\nQ\nL_1 R_1\nL_2 R_2\n...\nL_Q R_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line \\( (1 \\leq i \\leq Q) \\) should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n```\n4\n1 3 5 7\n1 2 3 4\n4\n1 1\n2 6\n0 10\n2 2\n```\n\n**Sample Output 1**\n```\n1\n5\n10\n0\n```\n\n*Consider the first query. The villages between coordinates 1 and 1 are the village at coordinate 1, with 1 villager. Hence, the answer is 1.*\n\n*Consider the second query. The villages between coordinates 2 and 6 are the villages at coordinates 3 and 5, with 2 and 3 villagers, respectively. Hence, the answer is \\( 2 + 3 = 5 \\).*\n\n**Sample Input 2**\n```\n7\n-10 -5 -3 -1 0 1 4\n2 5 6 5 2 1 7\n8\n-7 7\n-1 5\n-10 -4\n-8 10\n-5 0\n-10 5\n-8 7\n-8 -3\n```\n\n**Sample Output 2**\n```\n26\n15\n7\n26\n18\n28\n26\n11\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Beginner Contest 371 - D Problem Editorial\n\nIf we can count the number of villagers with coordinates less than or equal to \\(D\\), the problem can be solved because the answer for a query can be found as \\(f(R_i) - f(L_i-1)\\), where \\(f(D)\\) corresponds to that subproblem. \n\nAssume \\(x\\) and \\(D\\) are between \\(0\\) and \\(N\\). We can precalculate the cumulative sums to find the answer in \\(\\mathrm{O}(1)\\) time. The original difficulty lies in large \\(x\\) and \\(D\\). To handle this, we use binary search. The rightmost village with coordinate \\(D\\) or less can be found with binary search. Along with the cumulative sums, \\(f(D)\\) can be found in \\(\\mathrm{O}(\\log N)\\) time, which is efficient.\n        [END TEXT]\n \n\n", "problem_ids": ["abc371_d"]}, "abc331_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\( A \\) of length \\( N \\). For each \\( t = 1, 2, \\dots, N \\), determine whether \\( A_t \\) is included in a longest increasing subsequence of \\( A \\).\n\nHere, \\( A_t \\) is included in a longest increasing subsequence of \\( A \\) if and only if the following holds:\n- Let \\( L \\) be the length of a longest increasing subsequence of \\( A \\). There exists a strictly increasing integer sequence \\( i = (i_1, i_2, \\dots, i_L) \\ (i_1 < i_2 < \\dots < i_L) \\), where each element is between \\( 1 \\) and \\( N \\), inclusive, that satisfies all of the following conditions:\n  - \\( A_{i_1} < A_{i_2} < \\dots < A_{i_L} \\).\n  - \\( i_k = t \\) for some \\( k \\ (1 \\leq k \\leq L) \\).\n\nYou are given \\( T \\) test cases; solve each of them.\n\n**What is a longest increasing subsequence?**\n- A subsequence of a sequence \\( A \\) is a sequence that can be derived by extracting some elements from \\( A \\) without changing the order.\n- A longest increasing subsequence of a sequence \\( A \\) is a subsequence of \\( A \\) that is strictly increasing with the greatest possible length.\n\n**Constraints**\n- \\( 1 \\leq T \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- The sum of \\( N \\) across all test cases is at most \\( 2 \\times 10^5 \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nT\n\\mathrm{case}_1\n\\mathrm{case}_2\n\\vdots\n\\mathrm{case}_T\n```\nHere, \\(\\mathrm{case}_i\\) represents the input for the \\(i\\)-th case. Each case is given in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\nPrint the answers in the following format:\n```\n\\mathrm{answer}_1\n\\mathrm{answer}_2\n\\vdots\n\\mathrm{answer}_T\n```\nHere, \\(\\mathrm{answer}_i\\) represents the output for the \\(i\\)-th case. For each case, let there be \\( m \\) indices \\( t \\) such that \\( A_t \\) is included in a longest increasing subsequence of \\( A \\), which are \\( i_1, i_2, \\dots, i_m \\) in ascending order. Print these in the following format:\n```\nm\ni_1 i_2 \\cdots i_m\n```\n\n**Sample Input 1**\n```\n1\n5\n2 1 4 5 3\n```\n\n**Sample Output 1**\n```\n4\n1 2 3 4\n```\nOne of the longest increasing subsequences is \\( (2, 4, 5) \\), with a length of 3. Another longest increasing subsequence is \\( (1, 4, 5) \\). However, no longest increasing subsequence includes \\( A_5 \\). Therefore, print \\( 1, 2, 3, 4 \\).\n\n**Sample Input 2**\n```\n2\n6\n2 5 3 4 3 4\n5\n10000 1000 100 1 10\n```\n\n**Sample Output 2**\n```\n5\n1 3 4 5 6\n2\n4 5\n```\n\nSolution:\n\n```\nEditorial - Useless for LIS\n\nGiven a sequence \\( A \\), its Longest Increasing Sequence (LIS) can be found as follows: Apply coordinate compression to assume \\( 1 \\leq A_i \\leq N \\). Use Dynamic Programming (DP) with `dp[i][j]` representing the length of a LIS chosen from the first \\( i \\) elements with the last element \\( j \\). Initialize `dp[0][0] = 0` and `dp[0][1] = dp[0][2] = ... = dp[0][N] = -float('inf')`. The transitions for \\( i = 1, 2, ..., N \\) are:\n\n1. `dp[i][j] = max(dp[i - 1][k] + 1 for k in range(j))` for `j = A[i]`.\n2. `dp[i][j] = dp[i - 1][j]` for `j != A[i]`.\n\nThe length of a LIS is `max(dp[N][k] for k in range(N + 1))`. It is possible to reconstruct a LIS. The complexity can be reduced to \\(O(N \\log N)\\) using a segment tree.\n\nThe DP can be efficiently implemented using pseudocode and a segment tree for segment-max retrieval, which allows LIS length to be obtained in \\(O(N \\log N)\\). Furthermore, by considering constrained LIS lengths `l_i` and `r_i`, and checking if `l_i + r_i - 1 = L`, where `L` is the LIS length, we can address this problem. `l` is found by memorizing DP results, and `r` by reversing the array and applying the same algorithm.\n```\n \n\n", "problem_ids": ["abc354_f"]}, "abc331_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given an integer sequence \\( A \\) of length \\( N \\) and integers \\( K \\) and \\( X \\). Print the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\).\n\n**Constraints:**\n\n- All input values are integers.\n- \\( 1 \\le K \\le N \\le 100 \\)\n- \\( 1 \\le A_i, X \\le 100 \\)\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K X\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\n\nPrint the integer sequence \\( B \\) obtained by inserting the integer \\( X \\) immediately after the \\( K \\)-th element of the sequence \\( A \\), in the following format:\n\n```\nB_1 B_2 \\dots B_{N+1}\n```\n\n**Sample Input 1:**\n\n```\n4 3 7\n2 3 5 11\n```\n\n**Sample Output 1:**\n\n```\n2 3 5 7 11\n```\n\nFor \\( K=3, X=7, \\) and \\( A=(2,3,5,11) \\), we get \\( B=(2,3,5,7,11) \\).\n\n**Sample Input 2:**\n\n```\n1 1 100\n100\n```\n\n**Sample Output 2:**\n\n```\n100 100\n```\n\n**Sample Input 3:**\n\n```\n8 8 3\n9 9 8 2 4 4 3 5\n```\n\n**Sample Output 3:**\n\n```\n9 9 8 2 4 4 3 5 3\n```\n\nSolution:\n\n```\nDenso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09\n\nA - Insert Editorial by en_translator\n\nApproach 1: Construct the sequence \\(B\\)  \nReceive \\(N, K, X\\) and sequence \\(A\\). Insert \\(X\\) after the \\(K\\)-th element of \\(A\\). In Python, use the `insert` method.\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\na.insert(k, x)\nprint(*a)\n```\nThe `print(*a)` outputs the list without brackets.\n\nApproach 2: Print the sequence \\(B\\) sequentially  \nOutput the result without constructing the entire sequence \\(B\\). Receive and print each element of sequence \\(A\\). After printing the \\(K\\)-th element, output \\(X\\).\n\nSample code (Python):\n```python\nn, k, x = map(int, input().split())\nfor i in range(n):\n    a = int(input())\n    if i != 0:\n        print(\" \", end=\"\")\n    print(a, end=\"\")\n    if i == (k - 1):\n        print(\" \", x, end=\"\")\nprint()\n```\n```\n \n\n", "problem_ids": ["abc361_a"]}, "abc331_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a tree with \\( N \\) vertices. The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally. Additionally, you are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\).\n\nDefine \\( f(i, j) \\) as follows:\n\n- If \\( A_i = A_j \\), then \\( f(i, j) \\) is the minimum number of edges needed to traverse from vertex \\( i \\) to vertex \\( j \\).\n- If \\( A_i \\neq A_j \\), then \\( f(i, j) = 0 \\).\n\nCalculate the value of the following expression:\n\n\\[\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(i,j)\n\\]\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- The input graph is a tree.\n- All input values are integers.\n\n**Input**\n\nThe input is provided in the following format:\n\n```\nN\nu_1 v_1\n...\nu_{N-1} v_{N-1}\nA_1 A_2 ... A_N\n```\n\n**Output**\n\nPrint the computed answer.\n\n**Sample Input 1**\n\n```\n4\n3 4\n4 2\n1 2\n2 1 1 2\n```\n\n**Sample Output 1**\n\n```\n4\n```\n\nExplanation: \\( f(1,4)=2, f(2,3)=2 \\). For all other \\( i, j \\) \\((1 \\leq i < j \\leq N)\\), we have \\( f(i,j)=0 \\), so the answer is \\( 2+2=4 \\).\n\n**Sample Input 2**\n\n```\n8\n8 6\n3 8\n1 4\n7 8\n4 5\n3 4\n8 2\n1 2 2 2 3 1 1 3\n```\n\n**Sample Output 2**\n\n```\n19\n```\n\nSolution:\n\n[BEGIN TEXT]\nApplying the centroid decomposition, it is sufficient to find the answer for paths passing through the root. We consider two cases depending on whether the endpoint of the path is the root or not. If it is root, one can naively perform BFS (Breadth-First Search). Otherwise, for each vertex \\(v\\), count how many times the path between vertex \\(v\\) and the root contributes to the answer. Let \\(c_1,\\ldots,c_k\\) be the children of the root, and suppose that vertex \\(v\\) is contained in the subtree \\(c_i\\). Then, the number of times the path between vertex \\(v\\) and the root contributes to the answer is found as (the number of vertices \\(u\\) contained in the current tree such that \\(A_v = A_u\\)) - (the number of vertices \\(u\\) in the subtree \\(c_i\\) such that \\(A_v = A_u\\)). The values required can all be found using a DFS (Depth-First Search), so the problem has been solved.\n[END TEXT]\n \n\n", "problem_ids": ["abc359_g"]}, "abc331_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nFor strings \\( S \\) and \\( T \\) consisting of lowercase English letters, and a string \\( X \\) consisting of \\( 0 \\) and \\( 1 \\), define the string \\( f(S,T,X) \\) consisting of lowercase English letters as follows:\n\nStarting with an empty string, for each \\( i = 1, 2, \\dots, |X| \\), append \\( S \\) to the end if the \\( i \\)-th character of \\( X \\) is \\( 0 \\), and append \\( T \\) to the end if it is \\( 1 \\).\n\nYou are given a string \\( S \\) consisting of lowercase English letters, and strings \\( X \\) and \\( Y \\) consisting of \\( 0 \\) and \\( 1 \\).\n\nDetermine if there exists a string \\( T \\) (which can be empty) such that \\( f(S,T,X) = f(S,T,Y) \\).\n\nYou have \\( t \\) test cases to solve.\n\n### Constraints\n- \\( 1 \\leq t \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq |S| \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq |X|, |Y| \\leq 5 \\times 10^5 \\)\n- \\( S \\) is a string consisting of lowercase English letters.\n- \\( X \\) and \\( Y \\) are strings consisting of \\( 0 \\) and \\( 1 \\).\n- The sum of \\( |S| \\) across all test cases in a single input is at most \\( 5 \\times 10^5 \\).\n- The sum of \\( |X| \\) across all test cases in a single input is at most \\( 5 \\times 10^5 \\).\n- The sum of \\( |Y| \\) across all test cases in a single input is at most \\( 5 \\times 10^5 \\).\n\n### Input\nThe input is given from Standard Input in the following format:\n- \\( t \\)\n- \\( \\text{case}_1 \\)\n- \\( \\dots \\)\n- \\( \\text{case}_t \\)\n\nEach case is given in the following format:\n- \\( S \\)\n- \\( X \\)\n- \\( Y \\)\n\n### Output\nPrint \\( t \\) lines. The \\( i \\)-th line should contain `Yes` if there exists a \\( T \\) that satisfies the condition for the \\( i \\)-th test case, and `No` otherwise.\n\n### Sample Input 1\n```\n3\naraara\n01\n111\naraaaa\n100100\n0010111\nabacabac\n0\n1111\n```\n\n### Sample Output 1\n```\nYes\nNo\nNo\n```\n\nBelow, string concatenation is represented using \\( + \\). For the 1st test case, if \\( T = \\text{ara} \\), then \\( f(S,T,X) = S+T = \\text{araaraara} \\) and \\( f(S,T,Y) = T+T+T = \\text{araaraara} \\), so \\( f(S,T,X) = f(S,T,Y) \\). For the 2nd and 3rd test cases, there is no \\( T \\) that satisfies the condition.\n\n### Sample Input 2\n```\n2\nempty\n10101\n00\nempty\n11111\n111\n```\n\n### Sample Output 2\n```\nYes\nYes\n```\n\n\\( T \\) can be empty.\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 181\n\nB - Annoying String Problem Editorial\n\nIn most cases, the length of \\(f(S,T,X)\\) and \\(f(S,T,Y)\\) being equal reveals the length of \\(T\\). Let\u2019s consider under what conditions \\(S\\) and \\(T\\) satisfy \\(f(S,T,X)=f(S,T,Y)\\) when the lengths of \\(S\\) and \\(T\\) are known.\n\nFor instance, when \\(|S|=6\\) and \\(|T|=4\\), consider when \\(S+T+T+S+T+S=T+T+T+S+T+T+T\\) holds. \\(T\\) must be a prefix of \\(S\\), and \\(S\\) can be expressed as \\(S=T+S'\\) using \\(S'\\) with \\(|S'|=2\\). Replacing this in the equation, we get:\n\n\\(T+S'+T+T+T+S'+T+T+S' = T+T+T+T+S'+T+T+T\\)\n\nNext, \\(S'\\) must be a prefix of \\(T\\), and \\(T\\) can be expressed as \\(T=S'+T'\\) using \\(T'\\) with \\(|T'|=2\\). In this equation, \\(S'=T'\\) is necessary and sufficient since \\(|S'|\\) and \\(|T'|\\) are equal. Representing \\(S\\) and \\(T\\) using \\(S'=T'=U\\), we get \\(S=U+U+U\\) and \\(T=U+U\\). \n\nGeneralizing this process, we find:\n- If the lengths of two strings \\(A\\) and \\(B\\) are equal, \\(A=B\\).\n- If the equation is not trivial, \\(A\\) and \\(B\\) are repetitions of a common string \\(C\\) of length \\(L\\), where \\(L\\) is found using the Euclidean algorithm, so \\(L=\\mathrm{gcd}(n,m)\\).\n\nIf the number of 1s in \\(X\\) and \\(Y\\) is equal, setting \\(T=S\\) satisfies \\(f(S,T,X)=f(S,T,Y)\\), so the answer is Yes. Otherwise, lengths of \\(f(S,T,X)\\) and \\(f(S,T,Y)\\) cannot be equal, so the answer is No.\n\nWhen \\(X\\neq Y\\):\n- \\(f(S,T,X)=f(S,T,Y) \\iff S\\) and \\(T\\) are repetitions of a string \\(U\\) of length \\(\\mathrm{gcd}(|S|,|T|)\\).\n- \\(T\\) exists if \\(S\\) has a period of \\(\\mathrm{gcd}(|S|,|T|)\\).\n\nThis can be checked in \\(O(|S|)\\) time by verifying if the \\(i\\)-th character of \\(S\\) is equal to the \\((i+\\mathrm{gcd}(|S|,|T|))\\)-th character.\n\nProof is done by induction on \\(||S|-|T||\\), showing necessity and sufficiency.\n```\n \n\n", "problem_ids": ["arc181_b"]}, "abc331_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou have \\( N \\) keys numbered \\( 1, 2, \\dots, N \\). Some of these are real keys, while the others are dummies. There is a door, Door X, into which you can insert any number of keys. Door X will open if and only if at least \\( K \\) real keys are inserted.\n\nYou have conducted \\( M \\) tests on these keys. The \\( i \\)-th test went as follows:\n- You inserted \\( C_i \\) keys \\( A_{i,1}, A_{i,2}, \\dots, A_{i,C_i} \\) into Door X.\n- The test result is represented by a single English letter \\( R_i \\).\n  - \\( R_i = \\text{o} \\) means that Door X opened in the \\( i \\)-th test.\n  - \\( R_i = \\text{x} \\) means that Door X did not open in the \\( i \\)-th test.\n\nThere are \\( 2^N \\) possible combinations of which keys are real and which are dummies. Among these, find the number of combinations that do not contradict any of the test results. It is possible that the given test results are incorrect and no combination satisfies the conditions. In such a case, report \\( 0 \\).\n\n**Constraints**\n- \\( N, M, K, C_i, \\text{ and } A_{i,j} \\) are integers.\n- \\( 1 \\le K \\le N \\le 15 \\)\n- \\( 1 \\le M \\le 100 \\)\n- \\( 1 \\le C_i \\le N \\)\n- \\( 1 \\le A_{i,j} \\le N \\)\n- \\( A_{i,j} \\neq A_{i,k} \\) if \\( j \\neq k \\).\n- \\( R_i \\) is \\( \\text{o} \\) or \\( \\text{x} \\).\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M K\nC_1 A_{1,1} A_{1,2} \\dots A_{1,C_1} R_1\nC_2 A_{2,1} A_{2,2} \\dots A_{2,C_2} R_2\n\\vdots\nC_M A_{M,1} A_{M,2} \\dots A_{M,C_M} R_M\n```\n\n**Output**\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2 2\n3 1 2 3 o\n2 2 3 x\n```\n\n**Sample Output 1**\n```\n2\n```\n\nIn this input, there are three keys and two tests were conducted. Two correct keys are required to open Door X. In the first test, keys 1, 2, 3 were used, and Door X opened. In the second test, keys 2, 3 were used, and Door X did not open. There are two combinations of which keys are real and which are dummies that do not contradict any of the test results: Key 1 is real, key 2 is a dummy, and key 3 is real. Key 1 is real, key 2 is real, and key 3 is a dummy.\n\n**Sample Input 2**\n```\n4 5 3\n3 1 2 3 o\n3 2 3 4 o\n3 3 4 1 o\n3 4 1 2 o\n4 1 2 3 4 x\n```\n\n**Sample Output 2**\n```\n0\n```\n\nAs mentioned in the problem statement, the answer may be 0.\n\n**Sample Input 3**\n```\n11 4 9\n10 1 2 3 4 5 6 7 8 9 10 o\n11 1 2 3 4 5 6 7 8 9 10 11 o\n10 11 10 9 8 7 6 5 4 3 2 x\n10 11 9 1 4 3 7 5 6 2 10 x\n```\n\n**Sample Output 3**\n```\n8\n```\n\nSolution:\n\n```python\n# Editorial - AtCoder Beginner Contest 356\n\n# C - Keys Editorial by en_translator:\n\n# By the constraints, the number of keys \\(N \\le 15\\), and the tests \\(M \\le 100\\). \n# There are \\(2^N\\) combinations of authenticities of the keys. We may perform the \\(M\\) tests \n# on all \\(2^N\\) combinations and count the number of proper combinations. \n# \\(2^N \\times M \\le 3.3 \\times 10^6\\) tests are required. \n# Even with \\(N\\) operations per test, the total number of operations is \\(5 \\times 10^7\\), which is fast enough. \n# We achieve this through bitwise enumeration by iterating over \\(i=0,1,\\dots,2^N-1\\). \n# The presence of bit \\(2^k\\) in \\(i\\) determines if the \\((k+1)\\)-th key is real or a dummy. \n# For more details, refer to relevant articles on bitwise enumeration.\n\n# Note that operations exceeding \\(N\\) per test might not meet the execution time limit. \n# Managing whether the \\(k\\)-th key was used limits operations per test to \\(N\\).\n\n# Sample code translated to Python:\nn, m, k = map(int, input().split())\nkey = [[0]*n for _ in range(m)]\nr = []\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c + 1):\n        a = data[j]\n        key[i][a-1] = 1\n    r.append(input().strip())\n\nres = 0\n\nfor i in range(1 << n):\n    tf = [0] * n\n    for j in range(n):\n        if i & (1 << j):\n            tf[j] = 1\n        else:\n            tf[j] = 0\n    jud = True\n    for j in range(m):\n        ck = 0\n        for p in range(n):\n            if key[j][p] == 1 and tf[p] == 1:\n                ck += 1\n        if ck >= k and r[j] == \"x\":\n            jud = False\n        if ck < k and r[j] == \"o\":\n            jud = False\n    if jud:\n        res += 1\n\nprint(res)\n\n# A faster approach using bitwise operations translated to Python:\nn, m, k = map(int, input().split())\nks = [0] * m\nr = [0] * m\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    c = data[0]\n    for j in range(1, c+1):\n        a = data[j] - 1\n        ks[i] |= (1 << a)\n    s = input().strip()\n    if s == \"o\":\n        r[i] = 1\n    else:\n        r[i] = 0\n\nres = 0\n\nfor i in range(1 << n):\n    jud = True\n    for j in range(m):\n        ok = bin(i & ks[j]).count('1')\n        if ok >= k and r[j] == 0:\n            jud = False\n            break\n        if ok < k and r[j] == 1:\n            jud = False\n            break\n    if jud:\n        res += 1\n\nprint(res)\n```\n \n\n", "problem_ids": ["abc356_c"]}, "abc332_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 350 points\n\nProblem Statement:\n\nThe coordinate plane is covered with 2\u00d71 tiles. The tiles are laid out according to the following rules:\n\n- For an integer pair (i, j), the square \\(A_{i,j} = \\{(x, y) \\mid i \\leq x \\leq i+1 \\wedge j \\leq y \\leq j+1\\}\\) is contained in one tile.\n- When i + j is even, \\(A_{i,j}\\) and \\(A_{i+1,j}\\) are contained in the same tile.\n\nTiles include their boundaries, and no two different tiles share a positive area.\n\nNear the origin, the tiles are laid out as follows:\n\n![Tile Layout Image](https://img.atcoder.jp/abc359/7ab121cd550fa78b43845d4ffd7f74b3.png)\n\nTakahashi starts at the point (S_x + 0.5, S_y + 0.5) on the coordinate plane. He can repeat the following move as many times as he likes:\n\n- Choose a direction (up, down, left, or right) and a positive integer n. Move n units in that direction.\n\nEach time he enters a tile, he pays a toll of 1.\n\nFind the minimum toll he must pay to reach the point (T_x + 0.5, T_y + 0.5).\n\nConstraints:\n- 0 \u2264 S_x \u2264 2 \u00d7 10^16\n- 0 \u2264 S_y \u2264 2 \u00d7 10^16\n- 0 \u2264 T_x \u2264 2 \u00d7 10^16\n- 0 \u2264 T_y \u2264 2 \u00d7 10^16\n- All input values are integers.\n\nInput:\n\nThe input is given from Standard Input in the following format:\n```\nS_x S_y\nT_x T_y\n```\n\nOutput:\n\nPrint the minimum toll Takahashi must pay.\n\nSample Input 1:\n```\n5 0\n2 5\n```\n\nSample Output 1:\n```\n5\n```\n\nFor example, Takahashi can pay a toll of 5 by moving as follows:\n\n![Movement Image](https://img.atcoder.jp/abc359/187d19c48a9a0fcedb2602063689ee77.png)\n\n- Move left by 1. Pay a toll of 0.\n- Move up by 1. Pay a toll of 1.\n- Move left by 1. Pay a toll of 0.\n- Move up by 3. Pay a toll of 3.\n- Move left by 1. Pay a toll of 0.\n- Move up by 1. Pay a toll of 1.\n\nIt is impossible to reduce the toll to 4 or less, so print 5.\n\nSample Input 2:\n```\n3 1\n4 1\n```\n\nSample Output 2:\n```\n0\n```\n\nThere are cases where no toll needs to be paid.\n\nSample Input 3:\n```\n2552608206527595 5411232866732612\n771856005518028 7206210729152763\n```\n\nSample Output 3:\n```\n1794977862420151\n```\n\nNote that the value to be output may exceed the range of a 32-bit integer.\n\nSolution:\n\n```\nHere is the cleaned-up version of the editorial:\n\n---\n\nFor simplicity, we may assume that the start and goal are in the left half of a tile. If \\(S_x + S_y\\) is odd, subtract \\(1\\) from \\(S_x\\). One can travel freely between the left and right halves, so traveling from the left half of one tile to another is a complete move. By paying a toll of \\(1\\), one can make either of these two moves:\n\n1. Move by \\(1\\) vertically and by \\(1\\) horizontally.\n2. Move by \\(2\\) horizontally.\n\nSuppose one could travel from \\((S_x, S_y)\\) to \\((T_x, T_y)\\) by making the first move \\(a\\) times and the second \\(b\\) times. The following conditions must hold:\n\n\\(\\lvert S_y - T_y \\rvert \\leq a\\)\n\n\\(\\lvert S_x - T_x \\rvert \\leq a + 2b\\)\n\n\\(a > 0\\) or \\(S_x - T_x \\equiv 2b \\pmod{4}\\)\n\nConversely, if a pair of non-negative integers \\((a, b)\\) satisfies these conditions, then one can make the specified moves to travel from \\((S_x, S_y)\\) to \\((T_x, T_y)\\).\n\nWe aim to minimize the toll \\(a + b\\) while respecting \\((0 \\leq a, 0 \\leq b)\\) and the above conditions. With \\(0 \\leq b\\) and \\(\\lvert S_y - T_y \\rvert \\leq a\\), it is necessary that \\(\\lvert S_y - T_y \\rvert \\leq a + b\\). \n\nAdditionally, \\(\\frac{\\lvert S_x - T_x \\rvert + \\lvert S_y - T_y \\rvert}{2} \\leq a + b\\).\n\nConversely, \\((a, b) = \\left( \\lvert S_y - T_y \\rvert, \\max\\left\\lbrace 0, \\frac{\\lvert S_x - T_x \\rvert - \\lvert S_y - T_y \\rvert}{2} \\right\\rbrace \\right)\\) always satisfies all the conditions, thus ensuring one or both equations hold as an equality.\n\nHence, the minimum toll is:\n\n\\[\\max\\left\\lbrace \\lvert S_y - T_y \\rvert, \\frac{\\lvert S_x - T_x \\rvert + \\lvert S_y - T_y \\rvert}{2} \\right\\rbrace = \\frac{\\lvert S_y - T_y \\rvert + \\max \\lbrace \\lvert S_x - T_x \\rvert, \\lvert S_y - T_y \\rvert \\rbrace}{2}\\].\n\nBelow is the sample code:\n\n```python\nSx, Sy = map(int, input().split())\nTx, Ty = map(int, input().split())\n\nif (Sx + Sy) % 2 == 1:\n    Sx -= 1\nif (Tx + Ty) % 2 == 1:\n    Tx -= 1\n\nDx = abs(Sx - Tx)\nDy = abs(Sy - Ty)\n\nprint((Dy + max(Dx, Dy)) // 2)\n```\n\n---\n```\n \n\n", "problem_ids": ["abc359_c"]}, "abc332_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 900 points\n\nProblem Statement:\nWe have a long, thin piece of paper whose thickness can be ignored. We perform the following operation 100 times: lift the right end and fold it so that it aligns with the left end using the center as a crease. After completing the 100 folds, we unfold the paper back to its original state. At this point, there are \\(2^{100} - 1\\) creases on the paper, which can be classified into two types: mountain folds and valley folds. The figure below represents the state after performing the operation twice, where red solid lines represent mountain folds and red dashed lines represent valley folds.\n\nAbout mountain and valley folds:\n- A crease is a mountain fold if it is folded so that the back sides of the paper come together at the crease.\n- A crease is a valley fold if it is folded so that the front sides of the paper come together at the crease.\n\nYou are given a sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of N non-negative integers where \\(0 = A_1 < A_2 < \\dots < A_N \\leq 10^{18}\\).\n\nFor each integer \\(i\\) from 1 through \\(2^{100} - A_N - 1\\), define \\(f(i)\\) as follows:\n- The number of \\(k = 1, 2, \\dots, N\\) such that the \\((i + A_k)\\)-th crease from the left is a mountain fold.\n\nFind the maximum value among \\(f(1), f(2), \\dots, f(2^{100} - A_N - 1)\\).\n\nConstraints:\n- \\(1 \\leq N \\leq 10^3\\)\n- \\(0 = A_1 < A_2 < \\dots < A_N \\leq 10^{18}\\)\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\nOutput:\nPrint the answer in one line.\n\nSample Input 1:\n```\n4\n0 1 2 3\n```\n\nSample Output 1:\n```\n3\n```\n\nExplanation:\nIf mountain and valley folds are represented by M and V, respectively, there is a contiguous subsequence of creases like MMVM. There is no contiguous subsequence like MMMM, so the answer is 3.\n\nSample Input 2:\n```\n6\n0 2 3 5 7 8\n```\n\nSample Output 2:\n```\n4\n```\n\nSolution:\n\n```\nAtCoder Regular Contest 184 - C: Mountain and Valley Folds Editorial\n\nFirst, observe the structure of the creases. If we extract only the odd-numbered creases, the mountain and valley folds continue as VMVM.... If we extract only the even-numbered creases, this structure recurs. When grouping the creases based on the least significant bit that is 1 in the binary representation of their indices, each group forms a sequence like VMVM.... This can be proved using mathematical induction, among other methods, and is utilized in the solution.\n\nLet \\(f(a, k)\\) be the answer to the problem when taking \\(i\\) satisfying \\(i \\bmod 4 = k\\) for the sequence \\(a = (a_1, a_2, \\dots ,a_m)\\). When \\(k = 0, 2\\), the contribution to the answer from the odd elements of \\(a\\) is uniquely determined. When \\(k = 1, 3\\), the contribution from the even elements of \\(a\\) is uniquely determined, because the type (mountain or valley) of the fold at position \\(a_x + i\\) depends only on \\(i \\bmod 4\\).\n\nFor elements whose contribution is not uniquely determined\u2014namely, the even elements when \\(k = 0, 2\\), and the odd elements when \\(k = 1, 3\\)\u2014extract and divide them by \\(2\\) (rounded down) to form a sequence \\(b = (b_1, b_2, \\dots ,b_l)\\). The contribution of these elements is counted recursively as \\(\\max \\left( f\\left( b, \\left\\lceil \\frac{k}{2} \\right\\rceil \\right),\\ f\\left( b, \\left\\lceil \\frac{k}{2} \\right\\rceil + 2 \\right) \\right)\\). This recursive structure of the creases and the fact that 100 operations is sufficiently many in regard to the constraints make the approach viable.\n\nElements derived from a particular element of \\(A\\) appear in \\(a\\) at most \\(\\log_2 \\max A\\) times during recursion, making this solution efficient. With appropriate implementation, the computational complexity is \\(O(N \\log \\max A)\\).\n```\n \n\n", "problem_ids": ["arc184_c"]}, "abc332_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nA pair of binary strings \\( (S, T) \\) is called **good** if and only if the following conditions are satisfied:\n\n1. \\( S \\) and \\( T \\) contain the same number of \\( 0 \\)s.\n2. \\( S \\) and \\( T \\) contain the same number of \\( 1 \\)s.\n\nParticularly, for a good string pair \\( (S, T) \\), \\( S \\) and \\( T \\) have the same length.\n\nFor a good string pair \\( (S, T) \\), we define an undirected graph \\( G(S, T) \\) as follows:\n\n- Let \\( L \\) be the length of \\( S \\). Create a graph \\( g \\) with vertices \\( 1, 2, \\cdots, L \\).\n- Let \\( n \\) be the number of \\( 0 \\)s in \\( S \\). Let the indices of \\( 0 \\)s in \\( S \\) be \\( 1 \\leq a_1 < a_2 < \\cdots < a_n \\leq L \\). Let the indices of \\( 0 \\)s in \\( T \\) be \\( 1 \\leq b_1 < b_2 < \\cdots < b_n \\leq L \\). For each \\( 1 \\leq i \\leq n \\), add an edge between vertices \\( a_i \\) and \\( b_i \\) to \\( g \\).\n- Let \\( m \\) be the number of \\( 1 \\)s in \\( S \\). Let the indices of \\( 1 \\)s in \\( S \\) be \\( 1 \\leq c_1 < c_2 < \\cdots < c_m \\leq L \\). Let the indices of \\( 1 \\)s in \\( T \\) be \\( 1 \\leq d_1 < d_2 < \\cdots < d_m \\leq L \\). For each \\( 1 \\leq i \\leq m \\), add an edge between vertices \\( c_i \\) and \\( d_i \\) to \\( g \\).\n\nThe graph \\( g \\) obtained through the above steps is \\( G(S, T) \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\cdots, A_N) \\) of length \\( N \\). Find one good string pair \\( (S, T) \\) satisfying all of the following conditions:\n\n- Let \\( L \\) be the length of \\( S \\). It satisfies \\( N \\leq L \\leq 10^5 \\).\n- For each pair \\( 1 \\leq i, j \\leq N \\), vertices \\( i \\) and \\( j \\) belong to the same connected component in \\( G(S, T) \\) if and only if \\( A_i = A_j \\).\n\nIt can be proved that a solution always exists under the constraints of this problem.\n\n### Constraints\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq N \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n### Output\nPrint a solution in the following format:\n```\nL\nS\nT\n```\nHere, \\( L \\) is the length of \\( S \\) and \\( T \\).\n\nIf multiple solutions exist, any of them will be accepted.\n\n### Sample Input 1\n```\n3\n1 2 1\n```\n\n### Sample Output 1\n```\n4\n0011\n1100\n```\nFor the \\( S \\) and \\( T \\) in the sample output, we obtain \\( G(S, T) \\) as follows:\n- Prepare a graph \\( g \\) with 4 vertices.\n- The indices of \\( 0 \\)s in \\( S \\) are \\( (1, 2) \\), and the indices of \\( 0 \\)s in \\( T \\) are \\( (3, 4) \\). Add edges \\( (1, 3) \\) and \\( (2, 4) \\) to \\( g \\).\n- The indices of \\( 1 \\)s in \\( S \\) are \\( (3, 4) \\), and the indices of \\( 1 \\)s in \\( T \\) are \\( (1, 2) \\). Add edges \\( (3, 1) \\) and \\( (4, 2) \\) to \\( g \\).\n\n\\( G(S, T) \\) has a connected component with vertices \\( (1, 3) \\) and another with vertices \\( (2, 4) \\). This satisfies all the conditions, so this \\( (S, T) \\) is a valid output.\n\n### Sample Input 2\n```\n5\n1 2 3 4 5\n```\n\n### Sample Output 2\n```\n5\n01010\n01010\n```\n\n### Sample Input 3\n```\n6\n1 1 1 1 1 1\n```\n\n### Sample Output 3\n```\n6\n011111\n111110\n```\n\n### Sample Input 4\n```\n10\n1 2 3 2 4 3 4 4 5 6\n```\n\n### Sample Output 4\n```\n21\n000101010111100011011\n011010000010101111110\n```\n\nSolution:\n\n[BEGIN TEXT]\nHere's the cleaned version of the solution:\n\nFirst, initialize \\(S = 0 \\times N\\) (a string of \\(N\\) 0s), and \\(T = 1 \\times N\\). To satisfy the conditions, perform these operations: \n\n1. Append 0 to the end of \\(S\\), and 0 to the end of \\(T\\).\n2. Append 1 to the end of \\(S\\), and 0 to the end of \\(T\\).\n\nTrack the connected components of unmatched 0s and 1s. Let \\(x_1, x_2, \\cdots, x_k\\) be the components of unmatched 0s in \\(S\\), and \\(y_1, y_2, \\cdots, y_k\\) be for 1s in \\(T\\). Adding 0 to both \\(S\\) and \\(T\\) cyclically shifts \\(x\\) one position left. Adding 1 to \\(S\\) and 0 to \\(T\\) removes \\(x_1\\) and \\(y_1\\) and connects \\(x_1\\) and \\(y_1\\).\n\nTo meet \\(A\\), prepare a permutation \\(P\\) aligning with \\(A\\)'s cycle decomposition and connect \\(x_1\\) and \\(y_1\\) when \\(x_1 = A_{y_1}\\). The operations number is \\(O(N^2)\\).\n[END TEXT]\n \n\n", "problem_ids": ["agc068_b"]}, "abc332_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integer sequences of length \\( N \\): \\( A = (A_1, A_2, \\cdots, A_N) \\) and \\( B = (B_1, B_2, \\cdots, B_N) \\), and an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n- Choose integers \\( i \\) and \\( j \\) (where \\( 1 \\leq i, j \\leq N \\)) such that \\( |i-j| \\leq K \\). Then, change the value of \\( A_i \\) to \\( A_j \\).\n\nDetermine whether it is possible to make \\( A \\) identical to \\( B \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 125000 \\)\n- \\( 1 \\leq K < N \\leq 250000 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- The sum of \\( N \\) across all test cases in each input is at most 250000.\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\nB_1 B_2 \\cdots B_N\n```\n\n**Output Format**\n\nFor each test case, print `Yes` if it is possible to make \\( A \\) identical to \\( B \\), and `No` otherwise.\n\n**Sample Input 1**\n\n```\n4\n3 1\n1 1 2\n1 2 2\n5 4\n2 4 5 1 3\n2 1 3 2 2\n13 1\n3 1 3 3 5 3 3 4 2 2 2 5 1\n5 3 3 3 4 2 2 2 2 5 5 1 3\n20 14\n10 6 6 19 13 16 15 15 2 10 2 16 9 12 2 6 13 5 5 9\n5 9 6 2 10 19 16 15 13 12 10 2 9 6 5 16 19 12 15 13\n```\n\n**Sample Output 1**\n\n```\nYes\nYes\nNo\nYes\n```\n\n**Explanation for Sample Input 1**\n\nConsider the first test case. If we operate with \\( i=2 \\) and \\( j=3 \\), the value of \\( A_2 \\) will be changed to \\( A_3=2 \\), resulting in \\( A=(1,2,2) \\).\n\nSolution:\n\n```\nOfficial\n\nB - Near Assignment Editorial by evima\n\nIf \\(A = B\\), it is clearly possible, so we consider other cases. Consider two cases based on the value of \\(K\\).\n\nCase \\(K = 1\\): Considering the result of run-length encoding of the elements in \\(A\\), it can \u201cdecrease\u201d through operations, but not \u201cincrease.\u201d From this, we can deduce that the result of run-length encoding of \\(B\\) must be a subsequence of the run-length encoded \\(A\\). This condition is also sufficient because we can perform operations that extend the subsequence of \\(A\\) corresponding to \\(B\\). This solves the case where \\(K = 1\\).\n\nCase \\(K \\geq 2\\): Looking at the operations in reverse, they can be seen as follows:\n\nChoose \\(i,j\\) that satisfy \\(|i-j| \\leq K\\) and \\(B_i = B_j\\), then change \\(B_i\\) to any desired value. First, if no operation can be performed on \\(B\\), the answer is No. Also, if there is a value in \\(B\\) that does not appear in \\(A\\), the answer is No. Actually, in all other cases, the answer is Yes. Let\u2019s reinterpret the part where \\(B_i\\) can be changed to any desired value as an operation where \\(B_i\\) is changed to a wildcard \\(*\\). By performing one operation on \\(B\\), we create a state where there is exactly one \\(*\\). The involvement of \\(*\\) enables us to swap adjacent elements in \\(B\\).\n\nIf you want to change \\(*x\\) to \\(x*\\): think of \\(*x\\) as \\(xx\\) and perform the operation to turn it into \\(x*\\). If you want to change \\(*xy\\) to \\(*yx\\): follow the steps \\(*xy \\to yxy \\to yx* \\to y*x \\to *yx\\).\n\nBy combining these operations, you can remove all duplicates in \\(B\\) and arrange them in any desired order. In particular, you can arrange \\(B\\) to match \\(A\\). Therefore, it can be determined that \\(A\\) can be transformed into \\(B\\). Implementing the above operations directly yields an \\(O(N)\\) solution. The sample code below lazily uses sorting and is an \\(O(N\\log N)\\) solution.\n```\n \n\n", "problem_ids": ["arc183_b"]}, "abc333_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nN AtCoder users have gathered to play AtCoder RPS 2. The i-th user's name is \\( S_i \\) and their rating is \\( C_i \\).\n\nAtCoder RPS 2 is played as follows:\n1. Assign the numbers \\( 0, 1, \\dots, N - 1 \\) to the users in lexicographical order of their usernames.\n2. Let \\( T \\) be the sum of the ratings of the N users. The user assigned the number \\( T \\mod N \\) is the winner.\n\nPrint the winner's username.\n\n**What is lexicographical order?**\n\nLexicographical order, simply put, means \"the order in which words appear in a dictionary.\" More precisely, the algorithm to determine the order of two distinct strings \\( S \\) and \\( T \\) consisting of lowercase English letters is as follows:\n\n- If \\( S \\) is lexicographically smaller than \\( T \\), we write \\( S < T \\), and if \\( S \\) is larger, we write \\( S > T \\).\n1. Let \\( L \\) be the length of the shorter string among \\( S \\) and \\( T \\). Check if \\( S_i \\) and \\( T_i \\) match for \\( i = 1, 2, \\dots, L \\).\n2. If there exists an \\( i \\) such that \\( S_i \\neq T_i \\), let \\( j \\) be the smallest such \\( i \\). Compare \\( S_j \\) and \\( T_j \\). If \\( S_j \\) is alphabetically smaller than \\( T_j \\), then \\( S < T \\). Otherwise, \\( S > T \\). The algorithm ends here.\n3. If there is no \\( i \\) such that \\( S_i \\neq T_i \\), compare the lengths of \\( S \\) and \\( T \\). If \\( S \\) is shorter than \\( T \\), then \\( S < T \\). If \\( S \\) is longer, then \\( S > T \\). The algorithm ends here.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( S_i \\) is a string consisting of lowercase English letters with length between 3 and 16, inclusive.\n- \\( S_1, S_2, \\dots, S_N \\) are all distinct.\n- \\( 1 \\leq C_i \\leq 4229 \\)\n- \\( C_i \\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN\nS_1 C_1\nS_2 C_2\n\\vdots\nS_N C_N\n```\n\n**Output:**\n\nPrint the answer on a single line.\n\n**Sample Input 1:**\n```\n3\ntakahashi 2\naoki 6\nsnuke 5\n```\n\n**Sample Output 1:**\n```\nsnuke\n```\n\n*Explanation:*\nThe sum of the ratings of the three users is 13. Sorting their names in lexicographical order yields aoki, snuke, takahashi, so aoki is assigned number 0, snuke is 1, and takahashi is 2. Since \\( 13 \\mod 3 = 1 \\), print snuke, who is assigned number 1.\n\n**Sample Input 2:**\n```\n3\ntakahashi 2813\ntakahashixx 1086\ntakahashix 4229\n```\n\n**Sample Output 2:**\n```\ntakahashix\n```\n\nSolution:\n\n```\nEditorial - Panasonic Programming Contest 2024\uff08AtCoder Beginner Contest 354\uff09\n\nSolution:\nMost mainstream programming languages provide lexicographical comparison of strings as a function in the standard library or a language feature. With this feature, implementation will be simple. For example in Python, the < operator compares strings in lexicographical order. The total rating \\(T\\) of the users can be found using a for loop. Then one can find \\(T \\bmod N\\) to find the index of the winner. Also, one has to find the number assigned to each user. This can be done by sorting the user\u2019s name in lexicographical order. Most languages provide a sorting function, which enables us concise implementation.\n\nThe complexity of sorting strings:\nLet \\(\\displaystyle M = \\sum_{i=1}^{N} |S_i| \\). With merge sort, the complexity is \\(O(M \\log N)\\). This is due to the fact that lexicographical comparison of two strings \\(a\\) and \\(b\\) can be done in \\(O(\\min(|a|, |b|))\\) time. In Python, the sorted function uses Timsort, which runs in \\(O(n \\log n)\\) time, where n is the number of elements which are being sorted; it performs well for string comparison. It can also be solved in \\(O(M)\\) time using SA-IS for example.\n```\n \n\n", "problem_ids": ["abc354_b"]}, "abc333_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nIn the AtCoder World Tour Finals 2800, `N` contestants participated, and a total of five problems were presented. Each problem is assigned an integer score of at least 1 point, and the problems are numbered so that the scores are non-decreasing from problem 1 to problem 5. There are no partial points. Similar to the usual AtCoder rules, ranking is done as follows: The contestant with the higher total score ranks higher. In case of a tie, the one with the smaller penalty ranks higher. In this problem, we do not consider the situation where multiple contestants have the same total score and penalty.\n\nAoki, a reporter covering the finals, noted the following information:\n1. The number of participants `N`.\n2. Which problems each contestant solved. `A[i, j] = 1` means the `i`-th contestant (1 \u2264 `i` \u2264 `N`) correctly solved problem `j`, and `A[i, j] = 0` means they did not.\n3. The rank of each contestant. The `i`-th contestant (1 \u2264 `i` \u2264 `N`) was ranked `R[i]`-th.\n\nHowever, when he started writing the article, he realized he did not note the scores and penalties. Furthermore, he realized there might be inconsistencies in the information he noted. Now, solve the following problem:\n\nAssume that he correctly noted information 1 and 2. Let `D[i]` be the actual rank of contestant `i` (1 \u2264 `i` \u2264 `N`), and find the minimum possible total squared error `(D[1] - R[1])^2 + (D[2] - R[2])^2 + ... + (D[N] - R[N])^2`.\n\nYou have `T` test cases to process.\n\n## Constraints\n- `1 \u2264 T \u2264 10^5`\n- `2 \u2264 N \u2264 3 \u00d7 10^5`\n- Each `A[i,1], A[i,2], A[i,3], A[i,4], A[i,5]` is 0 or 1 (1 \u2264 `i` \u2264 `N`).\n- The sum of `A[i,1], A[i,2], A[i,3], A[i,4], A[i,5]` is at least 1 (1 \u2264 `i` \u2264 `N`).\n- `1 \u2264 R[i] \u2264 N` (1 \u2264 `i` \u2264 `N`)\n- `R[1], R[2], ..., R[N]` are distinct.\n- The total value of `N` across all test cases is at most 3 \u00d7 10^5.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format. Here `case_i` represents the `i`-th test case (1 \u2264 `i` \u2264 `T`).\n\n```\nT\ncase_1\ncase_2\n...\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN\nA[1,1] A[1,2] A[1,3] A[1,4] A[1,5]\nA[2,1] A[2,2] A[2,3] A[2,4] A[2,5]\n...\nA[N,1] A[N,2] A[N,3] A[N,4] A[N,5]\nR[1] R[2] ... R[N]\n```\n\n## Output\n\nPrint the answers.\n\n## Sample Input 1\n\n```\n6\n4\n0 1 1 0 0\n1 0 0 1 0\n1 1 0 1 0\n1 0 1 0 0\n1 2 3 4\n8\n0 1 0 0 0\n1 1 0 1 0\n0 1 1 0 1\n1 0 0 0 0\n1 1 0 1 0\n0 1 0 0 0\n0 0 0 1 0\n0 1 1 1 1\n7 4 2 8 3 6 5 1\n6\n1 1 0 0 0\n0 0 1 0 0\n1 1 1 0 0\n0 0 0 1 0\n1 1 1 1 0\n0 0 0 0 1\n1 2 3 4 5 6\n6\n1 1 0 0 0\n0 0 1 0 0\n1 1 1 0 0\n0 0 0 1 0\n1 1 1 1 0\n0 0 0 0 1\n6 5 4 3 2 1\n20\n0 0 0 0 1\n0 0 1 0 0\n1 1 0 0 1\n1 0 1 0 1\n0 0 0 1 1\n0 0 1 1 1\n1 1 1 1 0\n1 1 0 1 0\n0 0 1 1 0\n1 0 1 0 0\n0 1 0 0 1\n0 1 1 1 1\n1 1 1 1 1\n0 1 0 1 0\n1 0 0 0 1\n1 1 1 0 0\n0 1 1 1 0\n0 0 0 1 0\n1 1 1 0 1\n1 1 0 1 1\n7 18 3 5 19 11 13 2 4 10 14 15 17 6 16 9 8 12 1 20\n15\n0 0 1 1 0\n0 0 0 1 0\n0 0 0 0 1\n0 0 1 1 1\n1 1 0 0 1\n0 1 1 1 0\n1 1 1 1 1\n0 1 1 0 1\n1 1 0 1 0\n1 0 0 1 1\n1 0 1 0 0\n1 1 0 1 1\n0 1 0 1 0\n1 1 0 0 0\n0 1 0 0 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n```\n\n## Sample Output 1\n\n```\n6\n0\n26\n0\n1054\n428\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - AtCoder Regular Contest 177\n\nSolution to the problem:\nThere are only \\(113\\) scoring distributions for the contest that need to be considered. Once the scoring distribution is determined, arranging the penalties so that the smaller \\(R_i\\) values correspond to smaller penalties (within ties) will always minimize the squared error. Using something like `sorted`, the solution can be obtained in approximately \\(113N \\log N\\) computations.\n\nExample Scoring Distributions:\n- [1, 1, 1, 1, 1]\n- [1, 1, 1, 1, 2]\n... \n- [4, 5, 6, 7, 8]\n\nSteps to the solution:\n1. Consider scoring distributions based on problem-solving instances and ensure scores are non-decreasing.\n2. Extend the approach to contests with 5 problems, considering intersection points of hyperplanes in a 5-dimensional space.\n3. Prune duplicates and non-eligible scoring distributions, reducing the number of distributions to \\(113\\), allowing timely computations for input constraints.\n\nSample Implementation (Python):\n```python\n# Sample scoring distributions candidates\nCandidates = [ /* List of scoring distributions */ ]\n\ndef get_error(N, A, R, Score):\n    Sorted = []\n    for i in range(N):\n        sum_scores = sum(A[i][j] * Score[j] for j in range(5))\n        Sorted.append((sum_scores, -R[i]))\n    Sorted.sort(reverse=True)\n\n    error = 0\n    for i in range(N):\n        idx1 = -Sorted[i][1]\n        idx2 = i + 1\n        error += (idx1 - idx2) * (idx1 - idx2)\n    return error\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = [list(map(int, input().split())) for _ in range(N)]\n        R = list(map(int, input().split()))\n\n        answer = float('inf')\n        for cand in Candidates:\n            result = get_error(N, A, R, cand)\n            answer = min(answer, result)\n        print(answer)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis concise edit provides essential problem-solving steps, example scoring distributions, and the complete Python implementation code without unnecessary information.\n        [END TEXT]\n \n\n", "problem_ids": ["arc177_e"]}, "abc333_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\) and a prime \\( P \\).\n\nCount the number, modulo \\( P \\), of undirected connected graphs \\( G \\) of \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) that satisfy the following conditions:\n\n1. There are no self-loops in \\( G \\). Note that multiple edges are allowed.\n2. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) remains connected. In other words, \\( G \\) is edge-biconnected.\n3. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) is no longer edge-biconnected.\n\nTwo graphs are considered different if and only if there exists a pair of distinct vertices \\( (u,v) \\) such that the numbers of edges connecting \\( u \\) and \\( v \\) in the two graphs are different.\n\n**Constraints**\n\n- \\( 2 \\le N \\le 50 \\)\n- \\( 10^9 < P < 1.01 \\times 10^9 \\)\n- \\( P \\) is prime.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**  \n```\n2 1005976817\n```\n\n**Sample Output 1**  \n```\n1\n```\n\n**Sample Input 2**  \n```\n5 1000837403\n```\n\n**Sample Output 2**  \n```\n372\n```\n\n**Sample Input 3**  \n```\n10 1001160547\n```\n\n**Sample Output 3**  \n```\n789846604\n```\n\n**Sample Input 4**  \n```\n20 1006779551\n```\n\n**Sample Output 4**  \n```\n888612770\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Grand Contest 067 - E: Biconnected Graph Editorial by Kubic\n\nIf an edge is deleted, the remaining graph will form a chain after shrinking biconnected components; it will become a cycle if the edge is added back. Solve the problem for each biconnected component and multiply the answers. In the subproblem, there's an additional edge connecting two vertices, allowing them to reach each other through the cycle. Repeat this method by taking an edge connected to vertex \\(1\\), leading to subproblems formatted as:\n\nCount good graphs of \\(n\\) vertices with the first \\(k\\) vertices able to reach each other externally.\n\nConsider the distribution of the first \\(k\\) vertices:\n\n\\(\\forall 1\\le u,v\\le k\\), \\(C(u),C(v)\\) are not adjacent in the cycle, where \\(C(u)\\) is the biconnected component containing \\(u\\).\n\nDP through the cycle without constraining the edge choice so every good graph is counted \\(\\deg(1)\\) times. Store \\(\\deg(1)\\) in the DP state and divide the final answer by it.\n\nTime complexity: \\(O(n^5)\\). Some \\(O(n^6)\\) solutions with small constants may pass.\n        [END TEXT]\n \n\n", "problem_ids": ["agc067_e"]}, "abc333_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\nYou are given positive integers \\(N\\) and \\(K\\).\n\nAn integer sequence of length \\(NK\\) is called a **good** integer sequence if each integer from \\(1\\) to \\(N\\) appears exactly \\(K\\) times in the sequence.\n\nLet \\(S\\) be the number of good integer sequences. Find the \\(\\operatorname{floor}((S+1)/2)\\)-th good integer sequence in lexicographical order. Here, \\(\\operatorname{floor}(x)\\) represents the largest integer not exceeding \\(x\\).\n\n### What is lexicographical order for sequences?\nA sequence \\(S = (S_1,S_2,\\ldots,S_{|S|})\\) is **lexicographically smaller** than a sequence \\(T = (T_1,T_2,\\ldots,T_{|T|})\\) if either 1. or 2. below holds:\n1. \\(|S| < |T|\\) and \\((S_1,S_2,\\ldots,S_{|S|}) = (T_1,T_2,\\ldots,T_{|S|})\\).\n2. There exists an integer \\(1 \\leq i \\leq \\min\\lbrace |S|, |T| \\rbrace\\) such that both of the following hold:\n   - \\((S_1,S_2,\\ldots,S_{i-1}) = (T_1,T_2,\\ldots,T_{i-1})\\)\n   - \\(S_i\\) is (numerically) smaller than \\(T_i\\).\n\n### Constraints\n- \\(1 \\leq N \\leq 500\\)\n- \\(1 \\leq K \\leq 500\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\n```\n\n### Output\nPrint the desired integer sequence, with elements separated by spaces.\n\n### Sample Input 1\n```\n2 2\n```\n\n### Sample Output 1\n```\n1 2 2 1\n```\n\nThere are six good integer sequences:\n- (1,1,2,2)\n- (1,2,1,2)\n- (1,2,2,1)\n- (2,1,1,2)\n- (2,1,2,1)\n- (2,2,1,1)\n\nTherefore, the answer is the 3rd sequence in lexicographical order, (1,2,2,1).\n\n### Sample Input 2\n```\n1 5\n```\n\n### Sample Output 2\n```\n1 1 1 1 1\n```\n\n### Sample Input 3\n```\n6 1\n```\n\n### Sample Output 3\n```\n3 6 5 4 2 1\n```\n\n### Sample Input 4\n```\n3 3\n```\n\n### Sample Output 4\n```\n2 2 2 1 3 3 3 1 1\n```\n\nSolution:\n\n```python\ndef lexicographically_largest_sequence(N, K):\n    sequence = []\n    \n    if N % 2 == 0:\n        # When N is even\n        first_element = N // 2\n        sequence.extend([first_element] * K)\n        remaining_elements = list(range(1, first_element)) + list(range(first_element + 1, N + 1))\n        remaining_elements.sort(reverse=True)\n    else:\n        # When N is odd\n        first_element = (N + 1) // 2\n        sequence.extend([first_element] * K)\n        remaining_elements = list(range(1, first_element)) + list(range(first_element + 1, N + 1))\n        remaining_elements.sort(reverse=True)\n    \n    # Append the remaining elements to form the final sequence\n    sequence.extend(remaining_elements[:N-K])\n    \n    return sequence\n\n# Testing the function with an example case\nN = 7\nK = 3\nresult = lexicographically_largest_sequence(N, K)\nprint(\"Lexicographically largest sequence:\", result)\n```\n\nConsider two cases based on the parity of \\(N\\).\n\nWhen \\(N\\) is even: The number of good sequences starting with \\(1,2,\\cdots,N/2\\) matches exactly with those starting with \\(N/2+1,\\cdots,N\\). Therefore, the desired sequence is the lexicographically largest one among the good sequences that start with \\(N/2\\). This can be obtained simply by sorting the remaining elements in descending order.\n\nWhen \\(N\\) is odd: The number of good sequences starting with \\(1,2,\\cdots,(N-1)/2\\) matches exactly with those starting with \\((N+3)/2,\\cdots,N\\). Thus, the first element of the desired sequence will be \\((N+1)/2\\). The next step is to find the sequence that is exactly at the middle in lexicographical order among the sequences obtained by arranging the remaining elements. Now, let\u2019s consider the second element. If \\((N+1)/2\\) remains, we can apply the same logic, and thus the second element will also be \\((N+1)/2\\). In the end, the first \\(K\\) elements will be \\((N+1)/2\\). The remaining part of the sequence can be obtained in the same way as in the even case, so this case is resolved as well.\n\nImplementing the above steps directly yields an \\(O(NK)\\) time solution.\n\n \n\n", "problem_ids": ["arc183_a"]}, "abc333_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\nYou are given positive integers \\( N \\), \\( M \\), and \\( K \\), and a sequence of \\( M \\) non-negative integers \\( A = (A_0, A_1, \\ldots, A_{M-1}) \\). Here, \\( 2^{N-1} \\leq K < 2^N \\).\n\nIn the input, \\( K \\) is given as an \\( N \\)-digit number in binary notation, while the other integers are given in decimal notation.\n\nAdditionally, \\( A \\) is not given directly in the input. Instead, for each \\( i = 0, 1, \\ldots, M-1 \\), you are given a sequence of \\( L_i \\) integers \\( X_i = (X_{i,0}, X_{i,1}, \\ldots, X_{i,L_i-1}) \\) such that \\( A_i = \\sum_{j=0}^{L_i-1} 2^{X_{i,j}} \\). Here, \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\).\n\nFind the inversion number, modulo \\( 998244353 \\), of the sequence \\( B = (B_0, B_1, \\ldots, B_{MK-1}) \\) defined as follows:\n\n- For any integer \\( a \\) such that \\( 0 \\leq a < K \\) and any integer \\( b \\) such that \\( 0 \\leq b < M \\), the following holds:\n  - \\( B_{aM+b} \\) is equal to the remainder when \\( \\text{popcount}(a \\land A_b) \\) is divided by \\( 2 \\).\n\n**What is \\(\\operatorname{AND}\\)?**\nThe bitwise \\(\\operatorname{AND}\\) of integers \\( A \\) and \\( B \\), denoted as \\( A \\land B \\), is defined as follows:\n- In the binary representation of \\( A \\land B \\), the digit at the \\( 2^k \\) (\\( k \\geq 0 \\)) place is \\( 1 \\) if and only if the digits at the \\( 2^k \\) place in the binary representations of both \\( A \\) and \\( B \\) are \\( 1 \\); otherwise, it is \\( 0 \\).\n\nFor example, \\( 3 \\land 5 = 1 \\) (in binary: \\( 011 \\land 101 = 001 \\)).\n\nGenerally, the bitwise \\(\\operatorname{AND}\\) of \\( k \\) integers \\( p_1, p_2, p_3, \\ldots, p_k \\) is defined as \\(((\\ldots ((p_1 \\land p_2) \\land p_3) \\land \\ldots \\land p_k)\\), and it can be proved that this is independent of the order of \\( p_1, p_2, p_3, \\ldots, p_k \\).\n\n**What is \\(\\operatorname{popcount}\\)?**\nFor a non-negative integer \\( x \\), \\(\\operatorname{popcount}(x)\\) is the number of \\( 1 \\)s in the binary representation of \\( x \\). More precisely, for a non-negative integer \\( x \\) such that \\( x = \\sum_{i=0}^{\\infty} b_i 2^i \\) (\\( b_i \\in \\{0, 1\\} \\)), it holds that \\(\\operatorname{popcount}(x) = \\sum_{i=0}^{\\infty} b_i \\).\n\nFor example, \\( 13 \\) is \\( 1101 \\) in binary, so \\(\\operatorname{popcount}(13) = 3\\).\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 2^{N-1} \\leq K < 2^N \\)\n- \\( 0 \\leq L_i \\leq N \\)\n- \\(\\sum L_i \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq X_{i,0} < X_{i,1} < \\cdots < X_{i,L_i-1} < N \\)\n- All input values are integers.\n- \\( K \\) is given in binary notation.\n- All numbers except \\( K \\) are given in decimal notation.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN M\nK\nL_0 X_{0,0} X_{0,1} \\cdots X_{0,L_0-1}\nL_1 X_{1,0} X_{1,1} \\cdots X_{1,L_1-1}\n\\vdots\nL_{M-1} X_{M-1,0} X_{M-1,1} \\cdots X_{M-1,L_{M-1}-1}\n```\n\n**Output**\nPrint the answer.\n\n**Sample Input 1**\n```\n2 4\n11\n1 0\n2 0 1\n0\n1 1\n```\n\n**Sample Output 1**\n```\n9\n```\n\n**Explanation of Sample 1**\n\\( A = (1, 3, 0, 2) \\), \\( B = (0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1) \\).\n\n**Sample Input 2**\n```\n3 3\n101\n2 1 2\n2 0 1\n1 0\n```\n\n**Sample Output 2**\n```\n23\n```\n\n**Explanation of Sample 2**\n\\( A = (6, 3, 1) \\), \\( B = (0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0) \\).\n\n**Sample Input 3**\n```\n16 7\n1101010000100110\n11 0 1 2 3 7 10 11 12 13 14 15\n7 4 6 8 10 11 12 13\n6 0 1 6 8 10 12\n8 0 3 5 6 10 11 12 13\n10 0 1 2 3 4 5 6 8 12 13\n9 3 4 5 6 8 9 11 14 15\n8 0 4 7 9 10 11 13 14\n```\n\n**Sample Output 3**\n```\n97754354\n```\n\n**Sample Input 4**\n```\n92 4\n10101100101111111111011101111111101011001011111110011110111111101111111110100111100010111011\n23 1 2 5 13 14 20 28 32 34 39 52 56 59 60 62 64 67 69 71 78 84 87 91\n20 15 17 22 28 36 40 43 47 52 53 57 67 72 77 78 81 87 89 90 91\n23 7 8 9 10 11 13 16 19 22 23 30 33 42 49 51 52 58 64 71 73 76 79 83\n22 1 13 19 26 27 28 29 35 39 40 41 46 55 60 62 64 67 74 79 82 89 90\n```\n\n**Sample Output 4**\n```\n291412708\n```\n\nYou are required to find the number modulo \\( 998244353 \\).\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 178\n\nF - Long Sequence Inversion Editorial by evima\n\nThis explanation generally uses \\(0\\)-based indexing. For the inversion number of a binary sequence \\(Y = (Y_{0}, Y_{1}, \\dots, Y_{|Y|-1})\\), the following holds:\n\nIf there are \\(P\\) indices \\(i\\) where \\(Y_{i} = 0\\), and the sum of such indices is \\(Q\\), then the inversion number of \\(Y\\) is \\(Q - \\frac{P(P-1)}{2}\\).\n\nTherefore, we need to find the number of zeros in \\(B\\) and the sum of their indices. Here, we define a sequence of sequences \\(C = (C_{0}, C_{1}, \\dots, C_{M-1})\\) as follows:\n\n\\(C_{i} = (C_{i,0}, C_{i,1}, \\dots, C_{i,K-1})\\) is a sequence of length \\(K\\), where the \\(j\\)-th element \\(C_{i,j}\\) is equal to \\(\\operatorname{popcount}(j \\operatorname{AND} A_{i})\\).\n\nLet \\(P_{i}\\) be the number of \\(0\\)s in \\(C_{i}\\), and \\(Q_{i}\\) be the sum of indices where \\(C_{i}\\) is \\(0\\). The inversion number of \\(B\\) can be expressed as:\n\\[\n\\text{inversion}(B) = \\sum_{i=0}^{M-1}(Q_{i}M + iP_{i}) - \\frac{(\\sum P)(\\sum P - 1)}{2}\n\\]\nThus, if we know \\(P_{i}\\) and \\(Q_{i}\\) for each integer \\(i\\) from 0 to \\(M-1\\), we can determine the answer. To find \\(P_{i}\\) and \\(Q_{i}\\), we need the difference between the number of \\(0\\)s and \\(1\\)s in \\(C_{i}\\), and the difference between the sum of indices where \\(C_{i}\\) is \\(0\\) and where it is \\(1\\).\n\nHere, we find an integer sequence \\(Z\\) such that \\(K = \\sum 2^{Z_{j}}\\) and \\(0 \\leq Z_{0} < Z_{1} < \\cdots < Z_{L-1} = N-1\\). Using \\(Z\\), we decompose the interval \\([0, K)\\) and consider the contribution of each segment to \\(P_{i}\\) and \\(Q_{i}\\).\n\nFor the numbers of \\(0\\)s and \\(1\\)s in the contiguous subsequence \\((C_{i, K-2^{Z_{0}}}, C_{i, K-2^{Z_{0}+1}}, \\dots, C_{i, K-1})\\) in \\(C_{i}\\):\n- If \\((A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are equal to \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (K - 2^{Z_{0}}))\\).\n\nFor the sums of indices where \\(C_{i}\\) is \\(0\\) or \\(1\\):\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) \\geq 2\\), the difference is 0.\n- If \\(\\operatorname{popcount}(A_{i} \\operatorname{AND} (2^{Z_{0}} - 1)) = 0\\), all elements are \\(0\\) or \\(1\\).\n\nThis gives us the contribution of the interval \\([K - 2^{Z_{0}}, K)\\) to \\(P_{i}\\) and \\(Q_{i}\\). We can similarly find the contributions of other intervals. By dividing the intervals appropriately and performing precomputations such as cumulative sums, we can compute \\(P_{i}\\) and \\(Q_{i}\\) in \\(O(L_{i})\\) time. The answer to this problem can be obtained in linear time relative to the input.\n```\n \n\n", "problem_ids": ["arc178_f"]}, "abc334_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given an integer sequence \\(A = (A_1, A_2, \\dots, A_N)\\) of length \\(N\\). On this sequence, the following operation can be performed:\n\nChoose \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Replace each of \\(A_{l+1}, A_{l+2}, \\dots, A_{r-1}\\) with \\(A_l\\). The cost of this operation is \\(r-l-1\\).\n\nYou will repeat this operation until there is no \\(l\\) and \\(r\\) \\((1 \\leq l < r \\leq N)\\) such that \\(A_l = A_r\\), \\(A_{l+1} = A_{l+2} = \\dots = A_{r-1}\\), and \\(A_{l+1} \\neq A_l\\). Find the minimum total cost of such a series of operations.\n\n**Constraints:**\n- \\(3 \\leq N \\leq 5 \\times 10^5\\)\n- \\(1 \\leq A_i \\leq N\\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\dots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n7\n1 2 3 2 3 2 1\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n_For example, if you perform the operation with \\((l, r) = (3, 5), (2, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,3,3,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\), after which there is no \\(l\\) and \\(r\\) with the said property. The total cost of this series of operations is \\(1+3+5=9\\)._\n\n_On the other hand, if you perform the operation with \\((l, r) = (2, 4), (4, 6), (1, 7)\\) in this order, \\(A\\) changes as follows: \\((1,2,3,2,3,2,1) \\rightarrow (1,2,2,2,3,2,1) \\rightarrow (1,2,2,2,2,2,1) \\rightarrow (1,1,1,1,1,1,1)\\). The total cost of this series of operations is \\(1+1+5=7\\)._\n\n**Sample Input 2:**\n```\n5\n1 2 3 4 5\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n40\n1 2 3 4 5 6 7 8 7 6 5 6 7 8 7 6 5 4 3 2 2 1 2 3 4 5 4 5 6 7 8 7 7 6 5 6 6 7 8 8\n```\n\n**Sample Output 3:**\n```\n44\n```\n\nSolution:\n\n```\nHere's a cleaned-up version of the solution:\n\nStarting from a vertex with color \\(A_i\\) and a piece placed on it, create a tree with colored vertices by performing the following steps for \\(i=2,3,\\dots,N\\): Let \\(pos\\) be the current position. If the color of the vertex at \\(pos\\) is \\(A_i\\), do nothing. If there is an adjacent vertex to \\(pos\\) with color \\(A_i\\), move the piece there. If no such vertex exists, create a new adjacent vertex with color \\(A_i\\) and move the piece there. The colors of adjacent vertices are always distinct. \n\nThe state of the sequence corresponds to a walk on this tree, where operations change a walk \\(u\\rightarrow v\\rightarrow v\\rightarrow \\dots \\rightarrow v\\rightarrow u\\) to \\(u\\rightarrow u\\rightarrow u\\rightarrow \\dots \\rightarrow u\\rightarrow u\\). Let \\(start\\) and \\(goal\\) be the start and end points of the walk. The problem is finding the minimum cost to change the walk into a simple path connecting \\(start\\) and \\(goal\\). \n\nCalculate the minimum cost. Consider parts of the walk off the path connecting \\(start\\) and \\(goal\\), like \\(\\dots \\rightarrow a \\rightarrow b \\rightarrow \\dots \\rightarrow b \\rightarrow a \\rightarrow \\dots\\). Convert \\(b \\rightarrow \\dots \\rightarrow b\\) to stay at \\(a\\), with the cost equivalent to the sum of distances to \\(a\\). The problem becomes: \n\nGiven \\(V=(v_1,v_2,\\dots,v_n)\\) with:\n\n\\(v_1=1, v_n=\\max_{1\\leq i \\leq n} v_i\\)\n\\(|v_i-v_{i+1}| \\in \\{0,1\\}\\),\n\nFind the minimum \\(\\sum |v_i-v'_i|\\) for \\(V'=(v'_1,v'_2,\\dots,v'_n)\\) where:\n\n\\(v'_1=v_1, v'_n=v_n\\)\n\\(v'_i \\leq v'_{i+1}\\)\nIf \\(v'_i \\neq v'_{i+1}\\), then \\(v_i=v'_i\\) and \\(v_{i+1}=v'_{i+1}\\).\n\nSolve this using dynamic programming in \\(O(N)\\): \n\nUse \\(dp[k]=\\) the minimum value of \\(\\sum_{k \\leq i} |v_i-v'_i|\\) when \\(v'_k=v_k\\). If \\(v_{k+1}=v_k+1\\), update \\(dp[k] \\leftarrow \\min(dp[k],dp[k+1])\\). Let \\(k'\\) be the smallest \\(i\\ (k < i)\\) such that \\(v_{i}=v_k\\), then update \\(dp[k] \\leftarrow \\min(dp[k],dp[k']+\\sum_{i=k+1}^{k'}|v_k-v_i|)\\).\n```\n \n\n", "problem_ids": ["arc181_f"]}, "abc334_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nFor positive integers \\( x \\) and \\( y \\), define \\( f(x, y) \\) as follows:\n- Interpret the decimal representations of \\( x \\) and \\( y \\) as strings and concatenate them in this order to obtain a string \\( z \\). The value of \\( f(x, y) \\) is the value of \\( z \\) when interpreted as a decimal integer.\n\nFor example, \\( f(3, 14) = 314 \\) and \\( f(100, 1) = 1001 \\).\n\nYou are given a sequence of positive integers \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Find the value of the following expression modulo \\( 998244353 \\):\n\n\\[\n\\sum_{i=1}^{N-1} \\sum_{j=i+1}^N f(A_i, A_j)\n\\]\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n3\n3 14 15\n```\n\n**Sample Output 1:**\n```\n2044\n```\n\n- \\( f(A_1, A_2) = 314 \\)\n- \\( f(A_1, A_3) = 315 \\)\n- \\( f(A_2, A_3) = 1415 \\)\n\nThus, the answer is \\( f(A_1, A_2) + f(A_1, A_3) + f(A_2, A_3) = 2044 \\).\n\n**Sample Input 2:**\n```\n5\n1001 5 1000000 1000000000 100000\n```\n\n**Sample Output 2:**\n```\n625549048\n```\n\nBe sure to calculate the value modulo \\( 998244353 \\).\n\nSolution:\n\n        Here is the cleaned version of the text, focusing solely on the solution content:\n\n---\n\nWe reinterpret \\(f(x,y)\\) in a more useful form: \\(f(x,y) = 10^{\\mathrm{len}(y)} x + y\\), where \\(\\mathrm{len}(y)\\) is the length of \\(y\\) interpreted as a string. For each \\(i\\), let us find the contributions of \\(A_i\\) in the form of \\(f(*,A_i)\\) and of \\(f(A_i, *)\\). The former is easy; \\(f(*,A_i)\\) has the term \\(A_i\\) itself, so the contribution to the answer is \\((i-1)A_i\\). We consider the latter. The contribution is \\(\\sum_{k=1}^{10} d_k 10^{k} A_i\\), where \\(d_k\\) is the number of \\(j\\) such that \\(i < j\\) and \\(\\mathrm{len}(A_j) = k\\). \\(d_k\\) can be updated in a constant time for each \\(i\\), so the latter contribution can be computed in \\(\\mathrm{O}(\\log M)\\) for each \\(i\\), where \\(M\\) is the maximum value in \\(A\\). Therefore, the answer has been found in a total of \\(\\mathrm{O}(N\\log M)\\) time.\n\nSample code (Python 3):\n\n```python\nimport sys\nfrom atcoder.modint import ModInt998244353\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    d = [0] * 11\n    for v in a:\n        d[len(str(v))] += 1\n    res = ModInt998244353(0)\n    p10 = [ModInt998244353(1)] * 11\n    for i in range(1, 11):\n        p10[i] = p10[i - 1] * 10\n    for i in range(n):\n        res += ModInt998244353(a[i]) * i\n        d[len(str(a[i]))] -= 1\n        for j in range(1, 11):\n            res += p10[j] * a[i] * d[j]\n    print(res.val())\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n \n\n", "problem_ids": ["abc353_d"]}, "abc334_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nAt the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes \\( A \\) seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.\n\nCurrently, there is no one in line at the ticket booth, and \\( N \\) people will come to buy tickets one after another. Specifically, the \\( i \\)-th person will arrive at the ticket booth \\( T_i \\) seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately. Here, \\( T_1 < T_2 < \\dots < T_N \\).\n\nFor each \\( i\\ (1 \\leq i \\leq N) \\), determine how many seconds from now the \\( i \\)-th person will finish purchasing their ticket.\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 0 \\leq T_1 < T_2 < \\dots < T_N \\leq 10^6 \\)\n- \\( 1 \\leq A \\leq 10^6 \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN A\nT_1 T_2 \\dots T_N\n```\n\n**Output:**\n\nPrint \\( N \\) lines. The \\( i \\)-th line should contain the number of seconds from now that the \\( i \\)-th person will finish purchasing their ticket.\n\n**Sample Input 1:**\n\n```\n3 4\n0 2 10\n```\n\n**Sample Output 1:**\n\n```\n4\n8\n14\n```\n\nThe events proceed in the following order:\n\n- At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.\n- At 8 seconds: The 2nd person finishes purchasing their ticket.\n- At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 14 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 2:**\n\n```\n3 3\n1 4 7\n```\n\n**Sample Output 2:**\n\n```\n4\n7\n10\n```\n\nThe events proceed in the following order:\n\n- At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.\n- At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.\n- At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.\n- At 10 seconds: The 3rd person finishes purchasing their ticket.\n\n**Sample Input 3:**\n\n```\n10 50000\n120190 165111 196897 456895 540000 552614 561627 743796 757613 991216\n```\n\n**Sample Output 3:**\n\n```\n170190\n220190\n270190\n506895\n590000\n640000\n690000\n793796\n843796\n1041216\n```\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 358\n\nB - Ticket Counter Editorial by en_translator\n\nSuppose that the \\(i\\)-th person finishes buying a ticket at time \\(x_i\\). For convenience, let \\(x_0=0\\).\nFor each \\(i\\) (1 \\(\\leq i\\leq N\\)), we determine how to represent the value \\(x_i\\) using \\(x_{i-1}\\).\n\nIf \\(x_{i-1} \\leq T_i\\): there is no queue when the \\(i\\)-th person visits the ticket booth, so they can start purchasing instantly. Thus, \\(x_i=T_i+A\\).\nIf \\(x_{i-1} > T_i\\): someone is still purchasing a ticket when the \\(i\\)-th person visits the booth, so they start the process right after the \\((i-1)\\)-th person finishes. Thus, \\(x_i=x_{i-1}+A\\).\n\nTo summarize, \\(x_i=\\max(x_{i-1},T_i)+A\\). Use this to find \\(x_i\\) for each \\(i=1,2,\\dots,N\\).\n\nSample code (Python):\n```python\nn, a = map(int, input().split())\nt = list(map(int, input().split()))\npre = 0\nfor i in range(n):\n    ans = max(pre, t[i]) + a\n    print(ans)\n    pre = ans\n```\n \n\n", "problem_ids": ["abc358_b"]}, "abc334_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given \\(N\\) linear functions \\(f_1, f_2, \\ldots, f_N\\), where \\(f_i(x) = A_i x + B_i\\). Your task is to find the maximum possible value of \n\\[ \nf_{p_1}(f_{p_2}(\\ldots f_{p_K}(1) \\ldots )) \n\\]\nfor a sequence \\(p = (p_1, p_2, \\ldots, p_K)\\) composed of \\(K\\) distinct integers between \\(1\\) and \\(N\\), inclusive.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(1 \\leq K \\leq \\text{min}(N,10)\\)\n- \\(1 \\leq A_i, B_i \\leq 50\\) for all \\(1 \\leq i \\leq N\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN K\nA_1 B_1\nA_2 B_2\n\\vdots\nA_N B_N\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n```\n3 2\n2 3\n1 5\n4 2\n```\n\n**Sample Output 1**\n```\n26\n```\n\n**Explanation for Sample Input 1**\n\nHere are all possible \\(p\\) and the corresponding values of \\(f_{p_1}(f_{p_2}(1))\\):\n- \\(p= (1,2)\\): \\(f_1(f_2(1))=15\\)\n- \\(p= (1,3)\\): \\(f_1(f_3(1))=15\\)\n- \\(p= (2,1)\\): \\(f_2(f_1(1))=10\\)\n- \\(p= (2,3)\\): \\(f_2(f_3(1))=11\\)\n- \\(p= (3,1)\\): \\(f_3(f_1(1))=22\\)\n- \\(p= (3,2)\\): \\(f_3(f_2(1))=26\\)\n\nTherefore, the maximum value is \\(26\\), and you should print \\(26\\).\n\n**Sample Input 2**\n```\n10 3\n48 40\n34 22\n24 37\n45 40\n48 31\n49 44\n45 40\n44 6\n35 22\n39 28\n```\n\n**Sample Output 2**\n```\n216223\n```\n\nSolution:\n\n```python\nn, k = map(int, input().split())\na = []\nb = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nord_indices = list(range(n))\nord_indices.sort(key=lambda i: b[i] * (a[i] - 1), reverse=True)\n\ndp = [int(-1e9)] * (k + 1)\ndp[0] = 1\n\nfor i in ord_indices:\n    ndp = dp[:]\n    for j in range(k):\n        if dp[j] > int(-1e9):\n            ndp[j + 1] = max(ndp[j + 1], dp[j] * a[i] + b[i])\n    dp = ndp\n\nprint(dp[k])\n```\n \n\n", "problem_ids": ["abc366_f"]}, "abc334_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer \\( N \\) and a prime \\( P \\).\n\nCount the number, modulo \\( P \\), of undirected connected graphs \\( G \\) of \\( N \\) vertices numbered \\( 1 \\) to \\( N \\) that satisfy the following conditions:\n\n1. There are no self-loops in \\( G \\). Note that multiple edges are allowed.\n2. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) remains connected. In other words, \\( G \\) is edge-biconnected.\n3. For all edges \\( (u,v) \\) in \\( G \\), if we delete \\( (u,v) \\) from \\( G \\), \\( G \\) is no longer edge-biconnected.\n\nTwo graphs are considered different if and only if there exists a pair of distinct vertices \\( (u,v) \\) such that the numbers of edges connecting \\( u \\) and \\( v \\) in the two graphs are different.\n\n**Constraints**\n\n- \\( 2 \\le N \\le 50 \\)\n- \\( 10^9 < P < 1.01 \\times 10^9 \\)\n- \\( P \\) is prime.\n- All input values are integers.\n\n**Input**\n\nInput is given from Standard Input in the following format:\n\n```\nN P\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**  \n```\n2 1005976817\n```\n\n**Sample Output 1**  \n```\n1\n```\n\n**Sample Input 2**  \n```\n5 1000837403\n```\n\n**Sample Output 2**  \n```\n372\n```\n\n**Sample Input 3**  \n```\n10 1001160547\n```\n\n**Sample Output 3**  \n```\n789846604\n```\n\n**Sample Input 4**  \n```\n20 1006779551\n```\n\n**Sample Output 4**  \n```\n888612770\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        AtCoder Grand Contest 067 - E: Biconnected Graph Editorial by Kubic\n\nIf an edge is deleted, the remaining graph will form a chain after shrinking biconnected components; it will become a cycle if the edge is added back. Solve the problem for each biconnected component and multiply the answers. In the subproblem, there's an additional edge connecting two vertices, allowing them to reach each other through the cycle. Repeat this method by taking an edge connected to vertex \\(1\\), leading to subproblems formatted as:\n\nCount good graphs of \\(n\\) vertices with the first \\(k\\) vertices able to reach each other externally.\n\nConsider the distribution of the first \\(k\\) vertices:\n\n\\(\\forall 1\\le u,v\\le k\\), \\(C(u),C(v)\\) are not adjacent in the cycle, where \\(C(u)\\) is the biconnected component containing \\(u\\).\n\nDP through the cycle without constraining the edge choice so every good graph is counted \\(\\deg(1)\\) times. Store \\(\\deg(1)\\) in the DP state and divide the final answer by it.\n\nTime complexity: \\(O(n^5)\\). Some \\(O(n^6)\\) solutions with small constants may pass.\n        [END TEXT]\n \n\n", "problem_ids": ["agc067_e"]}, "abc335_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nA mayoral election is being held in AtCoder City. The candidates are Takahashi and Aoki. There are \\( N \\) valid votes cast for either of the two candidates, and the counting is currently underway. Here, \\( N \\) is an odd number. The current vote count is \\( T \\) votes for Takahashi and \\( A \\) votes for Aoki. Determine if the outcome of the election is already decided at this point.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 99 \\)\n- \\( N \\) is an odd number.\n- \\( 0 \\leq T, A \\leq N \\)\n- \\( T + A \\leq N \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from standard input in the following format:\n\n```\nN T A\n```\n\n**Output**\n\nPrint `Yes` if the outcome of the election is already decided, and `No` otherwise.\n\n**Sample Input 1**\n\n```\n7 4 2\n```\n\n**Sample Output 1**\n\n```\nYes\n```\n\nEven if the remaining one vote goes to Aoki, Takahashi will still win. That is, his victory is decided, so print `Yes`.\n\n**Sample Input 2**\n\n```\n99 12 48\n```\n\n**Sample Output 2**\n\n```\nNo\n```\n\nAlthough Aoki currently has more votes, Takahashi would win if he receives the remaining 39 votes. Therefore, print `No`.\n\n**Sample Input 3**\n\n```\n1 0 0\n```\n\n**Sample Output 3**\n\n```\nNo\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Here is the cleaned version with only the relevant solution content:\n\nFirst, let us consider when Takahashi\u2019s or Aoki\u2019s victory is already decided. If either candidate already has \\(\\lceil \\frac{N}{2} \\rceil\\) or more votes, then the other never wins even if he gets the remaining. Conversely, if both candidates do not have \\(\\lceil \\frac{N}{2} \\rceil\\) votes yet, then both may win, so the winner is not confirmed yet.\n\nImplement this condition in an if statement. Determine if \\(T \\geq \\lceil \\frac{N}{2} \\rceil\\) or \\(A \\geq \\lceil \\frac{N}{2} \\rceil \\). In most programming languages, \\(N / 2\\) is a floor division. If you want to find \\( \\lceil \\frac{N}{2} \\rceil \\), evaluate \\((N + 1) / 2\\).\n\nSample code (Python3):\n```python\nn, t, a = map(int, input().split())\nif a >= (n+1)//2 or t >= (n+1)//2:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc366_a"]}, "abc335_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a tree with \\( N \\) vertices numbered \\( 1, 2, \\ldots, N \\). The \\( i \\)-th edge connects vertices \\( u_i \\) and \\( v_i \\) bidirectionally.\n\nInitially, all vertices are painted white.\n\nTo efficiently visit all vertices of this tree, Alice has invented a magical gate. She uses one piece and one gate to travel according to the following procedure.\n\nFirst, she chooses a vertex and places both the piece and the gate on that vertex. Then, she repeatedly performs the following operations until all vertices are painted black.\n\nChoose one of the following actions:\n\n1. Paint the vertex where the piece is placed black.\n2. Choose a vertex adjacent to the vertex where the piece is placed and move the piece to that vertex. The cost of this action is 1.\n3. Move the piece to the vertex where the gate is placed.\n4. Move the gate to the vertex where the piece is placed.\n\nNote that only the second action incurs a cost.\n\nIt can be proved that it is possible to paint all vertices black in a finite number of operations. Find the minimum total cost required.\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq u_i, v_i \\leq N \\)\n- The given graph is a tree.\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nu_1 v_1\n\\vdots\nu_{N-1} v_{N-1}\n```\n\n**Output:**\nPrint the answer.\n\n**Sample Input 1:**\n```\n4\n1 2\n1 3\n1 4\n```\n\n**Sample Output 1:**\n```\n3\n```\n\nHere is an example of Alice's procedure. Let \\((u, v)\\) denote the state where the piece is at vertex \\( u \\) and the gate is at vertex \\( v \\).\n\n- Place the piece and the gate at vertex 4.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 1.\n  - Vertex 4 is painted black.\n  - The state is now \\((4, 4)\\).\n\n- Perform action 2 and move the piece to vertex 1.\n  - This costs 1.\n  - The state is now \\((1, 4)\\).\n\n- Perform action 1.\n  - Vertex 1 is painted black.\n\n- Perform action 4.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 2.\n  - This costs 1.\n  - The state is now \\((2, 1)\\).\n\n- Perform action 1.\n  - Vertex 2 is painted black.\n\n- Perform action 3.\n  - The state is now \\((1, 1)\\).\n\n- Perform action 2 and move the piece to vertex 3.\n  - This costs 1.\n  - The state is now \\((3, 1)\\).\n\n- Perform action 1.\n  - Vertex 3 is painted black.\n  - All vertices are now painted black, so the procedure ends.\n\nThe total cost of performing action 2 is 3, and there is no procedure with a smaller cost.\n\n**Sample Input 2:**\n```\n10\n1 7\n7 10\n10 8\n8 3\n8 4\n10 9\n9 6\n9 5\n7 2\n```\n\n**Sample Output 2:**\n```\n10\n```\n\nSolution:\n\n```\nHere is the cleaned version:\n\nEditorial - AtCoder Regular Contest 179\n\nD - Portable Gate Editorial by evima\n\nWhen moving the gate, it can be considered to move simultaneously with the piece. We will perform operation 1 as needed and consider the following operations:\n\nOperation A: When the piece and the gate are on the same vertex, move both the piece and the gate to an adjacent vertex. Operation B: Move the piece to an adjacent vertex. Operation C: Move the piece to the vertex where the gate is located.\n\nOperations A and B each incur a cost of 1. Once operation B is performed, the gate remains in its position until operation C is performed. It's inefficient to move the piece to the gate using operation B, so we will not consider this.\n\nLet \\(v\\) be the initial position of the piece and gate. By performing operation C at the end, the process ends when the piece and the gate are on the same vertex. Label the vertices and edges the gate moves to with A, and the rest with B. The vertices and edges labeled A form a connected subgraph, or subtree A. Vertex \\(v\\) is included in subtree A. Edges labeled B with one endpoint as A are boundary edges.\n\nVertices and edges labeled B not connected to boundary edges form connected components. Each component is a tree connected to a vertex in subtree A by a boundary edge \\(e_i\\). Let them form subtree \\(B_i\\), connected to vertex \\(l_i\\) in A.\n\nKey points:\n\n1. In optimal operations, assume edges labeled A are not traversed by operation B. By rearranging operations, the cost does not increase:\n\n   - The piece and gate start from \\(v\\), visit all vertices in A using operation A, and return to \\(v\\). This is the journey in A.\n   - If \\(l_i\\) is visited during A's journey, it's interrupted. The piece starts from \\(l_i\\), visits all vertices in \\(B_i\\) using operation B, and returns to \\(l_i\\). This is the journey in \\(B_i\\). The gate stays at \\(l_i\\).\n\n2. Assume moving along boundary edge \\(e_i\\) occurs only once in B's journey. If done more than once, moving with the gate using operation A during the first move and returning does not increase the cost. In \\(B_i\\)'s journey, operation C is done once at the end.\n\n3. In the journeys of A and \\(B_i\\), the farthest vertex is visited last. If the distance from start to the farthest vertex is \\(d\\) and the number of edges is \\(m\\), the cost is \\(2m - d\\).\n\nThe total number of edges in subtrees is \\(N-1\\). Minimize cost by maximizing \\(d\\)'s total sum. Calculate for fixed \\(v\\) using tree DP. Maintain:\n\n- Maximum distance to vertex where \\(B_i\\)'s journey ends, assuming \\(u = l_i\\).\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex in \\(u\\)'s subtree.\n- Maximum \\(d\\)'s sum if \\(u\\) is in A and A's journey ends in a vertex not in \\(u\\)'s subtree.\n\nExtend to rerooting DP to examine all possible starting vertices. Time complexity \\(\\mathrm{O}(N)\\).\n```\n\n \n\n", "problem_ids": ["arc179_d"]}, "abc335_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given two integers \\( N \\) and \\( M \\). An integer sequence of length between 1 and \\( N \\) (inclusive), where each element is between 1 and \\( M \\) (inclusive), is called a *good sequence*.\n\nThe *score* of a good sequence is defined as the number of positive divisors of \\( X \\), where \\( X \\) is the product of the elements in the sequence.\n\nThere are \\(\\displaystyle \\sum_{k=1}^{N}M^k\\) good sequences. Your task is to find the sum of the scores of all those sequences modulo 998244353.\n\n**Constraints:**\n\n- \\(1 \\leq N \\leq 10^{18}\\)\n- \\(1 \\leq M \\leq 16\\)\n- All input values are integers.\n\n**Input:**\n\nThe input is provided in the following format:\n\n```\nN M\n```\n\n**Output:**\n\nOutput the answer as an integer.\n\n**Examples:**\n\n- **Input:**\n  ```\n  1 7\n  ```\n\n  **Output:**\n  ```\n  16\n  ```\n  *Explanation:* \n  There are seven good sequences: (1), (2), (3), (4), (5), (6), (7). Their scores are 1, 2, 2, 3, 2, 4, 2, respectively, so the answer is 1 + 2 + 2 + 3 + 2 + 4 + 2 = 16.\n\n- **Input:**\n  ```\n  3 11\n  ```\n\n  **Output:**\n  ```\n  16095\n  ```\n  *Explanation:*\n  For example, (8, 11) and (1, 8, 2) are good sequences.\n  \n  - The product of the elements in (8, 11) is \\(8 \\times 11 = 88\\). 88 has eight positive divisors: 1, 2, 4, 8, 11, 22, 44, 88, so the score of (8, 11) is 8.\n  - The product of the elements in (1, 8, 2) is \\(1 \\times 8 \\times 2 = 16\\). 16 has five positive divisors: 1, 2, 4, 8, 16, so the score of (1, 8, 2) is 5.\n\n- **Input:**\n  ```\n  81131 14\n  ```\n\n  **Output:**\n  ```\n  182955659\n  ```\n  *Note:* Remember to take the result modulo 998244353.\n\nSolution:\n\n```python\nfrom collections import defaultdict\n\nMOD = 998244353\nMAX_PRIME = 6\nPRIMES = [2, 3, 5, 7, 11, 13]\n\ndef matrix_pow(a, x):\n    mat_size = len(a)\n    ret = [[0]*mat_size for _ in range(mat_size)]\n    for i in range(mat_size):\n        ret[i][i] = 1\n    while x > 0:\n        if x & 1:\n            nret = [[0]*mat_size for _ in range(mat_size)]\n            for i in range(mat_size):\n                for k in range(mat_size):\n                    for j in range(mat_size):\n                        nret[i][j] += ret[i][k] * a[k][j]\n                        nret[i][j] %= MOD\n            ret = nret\n        na = [[0]*mat_size for _ in range(mat_size)]\n        for i in range(mat_size):\n            for k in range(mat_size):\n                for j in range(mat_size):\n                    na[i][j] += a[i][k] * a[k][j]\n                    na[i][j] %= MOD\n        a = na\n        x >>= 1\n    return ret\n\nN, M = map(int, input().split())\nmat = [[0]*((1 << MAX_PRIME) + 1) for _ in range((1 << MAX_PRIME) + 1)]\nnxt = defaultdict(int)\nfor i in range(1 << MAX_PRIME):\n    for j in range(1, M + 1):\n        add = 1\n        for k in range(MAX_PRIME):\n            if not (i >> k) & 1:\n                continue\n            cnt = 0\n            while j % PRIMES[k] == 0:\n                cnt += 1\n                j //= PRIMES[k]\n            add *= cnt\n        nxt[i] += add\nfor i in range(1 << MAX_PRIME):\n    for j in nxt:\n        if (i & j) == 0:\n            mat[i][i | j] += nxt[j]\nmat[(1 << MAX_PRIME) - 1][1 << MAX_PRIME] = 1\nmat[1 << MAX_PRIME][1 << MAX_PRIME] = 1\nmat = matrix_pow(mat, N + 1)\nans = 0\nfor i in range(1 << MAX_PRIME):\n    ans += mat[i][1 << MAX_PRIME]\nprint((ans - 1) % MOD)\n```\n \n\n", "problem_ids": ["arc182_c"]}, "abc335_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThis is an interactive problem where your program interacts with the judge via input and output.\n\nYou are given a positive integer \\(N\\) and integers \\(L\\) and \\(R\\) such that \\(0 \\leq L \\leq R < 2^N\\). The judge has a hidden sequence \\(A = (A_0, A_1, \\dots, A_{2^N-1})\\) consisting of integers between 0 and 99, inclusive.\n\nYour goal is to find the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100. However, you cannot directly know the values of the elements in the sequence \\(A\\). Instead, you can ask the judge the following question:\n\nChoose non-negative integers \\(i\\) and \\(j\\) such that \\(2^i(j+1) \\leq 2^N\\). Let \\(l = 2^i j\\) and \\(r = 2^i (j+1) - 1\\). Ask for the remainder when \\(A_l + A_{l+1} + \\dots + A_r\\) is divided by 100.\n\nLet \\(m\\) be the minimum number of questions required to determine the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100 for any sequence \\(A\\). You need to find this remainder within \\(m\\) questions.\n\n**Constraints**\n\n- \\(1 \\leq N \\leq 18\\)\n- \\(0 \\leq L \\leq R \\leq 2^N - 1\\)\n- All input values are integers.\n\n**Input and Output**\n\nThis is an interactive problem.\n\nFirst, read the integers \\(N\\), \\(L\\), and \\(R\\) from Standard Input:\n\n```\nN L R\n```\n\nThen, repeat asking questions until you can determine the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100. Each question should be printed in the following format:\n\n```\n? i j\n```\n\nHere, \\(i\\) and \\(j\\) must satisfy the following constraints:\n\n- \\(i\\) and \\(j\\) are non-negative integers.\n- \\(2^i(j+1) \\leq 2^N\\)\n\nThe response to the question will be given in the following format from Standard Input:\n\n```\nT\n```\n\nHere, \\(T\\) is the answer to the question, which is the remainder when \\(A_l + A_{l+1} + \\dots + A_r\\) is divided by 100, where \\(l = 2^i j\\) and \\(r = 2^i (j+1) - 1\\).\n\nIf \\(i\\) and \\(j\\) do not satisfy the constraints, or if the number of questions exceeds \\(m\\), then \\(T\\) will be -1.\n\nIf the judge returns -1, your program is already considered incorrect. In this case, terminate the program immediately.\n\nOnce you have determined the remainder when \\(A_L + A_{L+1} + \\dots + A_R\\) is divided by 100, print the remainder \\(S\\) in the following format and terminate the program immediately:\n\n```\n! S\n```\n\n**Notes**\n\n- At the end of each output, print a newline and flush Standard Output. Otherwise, the verdict may be Time Limit Exceeded (TLE).\n- If your output is malformed or your program exits prematurely, the verdict will be indeterminate.\n- After printing the answer, terminate the program immediately. Otherwise, the verdict will be indeterminate.\n\n**Example**\n\nHere is an example for \\(N=3\\), \\(L=1\\), \\(R=5\\), and \\(A=(31, 41, 59, 26, 53, 58, 97, 93)\\). In this case, \\(m=3\\), so you can ask up to three questions.\n\n**Input**\n```\n3 1 5\n```\n**Output**\n```\n? 0 1\n41\n? 1 1\n85\n? 1 2\n11\n! 37\n```\n\nSolution:\n\n```python\nfrom collections import deque\n\nN, L, R = map(int, input().split())\nn = 1 << N\nedge = [[] for i in range(n + 1)]\nfor i in range(N + 1):\n    for l in range(0, n, 1 << i):\n        r = l + (1 << i)\n        edge[l].append(r)\n        edge[r].append(l)\n\nparent = [None] * (n + 1)\nparent[R + 1] = -1\ndq = deque([R + 1])\nwhile dq:\n    v = dq.popleft()\n    for u in edge[v]:\n        if parent[u] == None:\n            parent[u] = v\n            dq.append(u)\n\nans = 0\nnow = L\nwhile parent[now] != -1:\n    p = parent[now]\n    sgn = 1\n    l, r = now, p\n    if l > r:\n        sgn = -1\n        l, r = r, l\n    i = (r - l).bit_length() - 1\n    j = l >> i\n    print(\"?\", i, j, flush=True)\n    T = int(input())\n    ans += sgn * T\n    now = p\n\nprint(\"!\", ans % 100)\n```\n \n\n", "problem_ids": ["abc355_e"]}, "abc336_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 300 points\n\n**Problem Statement**\n\nYou are playing a game. There are \\( N \\) enemies lined up in a row, and the \\( i \\)-th enemy from the front has a health of \\( H_i \\).\n\nYou will repeat the following action until the healths of all enemies become 0 or less, using a variable \\( T \\) initialized to 0.\n\n1. Increase \\( T \\) by 1. \n2. Then, attack the frontmost enemy with health 1 or more. \n   - If \\( T \\) is a multiple of 3, the enemy's health decreases by 3.\n   - Otherwise, it decreases by 1.\n\nFind the value of \\( T \\) when the healths of all enemies become 0 or less.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq H_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nH_1 H_2 \\ldots H_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n3\n6 2 2\n```\n\n**Sample Output 1**\n```\n8\n```\n\nThe actions are performed as follows:\n- \\( T \\) becomes 1. Attack the 1st enemy, and its health becomes 6-1=5.\n- \\( T \\) becomes 2. Attack the 1st enemy, and its health becomes 5-1=4.\n- \\( T \\) becomes 3. Attack the 1st enemy, and its health becomes 4-3=1.\n- \\( T \\) becomes 4. Attack the 1st enemy, and its health becomes 1-1=0.\n- \\( T \\) becomes 5. Attack the 2nd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 6. Attack the 2nd enemy, and its health becomes 1-3=-2.\n- \\( T \\) becomes 7. Attack the 3rd enemy, and its health becomes 2-1=1.\n- \\( T \\) becomes 8. Attack the 3rd enemy, and its health becomes 1-1=0.\n\n**Sample Input 2**\n```\n9\n1 12 123 1234 12345 123456 1234567 12345678 123456789\n```\n\n**Sample Output 2**\n```\n82304529\n```\n\n**Sample Input 3**\n```\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\n3000000000\n```\n\nBeware of integer overflow.\n\nSolution:\n\n```\nOfficial\n\nC - Triple Attack Editorial\n\nLet us call the frontmost enemy with health \\(1\\) or more simply \u201cthe next enemy.\u201d If the next enemy has a health of \\(5\\) or greater, then we can reduce the health of the next enemy by \\(5\\) regardless of current \\(T\\). This set of three actions is repeated \\(\\lfloor\\frac{H}{5}\\rfloor\\), where \\(H\\) is the health of the next enemy. By processing this repetition at once and simulating the other parts naively, the answer can be found in a total of \\(O(N)\\) time.\n\nSample code (Python)\n\n```python\nN = int(input())\nA = list(map(int, input().split()))\nT = 0\nfor a in A:\n  num = a // 5\n  T += num * 3\n  a -= num * 5\n  while a > 0:\n    T += 1\n    if T % 3 == 0:\n      a -= 3\n    else:\n      a -= 1\n\nprint(T)\n```\n```\n \n\n", "problem_ids": ["abc368_c"]}, "abc336_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi decided to make takoyaki (octopus balls) and serve it to Snuke. Takahashi instructed Snuke to raise only his left hand if he wants to eat takoyaki, and only his right hand otherwise.\n\nYou are given the information about which hand Snuke is raising as two integers L and R. He is raising his left hand if and only if L = 1, and raising his right hand if and only if R = 1. He might not follow the instructions and could raise both hands or not raise any hand at all.\n\n- If Snuke is raising only one hand, print \"Yes\" if he wants to eat takoyaki, and \"No\" if he does not.\n- If he is raising both hands or not raising any hand, print \"Invalid\".\n\nAssume that if Snuke is raising only one hand, he is always following the instructions.\n\n**Constraints:**\n- Each of L and R is 0 or 1.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nL R\n```\n\n**Output:**\nPrint \"Yes\", \"No\", or \"Invalid\" according to the instructions in the problem statement.\n\n**Sample Input 1:**\n```\n1 0\n```\n\n**Sample Output 1:**\n```\nYes\n```\nSnuke wants to eat takoyaki, so he is raising only his left hand.\n\n**Sample Input 2:**\n```\n1 1\n```\n\n**Sample Output 2:**\n```\nInvalid\n```\nSnuke is raising both hands.\n\nSolution:\n\n        [BEGIN TEXT]\n        Toyota Programming Contest 2024#9\uff08AtCoder Beginner Contest 370\uff09\n\nDivide into cases based on the values \\(L\\) and \\(R\\). If \\(L = 0\\) and \\(R = 0\\), print Invalid; if \\(L = 0\\) and \\(R = 1\\), print No; if \\(L = 1\\) and \\(R = 0\\), print Yes; and if \\(L = 1\\) and \\(R = 1\\), print Invalid.\n\nSample code:\n```python\nl, r = map(int, input().split())\nif l == 0 and r == 0:\n    print(\"Invalid\")\nelif l == 0 and r == 1:\n    print(\"No\")\nelif l == 1 and r == 0:\n    print(\"Yes\")\nelse:\n    print(\"Invalid\")\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc370_a"]}, "abc336_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 550 points\n\n## Problem Statement\n\nYou are given a weighted undirected connected graph \\( G \\) with \\( N \\) vertices and \\( N-1 \\) edges, where vertices are numbered from \\( 1 \\) to \\( N \\) and edges are numbered from \\( 1 \\) to \\( N-1 \\). Edge \\( i \\) connects vertices \\( a_i \\) and \\( b_i \\) with a weight of \\( c_i \\).\n\nYou are given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- You are given integers \\( u_i, v_i, w_i \\). Add an edge with weight \\( w_i \\) between vertices \\( u_i \\) and \\( v_i \\) in \\( G \\). Then, print the sum of the weights of the edges in a minimum spanning tree of \\( G \\).\n\n## Constraints\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq a_i < b_i \\leq N \\)\n- \\( 1 \\leq u_i < v_i \\leq N \\)\n- \\( 1 \\leq c_i, w_i \\leq 10 \\)\n- The graph is connected before processing the queries.\n- All input values are integers.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\na_1 b_1 c_1\n.\n.\n.\na_{N-1} b_{N-1} c_{N-1}\nu_1 v_1 w_1\n.\n.\n.\nu_Q v_Q w_Q\n```\n\n## Output\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n## Sample Input 1\n\n```\n4 4\n1 2 6\n2 3 5\n2 4 4\n1 3 3\n1 2 3\n1 4 10\n3 4 1\n```\n\n## Sample Output 1\n\n```\n12\n10\n10\n7\n```\n\nHere is the graph after adding the edge for each query. The edges included in the minimum spanning tree are colored red.\n\n## Sample Input 2\n\n```\n8 6\n1 8 8\n1 6 10\n1 5 8\n2 6 6\n6 7 6\n1 3 9\n2 4 7\n1 3 4\n1 6 7\n3 4 6\n1 5 1\n7 8 4\n3 5 3\n```\n\n## Sample Output 2\n\n```\n49\n46\n45\n38\n34\n33\n```\n\nSolution:\n\n```\nHere is the trimmed editorial:\n\n---\n\n**F - MST Query Editorial**\n\nLet \\(W=10\\) be the maximum edge weight. Let \\(G_k (0\\leq k\\leq W)\\) be the (unweighted) subgraph of \\(G\\) consisting of the edges of \\(G\\) with weights not more than \\(k\\). Let \\(H\\) be the number of connected components of a graph \\(H\\), then the sum of weights of edges in an MST of graph \\(G\\) equals \\(\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Proof) Approach 1:** Among the edges in an MST of \\(G\\), there are \\(N-c(G_k)\\) edges whose weight is not greater than \\(k\\). Therefore, there are \\(\\left(N-c(G_k)\\right)-\\left(N-c(G_{k-1})\\right)=c(G_{k-1})-c(G_k)\\) edges whose weight is exactly \\(k\\), so the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle \\sum_{k=1}^{W}k\\left(c(G_{k-1})-c(G_k)\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)\\right)-W\\cdot c(G_W)=\\displaystyle \\sum_{k=0}^{W-1}\\left( c(G_k)-1\\right)\\).\n\n**(Approach 2):** Among the edges in an MST of \\(G\\), there are \\(c(G_{k-1})-1\\) edges whose weight is not greater than \\(c(G_{k-1})-1\\). Thus, the total edge weight in an MST of graph \\(G\\) is \\(\\displaystyle\\sum_{k=1}^{W}\\left(c(G_{k-1})-1\\right)=\\displaystyle \\sum_{k=0}^{W-1}\\left(c(G_k)-1\\right)\\).\n\nFor each \\(k(0\\leq k\\lt W)\\), one can manage the number of connected components of \\(G_k\\) with a disjoint set union (DSU) to solve this problem in a total of \\(O(W(N+Q)\\alpha(N))\\). The complexity can be reduced to \\(O((WN+Q)\\alpha(N))\\).\n\n**Sample Code:**\n\n```python\nfrom atcoder.dsu import DSU\n\nN, Q = map(int, input().split())\nuf = [DSU(N + 1) for i in range(10)]\nans = 10 * N - 10\nfor i in range(N - 1 + Q):\n    a, b, c = map(int, input().split())\n    for j in range(c, 10):\n        if not uf[j].same(a, b):\n            ans -= 1\n            uf[j].merge(a, b)\n    if i >= N - 1:\n        print(ans)\n```\n```\n \n\n", "problem_ids": ["abc355_f"]}, "abc336_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere are \\( N \\) people, and the current hair length of the \\( i \\)-th person \\( (1 \\leq i \\leq N) \\) is \\( L_i \\).\nEach person's hair grows by 1 per day.\n\nPrint the number of days after which the number of people whose hair length is at least \\( T \\) becomes \\( P \\) or more for the first time.\nIf there are already \\( P \\) or more people whose hair length is at least \\( T \\) now, print 0.\n\n**Constraints:**\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq L_i \\leq 100 \\)\n- \\( 1 \\leq T \\leq 100 \\)\n- \\( 1 \\leq P \\leq N \\)\n- All input values are integers.\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN T P\nL_1 L_2 \\ldots L_N\n```\n\n**Output:**\nPrint the number of days after which the number of people whose hair length is at least \\( T \\) becomes \\( P \\) or more for the first time. \nIf this condition is already satisfied now, print 0.\n\n**Sample Input 1:**\n```\n5 10 3\n3 11 1 6 2\n```\n\n**Sample Output 1:**\n```\n7\n```\n\n*Explanation:*\nThere are five people, and their current hair lengths are 3, 11, 1, 6, and 2, so there is one person whose hair length is at least 10.\nAfter seven days, the hair lengths of the people will be 10, 18, 8, 13, and 9, respectively, and there will be three people whose hair length is at least 10.\nAfter six days, there are only two people whose hair length is at least 10, not satisfying the condition, so print 7.\n\n**Sample Input 2:**\n```\n2 5 2\n10 10\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n*Explanation:*\nSince there are already two people whose hair length is at least 5 now, satisfying the condition, print 0.\n\n**Sample Input 3:**\n```\n3 10 1\n1 2 3\n```\n\n**Sample Output 3:**\n```\n7\n```\n\nSolution:\n\n        Editorial - B - Japanese Cursed Doll\n\n\\((T-1)\\) days later, everyone has hair of length \\(T\\) or greater. Together with \\(P\\leq N\\), the condition is always satisfied. One can find the answer by checking if the conditions are satisfied on day \\(i\\) for each \\(i=0,1,\\ldots,(T-1)\\) in order. The complexity is \\(O(NT)\\), which is fast enough for the constraints. The problem can also be solved in \\(O(N\\log N)\\) time by recording how many days are required for each person to have hair of length \\(T\\) or greater, sorting the counts of days, and finding the \\(P\\)-th smallest one among them.\n\nSample code in C++:\n```python\nn, t, p = map(int, input().split())\nl = list(map(int, input().split()))\n\nfor i in range(t):\n    cnt = 0\n    for j in range(n):\n        if l[j] + i >= t:\n            cnt += 1\n    if cnt >= p:\n        print(i)\n        break\n```\n\nSample code in Python:\n```python\nn,t,p=map(int, input().split())\nl=list(map(int, input().split()))\n\nfor i in range(t):\n    cnt=0\n    for j in range(n):\n        if l[j]+i>=t:\n            cnt+=1\n    if cnt>=p:\n        print(i)\n        break\n```\n\nSample code in C++ (another solution):\n```python\nn, t, p = map(int, input().split())\nl = []\n\nfor i in range(n):\n    x = int(input())\n    l.append(max(0, t - x))\n\nl.sort()\nprint(l[p - 1])\n```\n \n\n", "problem_ids": ["abc363_b"]}, "abc337_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n## Problem Statement\n\nThere is a grid with \\( N \\) rows and \\( N \\) columns. Let \\( (i, j) \\) \\((1 \\leq i \\leq N, 1 \\leq j \\leq N)\\) denote the cell at the \\( i \\)-th row from the top and the \\( j \\)-th column from the left. Each cell is initially painted red or blue, with cell \\( (i, j) \\) being red if \\( c_{i,j} = R \\) and blue if \\( c_{i,j} = B \\). You want to change the colors of some cells to purple so that the following two conditions are simultaneously satisfied:\n\n- **Condition 1:** You can move from cell \\( (1, 1) \\) to cell \\( (N, N) \\) by only passing through cells that are red or purple.\n- **Condition 2:** You can move from cell \\( (1, N) \\) to cell \\( (N, 1) \\) by only passing through cells that are blue or purple.\n\nHere, \"You can move\" means that you can reach the destination from the starting point by repeatedly moving to a horizontally or vertically adjacent cell of the relevant colors.\n\nWhat is the minimum number of cells that must be changed to purple to satisfy these conditions?\n\n## Constraints\n\n- \\( 3 \\leq N \\leq 500 \\)\n- Each \\( c_{i,j} \\) is \\( R \\) or \\( B \\).\n- \\( c_{1,1} \\) and \\( c_{N,N} \\) are \\( R \\).\n- \\( c_{1,N} \\) and \\( c_{N,1} \\) are \\( B \\).\n- \\( N \\) is an integer.\n\n## Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nc_{1,1}c_{1,2}\\cdots c_{1,N}\nc_{2,1}c_{2,2}\\cdots c_{2,N}\n\u22ee\nc_{N,1}c_{N,2}\\cdots c_{N,N}\n```\n\n## Output\n\nPrint the answer.\n\n## Sample Input 1\n\n```\n5\nRBRBB\nRBRRR\nRRRBR\nRBBRB\nBBRBR\n```\n\n## Sample Output 1\n\n```\n3\n```\n\nAs shown in the figure below, changing cells \\( (1, 3) \\), \\( (3, 2) \\), \\( (4, 5) \\) to purple satisfies the conditions.\n\n## Sample Input 2\n\n```\n5\nRBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBR\n```\n\n## Sample Output 2\n\n```\n7\n```\n\nAs shown in the figure below, changing cells \\( (1, 2) \\), \\( (2, 2) \\), \\( (2, 3) \\), \\( (3, 3) \\), \\( (3, 4) \\), \\( (4, 4) \\), \\( (4, 5) \\) to purple satisfies the conditions.\n\n## Sample Input 3\n\n```\n10\nRRBBBBBBBB\nBRRBBBBBBB\nBBRRBBBBBB\nBBBRRBBBBB\nBBBBRRBBBB\nBBBBBRRBBB\nBBBBBBRRBB\nBBBBBBBRRB\nBBBBBBBBRR\nBBBBBBBBBR\n```\n\n## Sample Output 3\n\n```\n2\n```\n\n## Sample Input 4\n\n```\n17\nRBBRRBRRRRRBBBBBB\nBBRBRBRRBRRBRRBBR\nBRBRBBBRBBRBBRBBB\nRBRRBBBBBBRRBRRRR\nRRRRRBRBRRRBBRBBR\nRRRRRBRRBRBBRRRBB\nBBBRRRBRBRBBRRRBB\nBBRRRBRBBBRBRRRBR\nRRBBBBBBBBBBBRBRR\nRRRBRRBRBRBRBRBBB\nRRBRRRRBRBRRBRBBR\nRRRBBRBRBBBRBBRBR\nBBRBBRRBRRRBBRBBB\nBBBRBRRRRRRRBBRBB\nRRRRRBRBRBBRRBRRR\nBRRRRBBBRRRBRRBBB\nBBRRBBRRRBBBRBBBR\n```\n\n## Sample Output 4\n\n```\n8\n```\n\nSolution:\n\n```python\n[BEGIN TEXT]\n**Editorial - AtCoder Regular Contest 177**\n\n**C - Routing Editorial by evima**\n\n**Step 1:** Consider solving the Sample Input 1 manually:  \nGrid:  \n5  \nRBRBB  \nRBRRR  \nRRRBR  \nRBBRB  \nBBRBR  \n\nThe problem involves these conditions:  \n1. Move from top-left to bottom-right only through red or purple cells.  \n2. Move from top-right to bottom-left only through blue or purple cells.  \n\nDivide the grid; red cells represent only the left side painted, and blue cells represent only the right side painted. Purple cells are where both sides are painted.\n\n**Operations:**  \n- Blue \u2192 Purple: Paint an unpainted cell in the left grid.  \n- Red \u2192 Purple: Paint an unpainted cell in the right grid.\n\n**Satisfying Conditions:**  \n- Condition 1 requires one \"Blue \u2192 Purple\" operation.  \n- Condition 2 requires two \"Red \u2192 Purple\" operations.  \n\nThe answer is \\(1+2=3\\).\n\n**Step 2:** For the general case, divide the grid and consider red and blue independently. Solve for red, then add results.  \n\n**Properties:**  \n- Minimum cells to repaint red = minimum white cells passed from top-left to bottom-right.  \nLet \\(a\\) be cells repainted red, and \\(b\\) be white cells passed.  \n- \\(b \\geq a\\): A path through \\(b\\) white cells can be repainted to move.  \n- \\(b \\leq a\\): A method with \\(a\\) repaintings moves without more than \\(a\\) white cells.  \nThus, \\(a = b\\).\n\n**Find Minimum White Cells Passed:**  \nReduce to shortest path problem:  \n- Each cell is a vertex; cost is 1 for white and 0 otherwise.  \n- Use Dijkstra\u2019s algorithm (\\(O(N^2 \\log N)\\) time). Constraint \\(N \\leq 500\\).\n\n**Sample Implementation (Python 3):**\n```python\nimport heapq\n\nN = int(input())\nC = [input().strip() for _ in range(N)]\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ndef solve(sx, sy, gx, gy, target):\n    dist = [[float('inf')] * N for _ in range(N)]\n    dist[sx][sy] = 0\n    used = [[False] * N for _ in range(N)]\n    queue = [(0, sx, sy)]\n\n    while queue:\n        cost, ax, ay = heapq.heappop(queue)\n        if used[ax][ay]:\n            continue\n        used[ax][ay] = True\n        for i in range(4):\n            bx = ax + dx[i]\n            by = ay + dy[i]\n            if 0 <= bx < N and 0 <= by < N:\n                new_cost = cost + (0 if C[bx][by] == target else 1)\n                if dist[bx][by] > new_cost:\n                    dist[bx][by] = new_cost\n                    heapq.heappush(queue, (new_cost, bx, by))\n\n    return dist[gx][gy]\n\ndist1 = solve(0, 0, N-1, N-1, 'R')\ndist2 = solve(0, N-1, N-1, 0, 'B')\nprint(dist1 + dist2)\n```\n[END TEXT]\n```\n \n\n", "problem_ids": ["arc177_c"]}, "abc337_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a string \\( S \\) consisting of lowercase English letters. You are also given \\( Q \\) queries to process sequentially. The \\( i \\)-th query is described as follows:\n\n- A string \\( T_i \\) consisting of lowercase English letters is given. Print the number of substrings of \\( S \\) that equal \\( T_i \\). Two substrings are distinguished if they are taken from different positions, even if they are equal as strings.\n\n**Constraints:**\n\n- \\( 1 \\leq |S| \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq Q \\leq 5 \\times 10^5 \\)\n- \\( 1 \\leq |T_i| \\leq |S| \\)\n- \\( \\displaystyle \\sum_{i=1}^Q |T_i| \\leq 5 \\times 10^5 \\)\n- \\( S \\) and \\( T_i \\) are strings consisting of lowercase English letters.\n- \\( Q \\) is an integer.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nS\nQ\nT_1\nT_2\n...\nT_Q\n```\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n```\nmissisippi\n5\ni\ns\na\nis\nmissisippi\n```\n\n**Sample Output 1:**\n```\n4\n3\n0\n2\n1\n```\n\nLet \\( S[l:r] \\) denote the substring of \\( S \\) from the \\( l \\)-th character through the \\( r \\)-th character.\n\nFor the 1st query, four substrings of \\( S \\) equal `i`: \\( S[2:2], S[5:5], S[7:7], S[10:10] \\).\n\nFor the 2nd query, three substrings of \\( S \\) equal `s`: \\( S[3:3], S[4:4], S[6:6] \\).\n\nFor the 3rd query, no substrings of \\( S \\) match `a`.\n\nFor the 4th query, two substrings of \\( S \\) equal `is`: \\( S[2:3], S[5:6] \\).\n\nFor the 5th query, one substring of \\( S \\) equals `missisippi`: \\( S[1:10] \\).\n\n**Sample Input 2:**\n```\naaaaaa\n6\na\naa\naaa\naaaa\naaaaa\naaaaaa\n```\n\n**Sample Output 2:**\n```\n6\n5\n4\n3\n2\n1\n```\n\nSolution:\n\n[BEGIN TEXT]\nEditorial - Toyota Programming Contest 2024#7\uff08AtCoder Beginner Contest 362\uff09\n\nG - Count Substring Query Editorial\nby en_translator\n\nLet ~ be a character lexicographically larger than any lowercase English letter. The query asks the number of, among \\(S[1:],S[2:],\\ldots,S[N:]\\), the strings with a prefix \\(T\\). Denoting by \\(T'\\) the string \\(T\\) followed by ~, the count equals the number of \\(i\\) with \\(T\\leq S[i:]\\leq T'\\). By precalculating \\(S[1:],S[2:],\\ldots,S[N:]\\) sorted in lexicographical order (as known as the suffix array) and performing a binary search on this sequence, one can find the number of \\(i\\) with \\(T\\leq S[i:]\\leq T'\\) fast. The complexity for the construction of the suffix array and for each query is \\(O(|S|)\\) and \\(O(|T|\\log |S|)\\), respectively.\n\n```python\nfrom atcoder.string import suffix_array\n\nS = input()\nSA = suffix_array(S)\n\ndef binary_search(T):\n    ng, ok = -1, len(S)\n    while ok - ng > 1:\n        mid = (ng + ok) // 2\n        l = SA[mid]\n        if T <= S[l : l + len(T)]:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nQ = int(input())\nfor _ in range(Q):\n    T = input()\n    print(binary_search(T + \"~\") - binary_search(T))\n```\n\n(Bonus) A standard feature of a language may help implement it concisely.\n```python\nfrom atcoder.string import suffix_array\nimport bisect\n\nS = input()\nSA = suffix_array(S)\n\nQ = int(input())\nfor _ in range(Q):\n    T = input()\n    l = bisect.bisect_left(SA, T, key=lambda x: S[x : x + len(T)])\n    r = bisect.bisect(SA, T, key=lambda x: S[x : x + len(T)])\n    print(r - l)\n```\n[END TEXT]\n \n\n", "problem_ids": ["abc362_g"]}, "abc337_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nTakahashi has a piano with 100 keys arranged in a row. The i-th key from the left is called key i.\n\nHe will play music by pressing N keys one by one. For the i-th press, he will press key \\( A_i \\), using his left hand if \\( S_i = L \\), and his right hand if \\( S_i = R \\).\n\nBefore starting to play, he can place both of his hands on any keys he likes, and his fatigue level at this point is 0. During the performance, if he moves one hand from key x to key y, the fatigue level increases by \\(|y-x|\\) (the fatigue level does not increase for any reason other than moving hands). To press a certain key with a hand, that hand must be placed on that key.\n\nFind the minimum possible fatigue level at the end of the performance.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq 100 \\)\n- \\( N \\) and \\( A_i \\) are integers.\n- \\( S_i \\) is 'L' or 'R'.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 S_1\nA_2 S_2\n...\nA_N S_N\n```\n\n**Output**\n\nPrint the minimum fatigue level at the end of the performance.\n\n**Sample Input 1**\n```\n4\n3 L\n6 R\n9 L\n1 R\n```\n\n**Sample Output 1**\n```\n11\n```\n\nFor example, the performance can be done as follows:\n- Initially, place the left hand on key 3 and the right hand on key 6.\n- Press key 3 with the left hand.\n- Press key 6 with the right hand.\n- Move the left hand from key 3 to key 9. The fatigue level increases by \\(|9-3| = 6\\).\n- Move the right hand from key 6 to key 1. The fatigue level increases by \\(|1-6| = 5\\).\n- Press key 9 with the left hand.\n- Press key 1 with the right hand.\n\nIn this case, the fatigue level at the end of the performance is \\(6 + 5 = 11\\), which is the minimum possible.\n\n**Sample Input 2**\n```\n3\n2 L\n2 L\n100 L\n```\n\n**Sample Output 2**\n```\n98\n```\n\n**Sample Input 3**\n```\n8\n22 L\n75 L\n26 R\n45 R\n72 R\n81 R\n47 L\n29 R\n```\n\n**Sample Output 3**\n```\n188\n```\n\nSolution:\n\n```\nEditorial - B - Piano 3\n\nManage the positions of left and right hands while inspecting the key to press for \\(1,2,\\dots,N\\)-th press, and add the fatigue level of each move required. In the sample code, an array \\(\\text{pos}\\) of length two is prepared, with \\(pos[0]\\) and \\(pos[1]\\) managing the current positions of left and right hands, respectively. Initial positions are set to \\(-1\\), and no fatigue is added when moving a hand from \\(-1\\) to another key. This simulates placing a hand at the first key to be pressed by that hand.\n\nSample code (Python):\n```python\nn = int(input())\npos = [-1, -1]   # 0: left, 1: right\nans = 0\nfor i in range(n):\n    a, s = input().split()\n    a = int(a)\n    hand = (0 if s == 'L' else 1)\n    if pos[hand] != -1:\n        ans += abs(pos[hand] - a)\n    pos[hand] = a\nprint(ans)\n```\n```\n \n\n", "problem_ids": ["abc369_b"]}, "abc337_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou have 12 strings \\( S_1, S_2, \\ldots, S_{12} \\) consisting of lowercase English letters. Determine how many integers \\( i \\) (where \\( 1 \\leq i \\leq 12 \\)) satisfy the condition that the length of the string \\( S_i \\) is exactly \\( i \\).\n\n**Constraints:**\n\n- Each \\( S_i \\) is a string of length between 1 and 100, inclusive, consisting of lowercase English letters for \\( 1 \\leq i \\leq 12 \\).\n\n**Input:**\n\nThe input consists of 12 lines, where each line contains a single string representing \\( S_1, S_2, \\ldots, S_{12} \\).\n\n**Output:**\n\nPrint the number of integers \\( i \\) (where \\( 1 \\leq i \\leq 12 \\)) such that the length of \\( S_i \\) is \\( i \\).\n\n**Sample Input 1:**\n\n```\njanuary\nfebruary\nmarch\napril\nmay\njune\njuly\naugust\nseptember\noctober\nnovember\ndecember\n```\n\n**Sample Output 1:**\n\n```\n1\n```\n\nExplanation: There is only one integer \\( i \\) such that the length of \\( S_i \\) is \\( i \\): 9. Thus, print 1.\n\n**Sample Input 2:**\n\n```\nve\ninrtfa\nnpccxva\ndjiq\nlmbkktngaovl\nmlfiv\nfmbvcmuxuwggfq\nqgmtwxmb\njii\nts\nbfxrvs\neqvy\n```\n\n**Sample Output 2:**\n\n```\n2\n```\n\nExplanation: There are two integers \\( i \\) such that the length of \\( S_i \\) is \\( i \\): 4 and 8. Thus, print 2.\n\nSolution:\n\n        Editorial - AtCoder Beginner Contest 373\n\nThis problem requires the usage of a for statement and the retrieval of the length of a string. Use a for statement to repeat the operation for \\(i=1,2,\\ldots, 12\\):\n\n1. Read a string.\n2. If its length equals \\(i\\), add \\(1\\) to the answer.\n\nTo implement this, use the appropriate function for string length retrieval provided by your programming language. In C++, a string type is represented by `std::string`; for a `std::string s`, its length can be obtained as `s.size()`. In Python, the length of `s` can be obtained as `len(s)`. Here are sample codes:\n\n**Sample code (Python3):**\n```python\nans = 0\n\nfor i in range(1, 12 + 1):\n    s = input()  # Read string s\n    if len(s) == i:  # Check if its length equals i\n        ans += 1  # If so, add 1 to the answer\n\nprint(ans)\n```\n \n\n", "problem_ids": ["abc373_a"]}, "abc337_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 500 points\n\n### Problem Statement\n\nHow many integers \\( x \\) between 1 and \\( N \\), inclusive, can be expressed as \\( x = a^b \\) using some positive integer \\( a \\) and a positive integer \\( b \\) not less than 2?\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 10^{18} \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\n```\n\n### Output\n\nPrint the answer as an integer.\n\n### Sample Input 1\n\n```\n99\n```\n\n### Sample Output 1\n\n```\n12\n```\n\nThe integers that satisfy the conditions in the problem statement are: 1, 4, 8, 9, 16, 25, 27, 32, 36, 49, 64, 81. There are 12 of these.\n\n### Sample Input 2\n\n```\n1000000000000000000\n```\n\n### Sample Output 2\n\n```\n1001003332\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Denso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09 Editorial - Problem F: x = a^b\n\nWe introduce a rather brute-force solution. As evident from Sample 2, a total of 1001003332 integers can satisfy the condition. Since \\((10^9)^2 = 10^{18}\\), \\(10^9\\) integers among them can be represented as \\(a^2\\). Therefore, there are only \\(10^6\\) integers that cannot be represented as \\(a^2\\). One can enumerate all of them and then add the number of those represented as \\(a^2\\). This enumeration can be done for \\(b=3,4,\\dots,59\\) and then stopped once \\(a^b > N\\) is satisfied; one can determine if an integer \\(x\\) can be represented as \\(a^2\\) by checking if \\((\\lfloor \\sqrt{x} \\rfloor )^2=x\\).\n\nSample code (Python):\n```python\nimport math\n\ndef safe_pow(a, b):\n    res = 1\n    for _ in range(b):\n        dres = res\n        dres *= a\n        if dres > 2e18:\n            return 2e18\n        res *= a\n    return res\n\ndef sqrt_floor(x):\n    l, r = 0, int(2e9)\n    while l <= r:\n        t = (l + r) // 2\n        if t * t > x:\n            r = t - 1\n        else:\n            l = t + 1\n    return r\n\ndef main():\n    n = int(input().strip())\n    st = set()\n    for b in range(3, 60):\n        a = 2\n        while True:\n            x = safe_pow(a, b)\n            if x > n:\n                break\n            s = sqrt_floor(x)\n            if s * s != x:\n                st.add(x)\n            a += 1\n    res = len(st)\n    res += sqrt_floor(n)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc361_f"]}, "abc338_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers of length \\( N \\): \\( A = (A_1, A_2, \\ldots, A_N) \\) and \\( B = (B_1, B_2, \\ldots, B_N) \\).\n\nYou are given \\( Q \\) queries to process in order. The \\( i \\)-th query is explained below:\n\n- You are given positive integers \\( l_i, r_i, L_i, R_i \\). Print \"Yes\" if it is possible to rearrange the subsequence \\( (A_{l_i}, A_{l_i+1}, \\ldots, A_{r_i}) \\) to match the subsequence \\( (B_{L_i}, B_{L_i+1}, \\ldots, B_{R_i}) \\), and \"No\" otherwise.\n\n**Constraints**\n\n- \\( 1 \\leq N, Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq l_i \\leq r_i \\leq N \\)\n- \\( 1 \\leq L_i \\leq R_i \\leq N \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nl_1 r_1 L_1 R_1\nl_2 r_2 L_2 R_2\n\\vdots\nl_Q r_Q L_Q R_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n\n```\n5 4\n1 2 3 2 4\n2 3 1 4 2\n1 3 1 3\n1 2 3 5\n1 4 2 5\n1 5 1 5\n```\n\n**Sample Output 1**\n\n```\nYes\nNo\nNo\nYes\n```\n\n**Explanation**\n\n- For the 1st query, it is possible to rearrange \\( (1, 2, 3) \\) to match \\( (2, 3, 1) \\). Hence, we print \"Yes\".\n- For the 2nd query, it is impossible to rearrange \\( (1, 2) \\) in any way to match \\( (1, 4, 2) \\). Hence, we print \"No\".\n- For the 3rd query, it is impossible to rearrange \\( (1, 2, 3, 2) \\) in any way to match \\( (3, 1, 4, 2) \\). Hence, we print \"No\".\n- For the 4th query, it is possible to rearrange \\( (1, 2, 3, 2, 4) \\) to match \\( (2, 3, 1, 4, 2) \\). Hence, we print \"Yes\".\n\n**Sample Input 2**\n\n```\n4 4\n4 4 4 4\n4 4 4 4\n1 2 2 3\n3 3 1 1\n1 3 1 4\n1 4 2 3\n```\n\n**Sample Output 2**\n\n```\nYes\nYes\nNo\nNo\n```\n\nSolution:\n\n[BEGIN TEXT]\nThe problem requires processing queries to check if \\(\\{A_l,A_{l+1},\\ldots,A_r\\}\\) coincides with \\(\\{B_L,B_{L+1},\\ldots,B_R\\}\\) as a multiset. A method for this involves using Zobrist Hashing to determine set equivalence. The hash function \\(H\\) should meet these requirements: \n\n1. Compute \\(H(S)\\) of a multiset quickly.\n2. If two multisets \\(S\\) and \\(T\\) are equal, then \\(H(S)=H(T)\\).\n3. If \\(S\\) and \\(T\\) are not equal, then \\(H(S)\\neq H(T)\\) with high probability.\n\nTo implement this, assign a hash value to each integer between \\(1\\) and \\(N\\), and define the hash function of \\(S\\) as the sum of its element hash values, modulo \\(P\\) (a large prime). Precalculate cumulative sums of hash values to compute the hash of subsequences in \\(O(1)\\) time. Hence, the total time complexity is \\(O(N+Q)\\).\n\n```python\nimport random\nmod = (1 << 61) - 1\n\nN, Q = map(int, input().split())\nA = list(map(lambda x: int(x) - 1, input().split()))\nB = list(map(lambda x: int(x) - 1, input().split()))\n\nhash = [random.randint(1, mod - 1) for i in range(N)]\ncumA = [0] * (N + 1)\ncumB = [0] * (N + 1)\nfor i in range(N):\n    cumA[i + 1] = (cumA[i] + hash[A[i]]) % mod\n    cumB[i + 1] = (cumB[i] + hash[B[i]]) % mod\n\nfor i in range(Q):\n    l, r, L, R = map(int, input().split())\n    if (cumA[r] - cumA[l - 1]) % mod == (cumB[R] - cumB[L - 1]) % mod:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n```\n[END TEXT]\n \n\n", "problem_ids": ["abc367_f"]}, "abc338_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integers \\( N \\) and \\( K \\).\n\nThe **cumulative sums** of an integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is defined as a sequence \\( Y = (Y_0, Y_1, \\dots, Y_N) \\) of length \\( N+1 \\) as follows:\n\n- \\( Y_0 = 0 \\)\n- \\( Y_i = \\sum_{j=1}^{i} X_j \\) for \\( i = 1, 2, \\dots, N \\)\n\nAn integer sequence \\( X = (X_1, X_2, \\dots, X_N) \\) of length \\( N \\) is called a **good sequence** if and only if it satisfies the following condition:\n\n- Any value in the cumulative sums of \\( X \\) that is less than \\( K \\) appears before any value that is not less than \\( K \\).\n  \n  Formally, for the cumulative sums \\( Y \\) of \\( X \\), for any pair of integers \\( (i, j) \\) such that \\( 0 \\le i, j \\le N \\), if \\( (Y_i < K \\) and \\( Y_j \\ge K) \\), then \\( i < j \\).\n\nYou are given an integer sequence \\( A = (A_1, A_2, \\dots, A_N) \\) of length \\( N \\). Determine whether the elements of \\( A \\) can be rearranged to form a good sequence. If so, print one such rearrangement.\n\n**Constraints**\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( -10^9 \\leq K \\leq 10^9 \\)\n- \\( -10^9 \\leq A_i \\leq 10^9 \\)\n\nAll input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nIf the elements of \\( A \\) can be rearranged to a good sequence, print the rearranged sequence \\( (A'_1, A'_2, \\dots, A'_N) \\) in the following format:\n\n```\nYes\nA'_1 A'_2 \\cdots A'_N\n```\n\nIf there are multiple valid rearrangements, any of them is considered correct.\n\nIf a good sequence cannot be obtained, print `No`.\n\n**Sample Input 1**\n```\n4 1\n-1 2 -3 4\n```\n\n**Sample Output 1**\n```\nYes\n-3 -1 2 4\n```\n\nIf you rearrange \\( A \\) to \\((-3, -1, 2, 4)\\), the cumulative sums \\( Y \\) will be \\( (0, -3, -4, -2, 2) \\). In this \\( Y \\), any value less than 1 appears before any value not less than 1.\n\n**Sample Input 2**\n```\n4 -1\n1 -2 3 -4\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n10 1000000000\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n**Sample Output 3**\n```\nYes\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\nSolution:\n\n[BEGIN TEXT]\nAtCoder Regular Contest 179 - A - Partition Editorial by evima\n\nIf \\(K \\geq 1\\):\nBy sorting \\(A\\) in ascending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in ascending order. Let \\(B\\) be the cumulative sums of \\(A\\). Values in \\(A\\) that are less than \\(0\\) appear before values that are \\(0\\) or greater. Therefore, \\(B\\) can be represented as a concatenation of a strictly decreasing sequence and a non-decreasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 < K\\) and decreasing for a while, it begins to increase from a value less than \\(K\\). Once it becomes \\(K\\) or greater, it remains so thereafter. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i \\geq K\\):\nBy sorting \\(A\\) in descending order, it can always be made into a good sequence. Assume \\(A\\) is sorted in descending order. Let \\(B\\) be the cumulative sum of \\(A\\). Values in \\(A\\) that are \\(0\\) or greater appear before values that are less than \\(0\\). Therefore, \\(B\\) can be represented as a concatenation of a strictly increasing sequence and a non-increasing sequence. Thus, when looking at the elements of \\(B\\) in order of increasing indices, after starting from \\(B_0 = 0 \\geq K\\) and increasing for a while, it begins to decrease from a value not less than \\(K\\). Since \\(B_0 \\geq K\\), it is \\(K\\) or greater from the start, and since \\(B_N = \\sum_{i=1}^{N}A_i \\geq K\\), it remains \\(K\\) or greater until the end. Therefore, \\(A\\) is a good sequence.\n\nIf \\(K \\leq 0\\) and \\(\\sum_{i=1}^{N}A_i < K\\):\nNo matter how \\(A\\) is rearranged, it cannot be made into a good sequence. No matter how \\(A\\) is rearranged, the initial and final terms of the cumulative sum \\(B\\) of \\(A\\) are fixed. Since \\(B_0 = 0 \\geq K\\) and \\(B_N = \\sum_{i=1}^{N}A_i < K\\), it does not satisfy the conditions for a good sequence.\n[END TEXT]\n \n\n", "problem_ids": ["arc179_a"]}, "abc338_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given a sequence of \\(N\\) positive integers \\(A = (A_1, A_2, \\dots, A_N)\\). Takahashi repeats the following operation until \\(A\\) contains one or fewer positive elements:\n\n1. Sort \\(A\\) in descending order.\n2. Then, decrease both \\(A_1\\) and \\(A_2\\) by 1.\n\nFind the number of times he performs this operation.\n\n**Constraints**\n\n- \\(2 \\leq N \\leq 100\\)\n- \\(1 \\leq A_i \\leq 100\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\cdots A_N\n```\n\n**Output**\n\nPrint the answer.\n\n**Sample Input 1**\n```\n4\n1 2 3 3\n```\n\n**Sample Output 1**\n```\n4\n```\n\n*Explanation:*\n\nThe process goes as follows:\n\n- After the 1st operation, \\(A\\) is \\((2, 2, 2, 1)\\).\n- After the 2nd operation, \\(A\\) is \\((1, 1, 2, 1)\\).\n- After the 3rd operation, \\(A\\) is \\((1, 0, 1, 1)\\).\n- After the 4th operation, \\(A\\) is \\((0, 0, 1, 0)\\). \\(A\\) no longer contains more than one positive element, so the process ends here.\n\n**Sample Input 2**\n```\n3\n1 1 100\n```\n\n**Sample Output 2**\n```\n2\n```\n\nSolution:\n\nCertainly! Here's the cleaned version of the editorial focused on the solution part:\n\n---\n\nThis problem can be solved with a simulation. Rearranging \\(A\\) in descending order can be done with the sort function in most programming languages. For more details, please refer to the following code.\n\n```python\ndef main():\n    # input\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    answer = 0\n    while True:\n        # sort\n        a.sort(reverse=True)\n        \n        # check condition\n        if a[0] == 0 or a[1] == 0:\n            break\n        \n        # apply\n        a[0] -= 1\n        a[1] -= 1\n        answer += 1\n    \n    # output\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n \n\n", "problem_ids": ["abc368_b"]}, "abc338_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nProblem Statement:\n\nFor a non-negative integer \\( K \\), we define a level-\\( K \\) carpet as follows:\n\n- A level-0 carpet is a \\( 1 \\times 1 \\) grid consisting of a single black cell.\n- For \\( K > 0 \\), a level-\\( K \\) carpet is a \\( 3^K \\times 3^K \\) grid. When this grid is divided into nine \\( 3^{K-1} \\times 3^{K-1} \\) blocks:\n  - The central block consists entirely of white cells.\n  - The other eight blocks are level-\\( (K-1) \\) carpets.\n\nYou are given a non-negative integer \\( N \\). Print a level-\\( N \\) carpet according to the specified format.\n\nConstraints:\n- \\( 0 \\leq N \\leq 6 \\)\n- \\( N \\) is an integer.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\n```\n\nOutput:\nPrint \\( 3^N \\) lines. The \\( i \\)-th line (\\( 1 \\leq i \\leq 3^N \\)) should contain a string \\( S_i \\) of length \\( 3^N \\) consisting of `.` and `#`. The \\( j \\)-th character of \\( S_i \\) (\\( 1 \\leq j \\leq 3^N \\)) should be `#` if the cell at the \\( i \\)-th row from the top and \\( j \\)-th column from the left of a level-\\( N \\) carpet is black, and `.` if it is white.\n\nSample Input 1:\n```\n1\n```\n\nSample Output 1:\n```\n###\n#.#\n###\n```\n\nA level-1 carpet is a \\( 3 \\times 3 \\) grid as follows. When output according to the specified format, it looks like the sample output.\n\nSample Input 2:\n```\n2\n```\n\nSample Output 2:\n```\n#########\n#.##.##.#\n#########\n###...###\n#.#...#.#\n###...###\n#########\n#.##.##.#\n#########\n```\n\nA level-2 carpet is a \\( 9 \\times 9 \\) grid.\n\nSolution:\n\n```python\ndef main():\n    n = int(input())\n    l = 1\n    a = [['\\0' for _ in range(730)] for _ in range(729)]\n    \n    a[0][0] = '#'\n    for k in range(n):\n        for x in range(3):\n            for y in range(3):\n                if (x == 0) and (y == 0):\n                    continue\n                if (x == 1) and (y == 1):\n                    for i in range(l):\n                        for j in range(l):\n                            a[x * l + i][y * l + j] = '.'\n                else:\n                    for i in range(l):\n                        for j in range(l):\n                            a[x * l + i][y * l + j] = a[i][j]\n        l *= 3\n    \n    for i in range(l):\n        print(''.join(a[i]))\n\nmain()\n```\n \n\n", "problem_ids": ["abc357_c"]}, "abc338_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) boxes numbered from 1 to \\( N \\) and \\( N \\) items also numbered from 1 to \\( N \\). Item \\( i \\) (\\( 1 \\leq i \\leq N \\)) is located in box \\( A_i \\) and has a weight of \\( W_i \\).\n\nYou can repeatedly perform the operation of selecting an item and moving it to another box. The cost of moving an item with weight \\( w \\) is \\( w \\).\n\nFind the minimum total cost required to ensure that each box contains exactly one item.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\) (\\( 1 \\leq i \\leq N \\))\n- \\( 1 \\leq W_i \\leq 10^4 \\) (\\( 1 \\leq i \\leq N \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given in the following format from Standard Input:\n```\nN\nA_1 A_2 \\ldots A_N\nW_1 W_2 \\ldots W_N\n```\n\n**Output**\n\nPrint the minimum total cost required to make each box contain exactly one item.\n\n**Sample Input 1**\n```\n5\n2 2 3 3 5\n33 40 2 12 16\n```\n\n**Sample Output 1**\n```\n35\n```\n\n*Explanation*: With the following two moves, you can make each box contain exactly one item:\n1. Move item 1 from box 2 to box 1. The cost is 33.\n2. Move item 3 from box 3 to box 4. The cost is 2.\n\nThe total cost of these two moves is 35. It is impossible to make each box contain exactly one item with a cost less than 35, so print 35.\n\n**Sample Input 2**\n```\n12\n3 6 7 4 12 4 8 11 11 1 8 11\n3925 9785 9752 3587 4013 1117 3937 7045 6437 6208 3391 6309\n```\n\n**Sample Output 2**\n```\n17254\n```\n\n\nSolution:\n\n```python\n# Python3 translation of the given C++ code\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n\n    max_weight = [0] * n\n    for i in range(n):\n        a[i] -= 1\n        max_weight[a[i]] = max(max_weight[a[i]], w[i])\n\n    sum_w = sum(w)\n    sum_max = sum(max_weight)\n    print(sum_w - sum_max)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc360_c"]}, "abc338_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nAn undirected graph with numbered vertices is called a **good graph** if it has a spanning tree \\( T \\) that satisfies the following condition: For every edge \\( (u, v) \\) (\\( u < v \\)) in the graph, the minimum and maximum vertex numbers on the unique simple path connecting vertices \\( u \\) and \\( v \\) in \\( T \\) are \\( u \\) and \\( v \\), respectively.\n\nYou are given a simple connected undirected graph \\( G \\) with \\( N \\) vertices numbered from \\( 1 \\) to \\( N \\). The graph \\( G \\) has \\( M \\) edges, and the \\( i \\)-th edge connects vertices \\( A_i \\) and \\( B_i \\) (\\( A_i < B_i \\)).\n\nFor each \\( i = 1, 2, \\dots, M \\), determine whether the graph obtained by removing the \\( i \\)-th edge from \\( G \\) is a **good graph**.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( N-1 \\leq M \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i < B_i \\leq N \\)\n- All input values are integers.\n- The given graph is a simple connected undirected graph.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1\n...\nA_M B_M\n```\n\n**Output**\n\nPrint \\( M \\) lines. The \\( i \\)-th line should contain `Yes` if the graph obtained by removing the \\( i \\)-th edge from \\( G \\) is a **good graph**, and `No` otherwise.\n\n**Sample Input 1**\n\n```\n6 9\n1 3\n1 5\n2 5\n2 6\n3 4\n3 5\n3 6\n4 6\n5 6\n```\n\n**Sample Output 1**\n\n```\nNo\nNo\nNo\nNo\nYes\nNo\nNo\nYes\nYes\n```\n\nConsider the case where edge \\( (4, 6) \\) is removed. A spanning tree formed by edges \\( (1, 3), (2, 5), (3, 4), (3, 5), (5, 6) \\) satisfies the condition. For example, for edge \\( (3, 6) \\), the simple path connecting vertices \\( 3 \\) and \\( 6 \\) traverses vertices \\( 3, 5, 6 \\) in this order, and the minimum and maximum vertex numbers on the path are \\( 3 \\) and \\( 6 \\), respectively, thus satisfying the condition. By verifying the other edges similarly, it can be seen that this spanning tree satisfies the condition, so the answer is `Yes`.\n\nOn the other hand, consider the case where edge \\( (1, 5) \\) is removed. The same spanning tree does not satisfy the condition. For edge \\( (4, 6) \\), the simple path connecting vertices \\( 4 \\) and \\( 6 \\) traverses vertices \\( 4, 3, 5, 6 \\) in this order, and the minimum and maximum vertex numbers on the path are \\( 3 \\) and \\( 6 \\), respectively, thus not satisfying the condition. It can also be shown that no other spanning tree satisfies the condition, so the answer is `No`.\n\n**Sample Input 2**\n\n```\n5 4\n1 2\n2 3\n3 4\n4 5\n```\n\n**Sample Output 2**\n\n```\nNo\nNo\nNo\nNo\n```\n\nRemoving an edge may disconnect the graph.\n\n**Sample Input 3**\n\n```\n15 20\n12 13\n7 8\n5 7\n8 10\n9 12\n4 5\n11 12\n2 4\n6 8\n4 14\n1 2\n14 15\n2 9\n3 8\n2 15\n10 11\n13 14\n8 9\n7 14\n5 13\n```\n\n**Sample Output 3**\n\n```\nNo\nNo\nNo\nYes\nYes\nNo\nYes\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nYes\nNo\nNo\nNo\nNo\n```\n\nSolution:\n\n```python\nEditorial - AtCoder Regular Contest 181\n\nE - Min and Max at the edge Editorial by evima\n\nThe spanning tree that possesses the properties described in the conditions for a good graph will be referred to as a \u201cgood spanning tree.\u201d First, let\u2019s consider how to determine the existence of a good spanning tree for a fixed graph. If a good spanning tree exists, when we define the cost of an edge \\( (u,v) \\) as \\(|X_u - X_v|\\) using a strictly increasing sequence \\(X\\), the good spanning tree will be one of the minimum spanning trees. This follows from Kruskal's algorithm and the fact that for an edge \\( (u,v) \\) not included in the good spanning tree, the cost of the edges on the simple path connecting \\(u\\) and \\(v\\) will be less than \\(|X_u - X_v|\\). Specifically, if we consider setting \\(X_u = 10^u\\) or \\(-10^{N-u}\\), the costs of each edge will be distinct, so the minimum spanning tree will be uniquely determined. The good spanning tree will be equal to both of the following:\n\n1. The minimum spanning tree \\(T_1\\) when the cost of edge \\((u,v)\\) is \\((N+1)v - u\\)\n2. The minimum spanning tree \\(T_2\\) when the cost of edge \\((u,v)\\) is \\((N+1)(N+1-u) - (N+1-v)\\)\n\nTherefore, for a good spanning tree to exist, it is necessary that \\(T_1 = T_2\\). Conversely, in \\(T_1\\), for an edge \\((u,v)\\), the maximum vertex number on the simple path connecting \\(u\\) and \\(v\\) must be \\(v\\). In \\(T_2\\), for an edge \\((u,v)\\), the minimum vertex number on the simple path connecting \\(u\\) and \\(v\\) must be \\(u\\). Thus, the above conditions are also sufficient. From the above, the existence of a good spanning tree can be determined by finding \\(T_1\\) and \\(T_2\\) and checking if they are identical. Then, to determine the existence of a good spanning tree when each edge is removed, we can find the changes in the minimum spanning tree when the edge is removed and check for identicalness.\n\nFor the minimum spanning tree \\(T\\) of graph \\(G\\), the minimum spanning tree \\(T_{u,v}\\) of the graph obtained by removing edge \\((u,v)\\) can be obtained by the following steps:\n- If \\((u,v)\\) is not included in \\(T\\), then \\(T_{u,v} = T\\).\n- Otherwise, remove \\((u,v)\\) from \\(T\\). As a result, \\(T\\) will be divided into two connected components. Among the edges that span the two connected components, add the one with the minimum cost to \\(T\\) to obtain the tree \\(T_{u,v}\\).\n\nTherefore, we need to solve the following problem:\n\n1. For each edge \\(e\\) in the minimum spanning tree \\(T\\) of graph \\(G\\), initialize a variable \\(X_e\\) to \\(\\infty\\).\n2. For each edge \\((u,v)\\) in graph \\(G\\) that is not included in \\(T\\), update \\(X_e \\leftarrow \\min(X_e, C_{u,v})\\) (where \\(C_{u,v}\\) is the cost of edge \\((u,v)\\)) for each edge \\(e\\) included in the simple path connecting \\(u\\) and \\(v\\) in \\(T\\), and find the final values of \\(X_e\\).\n\nThis can be processed in \\(O(M \\log N)\\) time by handling range chmin queries with a segment tree while performing a DFS. Alternatively, by decomposing the tree into heavy and light paths and arranging the heavy paths, it can be converted into \\(O(\\log N)\\) range chmin queries, allowing it to be processed in \\(O(M \\log^2 N)\\) time, which is also sufficient.\n```\n\n \n\n", "problem_ids": ["arc181_e"]}, "abc339_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere are \\( N \\) boxes numbered from 1 to \\( N \\) and \\( N \\) items also numbered from 1 to \\( N \\). Item \\( i \\) (\\( 1 \\leq i \\leq N \\)) is located in box \\( A_i \\) and has a weight of \\( W_i \\).\n\nYou can repeatedly perform the operation of selecting an item and moving it to another box. The cost of moving an item with weight \\( w \\) is \\( w \\).\n\nFind the minimum total cost required to ensure that each box contains exactly one item.\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq N \\) (\\( 1 \\leq i \\leq N \\))\n- \\( 1 \\leq W_i \\leq 10^4 \\) (\\( 1 \\leq i \\leq N \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given in the following format from Standard Input:\n```\nN\nA_1 A_2 \\ldots A_N\nW_1 W_2 \\ldots W_N\n```\n\n**Output**\n\nPrint the minimum total cost required to make each box contain exactly one item.\n\n**Sample Input 1**\n```\n5\n2 2 3 3 5\n33 40 2 12 16\n```\n\n**Sample Output 1**\n```\n35\n```\n\n*Explanation*: With the following two moves, you can make each box contain exactly one item:\n1. Move item 1 from box 2 to box 1. The cost is 33.\n2. Move item 3 from box 3 to box 4. The cost is 2.\n\nThe total cost of these two moves is 35. It is impossible to make each box contain exactly one item with a cost less than 35, so print 35.\n\n**Sample Input 2**\n```\n12\n3 6 7 4 12 4 8 11 11 1 8 11\n3925 9785 9752 3587 4013 1117 3937 7045 6437 6208 3391 6309\n```\n\n**Sample Output 2**\n```\n17254\n```\n\n\nSolution:\n\n```python\n# Python3 translation of the given C++ code\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n\n    max_weight = [0] * n\n    for i in range(n):\n        a[i] -= 1\n        max_weight[a[i]] = max(max_weight[a[i]], w[i])\n\n    sum_w = sum(w)\n    sum_max = sum(max_weight)\n    print(sum_w - sum_max)\n\nif __name__ == \"__main__\":\n    main()\n```\n \n\n", "problem_ids": ["abc360_c"]}, "abc339_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nFor strings \\( x \\) and \\( y \\), define \\( f(x, y) \\) as follows:  \n\\( f(x, y) \\) is the length of the longest common prefix of \\( x \\) and \\( y \\).\n\nYou are given \\( N \\) strings \\((S_1, S_2, \\ldots, S_N)\\) consisting of lowercase English letters. Find the value of the following expression:\n\n\\[ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j) \\]\n\n**Constraints:**\n\n- \\( 2 \\leq N \\leq 3 \\times 10^5 \\)\n- \\( S_i \\) is a string consisting of lowercase English letters.\n- \\( 1 \\leq |S_i| \\) (where \\(|S_i|\\) denotes the length of the string \\( S_i \\))\n- \\( |S_1| + |S_2| + \\ldots + |S_N| \\leq 3 \\times 10^5 \\)\n- All input numbers are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN\nS_1\nS_2\n...\nS_N\n```\n\n**Output:**\n\nPrint the answer.\n\n**Sample Input 1:**\n\n```\n3\nab\nabc\narc\n```\n\n**Sample Output 1:**\n\n```\n4\n```\n\n**Explanation:**\n\n- \\( f(S_1, S_2) = 2 \\)\n- \\( f(S_1, S_3) = 1 \\)\n- \\( f(S_2, S_3) = 1 \\)\n\nThus, the answer is \\( f(S_1, S_2) + f(S_1, S_3) + f(S_2, S_3) = 4 \\).\n\n**Sample Input 2:**\n\n```\n11\nab\nbb\naaa\nbba\nbaba\nbabb\naaaba\naabbb\na\na\nb\n```\n\n**Sample Output 2:**\n\n```\n32\n```\n\nSolution:\n\n```python\nEditorial - AtCoder Beginner Contest 353\n\nE - Yet Another Sigma Problem Editorial by en_translator\n\nThis problem can be solved with a data structure called Trie. The length of the longest common prefix of \\(S_i\\) and \\(S_j\\) equals the number of common prefixes of \\(S_i\\) and \\(S_j\\). For example, the longest common prefix of \"abc\" and \"abde\" has a length of two, and they have two common prefixes \"a\" and \"ab\". Thus, it is sufficient to enumerate all prefixes \\(T\\) of \\(S_j\\) for all \\(S_j\\), and count the number of \\(S_i\\ (1\\leq i < j)\\) that has \\(T\\) as its suffix. This can be done by inserting \\(S_i\\) in a Trie for each \\(i=1,2,\\ldots,N\\) in order, each of whose node manages the number of strings that has the string represented by the node as a suffix.\n\nSample code (Python 3):\n\n```python\nclass Trie:\n    def __init__(self, len):\n        self.pos = []\n        self.cnt = []\n        self.def_ = [-1] * 26\n        self.now_sz = 0\n        self.ans = 0\n        self.make_node()\n    \n    def make_node(self):\n        self.pos.append(self.def_[:])\n        self.cnt.append(0)\n        self.now_sz += 1\n        return self.now_sz - 1\n    \n    def add(self, s):\n        now = 0\n        for char in s:\n            d = ord(char) - ord('a')\n            nx = self.pos[now][d]\n            if nx == -1:\n                nx = self.make_node()\n                self.pos[now][d] = nx\n            now = nx\n            self.ans += self.cnt[now]\n            self.cnt[now] += 1\n\ndef main():\n    n = int(input())\n    tr = Trie(300000)\n    for _ in range(n):\n        s = input().strip()\n        tr.add(s)\n    print(tr.ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n```\n \n\n", "problem_ids": ["abc353_e"]}, "abc339_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThe AtCoder railway line has \\( N \\) stations, numbered \\( 1, 2, \\ldots, N \\).\n\nOn this line, there are **inbound trains** that start at station \\( 1 \\) and stop at the stations \\( 2, 3, \\ldots, N \\) in order, and **outbound trains** that start at station \\( N \\) and stop at the stations \\( N - 1, N - 2, \\ldots, 1 \\) in order.\n\nTakahashi is about to travel from station \\( X \\) to station \\( Y \\) using only one of the inbound and outbound trains.\n\nDetermine whether the train stops at station \\( Z \\) during this travel.\n\n**Constraints**\n- \\( 3 \\leq N \\leq 100 \\)\n- \\( 1 \\leq X, Y, Z \\leq N \\)\n- \\( X \\), \\( Y \\), and \\( Z \\) are distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN X Y Z\n```\n\n**Output**\n\nIf the train stops at station \\( Z \\) during the travel from station \\( X \\) to station \\( Y \\), print `Yes`; otherwise, print `No`.\n\n**Sample Input 1**\n```\n7 6 1 3\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*Explanation:* To travel from station 6 to station 1, Takahashi will take an outbound train. After departing from station 6, the train stops at stations 5, 4, 3, 2, 1 in order, which include station 3, so you should print `Yes`.\n\n**Sample Input 2**\n```\n10 3 2 9\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n**Sample Input 3**\n```\n100 23 67 45\n```\n\n**Sample Output 3**\n```\nYes\n```\n\nSolution:\n\n        Here is the cleaned version of the editorial content: \n\n---\n\nTakahashi takes an inbound train if \\(X < Y\\) and an outbound train if \\(X > Y\\). Takahashi\u2019s train will stop at station \\(Z\\) if and only if \\(X < Z < Y\\) if \\(X < Y\\), and \\(X > Z > Y\\) if \\(X > Y\\).\n\nSample code:\n```python\nn, x, y, z = map(int, input().split())\nif (x < z < y) or (y < z < x):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```\n \n\n", "problem_ids": ["abc352_a"]}, "abc339_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given an integer sequence \\( A = (A_1, \\ldots, A_N) \\) of length \\( N \\). Here, \\( A_1, A_2, \\ldots, A_N \\) are all distinct. Which element in \\( A \\) is the second largest?\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 100 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( A_1, A_2, \\ldots, A_N \\) are all distinct.\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{N}\n```\n\n**Output**\n\nPrint the integer \\( X \\) such that the \\( X \\)-th element in \\( A \\) is the second largest.\n\n**Sample Input 1**\n```\n4\n8 2 5 1\n```\n\n**Sample Output 1**\n```\n3\n```\n\nThe second largest element in \\( A \\) is \\( A_3 \\), so print \\( 3 \\).\n\n**Sample Input 2**\n```\n8\n1 2 3 4 5 10 9 11\n```\n\n**Sample Output 2**\n```\n6\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Toyota Programming Contest 2024#8\uff08AtCoder Beginner Contest 365\uff09\n\nThe second largest value can be found in the sequence \\(A'\\) obtained by sorting \\(A\\). When \\(A\\) is sorted in ascending order, the second last value, or \\(A'_{N-1}\\), is the second largest value. Next, find the position of that value in \\(A\\) using for and if statements.\n\nSample code (Python3):\n\n```python\nn = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\ntar = b[n - 2]\nfor i in range(n):\n    if a[i] == tar:\n        print(i + 1)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc365_b"]}, "abc340_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nIn AtCoder, a user's rating is represented as a positive integer. Based on the rating value, a certain number of `^` symbols are displayed. Specifically, here are the display rules for different rating ranges:\n\n- If the rating is between 1 and 99, inclusive, `^` is displayed once.\n- If the rating is between 100 and 199, inclusive, `^` is displayed twice.\n- If the rating is between 200 and 299, inclusive, `^` is displayed three times.\n- If the rating is between 300 and 399, inclusive, `^` is displayed four times.\n\nCurrently, Takahashi's rating is \\( R \\). It is guaranteed that \\( R \\) is an integer between 1 and 299, inclusive.\n\nFind the minimum increase in rating required for Takahashi to increase the number of displayed `^`.\n\nIt is guaranteed that under the constraints of this problem, it is possible for Takahashi to increase the number of `^` without his rating reaching 400 or above.\n\n**Constraints**\n\n- \\( 1 \\leq R \\leq 299 \\)\n- \\( R \\) is an integer.\n\n**Input**\n\nThe input is given from standard input as follows:\n```\nR\n```\n\n**Output**\n\nPrint, as an integer, the minimum increase in rating required for Takahashi to increase the number of displayed `^`.\n\n**Sample Input 1**\n```\n123\n```\n\n**Sample Output 1**\n```\n77\n```\n\nTakahashi's current rating is 123, and `^` is displayed twice. By increasing his rating by 77, his rating will become 200, and `^` will be displayed three times. When the rating is 199 or below, `^` is displayed not more than twice, so we print 77.\n\n**Sample Input 2**\n```\n250\n```\n\n**Sample Output 2**\n```\n50\n```\n\nSolution:\n\n        Here is the cleaned-up version of the coding problem editorial:\n\n---\n\n**Official A - Piling Up Editorial**\n\nTo determine the increase in rating required, we denote the current rating by \\(R\\):\n\n- \\((100-R)\\) if \\(1 \\leq R \\leq 99\\)\n- \\((200-R)\\) if \\(100 \\leq R \\leq 199\\)\n- \\((300-R)\\) if \\(200 \\leq R \\leq 299\\)\n\nThis value can be printed using an if statement. Alternatively, using the remainder when \\(R\\) is divided by \\(100\\), one can implement the solution without a conditional branch.\n\n**Sample code in C++:**\n\n```python\nr = int(input())\nif r < 100:\n    print(100 - r)\nelif r < 200:\n    print(200 - r)\nelse:\n    print(300 - r)\n```\n\n**Sample code in Python:**\n\n```python\nr = int(input())\nif r < 100:\n    print(100 - r)\nelif r < 200:\n    print(200 - r)\nelse:\n    print(300 - r)\n```\n\n**Sample code in C++ (alternate solution):**\n\n```python\nr = int(input())\nprint(100 - (r % 100))\n```\n \n\n", "problem_ids": ["abc363_a"]}, "abc340_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is an integer sequence \\( S \\) of length \\( N \\). Initially, all elements of \\( S \\) are \\( 0 \\).\n\nYou are also given two integer sequences of length \\( Q \\): \\( P = (P_1, P_2, \\dots, P_Q) \\) and \\( V = (V_1, V_2, \\dots, V_Q) \\).\n\nSnuke wants to perform \\( Q \\) operations on the sequence \\( S \\) in order. The \\( i \\)-th operation is as follows:\n\n- Perform one of the following:\n  - Replace each of the elements \\( S_1, S_2, \\dots, S_{P_i} \\) with \\( V_i \\). However, before this operation, if there is an element among \\( S_1, S_2, \\dots, S_{P_i} \\) that is strictly greater than \\( V_i \\), Snuke will start crying.\n  - Replace each of the elements \\( S_{P_i}, S_{P_i+1}, \\dots, S_N \\) with \\( V_i \\). However, before this operation, if there is an element among \\( S_{P_i}, S_{P_i+1}, \\dots, S_N \\) that is strictly greater than \\( V_i \\), Snuke will start crying.\n\nFind the number of sequences of \\( Q \\) operations where Snuke can perform all operations without crying, modulo \\( 998244353 \\).\n\nTwo sequences of operations are distinguished if and only if there is \\( 1 \\leq i \\leq Q \\) such that the choice for the \\( i \\)-th operation is different.\n\n**Constraints**\n\n- \\( 2 \\leq N \\leq 5000 \\)\n- \\( 1 \\leq Q \\leq 5000 \\)\n- \\( 1 \\leq P_i \\leq N \\)\n- \\( 1 \\leq V_i \\leq 10^9 \\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nP_1 V_1\nP_2 V_2\n\\vdots\nP_Q V_Q\n```\n\n**Output**\n\nPrint the answer as an integer.\n\n**Sample Input 1**\n\n```\n8 3\n1 8\n8 1\n2 1\n```\n\n**Sample Output 1**\n\n```\n1\n```\n\nSnuke can perform the three operations without crying as follows:\n1. Replace \\( S_1 \\) with \\( 8 \\).\n2. Replace \\( S_8 \\) with \\( 1 \\).\n3. Replace \\( S_2, S_3, \\dots, S_8 \\) with \\( 1 \\).\n\nNo other sequences of operations satisfy the conditions, so the answer is \\( 1 \\). For example, if he replaces \\( S_1, S_2, \\dots, S_8 \\) with \\( 8 \\) in the first operation, he will cry in the second operation regardless of the choice.\n\n**Sample Input 2**\n\n```\n8 3\n8 1\n1 8\n1 2\n```\n\n**Sample Output 2**\n\n```\n0\n```\n\nNo matter how he performs the first two operations, he will cry in the third operation.\n\n**Sample Input 3**\n\n```\n241 82\n190 3207371\n229 3639088\n61 4428925\n84 17258698\n34 42692503\n207 59753183\n180 67198566\n78 99285033\n60 102449991\n234 122146510\n111 126959145\n141 152331579\n78 159855439\n11 169658471\n22 189991287\n37 204602946\n73 209329065\n72 215363269\n152 236450854\n175 237822921\n22 261431608\n144 252550201\n54 268889550\n238 276997357\n69 313065279\n226 330144323\n6 335788783\n126 345410019\n220 348318997\n166 365778763\n142 382251905\n200 406191336\n234 392702679\n83 409660987\n183 410908761\n142 445707116\n205 470279207\n230 486436406\n156 494269002\n113 495687706\n200 500005738\n162 505246499\n201 548652987\n86 449551554\n62 459527873\n32 574001635\n230 601073337\n175 610244315\n174 613857555\n181 637452273\n158 637866397\n148 648101378\n172 646898076\n144 682578257\n239 703460335\n192 713255331\n28 727075136\n196 730768166\n111 751850547\n90 762445737\n204 762552166\n72 773170159\n240 803415865\n32 798873367\n195 814999380\n72 842641864\n125 851815348\n116 858041919\n200 869948671\n195 873324903\n5 877767414\n105 877710280\n150 877719360\n9 884707717\n230 880263190\n88 967344715\n49 977643789\n167 979463984\n70 981400941\n114 991068035\n94 991951735\n141 995762200\n```\n\n**Sample Output 3**\n\n```\n682155965\n```\n\nRemember to take the count modulo \\( 998244353 \\).\n\nSolution:\n\n```\nEditorial - AtCoder Regular Contest 182\n\nA - Chmax Rush! Editorial by evima\n\nSolution: Let\u2019s denote the \\(i\\)-th operation as operation \\(i\\). For each operation, we will refer to the former choice as the left operation and the latter choice as the right operation. Consider the relationship between operations \\(i\\) and \\(j\\) for all integer pairs \\((i, j)\\) such that \\(1 \\leq i < j \\leq Q\\).\n\n- When \\(V_i \\leq V_j\\): Any choice is fine.\n- When \\(V_i > V_j\\) and \\(P_i = P_j\\): No matter what, Snuke will cry during operation \\(j\\), so the answer is \\(0\\).\n- When \\(V_i > V_j\\) and \\(P_i < P_j\\): Operation \\(i\\) must be a left operation, and operation \\(j\\) must be a right operation.\n- When \\(V_i > V_j\\) and \\(P_i > P_j\\): Operation \\(i\\) must be a right operation, and operation \\(j\\) must be a left operation.\n\nAfter determining the direction of each operation in this way, if there is a contradiction, it is clear that the answer is \\(0\\). If there is no contradiction, the answer is at least \\(1\\). This is because, for any operation, the direction is set so that it can be performed after the previous operations. For those operations whose direction is not set, either choice is fine, so let \\(x\\) be the number of such operations, and the answer is \\(2^x\\) modulo \\(998244353\\). Therefore, by implementing this directly, we can find the answer in \\(O(Q^2)\\) time. This is fast enough to solve this problem.\n\nJudge\u2019s Solution (PyPy3):\n```python\ndef change(p,k):\n    global kind\n    if kind[p]==0:\n        kind[p]=k\n    elif kind[p]!=k:\n        print(0)\n        exit()\n\nN,Q=map(int,input().split())\nope=[tuple(map(int,input().split())) for i in range(Q)]\nkind=[0]*Q\nfor i in range(Q):\n    for j in range(i+1,Q):\n        if ope[i][1]<=ope[j][1]:\n            continue\n        if ope[i][0]==ope[j][0]:\n            print(0)\n            exit()\n        elif ope[i][0]<ope[j][0]:\n            change(i,-1)\n            change(j,1)\n        else:\n            change(i,1)\n            change(j,-1)\nprint(pow(2,kind.count(0),998244353))\n```\n\nBonus: Consider how to solve this problem quickly even when \\(N, Q \\leq 2 \\times 10^5\\).\n```\n \n\n", "problem_ids": ["arc182_a"]}, "abc340_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nThere is a stack of `N` cards, and the `i-th` card from the top has an integer `A_i` written on it. You take `K` cards from the bottom of the stack and place them on top of the stack, maintaining their order.\n\nPrint the integers written on the cards from top to bottom after the operation.\n\n**Constraints**\n\n- \\(1 \\leq K < N \\leq 100\\)\n- \\(1 \\leq A_i \\leq 100\\)\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n\n```\nN K\nA_1 A_2 \\ldots A_N\n```\n\n**Output**\n\nLet `B_i` be the integer written on the `i-th` card from the top of the stack after the operation. Print `B_1, B_2, \\ldots, B_N` in this order, separated by spaces.\n\n**Sample Input 1**\n\n```\n5 3\n1 2 3 4 5\n```\n\n**Sample Output 1**\n\n```\n3 4 5 1 2\n```\n\nInitially, the integers written on the cards are `1, 2, 3, 4, 5` from top to bottom. After taking three cards from the bottom of the stack and placing them on top, the integers written on the cards become `3, 4, 5, 1, 2` from top to bottom.\n\n**Sample Input 2**\n\n```\n6 2\n1 2 1 2 1 2\n```\n\n**Sample Output 2**\n\n```\n1 2 1 2 1 2\n```\n\nThe integers written on the cards are not necessarily distinct.\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - Hitachi Vantara Programming Contest 2024 (AtCoder Beginner Contest 368)\n\nThe topmost card after an operation is the \\(K\\)-th card from the bottom in the original pile. The \\(K\\)-th bottommost card is the \\((N-K+1)\\) card from the top, so the cards after the operation have \\(A_{N-K+1},A_{N-K+2},\\ldots,A_{N},A_{1},A_{2},\\ldots\\), and \\(A_{N-K}\\) written on them from the top. You may print these values. In many programming languages, indices start from \\(0\\), so beware of indices.\n\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\nfor i in range(N-K,N): print(A[i])\nfor i in range(N-K): print(A[i])\n```\n\nIn languages like Python, one can easily achieve the operation of splitting a pile into two and move the lower part to the top, as follows:\nSample code (Python):\n```python\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\ntop = A[:-K]  # upper\nbottom = A[-K:]  # lower\nB = bottom + top  # put the lower part to the top\nprint(*B)\n```\n\nIn Python, you can also achieve a similar operation using list slicing:\n```python\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA = A[-K:] + A[:-K]\nprint(*A)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc368_a"]}, "abc340_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given \\( N \\) points \\((x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)\\) on a two-dimensional plane, and a non-negative integer \\( D \\).\n\nFind the number of integer pairs \\((x, y)\\) such that:\n\n\\[\n\\sum_{i=1}^N (|x-x_i|+|y-y_i|) \\leq D\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 0 \\leq D \\leq 10^6 \\)\n- \\( -10^6 \\leq x_i, y_i \\leq 10^6 \\)\n- \\((x_i, y_i) \\neq (x_j, y_j)\\) for \\( i \\neq j \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n```\nN D\nx_1 y_1\nx_2 y_2\n...\nx_N y_N\n```\n\n**Output:**\n\nPrint the answer. \n\n**Sample Input 1:**\n```\n2 3\n0 0\n1 0\n```\n\n**Sample Output 1:**\n```\n8\n```\n\n*Explanation for Sample 1*: The following figure visualizes the input and the answer for Sample 1. The blue points represent the input. The blue and red points, eight in total, satisfy the condition in the statement.\n\n**Sample Input 2:**\n```\n2 0\n0 0\n2 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\n**Sample Input 3:**\n```\n6 100\n9 -6\n10 -1\n2 10\n-1 7\n-7 5\n-1 -4\n```\n\n**Sample Output 3:**\n```\n419\n```\n\nSolution:\n\n```plaintext\nEditorial - AtCoder Beginner Contest 366\n\nE - Manhattan Multifocal Ellipse Editorial\n\nThis problem is an exercise of sliding window. In this editorial, we assume the knowledge of the sliding window. Let \\(f(x) = \\displaystyle \\sum_{i=1}^N |x-x_i|\\) and \\(g(y) = \\displaystyle \\sum_{i=1}^N |y-y_i|\\); then the answer is the number of pairs \\((x,y)\\) such that \\(f(x) + g(y) \\leq D\\). Let \\(M\\) be the maximum coordinate. If \\(|x| > M + D\\) or \\(|y| > M + D\\), then \\(f(x),g(y)>D\\), so it is sufficient to consider \\((x,y)\\) with \\(|x|,|y| \\leq M + D\\).\n\nTo find the answer, it is sufficient to solve the following two problems:\n\n1. Find \\(f(x)\\) and \\(g(y)\\) for given \\(x\\) and \\(y\\) with \\(|x|,|y| \\leq M+D\\).\n2. Count integers \\(y\\) satisfying \\(f(x)+g(y) \\leq D\\) for given \\(x\\) with \\(|x| \\leq M+D\\).\n\nSolution to problem 1: \nWe explain how to evaluate \\(f(x)\\). Sort \\((x_1,x_2,\\dots,x_N)\\) to make \\(x_1\\leq x_2 \\leq \\dots \\leq x_N\\). First, for \\(x=-(M+D)\\), compute \\(f(x)\\) naively. Then, we find \\(f(x)\\) based on \\(f(x-1)\\). Considering the difference, \\(f(x)\\) equals \\(f(x-1)\\) + (the number of \\(i\\) with \\(x_i < x\\)) + (the number of \\(i\\) with \\(x_i \\geq x\\)). Since the number of \\(i\\) with \\(x_i < x\\) is monotonically increasing with respect to \\(x\\), it can be found using sliding window fast.\n\nSolution to problem 2:\nPrepare two sequences \\(F=(f(-(M+D)), f(-(M+D)+1),\\dots, f(M+D))\\) and \\(G=(g(-(M+D)), g(-(M+D)+1),\\dots, g(M+D))\\), each of length \\(2(M+D)+1\\). Sort them in ascending order. For \\(i=2(M+D)+1,2(M+D),\\dots,1\\) in order, find the number of \\(j\\) such that \\(F_i + G_j \\leq D\\). Since \\(D-F_i\\) is monotonically increasing, so is the number of \\(j\\) that satisfies the inequality, which can be counted using the sliding window technique.\n\nThe time complexity is \\(O(N \\log N + (M+D) \\log (M+D))\\), with sorting being bottleneck in both problem 1 and 2.\n\nSample code (Python):\n```python\nN, D = map(int, input().split())\nx = [0] * N\ny = [0] * N\nfor i in range(N):\n    x[i], y[i] = map(int, input().split())\nM = 2 * 10**6\n\ndef calc(xs):\n    xsum = [0] * (2 * M + 1)\n    xs.sort()\n    i = 0\n    xsum[-M] = sum(xs) + N * M\n    for x in range(-M + 1, M + 1):\n        while i < N and xs[i] < x:\n            i += 1\n        xsum[x] = xsum[x - 1] + 2 * i - N\n    return xsum\n\nxsum = calc(x)\nysum = calc(y)\nxsum.sort()\nysum.sort()\nans = 0\nj = 0\nfor i in range(2 * M + 1)[::-1]:\n    while j < 2 * M + 1 and xsum[i] + ysum[j] <= D:\n        j += 1\n    ans += j\nprint(ans)\n```\n```\n \n\n", "problem_ids": ["abc366_e"]}, "abc340_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given sequences of positive integers \\( A \\) and \\( B \\) of length \\( N \\). Process \\( Q \\) queries given in the following forms in the order they are given. Each query is of one of the following three types:\n\n1. **Type 1**: Given in the form `1 i x`. Replace \\( A_i \\) with \\( x \\).\n2. **Type 2**: Given in the form `2 i x`. Replace \\( B_i \\) with \\( x \\).\n3. **Type 3**: Given in the form `3 l r`. Solve the following problem and print the answer:\n   - Initially, set \\( v = 0 \\). For \\( i = l, l+1, \\ldots, r \\) in this order, replace \\( v \\) with either \\( v + A_i \\) or \\( v \\times B_i \\). Find the maximum possible value of \\( v \\) at the end.\n\n**It is guaranteed that the answers to the given type 3 queries are at most \\( 10^{18} \\).**\n\n**Constraints**\n\n- \\( 1 \\leq N \\leq 10^5 \\)\n- \\( 1 \\leq A_i \\leq 10^9 \\)\n- \\( 1 \\leq B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 10^5 \\)\n- For type 1 and 2 queries, \\( 1 \\leq i \\leq N \\).\n- For type 1 and 2 queries, \\( 1 \\leq x \\leq 10^9 \\).\n- For type 3 queries, \\( 1 \\leq l \\leq r \\leq N \\).\n- For type 3 queries, the value to be printed is at most \\( 10^{18} \\).\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_N\nQ\nquery_1\nquery_2\n\\vdots\nquery_Q\n```\n\nHere, `query_i` is the \\( i \\)-th query, given in one of the following formats:\n- `1 i x`\n- `2 i x`\n- `3 l r`\n\n**Output**\n\nLet \\( q \\) be the number of type 3 queries. Print \\( q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th type 3 query.\n\n**Sample Input 1**\n```\n3\n3 2 4\n1 2 2\n3\n3 1 3\n1 1 1\n3 1 3\n```\n\n**Sample Output 1**\n```\n12\n7\n```\n\nFor the first query, the answer is \\(((0 + A_1) \\times B_2) \\times B_3 = 12\\).\n\nFor the third query, the answer is \\(((0 + A_1) + A_2) + A_3 = 7\\).\n\n**Sample Input 2**\n```\n6\n65 32 12 5 8 312\n4 1 3 15 16 2\n6\n3 2 6\n3 1 5\n1 5 6\n2 4 9\n3 2 6\n3 3 5\n```\n\n**Sample Output 2**\n```\n46080\n69840\n27648\n1728\n```\n\nSolution:\n\n```\nConsider a type-3 query. Let \\(M\\) be the maximum \\(A\\). First, for \\(i = l\\), set \\(v = 0\\) and replace \\(v\\) with \\(v + A[i]\\). By the constraints, \\(v\\) becomes positive. Replace \\(v\\) with \\(v \\times B[i]\\) at most \\(\\log_2 M (< 60)\\) times, since \\(2^{60} > 10^{18}\\) and the input restricts this operation to under 60 times. Thus, the loop iterates a maximum of 59 times:\n\n```python\nv = A[l]\nwhile True:\n    next_l = min(r, smallest_i_after_l_plus_1_such_that_Bi_geq_2)\n    v += sum_a(l + 1, next_l)\n    v = max(v + A[next_l], v * B[next_l])\n    l = next_l\n    if l == r:\n        break\noutput(v)\n```\n\nBy using a segment tree appropriately, the complexity becomes \\(O(N + Q \\log N \\log M)\\). The algorithm is efficient due to the small constant factor.\n```\n \n\n", "problem_ids": ["abc368_g"]}, "abc341_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 350 points\n\n**Problem Statement**\n\nYou are given a string \\( S \\) of length \\( N \\). You are also given \\( Q \\) queries, which you should process in order.\n\nThe \\( i \\)-th query is as follows:\n- Given an integer \\( X_i \\) and a character \\( C_i \\), replace the \\( X_i \\)-th character of \\( S \\) with \\( C_i \\). Then, print the number of times the string \"ABC\" appears as a substring in \\( S \\).\n\nHere, a **substring** of \\( S \\) is a string obtained by deleting zero or more characters from the beginning and zero or more characters from the end of \\( S \\). For example, \"ab\" is a substring of \"abc\", but \"ac\" is not a substring of \"abc\".\n\n**Constraints**\n\n- \\( 3 \\le N \\le 2 \\times 10^5 \\)\n- \\( 1 \\le Q \\le 2 \\times 10^5 \\)\n- \\( S \\) is a string of length \\( N \\) consisting of uppercase English letters.\n- \\( 1 \\le X_i \\le N \\)\n- \\( C_i \\) is an uppercase English letter.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nN Q\nS\nX_1 C_1\nX_2 C_2\n\\vdots\nX_Q C_Q\n```\n\n**Output**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line (1 \u2264 \\( i \\) \u2264 \\( Q \\)) should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1**\n```\n7 4\nABCDABC\n4 B\n3 A\n5 C\n4 G\n```\n\n**Sample Output 1**\n```\n2\n1\n1\n0\n```\n\nAfter processing each query, \\( S \\) becomes as follows:\n- After the first query: \\( S = \\) \"ABCBABC\". In this string, \"ABC\" appears twice as a substring.\n- After the second query: \\( S = \\) \"ABABABC\". In this string, \"ABC\" appears once as a substring.\n- After the third query: \\( S = \\) \"ABABCBC\". In this string, \"ABC\" appears once as a substring.\n- After the fourth query: \\( S = \\) \"ABAGCBC\". In this string, \"ABC\" appears zero times as a substring.\n\n**Sample Input 2**\n```\n3 3\nABC\n1 A\n2 B\n3 C\n```\n\n**Sample Output 2**\n```\n1\n1\n1\n```\n\nThere are cases where \\( S \\) does not change through processing a query.\n\n**Sample Input 3**\n```\n15 10\nBBCCBCACCBACACA\n9 C\n11 B\n5 B\n11 B\n4 A\n8 C\n8 B\n5 B\n7 B\n14 B\n```\n\n**Sample Output 3**\n```\n0\n0\n0\n0\n1\n1\n2\n2\n1\n1\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Autumn (AtCoder Beginner Contest 372)\n\nC - Count ABC Again Editorial by en_translator\n\nIf you ignore the constraints, the following solution is valid:\n\nModify the \\(X_i\\)-th character of \\(S\\) to \\(C_i\\). Inspect the \\((N-2)\\) length-\\(3\\) substrings of \\(S\\), check if each coincides with ABC, and print the number of such substrings.\n\nHowever, \\(N\\) and \\(Q\\) can become as large as \\(2\\times 10^5\\), so this solution would result in TLE (Time Limit Exceeded). Now notice that modifying one character of \\(S\\) changes at most three length-\\(3\\) substrings of \\(S\\). For example, suppose that \\(S=\\) ABCDEFGHI has become \\(S=\\) ABCZEFGI. Before the modification, the length-\\(3\\) substrings of \\(S\\) were:\n\nABC, BCD, CDE, DEF, EFG, FGH, GHI.\n\nAfter the modification, it has become:\n\nABC, BCZ, CZE, ZEF, EFG, FGH, GHI.\n\nAmong them, only three substrings have changed. In general, at most three length-\\(3\\) substrings will change. Therefore, it is sufficient to inspect only three substrings that possibly changes, count the number of ABC before and after modifications, and find the answer after the modification based on the difference and the count before the modification. The complexity is \\(O(N+Q)\\).\n\nSample code (Python3)\n```python\nN, Q = map(int, input().split())\nS = list(input())\nans = 0\nfor i in range(N - 2):\n    if S[i] == \"A\" and S[i + 1] == \"B\" and S[i + 2] == \"C\":\n        ans += 1\nfor _ in range(Q):\n    t, c = input().split()\n    t = int(t) - 1\n    for k in range(3):\n        idx = t - k\n        if 0 <= idx and idx + 2 < N:\n            if S[idx] == \"A\" and S[idx + 1] == \"B\" and S[idx + 2] == \"C\":\n                ans -= 1\n    S[t] = c\n    for k in range(3):\n        idx = t - k\n        if 0 <= idx and idx + 2 < N:\n            if S[idx] == \"A\" and S[idx + 1] == \"B\" and S[idx + 2] == \"C\":\n                ans += 1\n    print(ans)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc372_c"]}, "abc341_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi and Aoki played rock-paper-scissors \\(N\\) times. [Note: In this game, Rock beats Scissors, Scissors beats Paper, and Paper beats Rock.]\n\nAoki's moves are represented by a string \\(S\\) of length \\(N\\) consisting of the characters \\(R\\), \\(P\\), and \\(S\\). The \\(i\\)-th character of \\(S\\) indicates Aoki's move in the \\(i\\)-th game: \\(R\\) for Rock, \\(P\\) for Paper, and \\(S\\) for Scissors.\n\nTakahashi's moves satisfy the following conditions:\n1. Takahashi never lost to Aoki.\n2. For \\(i = 1, 2, \\ldots, N-1\\), Takahashi's move in the \\(i\\)-th game is different from his move in the \\((i+1)\\)-th game.\n\nDetermine the maximum number of games Takahashi could have won.\n\nIt is guaranteed that there exists a sequence of moves for Takahashi that satisfies these conditions.\n\n**Constraints**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(S\\) is a string of length \\(N\\) consisting of \\(R\\), \\(P\\), and \\(S\\).\n- \\(N\\) is an integer.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN\nS\n```\n\n**Output**\nPrint the maximum number of games Takahashi could have won.\n\n**Sample Input 1**\n```\n6\nPRSSRS\n```\n\n**Sample Output 1**\n```\n5\n```\n\n*Explanation:* In the six games of rock-paper-scissors, Aoki played Paper, Rock, Scissors, Scissors, Rock, and Scissors. Takahashi can play Scissors, Paper, Rock, Scissors, Paper, and Rock to win the 1st, 2nd, 3rd, 5th, and 6th games. There is no sequence of moves for Takahashi that satisfies the conditions and wins all six games, so print 5.\n\n**Sample Input 2**\n```\n10\nSSSSSSSSSS\n```\n\n**Sample Output 2**\n```\n5\n```\n\n**Sample Input 3**\n```\n24\nSPRPSRRRRRPPRPRPSSRSPRSS\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Here is the trimmed content containing only the solution to the coding problem:\n\n---\n\nDefine \\(\\operatorname{dp} _ i[H]\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) by:\n\n\\(\\operatorname{dp} _ i[H]\\coloneqq\\) the maximum number of Takahashi\u2019s wins during conforming first \\(i\\) hands of Takahashi such that his \\(i\\)-th hand is \\(H\\).\n\nHere, we define \\(\\operatorname{dp} _ 0[H]=0\\) for convenience. (DP stands for Dynamic Programming.)\n\nTakahashi\u2019s \\(i\\)-th move is solely dependent on Aoki\u2019s \\(i\\)-th hand and Takahashi\u2019s \\(i\\)-th hand. Therefore, \\(\\operatorname{dp} _ i[H]\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) can be found based on \\(\\operatorname{dp} _ {i-1}\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) (and the value \\(S _ i\\)). Specifically, let \\(\\operatorname{rps}(a,b)\\) be \\(1\\) if \\(a\\) wins \\(b\\), \\(-1\\) if it loses, and \\(0\\) if they are draw (here rps stands for rock-scissors-paper), then\n\n\\[\\operatorname{dp} _ i[H]=\\begin{cases}\\displaystyle\\max _ {H^\\prime\\neq H}\\operatorname{dp} _ {i-1}[H^\\prime]&\\ &(\\operatorname{janken}(H,S _ i)=0)\\\\1+\\displaystyle\\max _ {H^\\prime\\neq H}\\operatorname{dp} _ {i-1}[H^\\prime]&&(\\operatorname{janken}(H,S _ i)=1)\\\\0&&(\\operatorname{janken}(H,S _ i)=-1).\\end{cases}\\]\n\nWhile we may set \\(-\\infty\\) to the value of the DP table when losing, one can prove that setting \\(0\\) still yields a correct value.\n\nThe following is sample code.\n\n```python\ndef main():\n    N = int(input().strip())\n    S = input().strip()\n\n    dp = [0, 0, 0]\n    rock, scissors, paper = dp\n\n    for c in S:\n        dp = [max(scissors, paper), max(rock, paper), max(rock, scissors)]\n\n        if c == 'R':\n            scissors = 0\n            paper += 1\n        elif c == 'S':\n            paper = 0\n            rock += 1\n        elif c == 'P':\n            rock = 0\n            scissors += 1\n\n    print(max(dp))\n\nmain()\n```\n \n\n", "problem_ids": ["abc365_d"]}, "abc341_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a positive integer \\( N \\), and an integer \\( A_{x,y,z} \\) for each triple of integers \\( (x, y, z) \\) such that \\( 1 \\leq x, y, z \\leq N \\).\n\nYou will be given \\( Q \\) queries in the following format, which must be processed in order.\n\nFor the \\( i \\)-th query \\( (1 \\leq i \\leq Q) \\), you are given a tuple of integers \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\) such that \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\), \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\), and \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\). Find:\n\n\\[\n\\displaystyle{\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}}\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 0 \\leq A_{x,y,z} \\leq 999 \\) where \\( 1 \\leq x, y, z \\leq N \\)\n- \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n- The integer \\( N \\)\n- An \\( N \\times N \\times N \\) array \\( A \\) of integers, given in the order \\( A_{1,1,1}, A_{1,1,2}, \\ldots \\), i.e., iterating through \\( x \\), then \\( y \\), then \\( z \\).\n- The integer \\( Q \\)\n- \\( Q \\) lines, each containing six integers representing \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\)\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n\n```\n2\n1 2\n3 4\n5 6\n7 8\n2\n1 2 2 2 1 1\n2 2 1 2 1 2\n```\n\n**Sample Output 1:**\n\n```\n10\n26\n```\n\n**Explanation:**\n\nFor the 1st query, the sought value is \\( A_{1,2,1} + A_{2,2,1} = 3 + 7 = 10 \\). Thus, print 10.\n\nFor the 2nd query, the sought value is \\( A_{2,1,1} + A_{2,1,2} + A_{2,2,1} + A_{2,2,2} = 5 + 6 + 7 + 8 = 26 \\). Thus, print 26.\n\n**Sample Input 2:**\n\n```\n3\n733 857 714\n956 208 257\n123 719 648\n840 881 245\n245 112 746\n306 942 694\n58 870 849\n13 208 789\n687 906 783\n8\n3 3 3 3 1 1\n1 3 2 3 3 3\n2 2 2 3 1 1\n1 3 1 1 1 1\n2 3 2 3 2 3\n1 2 1 1 1 2\n3 3 2 2 1 3\n1 2 2 3 2 3\n```\n\n**Sample Output 2:**\n\n```\n687\n3917\n551\n1631\n5180\n3311\n1010\n4326\n```\n\nSolution:\n\n```plaintext\nD - Cuboid Sum Query Editorial\n\nThis problem is an exercise of cumulative sums. We assume the knowledge of cumulative sums for a sequence (one-dimensional cumulative sums).\n\nGiven a length-\\(N\\) sequence \\(A\\), process \\(Q\\) queries. In the \\(i\\)-th query, given an integer pair \\((L_i,R_i)\\) satisfying \\(1 \\leq L_i \\leq R_i \\leq N\\), find \\(\\sum_{k=L_i}^{R_i}A_k\\).\n\nA solution to this problem is as follows: Define a length-\\((N+1)\\) sequence \\(S=(S_0,S_1,\\ldots S_N)\\) by \\(S_0=0,S_i=\\sum_{k=1}^{i-1}A_k\\), and use \\(\\sum_{k=L_i}^{R_i}A_k=S_{R_i+1}-S_{L_i}\\) to answer the query fast. The sequence \\(S\\) is called the cumulative sums of \\(A\\).\n\nThe original problem is an extension of this one-dimensional cumulative sum problem into three dimensions.\n\nConsider \\(S\\) such that \\(S_{i,j,k}=\\sum_{x=1}^{i-1} \\sum_{y=1}^{j-1}\\sum_{z=1}^{k-1}A_{x,y,z}\\) for \\(1 \\leq i,j,k \\leq N+1\\). If \\(i\\), \\(j\\), or \\(k\\) is \\(0\\), define \\(S_{i,j,k}=0\\).\n\nIt holds that \\(\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}=S_{Rx_i+1,Ry_i+1,Rz_i+1}-S_{Lx_i,Rx_i+1,Rz_i+1}-S_{Rx_i+1,Ly_i,Rz_i+1}-S_{Rx_i+1,Ry_i+1,Lz_i}+S_{Lx_i,Ly_i,Rz_i+1}+S_{Lx_i,Ry_i+1,Lz_i}+S_{Rx_i+1,Ly_i,Lz_i}-S_{Lx_i,Ly_i,Lz_i}\\).\n\nTherefore, if one can compute \\(S\\) fast, then each query can be answered in constant time.\n\n\\(S\\) can be found by the property that \\(S_{i,j,k}=S_{i-1,j,k}+S_{i,j-1,k}+S_{i,j,k-1}-S_{i-1,j-1,k}-S_{i-1,j,k-1}-S_{i,j-1,k-1}+S_{i-1,j-1,k-1}+A_{i-1,j-1,k-1}\\). The time complexity is \\(O(N^3+Q)\\).\n\nSample code (Python):\n```python\nn = int(input())\n\na = [[[0] * n for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        a[i][j]=list(map(int,input().split()))\n\nsum = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            sum[i + 1][j + 1][k + 1] = (sum[i][j+1][k+1]\n                                        + sum[i+1][j][k+1]\n                                        + sum[i+1][j+1][k]\n                                        - sum[i][j][k+1]\n                                        - sum[i][j+1][k]\n                                        - sum[i+1][j][k]\n                                        + sum[i][j][k]\n                                        + a[i][j][k])\n\nq = int(input())\nfor _ in range(q):\n    lx, rx, ly, ry, lz, rz = map(int, input().split())\n    lx -= 1\n    ly -= 1\n    lz -= 1\n\n    result = (sum[rx][ry][rz]\n                - sum[lx][ry][rz]\n                - sum[rx][ly][rz]\n                - sum[rx][ry][lz]\n                + sum[lx][ly][rz]\n                + sum[lx][ry][lz]\n                + sum[rx][ly][lz]\n                - sum[lx][ly][lz])\n    print(result)\n```\n```\n```\n \n\n", "problem_ids": ["abc366_d"]}, "abc341_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 150 points\n\nProblem Statement:\nThere are \\(2N\\) people standing in a row, and the person at the \\(i\\)-th position from the left is wearing clothes of color \\(A_i\\). The clothes have \\(N\\) colors from \\(1\\) to \\(N\\), and exactly two people are wearing clothes of each color.\n\nFind how many of the integers \\(i=1,2,\\ldots,N\\) satisfy the following condition:\n- There is exactly one person between the two people wearing clothes of color \\(i\\).\n\nConstraints:\n- \\(2 \\leq N \\leq 100\\)\n- \\(1 \\leq A_i \\leq N\\)\n- Each integer from \\(1\\) through \\(N\\) appears exactly twice in \\(A\\).\n- All input values are integers.\n\nInput:\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 A_2 \\ldots A_{2N}\n```\n\nOutput:\nPrint the answer.\n\nSample Input 1:\n```\n3\n1 2 1 3 2 3\n```\n\nSample Output 1:\n```\n2\n```\n\nExplanation:\nThere are two values of \\(i\\) that satisfy the condition: \\(1\\) and \\(3\\).\nIn fact, the people wearing clothes of color \\(1\\) are at the 1st and 3rd positions from the left, with exactly one person in between.\n\nSample Input 2:\n```\n2\n1 1 2 2\n```\n\nSample Output 2:\n```\n0\n```\n\nExplanation:\nThere may be no \\(i\\) that satisfies the condition.\n\nSample Input 3:\n```\n4\n4 3 2 3 2 1 4 1\n```\n\nSample Output 3:\n```\n3\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Editorial - UNIQUE VISION Programming Contest 2024 Summer (AtCoder Beginner Contest 359)\n\nB - Couples Editorial by en_translator\n\nBy mathematically interpreting the problem statement, it turns out that it is asking to count \\(i\\) such that \\(A_i=A_{i+2}\\). Use for and if statements to check if each \\(i\\) satisfies the condition. Sample code (Python3):\n\n```python\nn = int(input())\na = [int(input()) for _ in range(n * 2)]\nres = 0\nfor i in range(n * 2 - 2):\n    if a[i] == a[i + 2]:\n        res += 1\nprint(res)\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc359_b"]}, "abc341_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nGiven integers \\(N\\) and \\(M\\), compute the sum \\(\\sum_{k=0}^{N} \\text{popcount}(k \\& M)\\), modulo \\(998244353\\).\n\nHere, \\(\\&\\) represents the bitwise AND operation.\n\n**What is the bitwise AND operation?**\n\nThe result \\(x = a \\& b\\) of the bitwise AND operation between non-negative integers \\(a\\) and \\(b\\) is defined as follows:\n\n- \\(x\\) is the unique non-negative integer that satisfies the following conditions for all non-negative integers \\(k\\):\n  - If the \\(2^k\\) place in the binary representation of \\(a\\) and \\(b\\) are both \\(1\\), then the \\(2^k\\) place in the binary representation of \\(x\\) is \\(1\\).\n  - Otherwise, the \\(2^k\\) place in the binary representation of \\(x\\) is \\(0\\).\n\nFor example, \\(3=11_{(2)}\\) and \\(5=101_{(2)}\\), so \\(3 \\& 5 = 1\\).\n\n**What is popcount?**\n\n\\(\\text{popcount}(x)\\) represents the number of \\(1\\)s in the binary representation of \\(x\\).\n\nFor example, \\(13=1101_{(2)}\\), so \\(\\text{popcount}(13) = 3\\).\n\n**Constraints:**\n\n- \\(N\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n- \\(M\\) is an integer between \\(0\\) and \\(2^{60} - 1\\), inclusive.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN M\n```\n\n**Output:**\n\nPrint the answer as an integer.\n\n**Sample Input 1:**\n```\n4 3\n```\n\n**Sample Output 1:**\n```\n4\n```\n\n- \\(\\text{popcount}(0 \\& 3) = 0\\)\n- \\(\\text{popcount}(1 \\& 3) = 1\\)\n- \\(\\text{popcount}(2 \\& 3) = 1\\)\n- \\(\\text{popcount}(3 \\& 3) = 2\\)\n- \\(\\text{popcount}(4 \\& 3) = 0\\)\n\nThe sum of these values is \\(4\\).\n\n**Sample Input 2:**\n```\n0 0\n```\n\n**Sample Output 2:**\n```\n0\n```\n\nIt is possible that \\(N = 0\\) or \\(M = 0\\).\n\n**Sample Input 3:**\n```\n1152921504606846975 1152921504606846975\n```\n\n**Sample Output 3:**\n```\n499791890\n```\n\nRemember to compute the result modulo \\(998244353\\).\n\nSolution:\n\n[BEGIN TEXT]\nThe editorial presents the solution to a problem from AtCoder Beginner Contest 356, specifically the \"D - Masked Popcount\" problem. The goal is to compute the sum of set bits in the result of bitwise AND operations between each integer from 0 to N and a given integer M with the following steps:\n\n1. Iterate over each bit position \\( j \\) from 0 to 59.\n2. If the \\( j \\)-th bit of \\( M \\) is set, for each \\( j \\), add to the result the count of integers between 0 and N whose \\( j \\)-th bit is set.\n3. The number of integers with the \\( j \\)-th bit set is calculated by examining ranges defined by powers of two.\n4. During computation, handle overflow by taking results modulo 998244353.\n\nThe solution involves efficiently counting set bits using bit operations and properties of numbers, ensuring accurate summing even under large values.\n[END TEXT]\n \n\n", "problem_ids": ["abc356_d"]}, "abc341_f": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nYou are given a positive integer \\( N \\), and an integer \\( A_{x,y,z} \\) for each triple of integers \\( (x, y, z) \\) such that \\( 1 \\leq x, y, z \\leq N \\).\n\nYou will be given \\( Q \\) queries in the following format, which must be processed in order.\n\nFor the \\( i \\)-th query \\( (1 \\leq i \\leq Q) \\), you are given a tuple of integers \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\) such that \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\), \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\), and \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\). Find:\n\n\\[\n\\displaystyle{\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}}\n\\]\n\n**Constraints:**\n\n- \\( 1 \\leq N \\leq 100 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^{5} \\)\n- \\( 0 \\leq A_{x,y,z} \\leq 999 \\) where \\( 1 \\leq x, y, z \\leq N \\)\n- \\( 1 \\leq Lx_i \\leq Rx_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Ly_i \\leq Ry_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- \\( 1 \\leq Lz_i \\leq Rz_i \\leq N \\) for \\( 1 \\leq i \\leq Q \\)\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n\n- The integer \\( N \\)\n- An \\( N \\times N \\times N \\) array \\( A \\) of integers, given in the order \\( A_{1,1,1}, A_{1,1,2}, \\ldots \\), i.e., iterating through \\( x \\), then \\( y \\), then \\( z \\).\n- The integer \\( Q \\)\n- \\( Q \\) lines, each containing six integers representing \\( (Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i) \\)\n\n**Output:**\n\nPrint \\( Q \\) lines. The \\( i \\)-th line should contain the answer to the \\( i \\)-th query.\n\n**Sample Input 1:**\n\n```\n2\n1 2\n3 4\n5 6\n7 8\n2\n1 2 2 2 1 1\n2 2 1 2 1 2\n```\n\n**Sample Output 1:**\n\n```\n10\n26\n```\n\n**Explanation:**\n\nFor the 1st query, the sought value is \\( A_{1,2,1} + A_{2,2,1} = 3 + 7 = 10 \\). Thus, print 10.\n\nFor the 2nd query, the sought value is \\( A_{2,1,1} + A_{2,1,2} + A_{2,2,1} + A_{2,2,2} = 5 + 6 + 7 + 8 = 26 \\). Thus, print 26.\n\n**Sample Input 2:**\n\n```\n3\n733 857 714\n956 208 257\n123 719 648\n840 881 245\n245 112 746\n306 942 694\n58 870 849\n13 208 789\n687 906 783\n8\n3 3 3 3 1 1\n1 3 2 3 3 3\n2 2 2 3 1 1\n1 3 1 1 1 1\n2 3 2 3 2 3\n1 2 1 1 1 2\n3 3 2 2 1 3\n1 2 2 3 2 3\n```\n\n**Sample Output 2:**\n\n```\n687\n3917\n551\n1631\n5180\n3311\n1010\n4326\n```\n\nSolution:\n\n```plaintext\nD - Cuboid Sum Query Editorial\n\nThis problem is an exercise of cumulative sums. We assume the knowledge of cumulative sums for a sequence (one-dimensional cumulative sums).\n\nGiven a length-\\(N\\) sequence \\(A\\), process \\(Q\\) queries. In the \\(i\\)-th query, given an integer pair \\((L_i,R_i)\\) satisfying \\(1 \\leq L_i \\leq R_i \\leq N\\), find \\(\\sum_{k=L_i}^{R_i}A_k\\).\n\nA solution to this problem is as follows: Define a length-\\((N+1)\\) sequence \\(S=(S_0,S_1,\\ldots S_N)\\) by \\(S_0=0,S_i=\\sum_{k=1}^{i-1}A_k\\), and use \\(\\sum_{k=L_i}^{R_i}A_k=S_{R_i+1}-S_{L_i}\\) to answer the query fast. The sequence \\(S\\) is called the cumulative sums of \\(A\\).\n\nThe original problem is an extension of this one-dimensional cumulative sum problem into three dimensions.\n\nConsider \\(S\\) such that \\(S_{i,j,k}=\\sum_{x=1}^{i-1} \\sum_{y=1}^{j-1}\\sum_{z=1}^{k-1}A_{x,y,z}\\) for \\(1 \\leq i,j,k \\leq N+1\\). If \\(i\\), \\(j\\), or \\(k\\) is \\(0\\), define \\(S_{i,j,k}=0\\).\n\nIt holds that \\(\\sum_{x=Lx_i}^{Rx_i} \\sum_{y=Ly_i}^{Ry_i} \\sum_{z=Lz_i}^{Rz_i} A_{x,y,z}=S_{Rx_i+1,Ry_i+1,Rz_i+1}-S_{Lx_i,Rx_i+1,Rz_i+1}-S_{Rx_i+1,Ly_i,Rz_i+1}-S_{Rx_i+1,Ry_i+1,Lz_i}+S_{Lx_i,Ly_i,Rz_i+1}+S_{Lx_i,Ry_i+1,Lz_i}+S_{Rx_i+1,Ly_i,Lz_i}-S_{Lx_i,Ly_i,Lz_i}\\).\n\nTherefore, if one can compute \\(S\\) fast, then each query can be answered in constant time.\n\n\\(S\\) can be found by the property that \\(S_{i,j,k}=S_{i-1,j,k}+S_{i,j-1,k}+S_{i,j,k-1}-S_{i-1,j-1,k}-S_{i-1,j,k-1}-S_{i,j-1,k-1}+S_{i-1,j-1,k-1}+A_{i-1,j-1,k-1}\\). The time complexity is \\(O(N^3+Q)\\).\n\nSample code (Python):\n```python\nn = int(input())\n\na = [[[0] * n for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        a[i][j]=list(map(int,input().split()))\n\nsum = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            sum[i + 1][j + 1][k + 1] = (sum[i][j+1][k+1]\n                                        + sum[i+1][j][k+1]\n                                        + sum[i+1][j+1][k]\n                                        - sum[i][j][k+1]\n                                        - sum[i][j+1][k]\n                                        - sum[i+1][j][k]\n                                        + sum[i][j][k]\n                                        + a[i][j][k])\n\nq = int(input())\nfor _ in range(q):\n    lx, rx, ly, ry, lz, rz = map(int, input().split())\n    lx -= 1\n    ly -= 1\n    lz -= 1\n\n    result = (sum[rx][ry][rz]\n                - sum[lx][ry][rz]\n                - sum[rx][ly][rz]\n                - sum[rx][ry][lz]\n                + sum[lx][ly][rz]\n                + sum[lx][ry][lz]\n                + sum[rx][ly][lz]\n                - sum[lx][ly][lz])\n    print(result)\n```\n```\n```\n \n\n", "problem_ids": ["abc366_d"]}, "abc342_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nThere are \\( N \\) people, numbered from 1 to \\( N \\). A competition was held among these \\( N \\) people, and they were ranked accordingly. The following information is given about their ranks:\n\n1. Each person has a unique rank.\n2. For each \\( 1 \\leq i \\leq M \\), if person \\( A_i \\) is ranked \\( x \\)-th and person \\( B_i \\) is ranked \\( y \\)-th, then \\( x - y = C_i \\).\n\nThe given input guarantees that there is at least one possible ranking that does not contradict the given information.\n\nYou need to answer \\( N \\) queries. The answer to the \\( i \\)-th query is determined as follows:\n- If the rank of person \\( i \\) can be uniquely determined, return that rank.\n- Otherwise, return \\(-1\\).\n\n### Constraints\n- \\( 2 \\leq N \\leq 16 \\)\n- \\( 0 \\leq M \\leq \\frac{N(N - 1)}{2} \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- \\( 1 \\leq C_i \\leq N - 1 \\)\n- \\( (A_i, B_i) \\neq (A_j, B_j) \\) if \\( i \\neq j \\)\n- All input values are integers\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M\nA_1 B_1 C_1\nA_2 B_2 C_2\n...\nA_M B_M C_M\n```\n\n### Output\nPrint the answers to the \\( 1 \\)-st, \\( 2 \\)-nd, ..., \\( N \\)-th queries in this order, separated by spaces.\n\n### Sample Input 1\n```\n5 2\n2 3 3\n5 4 3\n```\n\n### Sample Output 1\n```\n3 -1 -1 -1 -1\n```\n\nExplanation: Let \\( X_i \\) be the rank of person \\( i \\). The possible rankings could be \\( (3, 4, 1, 2, 5) \\) or \\( (3, 5, 2, 1, 4) \\). Therefore, only the rank of person 1 is uniquely determined as 3.\n\n### Sample Input 2\n```\n3 0\n```\n\n### Sample Output 2\n```\n-1 -1 -1\n```\n\n### Sample Input 3\n```\n8 5\n6 7 3\n8 1 7\n4 5 1\n7 2 1\n6 2 4\n```\n\n### Sample Output 3\n```\n1 -1 -1 -1 -1 -1 -1 8\n```\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 352\n\nConsider a \\(N\\)-vertex \\(M\\)-edge graph whose \\(i\\)-th edge connects vertex \\(A_i\\) and vertex \\(B_i\\). By the constraints, we can take an integer sequence \\(D = (D_1, D_2, \\ldots, D_N)\\) such that \\(D_{A_i} - D_{B_i} = C_i\\) for each \\(i\\). This sequence can be obtained by appropriately performing DFS (Depth-First Search) or BFS (Breadth-First Search) on the graph defined above. The sequence of person \\(i\\)\u2019s rank \\(X_i\\), collectively written as \\(X = (X_1, X_2, \\ldots, X_N)\\), is limited to permutations of \\((1,2,\\ldots, N)\\) such that:\n\n\\(X_i = D_i + v\\), where \\(v\\) is an arbitrary integer taken for each connected component and \\(i\\) is any of the vertices in it.\n\nWe try to respond to the query per connected component. When finding the answer to the \\(i\\)-th query, we perform a bit DP (Dynamic Programming) that places connected components not containing vertex \\(i\\). Specifically, maintain boolean values \\(dp_{x,y}\\) that represent whether the vertices in the first \\(x\\) connected components may correspond to the set of ranks \\(y\\). Since there are \\(O(N)\\) pairs of possible tuples of rank for each connected component, the DP above costs \\(O(N^2 2^N)\\) time naively, or \\(O(N 2^N)\\) time if you use the property that the value of \\(x\\) uniquely determines the popcount of \\(y\\). Therefore, the problem has been solved in a total of \\(O(N^2 2^N)\\) time.\n```\n \n\n", "problem_ids": ["abc352_f"]}, "abc342_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nYou are given integer sequences of length \\( N \\): \\( A = (A_1, A_2, \\cdots, A_N) \\) and \\( B = (B_1, B_2, \\cdots, B_N) \\), and an integer \\( K \\).\n\nYou can perform the following operation zero or more times:\n\n- Choose integers \\( i \\) and \\( j \\) (where \\( 1 \\leq i, j \\leq N \\)) such that \\( |i-j| \\leq K \\). Then, change the value of \\( A_i \\) to \\( A_j \\).\n\nDetermine whether it is possible to make \\( A \\) identical to \\( B \\).\n\nThere are \\( T \\) test cases for each input.\n\n**Constraints**\n\n- \\( 1 \\leq T \\leq 125000 \\)\n- \\( 1 \\leq K < N \\leq 250000 \\)\n- \\( 1 \\leq A_i, B_i \\leq N \\)\n- The sum of \\( N \\) across all test cases in each input is at most 250000.\n- All input values are integers.\n\n**Input Format**\n\nThe input is given from Standard Input in the following format:\n\n```\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n```\n\nEach test case is given in the following format:\n\n```\nN K\nA_1 A_2 \\cdots A_N\nB_1 B_2 \\cdots B_N\n```\n\n**Output Format**\n\nFor each test case, print `Yes` if it is possible to make \\( A \\) identical to \\( B \\), and `No` otherwise.\n\n**Sample Input 1**\n\n```\n4\n3 1\n1 1 2\n1 2 2\n5 4\n2 4 5 1 3\n2 1 3 2 2\n13 1\n3 1 3 3 5 3 3 4 2 2 2 5 1\n5 3 3 3 4 2 2 2 2 5 5 1 3\n20 14\n10 6 6 19 13 16 15 15 2 10 2 16 9 12 2 6 13 5 5 9\n5 9 6 2 10 19 16 15 13 12 10 2 9 6 5 16 19 12 15 13\n```\n\n**Sample Output 1**\n\n```\nYes\nYes\nNo\nYes\n```\n\n**Explanation for Sample Input 1**\n\nConsider the first test case. If we operate with \\( i=2 \\) and \\( j=3 \\), the value of \\( A_2 \\) will be changed to \\( A_3=2 \\), resulting in \\( A=(1,2,2) \\).\n\nSolution:\n\n```\nOfficial\n\nB - Near Assignment Editorial by evima\n\nIf \\(A = B\\), it is clearly possible, so we consider other cases. Consider two cases based on the value of \\(K\\).\n\nCase \\(K = 1\\): Considering the result of run-length encoding of the elements in \\(A\\), it can \u201cdecrease\u201d through operations, but not \u201cincrease.\u201d From this, we can deduce that the result of run-length encoding of \\(B\\) must be a subsequence of the run-length encoded \\(A\\). This condition is also sufficient because we can perform operations that extend the subsequence of \\(A\\) corresponding to \\(B\\). This solves the case where \\(K = 1\\).\n\nCase \\(K \\geq 2\\): Looking at the operations in reverse, they can be seen as follows:\n\nChoose \\(i,j\\) that satisfy \\(|i-j| \\leq K\\) and \\(B_i = B_j\\), then change \\(B_i\\) to any desired value. First, if no operation can be performed on \\(B\\), the answer is No. Also, if there is a value in \\(B\\) that does not appear in \\(A\\), the answer is No. Actually, in all other cases, the answer is Yes. Let\u2019s reinterpret the part where \\(B_i\\) can be changed to any desired value as an operation where \\(B_i\\) is changed to a wildcard \\(*\\). By performing one operation on \\(B\\), we create a state where there is exactly one \\(*\\). The involvement of \\(*\\) enables us to swap adjacent elements in \\(B\\).\n\nIf you want to change \\(*x\\) to \\(x*\\): think of \\(*x\\) as \\(xx\\) and perform the operation to turn it into \\(x*\\). If you want to change \\(*xy\\) to \\(*yx\\): follow the steps \\(*xy \\to yxy \\to yx* \\to y*x \\to *yx\\).\n\nBy combining these operations, you can remove all duplicates in \\(B\\) and arrange them in any desired order. In particular, you can arrange \\(B\\) to match \\(A\\). Therefore, it can be determined that \\(A\\) can be transformed into \\(B\\). Implementing the above operations directly yields an \\(O(N)\\) solution. The sample code below lazily uses sorting and is an \\(O(N\\log N)\\) solution.\n```\n \n\n", "problem_ids": ["arc183_b"]}, "abc342_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nScore: 500 points\n\n### Problem Statement\n\nHow many integers \\( x \\) between 1 and \\( N \\), inclusive, can be expressed as \\( x = a^b \\) using some positive integer \\( a \\) and a positive integer \\( b \\) not less than 2?\n\n### Constraints\n\n- All input values are integers.\n- \\( 1 \\le N \\le 10^{18} \\)\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN\n```\n\n### Output\n\nPrint the answer as an integer.\n\n### Sample Input 1\n\n```\n99\n```\n\n### Sample Output 1\n\n```\n12\n```\n\nThe integers that satisfy the conditions in the problem statement are: 1, 4, 8, 9, 16, 25, 27, 32, 36, 49, 64, 81. There are 12 of these.\n\n### Sample Input 2\n\n```\n1000000000000000000\n```\n\n### Sample Output 2\n\n```\n1001003332\n```\n\nSolution:\n\n        [BEGIN TEXT]\n        Denso Create Programming Contest 2024\uff08AtCoder Beginner Contest 361\uff09 Editorial - Problem F: x = a^b\n\nWe introduce a rather brute-force solution. As evident from Sample 2, a total of 1001003332 integers can satisfy the condition. Since \\((10^9)^2 = 10^{18}\\), \\(10^9\\) integers among them can be represented as \\(a^2\\). Therefore, there are only \\(10^6\\) integers that cannot be represented as \\(a^2\\). One can enumerate all of them and then add the number of those represented as \\(a^2\\). This enumeration can be done for \\(b=3,4,\\dots,59\\) and then stopped once \\(a^b > N\\) is satisfied; one can determine if an integer \\(x\\) can be represented as \\(a^2\\) by checking if \\((\\lfloor \\sqrt{x} \\rfloor )^2=x\\).\n\nSample code (Python):\n```python\nimport math\n\ndef safe_pow(a, b):\n    res = 1\n    for _ in range(b):\n        dres = res\n        dres *= a\n        if dres > 2e18:\n            return 2e18\n        res *= a\n    return res\n\ndef sqrt_floor(x):\n    l, r = 0, int(2e9)\n    while l <= r:\n        t = (l + r) // 2\n        if t * t > x:\n            r = t - 1\n        else:\n            l = t + 1\n    return r\n\ndef main():\n    n = int(input().strip())\n    st = set()\n    for b in range(3, 60):\n        a = 2\n        while True:\n            x = safe_pow(a, b)\n            if x > n:\n                break\n            s = sqrt_floor(x)\n            if s * s != x:\n                st.add(x)\n            a += 1\n    res = len(st)\n    res += sqrt_floor(n)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n        [END TEXT]\n \n\n", "problem_ids": ["abc361_f"]}, "abc342_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi can swim in \\( N \\) different styles. When he swims in the \\( i \\)-th style, he consumes \\( A_i \\) stamina per second and advances \\( B_i \\) meters per second. \n\nYou need to answer \\( Q \\) queries. The \\( i \\)-th query is as follows: determine if it is possible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\). If it is possible, find the minimum number of seconds required.\n\nTakahashi can freely combine different swimming styles, and the time to switch styles is negligible. Specifically, he can swim using the following steps:\n- Choose a positive integer \\( m \\), a sequence of positive real numbers \\( t = (t_1, t_2, \\dots, t_m) \\) of length \\( m \\), and a sequence of integers \\( x = (x_1, x_2, \\dots, x_m) \\) of length \\( m \\) where each element is between \\( 1 \\) and \\( N \\), inclusive.\n- Then, swim in the \\( x_i \\)-th style for \\( t_i \\) seconds in the order \\( i = 1, 2, \\dots, m \\).\n\n**Constraints:**\n- All input values are integers.\n- \\( 1 \\leq N \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq A_i, B_i \\leq 10^9 \\)\n- \\( 1 \\leq Q \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq C_i, D_i \\leq 10^9 \\)\n\n**Input:**\nThe input is given from Standard Input in the following format:\n```\nN\nA_1 B_1\nA_2 B_2\n...\nA_N B_N\nQ\nC_1 D_1\nC_2 D_2\n...\nC_Q D_Q\n```\n\n**Output:**\nPrint \\( Q \\) lines in total. For the \\( i \\)-th query, print the answer in the \\( i \\)-th line as follows:\n- If it is impossible to advance \\( D_i \\) meters while keeping the total stamina consumption at most \\( C_i \\), print \\(-1\\).\n- Otherwise, print the minimum required time. The output is considered correct if the absolute or relative error between the printed value and the true answer is at most \\( 10^{-9} \\).\n\n**Sample Input:**\n```\n4\n1 2\n2 3\n3 3\n4 4\n5\n4 7\n7 7\n49 100\n1000 500\n4 5\n```\n\n**Sample Output:**\n```\n3.000000000000000000\n1.750000000000000000\n-1\n125.000000000000000000\n1.500000000000000000\n```\n\nIn this input, Takahashi can swim in the following four styles:\n- Consumes 1 stamina and advances 2 meters per second.\n- Consumes 2 stamina and advances 3 meters per second.\n- Consumes 3 stamina and advances 3 meters per second.\n- Consumes 4 stamina and advances 4 meters per second.\n\nThis input contains five queries:\n- For the first query, \\( C_1 = 4, D_1 = 7 \\). Choose \\( t = (1,2) \\) and \\( x = (2,1) \\). Takahashi swims as follows:\n  - In the first 1 second, he consumes 2 stamina and advances 3 meters.\n  - In the next 2 seconds, he consumes 2 stamina and advances 4 meters.\n  - In total, he consumes 4 stamina and advances 7 meters. The required time is 3 seconds, which is the minimum.\n- For the second query, \\( C_2 = 7, D_2 = 7 \\). Choose \\( t = (7/4) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 7/4 seconds, he consumes 7 stamina and advances 7 meters.\n  - In total, he consumes 7 stamina and advances 7 meters. The required time is 7/4 seconds, which is the minimum.\n- For the third query, \\( C_3 = 49, D_3 = 100 \\). No matter how Takahashi swims, it is not possible to advance 100 meters while keeping the total stamina consumption at most 49.\n- For the fourth query, \\( C_4 = 1000, D_4 = 500 \\). Choose \\( t = (125) \\) and \\( x = (4) \\). Takahashi swims as follows:\n  - In the first 125 seconds, he consumes 500 stamina and advances 500 meters.\n  - In total, he consumes 500 stamina and advances 500 meters. The required time is 125 seconds, which is the minimum.\n- For the fifth query, \\( C_5 = 4, D_5 = 5 \\). Choose \\( t = (1/2,1) \\) and \\( x = (4,2) \\). Takahashi swims as follows:\n  - In the first 1/2 seconds, he consumes 2 stamina and advances 2 meters.\n  - In the next 1 second, he consumes 2 stamina and advances 3 meters.\n  - In total, he consumes 4 stamina and advances 5 meters. The required time is 3/2 seconds, which is the minimum.\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 356\n\nConsider the case where Takahashi can swim using two styles: consume stamina of \\(A_1\\) to advance \\(B_1\\) meters per second or consume stamina of \\(A_2\\) to advance \\(B_2\\) meters per second. He can combine these styles to swim by consuming stamina of \\(tA_1+(1-t)A_2\\) to advance \\(tB_1+(1-t)B_2\\) meters per second. This corresponds to points on the segment connecting \\((B_1,A_1)\\) and \\((B_2,A_2)\\) in the \\(xy\\)-plane.\n\nIf there are \\(N\\) points \\((B_i,A_i)\\), he can swim for any point inside or on the convex hull's boundary, but not outside it. Plotting the styles on the \\(xy\\)-plane assists in this determination. The most time-efficient point has the maximum \\(B_i\\), and the most stamina-efficient point has the minimum \\(A_i/B_i\\). If he can't swim \\(D_i\\) meters using the stamina-efficient point, the answer is -1.\n\nTo swim \\(D_i\\) meters within stamina \\(C_i\\), locate the rightmost point in the intersection of the convex hull's circumference and a line passing through \\((0,0)\\) and \\((D_i,C_i)\\). This represents viable swimming styles under the stamina constraint. He should trace the convex hull from the stamina-efficient point to the time-efficient point counterclockwise. Using binary search helps identify which segment it lies on and then pinpoints \\(P_{opt}\\)'s exact coordinates.\n```\n \n\n", "problem_ids": ["abc356_g"]}, "abc342_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nTakahashi and Aoki played rock-paper-scissors \\(N\\) times. [Note: In this game, Rock beats Scissors, Scissors beats Paper, and Paper beats Rock.]\n\nAoki's moves are represented by a string \\(S\\) of length \\(N\\) consisting of the characters \\(R\\), \\(P\\), and \\(S\\). The \\(i\\)-th character of \\(S\\) indicates Aoki's move in the \\(i\\)-th game: \\(R\\) for Rock, \\(P\\) for Paper, and \\(S\\) for Scissors.\n\nTakahashi's moves satisfy the following conditions:\n1. Takahashi never lost to Aoki.\n2. For \\(i = 1, 2, \\ldots, N-1\\), Takahashi's move in the \\(i\\)-th game is different from his move in the \\((i+1)\\)-th game.\n\nDetermine the maximum number of games Takahashi could have won.\n\nIt is guaranteed that there exists a sequence of moves for Takahashi that satisfies these conditions.\n\n**Constraints**\n- \\(1 \\leq N \\leq 2 \\times 10^5\\)\n- \\(S\\) is a string of length \\(N\\) consisting of \\(R\\), \\(P\\), and \\(S\\).\n- \\(N\\) is an integer.\n\n**Input**\nThe input is given from Standard Input in the following format:\n```\nN\nS\n```\n\n**Output**\nPrint the maximum number of games Takahashi could have won.\n\n**Sample Input 1**\n```\n6\nPRSSRS\n```\n\n**Sample Output 1**\n```\n5\n```\n\n*Explanation:* In the six games of rock-paper-scissors, Aoki played Paper, Rock, Scissors, Scissors, Rock, and Scissors. Takahashi can play Scissors, Paper, Rock, Scissors, Paper, and Rock to win the 1st, 2nd, 3rd, 5th, and 6th games. There is no sequence of moves for Takahashi that satisfies the conditions and wins all six games, so print 5.\n\n**Sample Input 2**\n```\n10\nSSSSSSSSSS\n```\n\n**Sample Output 2**\n```\n5\n```\n\n**Sample Input 3**\n```\n24\nSPRPSRRRRRPPRPRPSSRSPRSS\n```\n\n**Sample Output 3**\n```\n18\n```\n\nSolution:\n\n        Here is the trimmed content containing only the solution to the coding problem:\n\n---\n\nDefine \\(\\operatorname{dp} _ i[H]\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) by:\n\n\\(\\operatorname{dp} _ i[H]\\coloneqq\\) the maximum number of Takahashi\u2019s wins during conforming first \\(i\\) hands of Takahashi such that his \\(i\\)-th hand is \\(H\\).\n\nHere, we define \\(\\operatorname{dp} _ 0[H]=0\\) for convenience. (DP stands for Dynamic Programming.)\n\nTakahashi\u2019s \\(i\\)-th move is solely dependent on Aoki\u2019s \\(i\\)-th hand and Takahashi\u2019s \\(i\\)-th hand. Therefore, \\(\\operatorname{dp} _ i[H]\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) can be found based on \\(\\operatorname{dp} _ {i-1}\\ (H\\in\\lbrace\\)R, P, S\\(\\rbrace)\\) (and the value \\(S _ i\\)). Specifically, let \\(\\operatorname{rps}(a,b)\\) be \\(1\\) if \\(a\\) wins \\(b\\), \\(-1\\) if it loses, and \\(0\\) if they are draw (here rps stands for rock-scissors-paper), then\n\n\\[\\operatorname{dp} _ i[H]=\\begin{cases}\\displaystyle\\max _ {H^\\prime\\neq H}\\operatorname{dp} _ {i-1}[H^\\prime]&\\ &(\\operatorname{janken}(H,S _ i)=0)\\\\1+\\displaystyle\\max _ {H^\\prime\\neq H}\\operatorname{dp} _ {i-1}[H^\\prime]&&(\\operatorname{janken}(H,S _ i)=1)\\\\0&&(\\operatorname{janken}(H,S _ i)=-1).\\end{cases}\\]\n\nWhile we may set \\(-\\infty\\) to the value of the DP table when losing, one can prove that setting \\(0\\) still yields a correct value.\n\nThe following is sample code.\n\n```python\ndef main():\n    N = int(input().strip())\n    S = input().strip()\n\n    dp = [0, 0, 0]\n    rock, scissors, paper = dp\n\n    for c in S:\n        dp = [max(scissors, paper), max(rock, paper), max(rock, scissors)]\n\n        if c == 'R':\n            scissors = 0\n            paper += 1\n        elif c == 'S':\n            paper = 0\n            rock += 1\n        elif c == 'P':\n            rock = 0\n            scissors += 1\n\n    print(max(dp))\n\nmain()\n```\n \n\n", "problem_ids": ["abc365_d"]}, "abc343_a": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nBelow is the cleaned version of the problem statement:\n\n---\n\nThere is a graph with \\(N + Q\\) vertices, numbered \\(1, 2, \\ldots, N + Q\\). Initially, the graph has no edges.\n\nFor this graph, perform the following operation for \\(i = 1, 2, \\ldots, Q\\) in order:\n\n- For each integer \\(j\\) satisfying \\(L_i \\leq j \\leq R_i\\), add an undirected edge with cost \\(C_i\\) between vertices \\(N + i\\) and \\(j\\).\n\nDetermine if the graph is connected after all operations are completed. If it is connected, find the cost of a minimum spanning tree of the graph.\n\nA minimum spanning tree is a spanning tree with the smallest possible cost, and the cost of a spanning tree is the sum of the costs of the edges used in the spanning tree.\n\n### Constraints\n\n- \\(1 \\leq N, Q \\leq 2 \\times 10^5\\)\n- \\(1 \\leq L_i \\leq R_i \\leq N\\)\n- \\(1 \\leq C_i \\leq 10^9\\)\n- All input values are integers.\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n```\nN Q\nL_1 R_1 C_1\nL_2 R_2 C_2\n...\nL_Q R_Q C_Q\n```\n\n### Output\n\nIf the graph is connected, print the cost of a minimum spanning tree. Otherwise, print \\(-1\\).\n\n### Sample Input 1\n\n```\n4 3\n1 2 2\n1 3 4\n2 4 5\n```\n\n### Sample Output 1\n\n```\n22\n```\n\nThe following edges form a minimum spanning tree:\n\n- An edge with cost 2 connecting vertices 1 and 5\n- An edge with cost 2 connecting vertices 2 and 5\n- An edge with cost 4 connecting vertices 1 and 6\n- An edge with cost 4 connecting vertices 3 and 6\n- An edge with cost 5 connecting vertices 3 and 7\n- An edge with cost 5 connecting vertices 4 and 7\n\nSince \\(2 + 2 + 4 + 4 + 5 + 5 = 22\\), print 22.\n\n### Sample Input 2\n\n```\n6 2\n1 2 10\n4 6 10\n```\n\n### Sample Output 2\n\n```\n-1\n```\n\nThe graph is disconnected.\n\n### Sample Input 3\n\n```\n200000 4\n1 200000 1000000000\n1 200000 998244353\n1 200000 999999999\n1 200000 999999999\n```\n\n### Sample Output 3\n\n```\n199651870599998\n```\n\n---\n\nSolution:\n\n        [BEGIN TEXT]\n        Since the graph in this problem may have up to \\(NQ\\) edges, one cannot directly apply an algorithm that determines the minimum spanning tree of a general graph. We will try to exploit the special form of the graph to optimize Kruskal\u2019s algorithm against it. We first sort the edges by their costs and appropriately reassign indices so that \\(C_1 \\leq C_2 \\leq \\ldots \\leq C_Q\\). According to Kruskal\u2019s algorithm, one can determine the minimum spanning tree as follows:\n\nPrepare an \\((N + Q)\\)-vertex graph without an edge. For \\(i = 1, 2, \\ldots ,Q\\) in order:\n\nFor each \\(j = L_i, L_i + 1, \\ldots, R_i\\) in order, add an edge between vertices \\((N + i)\\) and \\(j\\) of cost \\(C_i\\) if and only if vertices \\((N + i)\\) and \\(j\\) are not connected.\n\nWhile it is still difficult to handle the conditions, one can notice that vertices \\((N + i)\\) and \\(j\\) are always disconnected if \\(j =L_i\\), and that vertices \\((N + i)\\) and \\((j - 1)\\) are connected if and only if vertices \\((j - 1)\\) and \\(j\\) are, in order to realize that it is sufficient to perform connectivity check for vertices with adjacent indices: \\(j - 1\\) and \\(j\\). Also, the graph is disconnected if and only if there exists an integer \\(j\\) between \\(1\\) and \\((N-1)\\) (inclusive) such that vertices \\((j - 1)\\) and \\(j\\) are disconnected. Naively implementing this still costs \\(\\Theta(NQ + Q\\log Q)\\), but now that the problem is simplified, there are various approaches.\n\n(1) Use a set (or similar data structure) Manage the set of \\(1 \\leq j < N\\) such that vertices \\((j - 1)\\) and \\(j\\) are disconnected in a data structure like the built-in set in Python, and remove those among \\(L_i, L_i + 1, \\ldots, R_i - 1\\) that is not in the set. Naively checking the existence for each element still leads to TLE, but one can use a method such as bisect.bisect_left that retrieves the position of the minimum element greater than or equal to \\(x\\), as removal of an element occurs at most \\((N - 1)\\) times and the complexity is bounded by \\(O((N + Q) \\log N)\\), which is fast enough.\n\n(2) Use a lazy segment tree One can also use a lazy segment tree that supports segment-sum retrieval and segment-filling with \\(0\\). The \\(j\\)-th element of the lazy segment tree should be \\(0\\) if vertices \\(j\\) and \\((j+1)\\) are connected, and \\(1\\) otherwise. Initialize such a segment tree of length \\((N-1)\\) all with \\(1\\); then the number of edges connecting vertex \\(N + i\\) and any of vertices \\(L_i + 1, L_i + 2, \\ldots, R_i\\) can be retrieved as the segment sum of \\([L_i, R_i)\\), and adding an edge is fulfilled by filling \\([L_i, R_i)\\) with \\(0\\).\n\n(3) Use bitwise operations While a naive scan-based algorithm on an array results in TLE (Time Limit Exceeded), one can make use of bitwise operations with almost the same idea. The answer can be found fast enough by managing connectivity for each \\((j, j+1)\\) using the built-in int type in Python and using a function that returns the next position of \\(1\\) in the same way as found in (1), the answer can be found fast enough.\n        [END TEXT]\n \n\n", "problem_ids": ["abc364_f"]}, "abc343_b": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given a sequence \\(P = (P_1, P_2, \\dots, P_N)\\) of length \\(N\\). Takahashi and Aoki will play a game using the sequence \\(P\\).\n\nFirst, Takahashi will choose \\(K\\) distinct integers \\(x_1, x_2, \\dots, x_K\\) from \\(1, 2, \\dots, N\\).\n\nNext, Aoki will choose an integer \\(y\\) from \\(1, 2, \\dots, N\\) with a probability proportional to \\(P_y\\). That is, the probability that integer \\(y\\) is chosen is \\(\\dfrac{P_y}{\\sum_{y'=1}^N P_{y'}}\\). Then, Aoki's score will be \\(\\displaystyle \\min_{i=1,2,\\dots,K} |x_i - y|\\).\n\nTakahashi wants to minimize the expected value of Aoki's score. Find the expected value of Aoki's score when Takahashi chooses \\(x_1, x_2, \\dots, x_K\\) so that this value is minimized, then multiply by \\(\\sum_{y'=1}^N P_{y'}\\). It is guaranteed that the result is an integer.\n\n### Constraints\n- \\(1 \\leq N \\leq 5 \\times 10^4\\)\n- \\(1 \\leq K \\leq N\\)\n- \\(0 \\leq P_i \\leq 10^5\\)\n- \\(1 \\leq \\sum_{y'=1}^N P_{y'} \\leq 10^5\\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN K\nP_1 P_2 \\dots P_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n5 2\n1 1 1 1 1\n```\n\n### Sample Output 1\n```\n3\n```\n\nThe probabilities of Aoki choosing \\(1, 2, \\dots, N\\) are all equal: \\(\\frac{1}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 4\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} = \\frac{3}{5}\\).\n\nIf Takahashi chooses \\(x_1 = 2\\) and \\(x_2 = 3\\), then the expected value of Aoki's score will be \\(1 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 0 \\times \\frac{1}{5} + 1 \\times \\frac{1}{5} + 2 \\times \\frac{1}{5} = \\frac{4}{5}\\).\n\nNo matter how Takahashi chooses, the expected value of Aoki's score cannot be smaller than \\(\\frac{3}{5}\\). Therefore, the minimum value is \\(\\frac{3}{5}\\), so print this value multiplied by \\(5\\), which is \\(3\\).\n\n### Sample Input 2\n```\n5 1\n0 0 1 0 0\n```\n\n### Sample Output 2\n```\n0\n```\n\n### Sample Input 3\n```\n1 1\n100\n```\n\n### Sample Output 3\n```\n0\n```\n\n### Sample Input 4\n```\n20 7\n4262 9522 2426 3823 7364 964 2743 2423 1955 5274 3684 847 363 35 278 3220 203 2904 6304 1928\n```\n\n### Sample Output 4\n```\n22809\n```\n\nSolution:\n\n```\nHere is the cleaned version of the editorial text:\n\n---\n\n**G - Baseball Editorial**\n\n*Let \\(S\\coloneqq \\sum_{i=1}^N P_{i}\\).*\n\nGraph representation and formalization into DP (Dynamic Programming) are essential to solve the problem. The steps involve creating a graph with \\(N+2\\) vertices and directing edges with specified weights:\n\n- Edge \\((0,j)\\,(1 \\leq j \\leq N)\\) with weight \\(\\sum_{y=1}^{j-1} P_y \\times (j-y)\\).\n- Edge \\((i,j)\\,(1 \\leq i < j \\leq N)\\) with weight \\(\\sum_{y=i}^{j-1} P_y \\times \\min(y-i,j-y)\\).\n- Edge \\((i,N+1)\\,(1 \\leq i \\leq N)\\) with weight \\(\\sum_{y=i}^N P_y \\times (y-i)\\).\n\nThe objective is to minimize the expected score by finding the shortest path from vertex \\(0\\) to vertex \\(N+1\\) using exactly \\(K+1\\) edges with dynamic programming. Define \\(\\mathrm{dp}[k][j]\\) as the weight of the shortest path from vertex \\(0\\) to vertex \\(j\\) using \\(k\\) edges. The transition is:\n\n\\[\n\\mathrm{dp}[k][j] = \\min_{i<j} \\{\\mathrm{dp}[k-1][i] + c(i,j)\\}\n\\]\n\nThe transition cost function \\(c(i,j)\\) must be calculated beforehand. Optimizing this process through Alien DP, given the Monge property \\(c(i,l)+c(j,k) \\geq c(i,k) + c(j,l)\\), leads to a faster solution. Various methods such as divide-and-conquer, monotone minima, and convex hull trick are used to find the solution effectively.\n\nUltimately, the problem can be approached by:\n\n- Precomputing necessary sums for costs.\n- Leveraging Monge properties to run efficient dynamic programming.\n- Applying optimizations like divide-and-conquer, SMAWK, and convex hull trick for complexity reduction.\n\nThe primary goal of these methods is to manage the operations within a computational time limit for successful execution.\n```\n \n\n", "problem_ids": ["abc355_g"]}, "abc343_c": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement:**\n\nThere is an \\( N \\times N \\) grid, where the cell at the \\( i \\)-th row from the top and the \\( j \\)-th column from the left contains the integer \\( N \\times (i-1) + j \\).\n\nOver \\( T \\) turns, integers will be announced. On Turn \\( i \\), the integer \\( A_i \\) is announced, and the cell containing \\( A_i \\) is marked. Determine the turn on which Bingo is achieved for the first time. If Bingo is not achieved within \\( T \\) turns, print \\(-1\\).\n\nHere, achieving Bingo means satisfying at least one of the following conditions:\n- There exists a row in which all \\( N \\) cells are marked.\n- There exists a column in which all \\( N \\) cells are marked.\n- There exists a diagonal line (from top-left to bottom-right or from top-right to bottom-left) in which all \\( N \\) cells are marked.\n\n**Constraints:**\n- \\( 2 \\leq N \\leq 2000 \\)\n- \\( 1 \\leq T \\leq \\min(N^2, 200000) \\)\n- \\( 1 \\leq A_i \\leq N^2 \\)\n- \\( A_i \\neq A_j \\) if \\( i \\neq j \\).\n- All input values are integers.\n\n**Input:**\n\nThe input is given from Standard Input in the following format:\n```\nN T\nA_1 A_2 \\ldots A_T\n```\n\n**Output:**\n\nIf Bingo is achieved within \\( T \\) turns, print the turn number on which Bingo is achieved for the first time; otherwise, print \\(-1\\).\n\n**Sample Input 1:**\n\n```\n3 5\n5 1 8 9 7\n```\n\n**Sample Output 1:**\n\n```\n4\n```\n\n*Explanation:*\n\nThe state of the grid changes as follows. Bingo is achieved for the first time on Turn 4.\n\n**Sample Input 2:**\n\n```\n3 5\n4 2 9 7 5\n```\n\n**Sample Output 2:**\n\n```\n-1\n```\n\n*Explanation:*\n\nBingo is not achieved within five turns, so print -1.\n\n**Sample Input 3:**\n\n```\n4 12\n13 9 6 5 2 7 16 14 8 3 10 11\n```\n\n**Sample Output 3:**\n\n```\n9\n```\n\nSolution:\n\n```\nEditorial - AtCoder Beginner Contest 355: C - Bingo 2\n\nFor each row, column, or (anti)diagonal line, count the number of marked squares. Update only the counts for lines containing the current square. Check these lines to see if Bingo is achieved. With at most four lines per square, this is done in \\(O(1)\\) time. The overall time complexity is \\(O(N+T)\\).\n\nSample code:\n\n```python\nN, T = map(int, input().split())\nA = list(map(lambda x: int(x) - 1, input().split()))\nrow = [0] * N\ncol = [0] * N\ndiag = [0] * 2\n\nfor i in range(T):\n    x = A[i] // N\n    y = A[i] % N\n\n    # row\n    row[x] += 1\n    if row[x] == N:\n        print(i + 1)\n        exit()\n\n    # column\n    col[y] += 1\n    if col[y] == N:\n        print(i + 1)\n        exit()\n\n    # diagonal\n    if x == y:\n        diag[0] += 1\n        if diag[0] == N:\n            print(i + 1)\n            exit()\n\n    # anti-diagonal\n    if x + y == N - 1:\n        diag[1] += 1\n        if diag[1] == N:\n            print(i + 1)\n            exit()\n\nprint(-1)\n```\n```\n \n\n", "problem_ids": ["abc355_c"]}, "abc343_d": {"text": "Similar Problem 1 \n\n Problem Statement:\n\n**Problem Statement**\n\nIn Japan, there are six types of coins in circulation: 1 yen, 5 yen, 10 yen, 50 yen, 100 yen, and 500 yen. Answer the following question regarding these coins.\n\nMr. AtCoder's wallet contains:\n- \\( A \\) 1-yen coins,\n- \\( B \\) 5-yen coins,\n- \\( C \\) 10-yen coins,\n- \\( D \\) 50-yen coins,\n- \\( E \\) 100-yen coins,\n- \\( F \\) 500-yen coins.\n\nHe plans to shop at \\( N \\) stores in sequence. Specifically, at the \\( i \\)-th store (\\( 1 \\leq i \\leq N \\)), he plans to buy one item that costs \\( X_i \\) yen (including tax).\n\nGiving and receiving change takes time, so he wants to choose his coins so that he can pay the **exact amount** at each store. Determine if this is possible.\n\n**Constraints**\n- \\( 0 \\leq A \\leq 200 \\)\n- \\( 0 \\leq B \\leq 200 \\)\n- \\( 0 \\leq C \\leq 200 \\)\n- \\( 0 \\leq D \\leq 200 \\)\n- \\( 0 \\leq E \\leq 200 \\)\n- \\( 0 \\leq F \\leq 200 \\)\n- \\( 1 \\leq N \\leq 10 \\)\n- \\( 1 \\leq X_i \\leq 10000 \\) (for each \\( i \\))\n- All input values are integers.\n\n**Input**\n\nThe input is given from Standard Input in the following format:\n```\nA B C D E F\nN\nX_1 X_2 ... X_N\n```\n\n**Output**\n\nPrint `Yes` if the objective is achievable, and `No` otherwise.\n\n**Sample Input 1**\n```\n0 0 6 3 4 1\n3\n700 250 160\n```\n\n**Sample Output 1**\n```\nYes\n```\n\n*For example, he can make exact payments at all three stores as follows:*\n- At the first store: Use two 100-yen coins and one 500-yen coin.\n- At the second store: Use five 10-yen coins and two 100-yen coins.\n- At the third store: Use one 10-yen coin and three 50-yen coins.\n\n**Sample Input 2**\n```\n0 0 0 2 4 0\n3\n100 200 300\n```\n\n**Sample Output 2**\n```\nNo\n```\n\n*The total amount in the wallet is 500 yen, but a total payment of 100+200+300=600 yen is required, making it impossible to purchase all the items.*\n\n**Sample Input 3**\n```\n0 0 0 0 8 8\n1\n250\n```\n\n**Sample Output 3**\n```\nNo\n```\n\n*There are no 50-yen or smaller coins in the wallet, so it's impossible to pay exactly 250 yen.*\n\n**Sample Input 4**\n```\n20 5 9 7 10 6\n5\n177 177 177 177 177\n```\n\n**Sample Output 4**\n```\nYes\n```\n\n**Sample Input 5**\n```\n17 5 9 7 10 6\n5\n177 177 177 177 177\n```\n\n**Sample Output 5**\n```\nNo\n```\n\n\nSolution:\n\n\n        Here's the cleaned version focused on the solution:\n\n---\n\nMr. AtCoder has \\(A\\) 1-yen coins and \\(C\\) 10-yen coins, and must shop at \\(N\\) stores, spending \\(X_1, \\dots, X_N\\) yen. The goal is to determine if it is possible to pay the exact amount at each store.\n\nWhen possible, use 10-yen coins first to conserve 1-yen coins. There's no benefit in saving higher-value coins when purchasing with lower-value coins.\n\nThe same strategy applies when dealing with all coin types: \\(1\\), \\(5\\), \\(10\\), \\(50\\), \\(100\\), and \\(500\\)-yen coins. Pay with higher denominations first, until the amount left can be paid with the smaller denominations available, simulating if exact payment is possible at all stores.\n\nSample Python Implementation:\n\n```python\na, b, c, d, e, f = map(int, input().split())\nn = int(input())\nx = list(map(int, input().split()))\n\nans = True\nfor v in x:\n    while v >= 500 and f >= 1:\n        v -= 500\n        f -= 1\n    while v >= 100 and e >= 1:\n        v -= 100\n        e -= 1\n    while v >= 50 and d >= 1:\n        v -= 50\n        d -= 1\n    while v >= 10 and c >= 1:\n        v -= 10\n        c -= 1\n    while v >= 5 and b >= 1:\n        v -= 5\n        b -= 1\n    while v >= 1 and a >= 1:\n        v -= 1\n        a -= 1\n    if v != 0:\n        ans = False\n        break\n\nprint('Yes' if ans else 'No')\n```\n\n---\n \n\n", "problem_ids": ["arc177_a"]}, "abc343_e": {"text": "Similar Problem 1 \n\n Problem Statement:\n\nYou are given positive integers \\( N \\), \\( M \\), \\( K \\), and a sequence of non-negative integers: \\( A = (A_1,A_2,\\ldots,A_N) \\).\n\nFor a non-empty non-negative integer sequence \\( B = (B_1,B_2,\\ldots,B_{|B|}) \\), we define its **score** as follows:\n- If the length of \\( B \\) is a multiple of \\( M \\): \\( (B_1 \\oplus B_2 \\oplus \\dots \\oplus B_{|B|})^K \\)\n- Otherwise: \\( 0 \\)\n\nHere, \\( \\oplus \\) represents the bitwise XOR.\n\nFind the sum, modulo \\( 998244353 \\), of the scores of the \\( 2^N-1 \\) non-empty subsequences of \\( A \\).\n\n### Constraints\n- \\( 1 \\leq N, K \\leq 2 \\times 10^5 \\)\n- \\( 1 \\leq M \\leq 100 \\)\n- \\( 0 \\leq A_i < 2^{20} \\)\n- All input values are integers.\n\n### Input\nThe input is given from Standard Input in the following format:\n```\nN M K\nA_1 A_2 \\ldots A_N\n```\n\n### Output\nPrint the answer.\n\n### Sample Input 1\n```\n3 2 2\n1 2 3\n```\n\n### Sample Output 1\n```\n14\n```\n\nHere are the scores of the \\( 2^3-1=7 \\) non-empty subsequences of \\( A \\).\n- \\( (1) \\): \\( 0 \\)\n- \\( (2) \\): \\( 0 \\)\n- \\( (3) \\): \\( 0 \\)\n- \\( (1,2) \\): \\( (1 \\oplus 2)^2 = 9 \\)\n- \\( (1,3) \\): \\( (1 \\oplus 3)^2 = 4 \\)\n- \\( (2,3) \\): \\( (2 \\oplus 3)^2 = 1 \\)\n- \\( (1,2,3) \\): \\( 0 \\)\n\nTherefore, the sought sum is \\( 0 + 0 + 0 + 9 + 4 + 1 + 0 = 14 \\).\n\n### Sample Input 2\n```\n10 5 3\n100 100 100 100 100 100 100 100 100 100\n```\n\n### Sample Output 2\n```\n252000000\n```\n\n### Sample Input 3\n```\n16 4 100\n7053 3876 3178 8422 7802 5998 2334 6757 6889 6637 7365 9495 7848 9026 7312 6558\n```\n\n### Sample Output 3\n```\n432440016\n```\n\n\nSolution:\n\nThe problem requires knowledge of XOR convolution and Hadamard transform. Define \\(C_i\\) as the number of subsequences of \\(A\\) with length as a multiple of \\(M\\) and total XOR equals \\(i\\). We need to find \\(C_0, C_1, \\ldots, C_{2^L-1}\\) such that \\(\\sum_{i=0}^{2^L-1} C_i \\cdot i^K\\) is calculated, where \\(L=20\\).\n\nDefine sequences \\(v_i\\) such that each sequence term is a polynomial, with the 0-th term being 1, the \\(A_i\\)-th term as \\(x\\), and others 0. If \\(A_i=0\\), the 0-th term is \\(1+x\\). For two sequences \\(a, b\\), define the XOR convolution as \\((a \\ast b)_k = \\sum_{i \\oplus j = k} a_i \\times b_j\\). \n\nCompute the XOR convolution \\(V = v_1 \\ast v_2 \\ast \\cdots \\ast v_N\\). The coefficient of \\(x^j\\) of the \\(i\\)-th term (\\([x^j]V_i\\)) equals the number of length-\\(j\\) subsequences of \\(A\\) with a total XOR of \\(i\\), resulting in \\(C_i = [x^0]V_i + [x^M]V_i + \\cdots = [x^0]V_i \\, (\\text{mod } 1-x^M)\\).\n\nUtilize Hadamard conversion \\(H\\), where \\(H(a \\ast b)_i = H(a)_i \\times H(b)_i\\). Therefore, \\(H(V)_i = H(v_1)_i \\times \\cdots \\times H(v_N)_i\\). Compute \\(H(V)\\) using Hadamard conversion on sequences \\(v_1, v_2, \\ldots\\).\n\nGiven sequences that have 1 at the 0-th term and \\(x\\) at the \\(A_i\\)-th term, \\(H(v_i)\\) becomes \\((1+x)\\) or \\((1-x)\\). Thus, \\(H(V)_i\\) can be represented as \\((1+x)^{B_i}(1-x)^{N-B_i}\\). Calculate \\(B_i\\) efficiently using a combination of Hadamard conversion and population count divide-and-conquer strategy, allowing \\(O(L2^L)\\) calculation time. Alternatively, use \\(B_i = \\frac{H(\\text{cnt})_i + N}{2}\\).\n\nFind \\([x^0](1+x)^{B_i}(1-x)^{N-B_i} \\, (\\text{mod } 1-x^M)\\) in \\(O(NM)\\) using precalculated sequences for \\((1+x)^n\\) and \\((1-x)^n \\, (\\text{mod } 1-x^M)\\). Thus, the overall problem can be solved in \\(O(NM + 2^L (L + \\log K))\\) time.\n\nHere's the implementation:\n\n```python\nmod = 998244353\n\ndef hadamard(a, m):\n    for k in range(m):\n        i = 1 << k\n        for j in range(1 << m):\n            if not i & j:\n                a[j], a[i | j] = (a[j] + a[i | j]), (a[j] - a[i | j])\n\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nL = 20\ncnt = [0] * (1 << L)\nfor i in range(N):\n    cnt[A[i]] += 1\n\nF = [[0] * M for i in range(N + 1)]\nG = [[0] * M for i in range(N + 1)]\n\nF[0][0], G[0][0] = 1, 1\n\nfor i in range(N):\n    for j in range(M):\n        F[i + 1][j] = (F[i][j] + F[i][j - 1]) % mod\n        G[i + 1][j] = (G[i][j] - G[i][j - 1]) % mod\n\nres = [0] * (N + 1)\nfor i in range(N + 1):\n    for j in range(M):\n        res[i] += F[i][j] * G[N - i][-j]\n        res[i] %= mod\n\nhadamard(cnt, L)\nB = [(cnt[i] + N) // 2 for i in range(1 << L)]\nC = [res[B[i]] for i in range(1 << L)]\nhadamard(C, L)\n\ninv = pow(1 << L, mod - 2, mod)\nans = 0\nfor i in range(1 << L):\n    C[i] = C[i] % mod * inv % mod\n    ans += C[i] * pow(i, K, mod)\n    ans %= mod\n\nprint(ans)\n```\n\nCalculate \\(B\\) using divide-and-conquer:\n\n```python\ndef calc(off, k):\n    if k == 0:\n        return ([cnt[off]], cnt[off])\n    H0, c0 = calc(off, k - 1)\n    H1, c1 = calc(off | (1 << (k - 1)), k - 1)\n    H = [0] * (1 << k)\n    for i in range(1 << (k - 1)):\n        H[i] = H0[i] + H1[i]\n        H[i | (1 << (k - 1))] = H0[i] + c1 - H1[i]\n    return (H, c0 + c1)\n\nB = calc(0, L)[0]\n```\n \n\n", "problem_ids": ["abc367_g"]}}